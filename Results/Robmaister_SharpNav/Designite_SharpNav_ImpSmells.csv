Implementation smell,Namespace,Class,File,Method,Description
Long Method,SharpNav,Contour,C:\repos\Robmaister_SharpNav\Source\SharpNav\Contour.cs,Simplify,The method has 182 lines of code.
Long Method,SharpNav,PolyMesh,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyMesh.cs,PolyMesh,The method has 166 lines of code.
Long Method,SharpNav,PolyMesh,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyMesh.cs,Triangulate,The method has 103 lines of code.
Long Method,SharpNav,PolyMesh,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyMesh.cs,RemoveVertex,The method has 163 lines of code.
Long Method,SharpNav,NavMeshBuilder,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshBuilder.cs,NavMeshBuilder,The method has 300 lines of code.
Long Method,SharpNav,PolyMeshDetail,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyMeshDetail.cs,PolyMeshDetail,The method has 102 lines of code.
Long Method,SharpNav,PolyMeshDetail,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyMeshDetail.cs,GetHeightDataSeedsFromVertices,The method has 106 lines of code.
Long Method,SharpNav,PolyMeshDetail,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyMeshDetail.cs,BuildPolyDetail,The method has 206 lines of code.
Long Method,SharpNav,NavMeshQuery,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshQuery.cs,FindRandomPointAroundCircle,The method has 115 lines of code.
Long Method,SharpNav,NavMeshQuery,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshQuery.cs,FindPath,The method has 147 lines of code.
Long Method,SharpNav,NavMeshQuery,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshQuery.cs,FindStraightPath,The method has 160 lines of code.
Long Method,SharpNav,NavMeshQuery,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshQuery.cs,MoveAlongSurface,The method has 143 lines of code.
Long Method,SharpNav,NavMeshQuery,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshQuery.cs,UpdateSlicedFindPath,The method has 168 lines of code.
Long Method,SharpNav,NavMeshQuery,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshQuery.cs,Raycast,The method has 151 lines of code.
Long Method,SharpNav,NavMeshQuery,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshQuery.cs,FindLocalNeighborhood,The method has 122 lines of code.
Long Method,SharpNav,CompactHeightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\CompactHeightfield.cs,FilterSmallRegions,The method has 188 lines of code.
Long Method,SharpNav,CompactHeightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\CompactHeightfield.cs,CalculateDistanceField,The method has 137 lines of code.
Long Method,SharpNav,CompactHeightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\CompactHeightfield.cs,ExpandRegions,The method has 114 lines of code.
Long Method,SharpNav,CompactHeightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\CompactHeightfield.cs,BuildContourSet,The method has 124 lines of code.
Long Method,SharpNav.Crowds,Crowd,C:\repos\Robmaister_SharpNav\Source\SharpNav\Crowds\Crowd.cs,Update,The method has 293 lines of code.
Long Method,SharpNav.Crowds,Crowd,C:\repos\Robmaister_SharpNav\Source\SharpNav\Crowds\Crowd.cs,UpdateMoveRequest,The method has 173 lines of code.
Complex Method,SharpNav,Contour,C:\repos\Robmaister_SharpNav\Source\SharpNav\Contour.cs,Simplify,Cyclomatic complexity of the method is 26
Complex Method,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTrianglesIndexedWithAreas,Cyclomatic complexity of the method is 8
Complex Method,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTrianglesIndexedWithAreas,Cyclomatic complexity of the method is 8
Complex Method,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTrianglesWithAreas,Cyclomatic complexity of the method is 8
Complex Method,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTrianglesWithAreas,Cyclomatic complexity of the method is 8
Complex Method,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTriangle,Cyclomatic complexity of the method is 15
Complex Method,SharpNav,PolyMesh,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyMesh.cs,PolyMesh,Cyclomatic complexity of the method is 26
Complex Method,SharpNav,PolyMesh,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyMesh.cs,Triangulate,Cyclomatic complexity of the method is 16
Complex Method,SharpNav,PolyMesh,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyMesh.cs,GetPolyMergeValue,Cyclomatic complexity of the method is 10
Complex Method,SharpNav,PolyMesh,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyMesh.cs,CanRemoveVertex,Cyclomatic complexity of the method is 16
Complex Method,SharpNav,PolyMesh,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyMesh.cs,BuildMeshAdjacency,Cyclomatic complexity of the method is 14
Complex Method,SharpNav,PolyMesh,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyMesh.cs,RemoveVertex,Cyclomatic complexity of the method is 31
Complex Method,SharpNav,NavMeshBuilder,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshBuilder.cs,NavMeshBuilder,Cyclomatic complexity of the method is 37
Complex Method,SharpNav,PolyMeshDetail,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyMeshDetail.cs,PolyMeshDetail,Cyclomatic complexity of the method is 12
Complex Method,SharpNav,PolyMeshDetail,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyMeshDetail.cs,GetHeightData,Cyclomatic complexity of the method is 19
Complex Method,SharpNav,PolyMeshDetail,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyMeshDetail.cs,GetHeightDataSeedsFromVertices,Cyclomatic complexity of the method is 16
Complex Method,SharpNav,PolyMeshDetail,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyMeshDetail.cs,BuildPolyDetail,Cyclomatic complexity of the method is 31
Complex Method,SharpNav,PolyMeshDetail,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyMeshDetail.cs,DelaunayHull,Cyclomatic complexity of the method is 13
Complex Method,SharpNav,PolyMeshDetail,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyMeshDetail.cs,CompleteFacet,Cyclomatic complexity of the method is 10
Complex Method,SharpNav,NavMeshQuery,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshQuery.cs,FindRandomPoint,Cyclomatic complexity of the method is 11
Complex Method,SharpNav,NavMeshQuery,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshQuery.cs,FindRandomPointAroundCircle,Cyclomatic complexity of the method is 20
Complex Method,SharpNav,NavMeshQuery,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshQuery.cs,FindPath,Cyclomatic complexity of the method is 17
Complex Method,SharpNav,NavMeshQuery,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshQuery.cs,FindStraightPath,Cyclomatic complexity of the method is 17
Complex Method,SharpNav,NavMeshQuery,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshQuery.cs,MoveAlongSurface,Cyclomatic complexity of the method is 18
Complex Method,SharpNav,NavMeshQuery,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshQuery.cs,UpdateSlicedFindPath,Cyclomatic complexity of the method is 27
Complex Method,SharpNav,NavMeshQuery,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshQuery.cs,Raycast,Cyclomatic complexity of the method is 21
Complex Method,SharpNav,NavMeshQuery,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshQuery.cs,FindLocalNeighborhood,Cyclomatic complexity of the method is 22
Complex Method,SharpNav,NavMeshQuery,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshQuery.cs,GetPolyWallSegments,Cyclomatic complexity of the method is 12
Complex Method,SharpNav,NavMeshQuery,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshQuery.cs,GetPortalPoints,Cyclomatic complexity of the method is 12
Complex Method,SharpNav,NavMeshQuery,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshQuery.cs,ClosestPointOnPoly,Cyclomatic complexity of the method is 15
Complex Method,SharpNav,NavMeshQuery,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshQuery.cs,AppendPortals,Cyclomatic complexity of the method is 9
Complex Method,SharpNav,Region,C:\repos\Robmaister_SharpNav\Source\SharpNav\Region.cs,MergeWithRegion,Cyclomatic complexity of the method is 11
Complex Method,SharpNav,CompactHeightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\CompactHeightfield.cs,CompactHeightfield,Cyclomatic complexity of the method is 13
Complex Method,SharpNav,CompactHeightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\CompactHeightfield.cs,BuildRegions,Cyclomatic complexity of the method is 10
Complex Method,SharpNav,CompactHeightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\CompactHeightfield.cs,FilterSmallRegions,Cyclomatic complexity of the method is 28
Complex Method,SharpNav,CompactHeightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\CompactHeightfield.cs,CalculateDistanceField,Cyclomatic complexity of the method is 29
Complex Method,SharpNav,CompactHeightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\CompactHeightfield.cs,BoxBlur,Cyclomatic complexity of the method is 9
Complex Method,SharpNav,CompactHeightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\CompactHeightfield.cs,ExpandRegions,Cyclomatic complexity of the method is 20
Complex Method,SharpNav,CompactHeightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\CompactHeightfield.cs,FloodRegion,Cyclomatic complexity of the method is 15
Complex Method,SharpNav,CompactHeightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\CompactHeightfield.cs,WalkContour,Cyclomatic complexity of the method is 10
Complex Method,SharpNav,CompactHeightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\CompactHeightfield.cs,SortCellsByLevel,Cyclomatic complexity of the method is 8
Complex Method,SharpNav,CompactHeightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\CompactHeightfield.cs,BuildContourSet,Cyclomatic complexity of the method is 21
Complex Method,SharpNav,CompactHeightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\CompactHeightfield.cs,WalkContour,Cyclomatic complexity of the method is 10
Complex Method,SharpNav,TiledNavMesh,C:\repos\Robmaister_SharpNav\Source\SharpNav\TiledNavMesh.cs,GetOffMeshConnectionPolyEndPoints,Cyclomatic complexity of the method is 9
Complex Method,SharpNav.Collections.Generic,ProximityGrid<T>,C:\repos\Robmaister_SharpNav\Source\SharpNav\Collections\Generic\ProximityGrid.cs,QueryItems,Cyclomatic complexity of the method is 8
Complex Method,SharpNav.Crowds,Crowd,C:\repos\Robmaister_SharpNav\Source\SharpNav\Crowds\Crowd.cs,Update,Cyclomatic complexity of the method is 49
Complex Method,SharpNav.Crowds,Crowd,C:\repos\Robmaister_SharpNav\Source\SharpNav\Crowds\Crowd.cs,UpdateMoveRequest,Cyclomatic complexity of the method is 21
Complex Method,SharpNav.Crowds,Crowd,C:\repos\Robmaister_SharpNav\Source\SharpNav\Crowds\Crowd.cs,UpdateTopologyOptimization,Cyclomatic complexity of the method is 8
Complex Method,SharpNav.Crowds,Crowd,C:\repos\Robmaister_SharpNav\Source\SharpNav\Crowds\Crowd.cs,CheckPathValidity,Cyclomatic complexity of the method is 14
Complex Method,SharpNav.Crowds,ObstacleAvoidanceQuery,C:\repos\Robmaister_SharpNav\Source\SharpNav\Crowds\ObstacleAvoidanceQuery.cs,ProcessSample,Cyclomatic complexity of the method is 11
Complex Method,SharpNav.Crowds,PathCorridor,C:\repos\Robmaister_SharpNav\Source\SharpNav\Crowds\PathCorridor.cs,MergeCorridorStartMoved,Cyclomatic complexity of the method is 10
Complex Method,SharpNav.Crowds,PathCorridor,C:\repos\Robmaister_SharpNav\Source\SharpNav\Crowds\PathCorridor.cs,MergeCorridorStartShortcut,Cyclomatic complexity of the method is 10
Complex Method,SharpNav.Crowds,PathQueue,C:\repos\Robmaister_SharpNav\Source\SharpNav\Crowds\PathQueue.cs,Update,Cyclomatic complexity of the method is 9
Complex Method,SharpNav.Geometry,Triangle3,C:\repos\Robmaister_SharpNav\Source\SharpNav\Geometry\Triangle3.cs,GetBoundingBox,Cyclomatic complexity of the method is 13
Complex Method,SharpNav.Pathfinding,NavTile,C:\repos\Robmaister_SharpNav\Source\SharpNav\Pathfinding\NavTile.cs,ConnectExtLinks,Cyclomatic complexity of the method is 8
Long Parameter List,SharpNav,AreaGenerator,C:\repos\Robmaister_SharpNav\Source\SharpNav\AreaGenerator.cs,From,The method has 5 parameters. Parameters: verts' vertOffset' vertStride' triCount' area
Long Parameter List,SharpNav,AreaGenerator,C:\repos\Robmaister_SharpNav\Source\SharpNav\AreaGenerator.cs,From,The method has 5 parameters. Parameters: verts' floatOffset' floatStride' triCount' area
Long Parameter List,SharpNav,AreaGenerator,C:\repos\Robmaister_SharpNav\Source\SharpNav\AreaGenerator.cs,From,The method has 7 parameters. Parameters: verts' inds' vertOffset' vertStride' indexOffset' triCount' area
Long Parameter List,SharpNav,AreaGenerator,C:\repos\Robmaister_SharpNav\Source\SharpNav\AreaGenerator.cs,From,The method has 7 parameters. Parameters: verts' inds' floatOffset' floatStride' indexOffset' triCount' area
Long Parameter List,SharpNav,Contour,C:\repos\Robmaister_SharpNav\Source\SharpNav\Contour.cs,Simplify,The method has 5 parameters. Parameters: rawVerts' simplified' maxError' maxEdgeLen' buildFlags
Long Parameter List,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTrianglesIndexedWithAreas,The method has 7 parameters. Parameters: verts' inds' vertOffset' vertStride' indexOffset' triCount' areas
Long Parameter List,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTrianglesIndexedWithAreas,The method has 7 parameters. Parameters: verts' inds' floatOffset' floatStride' indexOffset' triCount' areas
Long Parameter List,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTrianglesWithAreas,The method has 5 parameters. Parameters: verts' vertOffset' vertStride' triCount' areas
Long Parameter List,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTrianglesWithAreas,The method has 5 parameters. Parameters: verts' floatOffset' floatStride' triCount' areas
Long Parameter List,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTrianglesIndexed,The method has 6 parameters. Parameters: verts' inds' vertOffset' vertStride' indexOffset' triCount
Long Parameter List,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTrianglesIndexed,The method has 7 parameters. Parameters: verts' inds' vertOffset' vertStride' indexOffset' triCount' area
Long Parameter List,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTrianglesIndexed,The method has 6 parameters. Parameters: verts' inds' floatOffset' floatStride' indexOffset' triCount
Long Parameter List,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTrianglesIndexed,The method has 7 parameters. Parameters: verts' inds' floatOffset' floatStride' indexOffset' triCount' area
Long Parameter List,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTriangles,The method has 5 parameters. Parameters: verts' vertOffset' vertStride' triCount' area
Long Parameter List,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTriangles,The method has 5 parameters. Parameters: verts' floatOffset' floatStride' triCount' area
Long Parameter List,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTriangle,The method has 9 parameters. Parameters: ax' ay' az' bx' by' bz' cx' cy' cz
Long Parameter List,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTriangle,The method has 10 parameters. Parameters: ax' ay' az' bx' by' bz' cx' cy' cz' area
Long Parameter List,SharpNav,PolyMesh,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyMesh.cs,PolyMesh,The method has 5 parameters. Parameters: contSet' cellSize' cellHeight' borderSize' numVertsPerPoly
Long Parameter List,SharpNav,PolyMesh,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyMesh.cs,GetPolyMergeValue,The method has 6 parameters. Parameters: polys' polyA' polyB' verts' edgeA' edgeB
Long Parameter List,SharpNav,PolyMeshDetail,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyMeshDetail.cs,GetHeightData,The method has 6 parameters. Parameters: compactField' poly' polyCount' verts' borderSize' hp
Long Parameter List,SharpNav,PolyMeshDetail,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyMeshDetail.cs,GetHeightDataSeedsFromVertices,The method has 7 parameters. Parameters: compactField' poly' polyCount' verts' borderSize' hp' stack
Long Parameter List,SharpNav,PolyMeshDetail,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyMeshDetail.cs,BuildPolyDetail,The method has 10 parameters. Parameters: polyMeshVerts' numMeshVerts' sampleDist' sampleMaxError' compactField' hp' verts' tris' edges' samples
Long Parameter List,SharpNav,PolyMeshDetail,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyMeshDetail.cs,AddEdge,The method has 5 parameters. Parameters: edges' s' t' leftFace' rightFace
Long Parameter List,SharpNav,PolyMeshDetail,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyMeshDetail.cs,CircumCircle,The method has 5 parameters. Parameters: p1' p2' p3' c' r
Long Parameter List,SharpNav,NavMeshQuery,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshQuery.cs,FindStraightPath,The method has 5 parameters. Parameters: startPos' endPos' path' straightPath' options
Long Parameter List,SharpNav,NavMeshQuery,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshQuery.cs,Raycast,The method has 5 parameters. Parameters: startPoint' endPos' options' hit' hitPath
Long Parameter List,SharpNav,NavMeshQuery,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshQuery.cs,Raycast,The method has 6 parameters. Parameters: startPoint' endPos' prevRef' options' hit' hitPath
Long Parameter List,SharpNav,NavMeshQuery,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshQuery.cs,FindLocalNeighborhood,The method has 6 parameters. Parameters: centerPoint' radius' resultRef' resultParent' resultCount' maxResult
Long Parameter List,SharpNav,NavMeshQuery,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshQuery.cs,GetPolyWallSegments,The method has 5 parameters. Parameters: reference' segmentVerts' segmentRefs' segmentCount' maxSegments
Long Parameter List,SharpNav,NavMeshQuery,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshQuery.cs,InsertInterval,The method has 6 parameters. Parameters: ints' nints' maxInts' tmin' tmax' reference
Long Parameter List,SharpNav,NavMeshQuery,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshQuery.cs,GetEdgeMidPoint,The method has 7 parameters. Parameters: from' fromPoly' fromTile' to' toPoly' toTile' mid
Long Parameter List,SharpNav,NavMeshQuery,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshQuery.cs,GetPortalPoints,The method has 6 parameters. Parameters: from' to' left' right' fromType' toType
Long Parameter List,SharpNav,NavMeshQuery,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshQuery.cs,GetPortalPoints,The method has 8 parameters. Parameters: from' fromPoly' fromTile' to' toPoly' toTile' left' right
Long Parameter List,SharpNav,NavMeshQuery,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshQuery.cs,AppendPortals,The method has 6 parameters. Parameters: startIdx' endIdx' endPos' path' straightPath' options
Long Parameter List,SharpNav,MathHelper,C:\repos\Robmaister_SharpNav\Source\SharpNav\MathHelper.cs,ClipPolygonToPlane,The method has 6 parameters. Parameters: inVertices' outVertices' numVerts' planeX' planeZ' planeD
Long Parameter List,SharpNav,MathHelper,C:\repos\Robmaister_SharpNav\Source\SharpNav\MathHelper.cs,ClipPolygonToPlane,The method has 7 parameters. Parameters: inVertices' outVertices' distances' numVerts' planeX' planeZ' planeD
Long Parameter List,SharpNav,CompactHeightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\CompactHeightfield.cs,ExpandRegions,The method has 7 parameters. Parameters: regions' floodDistances' maxIterations' level' stack' regionBuffer' distanceBuffer
Long Parameter List,SharpNav,CompactHeightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\CompactHeightfield.cs,FloodRegion,The method has 5 parameters. Parameters: regions' floodDistances' regionIndex' level' start
Long Parameter List,SharpNav,CompactHeightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\CompactHeightfield.cs,FillRectangleRegion,The method has 6 parameters. Parameters: regions' newRegionId' left' right' bottom' top
Long Parameter List,SharpNav,CompactHeightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\CompactHeightfield.cs,SortCellsByLevel,The method has 5 parameters. Parameters: regions' stacks' startlevel' numStacks' logLevelsPerStack
Long Parameter List,SharpNav,TiledNavMesh,C:\repos\Robmaister_SharpNav\Source\SharpNav\TiledNavMesh.cs,TiledNavMesh,The method has 5 parameters. Parameters: origin' tileWidth' tileHeight' maxTiles' maxPolys
Long Parameter List,SharpNav.Collections.Generic,ProximityGrid<T>,C:\repos\Robmaister_SharpNav\Source\SharpNav\Collections\Generic\ProximityGrid.cs,AddItem,The method has 5 parameters. Parameters: value' minX' minY' maxX' maxY
Long Parameter List,SharpNav.Collections.Generic,ProximityGrid<T>,C:\repos\Robmaister_SharpNav\Source\SharpNav\Collections\Generic\ProximityGrid.cs,QueryItems,The method has 6 parameters. Parameters: minX' minY' maxX' maxY' values' maxVals
Long Parameter List,SharpNav.Collections,BVTree,C:\repos\Robmaister_SharpNav\Source\SharpNav\Collections\BVTree.cs,BVTree,The method has 5 parameters. Parameters: verts' polys' nvp' cellSize' cellHeight
Long Parameter List,SharpNav.Crowds,Crowd,C:\repos\Robmaister_SharpNav\Source\SharpNav\Crowds\Crowd.cs,GetNeighbors,The method has 8 parameters. Parameters: pos' height' range' skip' result' maxResult' agents' grid
Long Parameter List,SharpNav.Crowds,Crowd,C:\repos\Robmaister_SharpNav\Source\SharpNav\Crowds\Crowd.cs,AddNeighbor,The method has 5 parameters. Parameters: agent' dist' neis' nneis' maxNeis
Long Parameter List,SharpNav.Crowds,ObstacleAvoidanceQuery,C:\repos\Robmaister_SharpNav\Source\SharpNav\Crowds\ObstacleAvoidanceQuery.cs,ProcessSample,The method has 6 parameters. Parameters: vcand' cs' position' radius' vel' desiredVel
Long Parameter List,SharpNav.Crowds,ObstacleAvoidanceQuery,C:\repos\Robmaister_SharpNav\Source\SharpNav\Crowds\ObstacleAvoidanceQuery.cs,SweepCircleCircle,The method has 7 parameters. Parameters: center0' radius0' v' center1' radius1' tmin' tmax
Long Parameter List,SharpNav.Crowds,ObstacleAvoidanceQuery,C:\repos\Robmaister_SharpNav\Source\SharpNav\Crowds\ObstacleAvoidanceQuery.cs,SampleVelocityGrid,The method has 7 parameters. Parameters: pos' rad' vmax' vel' desiredVel' nvel' parameters
Long Parameter List,SharpNav.Crowds,ObstacleAvoidanceQuery,C:\repos\Robmaister_SharpNav\Source\SharpNav\Crowds\ObstacleAvoidanceQuery.cs,SampleVelocityAdaptive,The method has 7 parameters. Parameters: position' radius' vmax' vel' desiredVel' nvel' parameters
Long Parameter List,SharpNav.Crowds,PathCorridor,C:\repos\Robmaister_SharpNav\Source\SharpNav\Crowds\PathCorridor.cs,MoveOverOffmeshConnection,The method has 5 parameters. Parameters: offMeshConRef' refs' startPos' endPos' navquery
Long Parameter List,SharpNav.Geometry,Distance,C:\repos\Robmaister_SharpNav\Source\SharpNav\Geometry\Distance.cs,PointToSegment2DSquared,The method has 6 parameters. Parameters: x' z' px' pz' qx' qz
Long Parameter List,SharpNav.Geometry,Distance,C:\repos\Robmaister_SharpNav\Source\SharpNav\Geometry\Distance.cs,PointToPolygonEdgeSquared,The method has 5 parameters. Parameters: pt' verts' nverts' edgeDist' edgeT
Long Parameter List,SharpNav.Geometry,Distance,C:\repos\Robmaister_SharpNav\Source\SharpNav\Geometry\Distance.cs,PointToTriangle,The method has 5 parameters. Parameters: p' a' b' c' height
Long Parameter List,SharpNav.Geometry,Intersection,C:\repos\Robmaister_SharpNav\Source\SharpNav\Geometry\Intersection.cs,RaySegment,The method has 5 parameters. Parameters: origin' dir' a' b' t
Long Parameter List,SharpNav.Geometry,Intersection,C:\repos\Robmaister_SharpNav\Source\SharpNav\Geometry\Intersection.cs,SegmentSegment2D,The method has 6 parameters. Parameters: a' b' c' d' s' t
Long Parameter List,SharpNav.Geometry,Intersection,C:\repos\Robmaister_SharpNav\Source\SharpNav\Geometry\Intersection.cs,SegmentPoly2D,The method has 8 parameters. Parameters: p0' p1' verts' nverts' tmin' tmax' segMin' segMax
Long Parameter List,SharpNav.Geometry,Intersection,C:\repos\Robmaister_SharpNav\Source\SharpNav\Geometry\Intersection.cs,ProjectPoly,The method has 5 parameters. Parameters: axis' poly' npoly' rmin' rmax
Long Parameter List,SharpNav.Geometry,Intersection,C:\repos\Robmaister_SharpNav\Source\SharpNav\Geometry\Intersection.cs,OverlapRange,The method has 5 parameters. Parameters: amin' amax' bmin' bmax' eps
Long Parameter List,SharpNav.Geometry,TriangleEnumerable,C:\repos\Robmaister_SharpNav\Source\SharpNav\Geometry\TriangleEnumerable.cs,FromIndexedVector3,The method has 6 parameters. Parameters: vertices' indices' vertOffset' vertStride' indexOffset' triCount
Long Parameter List,SharpNav.Geometry,TriangleEnumerable,C:\repos\Robmaister_SharpNav\Source\SharpNav\Geometry\TriangleEnumerable.cs,FromIndexedFloat,The method has 6 parameters. Parameters: vertices' indices' floatOffset' floatStride' indexOffset' triCount
Long Parameter List,SharpNav.Geometry,BBox3,C:\repos\Robmaister_SharpNav\Source\SharpNav\Geometry\BBox3.cs,BBox3,The method has 6 parameters. Parameters: minX' minY' minZ' maxX' maxY' maxZ
Long Parameter List,SharpNav.Geometry,Vector2,C:\repos\Robmaister_SharpNav\Source\SharpNav\Geometry\Vector2.cs,BaryCentric,The method has 5 parameters. Parameters: a' b' c' u' v
Long Parameter List,SharpNav.Geometry,Vector2,C:\repos\Robmaister_SharpNav\Source\SharpNav\Geometry\Vector2.cs,BaryCentric,The method has 6 parameters. Parameters: a' b' c' u' v' result
Long Parameter List,SharpNav.Geometry,Vector3,C:\repos\Robmaister_SharpNav\Source\SharpNav\Geometry\Vector3.cs,BaryCentric,The method has 5 parameters. Parameters: a' b' c' u' v
Long Parameter List,SharpNav.Geometry,Vector3,C:\repos\Robmaister_SharpNav\Source\SharpNav\Geometry\Vector3.cs,BaryCentric,The method has 6 parameters. Parameters: a' b' c' u' v' result
Long Parameter List,SharpNav.Pathfinding,NavTile,C:\repos\Robmaister_SharpNav\Source\SharpNav\Pathfinding\NavTile.cs,NavTile,The method has 5 parameters. Parameters: x' y' layer' manager' baseRef
Long Parameter List,SharpNav.Pathfinding,NavTile,C:\repos\Robmaister_SharpNav\Source\SharpNav\Pathfinding\NavTile.cs,FindConnectingPolys,The method has 5 parameters. Parameters: va' vb' side' con' conarea
Long Parameter List,SharpNav.Pathfinding,NavTile,C:\repos\Robmaister_SharpNav\Source\SharpNav\Pathfinding\NavTile.cs,CalcSlabEndPoints,The method has 5 parameters. Parameters: va' vb' bmin' bmax' side
Long Parameter List,SharpNav.Pathfinding,NavTile,C:\repos\Robmaister_SharpNav\Source\SharpNav\Pathfinding\NavTile.cs,OverlapSlabs,The method has 6 parameters. Parameters: amin' amax' bmin' bmax' px' py
Long Parameter List,SharpNav.Pathfinding,NavQueryFilter,C:\repos\Robmaister_SharpNav\Source\SharpNav\Pathfinding\NavQueryFilter.cs,GetCost,The method has 11 parameters. Parameters: a' b' prevRef' prevTile' prevPoly' curRef' curTile' curPoly' nextRef' nextTile' nextPoly
Long Identifier,SharpNav.Crowds,Crowd,C:\repos\Robmaister_SharpNav\Source\SharpNav\Crowds\Crowd.cs,,The length of the parameter AgentMaxObstacleAvoidanceParams is 31.
Long Statement,SharpNav,AreaGenerator,C:\repos\Robmaister_SharpNav\Source\SharpNav\AreaGenerator.cs,From,The length of the statement  "			return new AreaGenerator(TriangleEnumerable.FromIndexedVector3(verts' inds' 0' 1' 0' inds.Length / 3)' inds.Length / 3' area); " is 126.
Long Statement,SharpNav,AreaGenerator,C:\repos\Robmaister_SharpNav\Source\SharpNav\AreaGenerator.cs,From,The length of the statement  "			return new AreaGenerator(TriangleEnumerable.FromIndexedVector3(verts' inds' vertOffset' vertStride' indexOffset' triCount)' triCount' area); " is 140.
Long Statement,SharpNav,AreaGenerator,C:\repos\Robmaister_SharpNav\Source\SharpNav\AreaGenerator.cs,From,The length of the statement  "			return new AreaGenerator(TriangleEnumerable.FromIndexedFloat(verts' inds' 0' 3' 0' inds.Length / 3)' inds.Length / 3' area); " is 124.
Long Statement,SharpNav,AreaGenerator,C:\repos\Robmaister_SharpNav\Source\SharpNav\AreaGenerator.cs,From,The length of the statement  "			return new AreaGenerator(TriangleEnumerable.FromIndexedFloat(verts' inds' floatOffset' floatStride' indexOffset' triCount)' triCount' area); " is 140.
Long Statement,SharpNav,CompactSpan,C:\repos\Robmaister_SharpNav\Source\SharpNav\CompactSpan.cs,SetConnection,The length of the statement  "				throw new ArgumentOutOfRangeException("Index of connecting span is too high to be stored. Try increasing cell height."' "i"); " is 125.
Long Statement,SharpNav,Contour,C:\repos\Robmaister_SharpNav\Source\SharpNav\Contour.cs,Simplify,The length of the statement  "			bool tesselateWallEdges = (buildFlags & ContourBuildFlags.TessellateWallEdges) == ContourBuildFlags.TessellateWallEdges; " is 120.
Long Statement,SharpNav,Contour,C:\repos\Robmaister_SharpNav\Source\SharpNav\Contour.cs,Simplify,The length of the statement  "			bool tesselateAreaEdges = (buildFlags & ContourBuildFlags.TessellateAreaEdges) == ContourBuildFlags.TessellateAreaEdges; " is 120.
Long Statement,SharpNav,Contour,C:\repos\Robmaister_SharpNav\Source\SharpNav\Contour.cs,Simplify,The length of the statement  "					bool areaBorders = RegionId.HasFlags(rawVerts[i].RegionId' RegionFlags.AreaBorder) != RegionId.HasFlags(rawVerts[ii].RegionId' RegionFlags.AreaBorder); " is 151.
Long Statement,SharpNav,Contour,C:\repos\Robmaister_SharpNav\Source\SharpNav\Contour.cs,Simplify,The length of the statement  "				sv.RegionId = RegionId.FromRawBits(((int)rawVerts[ai].RegionId & (RegionId.MaskId | (int)RegionFlags.AreaBorder)) | ((int)rawVerts[(int)bi].RegionId & (int)RegionFlags.VertexBorder)); " is 183.
Long Statement,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTrianglesIndexedWithAreas,The length of the statement  "				throw new ArgumentOutOfRangeException("indexCount"' "The specified index offset and length end outside the provided index array."); " is 131.
Long Statement,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTrianglesIndexedWithAreas,The length of the statement  "				throw new ArgumentOutOfRangeException("indexCount"' "The specified index offset and length end outside the provided index array."); " is 131.
Long Statement,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTrianglesWithAreas,The length of the statement  "				throw new ArgumentOutOfRangeException("triCount"' "The specified offset and count end outside the bounds of the provided array."); " is 130.
Long Statement,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTrianglesWithAreas,The length of the statement  "				throw new ArgumentOutOfRangeException("triCount"' "The specified offset' count' and stride end outside the bounds of the provided array."); " is 139.
Long Statement,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTrianglesWithAreas,The length of the statement  "				throw new ArgumentOutOfRangeException("triCount"' "The specified offset' count' and stride end outside the bounds of the provided array."); " is 139.
Long Statement,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTrianglesIndexed,The length of the statement  "				throw new ArgumentOutOfRangeException("indexCount"' "The specified index offset and length end outside the provided index array."); " is 131.
Long Statement,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTrianglesIndexed,The length of the statement  "				throw new ArgumentOutOfRangeException("indexCount"' "The specified index offset and length end outside the provided index array."); " is 131.
Long Statement,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTriangles,The length of the statement  "				throw new ArgumentOutOfRangeException("triCount"' "The specified offset and count end outside the bounds of the provided array."); " is 130.
Long Statement,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTriangles,The length of the statement  "				throw new ArgumentOutOfRangeException("triCount"' "The specified offset' count' and stride end outside the bounds of the provided array."); " is 139.
Long Statement,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTriangles,The length of the statement  "				throw new ArgumentOutOfRangeException("triCount"' "The specified offset' count' and stride end outside the bounds of the provided array."); " is 139.
Long Statement,SharpNav,PolyMesh,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyMesh.cs,InCone,The length of the statement  "				return PolyVertex.IsLeft(ref verts[pi]' ref verts[pj]' ref verts[pin1]) && PolyVertex.IsLeft(ref verts[pj]' ref verts[pi]' ref verts[pi1]); " is 139.
Long Statement,SharpNav,PolyMesh,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyMesh.cs,InCone,The length of the statement  "			return !(PolyVertex.IsLeftOn(ref verts[pi]' ref verts[pj]' ref verts[pi1]) && PolyVertex.IsLeftOn(ref verts[pj]' ref verts[pi]' ref verts[pin1])); " is 146.
Long Statement,SharpNav,Polygon,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyMesh.cs,MergeWith,The length of the statement  "					throw new ArgumentException("Buffer not large enough. Must be at least numVertsPerPoly (" + vertices.Length + ")"' "temp"); " is 123.
Long Statement,SharpNav,PolyMeshDetail,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyMeshDetail.cs,GetHeightDataSeedsFromVertices,The length of the statement  "					int ai = compactField.Cells[(ay + borderSize) * compactField.Width + (ax + borderSize)].StartIndex + CompactSpan.GetConnection(ref cs' dir); " is 140.
Long Statement,SharpNav,NavMeshQuery,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshQuery.cs,FindRandomPointAroundCircle,The length of the statement  "						Triangle3.Area2D(ref bestTile.Verts[bestPoly.Verts[0]]' ref bestTile.Verts[bestPoly.Verts[j - 1]]' ref bestTile.Verts[bestPoly.Verts[j]]' out area); " is 148.
Long Statement,SharpNav,NavMeshQuery,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshQuery.cs,FindStraightPath,The length of the statement  "			stat = straightPath.AppendVertex(new StraightPathVertex(new NavPoint(path[0]' closestStartPos)' StraightPathFlags.Start)); " is 122.
Long Statement,SharpNav,NavMeshQuery,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshQuery.cs,FindStraightPath,The length of the statement  "			stat = straightPath.AppendVertex(new StraightPathVertex(new NavPoint(NavPolyId.Null' closestEndPos)' StraightPathFlags.End)); " is 125.
Long Statement,SharpNav,NavMeshQuery,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshQuery.cs,UpdateSlicedFindPath,The length of the statement  "					if ((parentRef != NavPolyId.Null) && (parentNode.Position - bestNode.Position).LengthSquared() < query.RaycastLimitSquared) " is 123.
Long Statement,SharpNav,CompactHeightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\CompactHeightfield.cs,FilterSmallRegions,The length of the statement  "						//HACK since the border region flag makes r negative' I changed r == 0 to r <= 0. Figure out exactly what maxRegionId's purpose is and see if Region.IsBorderOrNull is all we need. " is 179.
Long Statement,SharpNav,CompactHeightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\CompactHeightfield.cs,GetCornerHeight,The length of the statement  "				bool twoSameExteriors = RegionId.HasFlags(ra' RegionFlags.Border) && RegionId.HasFlags(rb' RegionFlags.Border) && (ra == rb && aa == ab); " is 137.
Long Statement,SharpNav.Collections.Generic,PriorityQueue<T>,C:\repos\Robmaister_SharpNav\Source\SharpNav\Collections\Generic\PriorityQueue.cs,Remove,The length of the statement  "			throw new InvalidOperationException("This priority queue implementation only allows elements to be popped off the top' not removed."); " is 134.
Long Statement,SharpNav.Collections,BVTree,C:\repos\Robmaister_SharpNav\Source\SharpNav\Collections\BVTree.cs,Subdivide,The length of the statement  "				int axis = LongestAxis((int)(bounds.Max.X - bounds.Min.X)' (int)(bounds.Max.Y - bounds.Min.Y)' (int)(bounds.Max.Z - bounds.Min.Z)); " is 131.
Long Statement,SharpNav.Crowds,Crowd,C:\repos\Robmaister_SharpNav\Source\SharpNav\Crowds\Crowd.cs,Update,The length of the statement  "				if (Vector3Extensions.Distance2D(agents[i].Position' agents[i].Boundary.Center) > updateThr * updateThr || !agents[i].Boundary.IsValid(navQuery)) " is 145.
Long Statement,SharpNav.Crowds,Crowd,C:\repos\Robmaister_SharpNav\Source\SharpNav\Crowds\Crowd.cs,Update,The length of the statement  "					agents[i].Boundary.Update(agents[i].Corridor.GetFirstPoly()' agents[i].Position' agents[i].Parameters.CollisionQueryRange' navQuery); " is 133.
Long Statement,SharpNav.Crowds,Crowd,C:\repos\Robmaister_SharpNav\Source\SharpNav\Crowds\Crowd.cs,Update,The length of the statement  "				agents[i].NeighborCount = GetNeighbors(agents[i].Position' agents[i].Parameters.Height' agents[i].Parameters.CollisionQueryRange' agents[i]' agents[i].Neighbors' AgentMaxNeighbors' agents' grid); " is 195.
Long Statement,SharpNav.Crowds,Crowd,C:\repos\Robmaister_SharpNav\Source\SharpNav\Crowds\Crowd.cs,Update,The length of the statement  "					if (agents[i].Corridor.MoveOverOffmeshConnection(agents[i].Corners[agents[i].Corners.Count - 1].Point.Polygon' refs' ref agentAnims[idx].StartPos' ref agentAnims[idx].EndPos' navQuery)) " is 185.
Long Statement,SharpNav.Crowds,Crowd,C:\repos\Robmaister_SharpNav\Source\SharpNav\Crowds\Crowd.cs,Update,The length of the statement  "					ObstacleAvoidanceQuery.ObstacleAvoidanceParams parameters = obstacleQueryParams[agents[i].Parameters.ObstacleAvoidanceType]; " is 124.
Long Statement,SharpNav.Crowds,Crowd,C:\repos\Robmaister_SharpNav\Source\SharpNav\Crowds\Crowd.cs,Update,The length of the statement  "						ns = obstacleQuery.SampleVelocityAdaptive(agents[i].Position' agents[i].Parameters.Radius' agents[i].DesiredSpeed' agents[i].Vel' agents[i].DesiredVel' ref agents[i].NVel' parameters); " is 184.
Long Statement,SharpNav.Crowds,Crowd,C:\repos\Robmaister_SharpNav\Source\SharpNav\Crowds\Crowd.cs,Update,The length of the statement  "						ns = obstacleQuery.SampleVelocityGrid(agents[i].Position' agents[i].Parameters.Radius' agents[i].DesiredSpeed' agents[i].Vel' agents[i].DesiredVel' ref agents[i].NVel' parameters); " is 180.
Long Statement,SharpNav.Crowds,Crowd,C:\repos\Robmaister_SharpNav\Source\SharpNav\Crowds\Crowd.cs,Update,The length of the statement  "						if (dist > (agents[i].Parameters.Radius + nei.Parameters.Radius) * (agents[i].Parameters.Radius + nei.Parameters.Radius)) " is 121.
Long Statement,SharpNav.Crowds,Crowd,C:\repos\Robmaister_SharpNav\Source\SharpNav\Crowds\Crowd.cs,UpdateMoveRequest,The length of the statement  "							status = navQuery.ClosestPointOnPoly(reqPath[reqPath.Count - 1]' agents[i].TargetPosition' out reqPos' out tempBool).ToStatus(); " is 128.
Long Statement,SharpNav.Crowds,Crowd,C:\repos\Robmaister_SharpNav\Source\SharpNav\Crowds\Crowd.cs,UpdateMoveRequest,The length of the statement  "				queue[i].TargetPathQueryIndex = pathq.Request(new NavPoint(queue[i].Corridor.GetLastPoly()' queue[i].Corridor.Target)' new NavPoint(queue[i].TargetRef' queue[i].TargetPosition)); " is 178.
Long Statement,SharpNav.Crowds,ObstacleAvoidanceQuery,C:\repos\Robmaister_SharpNav\Source\SharpNav\Crowds\ObstacleAvoidanceQuery.cs,Prepare,The length of the statement  "				segments[i].Touch = Distance.PointToSegment2DSquared(ref position' ref segments[i].P' ref segments[i].Q' out t) < (r * r); " is 122.
Long Statement,SharpNav.Crowds,ObstacleAvoidanceQuery,C:\repos\Robmaister_SharpNav\Source\SharpNav\Crowds\ObstacleAvoidanceQuery.cs,ProcessSample,The length of the statement  "				side += MathHelper.Clamp(Math.Min(Vector3Extensions.Dot2D(ref cir.Dp' ref vab) * 0.5f + 0.5f' Vector3Extensions.Dot2D(ref cir.Np' ref vab) * 2.0f)' 0.0f' 1.0f); " is 160.
Long Statement,SharpNav.IO.Json,Vector3Converter,C:\repos\Robmaister_SharpNav\Source\SharpNav\IO\Json\Vector3Converter.cs,ReadJson,The length of the statement  "			return new Vector3(jObject["X"].ToObject<float>(serializer)' jObject["Y"].ToObject<float>(serializer)' jObject["Z"].ToObject<float>(serializer)); " is 145.
Long Statement,SharpNav.IO.Json,NavMeshJsonSerializer,C:\repos\Robmaister_SharpNav\Source\SharpNav\IO\Json\NavMeshJsonSerializer.cs,Serialize,The length of the statement  "					sharpnav = Assembly.GetExecutingAssembly().GetCustomAttribute<AssemblyInformationalVersionAttribute>().InformationalVersion " is 123.
Long Statement,SharpNav.IO.Json,NavMeshJsonSerializer,C:\repos\Robmaister_SharpNav\Source\SharpNav\IO\Json\NavMeshJsonSerializer.cs,Deserialize,The length of the statement  "				throw new ArgumentException("The version of the file does not match the version of the parser. Consider using an older version of SharpNav or re-generating your .snj meshes."); " is 176.
Complex Conditional,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,FilterLedgeSpans,The conditional expression  "dx < 0 || dy < 0 || dx >= width || dy >= length"  is complex.
Complex Conditional,SharpNav,HeightPatch,C:\repos\Robmaister_SharpNav\Source\SharpNav\HeightPatch.cs,HeightPatch,The conditional expression  "x < 0 || y < 0 || width <= 0 || length <= 0"  is complex.
Complex Conditional,SharpNav,PolyMesh,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyMesh.cs,Diagonalie,The conditional expression  "!((k == i) || (k1 == i) || (k == j) || (k1 == j))"  is complex.
Complex Conditional,SharpNav,PolyMesh,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyMesh.cs,Diagonalie,The conditional expression  "PolyVertex.Equal2D(ref verts[d0]' ref verts[p0]) ||  						PolyVertex.Equal2D(ref verts[d1]' ref verts[p0]) ||  						PolyVertex.Equal2D(ref verts[d0]' ref verts[p1]) ||  						PolyVertex.Equal2D(ref verts[d1]' ref verts[p1])"  is complex.
Complex Conditional,SharpNav,PolyMesh,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyMesh.cs,DiagonalieLoose,The conditional expression  "!((k == i) || (k1 == i) || (k == j) || (k1 == j))"  is complex.
Complex Conditional,SharpNav,PolyMesh,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyMesh.cs,DiagonalieLoose,The conditional expression  "PolyVertex.Equal2D(ref verts[d0]' ref verts[p0]) ||  						PolyVertex.Equal2D(ref verts[d1]' ref verts[p0]) ||  						PolyVertex.Equal2D(ref verts[d0]' ref verts[p1]) ||  						PolyVertex.Equal2D(ref verts[d1]' ref verts[p1])"  is complex.
Complex Conditional,SharpNav,PolyMeshDetail,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyMeshDetail.cs,GetHeightData,The conditional expression  "hx < 0 || hx >= hp.Width || hy < 0 || hy >= hp.Length"  is complex.
Complex Conditional,SharpNav,PolyMeshDetail,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyMeshDetail.cs,GetHeightDataSeedsFromVertices,The conditional expression  "ax < hp.X || ax >= hp.X + hp.Width || az < hp.Y || az >= hp.Y + hp.Length"  is complex.
Complex Conditional,SharpNav,PolyMeshDetail,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyMeshDetail.cs,GetHeightDataSeedsFromVertices,The conditional expression  "ax < hp.X || ax >= (hp.X + hp.Width) || ay < hp.Y || ay >= (hp.Y + hp.Length)"  is complex.
Complex Conditional,SharpNav,PolyMeshDetail,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyMeshDetail.cs,GetHeight,The conditional expression  "nx < 0 || nz < 0 || nx >= hp.Width || nz >= hp.Length"  is complex.
Complex Conditional,SharpNav,PolyMeshDetail,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyMeshDetail.cs,FindEdge,The conditional expression  "(e.EndPt0 == s && e.EndPt1 == t) || (e.EndPt0 == t && e.EndPt1 == s)"  is complex.
Complex Conditional,SharpNav,PolyMeshDetail,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyMeshDetail.cs,OverlapEdges,The conditional expression  "s0 == s1 || s0 == t1 || t0 == s1 || t0 == t1"  is complex.
Complex Conditional,SharpNav,PolyVertex,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyVertex.cs,Intersect,The conditional expression  "IsBetween(ref a' ref b' ref c)  				|| IsBetween(ref a' ref b' ref d)  				|| IsBetween(ref c' ref d' ref a)  				|| IsBetween(ref c' ref d' ref b)"  is complex.
Complex Conditional,SharpNav,PolyVertex,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyVertex.cs,IntersectProp,The conditional expression  "IsCollinear(ref a' ref b' ref c)  				|| IsCollinear(ref a' ref b' ref d)  				|| IsCollinear(ref c' ref d' ref a)  				|| IsCollinear(ref c' ref d' ref b)"  is complex.
Complex Conditional,SharpNav,CompactHeightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\CompactHeightfield.cs,CompactHeightfield,The conditional expression  "dx < 0 || dz < 0 || dx >= width || dz >= length"  is complex.
Complex Conditional,SharpNav,CompactHeightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\CompactHeightfield.cs,GetCornerHeight,The conditional expression  "twoSameExteriors && twoSameInteriors && intsSameArea && noZeros"  is complex.
Complex Conditional,SharpNav.Geometry,BBox3,C:\repos\Robmaister_SharpNav\Source\SharpNav\Geometry\BBox3.cs,IsValid,The conditional expression  "float.IsNaN(b.Min.X) ||  				float.IsNaN(b.Min.Y) ||  				float.IsNaN(b.Min.Z) ||  				float.IsNaN(b.Max.X) ||  				float.IsNaN(b.Max.Y) ||  				float.IsNaN(b.Max.Z)"  is complex.
Magic Number,SharpNav,AreaGenerator,C:\repos\Robmaister_SharpNav\Source\SharpNav\AreaGenerator.cs,From,The following statement contains a magic number: return new AreaGenerator(TriangleEnumerable.FromVector3(verts' 0' 1' verts.Length / 3)' verts.Length / 3' area);
Magic Number,SharpNav,AreaGenerator,C:\repos\Robmaister_SharpNav\Source\SharpNav\AreaGenerator.cs,From,The following statement contains a magic number: return new AreaGenerator(TriangleEnumerable.FromVector3(verts' 0' 1' verts.Length / 3)' verts.Length / 3' area);
Magic Number,SharpNav,AreaGenerator,C:\repos\Robmaister_SharpNav\Source\SharpNav\AreaGenerator.cs,From,The following statement contains a magic number: return new AreaGenerator(TriangleEnumerable.FromFloat(verts' 0' 3' verts.Length / 9)' verts.Length / 9' area);
Magic Number,SharpNav,AreaGenerator,C:\repos\Robmaister_SharpNav\Source\SharpNav\AreaGenerator.cs,From,The following statement contains a magic number: return new AreaGenerator(TriangleEnumerable.FromFloat(verts' 0' 3' verts.Length / 9)' verts.Length / 9' area);
Magic Number,SharpNav,AreaGenerator,C:\repos\Robmaister_SharpNav\Source\SharpNav\AreaGenerator.cs,From,The following statement contains a magic number: return new AreaGenerator(TriangleEnumerable.FromFloat(verts' 0' 3' verts.Length / 9)' verts.Length / 9' area);
Magic Number,SharpNav,AreaGenerator,C:\repos\Robmaister_SharpNav\Source\SharpNav\AreaGenerator.cs,From,The following statement contains a magic number: return new AreaGenerator(TriangleEnumerable.FromIndexedVector3(verts' inds' 0' 1' 0' inds.Length / 3)' inds.Length / 3' area);
Magic Number,SharpNav,AreaGenerator,C:\repos\Robmaister_SharpNav\Source\SharpNav\AreaGenerator.cs,From,The following statement contains a magic number: return new AreaGenerator(TriangleEnumerable.FromIndexedVector3(verts' inds' 0' 1' 0' inds.Length / 3)' inds.Length / 3' area);
Magic Number,SharpNav,AreaGenerator,C:\repos\Robmaister_SharpNav\Source\SharpNav\AreaGenerator.cs,From,The following statement contains a magic number: return new AreaGenerator(TriangleEnumerable.FromIndexedFloat(verts' inds' 0' 3' 0' inds.Length / 3)' inds.Length / 3' area);
Magic Number,SharpNav,AreaGenerator,C:\repos\Robmaister_SharpNav\Source\SharpNav\AreaGenerator.cs,From,The following statement contains a magic number: return new AreaGenerator(TriangleEnumerable.FromIndexedFloat(verts' inds' 0' 3' 0' inds.Length / 3)' inds.Length / 3' area);
Magic Number,SharpNav,AreaGenerator,C:\repos\Robmaister_SharpNav\Source\SharpNav\AreaGenerator.cs,From,The following statement contains a magic number: return new AreaGenerator(TriangleEnumerable.FromIndexedFloat(verts' inds' 0' 3' 0' inds.Length / 3)' inds.Length / 3' area);
Magic Number,SharpNav,CompactSpanReference,C:\repos\Robmaister_SharpNav\Source\SharpNav\CompactSpanReference.cs,GetHashCode,The following statement contains a magic number: int hash = 27;
Magic Number,SharpNav,CompactSpanReference,C:\repos\Robmaister_SharpNav\Source\SharpNav\CompactSpanReference.cs,GetHashCode,The following statement contains a magic number: hash = (13 * hash) + X.GetHashCode();
Magic Number,SharpNav,CompactSpanReference,C:\repos\Robmaister_SharpNav\Source\SharpNav\CompactSpanReference.cs,GetHashCode,The following statement contains a magic number: hash = (13 * hash) + Y.GetHashCode();
Magic Number,SharpNav,CompactSpanReference,C:\repos\Robmaister_SharpNav\Source\SharpNav\CompactSpanReference.cs,GetHashCode,The following statement contains a magic number: hash = (13 * hash) + Index.GetHashCode();
Magic Number,SharpNav,Contour,C:\repos\Robmaister_SharpNav\Source\SharpNav\Contour.cs,MergeWith,The following statement contains a magic number: var newVerts = new List<ContourVertex>(vertices.Length + contour.vertices.Length + 2);
Magic Number,SharpNav,Contour,C:\repos\Robmaister_SharpNav\Source\SharpNav\Contour.cs,Simplify,The following statement contains a magic number: if (maxEdgeLen > 0 && (tesselateAreaEdges || tesselateWallEdges))  			{  				for (int i = 0; i < simplified.Count;)  				{  					int ii = (i + 1) % simplified.Count;    					//get (x' z) coordinates along with region id  					int ax = simplified[i].X;  					int az = simplified[i].Z;  					int ai = (int)simplified[i].RegionId;    					int bx = simplified[ii].X;  					int bz = simplified[ii].Z;  					int bi = (int)simplified[ii].RegionId;    					//find maximum deviation from segment  					int maxi = -1;  					int ci = (int)(ai + 1) % numPoints;    					//tessellate only outer edges or edges between areas  					bool tess = false;    					//wall edges  					if (tesselateWallEdges && rawVerts[ci].RegionId.Id == 0)  						tess = true;    					//edges between areas  					if (tesselateAreaEdges && RegionId.HasFlags(rawVerts[ci].RegionId' RegionFlags.AreaBorder))  						tess = true;    					if (tess)  					{  						int dx = bx - ax;  						int dz = bz - az;  						if (dx * dx + dz * dz > maxEdgeLen * maxEdgeLen)  						{  							//round based on lexilogical direction (smallest to largest cooridinates' first by x.  							//if x coordinates are equal' then compare z coordinates)  							int n = bi < ai ? (bi + numPoints - ai) : (bi - ai);    							if (n > 1)  							{  								if (bx > ax || (bx == ax && bz > az))  									maxi = (int)(ai + n / 2) % numPoints;  								else  									maxi = (int)(ai + (n + 1) / 2) % numPoints;  							}  						}  					}    					//add new point  					if (maxi != -1)  					{  						simplified.Insert(i + 1' new ContourVertex(rawVerts[maxi]' maxi));  					}  					else  					{  						i++;  					}  				}  			}
Magic Number,SharpNav,Contour,C:\repos\Robmaister_SharpNav\Source\SharpNav\Contour.cs,Simplify,The following statement contains a magic number: if (maxEdgeLen > 0 && (tesselateAreaEdges || tesselateWallEdges))  			{  				for (int i = 0; i < simplified.Count;)  				{  					int ii = (i + 1) % simplified.Count;    					//get (x' z) coordinates along with region id  					int ax = simplified[i].X;  					int az = simplified[i].Z;  					int ai = (int)simplified[i].RegionId;    					int bx = simplified[ii].X;  					int bz = simplified[ii].Z;  					int bi = (int)simplified[ii].RegionId;    					//find maximum deviation from segment  					int maxi = -1;  					int ci = (int)(ai + 1) % numPoints;    					//tessellate only outer edges or edges between areas  					bool tess = false;    					//wall edges  					if (tesselateWallEdges && rawVerts[ci].RegionId.Id == 0)  						tess = true;    					//edges between areas  					if (tesselateAreaEdges && RegionId.HasFlags(rawVerts[ci].RegionId' RegionFlags.AreaBorder))  						tess = true;    					if (tess)  					{  						int dx = bx - ax;  						int dz = bz - az;  						if (dx * dx + dz * dz > maxEdgeLen * maxEdgeLen)  						{  							//round based on lexilogical direction (smallest to largest cooridinates' first by x.  							//if x coordinates are equal' then compare z coordinates)  							int n = bi < ai ? (bi + numPoints - ai) : (bi - ai);    							if (n > 1)  							{  								if (bx > ax || (bx == ax && bz > az))  									maxi = (int)(ai + n / 2) % numPoints;  								else  									maxi = (int)(ai + (n + 1) / 2) % numPoints;  							}  						}  					}    					//add new point  					if (maxi != -1)  					{  						simplified.Insert(i + 1' new ContourVertex(rawVerts[maxi]' maxi));  					}  					else  					{  						i++;  					}  				}  			}
Magic Number,SharpNav,ContourSet,C:\repos\Robmaister_SharpNav\Source\SharpNav\ContourSet.cs,GetVertexLimits,The following statement contains a magic number: foreach (var c in contours)  			{  				int vertCount = c.Vertices.Length;    				maxVertices += vertCount;  				maxTris += vertCount - 2;  				maxVertsPerContour = Math.Max(maxVertsPerContour' vertCount);  			}
Magic Number,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTrianglesIndexedWithAreas,The following statement contains a magic number: RasterizeTrianglesIndexedWithAreas(verts' inds' 0' 1' 0' inds.Length / 3' areas);
Magic Number,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTrianglesIndexedWithAreas,The following statement contains a magic number: int indexEnd = triCount * 3 + indexOffset;
Magic Number,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTrianglesIndexedWithAreas,The following statement contains a magic number: for (int i = indexOffset' j = 0; i < indexEnd; i += 3' j++)  			{  				int indA = inds[i] * vertStride + vertOffset;  				int indB = inds[i + 1] * vertStride + vertOffset;  				int indC = inds[i + 2] * vertStride + vertOffset;    				RasterizeTriangle(ref verts[indA]' ref verts[indB]' ref verts[indC]' areas[j]);  			}
Magic Number,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTrianglesIndexedWithAreas,The following statement contains a magic number: for (int i = indexOffset' j = 0; i < indexEnd; i += 3' j++)  			{  				int indA = inds[i] * vertStride + vertOffset;  				int indB = inds[i + 1] * vertStride + vertOffset;  				int indC = inds[i + 2] * vertStride + vertOffset;    				RasterizeTriangle(ref verts[indA]' ref verts[indB]' ref verts[indC]' areas[j]);  			}
Magic Number,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTrianglesIndexedWithAreas,The following statement contains a magic number: RasterizeTrianglesIndexedWithAreas(verts' inds' 0' 3' 0' inds.Length / 3' areas);
Magic Number,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTrianglesIndexedWithAreas,The following statement contains a magic number: RasterizeTrianglesIndexedWithAreas(verts' inds' 0' 3' 0' inds.Length / 3' areas);
Magic Number,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTrianglesIndexedWithAreas,The following statement contains a magic number: int indexEnd = triCount * 3 + indexOffset;
Magic Number,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTrianglesIndexedWithAreas,The following statement contains a magic number: if (floatStride < 0)  				throw new ArgumentOutOfRangeException("floatStride"' "floatStride must be greater than or equal to 0.");  			else if (floatStride == 0)  				floatStride = 3;
Magic Number,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTrianglesIndexedWithAreas,The following statement contains a magic number: for (int i = indexOffset' j = 0; i < indexEnd; i += 3' j++)  			{  				int indA = inds[i] * floatStride + floatOffset;  				int indB = inds[i + 1] * floatStride + floatOffset;  				int indC = inds[i + 2] * floatStride + floatOffset;    				a.X = verts[indA];  				a.Y = verts[indA + 1];  				a.Z = verts[indA + 2];    				b.X = verts[indB];  				b.Y = verts[indB + 1];  				b.Z = verts[indB + 2];    				c.X = verts[indC];  				c.Y = verts[indC + 1];  				c.Z = verts[indC + 2];    				RasterizeTriangle(ref a' ref b' ref c' areas[j]);  			}
Magic Number,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTrianglesIndexedWithAreas,The following statement contains a magic number: for (int i = indexOffset' j = 0; i < indexEnd; i += 3' j++)  			{  				int indA = inds[i] * floatStride + floatOffset;  				int indB = inds[i + 1] * floatStride + floatOffset;  				int indC = inds[i + 2] * floatStride + floatOffset;    				a.X = verts[indA];  				a.Y = verts[indA + 1];  				a.Z = verts[indA + 2];    				b.X = verts[indB];  				b.Y = verts[indB + 1];  				b.Z = verts[indB + 2];    				c.X = verts[indC];  				c.Y = verts[indC + 1];  				c.Z = verts[indC + 2];    				RasterizeTriangle(ref a' ref b' ref c' areas[j]);  			}
Magic Number,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTrianglesIndexedWithAreas,The following statement contains a magic number: for (int i = indexOffset' j = 0; i < indexEnd; i += 3' j++)  			{  				int indA = inds[i] * floatStride + floatOffset;  				int indB = inds[i + 1] * floatStride + floatOffset;  				int indC = inds[i + 2] * floatStride + floatOffset;    				a.X = verts[indA];  				a.Y = verts[indA + 1];  				a.Z = verts[indA + 2];    				b.X = verts[indB];  				b.Y = verts[indB + 1];  				b.Z = verts[indB + 2];    				c.X = verts[indC];  				c.Y = verts[indC + 1];  				c.Z = verts[indC + 2];    				RasterizeTriangle(ref a' ref b' ref c' areas[j]);  			}
Magic Number,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTrianglesIndexedWithAreas,The following statement contains a magic number: for (int i = indexOffset' j = 0; i < indexEnd; i += 3' j++)  			{  				int indA = inds[i] * floatStride + floatOffset;  				int indB = inds[i + 1] * floatStride + floatOffset;  				int indC = inds[i + 2] * floatStride + floatOffset;    				a.X = verts[indA];  				a.Y = verts[indA + 1];  				a.Z = verts[indA + 2];    				b.X = verts[indB];  				b.Y = verts[indB + 1];  				b.Z = verts[indB + 2];    				c.X = verts[indC];  				c.Y = verts[indC + 1];  				c.Z = verts[indC + 2];    				RasterizeTriangle(ref a' ref b' ref c' areas[j]);  			}
Magic Number,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTrianglesIndexedWithAreas,The following statement contains a magic number: for (int i = indexOffset' j = 0; i < indexEnd; i += 3' j++)  			{  				int indA = inds[i] * floatStride + floatOffset;  				int indB = inds[i + 1] * floatStride + floatOffset;  				int indC = inds[i + 2] * floatStride + floatOffset;    				a.X = verts[indA];  				a.Y = verts[indA + 1];  				a.Z = verts[indA + 2];    				b.X = verts[indB];  				b.Y = verts[indB + 1];  				b.Z = verts[indB + 2];    				c.X = verts[indC];  				c.Y = verts[indC + 1];  				c.Z = verts[indC + 2];    				RasterizeTriangle(ref a' ref b' ref c' areas[j]);  			}
Magic Number,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTrianglesWithAreas,The following statement contains a magic number: RasterizeTrianglesWithAreas(verts' 0' 1' verts.Length / 3' areas);
Magic Number,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTrianglesWithAreas,The following statement contains a magic number: for (int i = vertOffset' j = 0; i < vertEnd; i += vertStride * 3' j++)  				RasterizeTriangle(ref verts[i]' ref verts[i + vertStride]' ref verts[i + vertStride * 2]' areas[j]);
Magic Number,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTrianglesWithAreas,The following statement contains a magic number: for (int i = vertOffset' j = 0; i < vertEnd; i += vertStride * 3' j++)  				RasterizeTriangle(ref verts[i]' ref verts[i + vertStride]' ref verts[i + vertStride * 2]' areas[j]);
Magic Number,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTrianglesWithAreas,The following statement contains a magic number: RasterizeTrianglesWithAreas(verts' 0' 3' verts.Length / 9' areas);
Magic Number,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTrianglesWithAreas,The following statement contains a magic number: RasterizeTrianglesWithAreas(verts' 0' 3' verts.Length / 9' areas);
Magic Number,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTrianglesWithAreas,The following statement contains a magic number: if (floatStride < 0)  				throw new ArgumentOutOfRangeException("floatStride"' "floatStride must be a positive integer.");  			else if (floatStride == 0)  				floatStride = 3;
Magic Number,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTrianglesWithAreas,The following statement contains a magic number: int floatEnd = triCount * (floatStride * 3) + floatOffset;
Magic Number,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTrianglesWithAreas,The following statement contains a magic number: for (int i = floatOffset' j = 0; i < floatEnd; i += floatStride * 3' j++)  			{  				int floatStride2 = floatStride * 2;    				a.X = verts[i];  				a.Y = verts[i + 1];  				a.Z = verts[i + 2];    				b.X = verts[i + floatStride];  				b.Y = verts[i + floatStride + 1];  				b.Z = verts[i + floatStride + 2];    				c.X = verts[i + floatStride2];  				c.Y = verts[i + floatStride2 + 1];  				c.Z = verts[i + floatStride2 + 2];    				RasterizeTriangle(ref a' ref b' ref c' areas[j]);  			}
Magic Number,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTrianglesWithAreas,The following statement contains a magic number: for (int i = floatOffset' j = 0; i < floatEnd; i += floatStride * 3' j++)  			{  				int floatStride2 = floatStride * 2;    				a.X = verts[i];  				a.Y = verts[i + 1];  				a.Z = verts[i + 2];    				b.X = verts[i + floatStride];  				b.Y = verts[i + floatStride + 1];  				b.Z = verts[i + floatStride + 2];    				c.X = verts[i + floatStride2];  				c.Y = verts[i + floatStride2 + 1];  				c.Z = verts[i + floatStride2 + 2];    				RasterizeTriangle(ref a' ref b' ref c' areas[j]);  			}
Magic Number,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTrianglesWithAreas,The following statement contains a magic number: for (int i = floatOffset' j = 0; i < floatEnd; i += floatStride * 3' j++)  			{  				int floatStride2 = floatStride * 2;    				a.X = verts[i];  				a.Y = verts[i + 1];  				a.Z = verts[i + 2];    				b.X = verts[i + floatStride];  				b.Y = verts[i + floatStride + 1];  				b.Z = verts[i + floatStride + 2];    				c.X = verts[i + floatStride2];  				c.Y = verts[i + floatStride2 + 1];  				c.Z = verts[i + floatStride2 + 2];    				RasterizeTriangle(ref a' ref b' ref c' areas[j]);  			}
Magic Number,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTrianglesWithAreas,The following statement contains a magic number: for (int i = floatOffset' j = 0; i < floatEnd; i += floatStride * 3' j++)  			{  				int floatStride2 = floatStride * 2;    				a.X = verts[i];  				a.Y = verts[i + 1];  				a.Z = verts[i + 2];    				b.X = verts[i + floatStride];  				b.Y = verts[i + floatStride + 1];  				b.Z = verts[i + floatStride + 2];    				c.X = verts[i + floatStride2];  				c.Y = verts[i + floatStride2 + 1];  				c.Z = verts[i + floatStride2 + 2];    				RasterizeTriangle(ref a' ref b' ref c' areas[j]);  			}
Magic Number,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTrianglesWithAreas,The following statement contains a magic number: for (int i = floatOffset' j = 0; i < floatEnd; i += floatStride * 3' j++)  			{  				int floatStride2 = floatStride * 2;    				a.X = verts[i];  				a.Y = verts[i + 1];  				a.Z = verts[i + 2];    				b.X = verts[i + floatStride];  				b.Y = verts[i + floatStride + 1];  				b.Z = verts[i + floatStride + 2];    				c.X = verts[i + floatStride2];  				c.Y = verts[i + floatStride2 + 1];  				c.Z = verts[i + floatStride2 + 2];    				RasterizeTriangle(ref a' ref b' ref c' areas[j]);  			}
Magic Number,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTrianglesIndexed,The following statement contains a magic number: RasterizeTrianglesIndexed(verts' inds' 0' 1' 0' inds.Length / 3' Area.Default);
Magic Number,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTrianglesIndexed,The following statement contains a magic number: RasterizeTrianglesIndexed(verts' inds' 0' 1' 0' inds.Length / 3' area);
Magic Number,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTrianglesIndexed,The following statement contains a magic number: int indexEnd = triCount * 3 + indexOffset;
Magic Number,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTrianglesIndexed,The following statement contains a magic number: for (int i = indexOffset; i < indexEnd; i += 3)  			{  				int indA = inds[i] * vertStride + vertOffset;  				int indB = inds[i + 1] * vertStride + vertOffset;  				int indC = inds[i + 2] * vertStride + vertOffset;    				RasterizeTriangle(ref verts[indA]' ref verts[indB]' ref verts[indC]' area);  			}
Magic Number,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTrianglesIndexed,The following statement contains a magic number: for (int i = indexOffset; i < indexEnd; i += 3)  			{  				int indA = inds[i] * vertStride + vertOffset;  				int indB = inds[i + 1] * vertStride + vertOffset;  				int indC = inds[i + 2] * vertStride + vertOffset;    				RasterizeTriangle(ref verts[indA]' ref verts[indB]' ref verts[indC]' area);  			}
Magic Number,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTrianglesIndexed,The following statement contains a magic number: RasterizeTrianglesIndexed(verts' inds' 0' 3' 0' inds.Length / 3' Area.Default);
Magic Number,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTrianglesIndexed,The following statement contains a magic number: RasterizeTrianglesIndexed(verts' inds' 0' 3' 0' inds.Length / 3' Area.Default);
Magic Number,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTrianglesIndexed,The following statement contains a magic number: RasterizeTrianglesIndexed(verts' inds' 0' 3' 0' inds.Length / 3' area);
Magic Number,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTrianglesIndexed,The following statement contains a magic number: RasterizeTrianglesIndexed(verts' inds' 0' 3' 0' inds.Length / 3' area);
Magic Number,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTrianglesIndexed,The following statement contains a magic number: int indexEnd = triCount * 3 + indexOffset;
Magic Number,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTrianglesIndexed,The following statement contains a magic number: if (floatStride < 0)  				throw new ArgumentOutOfRangeException("floatStride"' "floatStride must be greater than or equal to 0.");  			else if (floatStride == 0)  				floatStride = 3;
Magic Number,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTrianglesIndexed,The following statement contains a magic number: for (int i = indexOffset; i < indexEnd; i += 3)  			{  				int indA = inds[i] * floatStride + floatOffset;  				int indB = inds[i + 1] * floatStride + floatOffset;  				int indC = inds[i + 2] * floatStride + floatOffset;    				a.X = verts[indA];  				a.Y = verts[indA + 1];  				a.Z = verts[indA + 2];    				b.X = verts[indB];  				b.Y = verts[indB + 1];  				b.Z = verts[indB + 2];    				c.X = verts[indC];  				c.Y = verts[indC + 1];  				c.Z = verts[indC + 2];    				RasterizeTriangle(ref a' ref b' ref c' area);  			}
Magic Number,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTrianglesIndexed,The following statement contains a magic number: for (int i = indexOffset; i < indexEnd; i += 3)  			{  				int indA = inds[i] * floatStride + floatOffset;  				int indB = inds[i + 1] * floatStride + floatOffset;  				int indC = inds[i + 2] * floatStride + floatOffset;    				a.X = verts[indA];  				a.Y = verts[indA + 1];  				a.Z = verts[indA + 2];    				b.X = verts[indB];  				b.Y = verts[indB + 1];  				b.Z = verts[indB + 2];    				c.X = verts[indC];  				c.Y = verts[indC + 1];  				c.Z = verts[indC + 2];    				RasterizeTriangle(ref a' ref b' ref c' area);  			}
Magic Number,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTrianglesIndexed,The following statement contains a magic number: for (int i = indexOffset; i < indexEnd; i += 3)  			{  				int indA = inds[i] * floatStride + floatOffset;  				int indB = inds[i + 1] * floatStride + floatOffset;  				int indC = inds[i + 2] * floatStride + floatOffset;    				a.X = verts[indA];  				a.Y = verts[indA + 1];  				a.Z = verts[indA + 2];    				b.X = verts[indB];  				b.Y = verts[indB + 1];  				b.Z = verts[indB + 2];    				c.X = verts[indC];  				c.Y = verts[indC + 1];  				c.Z = verts[indC + 2];    				RasterizeTriangle(ref a' ref b' ref c' area);  			}
Magic Number,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTrianglesIndexed,The following statement contains a magic number: for (int i = indexOffset; i < indexEnd; i += 3)  			{  				int indA = inds[i] * floatStride + floatOffset;  				int indB = inds[i + 1] * floatStride + floatOffset;  				int indC = inds[i + 2] * floatStride + floatOffset;    				a.X = verts[indA];  				a.Y = verts[indA + 1];  				a.Z = verts[indA + 2];    				b.X = verts[indB];  				b.Y = verts[indB + 1];  				b.Z = verts[indB + 2];    				c.X = verts[indC];  				c.Y = verts[indC + 1];  				c.Z = verts[indC + 2];    				RasterizeTriangle(ref a' ref b' ref c' area);  			}
Magic Number,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTrianglesIndexed,The following statement contains a magic number: for (int i = indexOffset; i < indexEnd; i += 3)  			{  				int indA = inds[i] * floatStride + floatOffset;  				int indB = inds[i + 1] * floatStride + floatOffset;  				int indC = inds[i + 2] * floatStride + floatOffset;    				a.X = verts[indA];  				a.Y = verts[indA + 1];  				a.Z = verts[indA + 2];    				b.X = verts[indB];  				b.Y = verts[indB + 1];  				b.Z = verts[indB + 2];    				c.X = verts[indC];  				c.Y = verts[indC + 1];  				c.Z = verts[indC + 2];    				RasterizeTriangle(ref a' ref b' ref c' area);  			}
Magic Number,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTriangles,The following statement contains a magic number: int numBatches = 8;
Magic Number,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTriangles,The following statement contains a magic number: RasterizeTriangles(verts' 0' 1' verts.Length / 3' Area.Default);
Magic Number,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTriangles,The following statement contains a magic number: RasterizeTriangles(verts' 0' 1' verts.Length / 3' area);
Magic Number,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTriangles,The following statement contains a magic number: Parallel.For(0' triCount' i =>  			{  				i = vertOffset + (i * vertStride * 3);  				RasterizeTriangle(ref verts[i]' ref verts[i + vertStride]' ref verts[i + vertStride * 2]' area);  			});
Magic Number,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTriangles,The following statement contains a magic number: Parallel.For(0' triCount' i =>  			{  				i = vertOffset + (i * vertStride * 3);  				RasterizeTriangle(ref verts[i]' ref verts[i + vertStride]' ref verts[i + vertStride * 2]' area);  			});
Magic Number,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTriangles,The following statement contains a magic number: RasterizeTriangles(verts' 0' 3' verts.Length / 9' Area.Default);
Magic Number,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTriangles,The following statement contains a magic number: RasterizeTriangles(verts' 0' 3' verts.Length / 9' Area.Default);
Magic Number,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTriangles,The following statement contains a magic number: RasterizeTriangles(verts' 0' 3' verts.Length / 9' area);
Magic Number,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTriangles,The following statement contains a magic number: RasterizeTriangles(verts' 0' 3' verts.Length / 9' area);
Magic Number,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTriangles,The following statement contains a magic number: int floatEnd = triCount * (floatStride * 3) + floatOffset;
Magic Number,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTriangles,The following statement contains a magic number: if (floatStride < 0)  				throw new ArgumentOutOfRangeException("floatStride"' "floatStride must be a positive integer.");  			else if (floatStride == 0)  				floatStride = 3;
Magic Number,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTriangles,The following statement contains a magic number: Parallel.For(0' triCount' i =>  			{  				i = floatOffset + (i * floatStride * 3);  				int floatStride2 = floatStride * 2;    				a.X = verts[i];  				a.Y = verts[i + 1];  				a.Z = verts[i + 2];    				b.X = verts[i + floatStride];  				b.Y = verts[i + floatStride + 1];  				b.Z = verts[i + floatStride + 2];    				c.X = verts[i + floatStride2];  				c.Y = verts[i + floatStride2 + 1];  				c.Z = verts[i + floatStride2 + 2];    				RasterizeTriangle(ref a' ref b' ref c' area);  			});
Magic Number,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTriangles,The following statement contains a magic number: Parallel.For(0' triCount' i =>  			{  				i = floatOffset + (i * floatStride * 3);  				int floatStride2 = floatStride * 2;    				a.X = verts[i];  				a.Y = verts[i + 1];  				a.Z = verts[i + 2];    				b.X = verts[i + floatStride];  				b.Y = verts[i + floatStride + 1];  				b.Z = verts[i + floatStride + 2];    				c.X = verts[i + floatStride2];  				c.Y = verts[i + floatStride2 + 1];  				c.Z = verts[i + floatStride2 + 2];    				RasterizeTriangle(ref a' ref b' ref c' area);  			});
Magic Number,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTriangles,The following statement contains a magic number: Parallel.For(0' triCount' i =>  			{  				i = floatOffset + (i * floatStride * 3);  				int floatStride2 = floatStride * 2;    				a.X = verts[i];  				a.Y = verts[i + 1];  				a.Z = verts[i + 2];    				b.X = verts[i + floatStride];  				b.Y = verts[i + floatStride + 1];  				b.Z = verts[i + floatStride + 2];    				c.X = verts[i + floatStride2];  				c.Y = verts[i + floatStride2 + 1];  				c.Z = verts[i + floatStride2 + 2];    				RasterizeTriangle(ref a' ref b' ref c' area);  			});
Magic Number,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTriangles,The following statement contains a magic number: Parallel.For(0' triCount' i =>  			{  				i = floatOffset + (i * floatStride * 3);  				int floatStride2 = floatStride * 2;    				a.X = verts[i];  				a.Y = verts[i + 1];  				a.Z = verts[i + 2];    				b.X = verts[i + floatStride];  				b.Y = verts[i + floatStride + 1];  				b.Z = verts[i + floatStride + 2];    				c.X = verts[i + floatStride2];  				c.Y = verts[i + floatStride2 + 1];  				c.Z = verts[i + floatStride2 + 2];    				RasterizeTriangle(ref a' ref b' ref c' area);  			});
Magic Number,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTriangles,The following statement contains a magic number: Parallel.For(0' triCount' i =>  			{  				i = floatOffset + (i * floatStride * 3);  				int floatStride2 = floatStride * 2;    				a.X = verts[i];  				a.Y = verts[i + 1];  				a.Z = verts[i + 2];    				b.X = verts[i + floatStride];  				b.Y = verts[i + floatStride + 1];  				b.Z = verts[i + floatStride + 2];    				c.X = verts[i + floatStride2];  				c.Y = verts[i + floatStride2 + 1];  				c.Z = verts[i + floatStride2 + 2];    				RasterizeTriangle(ref a' ref b' ref c' area);  			});
Magic Number,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTriangle,The following statement contains a magic number: float[] distances = new float[12];
Magic Number,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTriangle,The following statement contains a magic number: Vector3[] inVerts = new Vector3[7]' outVerts = new Vector3[7]' inRowVerts = new Vector3[7];
Magic Number,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTriangle,The following statement contains a magic number: Vector3[] inVerts = new Vector3[7]' outVerts = new Vector3[7]' inRowVerts = new Vector3[7];
Magic Number,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTriangle,The following statement contains a magic number: Vector3[] inVerts = new Vector3[7]' outVerts = new Vector3[7]' inRowVerts = new Vector3[7];
Magic Number,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTriangle,The following statement contains a magic number: for (int z = z0; z <= z1; z++)  			{  				//copy the original vertices to the array.  				inVerts[0] = a;  				inVerts[1] = b;  				inVerts[2] = c;    				//clip the triangle to the row  				int nvrow = 3;  				float cz = bounds.Min.Z + z * cellSize;  				nvrow = MathHelper.ClipPolygonToPlane(inVerts' outVerts' distances' nvrow' 0' 1' -cz);  				if (nvrow < 3)  					continue;  				nvrow = MathHelper.ClipPolygonToPlane(outVerts' inRowVerts' distances' nvrow' 0' -1' cz + cellSize);  				if (nvrow < 3)  					continue;    				float minX = inRowVerts[0].X' maxX = minX;  				for (int i = 1; i < nvrow; i++)  				{  					float vx = inRowVerts[i].X;  					if (minX > vx)  						minX = vx;  					if (maxX < vx)  						maxX = vx;  				}    				int x0 = (int)((minX - bounds.Min.X) * invCellSize);  				int x1 = (int)((maxX - bounds.Min.X) * invCellSize);    				MathHelper.Clamp(ref x0' 0' width - 1);  				MathHelper.Clamp(ref x1' 0' width - 1);    				for (int x = x0; x <= x1; x++)  				{  					//clip the triangle to the column  					int nv = nvrow;  					float cx = bounds.Min.X + x * cellSize;  					nv = MathHelper.ClipPolygonToPlane(inRowVerts' outVerts' distances' nv' 1' 0' -cx);  					if (nv < 3)  						continue;  					nv = MathHelper.ClipPolygonToPlane(outVerts' inVerts' distances' nv' -1' 0' cx + cellSize);  					if (nv < 3)  						continue;    					//calculate the min/max of the polygon  					float polyMin = inVerts[0].Y' polyMax = polyMin;  					for (int i = 1; i < nv; i++)  					{  						float y = inVerts[i].Y;  						polyMin = Math.Min(polyMin' y);  						polyMax = Math.Max(polyMax' y);  					}    					//normalize span bounds to bottom of heightfield  					float boundMinY = bounds.Min.Y;  					polyMin -= boundMinY;  					polyMax -= boundMinY;    					//if the spans are outside the heightfield' skip.  					if (polyMax < 0f || polyMin > boundHeight)  						continue;    					//clamp the span to the heightfield.  					if (polyMin < 0)  						polyMin = 0;  					if (polyMax > boundHeight)  						polyMax = boundHeight;    					//snap to grid  					int spanMin = (int)(polyMin * invCellHeight);  					int spanMax = (int)Math.Ceiling(polyMax * invCellHeight);    					//add the span  					cells[z * width + x].AddSpan(new Span(spanMin' spanMax' area));  				}  			}
Magic Number,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTriangle,The following statement contains a magic number: for (int z = z0; z <= z1; z++)  			{  				//copy the original vertices to the array.  				inVerts[0] = a;  				inVerts[1] = b;  				inVerts[2] = c;    				//clip the triangle to the row  				int nvrow = 3;  				float cz = bounds.Min.Z + z * cellSize;  				nvrow = MathHelper.ClipPolygonToPlane(inVerts' outVerts' distances' nvrow' 0' 1' -cz);  				if (nvrow < 3)  					continue;  				nvrow = MathHelper.ClipPolygonToPlane(outVerts' inRowVerts' distances' nvrow' 0' -1' cz + cellSize);  				if (nvrow < 3)  					continue;    				float minX = inRowVerts[0].X' maxX = minX;  				for (int i = 1; i < nvrow; i++)  				{  					float vx = inRowVerts[i].X;  					if (minX > vx)  						minX = vx;  					if (maxX < vx)  						maxX = vx;  				}    				int x0 = (int)((minX - bounds.Min.X) * invCellSize);  				int x1 = (int)((maxX - bounds.Min.X) * invCellSize);    				MathHelper.Clamp(ref x0' 0' width - 1);  				MathHelper.Clamp(ref x1' 0' width - 1);    				for (int x = x0; x <= x1; x++)  				{  					//clip the triangle to the column  					int nv = nvrow;  					float cx = bounds.Min.X + x * cellSize;  					nv = MathHelper.ClipPolygonToPlane(inRowVerts' outVerts' distances' nv' 1' 0' -cx);  					if (nv < 3)  						continue;  					nv = MathHelper.ClipPolygonToPlane(outVerts' inVerts' distances' nv' -1' 0' cx + cellSize);  					if (nv < 3)  						continue;    					//calculate the min/max of the polygon  					float polyMin = inVerts[0].Y' polyMax = polyMin;  					for (int i = 1; i < nv; i++)  					{  						float y = inVerts[i].Y;  						polyMin = Math.Min(polyMin' y);  						polyMax = Math.Max(polyMax' y);  					}    					//normalize span bounds to bottom of heightfield  					float boundMinY = bounds.Min.Y;  					polyMin -= boundMinY;  					polyMax -= boundMinY;    					//if the spans are outside the heightfield' skip.  					if (polyMax < 0f || polyMin > boundHeight)  						continue;    					//clamp the span to the heightfield.  					if (polyMin < 0)  						polyMin = 0;  					if (polyMax > boundHeight)  						polyMax = boundHeight;    					//snap to grid  					int spanMin = (int)(polyMin * invCellHeight);  					int spanMax = (int)Math.Ceiling(polyMax * invCellHeight);    					//add the span  					cells[z * width + x].AddSpan(new Span(spanMin' spanMax' area));  				}  			}
Magic Number,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTriangle,The following statement contains a magic number: for (int z = z0; z <= z1; z++)  			{  				//copy the original vertices to the array.  				inVerts[0] = a;  				inVerts[1] = b;  				inVerts[2] = c;    				//clip the triangle to the row  				int nvrow = 3;  				float cz = bounds.Min.Z + z * cellSize;  				nvrow = MathHelper.ClipPolygonToPlane(inVerts' outVerts' distances' nvrow' 0' 1' -cz);  				if (nvrow < 3)  					continue;  				nvrow = MathHelper.ClipPolygonToPlane(outVerts' inRowVerts' distances' nvrow' 0' -1' cz + cellSize);  				if (nvrow < 3)  					continue;    				float minX = inRowVerts[0].X' maxX = minX;  				for (int i = 1; i < nvrow; i++)  				{  					float vx = inRowVerts[i].X;  					if (minX > vx)  						minX = vx;  					if (maxX < vx)  						maxX = vx;  				}    				int x0 = (int)((minX - bounds.Min.X) * invCellSize);  				int x1 = (int)((maxX - bounds.Min.X) * invCellSize);    				MathHelper.Clamp(ref x0' 0' width - 1);  				MathHelper.Clamp(ref x1' 0' width - 1);    				for (int x = x0; x <= x1; x++)  				{  					//clip the triangle to the column  					int nv = nvrow;  					float cx = bounds.Min.X + x * cellSize;  					nv = MathHelper.ClipPolygonToPlane(inRowVerts' outVerts' distances' nv' 1' 0' -cx);  					if (nv < 3)  						continue;  					nv = MathHelper.ClipPolygonToPlane(outVerts' inVerts' distances' nv' -1' 0' cx + cellSize);  					if (nv < 3)  						continue;    					//calculate the min/max of the polygon  					float polyMin = inVerts[0].Y' polyMax = polyMin;  					for (int i = 1; i < nv; i++)  					{  						float y = inVerts[i].Y;  						polyMin = Math.Min(polyMin' y);  						polyMax = Math.Max(polyMax' y);  					}    					//normalize span bounds to bottom of heightfield  					float boundMinY = bounds.Min.Y;  					polyMin -= boundMinY;  					polyMax -= boundMinY;    					//if the spans are outside the heightfield' skip.  					if (polyMax < 0f || polyMin > boundHeight)  						continue;    					//clamp the span to the heightfield.  					if (polyMin < 0)  						polyMin = 0;  					if (polyMax > boundHeight)  						polyMax = boundHeight;    					//snap to grid  					int spanMin = (int)(polyMin * invCellHeight);  					int spanMax = (int)Math.Ceiling(polyMax * invCellHeight);    					//add the span  					cells[z * width + x].AddSpan(new Span(spanMin' spanMax' area));  				}  			}
Magic Number,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTriangle,The following statement contains a magic number: for (int z = z0; z <= z1; z++)  			{  				//copy the original vertices to the array.  				inVerts[0] = a;  				inVerts[1] = b;  				inVerts[2] = c;    				//clip the triangle to the row  				int nvrow = 3;  				float cz = bounds.Min.Z + z * cellSize;  				nvrow = MathHelper.ClipPolygonToPlane(inVerts' outVerts' distances' nvrow' 0' 1' -cz);  				if (nvrow < 3)  					continue;  				nvrow = MathHelper.ClipPolygonToPlane(outVerts' inRowVerts' distances' nvrow' 0' -1' cz + cellSize);  				if (nvrow < 3)  					continue;    				float minX = inRowVerts[0].X' maxX = minX;  				for (int i = 1; i < nvrow; i++)  				{  					float vx = inRowVerts[i].X;  					if (minX > vx)  						minX = vx;  					if (maxX < vx)  						maxX = vx;  				}    				int x0 = (int)((minX - bounds.Min.X) * invCellSize);  				int x1 = (int)((maxX - bounds.Min.X) * invCellSize);    				MathHelper.Clamp(ref x0' 0' width - 1);  				MathHelper.Clamp(ref x1' 0' width - 1);    				for (int x = x0; x <= x1; x++)  				{  					//clip the triangle to the column  					int nv = nvrow;  					float cx = bounds.Min.X + x * cellSize;  					nv = MathHelper.ClipPolygonToPlane(inRowVerts' outVerts' distances' nv' 1' 0' -cx);  					if (nv < 3)  						continue;  					nv = MathHelper.ClipPolygonToPlane(outVerts' inVerts' distances' nv' -1' 0' cx + cellSize);  					if (nv < 3)  						continue;    					//calculate the min/max of the polygon  					float polyMin = inVerts[0].Y' polyMax = polyMin;  					for (int i = 1; i < nv; i++)  					{  						float y = inVerts[i].Y;  						polyMin = Math.Min(polyMin' y);  						polyMax = Math.Max(polyMax' y);  					}    					//normalize span bounds to bottom of heightfield  					float boundMinY = bounds.Min.Y;  					polyMin -= boundMinY;  					polyMax -= boundMinY;    					//if the spans are outside the heightfield' skip.  					if (polyMax < 0f || polyMin > boundHeight)  						continue;    					//clamp the span to the heightfield.  					if (polyMin < 0)  						polyMin = 0;  					if (polyMax > boundHeight)  						polyMax = boundHeight;    					//snap to grid  					int spanMin = (int)(polyMin * invCellHeight);  					int spanMax = (int)Math.Ceiling(polyMax * invCellHeight);    					//add the span  					cells[z * width + x].AddSpan(new Span(spanMin' spanMax' area));  				}  			}
Magic Number,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTriangle,The following statement contains a magic number: for (int z = z0; z <= z1; z++)  			{  				//copy the original vertices to the array.  				inVerts[0] = a;  				inVerts[1] = b;  				inVerts[2] = c;    				//clip the triangle to the row  				int nvrow = 3;  				float cz = bounds.Min.Z + z * cellSize;  				nvrow = MathHelper.ClipPolygonToPlane(inVerts' outVerts' distances' nvrow' 0' 1' -cz);  				if (nvrow < 3)  					continue;  				nvrow = MathHelper.ClipPolygonToPlane(outVerts' inRowVerts' distances' nvrow' 0' -1' cz + cellSize);  				if (nvrow < 3)  					continue;    				float minX = inRowVerts[0].X' maxX = minX;  				for (int i = 1; i < nvrow; i++)  				{  					float vx = inRowVerts[i].X;  					if (minX > vx)  						minX = vx;  					if (maxX < vx)  						maxX = vx;  				}    				int x0 = (int)((minX - bounds.Min.X) * invCellSize);  				int x1 = (int)((maxX - bounds.Min.X) * invCellSize);    				MathHelper.Clamp(ref x0' 0' width - 1);  				MathHelper.Clamp(ref x1' 0' width - 1);    				for (int x = x0; x <= x1; x++)  				{  					//clip the triangle to the column  					int nv = nvrow;  					float cx = bounds.Min.X + x * cellSize;  					nv = MathHelper.ClipPolygonToPlane(inRowVerts' outVerts' distances' nv' 1' 0' -cx);  					if (nv < 3)  						continue;  					nv = MathHelper.ClipPolygonToPlane(outVerts' inVerts' distances' nv' -1' 0' cx + cellSize);  					if (nv < 3)  						continue;    					//calculate the min/max of the polygon  					float polyMin = inVerts[0].Y' polyMax = polyMin;  					for (int i = 1; i < nv; i++)  					{  						float y = inVerts[i].Y;  						polyMin = Math.Min(polyMin' y);  						polyMax = Math.Max(polyMax' y);  					}    					//normalize span bounds to bottom of heightfield  					float boundMinY = bounds.Min.Y;  					polyMin -= boundMinY;  					polyMax -= boundMinY;    					//if the spans are outside the heightfield' skip.  					if (polyMax < 0f || polyMin > boundHeight)  						continue;    					//clamp the span to the heightfield.  					if (polyMin < 0)  						polyMin = 0;  					if (polyMax > boundHeight)  						polyMax = boundHeight;    					//snap to grid  					int spanMin = (int)(polyMin * invCellHeight);  					int spanMax = (int)Math.Ceiling(polyMax * invCellHeight);    					//add the span  					cells[z * width + x].AddSpan(new Span(spanMin' spanMax' area));  				}  			}
Magic Number,SharpNav,Heightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\Heightfield.Rasterization.cs,RasterizeTriangle,The following statement contains a magic number: for (int z = z0; z <= z1; z++)  			{  				//copy the original vertices to the array.  				inVerts[0] = a;  				inVerts[1] = b;  				inVerts[2] = c;    				//clip the triangle to the row  				int nvrow = 3;  				float cz = bounds.Min.Z + z * cellSize;  				nvrow = MathHelper.ClipPolygonToPlane(inVerts' outVerts' distances' nvrow' 0' 1' -cz);  				if (nvrow < 3)  					continue;  				nvrow = MathHelper.ClipPolygonToPlane(outVerts' inRowVerts' distances' nvrow' 0' -1' cz + cellSize);  				if (nvrow < 3)  					continue;    				float minX = inRowVerts[0].X' maxX = minX;  				for (int i = 1; i < nvrow; i++)  				{  					float vx = inRowVerts[i].X;  					if (minX > vx)  						minX = vx;  					if (maxX < vx)  						maxX = vx;  				}    				int x0 = (int)((minX - bounds.Min.X) * invCellSize);  				int x1 = (int)((maxX - bounds.Min.X) * invCellSize);    				MathHelper.Clamp(ref x0' 0' width - 1);  				MathHelper.Clamp(ref x1' 0' width - 1);    				for (int x = x0; x <= x1; x++)  				{  					//clip the triangle to the column  					int nv = nvrow;  					float cx = bounds.Min.X + x * cellSize;  					nv = MathHelper.ClipPolygonToPlane(inRowVerts' outVerts' distances' nv' 1' 0' -cx);  					if (nv < 3)  						continue;  					nv = MathHelper.ClipPolygonToPlane(outVerts' inVerts' distances' nv' -1' 0' cx + cellSize);  					if (nv < 3)  						continue;    					//calculate the min/max of the polygon  					float polyMin = inVerts[0].Y' polyMax = polyMin;  					for (int i = 1; i < nv; i++)  					{  						float y = inVerts[i].Y;  						polyMin = Math.Min(polyMin' y);  						polyMax = Math.Max(polyMax' y);  					}    					//normalize span bounds to bottom of heightfield  					float boundMinY = bounds.Min.Y;  					polyMin -= boundMinY;  					polyMax -= boundMinY;    					//if the spans are outside the heightfield' skip.  					if (polyMax < 0f || polyMin > boundHeight)  						continue;    					//clamp the span to the heightfield.  					if (polyMin < 0)  						polyMin = 0;  					if (polyMax > boundHeight)  						polyMax = boundHeight;    					//snap to grid  					int spanMin = (int)(polyMin * invCellHeight);  					int spanMax = (int)Math.Ceiling(polyMax * invCellHeight);    					//add the span  					cells[z * width + x].AddSpan(new Span(spanMin' spanMax' area));  				}  			}
Magic Number,SharpNav,NavMesh,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMesh.cs,Generate,The following statement contains a magic number: chf.BuildRegions(2' settings.MinRegionSize' settings.MergedRegionSize);
Magic Number,SharpNav,PolyMesh,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyMesh.cs,PolyMesh,The following statement contains a magic number: var vertDict = new Dictionary<PolyVertex' int>(new PolyVertex.RoughYEqualityComparer(2));
Magic Number,SharpNav,PolyMesh,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyMesh.cs,PolyMesh,The following statement contains a magic number: foreach (Contour cont in contSet)  			{  				//skip null contours  				if (cont.IsNull)  					continue;    				PolyVertex[] vertices = new PolyVertex[cont.Vertices.Length];    				//triangulate contours  				for (int i = 0; i < cont.Vertices.Length; i++)  				{  					var cv = cont.Vertices[i];  					vertices[i] = new PolyVertex(cv.X' cv.Y' cv.Z);  					indices[i] = i;  				}    				//Form triangles inside the area bounded by the contours  				int ntris = Triangulate(cont.Vertices.Length' vertices' indices' tris);  				if (ntris <= 0) //TODO notify user when this happens. Logging?  				{  					Console.WriteLine("ntris <= 0");  					ntris = -ntris;  				}    				//add and merge vertices  				for (int i = 0; i < cont.Vertices.Length; i++)  				{  					var cv = cont.Vertices[i];  					var pv = vertices[i];    					//save the hash code for each vertex  					indices[i] = AddVertex(vertDict' pv' verts);    					if (RegionId.HasFlags(cv.RegionId' RegionFlags.VertexBorder))  					{  						//the vertex should be removed  						vertRemoveQueue.Enqueue(indices[i]);  					}  				}    				contPolys.Clear();    				//iterate through all the triangles  				for (int i = 0; i < ntris; i++)  				{  					Triangle ti = tris[i];    					//make sure there are three distinct vertices. anything less can't be a polygon.  					if (ti.Index0 == ti.Index1  						|| ti.Index0 == ti.Index2  						|| ti.Index1 == ti.Index2)  						continue;    					//each polygon has numVertsPerPoly  					//index 0' 1' 2 store triangle vertices  					//other polygon indexes (3 to numVertsPerPoly - 1) should be used for storing extra vertices when two polygons merge together  					Polygon p = new Polygon(numVertsPerPoly' Area.Null' RegionId.Null);  					p.Vertices[0] = RemoveDiagonalFlag(indices[ti.Index0]);  					p.Vertices[1] = RemoveDiagonalFlag(indices[ti.Index1]);  					p.Vertices[2] = RemoveDiagonalFlag(indices[ti.Index2]);  					contPolys.Add(p);  				}  				  				//no polygons generated' so skip  				if (contPolys.Count == 0)  					continue;    				//merge polygons  				if (numVertsPerPoly > 3)  				{  					while (true)  					{  						//find best polygons  						int bestMergeVal = 0;  						int bestPolyA = 0' bestPolyB = 0' bestEdgeA = 0' bestEdgeB = 0;    						for (int i = 0; i < contPolys.Count - 1; i++)  						{  							int pj = i;    							for (int j = i + 1; j < contPolys.Count; j++)  							{  								int pk = j;  								int ea = 0' eb = 0;  								int v = GetPolyMergeValue(contPolys' pj' pk' verts' out ea' out eb);  								if (v > bestMergeVal)  								{  									bestMergeVal = v;  									bestPolyA = i;  									bestPolyB = j;  									bestEdgeA = ea;  									bestEdgeB = eb;  								}  							}  						}    						if (bestMergeVal <= 0)  							break;    						Polygon pa = contPolys[bestPolyA];  						Polygon pb = contPolys[bestPolyB];  						pa.MergeWith(pb' bestEdgeA' bestEdgeB' mergeTemp);  						contPolys[bestPolyB] = contPolys[contPolys.Count - 1];  						contPolys.RemoveAt(contPolys.Count - 1);    					}  				}    				//store polygons  				for (int i = 0; i < contPolys.Count; i++)  				{  					Polygon p = contPolys[i];  					Polygon p2 = new Polygon(numVertsPerPoly' cont.Area' cont.RegionId);    					Buffer.BlockCopy(p.Vertices' 0' p2.Vertices' 0' numVertsPerPoly * sizeof(int));    					polys.Add(p2);  				}  			}
Magic Number,SharpNav,PolyMesh,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyMesh.cs,PolyMesh,The following statement contains a magic number: foreach (Contour cont in contSet)  			{  				//skip null contours  				if (cont.IsNull)  					continue;    				PolyVertex[] vertices = new PolyVertex[cont.Vertices.Length];    				//triangulate contours  				for (int i = 0; i < cont.Vertices.Length; i++)  				{  					var cv = cont.Vertices[i];  					vertices[i] = new PolyVertex(cv.X' cv.Y' cv.Z);  					indices[i] = i;  				}    				//Form triangles inside the area bounded by the contours  				int ntris = Triangulate(cont.Vertices.Length' vertices' indices' tris);  				if (ntris <= 0) //TODO notify user when this happens. Logging?  				{  					Console.WriteLine("ntris <= 0");  					ntris = -ntris;  				}    				//add and merge vertices  				for (int i = 0; i < cont.Vertices.Length; i++)  				{  					var cv = cont.Vertices[i];  					var pv = vertices[i];    					//save the hash code for each vertex  					indices[i] = AddVertex(vertDict' pv' verts);    					if (RegionId.HasFlags(cv.RegionId' RegionFlags.VertexBorder))  					{  						//the vertex should be removed  						vertRemoveQueue.Enqueue(indices[i]);  					}  				}    				contPolys.Clear();    				//iterate through all the triangles  				for (int i = 0; i < ntris; i++)  				{  					Triangle ti = tris[i];    					//make sure there are three distinct vertices. anything less can't be a polygon.  					if (ti.Index0 == ti.Index1  						|| ti.Index0 == ti.Index2  						|| ti.Index1 == ti.Index2)  						continue;    					//each polygon has numVertsPerPoly  					//index 0' 1' 2 store triangle vertices  					//other polygon indexes (3 to numVertsPerPoly - 1) should be used for storing extra vertices when two polygons merge together  					Polygon p = new Polygon(numVertsPerPoly' Area.Null' RegionId.Null);  					p.Vertices[0] = RemoveDiagonalFlag(indices[ti.Index0]);  					p.Vertices[1] = RemoveDiagonalFlag(indices[ti.Index1]);  					p.Vertices[2] = RemoveDiagonalFlag(indices[ti.Index2]);  					contPolys.Add(p);  				}  				  				//no polygons generated' so skip  				if (contPolys.Count == 0)  					continue;    				//merge polygons  				if (numVertsPerPoly > 3)  				{  					while (true)  					{  						//find best polygons  						int bestMergeVal = 0;  						int bestPolyA = 0' bestPolyB = 0' bestEdgeA = 0' bestEdgeB = 0;    						for (int i = 0; i < contPolys.Count - 1; i++)  						{  							int pj = i;    							for (int j = i + 1; j < contPolys.Count; j++)  							{  								int pk = j;  								int ea = 0' eb = 0;  								int v = GetPolyMergeValue(contPolys' pj' pk' verts' out ea' out eb);  								if (v > bestMergeVal)  								{  									bestMergeVal = v;  									bestPolyA = i;  									bestPolyB = j;  									bestEdgeA = ea;  									bestEdgeB = eb;  								}  							}  						}    						if (bestMergeVal <= 0)  							break;    						Polygon pa = contPolys[bestPolyA];  						Polygon pb = contPolys[bestPolyB];  						pa.MergeWith(pb' bestEdgeA' bestEdgeB' mergeTemp);  						contPolys[bestPolyB] = contPolys[contPolys.Count - 1];  						contPolys.RemoveAt(contPolys.Count - 1);    					}  				}    				//store polygons  				for (int i = 0; i < contPolys.Count; i++)  				{  					Polygon p = contPolys[i];  					Polygon p2 = new Polygon(numVertsPerPoly' cont.Area' cont.RegionId);    					Buffer.BlockCopy(p.Vertices' 0' p2.Vertices' 0' numVertsPerPoly * sizeof(int));    					polys.Add(p2);  				}  			}
Magic Number,SharpNav,PolyMesh,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyMesh.cs,PolyMesh,The following statement contains a magic number: if (this.borderSize > 0)  			{  				//iterate through all the polygons  				for (int i = 0; i < polys.Count; i++)  				{  					Polygon p = polys[i];    					//iterate through all the vertices  					for (int j = 0; j < numVertsPerPoly; j++)  					{  						if (p.Vertices[j] == NullId)  							break;    						//skip connected edges  						if (p.NeighborEdges[j] != NullId)  							continue;    						int nj = j + 1;  						if (nj >= numVertsPerPoly || p.Vertices[nj] == NullId)  							nj = 0;    						//grab two consecutive vertices  						int va = p.Vertices[j];  						int vb = p.Vertices[nj];    						//set some flags  						if (verts[va].X == 0 && verts[vb].X == 0)  							p.NeighborEdges[j] = NeighborEdgeFlag | 0;  						else if (verts[va].Z == contSet.Height && verts[vb].Z == contSet.Height)  							p.NeighborEdges[j] = NeighborEdgeFlag | 1;  						else if (verts[va].X == contSet.Width && verts[vb].X == contSet.Width)  							p.NeighborEdges[j] = NeighborEdgeFlag | 2;  						else if (verts[va].Z == 0 && verts[vb].Z == 0)  							p.NeighborEdges[j] = NeighborEdgeFlag | 3;  					}  				}  			}
Magic Number,SharpNav,PolyMesh,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyMesh.cs,PolyMesh,The following statement contains a magic number: if (this.borderSize > 0)  			{  				//iterate through all the polygons  				for (int i = 0; i < polys.Count; i++)  				{  					Polygon p = polys[i];    					//iterate through all the vertices  					for (int j = 0; j < numVertsPerPoly; j++)  					{  						if (p.Vertices[j] == NullId)  							break;    						//skip connected edges  						if (p.NeighborEdges[j] != NullId)  							continue;    						int nj = j + 1;  						if (nj >= numVertsPerPoly || p.Vertices[nj] == NullId)  							nj = 0;    						//grab two consecutive vertices  						int va = p.Vertices[j];  						int vb = p.Vertices[nj];    						//set some flags  						if (verts[va].X == 0 && verts[vb].X == 0)  							p.NeighborEdges[j] = NeighborEdgeFlag | 0;  						else if (verts[va].Z == contSet.Height && verts[vb].Z == contSet.Height)  							p.NeighborEdges[j] = NeighborEdgeFlag | 1;  						else if (verts[va].X == contSet.Width && verts[vb].X == contSet.Width)  							p.NeighborEdges[j] = NeighborEdgeFlag | 2;  						else if (verts[va].Z == 0 && verts[vb].Z == 0)  							p.NeighborEdges[j] = NeighborEdgeFlag | 3;  					}  				}  			}
Magic Number,SharpNav,PolyMesh,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyMesh.cs,Triangulate,The following statement contains a magic number: while (n > 3)  			{  				//find the minimum distance betwee two vertices.   				//also' save their index  				int minLen = -1;  				int minIndex = -1;  				for (int i = 0; i < n; i++)  				{  					int i1 = Next(i' n);  					  					if (HasDiagonalFlag(indices[i1]))  					{  						int p0 = RemoveDiagonalFlag(indices[i]);  						int p2 = RemoveDiagonalFlag(indices[Next(i1' n)]);    						int dx = verts[p2].X - verts[p0].X;  						int dy = verts[p2].Z - verts[p0].Z;  						int len = dx * dx + dy * dy;    						if (minLen < 0 || len < minLen)  						{  							minLen = len;  							minIndex = i;  						}  					}  				}    				if (minIndex == -1)  				{  					minLen = -1;  					minIndex = -1;  					for (int i = 0; i < n; i++)  					{  						int i1 = Next(i' n);  						int i2 = Next(i1' n);  						if (DiagonalLoose(i' i2' verts' indices))  						{  							int p0 = RemoveDiagonalFlag(indices[i]);  							int p2 = RemoveDiagonalFlag(indices[Next(i2' n)]);    							int dx = verts[p2].X - verts[p0].X;  							int dy = verts[p2].Z - verts[p0].Z;  							int len = dx * dx + dy * dy;  							if (minLen < 0 || len < minLen)  							{  								minLen = len;  								minIndex = i;  							}  						}  					}    					//really messed up  					if (minIndex == -1)  						return -ntris;  				}    				int mi = minIndex;  				int mi1 = Next(mi' n);  				int mi2 = Next(mi1' n);    				tris[ntris] = new Triangle();  				tris[ntris].Index0 = RemoveDiagonalFlag(indices[mi]);  				tris[ntris].Index1 = RemoveDiagonalFlag(indices[mi1]);  				tris[ntris].Index2 = RemoveDiagonalFlag(indices[mi2]);  				ntris++;    				//remove P[i1]  				n--;  				for (int k = mi1; k < n; k++)  					indices[k] = indices[k + 1];    				if (mi1 >= n) mi1 = 0;  				mi = Prev(mi1' n);    				//update diagonal flags  				if (Diagonal(Prev(mi' n)' mi1' verts' indices))  				{  					SetDiagonalFlag(ref indices[mi]);  				}  				else  				{  					RemoveDiagonalFlag(ref indices[mi]);  				}    				if (Diagonal(mi' Next(mi1' n)' verts' indices))  				{  					SetDiagonalFlag(ref indices[mi1]);  				}  				else  				{  					RemoveDiagonalFlag(ref indices[mi1]);  				}  			}
Magic Number,SharpNav,PolyMesh,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyMesh.cs,Triangulate,The following statement contains a magic number: tris[ntris].Index2 = RemoveDiagonalFlag(indices[2]);
Magic Number,SharpNav,PolyMesh,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyMesh.cs,GetPolyMergeValue,The following statement contains a magic number: if (numVertsA + numVertsB - 2 > polys[polyA].Vertices.Length)  				return -1;
Magic Number,SharpNav,PolyMesh,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyMesh.cs,GetPolyMergeValue,The following statement contains a magic number: vertC = polys[polyB].Vertices[(edgeB + 2) % numVertsB];
Magic Number,SharpNav,PolyMesh,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyMesh.cs,GetPolyMergeValue,The following statement contains a magic number: vertC = polys[polyA].Vertices[(edgeA + 2) % numVertsA];
Magic Number,SharpNav,PolyMesh,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyMesh.cs,CanRemoveVertex,The following statement contains a magic number: if (numRemainingEdges <= 2)  				return false;
Magic Number,SharpNav,PolyMesh,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyMesh.cs,CanRemoveVertex,The following statement contains a magic number: int maxEdges = numTouchedVerts * 2;
Magic Number,SharpNav,PolyMesh,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyMesh.cs,CanRemoveVertex,The following statement contains a magic number: int[] edges = new int[maxEdges * 3];
Magic Number,SharpNav,PolyMesh,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyMesh.cs,CanRemoveVertex,The following statement contains a magic number: for (int i = 0; i < polys.Count; i++)  			{  				Polygon p = polys[i];  				int nv = p.VertexCount;    				//collect edges which touch removed vertex  				for (int j = 0' k = nv - 1; j < nv; k = j++)  				{  					if (p.Vertices[j] == remove || p.Vertices[k] == remove)  					{  						//arrange edge so that a has the removed value  						int a = p.Vertices[j]' b = p.Vertices[k];  						if (b == remove)  						{  							int temp = a;  							a = b;  							b = temp;  						}    						//check if edge exists  						bool exists = false;  						for (int m = 0; m < nedges; m++)  						{  							int e = m * 3;  							if (edges[e + 1] == b)  							{  								//increment vertex share count  								edges[e + 2]++;  								exists = true;  							}  						}    						//add new edge  						if (!exists)  						{  							int e = nedges * 3;  							edges[e + 0] = a;  							edges[e + 1] = b;  							edges[e + 2] = 1;  							nedges++;  						}  					}  				}  			}
Magic Number,SharpNav,PolyMesh,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyMesh.cs,CanRemoveVertex,The following statement contains a magic number: for (int i = 0; i < polys.Count; i++)  			{  				Polygon p = polys[i];  				int nv = p.VertexCount;    				//collect edges which touch removed vertex  				for (int j = 0' k = nv - 1; j < nv; k = j++)  				{  					if (p.Vertices[j] == remove || p.Vertices[k] == remove)  					{  						//arrange edge so that a has the removed value  						int a = p.Vertices[j]' b = p.Vertices[k];  						if (b == remove)  						{  							int temp = a;  							a = b;  							b = temp;  						}    						//check if edge exists  						bool exists = false;  						for (int m = 0; m < nedges; m++)  						{  							int e = m * 3;  							if (edges[e + 1] == b)  							{  								//increment vertex share count  								edges[e + 2]++;  								exists = true;  							}  						}    						//add new edge  						if (!exists)  						{  							int e = nedges * 3;  							edges[e + 0] = a;  							edges[e + 1] = b;  							edges[e + 2] = 1;  							nedges++;  						}  					}  				}  			}
Magic Number,SharpNav,PolyMesh,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyMesh.cs,CanRemoveVertex,The following statement contains a magic number: for (int i = 0; i < polys.Count; i++)  			{  				Polygon p = polys[i];  				int nv = p.VertexCount;    				//collect edges which touch removed vertex  				for (int j = 0' k = nv - 1; j < nv; k = j++)  				{  					if (p.Vertices[j] == remove || p.Vertices[k] == remove)  					{  						//arrange edge so that a has the removed value  						int a = p.Vertices[j]' b = p.Vertices[k];  						if (b == remove)  						{  							int temp = a;  							a = b;  							b = temp;  						}    						//check if edge exists  						bool exists = false;  						for (int m = 0; m < nedges; m++)  						{  							int e = m * 3;  							if (edges[e + 1] == b)  							{  								//increment vertex share count  								edges[e + 2]++;  								exists = true;  							}  						}    						//add new edge  						if (!exists)  						{  							int e = nedges * 3;  							edges[e + 0] = a;  							edges[e + 1] = b;  							edges[e + 2] = 1;  							nedges++;  						}  					}  				}  			}
Magic Number,SharpNav,PolyMesh,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyMesh.cs,CanRemoveVertex,The following statement contains a magic number: for (int i = 0; i < polys.Count; i++)  			{  				Polygon p = polys[i];  				int nv = p.VertexCount;    				//collect edges which touch removed vertex  				for (int j = 0' k = nv - 1; j < nv; k = j++)  				{  					if (p.Vertices[j] == remove || p.Vertices[k] == remove)  					{  						//arrange edge so that a has the removed value  						int a = p.Vertices[j]' b = p.Vertices[k];  						if (b == remove)  						{  							int temp = a;  							a = b;  							b = temp;  						}    						//check if edge exists  						bool exists = false;  						for (int m = 0; m < nedges; m++)  						{  							int e = m * 3;  							if (edges[e + 1] == b)  							{  								//increment vertex share count  								edges[e + 2]++;  								exists = true;  							}  						}    						//add new edge  						if (!exists)  						{  							int e = nedges * 3;  							edges[e + 0] = a;  							edges[e + 1] = b;  							edges[e + 2] = 1;  							nedges++;  						}  					}  				}  			}
Magic Number,SharpNav,PolyMesh,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyMesh.cs,CanRemoveVertex,The following statement contains a magic number: for (int i = 0; i < nedges; i++)  			{  				if (edges[i * 3 + 2] < 2)  					numOpenEdges++;  			}
Magic Number,SharpNav,PolyMesh,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyMesh.cs,CanRemoveVertex,The following statement contains a magic number: for (int i = 0; i < nedges; i++)  			{  				if (edges[i * 3 + 2] < 2)  					numOpenEdges++;  			}
Magic Number,SharpNav,PolyMesh,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyMesh.cs,CanRemoveVertex,The following statement contains a magic number: for (int i = 0; i < nedges; i++)  			{  				if (edges[i * 3 + 2] < 2)  					numOpenEdges++;  			}
Magic Number,SharpNav,PolyMesh,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyMesh.cs,CanRemoveVertex,The following statement contains a magic number: if (numOpenEdges > 2)  				return false;
Magic Number,SharpNav,PolyMesh,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyMesh.cs,RemoveVertex,The following statement contains a magic number: for (int j = 0; j < ntris; j++)  			{  				Triangle t = tris[j];  				if (t.Index0 != t.Index1 && t.Index0 != t.Index2 && t.Index1 != t.Index2)  				{  					Polygon p = new Polygon(numVertsPerPoly' areas[t.Index0]' regions[t.Index0]);  					p.Vertices[0] = hole[t.Index0];  					p.Vertices[1] = hole[t.Index1];  					p.Vertices[2] = hole[t.Index2];  					mergePolys.Add(p);  				}  			}
Magic Number,SharpNav,PolyMesh,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyMesh.cs,RemoveVertex,The following statement contains a magic number: if (numVertsPerPoly > 3)  			{  				while (true)  				{  					//find best polygons  					int bestMergeVal = 0;  					int bestPolyA = 0' bestPolyB = 0' bestEa = 0' bestEb = 0;    					for (int j = 0; j < mergePolys.Count - 1; j++)  					{  						int pj = j;  						for (int k = j + 1; k < mergePolys.Count; k++)  						{  							int pk = k;  							int edgeA' edgeB;  							int v = GetPolyMergeValue(mergePolys' pj' pk' verts' out edgeA' out edgeB);  							if (v > bestMergeVal)  							{  								bestMergeVal = v;  								bestPolyA = j;  								bestPolyB = k;  								bestEa = edgeA;  								bestEb = edgeB;  							}  						}  					}    					if (bestMergeVal <= 0)  						break;    					Polygon pa = mergePolys[bestPolyA];  					Polygon pb = mergePolys[bestPolyB];  					pa.MergeWith(pb' bestEa' bestEb' mergeTemp);  					mergePolys[bestPolyB] = mergePolys[mergePolys.Count - 1];  					mergePolys.RemoveAt(mergePolys.Count - 1);  				}  			}
Magic Number,SharpNav,NavMeshBuilder,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshBuilder.cs,NavMeshBuilder,The following statement contains a magic number: BoundarySide[] offMeshSides = new BoundarySide[offMeshCons.Length * 2];
Magic Number,SharpNav,NavMeshBuilder,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshBuilder.cs,NavMeshBuilder,The following statement contains a magic number: if (offMeshCons.Length > 0)  			{  				//find height bounds  				float hmin = float.MaxValue;  				float hmax = -float.MaxValue;    				if (polyMeshDetail != null)  				{  					for (int i = 0; i < polyMeshDetail.VertCount; i++)  					{  						float h = polyMeshDetail.Verts[i].Y;  						hmin = Math.Min(hmin' h);  						hmax = Math.Max(hmax' h);  					}  				}  				else  				{  					for (int i = 0; i < polyMesh.VertCount; i++)  					{  						PolyVertex iv = polyMesh.Verts[i];  						float h = polyMesh.Bounds.Min.Y + iv.Y * settings.CellHeight;  						hmin = Math.Min(hmin' h);  						hmax = Math.Max(hmax' h);  					}  				}    				hmin -= settings.MaxClimb;  				hmax += settings.MaxClimb;  				BBox3 bounds = polyMesh.Bounds;  				bounds.Min.Y = hmin;  				bounds.Max.Y = hmax;    				for (int i = 0; i < offMeshCons.Length; i++)  				{  					Vector3 p0 = offMeshCons[i].Pos0;  					Vector3 p1 = offMeshCons[i].Pos1;    					offMeshSides[i * 2 + 0] = BoundarySideExtensions.FromPoint(p0' bounds);  					offMeshSides[i * 2 + 1] = BoundarySideExtensions.FromPoint(p1' bounds);    					//off-mesh start position isn't touching mesh  					if (offMeshSides[i * 2 + 0] == BoundarySide.Internal)  					{  						if (p0.Y < bounds.Min.Y || p0.Y > bounds.Max.Y)  							offMeshSides[i * 2 + 0] = 0;  					}    					//count number of links to allocate  					if (offMeshSides[i * 2 + 0] == BoundarySide.Internal)  						offMeshConLinkCount++;  					if (offMeshSides[i * 2 + 1] == BoundarySide.Internal)  						offMeshConLinkCount++;    					if (offMeshSides[i * 2 + 0] == BoundarySide.Internal)  						storedOffMeshConCount++;  				}  			}
Magic Number,SharpNav,NavMeshBuilder,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshBuilder.cs,NavMeshBuilder,The following statement contains a magic number: if (offMeshCons.Length > 0)  			{  				//find height bounds  				float hmin = float.MaxValue;  				float hmax = -float.MaxValue;    				if (polyMeshDetail != null)  				{  					for (int i = 0; i < polyMeshDetail.VertCount; i++)  					{  						float h = polyMeshDetail.Verts[i].Y;  						hmin = Math.Min(hmin' h);  						hmax = Math.Max(hmax' h);  					}  				}  				else  				{  					for (int i = 0; i < polyMesh.VertCount; i++)  					{  						PolyVertex iv = polyMesh.Verts[i];  						float h = polyMesh.Bounds.Min.Y + iv.Y * settings.CellHeight;  						hmin = Math.Min(hmin' h);  						hmax = Math.Max(hmax' h);  					}  				}    				hmin -= settings.MaxClimb;  				hmax += settings.MaxClimb;  				BBox3 bounds = polyMesh.Bounds;  				bounds.Min.Y = hmin;  				bounds.Max.Y = hmax;    				for (int i = 0; i < offMeshCons.Length; i++)  				{  					Vector3 p0 = offMeshCons[i].Pos0;  					Vector3 p1 = offMeshCons[i].Pos1;    					offMeshSides[i * 2 + 0] = BoundarySideExtensions.FromPoint(p0' bounds);  					offMeshSides[i * 2 + 1] = BoundarySideExtensions.FromPoint(p1' bounds);    					//off-mesh start position isn't touching mesh  					if (offMeshSides[i * 2 + 0] == BoundarySide.Internal)  					{  						if (p0.Y < bounds.Min.Y || p0.Y > bounds.Max.Y)  							offMeshSides[i * 2 + 0] = 0;  					}    					//count number of links to allocate  					if (offMeshSides[i * 2 + 0] == BoundarySide.Internal)  						offMeshConLinkCount++;  					if (offMeshSides[i * 2 + 1] == BoundarySide.Internal)  						offMeshConLinkCount++;    					if (offMeshSides[i * 2 + 0] == BoundarySide.Internal)  						storedOffMeshConCount++;  				}  			}
Magic Number,SharpNav,NavMeshBuilder,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshBuilder.cs,NavMeshBuilder,The following statement contains a magic number: if (offMeshCons.Length > 0)  			{  				//find height bounds  				float hmin = float.MaxValue;  				float hmax = -float.MaxValue;    				if (polyMeshDetail != null)  				{  					for (int i = 0; i < polyMeshDetail.VertCount; i++)  					{  						float h = polyMeshDetail.Verts[i].Y;  						hmin = Math.Min(hmin' h);  						hmax = Math.Max(hmax' h);  					}  				}  				else  				{  					for (int i = 0; i < polyMesh.VertCount; i++)  					{  						PolyVertex iv = polyMesh.Verts[i];  						float h = polyMesh.Bounds.Min.Y + iv.Y * settings.CellHeight;  						hmin = Math.Min(hmin' h);  						hmax = Math.Max(hmax' h);  					}  				}    				hmin -= settings.MaxClimb;  				hmax += settings.MaxClimb;  				BBox3 bounds = polyMesh.Bounds;  				bounds.Min.Y = hmin;  				bounds.Max.Y = hmax;    				for (int i = 0; i < offMeshCons.Length; i++)  				{  					Vector3 p0 = offMeshCons[i].Pos0;  					Vector3 p1 = offMeshCons[i].Pos1;    					offMeshSides[i * 2 + 0] = BoundarySideExtensions.FromPoint(p0' bounds);  					offMeshSides[i * 2 + 1] = BoundarySideExtensions.FromPoint(p1' bounds);    					//off-mesh start position isn't touching mesh  					if (offMeshSides[i * 2 + 0] == BoundarySide.Internal)  					{  						if (p0.Y < bounds.Min.Y || p0.Y > bounds.Max.Y)  							offMeshSides[i * 2 + 0] = 0;  					}    					//count number of links to allocate  					if (offMeshSides[i * 2 + 0] == BoundarySide.Internal)  						offMeshConLinkCount++;  					if (offMeshSides[i * 2 + 1] == BoundarySide.Internal)  						offMeshConLinkCount++;    					if (offMeshSides[i * 2 + 0] == BoundarySide.Internal)  						storedOffMeshConCount++;  				}  			}
Magic Number,SharpNav,NavMeshBuilder,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshBuilder.cs,NavMeshBuilder,The following statement contains a magic number: if (offMeshCons.Length > 0)  			{  				//find height bounds  				float hmin = float.MaxValue;  				float hmax = -float.MaxValue;    				if (polyMeshDetail != null)  				{  					for (int i = 0; i < polyMeshDetail.VertCount; i++)  					{  						float h = polyMeshDetail.Verts[i].Y;  						hmin = Math.Min(hmin' h);  						hmax = Math.Max(hmax' h);  					}  				}  				else  				{  					for (int i = 0; i < polyMesh.VertCount; i++)  					{  						PolyVertex iv = polyMesh.Verts[i];  						float h = polyMesh.Bounds.Min.Y + iv.Y * settings.CellHeight;  						hmin = Math.Min(hmin' h);  						hmax = Math.Max(hmax' h);  					}  				}    				hmin -= settings.MaxClimb;  				hmax += settings.MaxClimb;  				BBox3 bounds = polyMesh.Bounds;  				bounds.Min.Y = hmin;  				bounds.Max.Y = hmax;    				for (int i = 0; i < offMeshCons.Length; i++)  				{  					Vector3 p0 = offMeshCons[i].Pos0;  					Vector3 p1 = offMeshCons[i].Pos1;    					offMeshSides[i * 2 + 0] = BoundarySideExtensions.FromPoint(p0' bounds);  					offMeshSides[i * 2 + 1] = BoundarySideExtensions.FromPoint(p1' bounds);    					//off-mesh start position isn't touching mesh  					if (offMeshSides[i * 2 + 0] == BoundarySide.Internal)  					{  						if (p0.Y < bounds.Min.Y || p0.Y > bounds.Max.Y)  							offMeshSides[i * 2 + 0] = 0;  					}    					//count number of links to allocate  					if (offMeshSides[i * 2 + 0] == BoundarySide.Internal)  						offMeshConLinkCount++;  					if (offMeshSides[i * 2 + 1] == BoundarySide.Internal)  						offMeshConLinkCount++;    					if (offMeshSides[i * 2 + 0] == BoundarySide.Internal)  						storedOffMeshConCount++;  				}  			}
Magic Number,SharpNav,NavMeshBuilder,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshBuilder.cs,NavMeshBuilder,The following statement contains a magic number: if (offMeshCons.Length > 0)  			{  				//find height bounds  				float hmin = float.MaxValue;  				float hmax = -float.MaxValue;    				if (polyMeshDetail != null)  				{  					for (int i = 0; i < polyMeshDetail.VertCount; i++)  					{  						float h = polyMeshDetail.Verts[i].Y;  						hmin = Math.Min(hmin' h);  						hmax = Math.Max(hmax' h);  					}  				}  				else  				{  					for (int i = 0; i < polyMesh.VertCount; i++)  					{  						PolyVertex iv = polyMesh.Verts[i];  						float h = polyMesh.Bounds.Min.Y + iv.Y * settings.CellHeight;  						hmin = Math.Min(hmin' h);  						hmax = Math.Max(hmax' h);  					}  				}    				hmin -= settings.MaxClimb;  				hmax += settings.MaxClimb;  				BBox3 bounds = polyMesh.Bounds;  				bounds.Min.Y = hmin;  				bounds.Max.Y = hmax;    				for (int i = 0; i < offMeshCons.Length; i++)  				{  					Vector3 p0 = offMeshCons[i].Pos0;  					Vector3 p1 = offMeshCons[i].Pos1;    					offMeshSides[i * 2 + 0] = BoundarySideExtensions.FromPoint(p0' bounds);  					offMeshSides[i * 2 + 1] = BoundarySideExtensions.FromPoint(p1' bounds);    					//off-mesh start position isn't touching mesh  					if (offMeshSides[i * 2 + 0] == BoundarySide.Internal)  					{  						if (p0.Y < bounds.Min.Y || p0.Y > bounds.Max.Y)  							offMeshSides[i * 2 + 0] = 0;  					}    					//count number of links to allocate  					if (offMeshSides[i * 2 + 0] == BoundarySide.Internal)  						offMeshConLinkCount++;  					if (offMeshSides[i * 2 + 1] == BoundarySide.Internal)  						offMeshConLinkCount++;    					if (offMeshSides[i * 2 + 0] == BoundarySide.Internal)  						storedOffMeshConCount++;  				}  			}
Magic Number,SharpNav,NavMeshBuilder,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshBuilder.cs,NavMeshBuilder,The following statement contains a magic number: if (offMeshCons.Length > 0)  			{  				//find height bounds  				float hmin = float.MaxValue;  				float hmax = -float.MaxValue;    				if (polyMeshDetail != null)  				{  					for (int i = 0; i < polyMeshDetail.VertCount; i++)  					{  						float h = polyMeshDetail.Verts[i].Y;  						hmin = Math.Min(hmin' h);  						hmax = Math.Max(hmax' h);  					}  				}  				else  				{  					for (int i = 0; i < polyMesh.VertCount; i++)  					{  						PolyVertex iv = polyMesh.Verts[i];  						float h = polyMesh.Bounds.Min.Y + iv.Y * settings.CellHeight;  						hmin = Math.Min(hmin' h);  						hmax = Math.Max(hmax' h);  					}  				}    				hmin -= settings.MaxClimb;  				hmax += settings.MaxClimb;  				BBox3 bounds = polyMesh.Bounds;  				bounds.Min.Y = hmin;  				bounds.Max.Y = hmax;    				for (int i = 0; i < offMeshCons.Length; i++)  				{  					Vector3 p0 = offMeshCons[i].Pos0;  					Vector3 p1 = offMeshCons[i].Pos1;    					offMeshSides[i * 2 + 0] = BoundarySideExtensions.FromPoint(p0' bounds);  					offMeshSides[i * 2 + 1] = BoundarySideExtensions.FromPoint(p1' bounds);    					//off-mesh start position isn't touching mesh  					if (offMeshSides[i * 2 + 0] == BoundarySide.Internal)  					{  						if (p0.Y < bounds.Min.Y || p0.Y > bounds.Max.Y)  							offMeshSides[i * 2 + 0] = 0;  					}    					//count number of links to allocate  					if (offMeshSides[i * 2 + 0] == BoundarySide.Internal)  						offMeshConLinkCount++;  					if (offMeshSides[i * 2 + 1] == BoundarySide.Internal)  						offMeshConLinkCount++;    					if (offMeshSides[i * 2 + 0] == BoundarySide.Internal)  						storedOffMeshConCount++;  				}  			}
Magic Number,SharpNav,NavMeshBuilder,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshBuilder.cs,NavMeshBuilder,The following statement contains a magic number: if (offMeshCons.Length > 0)  			{  				//find height bounds  				float hmin = float.MaxValue;  				float hmax = -float.MaxValue;    				if (polyMeshDetail != null)  				{  					for (int i = 0; i < polyMeshDetail.VertCount; i++)  					{  						float h = polyMeshDetail.Verts[i].Y;  						hmin = Math.Min(hmin' h);  						hmax = Math.Max(hmax' h);  					}  				}  				else  				{  					for (int i = 0; i < polyMesh.VertCount; i++)  					{  						PolyVertex iv = polyMesh.Verts[i];  						float h = polyMesh.Bounds.Min.Y + iv.Y * settings.CellHeight;  						hmin = Math.Min(hmin' h);  						hmax = Math.Max(hmax' h);  					}  				}    				hmin -= settings.MaxClimb;  				hmax += settings.MaxClimb;  				BBox3 bounds = polyMesh.Bounds;  				bounds.Min.Y = hmin;  				bounds.Max.Y = hmax;    				for (int i = 0; i < offMeshCons.Length; i++)  				{  					Vector3 p0 = offMeshCons[i].Pos0;  					Vector3 p1 = offMeshCons[i].Pos1;    					offMeshSides[i * 2 + 0] = BoundarySideExtensions.FromPoint(p0' bounds);  					offMeshSides[i * 2 + 1] = BoundarySideExtensions.FromPoint(p1' bounds);    					//off-mesh start position isn't touching mesh  					if (offMeshSides[i * 2 + 0] == BoundarySide.Internal)  					{  						if (p0.Y < bounds.Min.Y || p0.Y > bounds.Max.Y)  							offMeshSides[i * 2 + 0] = 0;  					}    					//count number of links to allocate  					if (offMeshSides[i * 2 + 0] == BoundarySide.Internal)  						offMeshConLinkCount++;  					if (offMeshSides[i * 2 + 1] == BoundarySide.Internal)  						offMeshConLinkCount++;    					if (offMeshSides[i * 2 + 0] == BoundarySide.Internal)  						storedOffMeshConCount++;  				}  			}
Magic Number,SharpNav,NavMeshBuilder,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshBuilder.cs,NavMeshBuilder,The following statement contains a magic number: int totVertCount = polyMesh.VertCount + storedOffMeshConCount * 2;
Magic Number,SharpNav,NavMeshBuilder,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshBuilder.cs,NavMeshBuilder,The following statement contains a magic number: for (int i = 0; i < polyMesh.PolyCount; i++)  			{  				PolyMesh.Polygon p = polyMesh.Polys[i];  				for (int j = 0; j < nvp; j++)  				{  					if (p.Vertices[j] == PolyMesh.NullId)  						break;    					edgeCount++;  					  					if (PolyMesh.IsBoundaryEdge(p.NeighborEdges[j]))  					{  						int dir = p.NeighborEdges[j] % 16;  						if (dir != 15)  							portalCount++;  					}  				}  			}
Magic Number,SharpNav,NavMeshBuilder,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshBuilder.cs,NavMeshBuilder,The following statement contains a magic number: for (int i = 0; i < polyMesh.PolyCount; i++)  			{  				PolyMesh.Polygon p = polyMesh.Polys[i];  				for (int j = 0; j < nvp; j++)  				{  					if (p.Vertices[j] == PolyMesh.NullId)  						break;    					edgeCount++;  					  					if (PolyMesh.IsBoundaryEdge(p.NeighborEdges[j]))  					{  						int dir = p.NeighborEdges[j] % 16;  						if (dir != 15)  							portalCount++;  					}  				}  			}
Magic Number,SharpNav,NavMeshBuilder,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshBuilder.cs,NavMeshBuilder,The following statement contains a magic number: int maxLinkCount = edgeCount + portalCount * 2 + offMeshConLinkCount * 2;
Magic Number,SharpNav,NavMeshBuilder,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshBuilder.cs,NavMeshBuilder,The following statement contains a magic number: int maxLinkCount = edgeCount + portalCount * 2 + offMeshConLinkCount * 2;
Magic Number,SharpNav,NavMeshBuilder,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshBuilder.cs,NavMeshBuilder,The following statement contains a magic number: if (polyMeshDetail != null)  			{  				detailTriCount = polyMeshDetail.TrisCount;  				for (int i = 0; i < polyMesh.PolyCount; i++)  				{  					int numDetailVerts = polyMeshDetail.Meshes[i].VertexCount;  					int numPolyVerts = polyMesh.Polys[i].VertexCount;  					uniqueDetailVertCount += numDetailVerts - numPolyVerts;  				}  			}  			else  			{  				uniqueDetailVertCount = 0;  				detailTriCount = 0;  				for (int i = 0; i < polyMesh.PolyCount; i++)  				{  					int numPolyVerts = polyMesh.Polys[i].VertexCount;  					uniqueDetailVertCount += numPolyVerts - 2;  				}  			}
Magic Number,SharpNav,NavMeshBuilder,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshBuilder.cs,NavMeshBuilder,The following statement contains a magic number: header.BvNodeCount = settings.BuildBoundingVolumeTree ? polyMesh.PolyCount * 2 : 0;
Magic Number,SharpNav,NavMeshBuilder,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshBuilder.cs,NavMeshBuilder,The following statement contains a magic number: for (int i = 0; i < offMeshCons.Length; i++)  			{  				//only store connections which start from this tile  				if (offMeshSides[i * 2 + 0] == BoundarySide.Internal)  				{  					navVerts[offMeshVertsBase + (n * 2 + 0)] = offMeshCons[i].Pos0;  					navVerts[offMeshVertsBase + (n * 2 + 1)] = offMeshCons[i].Pos1;  					n++;  				}  			}
Magic Number,SharpNav,NavMeshBuilder,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshBuilder.cs,NavMeshBuilder,The following statement contains a magic number: for (int i = 0; i < offMeshCons.Length; i++)  			{  				//only store connections which start from this tile  				if (offMeshSides[i * 2 + 0] == BoundarySide.Internal)  				{  					navVerts[offMeshVertsBase + (n * 2 + 0)] = offMeshCons[i].Pos0;  					navVerts[offMeshVertsBase + (n * 2 + 1)] = offMeshCons[i].Pos1;  					n++;  				}  			}
Magic Number,SharpNav,NavMeshBuilder,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshBuilder.cs,NavMeshBuilder,The following statement contains a magic number: for (int i = 0; i < offMeshCons.Length; i++)  			{  				//only store connections which start from this tile  				if (offMeshSides[i * 2 + 0] == BoundarySide.Internal)  				{  					navVerts[offMeshVertsBase + (n * 2 + 0)] = offMeshCons[i].Pos0;  					navVerts[offMeshVertsBase + (n * 2 + 1)] = offMeshCons[i].Pos1;  					n++;  				}  			}
Magic Number,SharpNav,NavMeshBuilder,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshBuilder.cs,NavMeshBuilder,The following statement contains a magic number: for (int i = 0; i < polyMesh.PolyCount; i++)  			{  				navPolys[i] = new NavPoly();  				navPolys[i].VertCount = 0;  				navPolys[i].Tag = polyMesh.Polys[i].Tag;  				navPolys[i].Area = polyMesh.Polys[i].Area;  				navPolys[i].PolyType = NavPolyType.Ground;  				navPolys[i].Verts = new int[nvp];  				navPolys[i].Neis = new int[nvp];  				for (int j = 0; j < nvp; j++)  				{  					if (polyMesh.Polys[i].Vertices[j] == PolyMesh.NullId)  						break;    					navPolys[i].Verts[j] = polyMesh.Polys[i].Vertices[j];  					if (PolyMesh.IsBoundaryEdge(polyMesh.Polys[i].NeighborEdges[j]))  					{  						//border or portal edge  						int dir = polyMesh.Polys[i].NeighborEdges[j] % 16;  						if (dir == 0xf) //border  							navPolys[i].Neis[j] = 0;  						else if (dir == 0) //portal x-  							navPolys[i].Neis[j] = Link.External | 4;  						else if (dir == 1) //portal z+  							navPolys[i].Neis[j] = Link.External | 2;  						else if (dir == 2) //portal x+  							navPolys[i].Neis[j] = Link.External | 0;  						else if (dir == 3) //portal z-  							navPolys[i].Neis[j] = Link.External | 6;  					}  					else  					{  						//normal connection  						navPolys[i].Neis[j] = polyMesh.Polys[i].NeighborEdges[j] + 1;  					}    					navPolys[i].VertCount++;  				}  			}
Magic Number,SharpNav,NavMeshBuilder,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshBuilder.cs,NavMeshBuilder,The following statement contains a magic number: for (int i = 0; i < polyMesh.PolyCount; i++)  			{  				navPolys[i] = new NavPoly();  				navPolys[i].VertCount = 0;  				navPolys[i].Tag = polyMesh.Polys[i].Tag;  				navPolys[i].Area = polyMesh.Polys[i].Area;  				navPolys[i].PolyType = NavPolyType.Ground;  				navPolys[i].Verts = new int[nvp];  				navPolys[i].Neis = new int[nvp];  				for (int j = 0; j < nvp; j++)  				{  					if (polyMesh.Polys[i].Vertices[j] == PolyMesh.NullId)  						break;    					navPolys[i].Verts[j] = polyMesh.Polys[i].Vertices[j];  					if (PolyMesh.IsBoundaryEdge(polyMesh.Polys[i].NeighborEdges[j]))  					{  						//border or portal edge  						int dir = polyMesh.Polys[i].NeighborEdges[j] % 16;  						if (dir == 0xf) //border  							navPolys[i].Neis[j] = 0;  						else if (dir == 0) //portal x-  							navPolys[i].Neis[j] = Link.External | 4;  						else if (dir == 1) //portal z+  							navPolys[i].Neis[j] = Link.External | 2;  						else if (dir == 2) //portal x+  							navPolys[i].Neis[j] = Link.External | 0;  						else if (dir == 3) //portal z-  							navPolys[i].Neis[j] = Link.External | 6;  					}  					else  					{  						//normal connection  						navPolys[i].Neis[j] = polyMesh.Polys[i].NeighborEdges[j] + 1;  					}    					navPolys[i].VertCount++;  				}  			}
Magic Number,SharpNav,NavMeshBuilder,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshBuilder.cs,NavMeshBuilder,The following statement contains a magic number: for (int i = 0; i < polyMesh.PolyCount; i++)  			{  				navPolys[i] = new NavPoly();  				navPolys[i].VertCount = 0;  				navPolys[i].Tag = polyMesh.Polys[i].Tag;  				navPolys[i].Area = polyMesh.Polys[i].Area;  				navPolys[i].PolyType = NavPolyType.Ground;  				navPolys[i].Verts = new int[nvp];  				navPolys[i].Neis = new int[nvp];  				for (int j = 0; j < nvp; j++)  				{  					if (polyMesh.Polys[i].Vertices[j] == PolyMesh.NullId)  						break;    					navPolys[i].Verts[j] = polyMesh.Polys[i].Vertices[j];  					if (PolyMesh.IsBoundaryEdge(polyMesh.Polys[i].NeighborEdges[j]))  					{  						//border or portal edge  						int dir = polyMesh.Polys[i].NeighborEdges[j] % 16;  						if (dir == 0xf) //border  							navPolys[i].Neis[j] = 0;  						else if (dir == 0) //portal x-  							navPolys[i].Neis[j] = Link.External | 4;  						else if (dir == 1) //portal z+  							navPolys[i].Neis[j] = Link.External | 2;  						else if (dir == 2) //portal x+  							navPolys[i].Neis[j] = Link.External | 0;  						else if (dir == 3) //portal z-  							navPolys[i].Neis[j] = Link.External | 6;  					}  					else  					{  						//normal connection  						navPolys[i].Neis[j] = polyMesh.Polys[i].NeighborEdges[j] + 1;  					}    					navPolys[i].VertCount++;  				}  			}
Magic Number,SharpNav,NavMeshBuilder,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshBuilder.cs,NavMeshBuilder,The following statement contains a magic number: for (int i = 0; i < polyMesh.PolyCount; i++)  			{  				navPolys[i] = new NavPoly();  				navPolys[i].VertCount = 0;  				navPolys[i].Tag = polyMesh.Polys[i].Tag;  				navPolys[i].Area = polyMesh.Polys[i].Area;  				navPolys[i].PolyType = NavPolyType.Ground;  				navPolys[i].Verts = new int[nvp];  				navPolys[i].Neis = new int[nvp];  				for (int j = 0; j < nvp; j++)  				{  					if (polyMesh.Polys[i].Vertices[j] == PolyMesh.NullId)  						break;    					navPolys[i].Verts[j] = polyMesh.Polys[i].Vertices[j];  					if (PolyMesh.IsBoundaryEdge(polyMesh.Polys[i].NeighborEdges[j]))  					{  						//border or portal edge  						int dir = polyMesh.Polys[i].NeighborEdges[j] % 16;  						if (dir == 0xf) //border  							navPolys[i].Neis[j] = 0;  						else if (dir == 0) //portal x-  							navPolys[i].Neis[j] = Link.External | 4;  						else if (dir == 1) //portal z+  							navPolys[i].Neis[j] = Link.External | 2;  						else if (dir == 2) //portal x+  							navPolys[i].Neis[j] = Link.External | 0;  						else if (dir == 3) //portal z-  							navPolys[i].Neis[j] = Link.External | 6;  					}  					else  					{  						//normal connection  						navPolys[i].Neis[j] = polyMesh.Polys[i].NeighborEdges[j] + 1;  					}    					navPolys[i].VertCount++;  				}  			}
Magic Number,SharpNav,NavMeshBuilder,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshBuilder.cs,NavMeshBuilder,The following statement contains a magic number: for (int i = 0; i < polyMesh.PolyCount; i++)  			{  				navPolys[i] = new NavPoly();  				navPolys[i].VertCount = 0;  				navPolys[i].Tag = polyMesh.Polys[i].Tag;  				navPolys[i].Area = polyMesh.Polys[i].Area;  				navPolys[i].PolyType = NavPolyType.Ground;  				navPolys[i].Verts = new int[nvp];  				navPolys[i].Neis = new int[nvp];  				for (int j = 0; j < nvp; j++)  				{  					if (polyMesh.Polys[i].Vertices[j] == PolyMesh.NullId)  						break;    					navPolys[i].Verts[j] = polyMesh.Polys[i].Vertices[j];  					if (PolyMesh.IsBoundaryEdge(polyMesh.Polys[i].NeighborEdges[j]))  					{  						//border or portal edge  						int dir = polyMesh.Polys[i].NeighborEdges[j] % 16;  						if (dir == 0xf) //border  							navPolys[i].Neis[j] = 0;  						else if (dir == 0) //portal x-  							navPolys[i].Neis[j] = Link.External | 4;  						else if (dir == 1) //portal z+  							navPolys[i].Neis[j] = Link.External | 2;  						else if (dir == 2) //portal x+  							navPolys[i].Neis[j] = Link.External | 0;  						else if (dir == 3) //portal z-  							navPolys[i].Neis[j] = Link.External | 6;  					}  					else  					{  						//normal connection  						navPolys[i].Neis[j] = polyMesh.Polys[i].NeighborEdges[j] + 1;  					}    					navPolys[i].VertCount++;  				}  			}
Magic Number,SharpNav,NavMeshBuilder,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshBuilder.cs,NavMeshBuilder,The following statement contains a magic number: for (int i = 0; i < polyMesh.PolyCount; i++)  			{  				navPolys[i] = new NavPoly();  				navPolys[i].VertCount = 0;  				navPolys[i].Tag = polyMesh.Polys[i].Tag;  				navPolys[i].Area = polyMesh.Polys[i].Area;  				navPolys[i].PolyType = NavPolyType.Ground;  				navPolys[i].Verts = new int[nvp];  				navPolys[i].Neis = new int[nvp];  				for (int j = 0; j < nvp; j++)  				{  					if (polyMesh.Polys[i].Vertices[j] == PolyMesh.NullId)  						break;    					navPolys[i].Verts[j] = polyMesh.Polys[i].Vertices[j];  					if (PolyMesh.IsBoundaryEdge(polyMesh.Polys[i].NeighborEdges[j]))  					{  						//border or portal edge  						int dir = polyMesh.Polys[i].NeighborEdges[j] % 16;  						if (dir == 0xf) //border  							navPolys[i].Neis[j] = 0;  						else if (dir == 0) //portal x-  							navPolys[i].Neis[j] = Link.External | 4;  						else if (dir == 1) //portal z+  							navPolys[i].Neis[j] = Link.External | 2;  						else if (dir == 2) //portal x+  							navPolys[i].Neis[j] = Link.External | 0;  						else if (dir == 3) //portal z-  							navPolys[i].Neis[j] = Link.External | 6;  					}  					else  					{  						//normal connection  						navPolys[i].Neis[j] = polyMesh.Polys[i].NeighborEdges[j] + 1;  					}    					navPolys[i].VertCount++;  				}  			}
Magic Number,SharpNav,NavMeshBuilder,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshBuilder.cs,NavMeshBuilder,The following statement contains a magic number: for (int i = 0; i < offMeshCons.Length; i++)  			{  				//only store connections which start from this tile  				if (offMeshSides[i * 2 + 0] == BoundarySide.Internal)  				{  					navPolys[offMeshPolyBase + n] = new NavPoly();  					navPolys[offMeshPolyBase + n].VertCount = 2;  					navPolys[offMeshPolyBase + n].Verts = new int[nvp];  					navPolys[offMeshPolyBase + n].Verts[0] = offMeshVertsBase + (n * 2 + 0);  					navPolys[offMeshPolyBase + n].Verts[1] = offMeshVertsBase + (n * 2 + 1);  					navPolys[offMeshPolyBase + n].Tag = offMeshCons[i].Flags;  					navPolys[offMeshPolyBase + n].Area = polyMesh.Polys[offMeshCons[i].Poly].Area; //HACK is this correct?  					navPolys[offMeshPolyBase + n].PolyType = NavPolyType.OffMeshConnection;  					n++;  				}  			}
Magic Number,SharpNav,NavMeshBuilder,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshBuilder.cs,NavMeshBuilder,The following statement contains a magic number: for (int i = 0; i < offMeshCons.Length; i++)  			{  				//only store connections which start from this tile  				if (offMeshSides[i * 2 + 0] == BoundarySide.Internal)  				{  					navPolys[offMeshPolyBase + n] = new NavPoly();  					navPolys[offMeshPolyBase + n].VertCount = 2;  					navPolys[offMeshPolyBase + n].Verts = new int[nvp];  					navPolys[offMeshPolyBase + n].Verts[0] = offMeshVertsBase + (n * 2 + 0);  					navPolys[offMeshPolyBase + n].Verts[1] = offMeshVertsBase + (n * 2 + 1);  					navPolys[offMeshPolyBase + n].Tag = offMeshCons[i].Flags;  					navPolys[offMeshPolyBase + n].Area = polyMesh.Polys[offMeshCons[i].Poly].Area; //HACK is this correct?  					navPolys[offMeshPolyBase + n].PolyType = NavPolyType.OffMeshConnection;  					n++;  				}  			}
Magic Number,SharpNav,NavMeshBuilder,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshBuilder.cs,NavMeshBuilder,The following statement contains a magic number: for (int i = 0; i < offMeshCons.Length; i++)  			{  				//only store connections which start from this tile  				if (offMeshSides[i * 2 + 0] == BoundarySide.Internal)  				{  					navPolys[offMeshPolyBase + n] = new NavPoly();  					navPolys[offMeshPolyBase + n].VertCount = 2;  					navPolys[offMeshPolyBase + n].Verts = new int[nvp];  					navPolys[offMeshPolyBase + n].Verts[0] = offMeshVertsBase + (n * 2 + 0);  					navPolys[offMeshPolyBase + n].Verts[1] = offMeshVertsBase + (n * 2 + 1);  					navPolys[offMeshPolyBase + n].Tag = offMeshCons[i].Flags;  					navPolys[offMeshPolyBase + n].Area = polyMesh.Polys[offMeshCons[i].Poly].Area; //HACK is this correct?  					navPolys[offMeshPolyBase + n].PolyType = NavPolyType.OffMeshConnection;  					n++;  				}  			}
Magic Number,SharpNav,NavMeshBuilder,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshBuilder.cs,NavMeshBuilder,The following statement contains a magic number: for (int i = 0; i < offMeshCons.Length; i++)  			{  				//only store connections which start from this tile  				if (offMeshSides[i * 2 + 0] == BoundarySide.Internal)  				{  					navPolys[offMeshPolyBase + n] = new NavPoly();  					navPolys[offMeshPolyBase + n].VertCount = 2;  					navPolys[offMeshPolyBase + n].Verts = new int[nvp];  					navPolys[offMeshPolyBase + n].Verts[0] = offMeshVertsBase + (n * 2 + 0);  					navPolys[offMeshPolyBase + n].Verts[1] = offMeshVertsBase + (n * 2 + 1);  					navPolys[offMeshPolyBase + n].Tag = offMeshCons[i].Flags;  					navPolys[offMeshPolyBase + n].Area = polyMesh.Polys[offMeshCons[i].Poly].Area; //HACK is this correct?  					navPolys[offMeshPolyBase + n].PolyType = NavPolyType.OffMeshConnection;  					n++;  				}  			}
Magic Number,SharpNav,NavMeshBuilder,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshBuilder.cs,NavMeshBuilder,The following statement contains a magic number: if (polyMeshDetail != null)  			{  				int vbase = 0;  				List<Vector3> storedDetailVerts = new List<Vector3>();  				for (int i = 0; i < polyMesh.PolyCount; i++)  				{  					int vb = polyMeshDetail.Meshes[i].VertexIndex;  					int numDetailVerts = polyMeshDetail.Meshes[i].VertexCount;  					int numPolyVerts = navPolys[i].VertCount;  					navDMeshes[i].VertexIndex = vbase;  					navDMeshes[i].VertexCount = numDetailVerts - numPolyVerts;  					navDMeshes[i].TriangleIndex = polyMeshDetail.Meshes[i].TriangleIndex;  					navDMeshes[i].TriangleCount = polyMeshDetail.Meshes[i].TriangleCount;  					  					//Copy detail vertices   					//first 'nv' verts are equal to nav poly verts  					//the rest are detail verts  					for (int j = 0; j < navDMeshes[i].VertexCount; j++)  					{  						storedDetailVerts.Add(polyMeshDetail.Verts[vb + numPolyVerts + j]);  					}    					vbase += numDetailVerts - numPolyVerts;  				}    				navDVerts = storedDetailVerts.ToArray();    				//store triangles  				for (int j = 0; j < polyMeshDetail.TrisCount; j++)  					navDTris[j] = polyMeshDetail.Tris[j];  			}  			else  			{  				//create dummy detail mesh by triangulating polys  				int tbase = 0;  				for (int i = 0; i < polyMesh.PolyCount; i++)  				{  					int numPolyVerts = navPolys[i].VertCount;  					navDMeshes[i].VertexIndex = 0;  					navDMeshes[i].VertexCount = 0;  					navDMeshes[i].TriangleIndex = tbase;  					navDMeshes[i].TriangleCount = numPolyVerts - 2;    					//triangulate polygon  					for (int j = 2; j < numPolyVerts; j++)  					{  						navDTris[tbase].VertexHash0 = 0;  						navDTris[tbase].VertexHash1 = j - 1;  						navDTris[tbase].VertexHash2 = j;    						//bit for each edge that belongs to the poly boundary  						navDTris[tbase].Flags = 1 << 2;  						if (j == 2)   							navDTris[tbase].Flags |= 1 << 0;  						if (j == numPolyVerts - 1)  							navDTris[tbase].Flags |= 1 << 4;  						  						tbase++;  					}  				}  			}
Magic Number,SharpNav,NavMeshBuilder,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshBuilder.cs,NavMeshBuilder,The following statement contains a magic number: if (polyMeshDetail != null)  			{  				int vbase = 0;  				List<Vector3> storedDetailVerts = new List<Vector3>();  				for (int i = 0; i < polyMesh.PolyCount; i++)  				{  					int vb = polyMeshDetail.Meshes[i].VertexIndex;  					int numDetailVerts = polyMeshDetail.Meshes[i].VertexCount;  					int numPolyVerts = navPolys[i].VertCount;  					navDMeshes[i].VertexIndex = vbase;  					navDMeshes[i].VertexCount = numDetailVerts - numPolyVerts;  					navDMeshes[i].TriangleIndex = polyMeshDetail.Meshes[i].TriangleIndex;  					navDMeshes[i].TriangleCount = polyMeshDetail.Meshes[i].TriangleCount;  					  					//Copy detail vertices   					//first 'nv' verts are equal to nav poly verts  					//the rest are detail verts  					for (int j = 0; j < navDMeshes[i].VertexCount; j++)  					{  						storedDetailVerts.Add(polyMeshDetail.Verts[vb + numPolyVerts + j]);  					}    					vbase += numDetailVerts - numPolyVerts;  				}    				navDVerts = storedDetailVerts.ToArray();    				//store triangles  				for (int j = 0; j < polyMeshDetail.TrisCount; j++)  					navDTris[j] = polyMeshDetail.Tris[j];  			}  			else  			{  				//create dummy detail mesh by triangulating polys  				int tbase = 0;  				for (int i = 0; i < polyMesh.PolyCount; i++)  				{  					int numPolyVerts = navPolys[i].VertCount;  					navDMeshes[i].VertexIndex = 0;  					navDMeshes[i].VertexCount = 0;  					navDMeshes[i].TriangleIndex = tbase;  					navDMeshes[i].TriangleCount = numPolyVerts - 2;    					//triangulate polygon  					for (int j = 2; j < numPolyVerts; j++)  					{  						navDTris[tbase].VertexHash0 = 0;  						navDTris[tbase].VertexHash1 = j - 1;  						navDTris[tbase].VertexHash2 = j;    						//bit for each edge that belongs to the poly boundary  						navDTris[tbase].Flags = 1 << 2;  						if (j == 2)   							navDTris[tbase].Flags |= 1 << 0;  						if (j == numPolyVerts - 1)  							navDTris[tbase].Flags |= 1 << 4;  						  						tbase++;  					}  				}  			}
Magic Number,SharpNav,NavMeshBuilder,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshBuilder.cs,NavMeshBuilder,The following statement contains a magic number: if (polyMeshDetail != null)  			{  				int vbase = 0;  				List<Vector3> storedDetailVerts = new List<Vector3>();  				for (int i = 0; i < polyMesh.PolyCount; i++)  				{  					int vb = polyMeshDetail.Meshes[i].VertexIndex;  					int numDetailVerts = polyMeshDetail.Meshes[i].VertexCount;  					int numPolyVerts = navPolys[i].VertCount;  					navDMeshes[i].VertexIndex = vbase;  					navDMeshes[i].VertexCount = numDetailVerts - numPolyVerts;  					navDMeshes[i].TriangleIndex = polyMeshDetail.Meshes[i].TriangleIndex;  					navDMeshes[i].TriangleCount = polyMeshDetail.Meshes[i].TriangleCount;  					  					//Copy detail vertices   					//first 'nv' verts are equal to nav poly verts  					//the rest are detail verts  					for (int j = 0; j < navDMeshes[i].VertexCount; j++)  					{  						storedDetailVerts.Add(polyMeshDetail.Verts[vb + numPolyVerts + j]);  					}    					vbase += numDetailVerts - numPolyVerts;  				}    				navDVerts = storedDetailVerts.ToArray();    				//store triangles  				for (int j = 0; j < polyMeshDetail.TrisCount; j++)  					navDTris[j] = polyMeshDetail.Tris[j];  			}  			else  			{  				//create dummy detail mesh by triangulating polys  				int tbase = 0;  				for (int i = 0; i < polyMesh.PolyCount; i++)  				{  					int numPolyVerts = navPolys[i].VertCount;  					navDMeshes[i].VertexIndex = 0;  					navDMeshes[i].VertexCount = 0;  					navDMeshes[i].TriangleIndex = tbase;  					navDMeshes[i].TriangleCount = numPolyVerts - 2;    					//triangulate polygon  					for (int j = 2; j < numPolyVerts; j++)  					{  						navDTris[tbase].VertexHash0 = 0;  						navDTris[tbase].VertexHash1 = j - 1;  						navDTris[tbase].VertexHash2 = j;    						//bit for each edge that belongs to the poly boundary  						navDTris[tbase].Flags = 1 << 2;  						if (j == 2)   							navDTris[tbase].Flags |= 1 << 0;  						if (j == numPolyVerts - 1)  							navDTris[tbase].Flags |= 1 << 4;  						  						tbase++;  					}  				}  			}
Magic Number,SharpNav,NavMeshBuilder,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshBuilder.cs,NavMeshBuilder,The following statement contains a magic number: if (polyMeshDetail != null)  			{  				int vbase = 0;  				List<Vector3> storedDetailVerts = new List<Vector3>();  				for (int i = 0; i < polyMesh.PolyCount; i++)  				{  					int vb = polyMeshDetail.Meshes[i].VertexIndex;  					int numDetailVerts = polyMeshDetail.Meshes[i].VertexCount;  					int numPolyVerts = navPolys[i].VertCount;  					navDMeshes[i].VertexIndex = vbase;  					navDMeshes[i].VertexCount = numDetailVerts - numPolyVerts;  					navDMeshes[i].TriangleIndex = polyMeshDetail.Meshes[i].TriangleIndex;  					navDMeshes[i].TriangleCount = polyMeshDetail.Meshes[i].TriangleCount;  					  					//Copy detail vertices   					//first 'nv' verts are equal to nav poly verts  					//the rest are detail verts  					for (int j = 0; j < navDMeshes[i].VertexCount; j++)  					{  						storedDetailVerts.Add(polyMeshDetail.Verts[vb + numPolyVerts + j]);  					}    					vbase += numDetailVerts - numPolyVerts;  				}    				navDVerts = storedDetailVerts.ToArray();    				//store triangles  				for (int j = 0; j < polyMeshDetail.TrisCount; j++)  					navDTris[j] = polyMeshDetail.Tris[j];  			}  			else  			{  				//create dummy detail mesh by triangulating polys  				int tbase = 0;  				for (int i = 0; i < polyMesh.PolyCount; i++)  				{  					int numPolyVerts = navPolys[i].VertCount;  					navDMeshes[i].VertexIndex = 0;  					navDMeshes[i].VertexCount = 0;  					navDMeshes[i].TriangleIndex = tbase;  					navDMeshes[i].TriangleCount = numPolyVerts - 2;    					//triangulate polygon  					for (int j = 2; j < numPolyVerts; j++)  					{  						navDTris[tbase].VertexHash0 = 0;  						navDTris[tbase].VertexHash1 = j - 1;  						navDTris[tbase].VertexHash2 = j;    						//bit for each edge that belongs to the poly boundary  						navDTris[tbase].Flags = 1 << 2;  						if (j == 2)   							navDTris[tbase].Flags |= 1 << 0;  						if (j == numPolyVerts - 1)  							navDTris[tbase].Flags |= 1 << 4;  						  						tbase++;  					}  				}  			}
Magic Number,SharpNav,NavMeshBuilder,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshBuilder.cs,NavMeshBuilder,The following statement contains a magic number: if (polyMeshDetail != null)  			{  				int vbase = 0;  				List<Vector3> storedDetailVerts = new List<Vector3>();  				for (int i = 0; i < polyMesh.PolyCount; i++)  				{  					int vb = polyMeshDetail.Meshes[i].VertexIndex;  					int numDetailVerts = polyMeshDetail.Meshes[i].VertexCount;  					int numPolyVerts = navPolys[i].VertCount;  					navDMeshes[i].VertexIndex = vbase;  					navDMeshes[i].VertexCount = numDetailVerts - numPolyVerts;  					navDMeshes[i].TriangleIndex = polyMeshDetail.Meshes[i].TriangleIndex;  					navDMeshes[i].TriangleCount = polyMeshDetail.Meshes[i].TriangleCount;  					  					//Copy detail vertices   					//first 'nv' verts are equal to nav poly verts  					//the rest are detail verts  					for (int j = 0; j < navDMeshes[i].VertexCount; j++)  					{  						storedDetailVerts.Add(polyMeshDetail.Verts[vb + numPolyVerts + j]);  					}    					vbase += numDetailVerts - numPolyVerts;  				}    				navDVerts = storedDetailVerts.ToArray();    				//store triangles  				for (int j = 0; j < polyMeshDetail.TrisCount; j++)  					navDTris[j] = polyMeshDetail.Tris[j];  			}  			else  			{  				//create dummy detail mesh by triangulating polys  				int tbase = 0;  				for (int i = 0; i < polyMesh.PolyCount; i++)  				{  					int numPolyVerts = navPolys[i].VertCount;  					navDMeshes[i].VertexIndex = 0;  					navDMeshes[i].VertexCount = 0;  					navDMeshes[i].TriangleIndex = tbase;  					navDMeshes[i].TriangleCount = numPolyVerts - 2;    					//triangulate polygon  					for (int j = 2; j < numPolyVerts; j++)  					{  						navDTris[tbase].VertexHash0 = 0;  						navDTris[tbase].VertexHash1 = j - 1;  						navDTris[tbase].VertexHash2 = j;    						//bit for each edge that belongs to the poly boundary  						navDTris[tbase].Flags = 1 << 2;  						if (j == 2)   							navDTris[tbase].Flags |= 1 << 0;  						if (j == numPolyVerts - 1)  							navDTris[tbase].Flags |= 1 << 4;  						  						tbase++;  					}  				}  			}
Magic Number,SharpNav,NavMeshBuilder,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshBuilder.cs,NavMeshBuilder,The following statement contains a magic number: for (int i = 0; i < offMeshConnections.Length; i++)  			{  				//only store connections which start from this tile  				if (offMeshSides[i * 2 + 0] == BoundarySide.Internal)  				{  					offMeshConnections [n] = new OffMeshConnection ();  					  					offMeshConnections[n].Poly = offMeshPolyBase + n;    					//copy connection end points  					offMeshConnections[n].Pos0 = offMeshCons[i].Pos0;  					offMeshConnections[n].Pos1 = offMeshCons[i].Pos1;    					offMeshConnections[n].Radius = offMeshCons[i].Radius;  					offMeshConnections[n].Flags = offMeshCons[i].Flags;  					offMeshConnections[n].Side = offMeshSides[i * 2 + 1];  					offMeshConnections[n].Tag = offMeshCons[i].Tag;    					n++;  				}  			}
Magic Number,SharpNav,NavMeshBuilder,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshBuilder.cs,NavMeshBuilder,The following statement contains a magic number: for (int i = 0; i < offMeshConnections.Length; i++)  			{  				//only store connections which start from this tile  				if (offMeshSides[i * 2 + 0] == BoundarySide.Internal)  				{  					offMeshConnections [n] = new OffMeshConnection ();  					  					offMeshConnections[n].Poly = offMeshPolyBase + n;    					//copy connection end points  					offMeshConnections[n].Pos0 = offMeshCons[i].Pos0;  					offMeshConnections[n].Pos1 = offMeshCons[i].Pos1;    					offMeshConnections[n].Radius = offMeshCons[i].Radius;  					offMeshConnections[n].Flags = offMeshCons[i].Flags;  					offMeshConnections[n].Side = offMeshSides[i * 2 + 1];  					offMeshConnections[n].Tag = offMeshCons[i].Tag;    					n++;  				}  			}
Magic Number,SharpNav,PolyMeshDetail,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyMeshDetail.cs,PolyMeshDetail,The following statement contains a magic number: for (int i = 0; i < mesh.PolyCount; i++)  			{  				var p = mesh.Polys[i];    				//store polygon vertices for processing  				int npoly = 0;  				for (int j = 0; j < mesh.NumVertsPerPoly; j++)  				{  					int pvi = p.Vertices[j];  					if (pvi == PolyMesh.NullId)  						break;    					PolyVertex pv = mesh.Verts[pvi];  					Vector3 v = new Vector3(pv.X' pv.Y' pv.Z);  					v.X *= mesh.CellSize;  					v.Y *= mesh.CellHeight;  					v.Z *= mesh.CellSize;  					poly[j] = v;  					npoly++;  				}    				//get height data from area of polygon  				BBox2i bound = bounds[i];  				hp.Resize(bound.Min.X' bound.Min.Y' bound.Max.X - bound.Min.X' bound.Max.Y - bound.Min.Y);  				GetHeightData(compactField' p' npoly' mesh.Verts' mesh.BorderSize' hp);    				List<Vector3> tempVerts = new List<Vector3>();  				List<TriangleData> tempTris = new List<TriangleData>(128);  				List<EdgeInfo> edges = new List<EdgeInfo>(16);  				List<SamplingData> samples = new List<SamplingData>(128);  				BuildPolyDetail(poly' npoly' sampleDist' sampleMaxError' compactField' hp' tempVerts' tempTris' edges' samples);    				//more detail verts  				for (int j = 0; j < tempVerts.Count; j++)  				{  					Vector3 tv = tempVerts[j];    					Vector3 v;  					v.X = tv.X + origin.X;  					v.Y = tv.Y + origin.Y + compactField.CellHeight;  					v.Z = tv.Z + origin.Z;    					tempVerts[j] = v;  				}    				for (int j = 0; j < npoly; j++)  				{  					Vector3 po = poly[j];    					po.X += origin.X;  					po.Y += origin.Y;  					po.Z += origin.Z;    					poly[j] = po;  				}    				//save data  				this.meshes[i].VertexIndex = storedVertices.Count;  				this.meshes[i].VertexCount = tempVerts.Count;  				this.meshes[i].TriangleIndex = storedTriangles.Count;  				this.meshes[i].TriangleCount = tempTris.Count;    				//store vertices  				storedVertices.AddRange(tempVerts);  				  				//store triangles  				for (int j = 0; j < tempTris.Count; j++)  				{  					storedTriangles.Add(new TriangleData(tempTris[j]' tempVerts' poly' npoly));  				}  			}
Magic Number,SharpNav,PolyMeshDetail,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyMeshDetail.cs,PolyMeshDetail,The following statement contains a magic number: for (int i = 0; i < mesh.PolyCount; i++)  			{  				var p = mesh.Polys[i];    				//store polygon vertices for processing  				int npoly = 0;  				for (int j = 0; j < mesh.NumVertsPerPoly; j++)  				{  					int pvi = p.Vertices[j];  					if (pvi == PolyMesh.NullId)  						break;    					PolyVertex pv = mesh.Verts[pvi];  					Vector3 v = new Vector3(pv.X' pv.Y' pv.Z);  					v.X *= mesh.CellSize;  					v.Y *= mesh.CellHeight;  					v.Z *= mesh.CellSize;  					poly[j] = v;  					npoly++;  				}    				//get height data from area of polygon  				BBox2i bound = bounds[i];  				hp.Resize(bound.Min.X' bound.Min.Y' bound.Max.X - bound.Min.X' bound.Max.Y - bound.Min.Y);  				GetHeightData(compactField' p' npoly' mesh.Verts' mesh.BorderSize' hp);    				List<Vector3> tempVerts = new List<Vector3>();  				List<TriangleData> tempTris = new List<TriangleData>(128);  				List<EdgeInfo> edges = new List<EdgeInfo>(16);  				List<SamplingData> samples = new List<SamplingData>(128);  				BuildPolyDetail(poly' npoly' sampleDist' sampleMaxError' compactField' hp' tempVerts' tempTris' edges' samples);    				//more detail verts  				for (int j = 0; j < tempVerts.Count; j++)  				{  					Vector3 tv = tempVerts[j];    					Vector3 v;  					v.X = tv.X + origin.X;  					v.Y = tv.Y + origin.Y + compactField.CellHeight;  					v.Z = tv.Z + origin.Z;    					tempVerts[j] = v;  				}    				for (int j = 0; j < npoly; j++)  				{  					Vector3 po = poly[j];    					po.X += origin.X;  					po.Y += origin.Y;  					po.Z += origin.Z;    					poly[j] = po;  				}    				//save data  				this.meshes[i].VertexIndex = storedVertices.Count;  				this.meshes[i].VertexCount = tempVerts.Count;  				this.meshes[i].TriangleIndex = storedTriangles.Count;  				this.meshes[i].TriangleCount = tempTris.Count;    				//store vertices  				storedVertices.AddRange(tempVerts);  				  				//store triangles  				for (int j = 0; j < tempTris.Count; j++)  				{  					storedTriangles.Add(new TriangleData(tempTris[j]' tempVerts' poly' npoly));  				}  			}
Magic Number,SharpNav,PolyMeshDetail,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyMeshDetail.cs,PolyMeshDetail,The following statement contains a magic number: for (int i = 0; i < mesh.PolyCount; i++)  			{  				var p = mesh.Polys[i];    				//store polygon vertices for processing  				int npoly = 0;  				for (int j = 0; j < mesh.NumVertsPerPoly; j++)  				{  					int pvi = p.Vertices[j];  					if (pvi == PolyMesh.NullId)  						break;    					PolyVertex pv = mesh.Verts[pvi];  					Vector3 v = new Vector3(pv.X' pv.Y' pv.Z);  					v.X *= mesh.CellSize;  					v.Y *= mesh.CellHeight;  					v.Z *= mesh.CellSize;  					poly[j] = v;  					npoly++;  				}    				//get height data from area of polygon  				BBox2i bound = bounds[i];  				hp.Resize(bound.Min.X' bound.Min.Y' bound.Max.X - bound.Min.X' bound.Max.Y - bound.Min.Y);  				GetHeightData(compactField' p' npoly' mesh.Verts' mesh.BorderSize' hp);    				List<Vector3> tempVerts = new List<Vector3>();  				List<TriangleData> tempTris = new List<TriangleData>(128);  				List<EdgeInfo> edges = new List<EdgeInfo>(16);  				List<SamplingData> samples = new List<SamplingData>(128);  				BuildPolyDetail(poly' npoly' sampleDist' sampleMaxError' compactField' hp' tempVerts' tempTris' edges' samples);    				//more detail verts  				for (int j = 0; j < tempVerts.Count; j++)  				{  					Vector3 tv = tempVerts[j];    					Vector3 v;  					v.X = tv.X + origin.X;  					v.Y = tv.Y + origin.Y + compactField.CellHeight;  					v.Z = tv.Z + origin.Z;    					tempVerts[j] = v;  				}    				for (int j = 0; j < npoly; j++)  				{  					Vector3 po = poly[j];    					po.X += origin.X;  					po.Y += origin.Y;  					po.Z += origin.Z;    					poly[j] = po;  				}    				//save data  				this.meshes[i].VertexIndex = storedVertices.Count;  				this.meshes[i].VertexCount = tempVerts.Count;  				this.meshes[i].TriangleIndex = storedTriangles.Count;  				this.meshes[i].TriangleCount = tempTris.Count;    				//store vertices  				storedVertices.AddRange(tempVerts);  				  				//store triangles  				for (int j = 0; j < tempTris.Count; j++)  				{  					storedTriangles.Add(new TriangleData(tempTris[j]' tempVerts' poly' npoly));  				}  			}
Magic Number,SharpNav,PolyMeshDetail,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyMeshDetail.cs,GetHeightData,The following statement contains a magic number: const int RetractSize = 256;
Magic Number,SharpNav,PolyMeshDetail,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyMeshDetail.cs,GetHeightDataSeedsFromVertices,The following statement contains a magic number: for (int j = 0; j < polyCount; j++)  			{  				var csr = new CompactSpanReference(0' 0' -1);  				int dmin = int.MaxValue;    				var v = verts[poly.Vertices[j]];    				for (int k = 0; k < 9; k++)  				{  					//get vertices and offset x and z coordinates depending on current drection  					int ax = v.X + VertexOffset[k * 2 + 0];  					int ay = v.Y;  					int az = v.Z + VertexOffset[k * 2 + 1];    					//skip if out of bounds  					if (ax < hp.X || ax >= hp.X + hp.Width || az < hp.Y || az >= hp.Y + hp.Length)  						continue;    					//get new cell  					CompactCell c = compactField.Cells[(az + borderSize) * compactField.Width + (ax + borderSize)];  					  					//loop through all the spans  					for (int i = c.StartIndex' end = c.StartIndex + c.Count; i < end; i++)  					{  						CompactSpan s = compactField.Spans[i];  						  						//find minimum y-distance  						int d = Math.Abs(ay - s.Minimum);  						if (d < dmin)  						{  							csr = new CompactSpanReference(ax' az' i);  							dmin = d;  						}  					}  				}    				//only add if something new found  				if (csr.Index != -1)  				{  					stack.Add(csr);  				}  			}
Magic Number,SharpNav,PolyMeshDetail,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyMeshDetail.cs,GetHeightDataSeedsFromVertices,The following statement contains a magic number: for (int j = 0; j < polyCount; j++)  			{  				var csr = new CompactSpanReference(0' 0' -1);  				int dmin = int.MaxValue;    				var v = verts[poly.Vertices[j]];    				for (int k = 0; k < 9; k++)  				{  					//get vertices and offset x and z coordinates depending on current drection  					int ax = v.X + VertexOffset[k * 2 + 0];  					int ay = v.Y;  					int az = v.Z + VertexOffset[k * 2 + 1];    					//skip if out of bounds  					if (ax < hp.X || ax >= hp.X + hp.Width || az < hp.Y || az >= hp.Y + hp.Length)  						continue;    					//get new cell  					CompactCell c = compactField.Cells[(az + borderSize) * compactField.Width + (ax + borderSize)];  					  					//loop through all the spans  					for (int i = c.StartIndex' end = c.StartIndex + c.Count; i < end; i++)  					{  						CompactSpan s = compactField.Spans[i];  						  						//find minimum y-distance  						int d = Math.Abs(ay - s.Minimum);  						if (d < dmin)  						{  							csr = new CompactSpanReference(ax' az' i);  							dmin = d;  						}  					}  				}    				//only add if something new found  				if (csr.Index != -1)  				{  					stack.Add(csr);  				}  			}
Magic Number,SharpNav,PolyMeshDetail,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyMeshDetail.cs,GetHeightDataSeedsFromVertices,The following statement contains a magic number: for (int j = 0; j < polyCount; j++)  			{  				var csr = new CompactSpanReference(0' 0' -1);  				int dmin = int.MaxValue;    				var v = verts[poly.Vertices[j]];    				for (int k = 0; k < 9; k++)  				{  					//get vertices and offset x and z coordinates depending on current drection  					int ax = v.X + VertexOffset[k * 2 + 0];  					int ay = v.Y;  					int az = v.Z + VertexOffset[k * 2 + 1];    					//skip if out of bounds  					if (ax < hp.X || ax >= hp.X + hp.Width || az < hp.Y || az >= hp.Y + hp.Length)  						continue;    					//get new cell  					CompactCell c = compactField.Cells[(az + borderSize) * compactField.Width + (ax + borderSize)];  					  					//loop through all the spans  					for (int i = c.StartIndex' end = c.StartIndex + c.Count; i < end; i++)  					{  						CompactSpan s = compactField.Spans[i];  						  						//find minimum y-distance  						int d = Math.Abs(ay - s.Minimum);  						if (d < dmin)  						{  							csr = new CompactSpanReference(ax' az' i);  							dmin = d;  						}  					}  				}    				//only add if something new found  				if (csr.Index != -1)  				{  					stack.Add(csr);  				}  			}
Magic Number,SharpNav,PolyMeshDetail,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyMeshDetail.cs,BuildPolyDetail,The following statement contains a magic number: const int MAX_VERTS = 127;
Magic Number,SharpNav,PolyMeshDetail,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyMeshDetail.cs,BuildPolyDetail,The following statement contains a magic number: const int MAX_TRIS = 255;
Magic Number,SharpNav,PolyMeshDetail,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyMeshDetail.cs,BuildPolyDetail,The following statement contains a magic number: const int MAX_VERTS_PER_EDGE = 32;
Magic Number,SharpNav,PolyMeshDetail,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyMeshDetail.cs,BuildPolyDetail,The following statement contains a magic number: if (sampleDist > 0)  			{  				for (int i = 0' j = verts.Count - 1; i < verts.Count; j = i++)  				{  					Vector3 vi = verts[i];  					Vector3 vj = verts[j];  					bool swapped = false;    					//make sure order is correct' otherwise swap data  					if (Math.Abs(vj.X - vi.X) < 1E-06f)  					{  						if (vj.Z > vi.Z)  						{  							Vector3 temp = vj;  							vj = vi;  							vi = temp;  							swapped = true;  						}  					}  					else if (vj.X > vi.X)  					{  						Vector3 temp = vj;  						vj = vi;  						vi = temp;  						swapped = true;  					}    					//create samples along the edge  					Vector3 dv;  					Vector3.Subtract(ref vi' ref vj' out dv);  					float d = (float)Math.Sqrt(dv.X * dv.X + dv.Z * dv.Z);  					int nn = 1 + (int)Math.Floor(d / sampleDist);    					if (nn >= MAX_VERTS_PER_EDGE)  						nn = MAX_VERTS_PER_EDGE - 1;    					if (verts.Count + nn >= MAX_VERTS)  						nn = MAX_VERTS - 1 - verts.Count;    					for (int k = 0; k <= nn; k++)  					{  						float u = (float)k / (float)nn;  						Vector3 pos;    						Vector3 tmp;  						Vector3.Multiply(ref dv' u' out tmp);  						Vector3.Add(ref vj' ref tmp' out pos);    						pos.Y = GetHeight(pos' ics' compactField.CellHeight' hp) * compactField.CellHeight;    						edge[k] = pos;  					}    					//simplify samples  					int[] idx = new int[MAX_VERTS_PER_EDGE];  					idx[0] = 0;  					idx[1] = nn;  					int nidx = 2;    					for (int k = 0; k < nidx - 1;)  					{  						int a = idx[k];  						int b = idx[k + 1];  						Vector3 va = edge[a];  						Vector3 vb = edge[b];    						//find maximum deviation along segment  						float maxd = 0;  						int maxi = -1;  						for (int m = a + 1; m < b; m++)  						{  							float dev = Distance.PointToSegmentSquared(ref edge[m]' ref va' ref vb);  							if (dev > maxd)  							{  								maxd = dev;  								maxi = m;  							}  						}    						if (maxi != -1 && maxd > (sampleMaxError * sampleMaxError))  						{  							//shift data to the right  							for (int m = nidx; m > k; m--)  								idx[m] = idx[m - 1];    							//set new value  							idx[k + 1] = maxi;  							nidx++;  						}  						else  						{  							k++;  						}  					}    					hull.Add(j);    					//add new vertices  					if (swapped)  					{  						for (int k = nidx - 2; k > 0; k--)  						{  							hull.Add(verts.Count);  							verts.Add(edge[idx[k]]);  						}  					}  					else  					{  						for (int k = 1; k < nidx - 1; k++)  						{  							hull.Add(verts.Count);  							verts.Add(edge[idx[k]]);  						}  					}  				}  			}
Magic Number,SharpNav,PolyMeshDetail,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyMeshDetail.cs,BuildPolyDetail,The following statement contains a magic number: if (sampleDist > 0)  			{  				for (int i = 0' j = verts.Count - 1; i < verts.Count; j = i++)  				{  					Vector3 vi = verts[i];  					Vector3 vj = verts[j];  					bool swapped = false;    					//make sure order is correct' otherwise swap data  					if (Math.Abs(vj.X - vi.X) < 1E-06f)  					{  						if (vj.Z > vi.Z)  						{  							Vector3 temp = vj;  							vj = vi;  							vi = temp;  							swapped = true;  						}  					}  					else if (vj.X > vi.X)  					{  						Vector3 temp = vj;  						vj = vi;  						vi = temp;  						swapped = true;  					}    					//create samples along the edge  					Vector3 dv;  					Vector3.Subtract(ref vi' ref vj' out dv);  					float d = (float)Math.Sqrt(dv.X * dv.X + dv.Z * dv.Z);  					int nn = 1 + (int)Math.Floor(d / sampleDist);    					if (nn >= MAX_VERTS_PER_EDGE)  						nn = MAX_VERTS_PER_EDGE - 1;    					if (verts.Count + nn >= MAX_VERTS)  						nn = MAX_VERTS - 1 - verts.Count;    					for (int k = 0; k <= nn; k++)  					{  						float u = (float)k / (float)nn;  						Vector3 pos;    						Vector3 tmp;  						Vector3.Multiply(ref dv' u' out tmp);  						Vector3.Add(ref vj' ref tmp' out pos);    						pos.Y = GetHeight(pos' ics' compactField.CellHeight' hp) * compactField.CellHeight;    						edge[k] = pos;  					}    					//simplify samples  					int[] idx = new int[MAX_VERTS_PER_EDGE];  					idx[0] = 0;  					idx[1] = nn;  					int nidx = 2;    					for (int k = 0; k < nidx - 1;)  					{  						int a = idx[k];  						int b = idx[k + 1];  						Vector3 va = edge[a];  						Vector3 vb = edge[b];    						//find maximum deviation along segment  						float maxd = 0;  						int maxi = -1;  						for (int m = a + 1; m < b; m++)  						{  							float dev = Distance.PointToSegmentSquared(ref edge[m]' ref va' ref vb);  							if (dev > maxd)  							{  								maxd = dev;  								maxi = m;  							}  						}    						if (maxi != -1 && maxd > (sampleMaxError * sampleMaxError))  						{  							//shift data to the right  							for (int m = nidx; m > k; m--)  								idx[m] = idx[m - 1];    							//set new value  							idx[k + 1] = maxi;  							nidx++;  						}  						else  						{  							k++;  						}  					}    					hull.Add(j);    					//add new vertices  					if (swapped)  					{  						for (int k = nidx - 2; k > 0; k--)  						{  							hull.Add(verts.Count);  							verts.Add(edge[idx[k]]);  						}  					}  					else  					{  						for (int k = 1; k < nidx - 1; k++)  						{  							hull.Add(verts.Count);  							verts.Add(edge[idx[k]]);  						}  					}  				}  			}
Magic Number,SharpNav,PolyMeshDetail,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyMeshDetail.cs,BuildPolyDetail,The following statement contains a magic number: if (minExtent < sampleDist * 2)  			{  				TriangulateHull(verts' hull' tris);  				return;  			}
Magic Number,SharpNav,PolyMeshDetail,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyMeshDetail.cs,GetHeight,The following statement contains a magic number: if (!hp.TryGetHeight(ix' iz' out h))  			{  				//go in counterclockwise direction starting from west' ending in northwest  				int[] off =  				{  					-1'  0'  					-1' -1'  					 0' -1'  					 1' -1'  					 1'  0'  					 1'  1'  					 0'  1'  					-1'  1  				};    				float dmin = float.MaxValue;    				for (int i = 0; i < 8; i++)  				{  					int nx = ix + off[i * 2 + 0];  					int nz = iz + off[i * 2 + 1];    					if (nx < 0 || nz < 0 || nx >= hp.Width || nz >= hp.Length)  						continue;    					int nh;  					if (!hp.TryGetHeight(nx' nz' out nh))  						continue;    					float d = Math.Abs(nh * cellHeight - loc.Y);  					if (d < dmin)  					{  						h = nh;  						dmin = d;  					}  				}  			}
Magic Number,SharpNav,PolyMeshDetail,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyMeshDetail.cs,GetHeight,The following statement contains a magic number: if (!hp.TryGetHeight(ix' iz' out h))  			{  				//go in counterclockwise direction starting from west' ending in northwest  				int[] off =  				{  					-1'  0'  					-1' -1'  					 0' -1'  					 1' -1'  					 1'  0'  					 1'  1'  					 0'  1'  					-1'  1  				};    				float dmin = float.MaxValue;    				for (int i = 0; i < 8; i++)  				{  					int nx = ix + off[i * 2 + 0];  					int nz = iz + off[i * 2 + 1];    					if (nx < 0 || nz < 0 || nx >= hp.Width || nz >= hp.Length)  						continue;    					int nh;  					if (!hp.TryGetHeight(nx' nz' out nh))  						continue;    					float d = Math.Abs(nh * cellHeight - loc.Y);  					if (d < dmin)  					{  						h = nh;  						dmin = d;  					}  				}  			}
Magic Number,SharpNav,PolyMeshDetail,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyMeshDetail.cs,GetHeight,The following statement contains a magic number: if (!hp.TryGetHeight(ix' iz' out h))  			{  				//go in counterclockwise direction starting from west' ending in northwest  				int[] off =  				{  					-1'  0'  					-1' -1'  					 0' -1'  					 1' -1'  					 1'  0'  					 1'  1'  					 0'  1'  					-1'  1  				};    				float dmin = float.MaxValue;    				for (int i = 0; i < 8; i++)  				{  					int nx = ix + off[i * 2 + 0];  					int nz = iz + off[i * 2 + 1];    					if (nx < 0 || nz < 0 || nx >= hp.Width || nz >= hp.Length)  						continue;    					int nh;  					if (!hp.TryGetHeight(nx' nz' out nh))  						continue;    					float d = Math.Abs(nh * cellHeight - loc.Y);  					if (d < dmin)  					{  						h = nh;  						dmin = d;  					}  				}  			}
Magic Number,SharpNav,PolyMeshDetail,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyMeshDetail.cs,CircumCircle,The following statement contains a magic number: if (Math.Abs(cp) > EPS)  			{  				//find magnitude of each point  				float p1sq' p2sq' p3sq;    				Vector3Extensions.Dot2D(ref p1' ref p1' out p1sq);  				Vector3Extensions.Dot2D(ref p2' ref p2' out p2sq);  				Vector3Extensions.Dot2D(ref p3' ref p3' out p3sq);    				c.X = (p1sq * (p2.Z - p3.Z) + p2sq * (p3.Z - p1.Z) + p3sq * (p1.Z - p2.Z)) / (2 * cp);  				c.Z = (p1sq * (p3.X - p2.X) + p2sq * (p1.X - p3.X) + p3sq * (p2.X - p1.X)) / (2 * cp);    				float dx = p1.X - c.X;  				float dy = p1.Z - c.Z;  				r = (float)Math.Sqrt(dx * dx + dy * dy);  				return true;  			}
Magic Number,SharpNav,PolyMeshDetail,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyMeshDetail.cs,CircumCircle,The following statement contains a magic number: if (Math.Abs(cp) > EPS)  			{  				//find magnitude of each point  				float p1sq' p2sq' p3sq;    				Vector3Extensions.Dot2D(ref p1' ref p1' out p1sq);  				Vector3Extensions.Dot2D(ref p2' ref p2' out p2sq);  				Vector3Extensions.Dot2D(ref p3' ref p3' out p3sq);    				c.X = (p1sq * (p2.Z - p3.Z) + p2sq * (p3.Z - p1.Z) + p3sq * (p1.Z - p2.Z)) / (2 * cp);  				c.Z = (p1sq * (p3.X - p2.X) + p2sq * (p1.X - p3.X) + p3sq * (p2.X - p1.X)) / (2 * cp);    				float dx = p1.X - c.X;  				float dy = p1.Z - c.Z;  				r = (float)Math.Sqrt(dx * dx + dy * dy);  				return true;  			}
Magic Number,SharpNav,TriangleData,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyMeshDetail.cs,GetTriFlags,The following statement contains a magic number: flags |= GetEdgeFlags(verts[t.VertexHash1]' verts[t.VertexHash2]' vpoly' npoly) << 2;
Magic Number,SharpNav,TriangleData,C:\repos\Robmaister_SharpNav\Source\SharpNav\PolyMeshDetail.cs,GetTriFlags,The following statement contains a magic number: flags |= GetEdgeFlags(verts[t.VertexHash2]' verts[t.VertexHash0]' vpoly' npoly) << 4;
Magic Number,SharpNav,NavMeshQuery,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshQuery.cs,NavMeshQuery,The following statement contains a magic number: tinyNodePool = new NodePool(64/*' 32*/);
Magic Number,SharpNav,NavMeshQuery,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshQuery.cs,FindRandomPoint,The following statement contains a magic number: for (int i = 0; i < tile.PolyCount; i++)  			{  				NavPoly p = tile.Polys[i];    				//don't return off-mesh connection polygons  				if (p.PolyType != NavPolyType.Ground)  					continue;    				NavPolyId reference;  				nav.IdManager.SetPolyIndex(ref polyBase' i' out reference);    				//calculate area of polygon  				float polyArea = 0.0f;  				float area;  				for (int j = 2; j < p.VertCount; j++)  				{  					Triangle3.Area2D(ref tile.Verts[p.Verts[0]]' ref tile.Verts[p.Verts[j - 1]]' ref tile.Verts[p.Verts[j]]' out area);  					polyArea += area;  				}    				//choose random polygon weighted by area' usig resevoir sampling  				areaSum += polyArea;  				float u = (float)rand.NextDouble();  				if (u * areaSum <= polyArea)  				{  					polyRef = reference;  				}  			}
Magic Number,SharpNav,NavMeshQuery,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshQuery.cs,FindRandomPointAroundCircle,The following statement contains a magic number: while (openList.Count > 0)  			{  				NavNode bestNode = openList.Pop();  				SetNodeFlagClosed(ref bestNode);    				//get poly and tile  				NavPolyId bestRef = bestNode.Id;  				NavTile bestTile;  				NavPoly bestPoly;  				nav.TryGetTileAndPolyByRefUnsafe(bestRef' out bestTile' out bestPoly);    				//place random locations on ground  				if (bestPoly.PolyType == NavPolyType.Ground)  				{  					//calculate area of polygon  					float polyArea = 0.0f;  					float area;  					for (int j = 2; j < bestPoly.VertCount; j++)  					{  						Triangle3.Area2D(ref bestTile.Verts[bestPoly.Verts[0]]' ref bestTile.Verts[bestPoly.Verts[j - 1]]' ref bestTile.Verts[bestPoly.Verts[j]]' out area);  						polyArea += area;  					}    					//choose random polygon weighted by area using resevoir sampling  					areaSum += polyArea;  					float u = (float)rand.NextDouble();  					if (u * areaSum <= polyArea)  					{  						randomPolyRef = bestRef;  					}  				}    				//get parent poly and tile  				NavPolyId parentRef = NavPolyId.Null;  				if (bestNode.ParentIndex != 0)  					parentRef = nodePool.GetNodeAtIdx(bestNode.ParentIndex).Id;    				foreach (Link link in bestPoly.Links)  				{  					NavPolyId neighborRef = link.Reference;    					//skip invalid neighbors and do not follow back to parent  					if (neighborRef == NavPolyId.Null || neighborRef == parentRef)  						continue;    					//expand to neighbor  					NavTile neighborTile;  					NavPoly neighborPoly;  					nav.TryGetTileAndPolyByRefUnsafe(neighborRef' out neighborTile' out neighborPoly);    					//find edge and calculate distance to edge  					Vector3 va = new Vector3();  					Vector3 vb = new Vector3();  					if (!GetPortalPoints(bestRef' bestPoly' bestTile' neighborRef' neighborPoly' neighborTile' ref va' ref vb))  						continue;    					//if circle isn't touching next polygon' skip it  					if (doRadiusCheck)  					{  						float tseg;  						float distSqr = Distance.PointToSegment2DSquared(ref center.Position' ref va' ref vb' out tseg);  						if (distSqr > radiusSqr)  							continue;  					}    					NavNode neighborNode = nodePool.GetNode(neighborRef);  					if (neighborNode == null)  						continue;    					if (IsInClosedList(neighborNode))  						continue;    					//cost  					if (neighborNode.Flags == 0)  						neighborNode.Position = Vector3.Lerp(va' vb' 0.5f);    					float total = bestNode.TotalCost + (bestNode.Position - neighborNode.Position).Length();    					//node is already in open list and new result is worse' so skip  					if (IsInOpenList(neighborNode) && total >= neighborNode.TotalCost)  						continue;    					neighborNode.Id = neighborRef;  					neighborNode.Flags = RemoveNodeFlagClosed(neighborNode);  					neighborNode.ParentIndex = nodePool.GetNodeIdx(bestNode);  					neighborNode.TotalCost = total;    					if (IsInOpenList(neighborNode))  					{  						openList.Modify(neighborNode);  					}  					else  					{  						neighborNode.Flags = NodeFlags.Open;  						openList.Push(neighborNode);  					}  				}  			}
Magic Number,SharpNav,NavMeshQuery,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshQuery.cs,FindStraightPath,The following statement contains a magic number: if (path.Count > 1)  			{  				Vector3 portalApex = closestStartPos;  				Vector3 portalLeft = portalApex;  				Vector3 portalRight = portalApex;  				int apexIndex = 0;  				int leftIndex = 0;  				int rightIndex = 0;    				NavPolyType leftPolyType = 0;  				NavPolyType rightPolyType = 0;    				NavPolyId leftPolyRef = path[0];  				NavPolyId rightPolyRef = path[0];    				for (int i = 0; i < path.Count; i++)  				{  					Vector3 left = new Vector3();  					Vector3 right = new Vector3();  					NavPolyType fromType = 0' toType = 0;    					if (i + 1 < path.Count)  					{  						//next portal  						if (GetPortalPoints(path[i]' path[i + 1]' ref left' ref right' ref fromType' ref toType) == false)  						{  							//failed to get portal points means path[i + 1] is an invalid polygon  							//clamp end point to path[i] and return path so far  							if (ClosestPointOnPolyBoundary(path[i]' endPos' ref closestEndPos) == false)  							{  								//first polygon is invalid  								return false;  							}    							if ((options & (PathBuildFlags.AreaCrossingVertices | PathBuildFlags.AllCrossingVertices)) != 0)  							{  								//append portals  								stat = AppendPortals(apexIndex' i' closestEndPos' path' straightPath' options);  							}    							stat = straightPath.AppendVertex(new StraightPathVertex(new NavPoint(path[i]' closestEndPos)' StraightPathFlags.None));    							return true;  						}    						//if starting really close to the portal' advance  						if (i == 0)  						{  							float t;  							if (Distance.PointToSegment2DSquared(ref portalApex' ref left' ref right' out t) < 0.001 * 0.001)  								continue;  						}  					}  					else  					{  						//end of the path  						left = closestEndPos;  						right = closestEndPos;    						fromType = toType = NavPolyType.Ground;  					}    					//right vertex  					float triArea2D;  					Triangle3.Area2D(ref portalApex' ref portalRight' ref right' out triArea2D);  					if (triArea2D <= 0.0)  					{  						Triangle3.Area2D(ref portalApex' ref portalLeft' ref right' out triArea2D);  						if (portalApex == portalRight || triArea2D > 0.0)  						{  							portalRight = right;  							rightPolyRef = (i + 1 < path.Count) ? path[i + 1] : NavPolyId.Null;  							rightPolyType = toType;  							rightIndex = i;  						}  						else  						{  							//append portals along current straight path segment  							if ((options & (PathBuildFlags.AreaCrossingVertices | PathBuildFlags.AllCrossingVertices)) != 0)  							{  								stat = AppendPortals(apexIndex' leftIndex' portalLeft' path' straightPath' options);    								if (stat != true)  									return true;  							}    							portalApex = portalLeft;  							apexIndex = leftIndex;    							StraightPathFlags flags = 0;  							if (leftPolyRef == NavPolyId.Null)  								flags = StraightPathFlags.End;  							else if (leftPolyType == NavPolyType.OffMeshConnection)  								flags = StraightPathFlags.OffMeshConnection;    							NavPolyId reference = leftPolyRef;    							//append or update vertex  							stat = straightPath.AppendVertex(new StraightPathVertex(new NavPoint(reference' portalApex)' flags));    							if (stat != true)  								return true;    							portalLeft = portalApex;  							portalRight = portalApex;  							leftIndex = apexIndex;  							rightIndex = apexIndex;    							//restart  							i = apexIndex;    							continue;  						}  					}    					//left vertex  					Triangle3.Area2D(ref portalApex' ref portalLeft' ref left' out triArea2D);  					if (triArea2D >= 0.0)  					{  						Triangle3.Area2D(ref portalApex' ref portalRight' ref left' out triArea2D);  						if (portalApex == portalLeft || triArea2D < 0.0f)  						{  							portalLeft = left;  							leftPolyRef = (i + 1 < path.Count) ? path[i + 1] : NavPolyId.Null;  							leftPolyType = toType;  							leftIndex = i;  						}  						else  						{  							if ((options & (PathBuildFlags.AreaCrossingVertices | PathBuildFlags.AllCrossingVertices)) != 0)  							{  								stat = AppendPortals(apexIndex' rightIndex' portalRight' path' straightPath' options);    								if (stat != true)  									return true;  							}    							portalApex = portalRight;  							apexIndex = rightIndex;    							StraightPathFlags flags = 0;  							if (rightPolyRef == NavPolyId.Null)  								flags = StraightPathFlags.End;  							else if (rightPolyType == NavPolyType.OffMeshConnection)  								flags = StraightPathFlags.OffMeshConnection;    							NavPolyId reference = rightPolyRef;    							//append or update vertex  							stat = straightPath.AppendVertex(new StraightPathVertex(new NavPoint(reference' portalApex)' flags));    							if (stat != true)  								return true;    							portalLeft = portalApex;  							portalRight = portalApex;  							leftIndex = apexIndex;  							rightIndex = apexIndex;    							//restart   							i = apexIndex;    							continue;  						}  					}  				}    				//append portals along the current straight line segment  				if ((options & (PathBuildFlags.AreaCrossingVertices | PathBuildFlags.AllCrossingVertices)) != 0)  				{  					stat = AppendPortals(apexIndex' path.Count - 1' closestEndPos' path' straightPath' options);    					if (stat != true)  						return true;  				}  			}
Magic Number,SharpNav,NavMeshQuery,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshQuery.cs,FindStraightPath,The following statement contains a magic number: if (path.Count > 1)  			{  				Vector3 portalApex = closestStartPos;  				Vector3 portalLeft = portalApex;  				Vector3 portalRight = portalApex;  				int apexIndex = 0;  				int leftIndex = 0;  				int rightIndex = 0;    				NavPolyType leftPolyType = 0;  				NavPolyType rightPolyType = 0;    				NavPolyId leftPolyRef = path[0];  				NavPolyId rightPolyRef = path[0];    				for (int i = 0; i < path.Count; i++)  				{  					Vector3 left = new Vector3();  					Vector3 right = new Vector3();  					NavPolyType fromType = 0' toType = 0;    					if (i + 1 < path.Count)  					{  						//next portal  						if (GetPortalPoints(path[i]' path[i + 1]' ref left' ref right' ref fromType' ref toType) == false)  						{  							//failed to get portal points means path[i + 1] is an invalid polygon  							//clamp end point to path[i] and return path so far  							if (ClosestPointOnPolyBoundary(path[i]' endPos' ref closestEndPos) == false)  							{  								//first polygon is invalid  								return false;  							}    							if ((options & (PathBuildFlags.AreaCrossingVertices | PathBuildFlags.AllCrossingVertices)) != 0)  							{  								//append portals  								stat = AppendPortals(apexIndex' i' closestEndPos' path' straightPath' options);  							}    							stat = straightPath.AppendVertex(new StraightPathVertex(new NavPoint(path[i]' closestEndPos)' StraightPathFlags.None));    							return true;  						}    						//if starting really close to the portal' advance  						if (i == 0)  						{  							float t;  							if (Distance.PointToSegment2DSquared(ref portalApex' ref left' ref right' out t) < 0.001 * 0.001)  								continue;  						}  					}  					else  					{  						//end of the path  						left = closestEndPos;  						right = closestEndPos;    						fromType = toType = NavPolyType.Ground;  					}    					//right vertex  					float triArea2D;  					Triangle3.Area2D(ref portalApex' ref portalRight' ref right' out triArea2D);  					if (triArea2D <= 0.0)  					{  						Triangle3.Area2D(ref portalApex' ref portalLeft' ref right' out triArea2D);  						if (portalApex == portalRight || triArea2D > 0.0)  						{  							portalRight = right;  							rightPolyRef = (i + 1 < path.Count) ? path[i + 1] : NavPolyId.Null;  							rightPolyType = toType;  							rightIndex = i;  						}  						else  						{  							//append portals along current straight path segment  							if ((options & (PathBuildFlags.AreaCrossingVertices | PathBuildFlags.AllCrossingVertices)) != 0)  							{  								stat = AppendPortals(apexIndex' leftIndex' portalLeft' path' straightPath' options);    								if (stat != true)  									return true;  							}    							portalApex = portalLeft;  							apexIndex = leftIndex;    							StraightPathFlags flags = 0;  							if (leftPolyRef == NavPolyId.Null)  								flags = StraightPathFlags.End;  							else if (leftPolyType == NavPolyType.OffMeshConnection)  								flags = StraightPathFlags.OffMeshConnection;    							NavPolyId reference = leftPolyRef;    							//append or update vertex  							stat = straightPath.AppendVertex(new StraightPathVertex(new NavPoint(reference' portalApex)' flags));    							if (stat != true)  								return true;    							portalLeft = portalApex;  							portalRight = portalApex;  							leftIndex = apexIndex;  							rightIndex = apexIndex;    							//restart  							i = apexIndex;    							continue;  						}  					}    					//left vertex  					Triangle3.Area2D(ref portalApex' ref portalLeft' ref left' out triArea2D);  					if (triArea2D >= 0.0)  					{  						Triangle3.Area2D(ref portalApex' ref portalRight' ref left' out triArea2D);  						if (portalApex == portalLeft || triArea2D < 0.0f)  						{  							portalLeft = left;  							leftPolyRef = (i + 1 < path.Count) ? path[i + 1] : NavPolyId.Null;  							leftPolyType = toType;  							leftIndex = i;  						}  						else  						{  							if ((options & (PathBuildFlags.AreaCrossingVertices | PathBuildFlags.AllCrossingVertices)) != 0)  							{  								stat = AppendPortals(apexIndex' rightIndex' portalRight' path' straightPath' options);    								if (stat != true)  									return true;  							}    							portalApex = portalRight;  							apexIndex = rightIndex;    							StraightPathFlags flags = 0;  							if (rightPolyRef == NavPolyId.Null)  								flags = StraightPathFlags.End;  							else if (rightPolyType == NavPolyType.OffMeshConnection)  								flags = StraightPathFlags.OffMeshConnection;    							NavPolyId reference = rightPolyRef;    							//append or update vertex  							stat = straightPath.AppendVertex(new StraightPathVertex(new NavPoint(reference' portalApex)' flags));    							if (stat != true)  								return true;    							portalLeft = portalApex;  							portalRight = portalApex;  							leftIndex = apexIndex;  							rightIndex = apexIndex;    							//restart   							i = apexIndex;    							continue;  						}  					}  				}    				//append portals along the current straight line segment  				if ((options & (PathBuildFlags.AreaCrossingVertices | PathBuildFlags.AllCrossingVertices)) != 0)  				{  					stat = AppendPortals(apexIndex' path.Count - 1' closestEndPos' path' straightPath' options);    					if (stat != true)  						return true;  				}  			}
Magic Number,SharpNav,NavMeshQuery,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshQuery.cs,MoveAlongSurface,The following statement contains a magic number: int MAX_STACK = 48;
Magic Number,SharpNav,NavMeshQuery,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshQuery.cs,MoveAlongSurface,The following statement contains a magic number: while (nodeQueue.Count > 0)  			{  				//pop front  				NavNode curNode = nodeQueue.Dequeue();    				//get poly and tile  				NavPolyId curRef = curNode.Id;  				NavTile curTile;  				NavPoly curPoly;  				nav.TryGetTileAndPolyByRefUnsafe(curRef' out curTile' out curPoly);    				//collect vertices  				int nverts = curPoly.VertCount;  				for (int i = 0; i < nverts; i++)  					verts[i] = curTile.Verts[curPoly.Verts[i]];    				//if target is inside poly' stop search  				if (Containment.PointInPoly(endPos' verts' nverts))  				{  					bestNode = curNode;  					bestPos = endPos;  					break;  				}    				//find wall edges and find nearest point inside walls  				for (int i = 0' j = curPoly.VertCount - 1; i < curPoly.VertCount; j = i++)  				{  					//find links to neighbors  					List<NavPolyId> neis = new List<NavPolyId>(8);    					if ((curPoly.Neis[j] & Link.External) != 0)  					{  						//tile border  						foreach (Link link in curPoly.Links)  						{  							if (link.Edge == j)  							{  								if (link.Reference != NavPolyId.Null)  								{  									NavTile neiTile;  									NavPoly neiPoly;  									nav.TryGetTileAndPolyByRefUnsafe(link.Reference' out neiTile' out neiPoly);  									  									if (neis.Count < neis.Capacity)  										neis.Add(link.Reference);  								}  							}  						}  					}  					else if (curPoly.Neis[j] != 0)  					{  						int idx = curPoly.Neis[j] - 1;  						NavPolyId reference = nav.GetTileRef(curTile);  						nav.IdManager.SetPolyIndex(ref reference' idx' out reference);  						neis.Add(reference); //internal edge' encode id  					}    					if (neis.Count == 0)  					{  						//wall edge' calculate distance  						float tseg = 0;  						float distSqr = Distance.PointToSegment2DSquared(ref endPos' ref verts[j]' ref verts[i]' out tseg);  						if (distSqr < bestDist)  						{  							//update nearest distance  							bestPos = Vector3.Lerp(verts[j]' verts[i]' tseg);  							bestDist = distSqr;  							bestNode = curNode;  						}  					}  					else  					{  						for (int k = 0; k < neis.Count; k++)  						{  							//skip if no node can be allocated  							NavNode neighborNode = tinyNodePool.GetNode(neis[k]);  							if (neighborNode == null)  								continue;  							  							//skip if already visited  							if ((neighborNode.Flags & NodeFlags.Closed) != 0)  								continue;    							//skip the link if too far from search constraint  							float distSqr = Distance.PointToSegment2DSquared(ref searchPos' ref verts[j]' ref verts[i]);  							if (distSqr > searchRadSqr)  								continue;    							//mark the node as visited and push to queue  							if (nodeQueue.Count < MAX_STACK)  							{  								neighborNode.ParentIndex = tinyNodePool.GetNodeIdx(curNode);  								neighborNode.Flags |= NodeFlags.Closed;  								nodeQueue.Enqueue(neighborNode);  							}  						}  					}  				}  			}
Magic Number,SharpNav,NavMeshQuery,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshQuery.cs,Raycast,The following statement contains a magic number: while (curRef != NavPolyId.Null)  			{  				//collect vertices  				int nv = 0;  				for (int i = 0; i < curPoly.VertCount; i++)  				{  					verts[nv] = curTile.Verts[curPoly.Verts[i]];  					nv++;  				}    				float tmin' tmax;  				int segMin' segMax;  				if (!Intersection.SegmentPoly2D(startPoint.Position' endPos' verts' nv' out tmin' out tmax' out segMin' out segMax))  				{  					//could not hit the polygon' keep the old t and report hit  					return true;  				}    				hit.EdgeIndex = segMax;    				//keep track of furthest t so far  				if (tmax > hit.T)  					hit.T = tmax;    				//store visited polygons  				if (hitPath != null)  					hitPath.Add(curRef);    				//ray end is completely inside the polygon  				if (segMax == -1)  				{  					hit.T = float.MaxValue;      					return true;  				}    				//follow neighbors  				NavPolyId nextRef = NavPolyId.Null;    				foreach (Link link in curPoly.Links)  				{  					//find link which contains the edge  					if (link.Edge != segMax)  						continue;    					//get pointer to the next polygon  					nav.TryGetTileAndPolyByRefUnsafe(link.Reference' out nextTile' out nextPoly);    					//skip off-mesh connection  					if (nextPoly.PolyType == NavPolyType.OffMeshConnection)  						continue;    					//TODO QueryFilter    					//if the link is internal' just return the ref  					if (link.Side == BoundarySide.Internal)  					{  						nextRef = link.Reference;  						break;  					}    					//if the link is at the tile boundary    					//check if the link spans the whole edge and accept  					if (link.BMin == 0 && link.BMax == 255)  					{  						nextRef = link.Reference;  						break;  					}    					//check for partial edge links  					int v0 = curPoly.Verts[link.Edge];  					int v1 = curPoly.Verts[(link.Edge + 1) % curPoly.VertCount];  					Vector3 left = curTile.Verts[v0];  					Vector3 right = curTile.Verts[v1];    					//check that the intersection lies inside the link portal  					if (link.Side == BoundarySide.PlusX || link.Side == BoundarySide.MinusX)  					{  						//calculate link size  						float s = 1.0f / 255.0f;  						float lmin = left.Z + (right.Z - left.Z) * (link.BMin * s);  						float lmax = left.Z + (right.Z - left.Z) * (link.BMax * s);  						if (lmin > lmax)  						{  							//swap  							float temp = lmin;  							lmin = lmax;  							lmax = temp;  						}    						//find z intersection  						float z = startPoint.Position.Z + (endPos.Z - startPoint.Position.Z) * tmax;  						if (z >= lmin && z <= lmax)  						{  							nextRef = link.Reference;  							break;  						}  					}  					else if (link.Side == BoundarySide.PlusZ || link.Side == BoundarySide.MinusZ)  					{  						//calculate link size  						float s = 1.0f / 255.0f;  						float lmin = left.X + (right.X - left.X) * (link.BMin * s);  						float lmax = left.X + (right.X - left.X) * (link.BMax * s);  						if (lmin > lmax)  						{  							//swap  							float temp = lmin;  							lmin = lmax;  							lmax = temp;  						}    						//find x intersection  						float x = startPoint.Position.X + (endPos.X - startPoint.Position.X) * tmax;  						if (x >= lmin && x <= lmax)  						{  							nextRef = link.Reference;  							break;  						}  					}  				}    				if ((options & RaycastOptions.UseCosts) != 0)  				{  					//TODO add cost  				}    				if (nextRef == NavPolyId.Null)  				{  					//no neighbor' we hit a wall    					//calculate hit normal  					int a = segMax;  					int b = (segMax + 1) < nv ? segMax + 1 : 0;  					Vector3 va = verts[a];  					Vector3 vb = verts[b];  					float dx = vb.X - va.X;  					float dz = vb.Z - va.Z;  					hit.Normal = new Vector3(dz' 0' dx);  					hit.Normal.Normalize();  					return true;  				}    				//no hit' advance to neighbor polygon  				prevRef = curRef;  				curRef = nextRef;  				prevTile = curTile;  				curTile = nextTile;  				prevPoly = curPoly;  				curPoly = nextPoly;  			}
Magic Number,SharpNav,NavMeshQuery,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshQuery.cs,FindLocalNeighborhood,The following statement contains a magic number: int MAX_STACK = 48;
Magic Number,SharpNav,NavMeshQuery,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshQuery.cs,GetPolyWallSegments,The following statement contains a magic number: int MAX_INTERVAL = 16;
Magic Number,SharpNav,NavMeshQuery,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshQuery.cs,GetPolyWallSegments,The following statement contains a magic number: for (int i = 0' j = poly.VertCount - 1; i < poly.VertCount; j = i++)  			{  				//skip non-solid edges  				nints = 0;  				if ((poly.Neis[j] & Link.External) != 0)  				{  					//tile border  					foreach (Link link in poly.Links)  					{  						if (link.Edge == j)  						{  							if (link.Reference != NavPolyId.Null)  							{  								NavTile neiTile;  								NavPoly neiPoly;  								nav.TryGetTileAndPolyByRefUnsafe(link.Reference' out neiTile' out neiPoly);  								InsertInterval(ints' ref nints' MAX_INTERVAL' link.BMin' link.BMax' link.Reference);  							}  						}  					}  				}  				else  				{  					//internal edge  					NavPolyId neiRef = NavPolyId.Null;  					if (poly.Neis[j] != 0)  					{  						int idx = poly.Neis[j] - 1;  						NavPolyId id = nav.GetTileRef(tile);  						nav.IdManager.SetPolyIndex(ref id' idx' out neiRef);  					}    					//if the edge leads to another polygon and portals are not stored' skip  					if (neiRef != NavPolyId.Null && !storePortals)  						continue;    					if (n < maxSegments)  					{  						Vector3 vj = tile.Verts[poly.Verts[j]];  						Vector3 vi = tile.Verts[poly.Verts[i]];  						segmentVerts[n].Start = vj;  						segmentVerts[n].End = vi;  						segmentRefs[n] = neiRef;  						n++; //could be n += 2' since segments have 2 vertices  					}    					continue;  				}    				//add sentinels  				InsertInterval(ints' ref nints' MAX_INTERVAL' -1' 0' NavPolyId.Null);  				InsertInterval(ints' ref nints' MAX_INTERVAL' 255' 256' NavPolyId.Null);    				//store segments  				Vector3 vj2 = tile.Verts[poly.Verts[j]];  				Vector3 vi2 = tile.Verts[poly.Verts[i]];  				for (int k = 1; k < nints; k++)  				{  					//portal segment  					if (storePortals && ints[k].Reference != NavPolyId.Null)  					{  						float tmin = ints[k].TMin / 255.0f;  						float tmax = ints[k].TMax / 255.0f;  						if (n < maxSegments)  						{  							Vector3.Lerp(ref vj2' ref vi2' tmin' out segmentVerts[n].Start);  							Vector3.Lerp(ref vj2' ref vi2' tmax' out segmentVerts[n].End);  							segmentRefs[n] = ints[k].Reference;  							n++;  						}  					}    					//wall segment  					int imin = ints[k - 1].TMax;  					int imax = ints[k].TMin;  					if (imin != imax)  					{  						float tmin = imin / 255.0f;  						float tmax = imax / 255.0f;  						if (n < maxSegments)  						{  							Vector3.Lerp(ref vj2' ref vi2' tmin' out segmentVerts[n].Start);  							Vector3.Lerp(ref vj2' ref vi2' tmax' out segmentVerts[n].End);  							segmentRefs[n] = NavPolyId.Null;  							n++;   						}  					}  				}  			}
Magic Number,SharpNav,NavMeshQuery,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshQuery.cs,GetPolyWallSegments,The following statement contains a magic number: for (int i = 0' j = poly.VertCount - 1; i < poly.VertCount; j = i++)  			{  				//skip non-solid edges  				nints = 0;  				if ((poly.Neis[j] & Link.External) != 0)  				{  					//tile border  					foreach (Link link in poly.Links)  					{  						if (link.Edge == j)  						{  							if (link.Reference != NavPolyId.Null)  							{  								NavTile neiTile;  								NavPoly neiPoly;  								nav.TryGetTileAndPolyByRefUnsafe(link.Reference' out neiTile' out neiPoly);  								InsertInterval(ints' ref nints' MAX_INTERVAL' link.BMin' link.BMax' link.Reference);  							}  						}  					}  				}  				else  				{  					//internal edge  					NavPolyId neiRef = NavPolyId.Null;  					if (poly.Neis[j] != 0)  					{  						int idx = poly.Neis[j] - 1;  						NavPolyId id = nav.GetTileRef(tile);  						nav.IdManager.SetPolyIndex(ref id' idx' out neiRef);  					}    					//if the edge leads to another polygon and portals are not stored' skip  					if (neiRef != NavPolyId.Null && !storePortals)  						continue;    					if (n < maxSegments)  					{  						Vector3 vj = tile.Verts[poly.Verts[j]];  						Vector3 vi = tile.Verts[poly.Verts[i]];  						segmentVerts[n].Start = vj;  						segmentVerts[n].End = vi;  						segmentRefs[n] = neiRef;  						n++; //could be n += 2' since segments have 2 vertices  					}    					continue;  				}    				//add sentinels  				InsertInterval(ints' ref nints' MAX_INTERVAL' -1' 0' NavPolyId.Null);  				InsertInterval(ints' ref nints' MAX_INTERVAL' 255' 256' NavPolyId.Null);    				//store segments  				Vector3 vj2 = tile.Verts[poly.Verts[j]];  				Vector3 vi2 = tile.Verts[poly.Verts[i]];  				for (int k = 1; k < nints; k++)  				{  					//portal segment  					if (storePortals && ints[k].Reference != NavPolyId.Null)  					{  						float tmin = ints[k].TMin / 255.0f;  						float tmax = ints[k].TMax / 255.0f;  						if (n < maxSegments)  						{  							Vector3.Lerp(ref vj2' ref vi2' tmin' out segmentVerts[n].Start);  							Vector3.Lerp(ref vj2' ref vi2' tmax' out segmentVerts[n].End);  							segmentRefs[n] = ints[k].Reference;  							n++;  						}  					}    					//wall segment  					int imin = ints[k - 1].TMax;  					int imax = ints[k].TMin;  					if (imin != imax)  					{  						float tmin = imin / 255.0f;  						float tmax = imax / 255.0f;  						if (n < maxSegments)  						{  							Vector3.Lerp(ref vj2' ref vi2' tmin' out segmentVerts[n].Start);  							Vector3.Lerp(ref vj2' ref vi2' tmax' out segmentVerts[n].End);  							segmentRefs[n] = NavPolyId.Null;  							n++;   						}  					}  				}  			}
Magic Number,SharpNav,NavMeshQuery,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshQuery.cs,GetPortalPoints,The following statement contains a magic number: if (link.Side != BoundarySide.Internal)  			{  				//unpack portal limits  				if (link.BMin != 0 || link.BMax != 255)  				{  					float s = 1.0f / 255.0f;  					float tmin = link.BMin * s;  					float tmax = link.BMax * s;  					left = Vector3.Lerp(fromTile.Verts[v0]' fromTile.Verts[v1]' tmin);  					right = Vector3.Lerp(fromTile.Verts[v0]' fromTile.Verts[v1]' tmax);  				}  			}
Magic Number,SharpNav,NavMeshQuery,C:\repos\Robmaister_SharpNav\Source\SharpNav\NavMeshQuery.cs,FindNearestPoly,The following statement contains a magic number: List<NavPolyId> polys = new List<NavPolyId>(128);
Magic Number,SharpNav,MathHelper,C:\repos\Robmaister_SharpNav\Source\SharpNav\MathHelper.cs,NextPowerOfTwo,The following statement contains a magic number: v |= v >> 2;
Magic Number,SharpNav,MathHelper,C:\repos\Robmaister_SharpNav\Source\SharpNav\MathHelper.cs,NextPowerOfTwo,The following statement contains a magic number: v |= v >> 4;
Magic Number,SharpNav,MathHelper,C:\repos\Robmaister_SharpNav\Source\SharpNav\MathHelper.cs,NextPowerOfTwo,The following statement contains a magic number: v |= v >> 8;
Magic Number,SharpNav,MathHelper,C:\repos\Robmaister_SharpNav\Source\SharpNav\MathHelper.cs,NextPowerOfTwo,The following statement contains a magic number: v |= v >> 16;
Magic Number,SharpNav,MathHelper,C:\repos\Robmaister_SharpNav\Source\SharpNav\MathHelper.cs,NextPowerOfTwo,The following statement contains a magic number: v |= v >> 2;
Magic Number,SharpNav,MathHelper,C:\repos\Robmaister_SharpNav\Source\SharpNav\MathHelper.cs,NextPowerOfTwo,The following statement contains a magic number: v |= v >> 4;
Magic Number,SharpNav,MathHelper,C:\repos\Robmaister_SharpNav\Source\SharpNav\MathHelper.cs,NextPowerOfTwo,The following statement contains a magic number: v |= v >> 8;
Magic Number,SharpNav,MathHelper,C:\repos\Robmaister_SharpNav\Source\SharpNav\MathHelper.cs,NextPowerOfTwo,The following statement contains a magic number: v |= v >> 16;
Magic Number,SharpNav,MathHelper,C:\repos\Robmaister_SharpNav\Source\SharpNav\MathHelper.cs,Log2,The following statement contains a magic number: r = (v > 0xffff) ? 1 << 4 : 0 << 4;
Magic Number,SharpNav,MathHelper,C:\repos\Robmaister_SharpNav\Source\SharpNav\MathHelper.cs,Log2,The following statement contains a magic number: r = (v > 0xffff) ? 1 << 4 : 0 << 4;
Magic Number,SharpNav,MathHelper,C:\repos\Robmaister_SharpNav\Source\SharpNav\MathHelper.cs,Log2,The following statement contains a magic number: shift = (v > 0xff) ? 1 << 3 : 0 << 3;
Magic Number,SharpNav,MathHelper,C:\repos\Robmaister_SharpNav\Source\SharpNav\MathHelper.cs,Log2,The following statement contains a magic number: shift = (v > 0xff) ? 1 << 3 : 0 << 3;
Magic Number,SharpNav,MathHelper,C:\repos\Robmaister_SharpNav\Source\SharpNav\MathHelper.cs,Log2,The following statement contains a magic number: shift = (v > 0xf) ? 1 << 2 : 0 << 2;
Magic Number,SharpNav,MathHelper,C:\repos\Robmaister_SharpNav\Source\SharpNav\MathHelper.cs,Log2,The following statement contains a magic number: shift = (v > 0xf) ? 1 << 2 : 0 << 2;
Magic Number,SharpNav,MathHelper,C:\repos\Robmaister_SharpNav\Source\SharpNav\MathHelper.cs,Log2,The following statement contains a magic number: r = (uint)((v > 0xffff) ? 1 << 4 : 0 << 4);
Magic Number,SharpNav,MathHelper,C:\repos\Robmaister_SharpNav\Source\SharpNav\MathHelper.cs,Log2,The following statement contains a magic number: r = (uint)((v > 0xffff) ? 1 << 4 : 0 << 4);
Magic Number,SharpNav,MathHelper,C:\repos\Robmaister_SharpNav\Source\SharpNav\MathHelper.cs,Log2,The following statement contains a magic number: shift = (v > 0xff) ? 1 << 3 : 0 << 3;
Magic Number,SharpNav,MathHelper,C:\repos\Robmaister_SharpNav\Source\SharpNav\MathHelper.cs,Log2,The following statement contains a magic number: shift = (v > 0xff) ? 1 << 3 : 0 << 3;
Magic Number,SharpNav,MathHelper,C:\repos\Robmaister_SharpNav\Source\SharpNav\MathHelper.cs,Log2,The following statement contains a magic number: shift = (v > 0xf) ? 1 << 2 : 0 << 2;
Magic Number,SharpNav,MathHelper,C:\repos\Robmaister_SharpNav\Source\SharpNav\MathHelper.cs,Log2,The following statement contains a magic number: shift = (v > 0xf) ? 1 << 2 : 0 << 2;
Magic Number,SharpNav,MathHelper,C:\repos\Robmaister_SharpNav\Source\SharpNav\MathHelper.cs,ClipPolygonToPlane,The following statement contains a magic number: float[] distances = new float[12];
Magic Number,SharpNav,CompactHeightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\CompactHeightfield.cs,Erode,The following statement contains a magic number: radius *= 2;
Magic Number,SharpNav,CompactHeightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\CompactHeightfield.cs,BuildRegions,The following statement contains a magic number: const int LogStackCount = 3;
Magic Number,SharpNav,CompactHeightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\CompactHeightfield.cs,BuildRegions,The following statement contains a magic number: for (int i = 0; i < stacks.Length; i++)  				stacks[i] = new List<CompactSpanReference>(1024);
Magic Number,SharpNav,CompactHeightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\CompactHeightfield.cs,BuildRegions,The following statement contains a magic number: int level = ((maxDistance + 1) / 2) * 2;
Magic Number,SharpNav,CompactHeightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\CompactHeightfield.cs,BuildRegions,The following statement contains a magic number: int level = ((maxDistance + 1) / 2) * 2;
Magic Number,SharpNav,CompactHeightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\CompactHeightfield.cs,BuildRegions,The following statement contains a magic number: const int ExpandIters = 8;
Magic Number,SharpNav,CompactHeightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\CompactHeightfield.cs,BuildRegions,The following statement contains a magic number: while (level > 0)  			{  				level = level >= 2 ? level - 2 : 0;  				stackId = (stackId + 1) & (StackCount - 1);    				if (stackId == 0)  					SortCellsByLevel(regions' stacks' level' StackCount' 1);  				else  					AppendStacks(stacks[stackId - 1]' stacks[stackId]' regions);    				//expand current regions until no new empty connected cells found  				ExpandRegions(regions' floodDistances' ExpandIters' level' stacks[stackId]' regionBuffer' distanceBuffer);    				//mark new regions with ids  				for (int j = 0; j < stacks[stackId].Count; j++)  				{  					var spanRef = stacks[stackId][j];  					if (spanRef.Index >= 0 && regions[spanRef.Index] == 0)  						if (FloodRegion(regions' floodDistances' regionIndex' level' ref spanRef))  							regionIndex++;  				}  			}
Magic Number,SharpNav,CompactHeightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\CompactHeightfield.cs,BuildRegions,The following statement contains a magic number: while (level > 0)  			{  				level = level >= 2 ? level - 2 : 0;  				stackId = (stackId + 1) & (StackCount - 1);    				if (stackId == 0)  					SortCellsByLevel(regions' stacks' level' StackCount' 1);  				else  					AppendStacks(stacks[stackId - 1]' stacks[stackId]' regions);    				//expand current regions until no new empty connected cells found  				ExpandRegions(regions' floodDistances' ExpandIters' level' stacks[stackId]' regionBuffer' distanceBuffer);    				//mark new regions with ids  				for (int j = 0; j < stacks[stackId].Count; j++)  				{  					var spanRef = stacks[stackId][j];  					if (spanRef.Index >= 0 && regions[spanRef.Index] == 0)  						if (FloodRegion(regions' floodDistances' regionIndex' level' ref spanRef))  							regionIndex++;  				}  			}
Magic Number,SharpNav,CompactHeightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\CompactHeightfield.cs,BuildRegions,The following statement contains a magic number: ExpandRegions(regions' floodDistances' ExpandIters * 8' 0' null' regionBuffer' distanceBuffer);
Magic Number,SharpNav,CompactHeightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\CompactHeightfield.cs,CalculateDistanceField,The following statement contains a magic number: for (int y = 0; y < length; y++)  			{  				for (int x = 0; x < width; x++)  				{  					CompactCell c = cells[y * width + x];  					for (int i = c.StartIndex' end = c.StartIndex + c.Count; i < end; i++)  					{  						CompactSpan s = spans[i];  						Area area = areas[i];    						bool isBoundary = false;  						if (s.ConnectionCount != 4)  							isBoundary = true;  						else  						{  							for (var dir = Direction.West; dir <= Direction.South; dir++)  							{  								int dx = x + dir.GetHorizontalOffset();  								int dy = y + dir.GetVerticalOffset();  								int di = cells[dx + dy * width].StartIndex + CompactSpan.GetConnection(ref s' dir);  								if (area != areas[di])  								{  									isBoundary = true;  									break;  								}  							}  						}    						if (isBoundary)  							src[i] = 0;  					}  				}  			}
Magic Number,SharpNav,CompactHeightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\CompactHeightfield.cs,CalculateDistanceField,The following statement contains a magic number: for (int y = 0; y < length; y++)  			{  				for (int x = 0; x < width; x++)  				{  					CompactCell c = cells[y * width + x];  					for (int i = c.StartIndex' end = c.StartIndex + c.Count; i < end; i++)  					{  						CompactSpan s = spans[i];    						if (s.IsConnected(Direction.West))  						{  							//(-1' 0)  							int dx = x + Direction.West.GetHorizontalOffset();  							int dy = y + Direction.West.GetVerticalOffset();  							int di = cells[dx + dy * width].StartIndex + CompactSpan.GetConnection(ref s' Direction.West);  							CompactSpan ds = spans[di];  							if (src[di] + 2 < src[i])  								src[i] = src[di] + 2;    							//(-1' -1)  							if (ds.IsConnected(Direction.South))  							{  								int ddx = dx + Direction.South.GetHorizontalOffset();  								int ddy = dy + Direction.South.GetVerticalOffset();  								int ddi = cells[ddx + ddy * width].StartIndex + CompactSpan.GetConnection(ref ds' Direction.South);  								if (src[ddi] + 3 < src[i])  									src[i] = src[ddi] + 3;  							}  						}    						if (s.IsConnected(Direction.South))  						{  							//(0' -1)  							int dx = x + Direction.South.GetHorizontalOffset();  							int dy = y + Direction.South.GetVerticalOffset();  							int di = cells[dx + dy * width].StartIndex + CompactSpan.GetConnection(ref s' Direction.South);  							CompactSpan ds = spans[di];  							if (src[di] + 2 < src[i])  								src[i] = src[di] + 2;    							//(1' -1)  							if (ds.IsConnected(Direction.East))  							{  								int ddx = dx + Direction.East.GetHorizontalOffset();  								int ddy = dy + Direction.East.GetVerticalOffset();  								int ddi = cells[ddx + ddy * width].StartIndex + CompactSpan.GetConnection(ref ds' Direction.East);  								if (src[ddi] + 3 < src[i])  									src[i] = src[ddi] + 3;  							}  						}  					}  				}  			}
Magic Number,SharpNav,CompactHeightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\CompactHeightfield.cs,CalculateDistanceField,The following statement contains a magic number: for (int y = 0; y < length; y++)  			{  				for (int x = 0; x < width; x++)  				{  					CompactCell c = cells[y * width + x];  					for (int i = c.StartIndex' end = c.StartIndex + c.Count; i < end; i++)  					{  						CompactSpan s = spans[i];    						if (s.IsConnected(Direction.West))  						{  							//(-1' 0)  							int dx = x + Direction.West.GetHorizontalOffset();  							int dy = y + Direction.West.GetVerticalOffset();  							int di = cells[dx + dy * width].StartIndex + CompactSpan.GetConnection(ref s' Direction.West);  							CompactSpan ds = spans[di];  							if (src[di] + 2 < src[i])  								src[i] = src[di] + 2;    							//(-1' -1)  							if (ds.IsConnected(Direction.South))  							{  								int ddx = dx + Direction.South.GetHorizontalOffset();  								int ddy = dy + Direction.South.GetVerticalOffset();  								int ddi = cells[ddx + ddy * width].StartIndex + CompactSpan.GetConnection(ref ds' Direction.South);  								if (src[ddi] + 3 < src[i])  									src[i] = src[ddi] + 3;  							}  						}    						if (s.IsConnected(Direction.South))  						{  							//(0' -1)  							int dx = x + Direction.South.GetHorizontalOffset();  							int dy = y + Direction.South.GetVerticalOffset();  							int di = cells[dx + dy * width].StartIndex + CompactSpan.GetConnection(ref s' Direction.South);  							CompactSpan ds = spans[di];  							if (src[di] + 2 < src[i])  								src[i] = src[di] + 2;    							//(1' -1)  							if (ds.IsConnected(Direction.East))  							{  								int ddx = dx + Direction.East.GetHorizontalOffset();  								int ddy = dy + Direction.East.GetVerticalOffset();  								int ddi = cells[ddx + ddy * width].StartIndex + CompactSpan.GetConnection(ref ds' Direction.East);  								if (src[ddi] + 3 < src[i])  									src[i] = src[ddi] + 3;  							}  						}  					}  				}  			}
Magic Number,SharpNav,CompactHeightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\CompactHeightfield.cs,CalculateDistanceField,The following statement contains a magic number: for (int y = 0; y < length; y++)  			{  				for (int x = 0; x < width; x++)  				{  					CompactCell c = cells[y * width + x];  					for (int i = c.StartIndex' end = c.StartIndex + c.Count; i < end; i++)  					{  						CompactSpan s = spans[i];    						if (s.IsConnected(Direction.West))  						{  							//(-1' 0)  							int dx = x + Direction.West.GetHorizontalOffset();  							int dy = y + Direction.West.GetVerticalOffset();  							int di = cells[dx + dy * width].StartIndex + CompactSpan.GetConnection(ref s' Direction.West);  							CompactSpan ds = spans[di];  							if (src[di] + 2 < src[i])  								src[i] = src[di] + 2;    							//(-1' -1)  							if (ds.IsConnected(Direction.South))  							{  								int ddx = dx + Direction.South.GetHorizontalOffset();  								int ddy = dy + Direction.South.GetVerticalOffset();  								int ddi = cells[ddx + ddy * width].StartIndex + CompactSpan.GetConnection(ref ds' Direction.South);  								if (src[ddi] + 3 < src[i])  									src[i] = src[ddi] + 3;  							}  						}    						if (s.IsConnected(Direction.South))  						{  							//(0' -1)  							int dx = x + Direction.South.GetHorizontalOffset();  							int dy = y + Direction.South.GetVerticalOffset();  							int di = cells[dx + dy * width].StartIndex + CompactSpan.GetConnection(ref s' Direction.South);  							CompactSpan ds = spans[di];  							if (src[di] + 2 < src[i])  								src[i] = src[di] + 2;    							//(1' -1)  							if (ds.IsConnected(Direction.East))  							{  								int ddx = dx + Direction.East.GetHorizontalOffset();  								int ddy = dy + Direction.East.GetVerticalOffset();  								int ddi = cells[ddx + ddy * width].StartIndex + CompactSpan.GetConnection(ref ds' Direction.East);  								if (src[ddi] + 3 < src[i])  									src[i] = src[ddi] + 3;  							}  						}  					}  				}  			}
Magic Number,SharpNav,CompactHeightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\CompactHeightfield.cs,CalculateDistanceField,The following statement contains a magic number: for (int y = 0; y < length; y++)  			{  				for (int x = 0; x < width; x++)  				{  					CompactCell c = cells[y * width + x];  					for (int i = c.StartIndex' end = c.StartIndex + c.Count; i < end; i++)  					{  						CompactSpan s = spans[i];    						if (s.IsConnected(Direction.West))  						{  							//(-1' 0)  							int dx = x + Direction.West.GetHorizontalOffset();  							int dy = y + Direction.West.GetVerticalOffset();  							int di = cells[dx + dy * width].StartIndex + CompactSpan.GetConnection(ref s' Direction.West);  							CompactSpan ds = spans[di];  							if (src[di] + 2 < src[i])  								src[i] = src[di] + 2;    							//(-1' -1)  							if (ds.IsConnected(Direction.South))  							{  								int ddx = dx + Direction.South.GetHorizontalOffset();  								int ddy = dy + Direction.South.GetVerticalOffset();  								int ddi = cells[ddx + ddy * width].StartIndex + CompactSpan.GetConnection(ref ds' Direction.South);  								if (src[ddi] + 3 < src[i])  									src[i] = src[ddi] + 3;  							}  						}    						if (s.IsConnected(Direction.South))  						{  							//(0' -1)  							int dx = x + Direction.South.GetHorizontalOffset();  							int dy = y + Direction.South.GetVerticalOffset();  							int di = cells[dx + dy * width].StartIndex + CompactSpan.GetConnection(ref s' Direction.South);  							CompactSpan ds = spans[di];  							if (src[di] + 2 < src[i])  								src[i] = src[di] + 2;    							//(1' -1)  							if (ds.IsConnected(Direction.East))  							{  								int ddx = dx + Direction.East.GetHorizontalOffset();  								int ddy = dy + Direction.East.GetVerticalOffset();  								int ddi = cells[ddx + ddy * width].StartIndex + CompactSpan.GetConnection(ref ds' Direction.East);  								if (src[ddi] + 3 < src[i])  									src[i] = src[ddi] + 3;  							}  						}  					}  				}  			}
Magic Number,SharpNav,CompactHeightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\CompactHeightfield.cs,CalculateDistanceField,The following statement contains a magic number: for (int y = 0; y < length; y++)  			{  				for (int x = 0; x < width; x++)  				{  					CompactCell c = cells[y * width + x];  					for (int i = c.StartIndex' end = c.StartIndex + c.Count; i < end; i++)  					{  						CompactSpan s = spans[i];    						if (s.IsConnected(Direction.West))  						{  							//(-1' 0)  							int dx = x + Direction.West.GetHorizontalOffset();  							int dy = y + Direction.West.GetVerticalOffset();  							int di = cells[dx + dy * width].StartIndex + CompactSpan.GetConnection(ref s' Direction.West);  							CompactSpan ds = spans[di];  							if (src[di] + 2 < src[i])  								src[i] = src[di] + 2;    							//(-1' -1)  							if (ds.IsConnected(Direction.South))  							{  								int ddx = dx + Direction.South.GetHorizontalOffset();  								int ddy = dy + Direction.South.GetVerticalOffset();  								int ddi = cells[ddx + ddy * width].StartIndex + CompactSpan.GetConnection(ref ds' Direction.South);  								if (src[ddi] + 3 < src[i])  									src[i] = src[ddi] + 3;  							}  						}    						if (s.IsConnected(Direction.South))  						{  							//(0' -1)  							int dx = x + Direction.South.GetHorizontalOffset();  							int dy = y + Direction.South.GetVerticalOffset();  							int di = cells[dx + dy * width].StartIndex + CompactSpan.GetConnection(ref s' Direction.South);  							CompactSpan ds = spans[di];  							if (src[di] + 2 < src[i])  								src[i] = src[di] + 2;    							//(1' -1)  							if (ds.IsConnected(Direction.East))  							{  								int ddx = dx + Direction.East.GetHorizontalOffset();  								int ddy = dy + Direction.East.GetVerticalOffset();  								int ddi = cells[ddx + ddy * width].StartIndex + CompactSpan.GetConnection(ref ds' Direction.East);  								if (src[ddi] + 3 < src[i])  									src[i] = src[ddi] + 3;  							}  						}  					}  				}  			}
Magic Number,SharpNav,CompactHeightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\CompactHeightfield.cs,CalculateDistanceField,The following statement contains a magic number: for (int y = 0; y < length; y++)  			{  				for (int x = 0; x < width; x++)  				{  					CompactCell c = cells[y * width + x];  					for (int i = c.StartIndex' end = c.StartIndex + c.Count; i < end; i++)  					{  						CompactSpan s = spans[i];    						if (s.IsConnected(Direction.West))  						{  							//(-1' 0)  							int dx = x + Direction.West.GetHorizontalOffset();  							int dy = y + Direction.West.GetVerticalOffset();  							int di = cells[dx + dy * width].StartIndex + CompactSpan.GetConnection(ref s' Direction.West);  							CompactSpan ds = spans[di];  							if (src[di] + 2 < src[i])  								src[i] = src[di] + 2;    							//(-1' -1)  							if (ds.IsConnected(Direction.South))  							{  								int ddx = dx + Direction.South.GetHorizontalOffset();  								int ddy = dy + Direction.South.GetVerticalOffset();  								int ddi = cells[ddx + ddy * width].StartIndex + CompactSpan.GetConnection(ref ds' Direction.South);  								if (src[ddi] + 3 < src[i])  									src[i] = src[ddi] + 3;  							}  						}    						if (s.IsConnected(Direction.South))  						{  							//(0' -1)  							int dx = x + Direction.South.GetHorizontalOffset();  							int dy = y + Direction.South.GetVerticalOffset();  							int di = cells[dx + dy * width].StartIndex + CompactSpan.GetConnection(ref s' Direction.South);  							CompactSpan ds = spans[di];  							if (src[di] + 2 < src[i])  								src[i] = src[di] + 2;    							//(1' -1)  							if (ds.IsConnected(Direction.East))  							{  								int ddx = dx + Direction.East.GetHorizontalOffset();  								int ddy = dy + Direction.East.GetVerticalOffset();  								int ddi = cells[ddx + ddy * width].StartIndex + CompactSpan.GetConnection(ref ds' Direction.East);  								if (src[ddi] + 3 < src[i])  									src[i] = src[ddi] + 3;  							}  						}  					}  				}  			}
Magic Number,SharpNav,CompactHeightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\CompactHeightfield.cs,CalculateDistanceField,The following statement contains a magic number: for (int y = 0; y < length; y++)  			{  				for (int x = 0; x < width; x++)  				{  					CompactCell c = cells[y * width + x];  					for (int i = c.StartIndex' end = c.StartIndex + c.Count; i < end; i++)  					{  						CompactSpan s = spans[i];    						if (s.IsConnected(Direction.West))  						{  							//(-1' 0)  							int dx = x + Direction.West.GetHorizontalOffset();  							int dy = y + Direction.West.GetVerticalOffset();  							int di = cells[dx + dy * width].StartIndex + CompactSpan.GetConnection(ref s' Direction.West);  							CompactSpan ds = spans[di];  							if (src[di] + 2 < src[i])  								src[i] = src[di] + 2;    							//(-1' -1)  							if (ds.IsConnected(Direction.South))  							{  								int ddx = dx + Direction.South.GetHorizontalOffset();  								int ddy = dy + Direction.South.GetVerticalOffset();  								int ddi = cells[ddx + ddy * width].StartIndex + CompactSpan.GetConnection(ref ds' Direction.South);  								if (src[ddi] + 3 < src[i])  									src[i] = src[ddi] + 3;  							}  						}    						if (s.IsConnected(Direction.South))  						{  							//(0' -1)  							int dx = x + Direction.South.GetHorizontalOffset();  							int dy = y + Direction.South.GetVerticalOffset();  							int di = cells[dx + dy * width].StartIndex + CompactSpan.GetConnection(ref s' Direction.South);  							CompactSpan ds = spans[di];  							if (src[di] + 2 < src[i])  								src[i] = src[di] + 2;    							//(1' -1)  							if (ds.IsConnected(Direction.East))  							{  								int ddx = dx + Direction.East.GetHorizontalOffset();  								int ddy = dy + Direction.East.GetVerticalOffset();  								int ddi = cells[ddx + ddy * width].StartIndex + CompactSpan.GetConnection(ref ds' Direction.East);  								if (src[ddi] + 3 < src[i])  									src[i] = src[ddi] + 3;  							}  						}  					}  				}  			}
Magic Number,SharpNav,CompactHeightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\CompactHeightfield.cs,CalculateDistanceField,The following statement contains a magic number: for (int y = 0; y < length; y++)  			{  				for (int x = 0; x < width; x++)  				{  					CompactCell c = cells[y * width + x];  					for (int i = c.StartIndex' end = c.StartIndex + c.Count; i < end; i++)  					{  						CompactSpan s = spans[i];    						if (s.IsConnected(Direction.West))  						{  							//(-1' 0)  							int dx = x + Direction.West.GetHorizontalOffset();  							int dy = y + Direction.West.GetVerticalOffset();  							int di = cells[dx + dy * width].StartIndex + CompactSpan.GetConnection(ref s' Direction.West);  							CompactSpan ds = spans[di];  							if (src[di] + 2 < src[i])  								src[i] = src[di] + 2;    							//(-1' -1)  							if (ds.IsConnected(Direction.South))  							{  								int ddx = dx + Direction.South.GetHorizontalOffset();  								int ddy = dy + Direction.South.GetVerticalOffset();  								int ddi = cells[ddx + ddy * width].StartIndex + CompactSpan.GetConnection(ref ds' Direction.South);  								if (src[ddi] + 3 < src[i])  									src[i] = src[ddi] + 3;  							}  						}    						if (s.IsConnected(Direction.South))  						{  							//(0' -1)  							int dx = x + Direction.South.GetHorizontalOffset();  							int dy = y + Direction.South.GetVerticalOffset();  							int di = cells[dx + dy * width].StartIndex + CompactSpan.GetConnection(ref s' Direction.South);  							CompactSpan ds = spans[di];  							if (src[di] + 2 < src[i])  								src[i] = src[di] + 2;    							//(1' -1)  							if (ds.IsConnected(Direction.East))  							{  								int ddx = dx + Direction.East.GetHorizontalOffset();  								int ddy = dy + Direction.East.GetVerticalOffset();  								int ddi = cells[ddx + ddy * width].StartIndex + CompactSpan.GetConnection(ref ds' Direction.East);  								if (src[ddi] + 3 < src[i])  									src[i] = src[ddi] + 3;  							}  						}  					}  				}  			}
Magic Number,SharpNav,CompactHeightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\CompactHeightfield.cs,CalculateDistanceField,The following statement contains a magic number: for (int y = length - 1; y >= 0; y--)  			{  				for (int x = width - 1; x >= 0; x--)  				{  					CompactCell c = cells[y * width + x];  					for (int i = c.StartIndex' end = c.StartIndex + c.Count; i < end; i++)  					{  						CompactSpan s = spans[i];    						if (s.IsConnected(Direction.East))  						{  							//(1' 0)  							int dx = x + Direction.East.GetHorizontalOffset();  							int dy = y + Direction.East.GetVerticalOffset();  							int di = cells[dx + dy * width].StartIndex + CompactSpan.GetConnection(ref s' Direction.East);  							CompactSpan ds = spans[di];  							if (src[di] + 2 < src[i])  								src[i] = src[di] + 2;    							//(1' 1)  							if (ds.IsConnected(Direction.North))  							{  								int ddx = dx + Direction.North.GetHorizontalOffset();  								int ddy = dy + Direction.North.GetVerticalOffset();  								int ddi = cells[ddx + ddy * width].StartIndex + CompactSpan.GetConnection(ref ds' Direction.North);  								if (src[ddi] + 3 < src[i])  									src[i] = src[ddi] + 3;  							}  						}    						if (s.IsConnected(Direction.North))  						{  							//(0' 1)  							int dx = x + Direction.North.GetHorizontalOffset();  							int dy = y + Direction.North.GetVerticalOffset();  							int di = cells[dx + dy * width].StartIndex + CompactSpan.GetConnection(ref s' Direction.North);  							CompactSpan ds = spans[di];  							if (src[di] + 2 < src[i])  								src[i] = src[di] + 2;    							//(-1' 1)  							if (ds.IsConnected(Direction.West))  							{  								int ddx = dx + Direction.West.GetHorizontalOffset();  								int ddy = dy + Direction.West.GetVerticalOffset();  								int ddi = cells[ddx + ddy * width].StartIndex + CompactSpan.GetConnection(ref ds' Direction.West);  								if (src[ddi] + 3 < src[i])  									src[i] = src[ddi] + 3;  							}  						}  					}  				}  			}
Magic Number,SharpNav,CompactHeightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\CompactHeightfield.cs,CalculateDistanceField,The following statement contains a magic number: for (int y = length - 1; y >= 0; y--)  			{  				for (int x = width - 1; x >= 0; x--)  				{  					CompactCell c = cells[y * width + x];  					for (int i = c.StartIndex' end = c.StartIndex + c.Count; i < end; i++)  					{  						CompactSpan s = spans[i];    						if (s.IsConnected(Direction.East))  						{  							//(1' 0)  							int dx = x + Direction.East.GetHorizontalOffset();  							int dy = y + Direction.East.GetVerticalOffset();  							int di = cells[dx + dy * width].StartIndex + CompactSpan.GetConnection(ref s' Direction.East);  							CompactSpan ds = spans[di];  							if (src[di] + 2 < src[i])  								src[i] = src[di] + 2;    							//(1' 1)  							if (ds.IsConnected(Direction.North))  							{  								int ddx = dx + Direction.North.GetHorizontalOffset();  								int ddy = dy + Direction.North.GetVerticalOffset();  								int ddi = cells[ddx + ddy * width].StartIndex + CompactSpan.GetConnection(ref ds' Direction.North);  								if (src[ddi] + 3 < src[i])  									src[i] = src[ddi] + 3;  							}  						}    						if (s.IsConnected(Direction.North))  						{  							//(0' 1)  							int dx = x + Direction.North.GetHorizontalOffset();  							int dy = y + Direction.North.GetVerticalOffset();  							int di = cells[dx + dy * width].StartIndex + CompactSpan.GetConnection(ref s' Direction.North);  							CompactSpan ds = spans[di];  							if (src[di] + 2 < src[i])  								src[i] = src[di] + 2;    							//(-1' 1)  							if (ds.IsConnected(Direction.West))  							{  								int ddx = dx + Direction.West.GetHorizontalOffset();  								int ddy = dy + Direction.West.GetVerticalOffset();  								int ddi = cells[ddx + ddy * width].StartIndex + CompactSpan.GetConnection(ref ds' Direction.West);  								if (src[ddi] + 3 < src[i])  									src[i] = src[ddi] + 3;  							}  						}  					}  				}  			}
Magic Number,SharpNav,CompactHeightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\CompactHeightfield.cs,CalculateDistanceField,The following statement contains a magic number: for (int y = length - 1; y >= 0; y--)  			{  				for (int x = width - 1; x >= 0; x--)  				{  					CompactCell c = cells[y * width + x];  					for (int i = c.StartIndex' end = c.StartIndex + c.Count; i < end; i++)  					{  						CompactSpan s = spans[i];    						if (s.IsConnected(Direction.East))  						{  							//(1' 0)  							int dx = x + Direction.East.GetHorizontalOffset();  							int dy = y + Direction.East.GetVerticalOffset();  							int di = cells[dx + dy * width].StartIndex + CompactSpan.GetConnection(ref s' Direction.East);  							CompactSpan ds = spans[di];  							if (src[di] + 2 < src[i])  								src[i] = src[di] + 2;    							//(1' 1)  							if (ds.IsConnected(Direction.North))  							{  								int ddx = dx + Direction.North.GetHorizontalOffset();  								int ddy = dy + Direction.North.GetVerticalOffset();  								int ddi = cells[ddx + ddy * width].StartIndex + CompactSpan.GetConnection(ref ds' Direction.North);  								if (src[ddi] + 3 < src[i])  									src[i] = src[ddi] + 3;  							}  						}    						if (s.IsConnected(Direction.North))  						{  							//(0' 1)  							int dx = x + Direction.North.GetHorizontalOffset();  							int dy = y + Direction.North.GetVerticalOffset();  							int di = cells[dx + dy * width].StartIndex + CompactSpan.GetConnection(ref s' Direction.North);  							CompactSpan ds = spans[di];  							if (src[di] + 2 < src[i])  								src[i] = src[di] + 2;    							//(-1' 1)  							if (ds.IsConnected(Direction.West))  							{  								int ddx = dx + Direction.West.GetHorizontalOffset();  								int ddy = dy + Direction.West.GetVerticalOffset();  								int ddi = cells[ddx + ddy * width].StartIndex + CompactSpan.GetConnection(ref ds' Direction.West);  								if (src[ddi] + 3 < src[i])  									src[i] = src[ddi] + 3;  							}  						}  					}  				}  			}
Magic Number,SharpNav,CompactHeightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\CompactHeightfield.cs,CalculateDistanceField,The following statement contains a magic number: for (int y = length - 1; y >= 0; y--)  			{  				for (int x = width - 1; x >= 0; x--)  				{  					CompactCell c = cells[y * width + x];  					for (int i = c.StartIndex' end = c.StartIndex + c.Count; i < end; i++)  					{  						CompactSpan s = spans[i];    						if (s.IsConnected(Direction.East))  						{  							//(1' 0)  							int dx = x + Direction.East.GetHorizontalOffset();  							int dy = y + Direction.East.GetVerticalOffset();  							int di = cells[dx + dy * width].StartIndex + CompactSpan.GetConnection(ref s' Direction.East);  							CompactSpan ds = spans[di];  							if (src[di] + 2 < src[i])  								src[i] = src[di] + 2;    							//(1' 1)  							if (ds.IsConnected(Direction.North))  							{  								int ddx = dx + Direction.North.GetHorizontalOffset();  								int ddy = dy + Direction.North.GetVerticalOffset();  								int ddi = cells[ddx + ddy * width].StartIndex + CompactSpan.GetConnection(ref ds' Direction.North);  								if (src[ddi] + 3 < src[i])  									src[i] = src[ddi] + 3;  							}  						}    						if (s.IsConnected(Direction.North))  						{  							//(0' 1)  							int dx = x + Direction.North.GetHorizontalOffset();  							int dy = y + Direction.North.GetVerticalOffset();  							int di = cells[dx + dy * width].StartIndex + CompactSpan.GetConnection(ref s' Direction.North);  							CompactSpan ds = spans[di];  							if (src[di] + 2 < src[i])  								src[i] = src[di] + 2;    							//(-1' 1)  							if (ds.IsConnected(Direction.West))  							{  								int ddx = dx + Direction.West.GetHorizontalOffset();  								int ddy = dy + Direction.West.GetVerticalOffset();  								int ddi = cells[ddx + ddy * width].StartIndex + CompactSpan.GetConnection(ref ds' Direction.West);  								if (src[ddi] + 3 < src[i])  									src[i] = src[ddi] + 3;  							}  						}  					}  				}  			}
Magic Number,SharpNav,CompactHeightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\CompactHeightfield.cs,CalculateDistanceField,The following statement contains a magic number: for (int y = length - 1; y >= 0; y--)  			{  				for (int x = width - 1; x >= 0; x--)  				{  					CompactCell c = cells[y * width + x];  					for (int i = c.StartIndex' end = c.StartIndex + c.Count; i < end; i++)  					{  						CompactSpan s = spans[i];    						if (s.IsConnected(Direction.East))  						{  							//(1' 0)  							int dx = x + Direction.East.GetHorizontalOffset();  							int dy = y + Direction.East.GetVerticalOffset();  							int di = cells[dx + dy * width].StartIndex + CompactSpan.GetConnection(ref s' Direction.East);  							CompactSpan ds = spans[di];  							if (src[di] + 2 < src[i])  								src[i] = src[di] + 2;    							//(1' 1)  							if (ds.IsConnected(Direction.North))  							{  								int ddx = dx + Direction.North.GetHorizontalOffset();  								int ddy = dy + Direction.North.GetVerticalOffset();  								int ddi = cells[ddx + ddy * width].StartIndex + CompactSpan.GetConnection(ref ds' Direction.North);  								if (src[ddi] + 3 < src[i])  									src[i] = src[ddi] + 3;  							}  						}    						if (s.IsConnected(Direction.North))  						{  							//(0' 1)  							int dx = x + Direction.North.GetHorizontalOffset();  							int dy = y + Direction.North.GetVerticalOffset();  							int di = cells[dx + dy * width].StartIndex + CompactSpan.GetConnection(ref s' Direction.North);  							CompactSpan ds = spans[di];  							if (src[di] + 2 < src[i])  								src[i] = src[di] + 2;    							//(-1' 1)  							if (ds.IsConnected(Direction.West))  							{  								int ddx = dx + Direction.West.GetHorizontalOffset();  								int ddy = dy + Direction.West.GetVerticalOffset();  								int ddi = cells[ddx + ddy * width].StartIndex + CompactSpan.GetConnection(ref ds' Direction.West);  								if (src[ddi] + 3 < src[i])  									src[i] = src[ddi] + 3;  							}  						}  					}  				}  			}
Magic Number,SharpNav,CompactHeightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\CompactHeightfield.cs,CalculateDistanceField,The following statement contains a magic number: for (int y = length - 1; y >= 0; y--)  			{  				for (int x = width - 1; x >= 0; x--)  				{  					CompactCell c = cells[y * width + x];  					for (int i = c.StartIndex' end = c.StartIndex + c.Count; i < end; i++)  					{  						CompactSpan s = spans[i];    						if (s.IsConnected(Direction.East))  						{  							//(1' 0)  							int dx = x + Direction.East.GetHorizontalOffset();  							int dy = y + Direction.East.GetVerticalOffset();  							int di = cells[dx + dy * width].StartIndex + CompactSpan.GetConnection(ref s' Direction.East);  							CompactSpan ds = spans[di];  							if (src[di] + 2 < src[i])  								src[i] = src[di] + 2;    							//(1' 1)  							if (ds.IsConnected(Direction.North))  							{  								int ddx = dx + Direction.North.GetHorizontalOffset();  								int ddy = dy + Direction.North.GetVerticalOffset();  								int ddi = cells[ddx + ddy * width].StartIndex + CompactSpan.GetConnection(ref ds' Direction.North);  								if (src[ddi] + 3 < src[i])  									src[i] = src[ddi] + 3;  							}  						}    						if (s.IsConnected(Direction.North))  						{  							//(0' 1)  							int dx = x + Direction.North.GetHorizontalOffset();  							int dy = y + Direction.North.GetVerticalOffset();  							int di = cells[dx + dy * width].StartIndex + CompactSpan.GetConnection(ref s' Direction.North);  							CompactSpan ds = spans[di];  							if (src[di] + 2 < src[i])  								src[i] = src[di] + 2;    							//(-1' 1)  							if (ds.IsConnected(Direction.West))  							{  								int ddx = dx + Direction.West.GetHorizontalOffset();  								int ddy = dy + Direction.West.GetVerticalOffset();  								int ddi = cells[ddx + ddy * width].StartIndex + CompactSpan.GetConnection(ref ds' Direction.West);  								if (src[ddi] + 3 < src[i])  									src[i] = src[ddi] + 3;  							}  						}  					}  				}  			}
Magic Number,SharpNav,CompactHeightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\CompactHeightfield.cs,CalculateDistanceField,The following statement contains a magic number: for (int y = length - 1; y >= 0; y--)  			{  				for (int x = width - 1; x >= 0; x--)  				{  					CompactCell c = cells[y * width + x];  					for (int i = c.StartIndex' end = c.StartIndex + c.Count; i < end; i++)  					{  						CompactSpan s = spans[i];    						if (s.IsConnected(Direction.East))  						{  							//(1' 0)  							int dx = x + Direction.East.GetHorizontalOffset();  							int dy = y + Direction.East.GetVerticalOffset();  							int di = cells[dx + dy * width].StartIndex + CompactSpan.GetConnection(ref s' Direction.East);  							CompactSpan ds = spans[di];  							if (src[di] + 2 < src[i])  								src[i] = src[di] + 2;    							//(1' 1)  							if (ds.IsConnected(Direction.North))  							{  								int ddx = dx + Direction.North.GetHorizontalOffset();  								int ddy = dy + Direction.North.GetVerticalOffset();  								int ddi = cells[ddx + ddy * width].StartIndex + CompactSpan.GetConnection(ref ds' Direction.North);  								if (src[ddi] + 3 < src[i])  									src[i] = src[ddi] + 3;  							}  						}    						if (s.IsConnected(Direction.North))  						{  							//(0' 1)  							int dx = x + Direction.North.GetHorizontalOffset();  							int dy = y + Direction.North.GetVerticalOffset();  							int di = cells[dx + dy * width].StartIndex + CompactSpan.GetConnection(ref s' Direction.North);  							CompactSpan ds = spans[di];  							if (src[di] + 2 < src[i])  								src[i] = src[di] + 2;    							//(-1' 1)  							if (ds.IsConnected(Direction.West))  							{  								int ddx = dx + Direction.West.GetHorizontalOffset();  								int ddy = dy + Direction.West.GetVerticalOffset();  								int ddi = cells[ddx + ddy * width].StartIndex + CompactSpan.GetConnection(ref ds' Direction.West);  								if (src[ddi] + 3 < src[i])  									src[i] = src[ddi] + 3;  							}  						}  					}  				}  			}
Magic Number,SharpNav,CompactHeightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\CompactHeightfield.cs,CalculateDistanceField,The following statement contains a magic number: for (int y = length - 1; y >= 0; y--)  			{  				for (int x = width - 1; x >= 0; x--)  				{  					CompactCell c = cells[y * width + x];  					for (int i = c.StartIndex' end = c.StartIndex + c.Count; i < end; i++)  					{  						CompactSpan s = spans[i];    						if (s.IsConnected(Direction.East))  						{  							//(1' 0)  							int dx = x + Direction.East.GetHorizontalOffset();  							int dy = y + Direction.East.GetVerticalOffset();  							int di = cells[dx + dy * width].StartIndex + CompactSpan.GetConnection(ref s' Direction.East);  							CompactSpan ds = spans[di];  							if (src[di] + 2 < src[i])  								src[i] = src[di] + 2;    							//(1' 1)  							if (ds.IsConnected(Direction.North))  							{  								int ddx = dx + Direction.North.GetHorizontalOffset();  								int ddy = dy + Direction.North.GetVerticalOffset();  								int ddi = cells[ddx + ddy * width].StartIndex + CompactSpan.GetConnection(ref ds' Direction.North);  								if (src[ddi] + 3 < src[i])  									src[i] = src[ddi] + 3;  							}  						}    						if (s.IsConnected(Direction.North))  						{  							//(0' 1)  							int dx = x + Direction.North.GetHorizontalOffset();  							int dy = y + Direction.North.GetVerticalOffset();  							int di = cells[dx + dy * width].StartIndex + CompactSpan.GetConnection(ref s' Direction.North);  							CompactSpan ds = spans[di];  							if (src[di] + 2 < src[i])  								src[i] = src[di] + 2;    							//(-1' 1)  							if (ds.IsConnected(Direction.West))  							{  								int ddx = dx + Direction.West.GetHorizontalOffset();  								int ddy = dy + Direction.West.GetVerticalOffset();  								int ddi = cells[ddx + ddy * width].StartIndex + CompactSpan.GetConnection(ref ds' Direction.West);  								if (src[ddi] + 3 < src[i])  									src[i] = src[ddi] + 3;  							}  						}  					}  				}  			}
Magic Number,SharpNav,CompactHeightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\CompactHeightfield.cs,BoxBlur,The following statement contains a magic number: threshold *= 2;
Magic Number,SharpNav,CompactHeightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\CompactHeightfield.cs,BoxBlur,The following statement contains a magic number: for (int y = 0; y < length; y++)  			{  				for (int x = 0; x < width; x++)  				{  					CompactCell c = cells[y * width + x];  					for (int i = c.StartIndex' end = c.StartIndex + c.Count; i < end; i++)  					{  						CompactSpan s = spans[i];  						int cellDist = buffer[i];    						//if the distance is below the threshold' skip the span.  						if (cellDist <= threshold)  							continue;    						//iterate the full neighborhood of 8 spans.  						int d = cellDist;  						for (Direction dir = Direction.West; dir <= Direction.South; dir++)  						{  							if (s.IsConnected(dir))  							{  								int dx = x + dir.GetHorizontalOffset();  								int dy = y + dir.GetVerticalOffset();  								int di = cells[dy * width + dx].StartIndex + CompactSpan.GetConnection(ref s' dir);    								d += buffer[di];    								CompactSpan ds = spans[di];  								Direction dir2 = dir.NextClockwise();  								if (ds.IsConnected(dir2))  								{  									int dx2 = dx + dir2.GetHorizontalOffset();  									int dy2 = dy + dir2.GetVerticalOffset();  									int di2 = cells[dy2 * width + dx2].StartIndex + CompactSpan.GetConnection(ref ds' dir2);    									d += buffer[di2];  								}  								else  								{  									d += cellDist;  								}  							}  							else  							{  								//add the center span if there's no connection.  								d += cellDist * 2;  							}  						}    						//save new value to destination  						distances[i] = (d + 5) / 9;  					}  				}  			}
Magic Number,SharpNav,CompactHeightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\CompactHeightfield.cs,BoxBlur,The following statement contains a magic number: for (int y = 0; y < length; y++)  			{  				for (int x = 0; x < width; x++)  				{  					CompactCell c = cells[y * width + x];  					for (int i = c.StartIndex' end = c.StartIndex + c.Count; i < end; i++)  					{  						CompactSpan s = spans[i];  						int cellDist = buffer[i];    						//if the distance is below the threshold' skip the span.  						if (cellDist <= threshold)  							continue;    						//iterate the full neighborhood of 8 spans.  						int d = cellDist;  						for (Direction dir = Direction.West; dir <= Direction.South; dir++)  						{  							if (s.IsConnected(dir))  							{  								int dx = x + dir.GetHorizontalOffset();  								int dy = y + dir.GetVerticalOffset();  								int di = cells[dy * width + dx].StartIndex + CompactSpan.GetConnection(ref s' dir);    								d += buffer[di];    								CompactSpan ds = spans[di];  								Direction dir2 = dir.NextClockwise();  								if (ds.IsConnected(dir2))  								{  									int dx2 = dx + dir2.GetHorizontalOffset();  									int dy2 = dy + dir2.GetVerticalOffset();  									int di2 = cells[dy2 * width + dx2].StartIndex + CompactSpan.GetConnection(ref ds' dir2);    									d += buffer[di2];  								}  								else  								{  									d += cellDist;  								}  							}  							else  							{  								//add the center span if there's no connection.  								d += cellDist * 2;  							}  						}    						//save new value to destination  						distances[i] = (d + 5) / 9;  					}  				}  			}
Magic Number,SharpNav,CompactHeightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\CompactHeightfield.cs,BoxBlur,The following statement contains a magic number: for (int y = 0; y < length; y++)  			{  				for (int x = 0; x < width; x++)  				{  					CompactCell c = cells[y * width + x];  					for (int i = c.StartIndex' end = c.StartIndex + c.Count; i < end; i++)  					{  						CompactSpan s = spans[i];  						int cellDist = buffer[i];    						//if the distance is below the threshold' skip the span.  						if (cellDist <= threshold)  							continue;    						//iterate the full neighborhood of 8 spans.  						int d = cellDist;  						for (Direction dir = Direction.West; dir <= Direction.South; dir++)  						{  							if (s.IsConnected(dir))  							{  								int dx = x + dir.GetHorizontalOffset();  								int dy = y + dir.GetVerticalOffset();  								int di = cells[dy * width + dx].StartIndex + CompactSpan.GetConnection(ref s' dir);    								d += buffer[di];    								CompactSpan ds = spans[di];  								Direction dir2 = dir.NextClockwise();  								if (ds.IsConnected(dir2))  								{  									int dx2 = dx + dir2.GetHorizontalOffset();  									int dy2 = dy + dir2.GetVerticalOffset();  									int di2 = cells[dy2 * width + dx2].StartIndex + CompactSpan.GetConnection(ref ds' dir2);    									d += buffer[di2];  								}  								else  								{  									d += cellDist;  								}  							}  							else  							{  								//add the center span if there's no connection.  								d += cellDist * 2;  							}  						}    						//save new value to destination  						distances[i] = (d + 5) / 9;  					}  				}  			}
Magic Number,SharpNav,CompactHeightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\CompactHeightfield.cs,ExpandRegions,The following statement contains a magic number: while (stack.Count > 0)  			{  				//spans in the stack that are skipped:  				// - assigned a region ID in an earlier iteration  				// - not neighboring any spans with region IDs  				int skipped = 0;    				for (int j = 0; j < stack.Count; j++)  				{  					CompactSpanReference spanRef = stack[j];  					int x = spanRef.X;  					int y = spanRef.Y;  					int i = spanRef.Index;    					//skip regions already assigned to  					if (i < 0)  					{  						skipped++;  						continue;  					}    					RegionId r = regions[i];  					Area area = areas[i];  					CompactSpan s = spans[i];    					//search direct neighbors for the one with the smallest distance value  					int minDist = int.MaxValue;  					for (var dir = Direction.West; dir <= Direction.South; dir++)  					{  						if (!s.IsConnected(dir))  							continue;    						int dx = x + dir.GetHorizontalOffset();  						int dy = y + dir.GetVerticalOffset();  						int di = cells[dx + dy * width].StartIndex + CompactSpan.GetConnection(ref s' dir);    						if (areas[di] != area)  							continue;    						//compare distance to previous best  						RegionId ri = regions[di];  						int dist = floodDistances[di];  						if (!(ri.IsNull || RegionId.HasFlags(ri' RegionFlags.Border)))  						{  							//set region and distance if better  							if (dist + 2 < minDist)  							{  								r = ri;  								minDist = dist + 2;  							}  						}  					}    					if (r != 0)  					{  						//set the region and distance for this span  						regionBuffer[i] = r;  						distanceBuffer[i] = minDist;    						//mark this item in the stack as assigned for the next iteration.  						stack[j] = CompactSpanReference.Null;  					}  					else  					{  						//skip spans that don't neighbor any regions  						skipped++;  					}  				}    				//if the entire stack is being skipped' we're done.  				if (skipped == stack.Count)  					break;    				//Copy from the buffers back to the original arrays. This is done after each iteration  				//because changing it in-place has some side effects for the other spans in the stack.  				Array.Copy(regionBuffer' 0' regions' 0' regions.Length);  				Array.Copy(distanceBuffer' 0' floodDistances' 0' floodDistances.Length);    				if (level > 0)  				{  					//if we hit maxIterations before expansion is done' break out anyways.  					++iter;  					if (iter >= maxIterations)  						break;  				}  			}
Magic Number,SharpNav,CompactHeightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\CompactHeightfield.cs,ExpandRegions,The following statement contains a magic number: while (stack.Count > 0)  			{  				//spans in the stack that are skipped:  				// - assigned a region ID in an earlier iteration  				// - not neighboring any spans with region IDs  				int skipped = 0;    				for (int j = 0; j < stack.Count; j++)  				{  					CompactSpanReference spanRef = stack[j];  					int x = spanRef.X;  					int y = spanRef.Y;  					int i = spanRef.Index;    					//skip regions already assigned to  					if (i < 0)  					{  						skipped++;  						continue;  					}    					RegionId r = regions[i];  					Area area = areas[i];  					CompactSpan s = spans[i];    					//search direct neighbors for the one with the smallest distance value  					int minDist = int.MaxValue;  					for (var dir = Direction.West; dir <= Direction.South; dir++)  					{  						if (!s.IsConnected(dir))  							continue;    						int dx = x + dir.GetHorizontalOffset();  						int dy = y + dir.GetVerticalOffset();  						int di = cells[dx + dy * width].StartIndex + CompactSpan.GetConnection(ref s' dir);    						if (areas[di] != area)  							continue;    						//compare distance to previous best  						RegionId ri = regions[di];  						int dist = floodDistances[di];  						if (!(ri.IsNull || RegionId.HasFlags(ri' RegionFlags.Border)))  						{  							//set region and distance if better  							if (dist + 2 < minDist)  							{  								r = ri;  								minDist = dist + 2;  							}  						}  					}    					if (r != 0)  					{  						//set the region and distance for this span  						regionBuffer[i] = r;  						distanceBuffer[i] = minDist;    						//mark this item in the stack as assigned for the next iteration.  						stack[j] = CompactSpanReference.Null;  					}  					else  					{  						//skip spans that don't neighbor any regions  						skipped++;  					}  				}    				//if the entire stack is being skipped' we're done.  				if (skipped == stack.Count)  					break;    				//Copy from the buffers back to the original arrays. This is done after each iteration  				//because changing it in-place has some side effects for the other spans in the stack.  				Array.Copy(regionBuffer' 0' regions' 0' regions.Length);  				Array.Copy(distanceBuffer' 0' floodDistances' 0' floodDistances.Length);    				if (level > 0)  				{  					//if we hit maxIterations before expansion is done' break out anyways.  					++iter;  					if (iter >= maxIterations)  						break;  				}  			}
Magic Number,SharpNav,CompactHeightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\CompactHeightfield.cs,FloodRegion,The following statement contains a magic number: int lev = level >= 2 ? level - 2 : 0;
Magic Number,SharpNav,CompactHeightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\CompactHeightfield.cs,FloodRegion,The following statement contains a magic number: int lev = level >= 2 ? level - 2 : 0;
Magic Number,SharpNav,CompactHeightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\CompactHeightfield.cs,WalkContour,The following statement contains a magic number: while (++iter < 40000)  			{  				CompactSpan s = spans[spanRef.Index];    				if (IsSolidEdge(regions' ref spanRef' dir))  				{  					//choose the edge corner  					RegionId r = RegionId.Null;  					if (s.IsConnected(dir))  					{  						int dx = spanRef.X + dir.GetHorizontalOffset();  						int dy = spanRef.Y + dir.GetVerticalOffset();  						int di = cells[dx + dy * width].StartIndex + CompactSpan.GetConnection(ref s' dir);  						r = regions[di];  					}    					if (r != curReg)  					{  						curReg = r;  						cont.Add(curReg);  					}    					dir = dir.NextClockwise(); //rotate clockwise  				}  				else  				{  					int di = -1;  					int dx = spanRef.X + dir.GetHorizontalOffset();  					int dy = spanRef.Y + dir.GetVerticalOffset();    					if (s.IsConnected(dir))  					{  						CompactCell dc = cells[dx + dy * width];  						di = dc.StartIndex + CompactSpan.GetConnection(ref s' dir);  					}    					if (di == -1)  					{  						//shouldn't happen  						return;  					}    					spanRef = new CompactSpanReference(dx' dy' di);  					dir = dir.NextCounterClockwise(); //rotate counterclockwise  				}    				if (starti == spanRef.Index && startDir == dir)  					break;  			}
Magic Number,SharpNav,CompactHeightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\CompactHeightfield.cs,BuildContourSet,The following statement contains a magic number: int contourSetWidth = width - borderSize * 2;
Magic Number,SharpNav,CompactHeightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\CompactHeightfield.cs,BuildContourSet,The following statement contains a magic number: int contourSetLength = length - borderSize * 2;
Magic Number,SharpNav,CompactHeightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\CompactHeightfield.cs,BuildContourSet,The following statement contains a magic number: int maxContours = Math.Max(maxRegions' 8);
Magic Number,SharpNav,CompactHeightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\CompactHeightfield.cs,WalkContour,The following statement contains a magic number: while (++iter < 40000)  			{  				// this direction is connected  				if (EdgeFlagsHelper.IsConnected(ref flags[spanReference.Index]' dir))  				{  					// choose the edge corner  					bool isBorderVertex;  					bool isAreaBorder = false;    					int px = spanReference.X;  					int py = GetCornerHeight(spanReference' dir' out isBorderVertex);  					int pz = spanReference.Y;    					switch (dir)  					{  						case Direction.West:  							pz++;  							break;  						case Direction.North:  							px++;  							pz++;  							break;  						case Direction.East:  							px++;  							break;  					}    					RegionId r = RegionId.Null;  					CompactSpan s = this[spanReference];  					if (s.IsConnected(dir))  					{  						int dx = spanReference.X + dir.GetHorizontalOffset();  						int dy = spanReference.Y + dir.GetVerticalOffset();  						int di = cells[dx + dy * width].StartIndex + CompactSpan.GetConnection(ref s' dir);  						r = spans[di].Region;  						if (area != areas[di])  							isAreaBorder = true;  					}    					// apply flags if neccessary  					if (isBorderVertex)  						r = RegionId.WithFlags(r' RegionFlags.VertexBorder);    					if (isAreaBorder)  						r = RegionId.WithFlags(r' RegionFlags.AreaBorder);    					//save the point  					points.Add(new ContourVertex(px' py' pz' r));    					EdgeFlagsHelper.RemoveEdge(ref flags[spanReference.Index]' dir);	// remove visited edges  					dir = dir.NextClockwise();			// rotate clockwise  				}  				else  				{  					//get a new cell(x' y) and span index(i)  					int di = -1;  					int dx = spanReference.X + dir.GetHorizontalOffset();  					int dy = spanReference.Y + dir.GetVerticalOffset();    					CompactSpan s = this[spanReference];  					if (s.IsConnected(dir))  					{  						CompactCell dc = cells[dx + dy * width];  						di = dc.StartIndex + CompactSpan.GetConnection(ref s' dir);  					}    					if (di == -1)  					{  						// shouldn't happen  						// TODO if this shouldn't happen' this check shouldn't be necessary.  						throw new InvalidOperationException("Something went wrong");  					}    					spanReference = new CompactSpanReference(dx' dy' di);  					dir = dir.NextCounterClockwise(); // rotate counterclockwise  				}    				if (startIndex == spanReference.Index && startDir == dir)  					break;  			}
Magic Number,SharpNav,CompactHeightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\CompactHeightfield.cs,GetCornerHeight,The following statement contains a magic number: RegionId[] cornerRegs = new RegionId[4];
Magic Number,SharpNav,CompactHeightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\CompactHeightfield.cs,GetCornerHeight,The following statement contains a magic number: Area[] cornerAreas = new Area[4];
Magic Number,SharpNav,CompactHeightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\CompactHeightfield.cs,GetCornerHeight,The following statement contains a magic number: if (s.IsConnected(dir))  			{  				//get neighbor span  				int dx = sr.X + dir.GetHorizontalOffset();  				int dy = sr.Y + dir.GetVerticalOffset();  				int di = cells[dx + dy * width].StartIndex + CompactSpan.GetConnection(ref s' dir);  				CompactSpan ds = spans[di];    				cornerHeight = Math.Max(cornerHeight' ds.Minimum);  				cornerRegs[1] = spans[di].Region;  				cornerAreas[1] = areas[di];    				//get neighbor of neighbor's span  				if (ds.IsConnected(dirp))  				{  					int dx2 = dx + dirp.GetHorizontalOffset();  					int dy2 = dy + dirp.GetVerticalOffset();  					int di2 = cells[dx2 + dy2 * width].StartIndex + CompactSpan.GetConnection(ref ds' dirp);  					CompactSpan ds2 = spans[di2];    					cornerHeight = Math.Max(cornerHeight' ds2.Minimum);  					cornerRegs[2] = ds2.Region;  					cornerAreas[2] = areas[di2];  				}  			}
Magic Number,SharpNav,CompactHeightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\CompactHeightfield.cs,GetCornerHeight,The following statement contains a magic number: if (s.IsConnected(dir))  			{  				//get neighbor span  				int dx = sr.X + dir.GetHorizontalOffset();  				int dy = sr.Y + dir.GetVerticalOffset();  				int di = cells[dx + dy * width].StartIndex + CompactSpan.GetConnection(ref s' dir);  				CompactSpan ds = spans[di];    				cornerHeight = Math.Max(cornerHeight' ds.Minimum);  				cornerRegs[1] = spans[di].Region;  				cornerAreas[1] = areas[di];    				//get neighbor of neighbor's span  				if (ds.IsConnected(dirp))  				{  					int dx2 = dx + dirp.GetHorizontalOffset();  					int dy2 = dy + dirp.GetVerticalOffset();  					int di2 = cells[dx2 + dy2 * width].StartIndex + CompactSpan.GetConnection(ref ds' dirp);  					CompactSpan ds2 = spans[di2];    					cornerHeight = Math.Max(cornerHeight' ds2.Minimum);  					cornerRegs[2] = ds2.Region;  					cornerAreas[2] = areas[di2];  				}  			}
Magic Number,SharpNav,CompactHeightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\CompactHeightfield.cs,GetCornerHeight,The following statement contains a magic number: if (s.IsConnected(dirp))  			{  				int dx = sr.X + dirp.GetHorizontalOffset();  				int dy = sr.Y + dirp.GetVerticalOffset();  				int di = cells[dx + dy * width].StartIndex + CompactSpan.GetConnection(ref s' dirp);  				CompactSpan ds = spans[di];    				cornerHeight = Math.Max(cornerHeight' ds.Minimum);  				cornerRegs[3] = ds.Region;  				cornerAreas[3] = areas[di];    				//get neighbor of neighbor's span  				if (ds.IsConnected(dir))  				{  					int dx2 = dx + dir.GetHorizontalOffset();  					int dy2 = dy + dir.GetVerticalOffset();  					int di2 = cells[dx2 + dy2 * width].StartIndex + CompactSpan.GetConnection(ref ds' dir);  					CompactSpan ds2 = spans[di2];    					cornerHeight = Math.Max(cornerHeight' ds2.Minimum);  					cornerRegs[2] = ds2.Region;  					cornerAreas[2] = areas[di2];  				}  			}
Magic Number,SharpNav,CompactHeightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\CompactHeightfield.cs,GetCornerHeight,The following statement contains a magic number: if (s.IsConnected(dirp))  			{  				int dx = sr.X + dirp.GetHorizontalOffset();  				int dy = sr.Y + dirp.GetVerticalOffset();  				int di = cells[dx + dy * width].StartIndex + CompactSpan.GetConnection(ref s' dirp);  				CompactSpan ds = spans[di];    				cornerHeight = Math.Max(cornerHeight' ds.Minimum);  				cornerRegs[3] = ds.Region;  				cornerAreas[3] = areas[di];    				//get neighbor of neighbor's span  				if (ds.IsConnected(dir))  				{  					int dx2 = dx + dir.GetHorizontalOffset();  					int dy2 = dy + dir.GetVerticalOffset();  					int di2 = cells[dx2 + dy2 * width].StartIndex + CompactSpan.GetConnection(ref ds' dir);  					CompactSpan ds2 = spans[di2];    					cornerHeight = Math.Max(cornerHeight' ds2.Minimum);  					cornerRegs[2] = ds2.Region;  					cornerAreas[2] = areas[di2];  				}  			}
Magic Number,SharpNav,CompactHeightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\CompactHeightfield.cs,GetCornerHeight,The following statement contains a magic number: if (s.IsConnected(dirp))  			{  				int dx = sr.X + dirp.GetHorizontalOffset();  				int dy = sr.Y + dirp.GetVerticalOffset();  				int di = cells[dx + dy * width].StartIndex + CompactSpan.GetConnection(ref s' dirp);  				CompactSpan ds = spans[di];    				cornerHeight = Math.Max(cornerHeight' ds.Minimum);  				cornerRegs[3] = ds.Region;  				cornerAreas[3] = areas[di];    				//get neighbor of neighbor's span  				if (ds.IsConnected(dir))  				{  					int dx2 = dx + dir.GetHorizontalOffset();  					int dy2 = dy + dir.GetVerticalOffset();  					int di2 = cells[dx2 + dy2 * width].StartIndex + CompactSpan.GetConnection(ref ds' dir);  					CompactSpan ds2 = spans[di2];    					cornerHeight = Math.Max(cornerHeight' ds2.Minimum);  					cornerRegs[2] = ds2.Region;  					cornerAreas[2] = areas[di2];  				}  			}
Magic Number,SharpNav,CompactHeightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\CompactHeightfield.cs,GetCornerHeight,The following statement contains a magic number: if (s.IsConnected(dirp))  			{  				int dx = sr.X + dirp.GetHorizontalOffset();  				int dy = sr.Y + dirp.GetVerticalOffset();  				int di = cells[dx + dy * width].StartIndex + CompactSpan.GetConnection(ref s' dirp);  				CompactSpan ds = spans[di];    				cornerHeight = Math.Max(cornerHeight' ds.Minimum);  				cornerRegs[3] = ds.Region;  				cornerAreas[3] = areas[di];    				//get neighbor of neighbor's span  				if (ds.IsConnected(dir))  				{  					int dx2 = dx + dir.GetHorizontalOffset();  					int dy2 = dy + dir.GetVerticalOffset();  					int di2 = cells[dx2 + dy2 * width].StartIndex + CompactSpan.GetConnection(ref ds' dir);  					CompactSpan ds2 = spans[di2];    					cornerHeight = Math.Max(cornerHeight' ds2.Minimum);  					cornerRegs[2] = ds2.Region;  					cornerAreas[2] = areas[di2];  				}  			}
Magic Number,SharpNav,CompactHeightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\CompactHeightfield.cs,GetCornerHeight,The following statement contains a magic number: for (int j = 0; j < 4; j++)  			{  				int a = j;  				int b = (j + 1) % 4;  				int c = (j + 2) % 4;  				int d = (j + 3) % 4;    				RegionId ra = cornerRegs[a]' rb = cornerRegs[b]' rc = cornerRegs[c]' rd = cornerRegs[d];  				Area aa = cornerAreas[a]' ab = cornerAreas[b]' ac = cornerAreas[c]' ad = cornerAreas[d];    				//the vertex is a border vertex if:  				//two same exterior cells in a row followed by two interior cells and none of the regions are out of bounds  				bool twoSameExteriors = RegionId.HasFlags(ra' RegionFlags.Border) && RegionId.HasFlags(rb' RegionFlags.Border) && (ra == rb && aa == ab);  				bool twoSameInteriors = !(RegionId.HasFlags(rc' RegionFlags.Border) || RegionId.HasFlags(rd' RegionFlags.Border));  				bool intsSameArea = ac == ad;  				bool noZeros = ra != 0 && rb != 0 && rc != 0 && rd != 0 && aa != 0 && ab != 0 && ac != 0 && ad != 0;  				if (twoSameExteriors && twoSameInteriors && intsSameArea && noZeros)  				{  					isBorderVertex = true;  					break;  				}  			}
Magic Number,SharpNav,CompactHeightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\CompactHeightfield.cs,GetCornerHeight,The following statement contains a magic number: for (int j = 0; j < 4; j++)  			{  				int a = j;  				int b = (j + 1) % 4;  				int c = (j + 2) % 4;  				int d = (j + 3) % 4;    				RegionId ra = cornerRegs[a]' rb = cornerRegs[b]' rc = cornerRegs[c]' rd = cornerRegs[d];  				Area aa = cornerAreas[a]' ab = cornerAreas[b]' ac = cornerAreas[c]' ad = cornerAreas[d];    				//the vertex is a border vertex if:  				//two same exterior cells in a row followed by two interior cells and none of the regions are out of bounds  				bool twoSameExteriors = RegionId.HasFlags(ra' RegionFlags.Border) && RegionId.HasFlags(rb' RegionFlags.Border) && (ra == rb && aa == ab);  				bool twoSameInteriors = !(RegionId.HasFlags(rc' RegionFlags.Border) || RegionId.HasFlags(rd' RegionFlags.Border));  				bool intsSameArea = ac == ad;  				bool noZeros = ra != 0 && rb != 0 && rc != 0 && rd != 0 && aa != 0 && ab != 0 && ac != 0 && ad != 0;  				if (twoSameExteriors && twoSameInteriors && intsSameArea && noZeros)  				{  					isBorderVertex = true;  					break;  				}  			}
Magic Number,SharpNav,CompactHeightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\CompactHeightfield.cs,GetCornerHeight,The following statement contains a magic number: for (int j = 0; j < 4; j++)  			{  				int a = j;  				int b = (j + 1) % 4;  				int c = (j + 2) % 4;  				int d = (j + 3) % 4;    				RegionId ra = cornerRegs[a]' rb = cornerRegs[b]' rc = cornerRegs[c]' rd = cornerRegs[d];  				Area aa = cornerAreas[a]' ab = cornerAreas[b]' ac = cornerAreas[c]' ad = cornerAreas[d];    				//the vertex is a border vertex if:  				//two same exterior cells in a row followed by two interior cells and none of the regions are out of bounds  				bool twoSameExteriors = RegionId.HasFlags(ra' RegionFlags.Border) && RegionId.HasFlags(rb' RegionFlags.Border) && (ra == rb && aa == ab);  				bool twoSameInteriors = !(RegionId.HasFlags(rc' RegionFlags.Border) || RegionId.HasFlags(rd' RegionFlags.Border));  				bool intsSameArea = ac == ad;  				bool noZeros = ra != 0 && rb != 0 && rc != 0 && rd != 0 && aa != 0 && ab != 0 && ac != 0 && ad != 0;  				if (twoSameExteriors && twoSameInteriors && intsSameArea && noZeros)  				{  					isBorderVertex = true;  					break;  				}  			}
Magic Number,SharpNav,CompactHeightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\CompactHeightfield.cs,GetCornerHeight,The following statement contains a magic number: for (int j = 0; j < 4; j++)  			{  				int a = j;  				int b = (j + 1) % 4;  				int c = (j + 2) % 4;  				int d = (j + 3) % 4;    				RegionId ra = cornerRegs[a]' rb = cornerRegs[b]' rc = cornerRegs[c]' rd = cornerRegs[d];  				Area aa = cornerAreas[a]' ab = cornerAreas[b]' ac = cornerAreas[c]' ad = cornerAreas[d];    				//the vertex is a border vertex if:  				//two same exterior cells in a row followed by two interior cells and none of the regions are out of bounds  				bool twoSameExteriors = RegionId.HasFlags(ra' RegionFlags.Border) && RegionId.HasFlags(rb' RegionFlags.Border) && (ra == rb && aa == ab);  				bool twoSameInteriors = !(RegionId.HasFlags(rc' RegionFlags.Border) || RegionId.HasFlags(rd' RegionFlags.Border));  				bool intsSameArea = ac == ad;  				bool noZeros = ra != 0 && rb != 0 && rc != 0 && rd != 0 && aa != 0 && ab != 0 && ac != 0 && ad != 0;  				if (twoSameExteriors && twoSameInteriors && intsSameArea && noZeros)  				{  					isBorderVertex = true;  					break;  				}  			}
Magic Number,SharpNav,CompactHeightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\CompactHeightfield.cs,GetCornerHeight,The following statement contains a magic number: for (int j = 0; j < 4; j++)  			{  				int a = j;  				int b = (j + 1) % 4;  				int c = (j + 2) % 4;  				int d = (j + 3) % 4;    				RegionId ra = cornerRegs[a]' rb = cornerRegs[b]' rc = cornerRegs[c]' rd = cornerRegs[d];  				Area aa = cornerAreas[a]' ab = cornerAreas[b]' ac = cornerAreas[c]' ad = cornerAreas[d];    				//the vertex is a border vertex if:  				//two same exterior cells in a row followed by two interior cells and none of the regions are out of bounds  				bool twoSameExteriors = RegionId.HasFlags(ra' RegionFlags.Border) && RegionId.HasFlags(rb' RegionFlags.Border) && (ra == rb && aa == ab);  				bool twoSameInteriors = !(RegionId.HasFlags(rc' RegionFlags.Border) || RegionId.HasFlags(rd' RegionFlags.Border));  				bool intsSameArea = ac == ad;  				bool noZeros = ra != 0 && rb != 0 && rc != 0 && rd != 0 && aa != 0 && ab != 0 && ac != 0 && ad != 0;  				if (twoSameExteriors && twoSameInteriors && intsSameArea && noZeros)  				{  					isBorderVertex = true;  					break;  				}  			}
Magic Number,SharpNav,CompactHeightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\CompactHeightfield.cs,GetCornerHeight,The following statement contains a magic number: for (int j = 0; j < 4; j++)  			{  				int a = j;  				int b = (j + 1) % 4;  				int c = (j + 2) % 4;  				int d = (j + 3) % 4;    				RegionId ra = cornerRegs[a]' rb = cornerRegs[b]' rc = cornerRegs[c]' rd = cornerRegs[d];  				Area aa = cornerAreas[a]' ab = cornerAreas[b]' ac = cornerAreas[c]' ad = cornerAreas[d];    				//the vertex is a border vertex if:  				//two same exterior cells in a row followed by two interior cells and none of the regions are out of bounds  				bool twoSameExteriors = RegionId.HasFlags(ra' RegionFlags.Border) && RegionId.HasFlags(rb' RegionFlags.Border) && (ra == rb && aa == ab);  				bool twoSameInteriors = !(RegionId.HasFlags(rc' RegionFlags.Border) || RegionId.HasFlags(rd' RegionFlags.Border));  				bool intsSameArea = ac == ad;  				bool noZeros = ra != 0 && rb != 0 && rc != 0 && rd != 0 && aa != 0 && ab != 0 && ac != 0 && ad != 0;  				if (twoSameExteriors && twoSameInteriors && intsSameArea && noZeros)  				{  					isBorderVertex = true;  					break;  				}  			}
Magic Number,SharpNav,TiledNavMesh,C:\repos\Robmaister_SharpNav\Source\SharpNav\TiledNavMesh.cs,TiledNavMesh,The following statement contains a magic number: int saltBits = Math.Min(31' 32 - tileBits - polyBits);
Magic Number,SharpNav,TiledNavMesh,C:\repos\Robmaister_SharpNav\Source\SharpNav\TiledNavMesh.cs,TiledNavMesh,The following statement contains a magic number: int saltBits = Math.Min(31' 32 - tileBits - polyBits);
Magic Number,SharpNav,TiledNavMesh,C:\repos\Robmaister_SharpNav\Source\SharpNav\TiledNavMesh.cs,TiledNavMesh,The following statement contains a magic number: if (saltBits < 10)  				return;
Magic Number,SharpNav,TiledNavMesh,C:\repos\Robmaister_SharpNav\Source\SharpNav\TiledNavMesh.cs,TiledNavMesh,The following statement contains a magic number: int saltBits = Math.Min(31' 32 - tileBits - polyBits);
Magic Number,SharpNav,TiledNavMesh,C:\repos\Robmaister_SharpNav\Source\SharpNav\TiledNavMesh.cs,TiledNavMesh,The following statement contains a magic number: int saltBits = Math.Min(31' 32 - tileBits - polyBits);
Magic Number,SharpNav,TiledNavMesh,C:\repos\Robmaister_SharpNav\Source\SharpNav\TiledNavMesh.cs,TiledNavMesh,The following statement contains a magic number: if (saltBits < 10)  				return;
Magic Number,SharpNav,TiledNavMesh,C:\repos\Robmaister_SharpNav\Source\SharpNav\TiledNavMesh.cs,AddTile,The following statement contains a magic number: for (int i = 0; i < 8; i++)  			{  				BoundarySide b = (BoundarySide)i;  				BoundarySide bo = b.GetOpposite();  				foreach (NavTile neighborTile in GetNeighborTilesAt(header.X' header.Y' b))  				{  					tile.ConnectExtLinks(neighborTile' b);  					neighborTile.ConnectExtLinks(tile' bo);  					tile.ConnectExtOffMeshLinks(neighborTile' b);  					neighborTile.ConnectExtOffMeshLinks(tile' bo);  				}  			}
Magic Number,SharpNav.Collections.Generic,PriorityQueue<T>,C:\repos\Robmaister_SharpNav\Source\SharpNav\Collections\Generic\PriorityQueue.cs,BubbleUp,The following statement contains a magic number: int parent = (i - 1) / 2;
Magic Number,SharpNav.Collections.Generic,PriorityQueue<T>,C:\repos\Robmaister_SharpNav\Source\SharpNav\Collections\Generic\PriorityQueue.cs,BubbleUp,The following statement contains a magic number: while ((i > 0) && (heap[parent].Cost > node.Cost))  			{  				heap[i] = heap[parent];  				i = parent;  				parent = (i - 1) / 2;  			}
Magic Number,SharpNav.Collections.Generic,PriorityQueue<T>,C:\repos\Robmaister_SharpNav\Source\SharpNav\Collections\Generic\PriorityQueue.cs,TrickleDown,The following statement contains a magic number: int child = (i * 2) + 1;
Magic Number,SharpNav.Collections.Generic,PriorityQueue<T>,C:\repos\Robmaister_SharpNav\Source\SharpNav\Collections\Generic\PriorityQueue.cs,TrickleDown,The following statement contains a magic number: while (child < size)  			{  				//determine which child element has a smaller cost   				if (((child + 1) < size) && (heap[child].Cost > heap[child + 1].Cost))  					child++;    				heap[i] = heap[child];  				i = child;  				child = (i * 2) + 1;  			}
Magic Number,SharpNav.Collections.Generic,ProximityGrid<T>,C:\repos\Robmaister_SharpNav\Source\SharpNav\Collections\Generic\ProximityGrid.cs,HashPos2,The following statement contains a magic number: return ((x * 73856093) ^ (y * 19349663)) & (n - 1);
Magic Number,SharpNav.Collections.Generic,ProximityGrid<T>,C:\repos\Robmaister_SharpNav\Source\SharpNav\Collections\Generic\ProximityGrid.cs,HashPos2,The following statement contains a magic number: return ((x * 73856093) ^ (y * 19349663)) & (n - 1);
Magic Number,SharpNav.Collections,BVTree,C:\repos\Robmaister_SharpNav\Source\SharpNav\Collections\BVTree.cs,BVTree,The following statement contains a magic number: nodes = new Node[polys.Length * 2];
Magic Number,SharpNav.Collections,BVTree,C:\repos\Robmaister_SharpNav\Source\SharpNav\Collections\BVTree.cs,LongestAxis,The following statement contains a magic number: if (z > max)  				axis = 2;
Magic Number,SharpNav.Collections,BVTree,C:\repos\Robmaister_SharpNav\Source\SharpNav\Collections\BVTree.cs,Subdivide,The following statement contains a magic number: if (numIndex == 1)  				nodes[oldNode] = items[minIndex];  			else  			{  				PolyBounds bounds;  				CalcExtends(items' minIndex' maxIndex' out bounds);  				nodes[oldNode].Bounds = bounds;    				int axis = LongestAxis((int)(bounds.Max.X - bounds.Min.X)' (int)(bounds.Max.Y - bounds.Min.Y)' (int)(bounds.Max.Z - bounds.Min.Z));    				switch (axis)  				{  					case 0:  						items.Sort(minIndex' numIndex' XComparer);  						break;  					case 1:  						items.Sort(minIndex' numIndex' YComparer);  						break;  					case 2:  						items.Sort(minIndex' numIndex' ZComparer);  						break;  					default:  						break;  				}    				int splitIndex = minIndex + (numIndex / 2);    				curNode = Subdivide(items' minIndex' splitIndex' curNode);  				curNode = Subdivide(items' splitIndex' maxIndex' curNode);    				int escapeIndex = curNode - curIndex;  				nodes[oldNode].Index = -escapeIndex;  			}
Magic Number,SharpNav.Collections,BVTree,C:\repos\Robmaister_SharpNav\Source\SharpNav\Collections\BVTree.cs,Subdivide,The following statement contains a magic number: if (numIndex == 1)  				nodes[oldNode] = items[minIndex];  			else  			{  				PolyBounds bounds;  				CalcExtends(items' minIndex' maxIndex' out bounds);  				nodes[oldNode].Bounds = bounds;    				int axis = LongestAxis((int)(bounds.Max.X - bounds.Min.X)' (int)(bounds.Max.Y - bounds.Min.Y)' (int)(bounds.Max.Z - bounds.Min.Z));    				switch (axis)  				{  					case 0:  						items.Sort(minIndex' numIndex' XComparer);  						break;  					case 1:  						items.Sort(minIndex' numIndex' YComparer);  						break;  					case 2:  						items.Sort(minIndex' numIndex' ZComparer);  						break;  					default:  						break;  				}    				int splitIndex = minIndex + (numIndex / 2);    				curNode = Subdivide(items' minIndex' splitIndex' curNode);  				curNode = Subdivide(items' splitIndex' maxIndex' curNode);    				int escapeIndex = curNode - curIndex;  				nodes[oldNode].Index = -escapeIndex;  			}
Magic Number,SharpNav.Crowds,Crowd,C:\repos\Robmaister_SharpNav\Source\SharpNav\Crowds\Crowd.cs,Crowd,The following statement contains a magic number: this.grid = new ProximityGrid<Agent>(maxAgents * 4' maxAgentRadius * 3);
Magic Number,SharpNav.Crowds,Crowd,C:\repos\Robmaister_SharpNav\Source\SharpNav\Crowds\Crowd.cs,Crowd,The following statement contains a magic number: this.grid = new ProximityGrid<Agent>(maxAgents * 4' maxAgentRadius * 3);
Magic Number,SharpNav.Crowds,Crowd,C:\repos\Robmaister_SharpNav\Source\SharpNav\Crowds\Crowd.cs,Crowd,The following statement contains a magic number: this.obstacleQuery = new ObstacleAvoidanceQuery(6' 8);
Magic Number,SharpNav.Crowds,Crowd,C:\repos\Robmaister_SharpNav\Source\SharpNav\Crowds\Crowd.cs,Crowd,The following statement contains a magic number: this.obstacleQuery = new ObstacleAvoidanceQuery(6' 8);
Magic Number,SharpNav.Crowds,Crowd,C:\repos\Robmaister_SharpNav\Source\SharpNav\Crowds\Crowd.cs,Crowd,The following statement contains a magic number: for (int i = 0; i < this.obstacleQueryParams.Length; i++)  			{  				this.obstacleQueryParams[i].VelBias = 0.4f;  				this.obstacleQueryParams[i].WeightDesVel = 2.0f;  				this.obstacleQueryParams[i].WeightCurVel = 0.75f;  				this.obstacleQueryParams[i].WeightSide = 0.75f;  				this.obstacleQueryParams[i].WeightToi = 2.5f;  				this.obstacleQueryParams[i].HorizTime = 2.5f;  				this.obstacleQueryParams[i].GridSize = 33;  				this.obstacleQueryParams[i].AdaptiveDivs = 7;  				this.obstacleQueryParams[i].AdaptiveRings = 2;  				this.obstacleQueryParams[i].AdaptiveDepth = 5;  			}
Magic Number,SharpNav.Crowds,Crowd,C:\repos\Robmaister_SharpNav\Source\SharpNav\Crowds\Crowd.cs,Crowd,The following statement contains a magic number: for (int i = 0; i < this.obstacleQueryParams.Length; i++)  			{  				this.obstacleQueryParams[i].VelBias = 0.4f;  				this.obstacleQueryParams[i].WeightDesVel = 2.0f;  				this.obstacleQueryParams[i].WeightCurVel = 0.75f;  				this.obstacleQueryParams[i].WeightSide = 0.75f;  				this.obstacleQueryParams[i].WeightToi = 2.5f;  				this.obstacleQueryParams[i].HorizTime = 2.5f;  				this.obstacleQueryParams[i].GridSize = 33;  				this.obstacleQueryParams[i].AdaptiveDivs = 7;  				this.obstacleQueryParams[i].AdaptiveRings = 2;  				this.obstacleQueryParams[i].AdaptiveDepth = 5;  			}
Magic Number,SharpNav.Crowds,Crowd,C:\repos\Robmaister_SharpNav\Source\SharpNav\Crowds\Crowd.cs,Crowd,The following statement contains a magic number: for (int i = 0; i < this.obstacleQueryParams.Length; i++)  			{  				this.obstacleQueryParams[i].VelBias = 0.4f;  				this.obstacleQueryParams[i].WeightDesVel = 2.0f;  				this.obstacleQueryParams[i].WeightCurVel = 0.75f;  				this.obstacleQueryParams[i].WeightSide = 0.75f;  				this.obstacleQueryParams[i].WeightToi = 2.5f;  				this.obstacleQueryParams[i].HorizTime = 2.5f;  				this.obstacleQueryParams[i].GridSize = 33;  				this.obstacleQueryParams[i].AdaptiveDivs = 7;  				this.obstacleQueryParams[i].AdaptiveRings = 2;  				this.obstacleQueryParams[i].AdaptiveDepth = 5;  			}
Magic Number,SharpNav.Crowds,Crowd,C:\repos\Robmaister_SharpNav\Source\SharpNav\Crowds\Crowd.cs,Crowd,The following statement contains a magic number: for (int i = 0; i < this.obstacleQueryParams.Length; i++)  			{  				this.obstacleQueryParams[i].VelBias = 0.4f;  				this.obstacleQueryParams[i].WeightDesVel = 2.0f;  				this.obstacleQueryParams[i].WeightCurVel = 0.75f;  				this.obstacleQueryParams[i].WeightSide = 0.75f;  				this.obstacleQueryParams[i].WeightToi = 2.5f;  				this.obstacleQueryParams[i].HorizTime = 2.5f;  				this.obstacleQueryParams[i].GridSize = 33;  				this.obstacleQueryParams[i].AdaptiveDivs = 7;  				this.obstacleQueryParams[i].AdaptiveRings = 2;  				this.obstacleQueryParams[i].AdaptiveDepth = 5;  			}
Magic Number,SharpNav.Crowds,Crowd,C:\repos\Robmaister_SharpNav\Source\SharpNav\Crowds\Crowd.cs,Crowd,The following statement contains a magic number: this.pathq = new PathQueue(4096' ref navMesh);
Magic Number,SharpNav.Crowds,Crowd,C:\repos\Robmaister_SharpNav\Source\SharpNav\Crowds\Crowd.cs,Crowd,The following statement contains a magic number: this.navQuery = new NavMeshQuery(navMesh' 512);
Magic Number,SharpNav.Crowds,Crowd,C:\repos\Robmaister_SharpNav\Source\SharpNav\Crowds\Crowd.cs,Update,The following statement contains a magic number: for (int i = 0; i < numAgents; i++)  			{  				if (agents[i].State != AgentState.Walking)  					continue;  				if (agents[i].TargetState == TargetState.None ||  					agents[i].TargetState == TargetState.Velocity)  					continue;    				//check  				float triggerRadius = agents[i].Parameters.Radius * 2.25f;  				if (OverOffmeshConnection(agents[i]' triggerRadius))  				{  					//prepare to off-mesh connection  					int idx = i;  					  					//adjust the path over the off-mesh connection  					NavPolyId[] refs = new NavPolyId[2];  					if (agents[i].Corridor.MoveOverOffmeshConnection(agents[i].Corners[agents[i].Corners.Count - 1].Point.Polygon' refs' ref agentAnims[idx].StartPos' ref agentAnims[idx].EndPos' navQuery))  					{  						agentAnims[idx].InitPos = agents[i].Position;  						agentAnims[idx].PolyRef = refs[1];  						agentAnims[idx].Active = true;  						agentAnims[idx].T = 0.0f;  						agentAnims[idx].TMax = (Vector3Extensions.Distance2D(agentAnims[idx].StartPos' agentAnims[idx].EndPos)  							/ agents[i].Parameters.MaxSpeed) * 0.5f;    						agents[i].State = AgentState.Offmesh;  						agents[i].Corners.Clear();  						agents[i].NeighborCount = 0;  						continue;  					}  				}  			}
Magic Number,SharpNav.Crowds,Crowd,C:\repos\Robmaister_SharpNav\Source\SharpNav\Crowds\Crowd.cs,Update,The following statement contains a magic number: for (int i = 0; i < numAgents; i++)  			{  				if (agents[i].State != AgentState.Walking)  					continue;  				if (agents[i].TargetState == TargetState.None)  					continue;    				Vector3 dvel = new Vector3(0' 0' 0);    				if (agents[i].TargetState == TargetState.Velocity)  				{  					dvel = agents[i].TargetPosition;  					agents[i].DesiredSpeed = agents[i].TargetPosition.Length();  				}  				else  				{  					//calculate steering direction  					if ((agents[i].Parameters.UpdateFlags & UpdateFlags.AnticipateTurns) != 0)  						CalcSmoothSteerDirection(agents[i]' ref dvel);  					else  						CalcStraightSteerDirection(agents[i]' ref dvel);    					//calculate speed scale' which tells the agent to slowdown at the end of the path  					float slowDownRadius = agents[i].Parameters.Radius * 2;  					float speedScale = GetDistanceToGoal(agents[i]' slowDownRadius) / slowDownRadius;    					agents[i].DesiredSpeed = agents[i].Parameters.MaxSpeed;  					dvel = dvel * (agents[i].DesiredSpeed * speedScale);  				}    				//separation  				if ((agents[i].Parameters.UpdateFlags & UpdateFlags.Separation) != 0)  				{  					float separationDist = agents[i].Parameters.CollisionQueryRange;  					float invSeparationDist = 1.0f / separationDist;  					float separationWeight = agents[i].Parameters.SeparationWeight;    					float w = 0;  					Vector3 disp = new Vector3(0' 0' 0);    					for (int j = 0; j < agents[i].NeighborCount; j++)  					{  						Agent nei = agents[agents[i].Neighbors[j].Index];    						Vector3 diff = agents[i].Position - nei.Position;  						diff.Y = 0;    						float distSqr = diff.LengthSquared();  						if (distSqr < 0.00001f)  							continue;  						if (distSqr > separationDist * separationDist)  							continue;  						float dist = (float)Math.Sqrt(distSqr);  						float weight = separationWeight * (1.0f - (dist * invSeparationDist) * (dist * invSeparationDist));    						disp = disp + diff * (weight / dist);  						w += 1.0f;  					}    					if (w > 0.0001f)  					{  						//adjust desired veloctiy  						dvel = dvel + disp * (1.0f / w);    						//clamp desired velocity to desired speed  						float speedSqr = dvel.LengthSquared();  						float desiredSqr = agents[i].DesiredSpeed * agents[i].DesiredSpeed;  						if (speedSqr > desiredSqr)  							dvel = dvel * (desiredSqr / speedSqr);  					}  				}    				//set the desired velocity  				agents[i].DesiredVel = dvel;  			}
Magic Number,SharpNav.Crowds,Crowd,C:\repos\Robmaister_SharpNav\Source\SharpNav\Crowds\Crowd.cs,Update,The following statement contains a magic number: for (int iter = 0; iter < 4; iter++)  			{  				for (int i = 0; i < numAgents; i++)  				{  					int idx0 = GetAgentIndex(agents[i]);    					if (agents[i].State != AgentState.Walking)  						continue;    					agents[i].Disp = new Vector3(0' 0' 0);    					float w = 0;    					for (int j = 0; j < agents[i].NeighborCount; j++)  					{  						Agent nei = agents[agents[i].Neighbors[j].Index];  						int idx1 = GetAgentIndex(nei);    						Vector3 diff = agents[i].Position - nei.Position;  						diff.Y = 0;    						float dist = diff.LengthSquared();  						if (dist > (agents[i].Parameters.Radius + nei.Parameters.Radius) * (agents[i].Parameters.Radius + nei.Parameters.Radius))  							continue;  						dist = (float)Math.Sqrt(dist);  						float pen = (agents[i].Parameters.Radius + nei.Parameters.Radius) - dist;  						if (dist < 0.0001f)  						{  							//agents on top of each other' try to choose diverging separation directions  							if (idx0 > idx1)  								diff = new Vector3(-agents[i].DesiredVel.Z' 0' agents[i].DesiredVel.X);  							else  								diff = new Vector3(agents[i].DesiredVel.Z' 0' -agents[i].DesiredVel.X);  							pen = 0.01f;  						}  						else  						{  							pen = (1.0f / dist) * (pen * 0.5f) * COLLISION_RESOLVE_FACTOR;  						}    						agents[i].Disp = agents[i].Disp + diff * pen;    						w += 1.0f;  					}    					if (w > 0.0001f)  					{  						float iw = 1.0f / w;  						agents[i].Disp = agents[i].Disp * iw;  					}  				}    				for (int i = 0; i < numAgents; i++)  				{  					if (agents[i].State != AgentState.Walking)  						continue;    					//move along navmesh  					agents[i].Corridor.MovePosition(agents[i].Position' navQuery);    					//get valid constrained position back  					agents[i].Position = agents[i].Corridor.Pos;    					//if not using path' truncate the corridor to just one poly  					if (agents[i].TargetState == TargetState.None ||  						agents[i].TargetState == TargetState.Velocity)  					{  						agents[i].Corridor.Reset(agents[i].Corridor.GetFirstPoly()' agents[i].Position);  						agents[i].IsPartial = false;  					}  				}    				//update agents using offmesh connections  				for (int i = 0; i < maxAgents; i++)  				{  					if (!agentAnims[i].Active)  						continue;    					agentAnims[i].T += dt;  					if (agentAnims[i].T > agentAnims[i].TMax)  					{  						//reset animation  						agentAnims[i].Active = false;    						//prepare agent for walking  						agents[i].State = AgentState.Walking;    						continue;  					}    					//update position  					float ta = agentAnims[i].TMax * 0.15f;  					float tb = agentAnims[i].TMax;  					if (agentAnims[i].T < ta)  					{  						float u = MathHelper.Normalize(agentAnims[i].T' 0.0f' ta);  						Vector3 lerpOut;  						Vector3.Lerp(ref agentAnims[i].InitPos' ref agentAnims[i].StartPos' u' out lerpOut);  						agents[i].Position = lerpOut;  					}  					else  					{  						float u = MathHelper.Normalize(agentAnims[i].T' ta' tb);  						Vector3 lerpOut;  						Vector3.Lerp(ref agentAnims[i].StartPos' ref agentAnims[i].EndPos' u' out lerpOut);  						agents[i].Position = lerpOut;  					}    					agents[i].Vel = new Vector3(0' 0' 0);  					agents[i].DesiredVel = new Vector3(0' 0' 0);  				}  			}
Magic Number,SharpNav.Crowds,Crowd,C:\repos\Robmaister_SharpNav\Source\SharpNav\Crowds\Crowd.cs,UpdateMoveRequest,The following statement contains a magic number: const int PATH_MAX_AGENTS = 8;
Magic Number,SharpNav.Crowds,Crowd,C:\repos\Robmaister_SharpNav\Source\SharpNav\Crowds\Crowd.cs,UpdateMoveRequest,The following statement contains a magic number: for (int i = 0; i < maxAgents; i++)  			{  				if (!agents[i].IsActive)  					continue;  				if (agents[i].State == AgentState.Invalid)  					continue;  				if (agents[i].TargetState == TargetState.None || agents[i].TargetState == TargetState.Velocity)  					continue;    				if (agents[i].TargetState == TargetState.Requesting)  				{  					Path path = agents[i].Corridor.NavPath;    					Vector3 reqPos = new Vector3();  					Path reqPath = new Path();    					//quick search towards the goal  					const int MAX_ITER = 20;  					NavPoint startPoint = new NavPoint(path[0]' agents[i].Position);  					NavPoint endPoint = new NavPoint(agents[i].TargetRef' agents[i].TargetPosition);  					navQuery.InitSlicedFindPath(ref startPoint' ref endPoint' navQueryFilter' FindPathOptions.None);  					int tempInt = 0;  					navQuery.UpdateSlicedFindPath(MAX_ITER' ref tempInt);  					status = Status.Failure;  					if (agents[i].TargetReplan)  					{  						//try to use an existing steady path during replan if possible  						status = navQuery.FinalizedSlicedPathPartial(path' reqPath).ToStatus();  					}  					else  					{  						//try to move towards the target when the goal changes  						status = navQuery.FinalizeSlicedFindPath(reqPath).ToStatus();  					}    					if (status != Status.Failure && reqPath.Count > 0)  					{  						//in progress or succeed  						if (reqPath[reqPath.Count - 1] != agents[i].TargetRef)  						{  							//partial path' constrain target position in last polygon  							bool tempBool;  							status = navQuery.ClosestPointOnPoly(reqPath[reqPath.Count - 1]' agents[i].TargetPosition' out reqPos' out tempBool).ToStatus();  							if (status == Status.Failure)  								reqPath.Clear();  						}  						else  						{  							reqPos = agents[i].TargetPosition;  						}  					}  					else  					{  						reqPath.Clear();  					}    					if (reqPath.Count == 0)  					{  						//could not find path' start the request from the current location  						reqPos = agents[i].Position;  						reqPath.Add(path[0]);  					}    					agents[i].Corridor.SetCorridor(reqPos' reqPath);  					agents[i].Boundary.Reset();  					agents[i].IsPartial = false;    					if (reqPath[reqPath.Count - 1] == agents[i].TargetRef)  					{  						agents[i].TargetState = TargetState.Valid;  						agents[i].TargetReplanTime = 0.0f;  					}  					else  					{  						//the path is longer or potentially unreachable' full plan  						agents[i].TargetState = TargetState.WaitingForQueue;  					}  				}    				if (agents[i].TargetState == TargetState.WaitingForQueue)  				{  					numQueue = AddToPathQueue(agents[i]' queue' numQueue' PATH_MAX_AGENTS);  				}  			}
Magic Number,SharpNav.Crowds,Crowd,C:\repos\Robmaister_SharpNav\Source\SharpNav\Crowds\Crowd.cs,CheckPathValidity,The following statement contains a magic number: const int CHECK_LOOKAHEAD = 10;
Magic Number,SharpNav.Crowds,Crowd,C:\repos\Robmaister_SharpNav\Source\SharpNav\Crowds\Crowd.cs,GetNeighbors,The following statement contains a magic number: const int MAX_NEIS = 32;
Magic Number,SharpNav.Crowds,ObstacleAvoidanceQuery,C:\repos\Robmaister_SharpNav\Source\SharpNav\Crowds\ObstacleAvoidanceQuery.cs,ProcessSample,The following statement contains a magic number: for (int i = 0; i < numCircles; i++)  			{  				ObstacleCircle cir = circles[i];    				//RVO  				Vector3 vab = vcand * 2;  				vab = vab - vel;  				vab = vab - cir.Vel;    				//side  				side += MathHelper.Clamp(Math.Min(Vector3Extensions.Dot2D(ref cir.Dp' ref vab) * 0.5f + 0.5f' Vector3Extensions.Dot2D(ref cir.Np' ref vab) * 2.0f)' 0.0f' 1.0f);  				numSide++;    				float htmin = 0' htmax = 0;  				if (!SweepCircleCircle(position' radius' vab' cir.Position' cir.Radius' ref htmin' ref htmax))  					continue;    				//handle overlapping obstacles  				if (htmin < 0.0f && htmax > 0.0f)  				{  					//avoid more when overlapped  					htmin = -htmin * 0.5f;  				}    				if (htmin >= 0.0f)  				{  					//the closest obstacle is sometime ahead of us' keep track of nearest obstacle  					if (htmin < tmin)  						tmin = htmin;  				}  			}
Magic Number,SharpNav.Crowds,ObstacleAvoidanceQuery,C:\repos\Robmaister_SharpNav\Source\SharpNav\Crowds\ObstacleAvoidanceQuery.cs,SampleVelocityGrid,The following statement contains a magic number: float cs = vmax * 2 * (1 - this.parameters.VelBias) / (float)(this.parameters.GridSize - 1);
Magic Number,SharpNav.Crowds,ObstacleAvoidanceQuery,C:\repos\Robmaister_SharpNav\Source\SharpNav\Crowds\ObstacleAvoidanceQuery.cs,SampleVelocityGrid,The following statement contains a magic number: for (int y = 0; y < this.parameters.GridSize; y++)  			{  				for (int x = 0; x < this.parameters.GridSize; x++)  				{  					Vector3 vcand = new Vector3(0' 0' 0);  					vcand.X = cvx + x * cs - half;  					vcand.Y = 0;  					vcand.Z = cvz + y * cs - half;    					if (vcand.X * vcand.X + vcand.Z * vcand.Z > (vmax + cs / 2) * (vmax + cs / 2))  						continue;    					float penalty = ProcessSample(vcand' cs' pos' rad' vel' desiredVel);  					numSamples++;  					if (penalty < minPenalty)  					{  						minPenalty = penalty;  						nvel = vcand;  					}  				}  			}
Magic Number,SharpNav.Crowds,ObstacleAvoidanceQuery,C:\repos\Robmaister_SharpNav\Source\SharpNav\Crowds\ObstacleAvoidanceQuery.cs,SampleVelocityGrid,The following statement contains a magic number: for (int y = 0; y < this.parameters.GridSize; y++)  			{  				for (int x = 0; x < this.parameters.GridSize; x++)  				{  					Vector3 vcand = new Vector3(0' 0' 0);  					vcand.X = cvx + x * cs - half;  					vcand.Y = 0;  					vcand.Z = cvz + y * cs - half;    					if (vcand.X * vcand.X + vcand.Z * vcand.Z > (vmax + cs / 2) * (vmax + cs / 2))  						continue;    					float penalty = ProcessSample(vcand' cs' pos' rad' vel' desiredVel);  					numSamples++;  					if (penalty < minPenalty)  					{  						minPenalty = penalty;  						nvel = vcand;  					}  				}  			}
Magic Number,SharpNav.Crowds,ObstacleAvoidanceQuery,C:\repos\Robmaister_SharpNav\Source\SharpNav\Crowds\ObstacleAvoidanceQuery.cs,SampleVelocityAdaptive,The following statement contains a magic number: float[] pattern = new float[(MaxPatternDivs * MaxPatternRings + 1) * 2];
Magic Number,SharpNav.Crowds,ObstacleAvoidanceQuery,C:\repos\Robmaister_SharpNav\Source\SharpNav\Crowds\ObstacleAvoidanceQuery.cs,SampleVelocityAdaptive,The following statement contains a magic number: float da = (1.0f / newNumDivs) * (float)Math.PI * 2;
Magic Number,SharpNav.Crowds,ObstacleAvoidanceQuery,C:\repos\Robmaister_SharpNav\Source\SharpNav\Crowds\ObstacleAvoidanceQuery.cs,SampleVelocityAdaptive,The following statement contains a magic number: pattern[numPatterns * 2 + 0] = 0;
Magic Number,SharpNav.Crowds,ObstacleAvoidanceQuery,C:\repos\Robmaister_SharpNav\Source\SharpNav\Crowds\ObstacleAvoidanceQuery.cs,SampleVelocityAdaptive,The following statement contains a magic number: pattern[numPatterns * 2 + 1] = 0;
Magic Number,SharpNav.Crowds,ObstacleAvoidanceQuery,C:\repos\Robmaister_SharpNav\Source\SharpNav\Crowds\ObstacleAvoidanceQuery.cs,SampleVelocityAdaptive,The following statement contains a magic number: for (int j = 0; j < newNumRings; j++)  			{  				float r = (float)(newNumRings - j) / (float)newNumRings;  				float a = dang + (j & 1) * 0.5f * da;  				for (int i = 0; i < newNumDivs; i++)  				{  					pattern[numPatterns * 2 + 0] = (float)Math.Cos(a) * r;  					pattern[numPatterns * 2 + 1] = (float)Math.Sin(a) * r;  					numPatterns++;  					a += da;  				}  			}
Magic Number,SharpNav.Crowds,ObstacleAvoidanceQuery,C:\repos\Robmaister_SharpNav\Source\SharpNav\Crowds\ObstacleAvoidanceQuery.cs,SampleVelocityAdaptive,The following statement contains a magic number: for (int j = 0; j < newNumRings; j++)  			{  				float r = (float)(newNumRings - j) / (float)newNumRings;  				float a = dang + (j & 1) * 0.5f * da;  				for (int i = 0; i < newNumDivs; i++)  				{  					pattern[numPatterns * 2 + 0] = (float)Math.Cos(a) * r;  					pattern[numPatterns * 2 + 1] = (float)Math.Sin(a) * r;  					numPatterns++;  					a += da;  				}  			}
Magic Number,SharpNav.Crowds,ObstacleAvoidanceQuery,C:\repos\Robmaister_SharpNav\Source\SharpNav\Crowds\ObstacleAvoidanceQuery.cs,SampleVelocityAdaptive,The following statement contains a magic number: for (int k = 0; k < depth; k++)  			{  				float minPenalty = float.MaxValue;  				Vector3 bvel = new Vector3(0' 0' 0);    				for (int i = 0; i < numPatterns; i++)  				{  					Vector3 vcand = new Vector3();  					vcand.X = res.X + pattern[i * 2 + 0] * cr;  					vcand.Y = 0;  					vcand.Z = res.Z + pattern[i * 2 + 1] * cr;    					if (vcand.X * vcand.X + vcand.Z * vcand.Z > (vmax + 0.001f) * (vmax + 0.001f))  						continue;    					float penalty = ProcessSample(vcand' cr / 10' position' radius' vel' desiredVel);  					ns++;  					if (penalty < minPenalty)  					{  						minPenalty = penalty;  						bvel = vcand;  					}  				}    				res = bvel;    				cr *= 0.5f;  			}
Magic Number,SharpNav.Crowds,ObstacleAvoidanceQuery,C:\repos\Robmaister_SharpNav\Source\SharpNav\Crowds\ObstacleAvoidanceQuery.cs,SampleVelocityAdaptive,The following statement contains a magic number: for (int k = 0; k < depth; k++)  			{  				float minPenalty = float.MaxValue;  				Vector3 bvel = new Vector3(0' 0' 0);    				for (int i = 0; i < numPatterns; i++)  				{  					Vector3 vcand = new Vector3();  					vcand.X = res.X + pattern[i * 2 + 0] * cr;  					vcand.Y = 0;  					vcand.Z = res.Z + pattern[i * 2 + 1] * cr;    					if (vcand.X * vcand.X + vcand.Z * vcand.Z > (vmax + 0.001f) * (vmax + 0.001f))  						continue;    					float penalty = ProcessSample(vcand' cr / 10' position' radius' vel' desiredVel);  					ns++;  					if (penalty < minPenalty)  					{  						minPenalty = penalty;  						bvel = vcand;  					}  				}    				res = bvel;    				cr *= 0.5f;  			}
Magic Number,SharpNav.Crowds,ObstacleAvoidanceQuery,C:\repos\Robmaister_SharpNav\Source\SharpNav\Crowds\ObstacleAvoidanceQuery.cs,SampleVelocityAdaptive,The following statement contains a magic number: for (int k = 0; k < depth; k++)  			{  				float minPenalty = float.MaxValue;  				Vector3 bvel = new Vector3(0' 0' 0);    				for (int i = 0; i < numPatterns; i++)  				{  					Vector3 vcand = new Vector3();  					vcand.X = res.X + pattern[i * 2 + 0] * cr;  					vcand.Y = 0;  					vcand.Z = res.Z + pattern[i * 2 + 1] * cr;    					if (vcand.X * vcand.X + vcand.Z * vcand.Z > (vmax + 0.001f) * (vmax + 0.001f))  						continue;    					float penalty = ProcessSample(vcand' cr / 10' position' radius' vel' desiredVel);  					ns++;  					if (penalty < minPenalty)  					{  						minPenalty = penalty;  						bvel = vcand;  					}  				}    				res = bvel;    				cr *= 0.5f;  			}
Magic Number,SharpNav.Crowds,PathCorridor,C:\repos\Robmaister_SharpNav\Source\SharpNav\Crowds\PathCorridor.cs,MovePosition,The following statement contains a magic number: const int MaxVisited = 16;
Magic Number,SharpNav.Crowds,PathCorridor,C:\repos\Robmaister_SharpNav\Source\SharpNav\Crowds\PathCorridor.cs,OptimizePathTopology,The following statement contains a magic number: if (path.Count < 3)  				return false;
Magic Number,SharpNav.Crowds,PathCorridor,C:\repos\Robmaister_SharpNav\Source\SharpNav\Crowds\PathCorridor.cs,OptimizePathTopology,The following statement contains a magic number: const int MaxIter = 32;
Magic Number,SharpNav.Crowds,PathCorridor,C:\repos\Robmaister_SharpNav\Source\SharpNav\Crowds\PathCorridor.cs,OptimizePathTopology,The following statement contains a magic number: const int MaxRes = 32;
Magic Number,SharpNav.Crowds,PathCorridor,C:\repos\Robmaister_SharpNav\Source\SharpNav\Crowds\PathCorridor.cs,FixPathStart,The following statement contains a magic number: if (path.Count < 3 && path.Count > 0)  			{  				NavPolyId lastPathId = path[path.Count - 1];    				path.Clear();  				path.Add(safeRef);  				path.Add(NavPolyId.Null);  				path.Add(lastPathId);  			}  			else  			{  				path[0] = safeRef;  				path[1] = NavPolyId.Null;  			}
Magic Number,SharpNav.Geometry,TriangleEnumerable,C:\repos\Robmaister_SharpNav\Source\SharpNav\Geometry\TriangleEnumerable.cs,FromVector3,The following statement contains a magic number: if (vertStride == 0)  				vertStride = 3;
Magic Number,SharpNav.Geometry,TriangleEnumerable,C:\repos\Robmaister_SharpNav\Source\SharpNav\Geometry\TriangleEnumerable.cs,FromVector3,The following statement contains a magic number: for (int i = 0; i < triCount; i++)  			{  				tri.A = vertices[i * vertStride + vertOffset];  				tri.B = vertices[i * vertStride + vertOffset + 1];  				tri.C = vertices[i * vertStride + vertOffset + 2];    				yield return tri;  			}
Magic Number,SharpNav.Geometry,TriangleEnumerable,C:\repos\Robmaister_SharpNav\Source\SharpNav\Geometry\TriangleEnumerable.cs,FromFloat,The following statement contains a magic number: if (floatStride == 0)  				floatStride = 3;
Magic Number,SharpNav.Geometry,TriangleEnumerable,C:\repos\Robmaister_SharpNav\Source\SharpNav\Geometry\TriangleEnumerable.cs,FromFloat,The following statement contains a magic number: for (int i = 0; i < triCount; i++)  			{  				int indA = i * (floatStride * 3) + floatOffset;  				int indB = indA + floatStride;  				int indC = indB + floatStride;    				tri.A.X = vertices[indA];  				tri.A.Y = vertices[indA + 1];  				tri.A.Z = vertices[indA + 2];    				tri.B.X = vertices[indB];  				tri.B.Y = vertices[indB + 1];  				tri.B.Z = vertices[indB + 2];    				tri.C.X = vertices[indC];  				tri.C.Y = vertices[indC + 1];  				tri.C.Z = vertices[indC + 2];    				yield return tri;  			}
Magic Number,SharpNav.Geometry,TriangleEnumerable,C:\repos\Robmaister_SharpNav\Source\SharpNav\Geometry\TriangleEnumerable.cs,FromFloat,The following statement contains a magic number: for (int i = 0; i < triCount; i++)  			{  				int indA = i * (floatStride * 3) + floatOffset;  				int indB = indA + floatStride;  				int indC = indB + floatStride;    				tri.A.X = vertices[indA];  				tri.A.Y = vertices[indA + 1];  				tri.A.Z = vertices[indA + 2];    				tri.B.X = vertices[indB];  				tri.B.Y = vertices[indB + 1];  				tri.B.Z = vertices[indB + 2];    				tri.C.X = vertices[indC];  				tri.C.Y = vertices[indC + 1];  				tri.C.Z = vertices[indC + 2];    				yield return tri;  			}
Magic Number,SharpNav.Geometry,TriangleEnumerable,C:\repos\Robmaister_SharpNav\Source\SharpNav\Geometry\TriangleEnumerable.cs,FromFloat,The following statement contains a magic number: for (int i = 0; i < triCount; i++)  			{  				int indA = i * (floatStride * 3) + floatOffset;  				int indB = indA + floatStride;  				int indC = indB + floatStride;    				tri.A.X = vertices[indA];  				tri.A.Y = vertices[indA + 1];  				tri.A.Z = vertices[indA + 2];    				tri.B.X = vertices[indB];  				tri.B.Y = vertices[indB + 1];  				tri.B.Z = vertices[indB + 2];    				tri.C.X = vertices[indC];  				tri.C.Y = vertices[indC + 1];  				tri.C.Z = vertices[indC + 2];    				yield return tri;  			}
Magic Number,SharpNav.Geometry,TriangleEnumerable,C:\repos\Robmaister_SharpNav\Source\SharpNav\Geometry\TriangleEnumerable.cs,FromFloat,The following statement contains a magic number: for (int i = 0; i < triCount; i++)  			{  				int indA = i * (floatStride * 3) + floatOffset;  				int indB = indA + floatStride;  				int indC = indB + floatStride;    				tri.A.X = vertices[indA];  				tri.A.Y = vertices[indA + 1];  				tri.A.Z = vertices[indA + 2];    				tri.B.X = vertices[indB];  				tri.B.Y = vertices[indB + 1];  				tri.B.Z = vertices[indB + 2];    				tri.C.X = vertices[indC];  				tri.C.Y = vertices[indC + 1];  				tri.C.Z = vertices[indC + 2];    				yield return tri;  			}
Magic Number,SharpNav.Geometry,TriangleEnumerable,C:\repos\Robmaister_SharpNav\Source\SharpNav\Geometry\TriangleEnumerable.cs,FromIndexedVector3,The following statement contains a magic number: for (int i = 0; i < triCount; i++)  			{  				int indA = vertOffset + indices[i * 3 + indexOffset] * vertStride;  				int indB = vertOffset + indices[i * 3 + indexOffset + 1] * vertStride;  				int indC = vertOffset + indices[i * 3 + indexOffset + 2] * vertStride;    				tri.A = vertices[indA];  				tri.B = vertices[indB];  				tri.C = vertices[indC];    				yield return tri;  			}
Magic Number,SharpNav.Geometry,TriangleEnumerable,C:\repos\Robmaister_SharpNav\Source\SharpNav\Geometry\TriangleEnumerable.cs,FromIndexedVector3,The following statement contains a magic number: for (int i = 0; i < triCount; i++)  			{  				int indA = vertOffset + indices[i * 3 + indexOffset] * vertStride;  				int indB = vertOffset + indices[i * 3 + indexOffset + 1] * vertStride;  				int indC = vertOffset + indices[i * 3 + indexOffset + 2] * vertStride;    				tri.A = vertices[indA];  				tri.B = vertices[indB];  				tri.C = vertices[indC];    				yield return tri;  			}
Magic Number,SharpNav.Geometry,TriangleEnumerable,C:\repos\Robmaister_SharpNav\Source\SharpNav\Geometry\TriangleEnumerable.cs,FromIndexedVector3,The following statement contains a magic number: for (int i = 0; i < triCount; i++)  			{  				int indA = vertOffset + indices[i * 3 + indexOffset] * vertStride;  				int indB = vertOffset + indices[i * 3 + indexOffset + 1] * vertStride;  				int indC = vertOffset + indices[i * 3 + indexOffset + 2] * vertStride;    				tri.A = vertices[indA];  				tri.B = vertices[indB];  				tri.C = vertices[indC];    				yield return tri;  			}
Magic Number,SharpNav.Geometry,TriangleEnumerable,C:\repos\Robmaister_SharpNav\Source\SharpNav\Geometry\TriangleEnumerable.cs,FromIndexedVector3,The following statement contains a magic number: for (int i = 0; i < triCount; i++)  			{  				int indA = vertOffset + indices[i * 3 + indexOffset] * vertStride;  				int indB = vertOffset + indices[i * 3 + indexOffset + 1] * vertStride;  				int indC = vertOffset + indices[i * 3 + indexOffset + 2] * vertStride;    				tri.A = vertices[indA];  				tri.B = vertices[indB];  				tri.C = vertices[indC];    				yield return tri;  			}
Magic Number,SharpNav.Geometry,TriangleEnumerable,C:\repos\Robmaister_SharpNav\Source\SharpNav\Geometry\TriangleEnumerable.cs,FromIndexedFloat,The following statement contains a magic number: for (int i = 0; i < triCount; i++)  			{  				int indA = floatOffset + indices[i * 3 + indexOffset] * floatStride;  				int indB = floatOffset + indices[i * 3 + indexOffset + 1] * floatStride;  				int indC = floatOffset + indices[i * 3 + indexOffset + 2] * floatStride;    				tri.A.X = vertices[indA];  				tri.A.Y = vertices[indA + 1];  				tri.A.Z = vertices[indA + 2];    				tri.B.X = vertices[indB];  				tri.B.Y = vertices[indB + 1];  				tri.B.Z = vertices[indB + 2];    				tri.C.X = vertices[indC];  				tri.C.Y = vertices[indC + 1];  				tri.C.Z = vertices[indC + 2];    				yield return tri;  			}
Magic Number,SharpNav.Geometry,TriangleEnumerable,C:\repos\Robmaister_SharpNav\Source\SharpNav\Geometry\TriangleEnumerable.cs,FromIndexedFloat,The following statement contains a magic number: for (int i = 0; i < triCount; i++)  			{  				int indA = floatOffset + indices[i * 3 + indexOffset] * floatStride;  				int indB = floatOffset + indices[i * 3 + indexOffset + 1] * floatStride;  				int indC = floatOffset + indices[i * 3 + indexOffset + 2] * floatStride;    				tri.A.X = vertices[indA];  				tri.A.Y = vertices[indA + 1];  				tri.A.Z = vertices[indA + 2];    				tri.B.X = vertices[indB];  				tri.B.Y = vertices[indB + 1];  				tri.B.Z = vertices[indB + 2];    				tri.C.X = vertices[indC];  				tri.C.Y = vertices[indC + 1];  				tri.C.Z = vertices[indC + 2];    				yield return tri;  			}
Magic Number,SharpNav.Geometry,TriangleEnumerable,C:\repos\Robmaister_SharpNav\Source\SharpNav\Geometry\TriangleEnumerable.cs,FromIndexedFloat,The following statement contains a magic number: for (int i = 0; i < triCount; i++)  			{  				int indA = floatOffset + indices[i * 3 + indexOffset] * floatStride;  				int indB = floatOffset + indices[i * 3 + indexOffset + 1] * floatStride;  				int indC = floatOffset + indices[i * 3 + indexOffset + 2] * floatStride;    				tri.A.X = vertices[indA];  				tri.A.Y = vertices[indA + 1];  				tri.A.Z = vertices[indA + 2];    				tri.B.X = vertices[indB];  				tri.B.Y = vertices[indB + 1];  				tri.B.Z = vertices[indB + 2];    				tri.C.X = vertices[indC];  				tri.C.Y = vertices[indC + 1];  				tri.C.Z = vertices[indC + 2];    				yield return tri;  			}
Magic Number,SharpNav.Geometry,TriangleEnumerable,C:\repos\Robmaister_SharpNav\Source\SharpNav\Geometry\TriangleEnumerable.cs,FromIndexedFloat,The following statement contains a magic number: for (int i = 0; i < triCount; i++)  			{  				int indA = floatOffset + indices[i * 3 + indexOffset] * floatStride;  				int indB = floatOffset + indices[i * 3 + indexOffset + 1] * floatStride;  				int indC = floatOffset + indices[i * 3 + indexOffset + 2] * floatStride;    				tri.A.X = vertices[indA];  				tri.A.Y = vertices[indA + 1];  				tri.A.Z = vertices[indA + 2];    				tri.B.X = vertices[indB];  				tri.B.Y = vertices[indB + 1];  				tri.B.Z = vertices[indB + 2];    				tri.C.X = vertices[indC];  				tri.C.Y = vertices[indC + 1];  				tri.C.Z = vertices[indC + 2];    				yield return tri;  			}
Magic Number,SharpNav.Geometry,TriangleEnumerable,C:\repos\Robmaister_SharpNav\Source\SharpNav\Geometry\TriangleEnumerable.cs,FromIndexedFloat,The following statement contains a magic number: for (int i = 0; i < triCount; i++)  			{  				int indA = floatOffset + indices[i * 3 + indexOffset] * floatStride;  				int indB = floatOffset + indices[i * 3 + indexOffset + 1] * floatStride;  				int indC = floatOffset + indices[i * 3 + indexOffset + 2] * floatStride;    				tri.A.X = vertices[indA];  				tri.A.Y = vertices[indA + 1];  				tri.A.Z = vertices[indA + 2];    				tri.B.X = vertices[indB];  				tri.B.Y = vertices[indB + 1];  				tri.B.Z = vertices[indB + 2];    				tri.C.X = vertices[indC];  				tri.C.Y = vertices[indC + 1];  				tri.C.Z = vertices[indC + 2];    				yield return tri;  			}
Magic Number,SharpNav.Geometry,TriangleEnumerable,C:\repos\Robmaister_SharpNav\Source\SharpNav\Geometry\TriangleEnumerable.cs,FromIndexedFloat,The following statement contains a magic number: for (int i = 0; i < triCount; i++)  			{  				int indA = floatOffset + indices[i * 3 + indexOffset] * floatStride;  				int indB = floatOffset + indices[i * 3 + indexOffset + 1] * floatStride;  				int indC = floatOffset + indices[i * 3 + indexOffset + 2] * floatStride;    				tri.A.X = vertices[indA];  				tri.A.Y = vertices[indA + 1];  				tri.A.Z = vertices[indA + 2];    				tri.B.X = vertices[indB];  				tri.B.Y = vertices[indB + 1];  				tri.B.Z = vertices[indB + 2];    				tri.C.X = vertices[indC];  				tri.C.Y = vertices[indC + 1];  				tri.C.Z = vertices[indC + 2];    				yield return tri;  			}
Magic Number,SharpNav.Geometry,TriangleEnumerable,C:\repos\Robmaister_SharpNav\Source\SharpNav\Geometry\TriangleEnumerable.cs,FromIndexedFloat,The following statement contains a magic number: for (int i = 0; i < triCount; i++)  			{  				int indA = floatOffset + indices[i * 3 + indexOffset] * floatStride;  				int indB = floatOffset + indices[i * 3 + indexOffset + 1] * floatStride;  				int indC = floatOffset + indices[i * 3 + indexOffset + 2] * floatStride;    				tri.A.X = vertices[indA];  				tri.A.Y = vertices[indA + 1];  				tri.A.Z = vertices[indA + 2];    				tri.B.X = vertices[indB];  				tri.B.Y = vertices[indB + 1];  				tri.B.Z = vertices[indB + 2];    				tri.C.X = vertices[indC];  				tri.C.Y = vertices[indC + 1];  				tri.C.Z = vertices[indC + 2];    				yield return tri;  			}
Magic Number,SharpNav.Geometry,Triangle3,C:\repos\Robmaister_SharpNav\Source\SharpNav\Geometry\Triangle3.cs,GetHashCode,The following statement contains a magic number: int hash = 17;
Magic Number,SharpNav.Geometry,Triangle3,C:\repos\Robmaister_SharpNav\Source\SharpNav\Geometry\Triangle3.cs,GetHashCode,The following statement contains a magic number: hash = hash * 23 + A.GetHashCode();
Magic Number,SharpNav.Geometry,Triangle3,C:\repos\Robmaister_SharpNav\Source\SharpNav\Geometry\Triangle3.cs,GetHashCode,The following statement contains a magic number: hash = hash * 23 + B.GetHashCode();
Magic Number,SharpNav.Geometry,Triangle3,C:\repos\Robmaister_SharpNav\Source\SharpNav\Geometry\Triangle3.cs,GetHashCode,The following statement contains a magic number: hash = hash * 23 + C.GetHashCode();
Magic Number,SharpNav.Pathfinding,BoundarySideExtensions,C:\repos\Robmaister_SharpNav\Source\SharpNav\Pathfinding\BoundarySide.cs,GetOpposite,The following statement contains a magic number: return (BoundarySide)((int)(side + 4) % 8);
Magic Number,SharpNav.Pathfinding,BoundarySideExtensions,C:\repos\Robmaister_SharpNav\Source\SharpNav\Pathfinding\BoundarySide.cs,GetOpposite,The following statement contains a magic number: return (BoundarySide)((int)(side + 4) % 8);
Magic Number,SharpNav.Pathfinding,NavTile,C:\repos\Robmaister_SharpNav\Source\SharpNav\Pathfinding\NavTile.cs,ConnectExtLinks,The following statement contains a magic number: for (int i = 0; i < PolyCount; i++)  			{  				int numPolyVerts = Polys[i].VertCount;    				for (int j = 0; j < numPolyVerts; j++)  				{  					//Skip non-portal edges  					if ((Polys[i].Neis[j] & Link.External) == 0)  						continue;    					BoundarySide dir = (BoundarySide)(Polys[i].Neis[j] & 0xff);  					if (side != BoundarySide.Internal && dir != side)  						continue;    					//Create new links  					Vector3 va = Verts[Polys[i].Verts[j]];  					Vector3 vb = Verts[Polys[i].Verts[(j + 1) % numPolyVerts]];  					List<NavPolyId> nei = new List<NavPolyId>(4);  					List<float> neia = new List<float>(4 * 2);  					target.FindConnectingPolys(va' vb' dir.GetOpposite()' nei' neia);    					//Iterate through neighbors  					for (int k = 0; k < nei.Count; k++)  					{  						Link link = new Link();  						link.Reference = nei[k];  						link.Edge = j;  						link.Side = dir;  						Polys[i].Links.Add(link);    						//Compress portal limits to a value  						if (dir == BoundarySide.PlusX || dir == BoundarySide.MinusX)  						{  							float tmin = (neia[k * 2 + 0] - va.Z) / (vb.Z - va.Z);  							float tmax = (neia[k * 2 + 1] - va.Z) / (vb.Z - va.Z);    							if (tmin > tmax)  							{  								float temp = tmin;  								tmin = tmax;  								tmax = temp;  							}    							link.BMin = (int)(MathHelper.Clamp(tmin' 0.0f' 1.0f) * 255.0f);  							link.BMax = (int)(MathHelper.Clamp(tmax' 0.0f' 1.0f) * 255.0f);  						}  						else if (dir == BoundarySide.PlusZ || dir == BoundarySide.MinusZ)  						{  							float tmin = (neia[k * 2 + 0] - va.X) / (vb.X - va.X);  							float tmax = (neia[k * 2 + 1] - va.X) / (vb.X - va.X);    							if (tmin > tmax)  							{  								float temp = tmin;  								tmin = tmax;  								tmax = temp;  							}    							link.BMin = (int)(MathHelper.Clamp(tmin' 0.0f' 1.0f) * 255.0f);  							link.BMax = (int)(MathHelper.Clamp(tmax' 0.0f' 1.0f) * 255.0f);  						}  					}  				}  			}
Magic Number,SharpNav.Pathfinding,NavTile,C:\repos\Robmaister_SharpNav\Source\SharpNav\Pathfinding\NavTile.cs,ConnectExtLinks,The following statement contains a magic number: for (int i = 0; i < PolyCount; i++)  			{  				int numPolyVerts = Polys[i].VertCount;    				for (int j = 0; j < numPolyVerts; j++)  				{  					//Skip non-portal edges  					if ((Polys[i].Neis[j] & Link.External) == 0)  						continue;    					BoundarySide dir = (BoundarySide)(Polys[i].Neis[j] & 0xff);  					if (side != BoundarySide.Internal && dir != side)  						continue;    					//Create new links  					Vector3 va = Verts[Polys[i].Verts[j]];  					Vector3 vb = Verts[Polys[i].Verts[(j + 1) % numPolyVerts]];  					List<NavPolyId> nei = new List<NavPolyId>(4);  					List<float> neia = new List<float>(4 * 2);  					target.FindConnectingPolys(va' vb' dir.GetOpposite()' nei' neia);    					//Iterate through neighbors  					for (int k = 0; k < nei.Count; k++)  					{  						Link link = new Link();  						link.Reference = nei[k];  						link.Edge = j;  						link.Side = dir;  						Polys[i].Links.Add(link);    						//Compress portal limits to a value  						if (dir == BoundarySide.PlusX || dir == BoundarySide.MinusX)  						{  							float tmin = (neia[k * 2 + 0] - va.Z) / (vb.Z - va.Z);  							float tmax = (neia[k * 2 + 1] - va.Z) / (vb.Z - va.Z);    							if (tmin > tmax)  							{  								float temp = tmin;  								tmin = tmax;  								tmax = temp;  							}    							link.BMin = (int)(MathHelper.Clamp(tmin' 0.0f' 1.0f) * 255.0f);  							link.BMax = (int)(MathHelper.Clamp(tmax' 0.0f' 1.0f) * 255.0f);  						}  						else if (dir == BoundarySide.PlusZ || dir == BoundarySide.MinusZ)  						{  							float tmin = (neia[k * 2 + 0] - va.X) / (vb.X - va.X);  							float tmax = (neia[k * 2 + 1] - va.X) / (vb.X - va.X);    							if (tmin > tmax)  							{  								float temp = tmin;  								tmin = tmax;  								tmax = temp;  							}    							link.BMin = (int)(MathHelper.Clamp(tmin' 0.0f' 1.0f) * 255.0f);  							link.BMax = (int)(MathHelper.Clamp(tmax' 0.0f' 1.0f) * 255.0f);  						}  					}  				}  			}
Magic Number,SharpNav.Pathfinding,NavTile,C:\repos\Robmaister_SharpNav\Source\SharpNav\Pathfinding\NavTile.cs,ConnectExtLinks,The following statement contains a magic number: for (int i = 0; i < PolyCount; i++)  			{  				int numPolyVerts = Polys[i].VertCount;    				for (int j = 0; j < numPolyVerts; j++)  				{  					//Skip non-portal edges  					if ((Polys[i].Neis[j] & Link.External) == 0)  						continue;    					BoundarySide dir = (BoundarySide)(Polys[i].Neis[j] & 0xff);  					if (side != BoundarySide.Internal && dir != side)  						continue;    					//Create new links  					Vector3 va = Verts[Polys[i].Verts[j]];  					Vector3 vb = Verts[Polys[i].Verts[(j + 1) % numPolyVerts]];  					List<NavPolyId> nei = new List<NavPolyId>(4);  					List<float> neia = new List<float>(4 * 2);  					target.FindConnectingPolys(va' vb' dir.GetOpposite()' nei' neia);    					//Iterate through neighbors  					for (int k = 0; k < nei.Count; k++)  					{  						Link link = new Link();  						link.Reference = nei[k];  						link.Edge = j;  						link.Side = dir;  						Polys[i].Links.Add(link);    						//Compress portal limits to a value  						if (dir == BoundarySide.PlusX || dir == BoundarySide.MinusX)  						{  							float tmin = (neia[k * 2 + 0] - va.Z) / (vb.Z - va.Z);  							float tmax = (neia[k * 2 + 1] - va.Z) / (vb.Z - va.Z);    							if (tmin > tmax)  							{  								float temp = tmin;  								tmin = tmax;  								tmax = temp;  							}    							link.BMin = (int)(MathHelper.Clamp(tmin' 0.0f' 1.0f) * 255.0f);  							link.BMax = (int)(MathHelper.Clamp(tmax' 0.0f' 1.0f) * 255.0f);  						}  						else if (dir == BoundarySide.PlusZ || dir == BoundarySide.MinusZ)  						{  							float tmin = (neia[k * 2 + 0] - va.X) / (vb.X - va.X);  							float tmax = (neia[k * 2 + 1] - va.X) / (vb.X - va.X);    							if (tmin > tmax)  							{  								float temp = tmin;  								tmin = tmax;  								tmax = temp;  							}    							link.BMin = (int)(MathHelper.Clamp(tmin' 0.0f' 1.0f) * 255.0f);  							link.BMax = (int)(MathHelper.Clamp(tmax' 0.0f' 1.0f) * 255.0f);  						}  					}  				}  			}
Magic Number,SharpNav.Pathfinding,NavTile,C:\repos\Robmaister_SharpNav\Source\SharpNav\Pathfinding\NavTile.cs,ConnectExtLinks,The following statement contains a magic number: for (int i = 0; i < PolyCount; i++)  			{  				int numPolyVerts = Polys[i].VertCount;    				for (int j = 0; j < numPolyVerts; j++)  				{  					//Skip non-portal edges  					if ((Polys[i].Neis[j] & Link.External) == 0)  						continue;    					BoundarySide dir = (BoundarySide)(Polys[i].Neis[j] & 0xff);  					if (side != BoundarySide.Internal && dir != side)  						continue;    					//Create new links  					Vector3 va = Verts[Polys[i].Verts[j]];  					Vector3 vb = Verts[Polys[i].Verts[(j + 1) % numPolyVerts]];  					List<NavPolyId> nei = new List<NavPolyId>(4);  					List<float> neia = new List<float>(4 * 2);  					target.FindConnectingPolys(va' vb' dir.GetOpposite()' nei' neia);    					//Iterate through neighbors  					for (int k = 0; k < nei.Count; k++)  					{  						Link link = new Link();  						link.Reference = nei[k];  						link.Edge = j;  						link.Side = dir;  						Polys[i].Links.Add(link);    						//Compress portal limits to a value  						if (dir == BoundarySide.PlusX || dir == BoundarySide.MinusX)  						{  							float tmin = (neia[k * 2 + 0] - va.Z) / (vb.Z - va.Z);  							float tmax = (neia[k * 2 + 1] - va.Z) / (vb.Z - va.Z);    							if (tmin > tmax)  							{  								float temp = tmin;  								tmin = tmax;  								tmax = temp;  							}    							link.BMin = (int)(MathHelper.Clamp(tmin' 0.0f' 1.0f) * 255.0f);  							link.BMax = (int)(MathHelper.Clamp(tmax' 0.0f' 1.0f) * 255.0f);  						}  						else if (dir == BoundarySide.PlusZ || dir == BoundarySide.MinusZ)  						{  							float tmin = (neia[k * 2 + 0] - va.X) / (vb.X - va.X);  							float tmax = (neia[k * 2 + 1] - va.X) / (vb.X - va.X);    							if (tmin > tmax)  							{  								float temp = tmin;  								tmin = tmax;  								tmax = temp;  							}    							link.BMin = (int)(MathHelper.Clamp(tmin' 0.0f' 1.0f) * 255.0f);  							link.BMax = (int)(MathHelper.Clamp(tmax' 0.0f' 1.0f) * 255.0f);  						}  					}  				}  			}
Magic Number,SharpNav.Pathfinding,NavTile,C:\repos\Robmaister_SharpNav\Source\SharpNav\Pathfinding\NavTile.cs,ConnectExtLinks,The following statement contains a magic number: for (int i = 0; i < PolyCount; i++)  			{  				int numPolyVerts = Polys[i].VertCount;    				for (int j = 0; j < numPolyVerts; j++)  				{  					//Skip non-portal edges  					if ((Polys[i].Neis[j] & Link.External) == 0)  						continue;    					BoundarySide dir = (BoundarySide)(Polys[i].Neis[j] & 0xff);  					if (side != BoundarySide.Internal && dir != side)  						continue;    					//Create new links  					Vector3 va = Verts[Polys[i].Verts[j]];  					Vector3 vb = Verts[Polys[i].Verts[(j + 1) % numPolyVerts]];  					List<NavPolyId> nei = new List<NavPolyId>(4);  					List<float> neia = new List<float>(4 * 2);  					target.FindConnectingPolys(va' vb' dir.GetOpposite()' nei' neia);    					//Iterate through neighbors  					for (int k = 0; k < nei.Count; k++)  					{  						Link link = new Link();  						link.Reference = nei[k];  						link.Edge = j;  						link.Side = dir;  						Polys[i].Links.Add(link);    						//Compress portal limits to a value  						if (dir == BoundarySide.PlusX || dir == BoundarySide.MinusX)  						{  							float tmin = (neia[k * 2 + 0] - va.Z) / (vb.Z - va.Z);  							float tmax = (neia[k * 2 + 1] - va.Z) / (vb.Z - va.Z);    							if (tmin > tmax)  							{  								float temp = tmin;  								tmin = tmax;  								tmax = temp;  							}    							link.BMin = (int)(MathHelper.Clamp(tmin' 0.0f' 1.0f) * 255.0f);  							link.BMax = (int)(MathHelper.Clamp(tmax' 0.0f' 1.0f) * 255.0f);  						}  						else if (dir == BoundarySide.PlusZ || dir == BoundarySide.MinusZ)  						{  							float tmin = (neia[k * 2 + 0] - va.X) / (vb.X - va.X);  							float tmax = (neia[k * 2 + 1] - va.X) / (vb.X - va.X);    							if (tmin > tmax)  							{  								float temp = tmin;  								tmin = tmax;  								tmax = temp;  							}    							link.BMin = (int)(MathHelper.Clamp(tmin' 0.0f' 1.0f) * 255.0f);  							link.BMax = (int)(MathHelper.Clamp(tmax' 0.0f' 1.0f) * 255.0f);  						}  					}  				}  			}
Magic Number,SharpNav.Pathfinding,NavTile,C:\repos\Robmaister_SharpNav\Source\SharpNav\Pathfinding\NavTile.cs,ConnectExtLinks,The following statement contains a magic number: for (int i = 0; i < PolyCount; i++)  			{  				int numPolyVerts = Polys[i].VertCount;    				for (int j = 0; j < numPolyVerts; j++)  				{  					//Skip non-portal edges  					if ((Polys[i].Neis[j] & Link.External) == 0)  						continue;    					BoundarySide dir = (BoundarySide)(Polys[i].Neis[j] & 0xff);  					if (side != BoundarySide.Internal && dir != side)  						continue;    					//Create new links  					Vector3 va = Verts[Polys[i].Verts[j]];  					Vector3 vb = Verts[Polys[i].Verts[(j + 1) % numPolyVerts]];  					List<NavPolyId> nei = new List<NavPolyId>(4);  					List<float> neia = new List<float>(4 * 2);  					target.FindConnectingPolys(va' vb' dir.GetOpposite()' nei' neia);    					//Iterate through neighbors  					for (int k = 0; k < nei.Count; k++)  					{  						Link link = new Link();  						link.Reference = nei[k];  						link.Edge = j;  						link.Side = dir;  						Polys[i].Links.Add(link);    						//Compress portal limits to a value  						if (dir == BoundarySide.PlusX || dir == BoundarySide.MinusX)  						{  							float tmin = (neia[k * 2 + 0] - va.Z) / (vb.Z - va.Z);  							float tmax = (neia[k * 2 + 1] - va.Z) / (vb.Z - va.Z);    							if (tmin > tmax)  							{  								float temp = tmin;  								tmin = tmax;  								tmax = temp;  							}    							link.BMin = (int)(MathHelper.Clamp(tmin' 0.0f' 1.0f) * 255.0f);  							link.BMax = (int)(MathHelper.Clamp(tmax' 0.0f' 1.0f) * 255.0f);  						}  						else if (dir == BoundarySide.PlusZ || dir == BoundarySide.MinusZ)  						{  							float tmin = (neia[k * 2 + 0] - va.X) / (vb.X - va.X);  							float tmax = (neia[k * 2 + 1] - va.X) / (vb.X - va.X);    							if (tmin > tmax)  							{  								float temp = tmin;  								tmin = tmax;  								tmax = temp;  							}    							link.BMin = (int)(MathHelper.Clamp(tmin' 0.0f' 1.0f) * 255.0f);  							link.BMax = (int)(MathHelper.Clamp(tmax' 0.0f' 1.0f) * 255.0f);  						}  					}  				}  			}
Magic Number,SharpNav.Pathfinding,NavTile,C:\repos\Robmaister_SharpNav\Source\SharpNav\Pathfinding\NavTile.cs,ConnectExtLinks,The following statement contains a magic number: for (int i = 0; i < PolyCount; i++)  			{  				int numPolyVerts = Polys[i].VertCount;    				for (int j = 0; j < numPolyVerts; j++)  				{  					//Skip non-portal edges  					if ((Polys[i].Neis[j] & Link.External) == 0)  						continue;    					BoundarySide dir = (BoundarySide)(Polys[i].Neis[j] & 0xff);  					if (side != BoundarySide.Internal && dir != side)  						continue;    					//Create new links  					Vector3 va = Verts[Polys[i].Verts[j]];  					Vector3 vb = Verts[Polys[i].Verts[(j + 1) % numPolyVerts]];  					List<NavPolyId> nei = new List<NavPolyId>(4);  					List<float> neia = new List<float>(4 * 2);  					target.FindConnectingPolys(va' vb' dir.GetOpposite()' nei' neia);    					//Iterate through neighbors  					for (int k = 0; k < nei.Count; k++)  					{  						Link link = new Link();  						link.Reference = nei[k];  						link.Edge = j;  						link.Side = dir;  						Polys[i].Links.Add(link);    						//Compress portal limits to a value  						if (dir == BoundarySide.PlusX || dir == BoundarySide.MinusX)  						{  							float tmin = (neia[k * 2 + 0] - va.Z) / (vb.Z - va.Z);  							float tmax = (neia[k * 2 + 1] - va.Z) / (vb.Z - va.Z);    							if (tmin > tmax)  							{  								float temp = tmin;  								tmin = tmax;  								tmax = temp;  							}    							link.BMin = (int)(MathHelper.Clamp(tmin' 0.0f' 1.0f) * 255.0f);  							link.BMax = (int)(MathHelper.Clamp(tmax' 0.0f' 1.0f) * 255.0f);  						}  						else if (dir == BoundarySide.PlusZ || dir == BoundarySide.MinusZ)  						{  							float tmin = (neia[k * 2 + 0] - va.X) / (vb.X - va.X);  							float tmax = (neia[k * 2 + 1] - va.X) / (vb.X - va.X);    							if (tmin > tmax)  							{  								float temp = tmin;  								tmin = tmax;  								tmax = temp;  							}    							link.BMin = (int)(MathHelper.Clamp(tmin' 0.0f' 1.0f) * 255.0f);  							link.BMax = (int)(MathHelper.Clamp(tmax' 0.0f' 1.0f) * 255.0f);  						}  					}  				}  			}
Magic Number,SharpNav.Pathfinding,NavTile,C:\repos\Robmaister_SharpNav\Source\SharpNav\Pathfinding\NavTile.cs,FindNearestPoly,The following statement contains a magic number: List<NavPolyId> polys = new List<NavPolyId>(128);
Magic Number,SharpNav.Pathfinding,NavTile,C:\repos\Robmaister_SharpNav\Source\SharpNav\Pathfinding\NavTile.cs,OverlapSlabs,The following statement contains a magic number: float threshold = (py * 2) * (py * 2);
Magic Number,SharpNav.Pathfinding,NavTile,C:\repos\Robmaister_SharpNav\Source\SharpNav\Pathfinding\NavTile.cs,OverlapSlabs,The following statement contains a magic number: float threshold = (py * 2) * (py * 2);
Magic Number,SharpNav.Pathfinding,NavTile,C:\repos\Robmaister_SharpNav\Source\SharpNav\Pathfinding\NavTile.cs,ClosestHeight,The following statement contains a magic number: for (int j = 0; j < DetailMeshes[indexPoly].TriangleCount; j++)  			{  				PolyMeshDetail.TriangleData t = DetailTris[pd.TriangleIndex + j];  				Vector3[] v = new Vector3[3];    				for (int k = 0; k < 3; k++)  				{  					if (t[k] < poly.VertCount)  						v[k] = Verts[poly.Verts[t[k]]];  					else  						v[k] = DetailVerts[pd.VertexIndex + (t[k] - poly.VertCount)];  				}    				if (Distance.PointToTriangle(pos' v[0]' v[1]' v[2]' out h))  					return true;  			}
Magic Number,SharpNav.Pathfinding,NavTile,C:\repos\Robmaister_SharpNav\Source\SharpNav\Pathfinding\NavTile.cs,ClosestHeight,The following statement contains a magic number: for (int j = 0; j < DetailMeshes[indexPoly].TriangleCount; j++)  			{  				PolyMeshDetail.TriangleData t = DetailTris[pd.TriangleIndex + j];  				Vector3[] v = new Vector3[3];    				for (int k = 0; k < 3; k++)  				{  					if (t[k] < poly.VertCount)  						v[k] = Verts[poly.Verts[t[k]]];  					else  						v[k] = DetailVerts[pd.VertexIndex + (t[k] - poly.VertCount)];  				}    				if (Distance.PointToTriangle(pos' v[0]' v[1]' v[2]' out h))  					return true;  			}
Magic Number,SharpNav.Pathfinding,NavTile,C:\repos\Robmaister_SharpNav\Source\SharpNav\Pathfinding\NavTile.cs,ClosestHeight,The following statement contains a magic number: for (int j = 0; j < DetailMeshes[indexPoly].TriangleCount; j++)  			{  				PolyMeshDetail.TriangleData t = DetailTris[pd.TriangleIndex + j];  				Vector3[] v = new Vector3[3];    				for (int k = 0; k < 3; k++)  				{  					if (t[k] < poly.VertCount)  						v[k] = Verts[poly.Verts[t[k]]];  					else  						v[k] = DetailVerts[pd.VertexIndex + (t[k] - poly.VertCount)];  				}    				if (Distance.PointToTriangle(pos' v[0]' v[1]' v[2]' out h))  					return true;  			}
Magic Number,SharpNav.Pathfinding,NavTile,C:\repos\Robmaister_SharpNav\Source\SharpNav\Pathfinding\NavTile.cs,GetHashCode,The following statement contains a magic number: unchecked  			{  				int h1 = (int)2166136261;  				int h2 = (int)16777619;  				h1 = (h1 * h2) ^ Location.X;  				h1 = (h1 * h2) ^ Location.Y;  				h1 = (h1 * h2) ^ Layer;  				return h1;  			}
Magic Number,SharpNav.Pathfinding,NavTile,C:\repos\Robmaister_SharpNav\Source\SharpNav\Pathfinding\NavTile.cs,GetHashCode,The following statement contains a magic number: unchecked  			{  				int h1 = (int)2166136261;  				int h2 = (int)16777619;  				h1 = (h1 * h2) ^ Location.X;  				h1 = (h1 * h2) ^ Location.Y;  				h1 = (h1 * h2) ^ Layer;  				return h1;  			}
Magic Number,SharpNav.Pathfinding,Path,C:\repos\Robmaister_SharpNav\Source\SharpNav\Pathfinding\Path.cs,RemoveTrackbacks,The following statement contains a magic number: for (int i = 0; i < polys.Count; i++)  			{  				if (i - 1 >= 0 && i + 1 < polys.Count)  				{  					if (polys[i - 1] == polys[i + 1])  					{  						polys.RemoveRange(i - 1' 2);  						i -= 2;  					}  				}  			}
Magic Number,SharpNav.Pathfinding,Path,C:\repos\Robmaister_SharpNav\Source\SharpNav\Pathfinding\Path.cs,RemoveTrackbacks,The following statement contains a magic number: for (int i = 0; i < polys.Count; i++)  			{  				if (i - 1 >= 0 && i + 1 < polys.Count)  				{  					if (polys[i - 1] == polys[i + 1])  					{  						polys.RemoveRange(i - 1' 2);  						i -= 2;  					}  				}  			}
Magic Number,SharpNav.Pathfinding,PathfindingCommon,C:\repos\Robmaister_SharpNav\Source\SharpNav\Pathfinding\PathfindingCommon.cs,RandomPointInConvexPoly,The following statement contains a magic number: for (int i = 2; i < pts.Length; i++)  			{  				Triangle3.Area2D(ref pts[0]' ref pts[i - 1]' ref pts[i]' out area);  				areaSum += Math.Max(0.001f' area);  				areas[i] = area;  			}
Magic Number,SharpNav.Pathfinding,PathfindingCommon,C:\repos\Robmaister_SharpNav\Source\SharpNav\Pathfinding\PathfindingCommon.cs,RandomPointInConvexPoly,The following statement contains a magic number: for (int i = 2; i < pts.Length; i++)  			{  				float currentArea = areas[i];  				if (threshold >= accumulatedArea && threshold < (accumulatedArea + currentArea))  				{  					u = (threshold - accumulatedArea) / currentArea;  					triangleVertex = i;  					break;  				}    				accumulatedArea += currentArea;  			}
Missing Default,SharpNav,CompactHeightfield,C:\repos\Robmaister_SharpNav\Source\SharpNav\CompactHeightfield.cs,WalkContour,The following switch statement is missing a default case: switch (dir)  					{  						case Direction.West:  							pz++;  							break;  						case Direction.North:  							px++;  							pz++;  							break;  						case Direction.East:  							px++;  							break;  					}
Missing Default,SharpNav,TiledNavMesh,C:\repos\Robmaister_SharpNav\Source\SharpNav\TiledNavMesh.cs,GetNeighborTilesAt,The following switch statement is missing a default case: switch (side)  			{  				case BoundarySide.PlusX:  					nx++;  					break;    				case BoundarySide.PlusXPlusZ:  					nx++;  					ny++;  					break;    				case BoundarySide.PlusZ:  					ny++;  					break;    				case BoundarySide.MinusXPlusZ:  					nx--;  					ny++;  					break;    				case BoundarySide.MinusX:  					nx--;  					break;    				case BoundarySide.MinusXMinusZ:  					nx--;  					ny--;  					break;    				case BoundarySide.MinusZ:  					ny--;  					break;    				case BoundarySide.PlusXMinusZ:  					nx++;  					ny--;  					break;  			}
