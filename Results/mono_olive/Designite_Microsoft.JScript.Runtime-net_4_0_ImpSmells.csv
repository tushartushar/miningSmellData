Implementation smell,Namespace,Class,File,Method,Description
Long Method,Microsoft.JScript.Compiler,RowanGenerator,C:\research\architectureSmells\repos\mono_olive\class\Microsoft.JScript.Runtime\Microsoft.JScript.Compiler\RowanGenerator.cs,Generate,The method has 345 lines of code.
Long Method,Microsoft.JScript.Runtime.Hosting,JSTokenizerService,C:\research\architectureSmells\repos\mono_olive\class\Microsoft.JScript.Runtime\Microsoft.JScript.Compiler\JSTokenizerService.cs,GetCategory,The method has 131 lines of code.
Long Method,Microsoft.JScript.Runtime.Hosting,JSTokenizerService,C:\research\architectureSmells\repos\mono_olive\class\Microsoft.JScript.Runtime\Microsoft.JScript.Compiler\JSTokenizerService.cs,GetTrigger,The method has 128 lines of code.
Complex Method,Microsoft.JScript.Compiler,RowanGenerator,C:\research\architectureSmells\repos\mono_olive\class\Microsoft.JScript.Runtime\Microsoft.JScript.Compiler\RowanGenerator.cs,Generate,Cyclomatic complexity of the method is 73
Complex Method,Microsoft.JScript.Compiler,RowanGenerator,C:\research\architectureSmells\repos\mono_olive\class\Microsoft.JScript.Runtime\Microsoft.JScript.Compiler\RowanGenerator.cs,Generate,Cyclomatic complexity of the method is 22
Complex Method,Microsoft.JScript.Runtime.Hosting,JSTokenizerService,C:\research\architectureSmells\repos\mono_olive\class\Microsoft.JScript.Runtime\Microsoft.JScript.Compiler\JSTokenizerService.cs,GetCategory,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.JScript.Runtime.Types,JSObject,C:\research\architectureSmells\repos\mono_olive\class\Microsoft.JScript.Runtime\Microsoft.JScript.Runtime.Types\JSObject.cs,GetDefaultValue,Cyclomatic complexity of the method is 14
Long Parameter List,Microsoft.JScript.Runtime.Hosting,JSCompilerErrorSink,C:\research\architectureSmells\repos\mono_olive\class\Microsoft.JScript.Runtime\Microsoft.JScript.Runtime.Hosting\JSCompilerErrorSink.cs,Add,The method has 5 parameters. Parameters: sourceUnit' message' span' errorCode' severity
Long Parameter List,Microsoft.JScript.Runtime,JSContext,C:\research\architectureSmells\repos\mono_olive\class\Microsoft.JScript.Runtime\Microsoft.JScript.Runtime\JSContext.cs,CallWithArgsKeywordsTupleDict,The method has 6 parameters. Parameters: context' func' args' names' argsTuple' kwDict
Long Parameter List,Microsoft.JScript.Runtime.Types,ArgumentsObject,C:\research\architectureSmells\repos\mono_olive\class\Microsoft.JScript.Runtime\Microsoft.JScript.Runtime.Types\ArgumentsObject.cs,Create,The method has 5 parameters. Parameters: context' function' paramIds' dict' actualParameters
Long Parameter List,Microsoft.JScript.Runtime.Types,ArrayObject,C:\research\architectureSmells\repos\mono_olive\class\Microsoft.JScript.Runtime\Microsoft.JScript.Runtime.Types\ArrayObject.cs,SpliceSlowly,The method has 7 parameters. Parameters: context' start' deleteCount' args' outArray' oldLength' newLength
Long Parameter List,Microsoft.JScript.Runtime.Types,ArrayPrototype,C:\research\architectureSmells\repos\mono_olive\class\Microsoft.JScript.Runtime\Microsoft.JScript.Runtime.Types\ArrayPrototype.cs,splice,The method has 5 parameters. Parameters: context' thisob' start' deleteCnt' args
Long Parameter List,Microsoft.JScript.Runtime.Types,BuiltinFunctionObject,C:\research\architectureSmells\repos\mono_olive\class\Microsoft.JScript.Runtime\Microsoft.JScript.Runtime.Types\BuiltinFunctionObject.cs,MakeFunction,The method has 7 parameters. Parameters: context' name' method' argNames' hasContextParameter' hasThisParameter' hasParamsParameter
Long Parameter List,Microsoft.JScript.Runtime.Types,DateConstructor,C:\research\architectureSmells\repos\mono_olive\class\Microsoft.JScript.Runtime\Microsoft.JScript.Runtime.Types\DateConstructor.cs,UTC,The method has 7 parameters. Parameters: year' month' date' hours' minutes' seconds' ms
Long Parameter List,Microsoft.JScript.Runtime.Types,DatePrototype,C:\research\architectureSmells\repos\mono_olive\class\Microsoft.JScript.Runtime\Microsoft.JScript.Runtime.Types\DatePrototype.cs,setHours,The method has 5 parameters. Parameters: thisob' dhour' min' sec' msec
Long Parameter List,Microsoft.JScript.Runtime.Types,DatePrototype,C:\research\architectureSmells\repos\mono_olive\class\Microsoft.JScript.Runtime\Microsoft.JScript.Runtime.Types\DatePrototype.cs,setUTCHours,The method has 5 parameters. Parameters: thisob' dhour' min' sec' msec
Long Parameter List,Microsoft.JScript.Runtime.Types,FunctionObject,C:\research\architectureSmells\repos\mono_olive\class\Microsoft.JScript.Runtime\Microsoft.JScript.Runtime.Types\FunctionObject.cs,FunctionObject,The method has 5 parameters. Parameters: context' name' callTarget' argNames' isStandardConstructor
Long Parameter List,Microsoft.JScript.Runtime.Types,FunctionObject,C:\research\architectureSmells\repos\mono_olive\class\Microsoft.JScript.Runtime\Microsoft.JScript.Runtime.Types\FunctionObject.cs,MakeFunction,The method has 6 parameters. Parameters: context' name' target' argNames' isStandardConstructor' usesArguments
Long Parameter List,Microsoft.JScript.Runtime.Types,FunctionObject,C:\research\architectureSmells\repos\mono_olive\class\Microsoft.JScript.Runtime\Microsoft.JScript.Runtime.Types\FunctionObject.cs,MakeFunction,The method has 5 parameters. Parameters: context' name' target' argNames' isStandardConstructor
Long Parameter List,Microsoft.JScript.Runtime.Types,FunctionObjectWithRuntimeContext,C:\research\architectureSmells\repos\mono_olive\class\Microsoft.JScript.Runtime\Microsoft.JScript.Runtime.Types\FunctionObjectWithRuntimeContext.cs,FunctionObjectWithRuntimeContext,The method has 5 parameters. Parameters: context' name' callTarget' argNames' isStandardConstructor
Long Parameter List,Microsoft.JScript.Runtime.Types,FunctionObjectWithRuntimeContext,C:\research\architectureSmells\repos\mono_olive\class\Microsoft.JScript.Runtime\Microsoft.JScript.Runtime.Types\FunctionObjectWithRuntimeContext.cs,FunctionObjectWithRuntimeContext,The method has 6 parameters. Parameters: context' name' callTarget' argNames' isStandardConstructor' callWithRuntimeContext
Long Parameter List,Microsoft.JScript.Runtime.Types,FunctionObjectWithThis0,C:\research\architectureSmells\repos\mono_olive\class\Microsoft.JScript.Runtime\Microsoft.JScript.Runtime.Types\FunctionObjectWithThis0.cs,FunctionObjectWithThis0,The method has 5 parameters. Parameters: context' name' callTarget' argNames' isStandardConstructor
Long Parameter List,Microsoft.JScript.Runtime.Types,FunctionObjectWithThis1,C:\research\architectureSmells\repos\mono_olive\class\Microsoft.JScript.Runtime\Microsoft.JScript.Runtime.Types\FunctionObjectWithThis1.cs,FunctionObjectWithThis1,The method has 5 parameters. Parameters: context' name' callTarget' argNames' isStandardConstructor
Long Parameter List,Microsoft.JScript.Runtime.Types,FunctionObjectWithThis2,C:\research\architectureSmells\repos\mono_olive\class\Microsoft.JScript.Runtime\Microsoft.JScript.Runtime.Types\FunctionObjectWithThis2.cs,FunctionObjectWithThis2,The method has 5 parameters. Parameters: context' name' callTarget' argNames' isStandardConstructor
Long Parameter List,Microsoft.JScript.Runtime.Types,FunctionObjectWithThis3,C:\research\architectureSmells\repos\mono_olive\class\Microsoft.JScript.Runtime\Microsoft.JScript.Runtime.Types\FunctionObjectWithThis3.cs,FunctionObjectWithThis3,The method has 5 parameters. Parameters: context' name' callTarget' argNames' isStandardConstructor
Long Parameter List,Microsoft.JScript.Runtime.Types,FunctionObjectWithThis4,C:\research\architectureSmells\repos\mono_olive\class\Microsoft.JScript.Runtime\Microsoft.JScript.Runtime.Types\FunctionObjectWithThis4.cs,FunctionObjectWithThis4,The method has 5 parameters. Parameters: context' name' callTarget' argNames' isStandardConstructor
Long Parameter List,Microsoft.JScript.Runtime.Types,FunctionObjectWithThis5,C:\research\architectureSmells\repos\mono_olive\class\Microsoft.JScript.Runtime\Microsoft.JScript.Runtime.Types\FunctionObjectWithThis5.cs,FunctionObjectWithThis5,The method has 5 parameters. Parameters: context' name' callTarget' argNames' isStandardConstructor
Long Parameter List,Microsoft.JScript.Runtime.Types,FunctionObjectWithThis,C:\research\architectureSmells\repos\mono_olive\class\Microsoft.JScript.Runtime\Microsoft.JScript.Runtime.Types\FunctionObjectWithThis.cs,FunctionObjectWithThis,The method has 5 parameters. Parameters: context' name' callTarget' argNames' isStandardConstructor
Long Parameter List,Microsoft.JScript.Runtime.Types,RegExpConstructor,C:\research\architectureSmells\repos\mono_olive\class\Microsoft.JScript.Runtime\Microsoft.JScript.Runtime.Types\RegExpConstructor.cs,Construct,The method has 5 parameters. Parameters: context' pattern' ignoreCase' global' multiline
Long Statement,Microsoft.JScript.Compiler,Compiler,C:\research\architectureSmells\repos\mono_olive\class\Microsoft.JScript.Runtime\Microsoft.JScript.Compiler\Compiler.cs,CompileExpression,The length of the statement  "			RowanGenerator gen = new RowanGenerator (idmtable' idtable.InsertIdentifier("this")'  idtable.InsertIdentifier("arguments"));" is 125.
Long Statement,Microsoft.JScript.Compiler,Compiler,C:\research\architectureSmells\repos\mono_olive\class\Microsoft.JScript.Runtime\Microsoft.JScript.Compiler\Compiler.cs,CompileProgram,The length of the statement  "			RowanGenerator gen = new RowanGenerator (idmtable' idtable.InsertIdentifier ("this")' idtable.InsertIdentifier ("arguments"));" is 126.
Long Statement,Microsoft.JScript.Compiler,RowanGenerator,C:\research\architectureSmells\repos\mono_olive\class\Microsoft.JScript.Runtime\Microsoft.JScript.Compiler\RowanGenerator.cs,Generate,The length of the statement  "					result = SLE.Expression.Call (typeof (CompilerHelpers).GetMethod ("ConstructArrayFromArrayLiteral")' arguments.ToArray ());" is 123.
Long Statement,Microsoft.JScript.Compiler,RowanGenerator,C:\research\architectureSmells\repos\mono_olive\class\Microsoft.JScript.Runtime\Microsoft.JScript.Compiler\RowanGenerator.cs,Generate,The length of the statement  "					result = SLE.Expression.Action.GetMember (GetSymbolId (((MJCP.QualifiedExpression)Input).Qualifier)' null' arguments.ToArray());" is 128.
Long Statement,Microsoft.JScript.Compiler,RowanGenerator,C:\research\architectureSmells\repos\mono_olive\class\Microsoft.JScript.Runtime\Microsoft.JScript.Compiler\RowanGenerator.cs,Generate,The length of the statement  "					result = SLE.Expression.OrElse (Generate (((MJCP.BinaryOperatorExpression)Input).Left)' Generate (((MJCP.BinaryOperatorExpression)Input).Right));" is 145.
Long Statement,Microsoft.JScript.Compiler,RowanGenerator,C:\research\architectureSmells\repos\mono_olive\class\Microsoft.JScript.Runtime\Microsoft.JScript.Compiler\RowanGenerator.cs,Generate,The length of the statement  "					result = SLE.Expression.AndAlso (Generate (((MJCP.BinaryOperatorExpression)Input).Left)' Generate (((MJCP.BinaryOperatorExpression)Input).Right));" is 146.
Long Statement,Microsoft.JScript.Compiler,RowanGenerator,C:\research\architectureSmells\repos\mono_olive\class\Microsoft.JScript.Runtime\Microsoft.JScript.Compiler\RowanGenerator.cs,Generate,The length of the statement  "			DList<MJCP.Statement' MJCP.BlockStatement>.Iterator it = new DList<MJCP.Statement' MJCP.BlockStatement>.Iterator (Input);" is 121.
Long Statement,Microsoft.JScript.Compiler,RowanGenerator,C:\research\architectureSmells\repos\mono_olive\class\Microsoft.JScript.Runtime\Microsoft.JScript.Compiler\RowanGenerator.cs,GenerateBlockStatement,The length of the statement  "			DList<MJCP.Statement' MJCP.BlockStatement>.Iterator it = new DList<MJCP.Statement' MJCP.BlockStatement>.Iterator (blockStatement.Children);" is 139.
Long Statement,Microsoft.JScript.Compiler,RowanGenerator,C:\research\architectureSmells\repos\mono_olive\class\Microsoft.JScript.Runtime\Microsoft.JScript.Compiler\RowanGenerator.cs,GenerateSwitchStatement,The length of the statement  "			DList<MJCP.CaseClause' MJCP.SwitchStatement>.Iterator it = new DList<MJCP.CaseClause' MJCP.SwitchStatement>.Iterator (switchStatement.Cases);" is 141.
Long Statement,Microsoft.JScript.Compiler,RowanGenerator,C:\research\architectureSmells\repos\mono_olive\class\Microsoft.JScript.Runtime\Microsoft.JScript.Compiler\RowanGenerator.cs,GenerateSwitchStatement,The length of the statement  "					builder.Case ((int)((SLE.ConstantExpression)Generate(((MJCP.ValueCaseClause)it.Element).Value)).Value' Generate (it.Element.Children));" is 135.
Empty Catch Block,Microsoft.JScript.Compiler,RowanGenerator,C:\research\architectureSmells\repos\mono_olive\class\Microsoft.JScript.Runtime\Microsoft.JScript.Compiler\RowanGenerator.cs,Generate,The method has an empty catch block.
Magic Number,Microsoft.JScript.Runtime.Conversions,ConvertHelper,C:\research\architectureSmells\repos\mono_olive\class\Microsoft.JScript.Runtime\Microsoft.JScript.Runtime.Conversions\ConvertHelper.cs,ToInt32,The following statement contains a magic number: double ddd = Math.IEEERemainder(dd'(1 << 32));
Magic Number,Microsoft.JScript.Runtime.Conversions,ConvertHelper,C:\research\architectureSmells\repos\mono_olive\class\Microsoft.JScript.Runtime\Microsoft.JScript.Runtime.Conversions\ConvertHelper.cs,ToInt32,The following statement contains a magic number: return (int)(ddd - (1 << 32));
Magic Number,Microsoft.JScript.Runtime.Conversions,ConvertHelper,C:\research\architectureSmells\repos\mono_olive\class\Microsoft.JScript.Runtime\Microsoft.JScript.Runtime.Conversions\ConvertHelper.cs,ToInt32,The following statement contains a magic number: ddd >= (1 << 31)
Missing Default,Microsoft.JScript.Compiler,RowanGenerator,C:\research\architectureSmells\repos\mono_olive\class\Microsoft.JScript.Runtime\Microsoft.JScript.Compiler\RowanGenerator.cs,Generate,The following switch statement is missing a default case: switch (Input.Opcode) {  				case MJCP.Expression.Operation.SyntaxError : 					return null;//sample show null 				case MJCP.Expression.Operation.@this : 					//TODO this must not be a variable! 					if (withinFunction > 1)//if this is call inside a function 						result = SLE.Expression.Read (builder.CreateVariable (GetSymbolId(thisIdent)' SLE.Variable.VariableKind.Global' null)); 					else {//if this is call ouside of function 						arguments = new List<SLE.Expression> (); 						arguments.Add (SLE.Expression.CodeContext ()); 						result = SLE.Expression.Call (typeof (MJR.JSOps).GetMethod ("GetGlobalObject")' arguments.ToArray ()); 					} 					break; 				case MJCP.Expression.Operation.@false : 					result = SLE.Expression.False (); 					break; 				case MJCP.Expression.Operation.@true : 					result = SLE.Expression.True (); 					break; 				case MJCP.Expression.Operation.Identifier : 						Identifier id = ((MJCP.IdentifierExpression)Input).ID;//TODO make a tree of variable and allow to get it  						result = SLE.Expression.Read (builder.CreateVariable (GetSymbolId(id)' SLE.Variable.VariableKind.Global' null)); 						break; 				case MJCP.Expression.Operation.NumericLiteral : 					double val = 0; 					try { 						val = Double.Parse (((MJCP.NumericLiteralExpression)Input).Spelling); 						result = SLE.Expression.Constant (val); 					} catch { 						//TODO  					} 					break; 				case MJCP.Expression.Operation.HexLiteral : 					result = SLE.Expression.Constant (((MJCP.HexLiteralExpression)Input).Value); 					break; 				case MJCP.Expression.Operation.OctalLiteral : 					result = SLE.Expression.Constant (((MJCP.OctalLiteralExpression)Input).Value); 					break; 				case MJCP.Expression.Operation.RegularExpressionLiteral : 					//TODO 					throw new NotImplementedException (); 				case MJCP.Expression.Operation.StringLiteral : 					result = SLE.Expression.Constant (((MJCP.StringLiteralExpression)Input).Value); 					break; 				case MJCP.Expression.Operation.ArrayLiteral : 					arguments = new List<SLE.Expression> (); 					 					arguments.Add (SLE.Expression.CodeContext ());  					initializers =new List<SLE.Expression> (); 					foreach (MJCP.ExpressionListElement element in ((MJCP.ArrayLiteralExpression)Input).Elements) 							initializers.Add (Generate (element.Value)); 					arguments.Add (SLE.Expression.NewArray (typeof (object [])' initializers));  					result = SLE.Expression.Call (typeof (CompilerHelpers).GetMethod ("ConstructArrayFromArrayLiteral")' arguments.ToArray ()); 					break; 				case MJCP.Expression.Operation.ObjectLiteral : 					arguments = new List<SLE.Expression> ();  					arguments.Add (SLE.Expression.CodeContext ()); 					 					initializers = new List<SLE.Expression> (); 					List<SLE.Expression> initializers2 = new List<SLE.Expression> (); 					foreach (MJCP.ObjectLiteralElement element in ((MJCP.ObjectLiteralExpression)Input).Elements) { 						initializers.Add (Generate (element.Name)); 						initializers2.Add (Generate (element.Value)); 					} 					arguments.Add (SLE.Expression.NewArray (typeof (object[])' initializers)); 					arguments.Add (SLE.Expression.NewArray (typeof (object[])' initializers2));  					result = SLE.Expression.Call (typeof (CompilerHelpers).GetMethod ("ConstructObjectFromLiteral")' arguments.ToArray ()); 					break; 				case MJCP.Expression.Operation.Parenthesized : 					result = Generate (((MJCP.UnaryOperatorExpression)Input).Operand);  					break; 				case MJCP.Expression.Operation.Invocation : 					arguments = new List<SLE.Expression> (); 					//TODO fill arguments 					//args = new List<SLE.Arg> (); 					foreach (MJCP.ExpressionListElement element in ((MJCP.InvocationExpression)Input).Arguments.Arguments) 						arguments.Add (Generate (element.Value)); 					 					SLE.Expression instance = Generate (((MJCP.InvocationExpression)Input).Target); 					//(Expression instance') MethodInfo method' params Expression[] arguments 					//TODO MethodInfo! 					result = SLE.Expression.Call (instance' null' arguments.ToArray ()); 					break; 				case MJCP.Expression.Operation.Subscript : 					arguments = new List<SLE.Expression> (); 					//TODO fill arguments and type result 					result = SLE.Expression.Action.Operator (MSO.GetItem' null' arguments.ToArray()); 					break; 				case MJCP.Expression.Operation.Qualified : 					arguments = new List<SLE.Expression> (); 					//TODO fill arguments and type result 					result = SLE.Expression.Action.GetMember (GetSymbolId (((MJCP.QualifiedExpression)Input).Qualifier)' null' arguments.ToArray()); 					break; 				case MJCP.Expression.Operation.@new : 					SLE.Expression constructor = Generate (((MJCP.InvocationExpression)Input).Target); 					arguments = new List<SLE.Expression> (); 					foreach (MJCP.ExpressionListElement element in ((MJCP.InvocationExpression)Input).Arguments.Arguments) 						arguments.Add (Generate(element.Value)); 					//todo fill the type result 					result = SLE.Expression.Action.Create (null' arguments.ToArray()); 					break; 				case MJCP.Expression.Operation.Function : 					result = GenerateFunction (((MJCP.FunctionExpression)Input).Function); 					//the statement and expression is not the same 					result = SLE.Expression.Assign (GetVar (((MJCP.FunctionExpression)Input).Function.Name)' result); 					break; 				case MJCP.Expression.Operation.delete : 					arguments = new List<SLE.Expression> (); 					//TODO fill arguments 					result = SLE.Expression.Call (typeof (CompilerHelpers).GetMethod ("Delete")' arguments.ToArray ()); 					break; 				case MJCP.Expression.Operation.@void : 					arguments = new List<SLE.Expression> (); 					//TODO fill arguments 					result = SLE.Expression.Call (typeof (CompilerHelpers).GetMethod ("Void")' arguments.ToArray ()); 					break; 				case MJCP.Expression.Operation.@typeof : 					arguments = new List<SLE.Expression> (); 					//TODO fill arguments 					result = SLE.Expression.Call (typeof (CompilerHelpers).GetMethod ("TypeOf")' arguments.ToArray ()); 					break; 				case MJCP.Expression.Operation.PrefixPlusPlus : 					// 					break; 				case MJCP.Expression.Operation.PrefixMinusMinus : 					// 					break; 				case MJCP.Expression.Operation.PrefixPlus : 					arguments = new List<SLE.Expression> (); 					//TODO fill arguments 					result = SLE.Expression.Call (typeof (CompilerHelpers).GetMethod ("Positive")' arguments.ToArray()); 					break; 				case MJCP.Expression.Operation.PrefixMinus : 					arguments = new List<SLE.Expression> (); 					//TODO fill arguments 					result = SLE.Expression.Call (typeof (CompilerHelpers).GetMethod ("Negate")' arguments.ToArray()); 					break; 				case MJCP.Expression.Operation.Tilda : 					arguments = new List<SLE.Expression> (); 					//TODO fill arguments 					result = SLE.Expression.Call (typeof (CompilerHelpers).GetMethod ("OnesComplement")' arguments.ToArray()); 					break; 				case MJCP.Expression.Operation.Bang : 					arguments = new List<SLE.Expression> (); 					//TODO fill arguments 					result = SLE.Expression.Call (typeof (CompilerHelpers).GetMethod ("Not")' arguments.ToArray()); 					break; 				case MJCP.Expression.Operation.PostfixPlusPlus : 					//TODO 					break; 				case MJCP.Expression.Operation.PostfixMinusMinus : 					MJCP.UnaryOperatorExpression expr = (MJCP.UnaryOperatorExpression)Input; 					//TODO 					break; 				case MJCP.Expression.Operation.Comma : 					binOp = (MJCP.BinaryOperatorExpression)Input; 					arguments = new List<SLE.Expression> (); 					arguments.Add (Generate (binOp.Left)); 					arguments.Add (Generate (binOp.Right)); 					result = SLE.Expression.Comma (arguments); 					break; 				case MJCP.Expression.Operation.Equal : 					binOp = (MJCP.BinaryOperatorExpression)Input; 					result = GenerateBoundAssignment (binOp.Left' binOp.Right); 					break; 				case MJCP.Expression.Operation.StarEqual : 					binOp = (MJCP.BinaryOperatorExpression)Input; 					right = SLE.Expression.Multiply (Generate(binOp.Left)' Generate(binOp.Right)); 					result = GenerateBoundAssignment (binOp.Left' right); 					break; 				case MJCP.Expression.Operation.DivideEqual : 					binOp = (MJCP.BinaryOperatorExpression)Input; 					right = SLE.Expression.Multiply (Generate(binOp.Left)' Generate(binOp.Right)); 					result = GenerateBoundAssignment (binOp.Left' right); 					break; 				case MJCP.Expression.Operation.PercentEqual : 					binOp = (MJCP.BinaryOperatorExpression)Input; 					right = SLE.Expression.Modulo (Generate(binOp.Left)' Generate(binOp.Right)); 					result = GenerateBoundAssignment (binOp.Left' right); 					break; 				case MJCP.Expression.Operation.PlusEqual : 					binOp = (MJCP.BinaryOperatorExpression)Input; 					right = SLE.Expression.Add (Generate(binOp.Left)' Generate(binOp.Right)); 					result = GenerateBoundAssignment (binOp.Left' right); 					break; 				case MJCP.Expression.Operation.MinusEqual: 					binOp = (MJCP.BinaryOperatorExpression)Input; 					right = SLE.Expression.Subtract (Generate(binOp.Left)' Generate(binOp.Right)); 					result = GenerateBoundAssignment (binOp.Left' right); 					break; 				case MJCP.Expression.Operation.LessLessEqual: 					binOp = (MJCP.BinaryOperatorExpression)Input; 					right = SLE.Expression.LeftShift (Generate(binOp.Left)' Generate(binOp.Right)); 					result = GenerateBoundAssignment (binOp.Left' right); 					break; 				case MJCP.Expression.Operation.GreaterGreaterEqual: 					binOp = (MJCP.BinaryOperatorExpression)Input; 					right = SLE.Expression.RightShift (Generate(binOp.Left)' Generate(binOp.Right)); 					result = GenerateBoundAssignment (binOp.Left' right); 					break; 				case MJCP.Expression.Operation.GreaterGreaterGreaterEqual: 					binOp = (MJCP.BinaryOperatorExpression)Input;//TODO right shift unsigned 					right = SLE.Expression.RightShift (Generate(binOp.Left)' Generate(binOp.Right)); 					result = GenerateBoundAssignment (binOp.Left' right); 					break; 				case MJCP.Expression.Operation.AmpersandEqual: 					binOp = (MJCP.BinaryOperatorExpression)Input; 					right = SLE.Expression.And (Generate(binOp.Left)' Generate(binOp.Right)); 					result = GenerateBoundAssignment (binOp.Left' right); 					break; 				case MJCP.Expression.Operation.CircumflexEqual: 					binOp = (MJCP.BinaryOperatorExpression)Input; 					right = SLE.Expression.ExclusiveOr (Generate(binOp.Left)' Generate(binOp.Right)); 					result = GenerateBoundAssignment (binOp.Left' right); 					break; 				case MJCP.Expression.Operation.BarEqual: 					binOp = (MJCP.BinaryOperatorExpression)Input; 					right = SLE.Expression.Or (Generate(binOp.Left)' Generate(binOp.Right)); 					result = GenerateBoundAssignment (binOp.Left' right); 					break; 				case MJCP.Expression.Operation.BarBar : 					result = SLE.Expression.OrElse (Generate (((MJCP.BinaryOperatorExpression)Input).Left)' Generate (((MJCP.BinaryOperatorExpression)Input).Right)); 					break; 				case MJCP.Expression.Operation.AmpersandAmpersand : 					result = SLE.Expression.AndAlso (Generate (((MJCP.BinaryOperatorExpression)Input).Left)' Generate (((MJCP.BinaryOperatorExpression)Input).Right)); 					break; 				case MJCP.Expression.Operation.Bar: 					binOp = (MJCP.BinaryOperatorExpression)Input; 					result = SLE.Expression.Or (Generate(binOp.Left)' Generate(binOp.Right)); 					break; 				case MJCP.Expression.Operation.Circumflex: 					binOp = (MJCP.BinaryOperatorExpression)Input; 					result = SLE.Expression.ExclusiveOr (Generate(binOp.Left)' Generate(binOp.Right)); 					break; 				case MJCP.Expression.Operation.Ampersand: 					binOp = (MJCP.BinaryOperatorExpression)Input; 					result = SLE.Expression.And (Generate(binOp.Left)' Generate(binOp.Right)); 					break; 				case MJCP.Expression.Operation.EqualEqual: 					binOp = (MJCP.BinaryOperatorExpression)Input; 					result = SLE.Expression.Equal (Generate(binOp.Left)' Generate(binOp.Right)); 					break; 				case MJCP.Expression.Operation.BangEqual: 					binOp = (MJCP.BinaryOperatorExpression)Input; 					result = SLE.Expression.NotEqual (Generate(binOp.Left)' Generate(binOp.Right)); 					break; 				case MJCP.Expression.Operation.EqualEqualEqual: 					arguments = new List<SLE.Expression> (); 					//TODO fill arguments 					result = SLE.Expression.Call (typeof (CompilerHelpers).GetMethod ("Is")' arguments.ToArray()); 					break; 				case MJCP.Expression.Operation.BangEqualEqual: 					arguments = new List<SLE.Expression> (); 					//TODO fill arguments 					result = SLE.Expression.Call (typeof (CompilerHelpers).GetMethod ("IsNot")' arguments.ToArray()); 					break; 				case MJCP.Expression.Operation.Less: 					binOp = (MJCP.BinaryOperatorExpression)Input; 					result = SLE.Expression.LessThan (Generate(binOp.Left)' Generate(binOp.Right)); 					break; 				case MJCP.Expression.Operation.Greater: 					binOp = (MJCP.BinaryOperatorExpression)Input; 					result = SLE.Expression.GreaterThan (Generate(binOp.Left)' Generate(binOp.Right)); 					break; 				case MJCP.Expression.Operation.LessEqual: 					binOp = (MJCP.BinaryOperatorExpression)Input; 					result = SLE.Expression.LessThanEquals (Generate(binOp.Left)' Generate(binOp.Right)); 					break; 				case MJCP.Expression.Operation.GreaterEqual: 					binOp = (MJCP.BinaryOperatorExpression)Input; 					result = SLE.Expression.GreaterThanEquals (Generate(binOp.Left)' Generate(binOp.Right)); 					break; 				case MJCP.Expression.Operation.instanceof: 					arguments = new List<SLE.Expression> (); 					//TODO fill arguments 					result = SLE.Expression.Call (typeof (CompilerHelpers).GetMethod ("InstanceOf")' arguments.ToArray()); 					break; 				case MJCP.Expression.Operation.@in: 					arguments = new List<SLE.Expression> (); 					//TODO fill arguments 					result = SLE.Expression.Call (typeof (CompilerHelpers).GetMethod ("In")' arguments.ToArray()); 					break; 				case MJCP.Expression.Operation.LessLess: 					binOp = (MJCP.BinaryOperatorExpression)Input; 					result = SLE.Expression.LeftShift (Generate(binOp.Left)' Generate(binOp.Right)); 					break; 				case MJCP.Expression.Operation.GreaterGreater: 					binOp = (MJCP.BinaryOperatorExpression)Input; 					result = SLE.Expression.RightShift (Generate(binOp.Left)' Generate(binOp.Right)); 					break; 				case MJCP.Expression.Operation.GreaterGreaterGreater: 					arguments = new List<SLE.Expression> (); 					arguments.Add (Generate (((MJCP.BinaryOperatorExpression)Input).Left)); 					arguments.Add (Generate (((MJCP.BinaryOperatorExpression)Input).Right)); 					//TODO type result 					result = SLE.Expression.Action.Operator (MSO.RightShiftUnsigned' null' arguments.ToArray()); 					break; 				case MJCP.Expression.Operation.Plus: 					binOp = (MJCP.BinaryOperatorExpression)Input; 					result = SLE.Expression.Add (Generate(binOp.Left)' Generate(binOp.Right)); 					break; 				case MJCP.Expression.Operation.Minus: 					binOp = (MJCP.BinaryOperatorExpression)Input; 					result = SLE.Expression.Subtract (Generate(binOp.Left)' Generate(binOp.Right)); 					break; 				case MJCP.Expression.Operation.Star: 					binOp = (MJCP.BinaryOperatorExpression)Input; 					result = SLE.Expression.Multiply (Generate(binOp.Left)' Generate(binOp.Right)); 					break; 				case MJCP.Expression.Operation.Divide: 					binOp = (MJCP.BinaryOperatorExpression)Input; 					result = SLE.Expression.Divide (Generate(binOp.Left)' Generate(binOp.Right)); 					break; 				case MJCP.Expression.Operation.Percent: 					binOp = (MJCP.BinaryOperatorExpression)Input; 					result = SLE.Expression.Modulo (Generate(binOp.Left)' Generate(binOp.Right)); 					break; 				case MJCP.Expression.Operation.Question: 					result = SLE.Expression.Condition (Generate (((MJCP.TernaryOperatorExpression)Input).First)' 						Generate (((MJCP.TernaryOperatorExpression)Input).Second)' 						Generate (((MJCP.TernaryOperatorExpression)Input).Third)); 					break; 				case MJCP.Expression.Operation.@null: 					result = SLE.Expression.Null (); 					break; 			}
Missing Default,Microsoft.JScript.Runtime.Hosting,JSTokenizerService,C:\research\architectureSmells\repos\mono_olive\class\Microsoft.JScript.Runtime\Microsoft.JScript.Compiler\JSTokenizerService.cs,GetCategory,The following switch statement is missing a default case: switch (type) {				  				case Token.Type.None:  				case Token.Type.final:  				case Token.Type.OctalIntegerLiteral:  				case Token.Type.HexIntegerLiteral:  					return TokenCategory.None;  				case Token.Type.EndOfInput:  					return TokenCategory.EndOfStream;  				case Token.Type.LeftBrace:  				case Token.Type.RightBrace:  				case Token.Type.LeftParenthesis:  				case Token.Type.RightParenthesis:  				case Token.Type.LeftBracket:  				case Token.Type.RightBracket:  				case Token.Type.Dot:  				case Token.Type.Semicolon:  				case Token.Type.Comma:  					return TokenCategory.Delimiter;  				case Token.Type.Less:  				case Token.Type.Greater:  				case Token.Type.LessEqual:  				case Token.Type.GreaterEqual:  				case Token.Type.EqualEqual:  				case Token.Type.BangEqual:  				case Token.Type.EqualEqualEqual:  				case Token.Type.BangEqualEqual:  				case Token.Type.Plus:  				case Token.Type.Minus:  				case Token.Type.Star:  				case Token.Type.Percent:  				case Token.Type.PlusPlus:  				case Token.Type.MinusMinus:  				case Token.Type.LessLess:  				case Token.Type.GreaterGreater:  				case Token.Type.GreaterGreaterGreater:  				case Token.Type.Ampersand:  				case Token.Type.Bar:  				case Token.Type.Circumflex:  				case Token.Type.Bang:  				case Token.Type.Tilda:  				case Token.Type.AmpersandAmpersand:  				case Token.Type.BarBar:  				case Token.Type.Question:  				case Token.Type.Colon:  				case Token.Type.Equal:  				case Token.Type.PlusEqual:  				case Token.Type.MinusEqual:  				case Token.Type.StarEqual:  				case Token.Type.PercentEqual:  				case Token.Type.LessLessEqual:  				case Token.Type.GreaterGreaterEqual:  				case Token.Type.GreaterGreaterGreaterEqual:  				case Token.Type.AmpersandEqual:  				case Token.Type.BarEqual:  				case Token.Type.CircumflexEqual:  				case Token.Type.Divide:  				case Token.Type.DivideEqual:  					return TokenCategory.Operator;  				case Token.Type.@break:  				case Token.Type.@else:  				case Token.Type.@new:  				case Token.Type.var:  				case Token.Type.@case:  				case Token.Type.@finally:  				case Token.Type.@return:  				case Token.Type.@void:  				case Token.Type.@catch:  				case Token.Type.@for:  				case Token.Type.@switch:  				case Token.Type.@while:  				case Token.Type.@continue:  				case Token.Type.function:  				case Token.Type.@this:  				case Token.Type.with:  				case Token.Type.@default:  				case Token.Type.@if:  				case Token.Type.@throw:  				case Token.Type.delete:	  				case Token.Type.@in:	  				case Token.Type.@try:	  				case Token.Type.@do:	  				case Token.Type.instanceof:	  				case Token.Type.@typeof:	  				case Token.Type.@abstract:	  				case Token.Type.@enum:	  				case Token.Type.@int:	  				case Token.Type.@short:	  				case Token.Type.boolean:	  				case Token.Type.export:	  				case Token.Type.@interface:	  				case Token.Type.@static:	  				case Token.Type.@byte:	  				case Token.Type.extends:	  				case Token.Type.@long:	  				case Token.Type.super:	  				case Token.Type.@char:	  				case Token.Type.native:	  				case Token.Type.synchronized:	  				case Token.Type.@class:	  				case Token.Type.@float:	  				case Token.Type.packate:	  				case Token.Type.throws:	  				case Token.Type.@const:	  				case Token.Type.@goto:	  				case Token.Type.@private:	  				case Token.Type.transient:	  				case Token.Type.debugger:	  				case Token.Type.implements:	  				case Token.Type.@protected:	  				case Token.Type.@volatile:	  				case Token.Type.@double:	  				case Token.Type.import:	  				case Token.Type.@public:	  				case Token.Type.@null:	  				case Token.Type.@true:	  				case Token.Type.@false:  					return TokenCategory.Keyword;  				case Token.Type.NumericLiteral:  					return TokenCategory.NumericLiteral;  				case Token.Type.StringLiteral:  					return TokenCategory.StringLiteral;  				case Token.Type.RegularExpressionLiteral:  					return TokenCategory.RegularExpressionLiteral;  				case Token.Type.Identifier:  					return TokenCategory.Identifier;  				case Token.Type.Bad:  					return TokenCategory.Error;  			}
Missing Default,Microsoft.JScript.Runtime.Hosting,JSTokenizerService,C:\research\architectureSmells\repos\mono_olive\class\Microsoft.JScript.Runtime\Microsoft.JScript.Compiler\JSTokenizerService.cs,GetTrigger,The following switch statement is missing a default case: switch (type) {  				case Token.Type.LeftBrace:  				case Token.Type.RightBrace:  				case Token.Type.LeftBracket:  				case Token.Type.RightBracket:  					return TokenTriggers.MatchBraces;  				case Token.Type.LeftParenthesis:  					return TokenTriggers.MatchBraces | TokenTriggers.ParameterStart;  				case Token.Type.RightParenthesis:  					return TokenTriggers.MatchBraces | TokenTriggers.ParameterEnd ;  				case Token.Type.Dot:  					return TokenTriggers.MemberSelect;  				case Token.Type.Comma:  					return TokenTriggers.ParameterNext;  				//TODO : not found where we can use TokenTriggers.Parameter  				case Token.Type.None:  				case Token.Type.EndOfInput:  				case Token.Type.Semicolon:  				case Token.Type.Less:  				case Token.Type.Greater:  				case Token.Type.LessEqual:  				case Token.Type.GreaterEqual:  				case Token.Type.EqualEqual:  				case Token.Type.BangEqual:  				case Token.Type.EqualEqualEqual:  				case Token.Type.BangEqualEqual:  				case Token.Type.Plus:  				case Token.Type.Minus:  				case Token.Type.Star:  				case Token.Type.Percent:  				case Token.Type.PlusPlus:  				case Token.Type.MinusMinus:  				case Token.Type.LessLess:  				case Token.Type.GreaterGreater:  				case Token.Type.GreaterGreaterGreater:  				case Token.Type.Ampersand:  				case Token.Type.Bar:  				case Token.Type.Circumflex:  				case Token.Type.Bang:  				case Token.Type.Tilda:  				case Token.Type.AmpersandAmpersand:  				case Token.Type.BarBar:  				case Token.Type.Question:  				case Token.Type.Colon:  				case Token.Type.Equal:  				case Token.Type.PlusEqual:  				case Token.Type.MinusEqual:  				case Token.Type.StarEqual:  				case Token.Type.PercentEqual:  				case Token.Type.LessLessEqual:  				case Token.Type.GreaterGreaterEqual:  				case Token.Type.GreaterGreaterGreaterEqual:  				case Token.Type.AmpersandEqual:  				case Token.Type.BarEqual:  				case Token.Type.CircumflexEqual:  				case Token.Type.Divide:  				case Token.Type.DivideEqual:  				case Token.Type.@break:  				case Token.Type.@else:  				case Token.Type.@new:  				case Token.Type.var:  				case Token.Type.@case:  				case Token.Type.@finally:  				case Token.Type.@return:  				case Token.Type.@void:  				case Token.Type.@catch:  				case Token.Type.@for:  				case Token.Type.@switch:  				case Token.Type.@while:  				case Token.Type.@continue:  				case Token.Type.function:  				case Token.Type.@this:  				case Token.Type.with:  				case Token.Type.@default:  				case Token.Type.@if:  				case Token.Type.@throw:  				case Token.Type.delete:  				case Token.Type.@in:  				case Token.Type.@try:  				case Token.Type.@do:  				case Token.Type.instanceof:  				case Token.Type.@typeof:  				case Token.Type.@abstract:  				case Token.Type.@enum:  				case Token.Type.@int:  				case Token.Type.@short:  				case Token.Type.boolean:  				case Token.Type.export:  				case Token.Type.@interface:  				case Token.Type.@static:  				case Token.Type.@byte:  				case Token.Type.extends:  				case Token.Type.@long:  				case Token.Type.super:  				case Token.Type.@char:  				case Token.Type.final:  				case Token.Type.native:  				case Token.Type.synchronized:  				case Token.Type.@class:  				case Token.Type.@float:  				case Token.Type.packate:  				case Token.Type.throws:  				case Token.Type.@const:  				case Token.Type.@goto:  				case Token.Type.@private:  				case Token.Type.transient:  				case Token.Type.debugger:  				case Token.Type.implements:  				case Token.Type.@protected:  				case Token.Type.@volatile:  				case Token.Type.@double:  				case Token.Type.import:  				case Token.Type.@public:  				case Token.Type.@null:  				case Token.Type.@true:  				case Token.Type.@false:  				case Token.Type.NumericLiteral:  				case Token.Type.HexIntegerLiteral:  				case Token.Type.OctalIntegerLiteral:  				case Token.Type.StringLiteral:  				case Token.Type.RegularExpressionLiteral:  				case Token.Type.Identifier:  				case Token.Type.Bad:  					return TokenTriggers.None;  			}
Missing Default,Microsoft.JScript.Runtime.Conversions,ConvertHelper,C:\research\architectureSmells\repos\mono_olive\class\Microsoft.JScript.Runtime\Microsoft.JScript.Runtime.Conversions\ConvertHelper.cs,ToBoolean,The following switch statement is missing a default case: switch (preferredType) { 					//undefined & null 				case TypeCode.Empty: 				case TypeCode.DBNull: 					return false;  				case TypeCode.Boolean: 					return convertible.ToBoolean (null);  				case TypeCode.Byte: 				case TypeCode.Char: 				case TypeCode.Decimal: 				case TypeCode.Double: 				case TypeCode.Int16: 				case TypeCode.Int32: 				case TypeCode.Int64: 				case TypeCode.SByte: 				case TypeCode.Single: 				case TypeCode.UInt16: 				case TypeCode.UInt32: 				case TypeCode.UInt64: 					double d = convertible.ToDouble (null); 					return ((d != 0.0) && !double.IsNaN (d)); 				case TypeCode.String: 					string str = convertible.ToString (); 					return str.Length != 0; 				case TypeCode.Object: 					return true;  				//TODO datetime find behaviour maybe as a number 				case TypeCode.DateTime: 					return true; 								 			}
Missing Default,Microsoft.JScript.Runtime.Conversions,ConvertHelper,C:\research\architectureSmells\repos\mono_olive\class\Microsoft.JScript.Runtime\Microsoft.JScript.Runtime.Conversions\ConvertHelper.cs,ToNumber,The following switch statement is missing a default case: switch (preferredType) { 				case TypeCode.Empty: 					return double.NaN; 				case TypeCode.DBNull: 					return 0; 				case TypeCode.Boolean: 					return (convertible.ToBoolean (null) ? 1 : 0); 					//TODO here 				/*case TypeCode.String: 				case TypeCode.Decimal: 				case TypeCode.Double: 				case TypeCode.Single: 					*/ 				case TypeCode.Byte: 				case TypeCode.Char: 				case TypeCode.Int16: 				case TypeCode.Int32: 				case TypeCode.Int64: 				case TypeCode.SByte: 				case TypeCode.UInt16: 				case TypeCode.UInt32: 				case TypeCode.UInt64: 					return (double)value;  				case TypeCode.Object: 					return ToNumber(ToPrimitive (value' TypeCode.Double)); 				//case TypeCode.DateTime:  			}
Missing Default,Microsoft.JScript.Runtime.Conversions,ConvertHelper,C:\research\architectureSmells\repos\mono_olive\class\Microsoft.JScript.Runtime\Microsoft.JScript.Runtime.Conversions\ConvertHelper.cs,ToObject,The following switch statement is missing a default case: switch (preferredType) { 				case TypeCode.Empty: 				case TypeCode.DBNull: 					throw new TypeErrorException();  				case TypeCode.Boolean: 					return new JSBooleanObject (null' convertible.ToBoolean (null));  				case TypeCode.String: 					return new JSStringObject (null' convertible.ToString ());  				case TypeCode.Object: 					return value;  				//case TypeCode.DateTime:  				case TypeCode.Byte: 				case TypeCode.Char: 				case TypeCode.Decimal: 				case TypeCode.Double: 				case TypeCode.Int16: 				case TypeCode.Int32: 				case TypeCode.Int64: 				case TypeCode.SByte: 				case TypeCode.Single: 				case TypeCode.UInt16: 				case TypeCode.UInt32: 				case TypeCode.UInt64: 					return new JSNumberObject (null' convertible.ToDouble (null)); 			}
