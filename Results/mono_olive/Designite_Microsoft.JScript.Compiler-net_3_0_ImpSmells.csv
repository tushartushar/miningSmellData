Implementation smell,Namespace,Class,File,Method,Description
Long Method,Microsoft.JScript.Compiler,Tokenizer,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler\Tokenizer.cs,GetNext,The method has 255 lines of code.
Long Parameter List,Microsoft.JScript.Compiler.Tokens,BadToken,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler.Tokens\BadToken.cs,BadToken,The method has 6 parameters. Parameters: Spelling' Diagnostic' StartCharacterPosition' StartLine' StartColumn' FirstOnLine
Long Parameter List,Microsoft.JScript.Compiler.Tokens,HexIntegerLiteralToken,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler.Tokens\HexIntegerLiteralToken.cs,HexIntegerLiteralToken,The method has 6 parameters. Parameters: Spelling' Value' StartCharacterPosition' StartLine' StartColumn' FirstOnLine
Long Parameter List,Microsoft.JScript.Compiler.Tokens,IdentifierToken,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler.Tokens\IdentifierToken.cs,IdentifierToken,The method has 7 parameters. Parameters: Spelling' Width' Kind' StartCharacterPosition' StartLine' StartColumn' FirstOnLine
Long Parameter List,Microsoft.JScript.Compiler.Tokens,NumericLiteralToken,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler.Tokens\NumericLiteralToken.cs,NumericLiteralToken,The method has 5 parameters. Parameters: Spelling' StartCharacterPosition' StartLine' StartColumn' FirstOnLine
Long Parameter List,Microsoft.JScript.Compiler.Tokens,OctalIntegerLiteralToken,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler.Tokens\OctalIntegerLiteralToken.cs,OctalIntegerLiteralToken,The method has 6 parameters. Parameters: Spelling' Value' StartCharacterPosition' StartLine' StartColumn' FirstOnLine
Long Parameter List,Microsoft.JScript.Compiler.Tokens,RegularExpressionLiteralToken,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler.Tokens\RegularExpressionLiteralToken.cs,RegularExpressionLiteralToken,The method has 7 parameters. Parameters: BodySpelling' FlagsSpelling' Width' StartCharacterPosition' StartLine' StartColumn' FirstOnLine
Long Parameter List,Microsoft.JScript.Compiler.Tokens,StringLiteralToken,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler.Tokens\StringLiteralToken.cs,StringLiteralToken,The method has 6 parameters. Parameters: Spelling' Value' StartCharacterPosition' StartLine' StartColumn' FirstOnLine
Long Parameter List,Microsoft.JScript.Compiler.Tokens,Token,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler.Tokens\Token.cs,Token,The method has 5 parameters. Parameters: Kind' StartPosition' StartLine' StartColumn' FirstOnLine
Long Parameter List,Microsoft.JScript.Compiler,TextSpan,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler\TextSpan.cs,TextSpan,The method has 6 parameters. Parameters: StartLine' StartColumn' EndLine' EndColumn' StartPosition' EndPosition
Long Parameter List,Microsoft.JScript.Compiler.ParseTree,BinaryOperatorExpression,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler.ParseTree\BinaryOperatorExpression.cs,BinaryOperatorExpression,The method has 5 parameters. Parameters: Left' Right' Opcode' Location' OperatorLocation
Long Parameter List,Microsoft.JScript.Compiler.ParseTree,CatchClause,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler.ParseTree\CatchClause.cs,CatchClause,The method has 6 parameters. Parameters: Name' Handler' Location' NameLocation' LeftParen' RightParen
Long Parameter List,Microsoft.JScript.Compiler.ParseTree,DeclarationForInStatement,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler.ParseTree\DeclarationForInStatement.cs,DeclarationForInStatement,The method has 8 parameters. Parameters: Item' Collection' Body' Location' HeaderLocation' In' LeftParen' RightParen
Long Parameter List,Microsoft.JScript.Compiler.ParseTree,DeclarationForStatement,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler.ParseTree\DeclarationForStatement.cs,DeclarationForStatement,The method has 10 parameters. Parameters: Initial' Condition' Increment' Body' Location' HeaderLocation' FirstSemicolon' SecondSemicolon' LeftParen' RightParen
Long Parameter List,Microsoft.JScript.Compiler.ParseTree,DoStatement,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler.ParseTree\DoStatement.cs,DoStatement,The method has 7 parameters. Parameters: Body' Condition' Location' HeaderLocation' While' LeftParen' RightParen
Long Parameter List,Microsoft.JScript.Compiler.ParseTree,ExpressionForInStatement,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler.ParseTree\ExpressionForInStatement.cs,ExpressionForInStatement,The method has 8 parameters. Parameters: Item' Collection' Body' Location' HeaderLocation' In' LeftParen' RightParen
Long Parameter List,Microsoft.JScript.Compiler.ParseTree,ExpressionForStatement,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler.ParseTree\ExpressionForStatement.cs,ExpressionForStatement,The method has 10 parameters. Parameters: Initial' Condition' Increment' Body' Location' HeaderLocation' FirstSemicolon' SecondSemicolon' LeftParen' RightParen
Long Parameter List,Microsoft.JScript.Compiler.ParseTree,ForInStatement,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler.ParseTree\ForInStatement.cs,ForInStatement,The method has 8 parameters. Parameters: Opcode' Collection' Body' Location' HeaderLocation' In' LeftParen' RightParen
Long Parameter List,Microsoft.JScript.Compiler.ParseTree,ForStatement,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler.ParseTree\ForStatement.cs,ForStatement,The method has 10 parameters. Parameters: Opcode' Condition' Increment' Body' Location' HeaderLocation' FirstSemicolon' SecondSemicolon' LeftParen' RightParen
Long Parameter List,Microsoft.JScript.Compiler.ParseTree,FunctionDefinition,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler.ParseTree\FunctionDefinition.cs,FunctionDefinition,The method has 8 parameters. Parameters: Name' Parameters' Body' Location' HeaderLocation' NameLocation' LeftParenLocation' RightParenLocation
Long Parameter List,Microsoft.JScript.Compiler.ParseTree,IfStatement,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler.ParseTree\IfStatement.cs,IfStatement,The method has 8 parameters. Parameters: Condition' IfBody' ElseBody' Location' HeaderLocation' LeftParen' RightParen' Else
Long Parameter List,Microsoft.JScript.Compiler.ParseTree,LoopStatement,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler.ParseTree\LoopStatement.cs,LoopStatement,The method has 5 parameters. Parameters: Opcode' Body' Location' LeftParen' RightParen
Long Parameter List,Microsoft.JScript.Compiler.ParseTree,QualifiedExpression,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler.ParseTree\QualifiedExpression.cs,QualifiedExpression,The method has 5 parameters. Parameters: Base' Qualifier' Location' DotLocation' QualifierLocation
Long Parameter List,Microsoft.JScript.Compiler.ParseTree,SwitchStatement,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler.ParseTree\SwitchStatement.cs,SwitchStatement,The method has 7 parameters. Parameters: Value' Cases' Location' HeaderLocation' LeftParen' RightParen' LeftBrace
Long Parameter List,Microsoft.JScript.Compiler.ParseTree,TernaryOperatorExpression,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler.ParseTree\TernaryOperatorExpression.cs,TernaryOperatorExpression,The method has 7 parameters. Parameters: First' Second' Third' opcode' Location' FirstOperatorLocation' SecondOperatorLocation
Long Parameter List,Microsoft.JScript.Compiler.ParseTree,ValueCaseClause,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler.ParseTree\ValueCaseClause.cs,ValueCaseClause,The method has 5 parameters. Parameters: Value' Children' Location' HeaderLocation' Colon
Long Parameter List,Microsoft.JScript.Compiler.ParseTree,WhileStatement,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler.ParseTree\WhileStatement.cs,WhileStatement,The method has 6 parameters. Parameters: Condition' Body' Location' HeaderLocation' LeftParen' RightParen
Long Parameter List,Microsoft.JScript.Compiler.ParseTree,WithStatement,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler.ParseTree\WithStatement.cs,WithStatement,The method has 6 parameters. Parameters: Scope' Body' Location' HeaderLocation' LeftParen' RightParen
Long Statement,Microsoft.JScript.Compiler,Parser,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler\Parser.cs,ParseVarDeclaration,The length of the statement  "					declaration = new InitializerVariableDeclaration (name' initializer' new TextSpan (start2' current)' new TextPoint (start2.StartPosition)); " is 139.
Long Statement,Microsoft.JScript.Compiler,Parser,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler\Parser.cs,ParseVarDeclaration,The length of the statement  "				VariableDeclarationListElement vardeclarListElt = new VariableDeclarationListElement (declaration' new TextPoint (current.StartPosition)); " is 138.
Long Statement,Microsoft.JScript.Compiler,Parser,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler\Parser.cs,ParseVarDeclaration,The length of the statement  "			VariableDeclarationStatement statement = new VariableDeclarationStatement (declarations' new TextSpan (start' current)); " is 120.
Long Statement,Microsoft.JScript.Compiler,Parser,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler\Parser.cs,ParseIfElse,The length of the statement  "			return new IfStatement (condition' ifBody' elseBody' new TextSpan (start' current)' new TextSpan (start' rightParen)' new TextPoint (leftParen.StartPosition)' new TextPoint (rightParen.StartPosition)' elsePoint); " is 212.
Long Statement,Microsoft.JScript.Compiler,Parser,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler\Parser.cs,ParseWhile,The length of the statement  "			return new WhileStatement (condition' body' new TextSpan (start' current)' new TextSpan (start' rightParen)' new TextPoint (leftParen.StartPosition)' new TextPoint (rightParen.StartPosition)); " is 192.
Long Statement,Microsoft.JScript.Compiler,Parser,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler\Parser.cs,ParseDo,The length of the statement  "			return new DoStatement (body' condition' new TextSpan (start' current)' new TextSpan (start' start)' new TextPoint (whileToken.StartPosition)' new TextPoint (leftParen.StartPosition)' new TextPoint (rightParen.StartPosition)); " is 226.
Long Statement,Microsoft.JScript.Compiler,Parser,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler\Parser.cs,ParseContinue,The length of the statement  "			return new BreakOrContinueStatement (Statement.Operation.Continue' label' new TextSpan (start' current)' new TextPoint (current.StartPosition)); " is 144.
Long Statement,Microsoft.JScript.Compiler,Parser,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler\Parser.cs,ParseBreak,The length of the statement  "			return new BreakOrContinueStatement (Statement.Operation.Break' label' new TextSpan (start' current)' new TextPoint (current.StartPosition)); " is 141.
Long Statement,Microsoft.JScript.Compiler,Parser,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler\Parser.cs,ParseWith,The length of the statement  "			return new WithStatement (scope' body' new TextSpan (start' current)' new TextSpan (start' rightParen)' new TextPoint (leftParen.StartPosition)' new TextPoint (rightParen.StartPosition)); " is 187.
Long Statement,Microsoft.JScript.Compiler,Parser,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler\Parser.cs,ParseSwitch,The length of the statement  "			SwitchStatement switchStatement = new SwitchStatement (Value' cases' new TextSpan (start' current)' new TextSpan (start' rightParen)' new TextPoint (leftParen.StartPosition)' new TextPoint (rightParen.StartPosition)' new TextPoint (leftBrace.StartPosition)); " is 258.
Long Statement,Microsoft.JScript.Compiler,Parser,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler\Parser.cs,ParseDefaultCaseClause,The length of the statement  "			DefaultCaseClause result = new DefaultCaseClause (children' new TextSpan (start' current)' new TextSpan (start' colon)' new TextPoint (colon.StartPosition)); " is 157.
Long Statement,Microsoft.JScript.Compiler,Parser,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler\Parser.cs,ParseValueCaseClause,The length of the statement  "			ValueCaseClause result = new ValueCaseClause (expression' children' new TextSpan (start' current)' new TextSpan (start' colon)' new TextPoint (colon.StartPosition)); " is 165.
Long Statement,Microsoft.JScript.Compiler,Parser,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler\Parser.cs,ParseTry,The length of the statement  "				catchClause = new CatchClause(name' handler'new TextSpan(start2'current)' new TextSpan(id' id)' new TextPoint(left.StartPosition)'new TextPoint(right.StartPosition)); " is 166.
Long Statement,Microsoft.JScript.Compiler,Parser,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler\Parser.cs,ParseLeftHandSideExpression,The length of the statement  "					expr = new StringLiteralExpression ((current as StringLiteralToken).Value' (current as StringLiteralToken).Spelling' new TextSpan (current' current)); " is 150.
Long Statement,Microsoft.JScript.Compiler,Parser,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler\Parser.cs,ParseLeftHandSideExpression,The length of the statement  "					expr = new UnaryOperatorExpression(ParseExpression ()' Expression.Operation.Parenthesized' new TextSpan(current'current)); " is 122.
Long Statement,Microsoft.JScript.Compiler,Parser,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler\Parser.cs,ParseRightExpression,The length of the statement  "						expr = new QualifiedExpression (expr' id' new TextSpan (start' current)' new TextPoint (start.StartPosition)' new TextPoint (current.StartPosition)); " is 149.
Long Statement,Microsoft.JScript.Compiler,Parser,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler\Parser.cs,ParsePostfixExpression,The length of the statement  "					expr = new UnaryOperatorExpression (expr' Expression.Operation.PostfixPlusPlus' new TextSpan (expr.Location.StartLine' expr.Location.StartColumn' current.StartLine' current.StartColumn + current.Width' expr.Location.StartPosition' current.StartPosition+current.Width)); " is 269.
Long Statement,Microsoft.JScript.Compiler,Parser,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler\Parser.cs,ParsePostfixExpression,The length of the statement  "					expr = new UnaryOperatorExpression (expr' Expression.Operation.PostfixMinusMinus' new TextSpan (expr.Location.StartLine' expr.Location.StartColumn' current.StartLine' current.StartColumn + current.Width' expr.Location.StartPosition' current.StartPosition + current.Width)); " is 273.
Long Statement,Microsoft.JScript.Compiler,Parser,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler\Parser.cs,ParseUnaryExpression,The length of the statement  "					expr = new UnaryOperatorExpression (this.ParseExpression (noIn)' Expression.Operation.delete' new TextSpan (start' current)); " is 125.
Long Statement,Microsoft.JScript.Compiler,Parser,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler\Parser.cs,ParseUnaryExpression,The length of the statement  "					expr = new UnaryOperatorExpression (this.ParseExpression (noIn)' Expression.Operation.@void' new TextSpan (start' current)); " is 124.
Long Statement,Microsoft.JScript.Compiler,Parser,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler\Parser.cs,ParseUnaryExpression,The length of the statement  "					expr = new UnaryOperatorExpression (this.ParseExpression (noIn)' Expression.Operation.@typeof' new TextSpan (start' current)); " is 126.
Long Statement,Microsoft.JScript.Compiler,Parser,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler\Parser.cs,ParseUnaryExpression,The length of the statement  "					expr = new UnaryOperatorExpression (this.ParseExpression (noIn)' Expression.Operation.PrefixPlusPlus' new TextSpan (start' current)); " is 133.
Long Statement,Microsoft.JScript.Compiler,Parser,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler\Parser.cs,ParseUnaryExpression,The length of the statement  "					expr = new UnaryOperatorExpression (this.ParseExpression (noIn)' Expression.Operation.PrefixMinusMinus' new TextSpan (start' current)); " is 135.
Long Statement,Microsoft.JScript.Compiler,Parser,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler\Parser.cs,ParseUnaryExpression,The length of the statement  "					expr = new UnaryOperatorExpression (this.ParseExpression (noIn)' Expression.Operation.PrefixPlus' new TextSpan (start' current)); " is 129.
Long Statement,Microsoft.JScript.Compiler,Parser,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler\Parser.cs,ParseUnaryExpression,The length of the statement  "					expr = new UnaryOperatorExpression (this.ParseExpression (noIn)' Expression.Operation.PrefixMinus' new TextSpan (start' current));  " is 130.
Long Statement,Microsoft.JScript.Compiler,Parser,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler\Parser.cs,ParseUnaryExpression,The length of the statement  "					expr = new UnaryOperatorExpression (this.ParseExpression (noIn)' Expression.Operation.Tilda' new TextSpan (start' current)); " is 124.
Long Statement,Microsoft.JScript.Compiler,Parser,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler\Parser.cs,ParseUnaryExpression,The length of the statement  "					expr = new UnaryOperatorExpression (this.ParseExpression (noIn)' Expression.Operation.Bang' new TextSpan (start' current)); " is 123.
Long Statement,Microsoft.JScript.Compiler,Parser,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler\Parser.cs,ParseMultiplicativeExpression,The length of the statement  "				expr = new BinaryOperatorExpression (expr' right' op' new TextSpan (start' current)' new TextPoint (start.StartPosition)); " is 122.
Long Statement,Microsoft.JScript.Compiler,Parser,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler\Parser.cs,ParseAdditiveExpression,The length of the statement  "				expr = new BinaryOperatorExpression (expr' right' op' new TextSpan (start' current)' new TextPoint (start.StartPosition)); " is 122.
Long Statement,Microsoft.JScript.Compiler,Parser,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler\Parser.cs,ParseShiftExpression,The length of the statement  "				expr = new BinaryOperatorExpression (expr' right' op' new TextSpan (start' current)' new TextPoint (start.StartPosition)); " is 122.
Long Statement,Microsoft.JScript.Compiler,Parser,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler\Parser.cs,ParseRelationalExpression,The length of the statement  "				expr = new BinaryOperatorExpression (expr' right' op' new TextSpan (start' current)' new TextPoint (start.StartPosition)); " is 122.
Long Statement,Microsoft.JScript.Compiler,Parser,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler\Parser.cs,ParseEqualityExpression,The length of the statement  "				expr = new BinaryOperatorExpression (expr' right' op' new TextSpan (start' current)' new TextPoint (ope.StartPosition)); " is 120.
Long Statement,Microsoft.JScript.Compiler,Parser,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler\Parser.cs,ParseBitwiseANDExpression,The length of the statement  "				expr = new BinaryOperatorExpression (expr' right' Expression.Operation.Ampersand' new TextSpan (start' current)' new TextPoint (op.StartPosition)); " is 147.
Long Statement,Microsoft.JScript.Compiler,Parser,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler\Parser.cs,ParseBitwiseXORExpression,The length of the statement  "				expr = new BinaryOperatorExpression (expr' right' Expression.Operation.Circumflex' new TextSpan (start' current)' new TextPoint (op.StartPosition)); " is 148.
Long Statement,Microsoft.JScript.Compiler,Parser,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler\Parser.cs,ParseBitwiseORExpression,The length of the statement  "				expr = new BinaryOperatorExpression (expr' right' Expression.Operation.Bar' new TextSpan (start' current)' new TextPoint (op.StartPosition)); " is 141.
Long Statement,Microsoft.JScript.Compiler,Parser,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler\Parser.cs,ParselogicalANDExpression,The length of the statement  "				expr = new BinaryOperatorExpression (expr' right' Expression.Operation.AmpersandAmpersand' new TextSpan (start' current)' new TextPoint (op.StartPosition)); " is 156.
Long Statement,Microsoft.JScript.Compiler,Parser,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler\Parser.cs,ParselogicalORExpression,The length of the statement  "				expr = new BinaryOperatorExpression (expr' right' Expression.Operation.BarBar' new TextSpan (start' current)' new TextPoint (start.StartPosition)); " is 147.
Long Statement,Microsoft.JScript.Compiler,Parser,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler\Parser.cs,ParseConditionalExpression,The length of the statement  "				expr = new TernaryOperatorExpression (expr' second' third' Expression.Operation.Question' new TextSpan (start' current)' new TextPoint (start.StartPosition)' new TextPoint (colon.StartPosition)); " is 195.
Long Statement,Microsoft.JScript.Compiler,Parser,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler\Parser.cs,ParseAssignmentExpression,The length of the statement  "			return new BinaryOperatorExpression (expr' right' op' new TextSpan (start' current)' new TextPoint (ope.StartPosition)); " is 120.
Long Statement,Microsoft.JScript.Compiler,Parser,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler\Parser.cs,ParseExpression,The length of the statement  "				expr = new BinaryOperatorExpression (expr' right' Expression.Operation.Comma' new TextSpan (start' current)' new TextPoint (start.StartPosition)); " is 146.
Long Statement,Microsoft.JScript.Compiler,Parser,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler\Parser.cs,ParseFunctionDefinition,The length of the statement  "			return new FunctionDefinition (id' parametters' body' location' HeaderLocation' NameLocation' leftParenLocation' rightParenLocation); " is 133.
Long Statement,Microsoft.JScript.Compiler,Parser,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler\Parser.cs,ParseObjectLiteral,The length of the statement  "						name = new StringLiteralExpression ((current as StringLiteralToken).Value' (current as StringLiteralToken).Spelling' new TextSpan (current' current)); " is 150.
Long Statement,Microsoft.JScript.Compiler,Tokenizer,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler\Tokenizer.cs,ScanRegularExpression,The length of the statement  "			return new RegularExpressionLiteralToken (regexp.ToString ()' ""' position - startpos' startpos' startrow' startcol' false); " is 124.
Long Statement,Microsoft.JScript.Compiler,Tokenizer,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler\Tokenizer.cs,CreateBlockComment,The length of the statement  "			comments.Add (new Comment (sb.ToString ()' new TextSpan (startLine' startColumn' Line' Column' startPosition' position))); " is 122.
Complex Conditional,Microsoft.JScript.Compiler,Parser,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler\Parser.cs,ParseDefaultCaseClause,The conditional expression  "current.Kind == Token.Type.@case  					|| current.Kind == Token.Type.@default  					|| current.Kind == Token.Type.RightBrace  					|| current.Kind == Token.Type.EndOfInput"  is complex.
Complex Conditional,Microsoft.JScript.Compiler,Parser,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler\Parser.cs,ParseValueCaseClause,The conditional expression  "current.Kind == Token.Type.@case  					|| current.Kind == Token.Type.@default  					|| current.Kind == Token.Type.RightBrace  					|| current.Kind == Token.Type.EndOfInput"  is complex.
Complex Conditional,Microsoft.JScript.Compiler,Parser,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler\Parser.cs,ParseRelationalExpression,The conditional expression  "current.Kind == Token.Type.Less  				|| current.Kind == Token.Type.Greater  				|| current.Kind == Token.Type.GreaterEqual  				|| current.Kind == Token.Type.LessEqual  				|| current.Kind == Token.Type.instanceof  				|| (current.Kind == Token.Type.@in && !noIn)"  is complex.
Complex Conditional,Microsoft.JScript.Compiler,Parser,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler\Parser.cs,ParseEqualityExpression,The conditional expression  "current.Kind == Token.Type.EqualEqual  				|| current.Kind == Token.Type.BangEqual  				|| current.Kind == Token.Type.EqualEqualEqual  				|| current.Kind == Token.Type.BangEqualEqual"  is complex.
Complex Conditional,Microsoft.JScript.Compiler,Tokenizer,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler\Tokenizer.cs,StripWhiteSpace,The conditional expression  "next == ' ' || next == '\t' || next == '\r' || next == '\n'"  is complex.
Magic Number,Microsoft.JScript.Compiler,Tokenizer,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler\Tokenizer.cs,CreateStringLiteralToken,The following statement contains a magic number: while (Advance ()) {  				int c = PeekChar ();  				if (c == quote)  					break;  				if (c == -1 || c == '\n') {  					return CreateBadToken (builder.ToString()' DiagnosticCode.SyntaxError);  				}  				if (c == '\\') {  					ReadChar ();  					c = PeekChar ();  					switch (c) {  						case '\'':  							c = '\'';   							break;  						case '"' :  							c = '"';//not sure  							break;  						case '\\':  							c = '\\';  							break;  						case 'b':  							c = '\b';  							break;  						case 'f':  							c = '\f';  							break;  						case 'n':  							c = '\n';  							break;  						case 'r':  							c = '\r';  							break;  						case 't':  							c = '\t';  							break;  						case 'v':  							c = '\v';  							break;  						case 'x'://2 hex digits  							ReadChar ();//next  							int r2 = 0;  							for (int i =0;i<2;i++) {  								ReadChar ();  								int d = PeekChar ();  								if (d >= '0' && d <= '9')  									d -= '0';  								else if (d >= 'A' && d <= 'F')  									d = d - 'A' + 10;  								else if (d >= 'a' && d <= 'f')  									d = d - 'a' + 10;  								else  									return CreateBadToken (builder.ToString()' DiagnosticCode.HexLiteralNoDigits);  								r2 = (r2 << 4) | d;  							}  							c = r2;  							break;  						case 'u'://4 hex digits  							ReadChar ();//next  							int r4 = 0;  							for (int i = 0; i < 4; i++) {  								ReadChar ();  								int d = PeekChar ();  								if (d >= '0' && d <= '9')  									d -= '0';  								else if (d >= 'A' && d <= 'F')  									d = d - 'A' + 10;  								else if (d >= 'a' && d <= 'f')  									d = d - 'a' + 10;  								else  									return CreateBadToken (builder.ToString()' DiagnosticCode.HexLiteralNoDigits);  								r4 = (r4 << 4) | d;  							}  							c = r4;  							break;  						default:  							//TODO 0 [lookahead ?DecimalDigit] or NonEscapeCharacter  							return CreateBadToken (builder.ToString()' DiagnosticCode.HexLiteralNoDigits);  					}  				}  				builder.Append ((char)c);  				ReadChar ();  			}
Magic Number,Microsoft.JScript.Compiler,Tokenizer,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler\Tokenizer.cs,CreateStringLiteralToken,The following statement contains a magic number: while (Advance ()) {  				int c = PeekChar ();  				if (c == quote)  					break;  				if (c == -1 || c == '\n') {  					return CreateBadToken (builder.ToString()' DiagnosticCode.SyntaxError);  				}  				if (c == '\\') {  					ReadChar ();  					c = PeekChar ();  					switch (c) {  						case '\'':  							c = '\'';   							break;  						case '"' :  							c = '"';//not sure  							break;  						case '\\':  							c = '\\';  							break;  						case 'b':  							c = '\b';  							break;  						case 'f':  							c = '\f';  							break;  						case 'n':  							c = '\n';  							break;  						case 'r':  							c = '\r';  							break;  						case 't':  							c = '\t';  							break;  						case 'v':  							c = '\v';  							break;  						case 'x'://2 hex digits  							ReadChar ();//next  							int r2 = 0;  							for (int i =0;i<2;i++) {  								ReadChar ();  								int d = PeekChar ();  								if (d >= '0' && d <= '9')  									d -= '0';  								else if (d >= 'A' && d <= 'F')  									d = d - 'A' + 10;  								else if (d >= 'a' && d <= 'f')  									d = d - 'a' + 10;  								else  									return CreateBadToken (builder.ToString()' DiagnosticCode.HexLiteralNoDigits);  								r2 = (r2 << 4) | d;  							}  							c = r2;  							break;  						case 'u'://4 hex digits  							ReadChar ();//next  							int r4 = 0;  							for (int i = 0; i < 4; i++) {  								ReadChar ();  								int d = PeekChar ();  								if (d >= '0' && d <= '9')  									d -= '0';  								else if (d >= 'A' && d <= 'F')  									d = d - 'A' + 10;  								else if (d >= 'a' && d <= 'f')  									d = d - 'a' + 10;  								else  									return CreateBadToken (builder.ToString()' DiagnosticCode.HexLiteralNoDigits);  								r4 = (r4 << 4) | d;  							}  							c = r4;  							break;  						default:  							//TODO 0 [lookahead ?DecimalDigit] or NonEscapeCharacter  							return CreateBadToken (builder.ToString()' DiagnosticCode.HexLiteralNoDigits);  					}  				}  				builder.Append ((char)c);  				ReadChar ();  			}
Magic Number,Microsoft.JScript.Compiler,Tokenizer,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler\Tokenizer.cs,CreateStringLiteralToken,The following statement contains a magic number: while (Advance ()) {  				int c = PeekChar ();  				if (c == quote)  					break;  				if (c == -1 || c == '\n') {  					return CreateBadToken (builder.ToString()' DiagnosticCode.SyntaxError);  				}  				if (c == '\\') {  					ReadChar ();  					c = PeekChar ();  					switch (c) {  						case '\'':  							c = '\'';   							break;  						case '"' :  							c = '"';//not sure  							break;  						case '\\':  							c = '\\';  							break;  						case 'b':  							c = '\b';  							break;  						case 'f':  							c = '\f';  							break;  						case 'n':  							c = '\n';  							break;  						case 'r':  							c = '\r';  							break;  						case 't':  							c = '\t';  							break;  						case 'v':  							c = '\v';  							break;  						case 'x'://2 hex digits  							ReadChar ();//next  							int r2 = 0;  							for (int i =0;i<2;i++) {  								ReadChar ();  								int d = PeekChar ();  								if (d >= '0' && d <= '9')  									d -= '0';  								else if (d >= 'A' && d <= 'F')  									d = d - 'A' + 10;  								else if (d >= 'a' && d <= 'f')  									d = d - 'a' + 10;  								else  									return CreateBadToken (builder.ToString()' DiagnosticCode.HexLiteralNoDigits);  								r2 = (r2 << 4) | d;  							}  							c = r2;  							break;  						case 'u'://4 hex digits  							ReadChar ();//next  							int r4 = 0;  							for (int i = 0; i < 4; i++) {  								ReadChar ();  								int d = PeekChar ();  								if (d >= '0' && d <= '9')  									d -= '0';  								else if (d >= 'A' && d <= 'F')  									d = d - 'A' + 10;  								else if (d >= 'a' && d <= 'f')  									d = d - 'a' + 10;  								else  									return CreateBadToken (builder.ToString()' DiagnosticCode.HexLiteralNoDigits);  								r4 = (r4 << 4) | d;  							}  							c = r4;  							break;  						default:  							//TODO 0 [lookahead ?DecimalDigit] or NonEscapeCharacter  							return CreateBadToken (builder.ToString()' DiagnosticCode.HexLiteralNoDigits);  					}  				}  				builder.Append ((char)c);  				ReadChar ();  			}
Magic Number,Microsoft.JScript.Compiler,Tokenizer,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler\Tokenizer.cs,CreateStringLiteralToken,The following statement contains a magic number: while (Advance ()) {  				int c = PeekChar ();  				if (c == quote)  					break;  				if (c == -1 || c == '\n') {  					return CreateBadToken (builder.ToString()' DiagnosticCode.SyntaxError);  				}  				if (c == '\\') {  					ReadChar ();  					c = PeekChar ();  					switch (c) {  						case '\'':  							c = '\'';   							break;  						case '"' :  							c = '"';//not sure  							break;  						case '\\':  							c = '\\';  							break;  						case 'b':  							c = '\b';  							break;  						case 'f':  							c = '\f';  							break;  						case 'n':  							c = '\n';  							break;  						case 'r':  							c = '\r';  							break;  						case 't':  							c = '\t';  							break;  						case 'v':  							c = '\v';  							break;  						case 'x'://2 hex digits  							ReadChar ();//next  							int r2 = 0;  							for (int i =0;i<2;i++) {  								ReadChar ();  								int d = PeekChar ();  								if (d >= '0' && d <= '9')  									d -= '0';  								else if (d >= 'A' && d <= 'F')  									d = d - 'A' + 10;  								else if (d >= 'a' && d <= 'f')  									d = d - 'a' + 10;  								else  									return CreateBadToken (builder.ToString()' DiagnosticCode.HexLiteralNoDigits);  								r2 = (r2 << 4) | d;  							}  							c = r2;  							break;  						case 'u'://4 hex digits  							ReadChar ();//next  							int r4 = 0;  							for (int i = 0; i < 4; i++) {  								ReadChar ();  								int d = PeekChar ();  								if (d >= '0' && d <= '9')  									d -= '0';  								else if (d >= 'A' && d <= 'F')  									d = d - 'A' + 10;  								else if (d >= 'a' && d <= 'f')  									d = d - 'a' + 10;  								else  									return CreateBadToken (builder.ToString()' DiagnosticCode.HexLiteralNoDigits);  								r4 = (r4 << 4) | d;  							}  							c = r4;  							break;  						default:  							//TODO 0 [lookahead ?DecimalDigit] or NonEscapeCharacter  							return CreateBadToken (builder.ToString()' DiagnosticCode.HexLiteralNoDigits);  					}  				}  				builder.Append ((char)c);  				ReadChar ();  			}
Magic Number,Microsoft.JScript.Compiler,Tokenizer,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler\Tokenizer.cs,CreateStringLiteralToken,The following statement contains a magic number: while (Advance ()) {  				int c = PeekChar ();  				if (c == quote)  					break;  				if (c == -1 || c == '\n') {  					return CreateBadToken (builder.ToString()' DiagnosticCode.SyntaxError);  				}  				if (c == '\\') {  					ReadChar ();  					c = PeekChar ();  					switch (c) {  						case '\'':  							c = '\'';   							break;  						case '"' :  							c = '"';//not sure  							break;  						case '\\':  							c = '\\';  							break;  						case 'b':  							c = '\b';  							break;  						case 'f':  							c = '\f';  							break;  						case 'n':  							c = '\n';  							break;  						case 'r':  							c = '\r';  							break;  						case 't':  							c = '\t';  							break;  						case 'v':  							c = '\v';  							break;  						case 'x'://2 hex digits  							ReadChar ();//next  							int r2 = 0;  							for (int i =0;i<2;i++) {  								ReadChar ();  								int d = PeekChar ();  								if (d >= '0' && d <= '9')  									d -= '0';  								else if (d >= 'A' && d <= 'F')  									d = d - 'A' + 10;  								else if (d >= 'a' && d <= 'f')  									d = d - 'a' + 10;  								else  									return CreateBadToken (builder.ToString()' DiagnosticCode.HexLiteralNoDigits);  								r2 = (r2 << 4) | d;  							}  							c = r2;  							break;  						case 'u'://4 hex digits  							ReadChar ();//next  							int r4 = 0;  							for (int i = 0; i < 4; i++) {  								ReadChar ();  								int d = PeekChar ();  								if (d >= '0' && d <= '9')  									d -= '0';  								else if (d >= 'A' && d <= 'F')  									d = d - 'A' + 10;  								else if (d >= 'a' && d <= 'f')  									d = d - 'a' + 10;  								else  									return CreateBadToken (builder.ToString()' DiagnosticCode.HexLiteralNoDigits);  								r4 = (r4 << 4) | d;  							}  							c = r4;  							break;  						default:  							//TODO 0 [lookahead ?DecimalDigit] or NonEscapeCharacter  							return CreateBadToken (builder.ToString()' DiagnosticCode.HexLiteralNoDigits);  					}  				}  				builder.Append ((char)c);  				ReadChar ();  			}
Magic Number,Microsoft.JScript.Compiler,Tokenizer,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler\Tokenizer.cs,CreateStringLiteralToken,The following statement contains a magic number: while (Advance ()) {  				int c = PeekChar ();  				if (c == quote)  					break;  				if (c == -1 || c == '\n') {  					return CreateBadToken (builder.ToString()' DiagnosticCode.SyntaxError);  				}  				if (c == '\\') {  					ReadChar ();  					c = PeekChar ();  					switch (c) {  						case '\'':  							c = '\'';   							break;  						case '"' :  							c = '"';//not sure  							break;  						case '\\':  							c = '\\';  							break;  						case 'b':  							c = '\b';  							break;  						case 'f':  							c = '\f';  							break;  						case 'n':  							c = '\n';  							break;  						case 'r':  							c = '\r';  							break;  						case 't':  							c = '\t';  							break;  						case 'v':  							c = '\v';  							break;  						case 'x'://2 hex digits  							ReadChar ();//next  							int r2 = 0;  							for (int i =0;i<2;i++) {  								ReadChar ();  								int d = PeekChar ();  								if (d >= '0' && d <= '9')  									d -= '0';  								else if (d >= 'A' && d <= 'F')  									d = d - 'A' + 10;  								else if (d >= 'a' && d <= 'f')  									d = d - 'a' + 10;  								else  									return CreateBadToken (builder.ToString()' DiagnosticCode.HexLiteralNoDigits);  								r2 = (r2 << 4) | d;  							}  							c = r2;  							break;  						case 'u'://4 hex digits  							ReadChar ();//next  							int r4 = 0;  							for (int i = 0; i < 4; i++) {  								ReadChar ();  								int d = PeekChar ();  								if (d >= '0' && d <= '9')  									d -= '0';  								else if (d >= 'A' && d <= 'F')  									d = d - 'A' + 10;  								else if (d >= 'a' && d <= 'f')  									d = d - 'a' + 10;  								else  									return CreateBadToken (builder.ToString()' DiagnosticCode.HexLiteralNoDigits);  								r4 = (r4 << 4) | d;  							}  							c = r4;  							break;  						default:  							//TODO 0 [lookahead ?DecimalDigit] or NonEscapeCharacter  							return CreateBadToken (builder.ToString()' DiagnosticCode.HexLiteralNoDigits);  					}  				}  				builder.Append ((char)c);  				ReadChar ();  			}
Magic Number,Microsoft.JScript.Compiler,Tokenizer,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler\Tokenizer.cs,CreateStringLiteralToken,The following statement contains a magic number: while (Advance ()) {  				int c = PeekChar ();  				if (c == quote)  					break;  				if (c == -1 || c == '\n') {  					return CreateBadToken (builder.ToString()' DiagnosticCode.SyntaxError);  				}  				if (c == '\\') {  					ReadChar ();  					c = PeekChar ();  					switch (c) {  						case '\'':  							c = '\'';   							break;  						case '"' :  							c = '"';//not sure  							break;  						case '\\':  							c = '\\';  							break;  						case 'b':  							c = '\b';  							break;  						case 'f':  							c = '\f';  							break;  						case 'n':  							c = '\n';  							break;  						case 'r':  							c = '\r';  							break;  						case 't':  							c = '\t';  							break;  						case 'v':  							c = '\v';  							break;  						case 'x'://2 hex digits  							ReadChar ();//next  							int r2 = 0;  							for (int i =0;i<2;i++) {  								ReadChar ();  								int d = PeekChar ();  								if (d >= '0' && d <= '9')  									d -= '0';  								else if (d >= 'A' && d <= 'F')  									d = d - 'A' + 10;  								else if (d >= 'a' && d <= 'f')  									d = d - 'a' + 10;  								else  									return CreateBadToken (builder.ToString()' DiagnosticCode.HexLiteralNoDigits);  								r2 = (r2 << 4) | d;  							}  							c = r2;  							break;  						case 'u'://4 hex digits  							ReadChar ();//next  							int r4 = 0;  							for (int i = 0; i < 4; i++) {  								ReadChar ();  								int d = PeekChar ();  								if (d >= '0' && d <= '9')  									d -= '0';  								else if (d >= 'A' && d <= 'F')  									d = d - 'A' + 10;  								else if (d >= 'a' && d <= 'f')  									d = d - 'a' + 10;  								else  									return CreateBadToken (builder.ToString()' DiagnosticCode.HexLiteralNoDigits);  								r4 = (r4 << 4) | d;  							}  							c = r4;  							break;  						default:  							//TODO 0 [lookahead ?DecimalDigit] or NonEscapeCharacter  							return CreateBadToken (builder.ToString()' DiagnosticCode.HexLiteralNoDigits);  					}  				}  				builder.Append ((char)c);  				ReadChar ();  			}
Magic Number,Microsoft.JScript.Compiler,Tokenizer,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler\Tokenizer.cs,CreateStringLiteralToken,The following statement contains a magic number: while (Advance ()) {  				int c = PeekChar ();  				if (c == quote)  					break;  				if (c == -1 || c == '\n') {  					return CreateBadToken (builder.ToString()' DiagnosticCode.SyntaxError);  				}  				if (c == '\\') {  					ReadChar ();  					c = PeekChar ();  					switch (c) {  						case '\'':  							c = '\'';   							break;  						case '"' :  							c = '"';//not sure  							break;  						case '\\':  							c = '\\';  							break;  						case 'b':  							c = '\b';  							break;  						case 'f':  							c = '\f';  							break;  						case 'n':  							c = '\n';  							break;  						case 'r':  							c = '\r';  							break;  						case 't':  							c = '\t';  							break;  						case 'v':  							c = '\v';  							break;  						case 'x'://2 hex digits  							ReadChar ();//next  							int r2 = 0;  							for (int i =0;i<2;i++) {  								ReadChar ();  								int d = PeekChar ();  								if (d >= '0' && d <= '9')  									d -= '0';  								else if (d >= 'A' && d <= 'F')  									d = d - 'A' + 10;  								else if (d >= 'a' && d <= 'f')  									d = d - 'a' + 10;  								else  									return CreateBadToken (builder.ToString()' DiagnosticCode.HexLiteralNoDigits);  								r2 = (r2 << 4) | d;  							}  							c = r2;  							break;  						case 'u'://4 hex digits  							ReadChar ();//next  							int r4 = 0;  							for (int i = 0; i < 4; i++) {  								ReadChar ();  								int d = PeekChar ();  								if (d >= '0' && d <= '9')  									d -= '0';  								else if (d >= 'A' && d <= 'F')  									d = d - 'A' + 10;  								else if (d >= 'a' && d <= 'f')  									d = d - 'a' + 10;  								else  									return CreateBadToken (builder.ToString()' DiagnosticCode.HexLiteralNoDigits);  								r4 = (r4 << 4) | d;  							}  							c = r4;  							break;  						default:  							//TODO 0 [lookahead ?DecimalDigit] or NonEscapeCharacter  							return CreateBadToken (builder.ToString()' DiagnosticCode.HexLiteralNoDigits);  					}  				}  				builder.Append ((char)c);  				ReadChar ();  			}
Magic Number,Microsoft.JScript.Compiler,Tokenizer,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler\Tokenizer.cs,CreateOctalIntegerLiteralToken,The following statement contains a magic number: while (Advance ()) {  				int next = PeekChar ();  				switch (next) {  					case '0':  					case '1':  					case '2':  					case '3':  					case '4':  					case '5':  					case '6':  					case '7': {  							builder.Append ((char)next);  							val = val * 8 + next - '0';  							ReadChar ();  							continue;  						}  				}  				break;  			}
Magic Number,Microsoft.JScript.Compiler,Tokenizer,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler\Tokenizer.cs,CreateHexIntegerLiteralToken,The following statement contains a magic number: while (Advance ()) {  				int next = PeekChar ();  				switch (next) {  					case '0':  					case '1':  					case '2':  					case '3':  					case '4':  					case '5':  					case '6':  					case '7':  					case '8':  					case '9': {  							builder.Append ((char)next);  							val = val * 16 + next - '0';  							ReadChar ();  							continue;  						}  					case 'a':  					case 'b':  					case 'c':  					case 'd':  					case 'e':  					case 'f': {  							builder.Append ((char)next);  							val = val * 16 + next - 'a' + 10;  							ReadChar ();  							continue;  						}  					case 'A':  					case 'B':  					case 'C':  					case 'D':  					case 'E':  					case 'F': {  							builder.Append ((char)next);  							val = val * 16 + next - 'A' + 10;  							ReadChar ();  							continue;  						}  				}  				break;  			}
Magic Number,Microsoft.JScript.Compiler,Tokenizer,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler\Tokenizer.cs,CreateHexIntegerLiteralToken,The following statement contains a magic number: while (Advance ()) {  				int next = PeekChar ();  				switch (next) {  					case '0':  					case '1':  					case '2':  					case '3':  					case '4':  					case '5':  					case '6':  					case '7':  					case '8':  					case '9': {  							builder.Append ((char)next);  							val = val * 16 + next - '0';  							ReadChar ();  							continue;  						}  					case 'a':  					case 'b':  					case 'c':  					case 'd':  					case 'e':  					case 'f': {  							builder.Append ((char)next);  							val = val * 16 + next - 'a' + 10;  							ReadChar ();  							continue;  						}  					case 'A':  					case 'B':  					case 'C':  					case 'D':  					case 'E':  					case 'F': {  							builder.Append ((char)next);  							val = val * 16 + next - 'A' + 10;  							ReadChar ();  							continue;  						}  				}  				break;  			}
Magic Number,Microsoft.JScript.Compiler,Tokenizer,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler\Tokenizer.cs,CreateHexIntegerLiteralToken,The following statement contains a magic number: while (Advance ()) {  				int next = PeekChar ();  				switch (next) {  					case '0':  					case '1':  					case '2':  					case '3':  					case '4':  					case '5':  					case '6':  					case '7':  					case '8':  					case '9': {  							builder.Append ((char)next);  							val = val * 16 + next - '0';  							ReadChar ();  							continue;  						}  					case 'a':  					case 'b':  					case 'c':  					case 'd':  					case 'e':  					case 'f': {  							builder.Append ((char)next);  							val = val * 16 + next - 'a' + 10;  							ReadChar ();  							continue;  						}  					case 'A':  					case 'B':  					case 'C':  					case 'D':  					case 'E':  					case 'F': {  							builder.Append ((char)next);  							val = val * 16 + next - 'A' + 10;  							ReadChar ();  							continue;  						}  				}  				break;  			}
Magic Number,Microsoft.JScript.Compiler,Tokenizer,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler\Tokenizer.cs,CreateHexIntegerLiteralToken,The following statement contains a magic number: while (Advance ()) {  				int next = PeekChar ();  				switch (next) {  					case '0':  					case '1':  					case '2':  					case '3':  					case '4':  					case '5':  					case '6':  					case '7':  					case '8':  					case '9': {  							builder.Append ((char)next);  							val = val * 16 + next - '0';  							ReadChar ();  							continue;  						}  					case 'a':  					case 'b':  					case 'c':  					case 'd':  					case 'e':  					case 'f': {  							builder.Append ((char)next);  							val = val * 16 + next - 'a' + 10;  							ReadChar ();  							continue;  						}  					case 'A':  					case 'B':  					case 'C':  					case 'D':  					case 'E':  					case 'F': {  							builder.Append ((char)next);  							val = val * 16 + next - 'A' + 10;  							ReadChar ();  							continue;  						}  				}  				break;  			}
Magic Number,Microsoft.JScript.Compiler,Tokenizer,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler\Tokenizer.cs,CreateHexIntegerLiteralToken,The following statement contains a magic number: while (Advance ()) {  				int next = PeekChar ();  				switch (next) {  					case '0':  					case '1':  					case '2':  					case '3':  					case '4':  					case '5':  					case '6':  					case '7':  					case '8':  					case '9': {  							builder.Append ((char)next);  							val = val * 16 + next - '0';  							ReadChar ();  							continue;  						}  					case 'a':  					case 'b':  					case 'c':  					case 'd':  					case 'e':  					case 'f': {  							builder.Append ((char)next);  							val = val * 16 + next - 'a' + 10;  							ReadChar ();  							continue;  						}  					case 'A':  					case 'B':  					case 'C':  					case 'D':  					case 'E':  					case 'F': {  							builder.Append ((char)next);  							val = val * 16 + next - 'A' + 10;  							ReadChar ();  							continue;  						}  				}  				break;  			}
Missing Default,Microsoft.JScript.Compiler,Parser,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler\Parser.cs,ParsePostfixExpression,The following switch statement is missing a default case: switch (current.Kind) {  				case Token.Type.PlusPlus :  					expr = new UnaryOperatorExpression (expr' Expression.Operation.PostfixPlusPlus' new TextSpan (expr.Location.StartLine' expr.Location.StartColumn' current.StartLine' current.StartColumn + current.Width' expr.Location.StartPosition' current.StartPosition+current.Width));  					Next ();  					break;  				case Token.Type.MinusMinus:  					expr = new UnaryOperatorExpression (expr' Expression.Operation.PostfixMinusMinus' new TextSpan (expr.Location.StartLine' expr.Location.StartColumn' current.StartLine' current.StartColumn + current.Width' expr.Location.StartPosition' current.StartPosition + current.Width));  					Next ();  					break;  			}
Missing Default,Microsoft.JScript.Compiler,Parser,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler\Parser.cs,ParseMultiplicativeExpression,The following switch statement is missing a default case: switch (current.Kind) {  					case Token.Type.Star:  						op = Expression.Operation.Star;  						break;  					case Token.Type.Divide:  						op = Expression.Operation.Divide;  						break;  					case Token.Type.Percent:  						op = Expression.Operation.Percent;  						break;  				}
Missing Default,Microsoft.JScript.Compiler,Parser,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler\Parser.cs,ParseAdditiveExpression,The following switch statement is missing a default case: switch (current.Kind) {  					case Token.Type.Plus:  						op = Expression.Operation.Plus;  						break;  					case Token.Type.Minus:  						op = Expression.Operation.Minus;  						break;  				}
Missing Default,Microsoft.JScript.Compiler,Parser,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler\Parser.cs,ParseShiftExpression,The following switch statement is missing a default case: switch (current.Kind) {  					case Token.Type.LessLess:  						op = Expression.Operation.LessLess;  						break;  					case Token.Type.GreaterGreater:  						op = Expression.Operation.GreaterGreater;  						break;  					case Token.Type.GreaterGreaterGreater:  						op = Expression.Operation.GreaterGreaterGreater;  						break;  				}
Missing Default,Microsoft.JScript.Compiler,Parser,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler\Parser.cs,ParseRelationalExpression,The following switch statement is missing a default case: switch (current.Kind) {  					case Token.Type.Less:  						op = Expression.Operation.Less;  						break;  					case Token.Type.Greater:  						op = Expression.Operation.Greater;  						break;  					case Token.Type.GreaterEqual:  						op = Expression.Operation.GreaterEqual;  						break;  					case Token.Type.LessEqual:  						op = Expression.Operation.LessEqual;  						break;  					case Token.Type.instanceof:  						op = Expression.Operation.instanceof;  						break;  					case Token.Type.@in:  						if (noIn)  							return ParseShiftExpression (noIn);  						else  							op = Expression.Operation.@in;  						break;  				}
Missing Default,Microsoft.JScript.Compiler,Parser,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler\Parser.cs,ParseEqualityExpression,The following switch statement is missing a default case: switch (current.Kind) {  					case Token.Type.EqualEqual:  						op = Expression.Operation.EqualEqual;  						break;  					case Token.Type.BangEqual:  						op = Expression.Operation.BangEqual;  						break;  					case Token.Type.EqualEqualEqual:  						op = Expression.Operation.EqualEqualEqual;  						break;  					case Token.Type.BangEqualEqual:  						op = Expression.Operation.BangEqualEqual;  						break;  				}
Missing Default,Microsoft.JScript.Compiler,Parser,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler\Parser.cs,CheckSyntaxExpected,The following switch statement is missing a default case: switch (type) {  				case Token.Type.@case:  				case Token.Type.@default:  					code = DiagnosticCode.CaseOrDefaultExpected;  					break;  				case Token.Type.Identifier:  					code = DiagnosticCode.IdentifierExpected;  					break;  				case Token.Type.LeftBrace:  					code = DiagnosticCode.LeftBraceExpected;  					break;  				case Token.Type.LeftParenthesis:  					code = DiagnosticCode.LeftParenExpected;  					break;  				case Token.Type.Semicolon:  					code = DiagnosticCode.SemicolonExpected;  					break;  			}
Missing Default,Microsoft.JScript.Compiler,Tokenizer,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler\Tokenizer.cs,GetNext,The following switch statement is missing a default case: switch (c)  			{  				case '{':  					return CreateToken (Token.Type.LeftBrace);  				case '}':  					return CreateToken (Token.Type.RightBrace);  				case '(':  					return CreateToken (Token.Type.LeftParenthesis);  				case ')':  					return CreateToken (Token.Type.RightParenthesis);  				case '[':  					return CreateToken (Token.Type.LeftBracket);  				case ']':  					return CreateToken (Token.Type.RightBracket);  				case '.':  					return CreateToken (Token.Type.Dot);  				case ';':  					return CreateToken (Token.Type.Semicolon);  				case ''':  					return CreateToken (Token.Type.Comma);  				case '<':    					if (next == '=') {  						ReadChar ();  						return CreateToken (Token.Type.LessEqual);  					} else if (next == '<') {  						ReadChar ();  						next = PeekChar ();  						if (next == '=') {  							ReadChar ();  							return CreateToken (Token.Type.LessLessEqual);  						} else {  							return CreateToken (Token.Type.LessLess);  						}  					} else {  						return CreateToken (Token.Type.Less);  					}  				case '>':  					if (next == '=') {  						ReadChar ();  						return CreateToken (Token.Type.GreaterEqual);  					} else if (next == '>') {  						ReadChar ();  						next = PeekChar ();  						if (next == '=') {  							ReadChar ();  							return CreateToken (Token.Type.GreaterGreaterEqual);  						}  						else if (next == '>') {  							ReadChar ();  							next = PeekChar ();  							if (next == '=') {  								ReadChar ();  								return CreateToken (Token.Type.GreaterGreaterGreaterEqual);  							}  							else  								return CreateToken (Token.Type.GreaterGreaterGreater);  						}  						else {  							return CreateToken (Token.Type.GreaterGreater);  						}  					} else {  						return CreateToken (Token.Type.Greater);  					}  				case '=':  					if (next == '=') {  						ReadChar ();  						next = PeekChar ();  						if (next == '=') {  							ReadChar ();  							return CreateToken (Token.Type.EqualEqualEqual);  						} else {  							return CreateToken (Token.Type.EqualEqual);  						}  					} else {  						return CreateToken (Token.Type.Equal);  					}  				case '!':  					if (next == '=') {  						ReadChar ();  						next = PeekChar ();  						if (next == '=') {  							ReadChar ();  							return CreateToken (Token.Type.BangEqualEqual);  						} else {  							return CreateToken (Token.Type.BangEqual);  						}  					}  					return CreateToken (Token.Type.Bang);  				case '+':  					if (next == '+') {  						ReadChar ();  						return CreateToken (Token.Type.PlusPlus);  					} else if (next == '=') {  						ReadChar ();  						return CreateToken (Token.Type.PlusEqual);  					} else {  						return CreateToken (Token.Type.Plus);  					}  				case '-':  					if (next == '-') {  						ReadChar ();  						return CreateToken (Token.Type.MinusMinus);  					} else if (next == '=') {  						ReadChar ();  						return CreateToken (Token.Type.MinusEqual);  					} else {  						return CreateToken (Token.Type.Minus);  					}  				case '*':  					if (next == '=') {  						ReadChar ();  						return CreateToken (Token.Type.StarEqual);  					} else {  						return CreateToken (Token.Type.Star);  					}  				case '%':  					if (next == '=') {  						ReadChar ();  						return CreateToken (Token.Type.PercentEqual);  					} else {  						return CreateToken (Token.Type.Percent);  					}  				case '&':  					if (next == '&') {  						ReadChar ();  						return CreateToken (Token.Type.AmpersandAmpersand);  					} else if (next == '=') {  						ReadChar ();  						return CreateToken (Token.Type.AmpersandEqual);  					} else {  						return CreateToken (Token.Type.Ampersand);  					}  				case '|':  					if (next == '|') {  						ReadChar ();  						return CreateToken (Token.Type.BarBar);  					} else if (next == '=') {  						ReadChar ();  						return CreateToken (Token.Type.BarEqual);  					} else {  						return CreateToken (Token.Type.Bar);  					}  				case '^':  					if (next == '=') {  						ReadChar ();  						return CreateToken (Token.Type.CircumflexEqual);  					} else {  						return CreateToken (Token.Type.Circumflex);  					}  				case '~':  					return CreateToken (Token.Type.Tilda);  				case '?':  					return CreateToken (Token.Type.Question);  				case ':':  					return CreateToken (Token.Type.Colon);  				case '/':  					if (next == '=') {  						ReadChar ();  						return CreateToken (Token.Type.DivideEqual);  					} else if (next == '/') {  						// FIXME  						ReadChar ();  						CreateLineComment ();  						return GetNext ();  					} else if (next == '*') {  						ReadChar ();  						CreateBlockComment ();  						return GetNext ();  					} else {  						return CreateToken (Token.Type.Divide);  					}  				case '"':  				case '\'':  					return CreateStringLiteralToken (c);    				case '0':  				case '1':  				case '2':  				case '3':  				case '4':  				case '5':  				case '6':  				case '7':  				case '8':  				case '9':  					return CreateNumericLiteralToken (c);    				case 'a':  				case 'b':  				case 'c':  				case 'd':  				case 'e':  				case 'f':  				case 'g':  				case 'h':  				case 'i':  				case 'j':  				case 'k':  				case 'l':  				case 'm':  				case 'n':  				case 'o':  				case 'p':  				case 'q':  				case 'r':  				case 's':  				case 't':  				case 'u':  				case 'v':  				case 'w':  				case 'x':  				case 'y':  				case 'z':  				case 'A':  				case 'B':  				case 'C':  				case 'D':  				case 'E':  				case 'F':  				case 'G':  				case 'H':  				case 'I':  				case 'J':  				case 'K':  				case 'L':  				case 'M':  				case 'N':  				case 'O':  				case 'P':  				case 'Q':  				case 'R':  				case 'S':  				case 'T':  				case 'U':  				case 'V':  				case 'W':  				case 'X':  				case 'Y':  				case 'Z':  				case '$':  				case '_':  					return this.CreateIdentOrKeyword (c);  			}
Missing Default,Microsoft.JScript.Compiler,Tokenizer,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler\Tokenizer.cs,CreateNumericLiteralToken,The following switch statement is missing a default case: switch (next) {  						case '0':  						case '1':  						case '2':  						case '3':  						case '4':  						case '5':  						case '6':  						case '7':							  							return CreateOctalIntegerLiteralToken (first);  					}
Missing Default,Microsoft.JScript.Compiler,Tokenizer,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler\Tokenizer.cs,CreateNumericLiteralToken,The following switch statement is missing a default case: switch (next) {  					case '0':  					case '1':  					case '2':  					case '3':  					case '4':  					case '5':  					case '6':  					case '7':  					case '8':  					case '9': {  							builder.Append ((char) next);  							ReadChar ();  							continue;  						}  					case '.': {  							ReadChar ();  							dot++;  							builder.Append ((char)next);  							if (dot > 1) {  								current = CreateBadToken (builder.ToString()' DiagnosticCode.MalformedNumericLiteral);  								return current;  							}							  							continue;  						}  					case 'e':  					case 'E': {  							builder.Append ((char)next);  							ReadChar ();  							exp++;  							if (exp > 1) {  								current = CreateBadToken (builder.ToString ()' DiagnosticCode.MalformedNumericLiteral);  								return current;  							}  							next = PeekChar ();  							if (next == '+' || next == '-') {  								builder.Append ((char)next);  								ReadChar ();  							}  							continue;  						}  				}
Missing Default,Microsoft.JScript.Compiler,Tokenizer,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler\Tokenizer.cs,CreateOctalIntegerLiteralToken,The following switch statement is missing a default case: switch (next) {  					case '0':  					case '1':  					case '2':  					case '3':  					case '4':  					case '5':  					case '6':  					case '7': {  							builder.Append ((char)next);  							val = val * 8 + next - '0';  							ReadChar ();  							continue;  						}  				}
Missing Default,Microsoft.JScript.Compiler,Tokenizer,C:\repos\mono_olive\class\Microsoft.JScript.Compiler\Microsoft.JScript.Compiler\Tokenizer.cs,CreateHexIntegerLiteralToken,The following switch statement is missing a default case: switch (next) {  					case '0':  					case '1':  					case '2':  					case '3':  					case '4':  					case '5':  					case '6':  					case '7':  					case '8':  					case '9': {  							builder.Append ((char)next);  							val = val * 16 + next - '0';  							ReadChar ();  							continue;  						}  					case 'a':  					case 'b':  					case 'c':  					case 'd':  					case 'e':  					case 'f': {  							builder.Append ((char)next);  							val = val * 16 + next - 'a' + 10;  							ReadChar ();  							continue;  						}  					case 'A':  					case 'B':  					case 'C':  					case 'D':  					case 'E':  					case 'F': {  							builder.Append ((char)next);  							val = val * 16 + next - 'A' + 10;  							ReadChar ();  							continue;  						}  				}
