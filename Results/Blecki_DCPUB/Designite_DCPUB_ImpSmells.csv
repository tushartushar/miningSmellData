Implementation smell,Namespace,Class,File,Method,Description
Long Method,DCPUB.Intermediate,StatementNode,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Intermediate\StatementNode_SSA.cs,__ApplySSA,The method has 204 lines of code.
Long Method,DCPUB.Testing,Emulator,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Testing\Emulator.cs,Step,The method has 209 lines of code.
Long Method,DCPUB,Grammar,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Grammar.cs,Grammar,The method has 131 lines of code.
Complex Method,DCPUB.Intermediate,Instruction,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Intermediate\Instruction_EncodeOperand.cs,EncodeOperand,Cyclomatic complexity of the method is 17
Complex Method,DCPUB.Intermediate,StatementNode,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Intermediate\StatementNode_SSA.cs,__ApplySSA,Cyclomatic complexity of the method is 35
Complex Method,DCPUB.Intermediate,StatementNode,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Intermediate\StatementNode_SSA.cs,AssignRealRegisterToOperand,Cyclomatic complexity of the method is 8
Complex Method,DCPUB.Intermediate,Operand,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Intermediate\Operand.cs,OperandsEqual,Cyclomatic complexity of the method is 11
Complex Method,DCPUB.Intermediate,InstructionExtension,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Intermediate\Instructions.cs,GetOperandsModified,Cyclomatic complexity of the method is 16
Complex Method,DCPUB.Preprocessor,Parser,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Preprocessor\Parser.cs,ParseDirective,Cyclomatic complexity of the method is 18
Complex Method,DCPUB.Preprocessor,Parser,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Preprocessor\Parser.cs,Expand,Cyclomatic complexity of the method is 10
Complex Method,DCPUB.Preprocessor,Parser,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Preprocessor\Parser.cs,ParseBlock,Cyclomatic complexity of the method is 9
Complex Method,DCPUB.Testing,Emulator,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Testing\Emulator.cs,AssignToOperand,Cyclomatic complexity of the method is 12
Complex Method,DCPUB.Testing,Emulator,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Testing\Emulator.cs,GetOperandValue,Cyclomatic complexity of the method is 15
Complex Method,DCPUB.Testing,Emulator,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Testing\Emulator.cs,DisassembleOperand,Cyclomatic complexity of the method is 13
Complex Method,DCPUB.Testing,Emulator,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Testing\Emulator.cs,Step,Cyclomatic complexity of the method is 44
Complex Method,DCPUB.Ast.Assembly,InstructionAstNode,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Ast\Assembly\InstructionAstNode.cs,ParseInstruction,Cyclomatic complexity of the method is 10
Complex Method,DCPUB.Ast,AddressOfNode,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Ast\AddressOfNode.cs,ResolveTypes,Cyclomatic complexity of the method is 8
Complex Method,DCPUB.Ast,FunctionCallNode,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Ast\FunctionCallNode.cs,ResolveTypes,Cyclomatic complexity of the method is 8
Complex Method,DCPUB.Ast,FunctionDeclarationNode,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Ast\FunctionDeclarationNode.cs,CompileFunction,Cyclomatic complexity of the method is 13
Complex Method,DCPUB.Ast,NumberLiteralNode,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Ast\NumberLiteralNode.cs,Init,Cyclomatic complexity of the method is 8
Complex Method,DCPUB.Ast,VariableDeclarationNode,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Ast\VariableDeclarationNode.cs,ResolveTypes,Cyclomatic complexity of the method is 19
Complex Method,DCPUB.Ast,VariableNameNode,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Ast\VariableNameNode.cs,Emit,Cyclomatic complexity of the method is 8
Complex Method,DCPUB.Ast,VariableNameNode,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Ast\VariableNameNode.cs,GetFetchToken,Cyclomatic complexity of the method is 9
Long Parameter List,DCPUB.Ast,BinaryOperator,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Ast\BinaryOperationNode.cs,Emit,The method has 5 parameters. Parameters: Context' Scope' Target' Lhs' Rhs
Long Parameter List,DCPUB.Ast,BasicBinaryOperator,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Ast\BinaryOperationNode.cs,Emit,The method has 5 parameters. Parameters: Context' Scope' Target' Lhs' Rhs
Long Parameter List,DCPUB.Ast,ComparisonBinaryOperator,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Ast\BinaryOperationNode.cs,Emit,The method has 5 parameters. Parameters: Context' Scope' Target' Lhs' Rhs
Long Parameter List,DCPUB.Ast,LogicalBinaryOperator,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Ast\BinaryOperationNode.cs,Emit,The method has 5 parameters. Parameters: Context' Scope' Target' Lhs' Rhs
Long Statement,DCPUB.Intermediate,StatementNode,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Intermediate\StatementNode_SSA.cs,__ApplySSA,The length of the statement  "                            ssa_instructions.AddInstruction(Instructions.SET' CompilableNode.Virtual(first_operand.virtual_register)' ori_first_operand); " is 125.
Long Statement,DCPUB.Intermediate,StatementNode,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Intermediate\StatementNode_SSA.cs,__ApplySSA,The length of the statement  "                            ssa_instructions.AddInstruction(ins.instruction' CompilableNode.Virtual(first_operand.virtual_register)' second_operand); " is 121.
Long Statement,DCPUB.Intermediate,StatementNode,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Intermediate\StatementNode_SSA.cs,AssignRegisters,The length of the statement  "                    if (instruction.secondOperand != null) AssignRealRegisterToOperand(mapping' usedRegisters' (i * 2) + 1' instruction.secondOperand); " is 131.
Long Statement,DCPUB.Preprocessor,Parser,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Preprocessor\Parser.cs,ParseDirective,The length of the statement  "                state.LineLocationTable.AddLocation(state.filename' state.totalLinesInResult + result.Item2.totalLinesInResult' state.currentLineInFile); " is 137.
Long Statement,DCPUB.Testing,Emulator,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Testing\Emulator.cs,Step,The length of the statement  "                case Intermediate.Instructions.SUB: //SUB b' a | sets b to b-a' sets EX to 0xffff if there's an underflow' 0x0 otherwise " is 120.
Long Statement,DCPUB.Testing,Emulator,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Testing\Emulator.cs,Step,The length of the statement  "                case Intermediate.Instructions.DIV: //DIV b' a | sets b to b/a' sets EX to ((b<<16)/a)&0xffff. if a==0' sets b and EX to 0 instead. (treats b' a as unsigned) " is 157.
Long Statement,DCPUB.Testing,Emulator,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Testing\Emulator.cs,Step,The length of the statement  "                case Intermediate.Instructions.ASR: //ASR b' a | sets b to b>>a' sets EX to ((b<<16)>>>a)&0xffff (arithmetic shift) (treats b as signed) " is 136.
Long Statement,DCPUB.Testing,Emulator,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Testing\Emulator.cs,Step,The length of the statement  "                case Intermediate.Instructions.ADX: //ADX b' a | sets b to b+a+EX' sets EX to 0x0001 if there is an over-flow' 0x0 otherwise " is 124.
Long Statement,DCPUB.Testing,Emulator,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Testing\Emulator.cs,Step,The length of the statement  "                case Intermediate.Instructions.SBX: //SBX b' a | sets b to b-a+EX' sets EX to 0xFFFF if there is an under-flow' 0x0 otherwise " is 125.
Long Statement,DCPUB.Testing,Emulator,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Testing\Emulator.cs,Step,The length of the statement  "                case Intermediate.Instructions.RFI: //RFI a | disables interrupt queueing' pops A from the stack' then pops PC from the stack " is 125.
Long Statement,DCPUB.Testing,Emulator,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Testing\Emulator.cs,Step,The length of the statement  "                    registers[(int)Registers.A] = (ushort)(devices[value].HardwareID & 0xFFFF); //A+(B<<16) is a 32 bit word identifying the hardware id " is 132.
Long Statement,DCPUB.Testing,Emulator,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Testing\Emulator.cs,Step,The length of the statement  "                    registers[(int)Registers.X] = (ushort)(devices[value].ManufacturerID & 0xFFFF); //X+(Y<<16) is a 32 bit word identifying the manufacturer " is 137.
Long Statement,DCPUB,CompileContext,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\CompileContext.cs,Parse,The length of the statement  "                    onError("%PARSER " + msg.Level + ": " + msg.Message + " [line:" + msg.Location.Line + " column:" + msg.Location.Column + "]\r\n"); " is 130.
Long Statement,DCPUB,CompileContext,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\CompileContext.cs,Compile,The length of the statement  "            globalScope.variables.Add(new Model.Variable { type = Model.VariableType.ConstantLabel' name = "__endofprogram"' staticLabel = end_label }); " is 140.
Long Statement,DCPUB,CompileContext,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\CompileContext.cs,Compile,The length of the statement  "            globalScope.variables.Add(new Model.Variable { name = "false"' type = Model.VariableType.Constant' constantValue = 0 }); " is 120.
Long Statement,DCPUB.Ast,AddressOfNode,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Ast\AddressOfNode.cs,Emit,The length of the statement  "                    r.AddInstruction(Instructions.SET' target.GetOperand(TargetUsage.Push)' target.GetOperand(TargetUsage.Peek' OperandSemantics.Dereference)); " is 139.
Long Statement,DCPUB.Ast,LogicalBinaryOperator,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Ast\BinaryOperationNode.cs,Emit,The length of the statement  "                r.AddInstruction(Instructions.IFN' intermediate.GetOperand(TargetUsage.Peek)' secondTarget.GetOperand(TargetUsage.Peek)); " is 121.
Long Statement,DCPUB.Ast,BinaryOperationNode,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Ast\BinaryOperationNode.cs,Init,The length of the statement  "            //Console.WriteLine("{0} {1} {2}\n"' treeNode.ChildNodes[0].ToString()' treeNode.ChildNodes[1].ToString()' treeNode.ChildNodes[2].ToString()); " is 142.
Long Statement,DCPUB.Ast,BlockNode,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Ast\BlockNode.cs,Emit,The length of the statement  "                    r.AddInstruction(Instructions.ADD' Operand("SP")' Constant((ushort)(blockScope.variablesOnStack - scope.variablesOnStack))); " is 124.
Long Statement,DCPUB.Ast,VariableNameNode,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Ast\VariableNameNode.cs,Emit,The length of the statement  "                r.AddInstruction(Instructions.SET' target.GetOperand(TargetUsage.Peek)' target.GetOperand(TargetUsage.Peek' Intermediate.OperandSemantics.Dereference)); " is 152.
Long Statement,DCPUB.Ast,VariableNameNode,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Ast\VariableNameNode.cs,Emit,The length of the statement  "                r.AddInstruction(Instructions.SET' target.GetOperand(TargetUsage.Peek)' target.GetOperand(TargetUsage.Peek' Intermediate.OperandSemantics.Dereference)); " is 152.
Complex Conditional,DCPUB.Intermediate,StatementNode,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Intermediate\StatementNode_SSA.cs,__ApplySSA,The conditional expression  "c_ins.secondOperand != null                              && c_ins.secondOperand.semantics == OperandSemantics.None                              && c_ins.secondOperand.register == OperandRegister.VIRTUAL                              && c_ins.secondOperand.virtual_register == valueName.virtual_register"  is complex.
Complex Conditional,DCPUB.Intermediate,StatementNode,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Intermediate\StatementNode_SSA.cs,__ApplySSA,The conditional expression  "c_ins.firstOperand.semantics == OperandSemantics.None                              && c_ins.firstOperand.register == OperandRegister.VIRTUAL                              && c_ins.firstOperand.virtual_register == valueName.virtual_register                              // But don't fuck with J                              && !(value.semantics == OperandSemantics.None && value.register == OperandRegister.J)"  is complex.
Complex Conditional,DCPUB.Ast,BinaryOperationNode,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Ast\BinaryOperationNode.cs,GetFetchToken,The conditional expression  "A != null && (A.semantics & Intermediate.OperandSemantics.Constant) == Intermediate.OperandSemantics.Constant                  && B != null && (B.semantics & Intermediate.OperandSemantics.Constant) == Intermediate.OperandSemantics.Constant"  is complex.
Magic Number,DCPUB.Intermediate,Instruction,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Intermediate\Instruction_EncodeOperand.cs,EncodeOperand,The following statement contains a magic number: usage == OperandUsage.A && op.constant <= 30
Magic Number,DCPUB.Intermediate,Instruction,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Intermediate\Instruction_EncodeOperand.cs,EncodeOperand,The following statement contains a magic number: r += 8;
Magic Number,DCPUB.Intermediate,Instruction,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Intermediate\Instruction_EncodeOperand.cs,EncodeOperand,The following statement contains a magic number: r += 8;
Magic Number,DCPUB.Intermediate,Instruction,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Intermediate\Instruction_EncodeOperand.cs,EmitBinary,The following statement contains a magic number: ins.data += (ushort)(((ushort)instruction - (ushort)Instructions.SINGLE_OPERAND_INSTRUCTIONS) << 5);
Magic Number,DCPUB.Intermediate,StatementNode,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Intermediate\StatementNode_SSA.cs,AssignRealRegisterToOperand,The following statement contains a magic number: r < 6
Magic Number,DCPUB.Intermediate,StatementNode,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Intermediate\StatementNode_SSA.cs,AssignRegisters,The following statement contains a magic number: MarkVirtualRegisterLifetime(mapping' i * 2' instruction.firstOperand);
Magic Number,DCPUB.Intermediate,StatementNode,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Intermediate\StatementNode_SSA.cs,AssignRegisters,The following statement contains a magic number: MarkVirtualRegisterLifetime(mapping' (i * 2) + 1' instruction.secondOperand);
Magic Number,DCPUB.Intermediate,StatementNode,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Intermediate\StatementNode_SSA.cs,AssignRegisters,The following statement contains a magic number: bool[] usedRegisters = new bool[6] { false' false' false' false' false' false };
Magic Number,DCPUB.Intermediate,StatementNode,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Intermediate\StatementNode_SSA.cs,AssignRegisters,The following statement contains a magic number: AssignRealRegisterToOperand(mapping' usedRegisters' i * 2' instruction.firstOperand);
Magic Number,DCPUB.Intermediate,StatementNode,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Intermediate\StatementNode_SSA.cs,AssignRegisters,The following statement contains a magic number: AssignRealRegisterToOperand(mapping' usedRegisters' (i * 2) + 1' instruction.secondOperand);
Magic Number,DCPUB.Intermediate,InstructionExtension,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Intermediate\Instructions.cs,GetOperandCount,The following statement contains a magic number: return 2;
Magic Number,DCPUB.Intermediate,LabelNode,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Intermediate\LabelNode.cs,Emit,The following statement contains a magic number: stream.WriteLine(new String(' '' stream.indentDepth * 3) + ":" + label);
Magic Number,DCPUB.Testing,Emulator,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Testing\Emulator.cs,Disassemble,The following statement contains a magic number: ushort operandA = (ushort)((instruction & 0xFC00) >> 10);
Magic Number,DCPUB.Testing,Emulator,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Testing\Emulator.cs,Disassemble,The following statement contains a magic number: ushort operandB = (ushort)((instruction >> 5) & 0x1F);
Magic Number,DCPUB.Testing,Emulator,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Testing\Emulator.cs,Step,The following statement contains a magic number: ram[(ushort)(registers[(int)Registers.SP] - 2)] = registers[(int)Registers.A];
Magic Number,DCPUB.Testing,Emulator,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Testing\Emulator.cs,Step,The following statement contains a magic number: registers[(int)Registers.SP] -= 2;
Magic Number,DCPUB.Testing,Emulator,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Testing\Emulator.cs,Step,The following statement contains a magic number: ushort operandA = (ushort)((instruction & 0xFC00) >> 10);
Magic Number,DCPUB.Testing,Emulator,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Testing\Emulator.cs,Step,The following statement contains a magic number: ushort operandB = (ushort)((instruction >> 5) & 0x1F);
Magic Number,DCPUB.Testing,Emulator,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Testing\Emulator.cs,Step,The following statement contains a magic number: switch (ins)              {                  case Intermediate.Instructions.SET: //0x01 | SET b' a | sets b to a                      AssignToOperand(operandB' value' false);                      break;                  case Intermediate.Instructions.ADD: //ADD b' a | sets b to b+a' sets EX to 0x0001 if there's an overflow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) + value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.SUB: //SUB b' a | sets b to b-a' sets EX to 0xffff if there's an underflow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) - value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MUL: //MUL b' a | sets b to b*a' sets EX to ((b*a)>>16)&0xffff (treats b' a as unsigned)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) * value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MLI: //MLI b' a | like MUL' but treat b' a as signed                      intermediate = (UInt32)((short)GetOperandValue(operandB' OperandPlace.B) * (short)value);                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.DIV: //DIV b' a | sets b to b/a' sets EX to ((b<<16)/a)&0xffff. if a==0' sets b and EX to 0 instead. (treats b' a as unsigned)                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      intermediate = value == 0 ? 0 : (UInt32)bValue / value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.DVI: //DVI b' a | like DIV' but treat b' a as signed. Rounds towards 0                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      intermediate = value == 0 ? 0 : (UInt32)((short)bValue / (short)value);                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MOD: //MOD b' a | sets b to b%a. if a==0' sets b to 0 instead.                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      AssignToOperand(operandB' value == 0 ? (ushort)0 : (ushort)(bValue % value)' true);                      break;                  case Intermediate.Instructions.MDI: //MDI b' a | like MOD' but treat b' a as signed. (MDI -7' 16 == -7)                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      AssignToOperand(operandB' value == 0 ? (ushort)0 : (ushort)((short)bValue % (short)value)' true);                      break;                  case Intermediate.Instructions.AND: //AND b' a | sets b to b&a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) & value)' true);                      break;                  case Intermediate.Instructions.BOR: //BOR b' a | sets b to b|a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) | value)' true);                      break;                  case Intermediate.Instructions.XOR: //XOR b' a | sets b to b^a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) ^ value));                      break;                  case Intermediate.Instructions.SHR: //SHR b' a | sets b to b>>>a' sets EX to ((b<<16)>>a)&0xffff (logical shift)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)(intermediate >> value)' true);                      AssignToEx((ushort)(intermediate << 16 >> value));                      break;                  case Intermediate.Instructions.ASR: //ASR b' a | sets b to b>>a' sets EX to ((b<<16)>>>a)&0xffff (arithmetic shift) (treats b as signed)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)((int)intermediate >> value)' true);                      AssignToEx((ushort)((int)intermediate << 16 >> value));                      break;                  case Intermediate.Instructions.SHL: //SHL b' a | sets b to b<<a' sets EX to ((b<<a)>>16)&0xffff                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)(intermediate << value)' true);                      AssignToEx((ushort)(intermediate << value >> 16));                      break;                  case Intermediate.Instructions.IFB: //IFB b' a | performs next instruction only if (b&a)!=0                      SkipIf = (GetOperandValue(operandB' OperandPlace.B) & value) != 0;                      break;                  case Intermediate.Instructions.IFC: //IFC b' a | performs next instruction only if (b&a)==0                      SkipIf = (GetOperandValue(operandB' OperandPlace.B) & value) == 0;                      break;                  case Intermediate.Instructions.IFE: //IFE b' a | performs next instruction only if b==a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) == value;                      break;                  case Intermediate.Instructions.IFN: //IFB b' a | performs next instruction only if b!=a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) != value;                      break;                  case Intermediate.Instructions.IFG: //IFG b' a | performs next instruction only if b>a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) > value;                      break;                  case Intermediate.Instructions.IFA: //IFA b' a | performs next instruction only if b>a (signed)                      SkipIf = (int)GetOperandValue(operandB' OperandPlace.B) > (int)value;                      break;                  case Intermediate.Instructions.IFL: //IFL b' a | performs next instruction only if b<a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) < value;                      break;                  case Intermediate.Instructions.IFU: //IFU b' a | performs next instruction only if b<a (signed)                      SkipIf = (int)GetOperandValue(operandB' OperandPlace.B) < (int)value;                      break;                  case Intermediate.Instructions.ADX: //ADX b' a | sets b to b+a+EX' sets EX to 0x0001 if there is an over-flow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) + value + registers[(int)Registers.EX];                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.SBX: //SBX b' a | sets b to b-a+EX' sets EX to 0xFFFF if there is an under-flow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) - value + registers[(int)Registers.EX];                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.STI: //STI b' a | sets b to a' then increases I and J by 1                      AssignToOperand(operandB' value' false);                      registers[(int)Registers.I] += 1;                      registers[(int)Registers.J] += 1;                      break;                  case Intermediate.Instructions.STD: //STI b' a | sets b to a' then decreases I and J by 1                      AssignToOperand(operandB' value' false);                      registers[(int)Registers.I] -= 1;                      registers[(int)Registers.J] -= 1;                      break;                    case Intermediate.Instructions.JSR: //pushes the address of the next instruction to the stack' then sets PC to a                      ram[(ushort)(registers[(int)Registers.SP] - 1)] = registers[(int)Registers.PC];                      registers[(int)Registers.SP] -= 1;                      registers[(int)Registers.PC] = value;                      break;                  case Intermediate.Instructions.HLT:                      throw new Halt();                    case Intermediate.Instructions.INT: //INT a | triggers a software interrupt with message a                      TriggerInterrupt(value);                      break;                  case Intermediate.Instructions.IAG: //IAG a | sets a to IA                       AssignToOperand(operandA' registers[(int)Registers.IA]' true);                      break;                  case Intermediate.Instructions.IAS: //IAS a | sets IA to A                       registers[(int)Registers.IA] = value;                      break;                  case Intermediate.Instructions.RFI: //RFI a | disables interrupt queueing' pops A from the stack' then pops PC from the stack                      protectInterruptQueue.WaitOne();                      interruptQueueEnabled = false;                      registers[(int)Registers.A] = ram[(ushort)(registers[(int)Registers.SP])];                      registers[(int)Registers.PC] = ram[(ushort)(registers[(int)Registers.SP] + 1)];                      registers[(int)Registers.SP] += 2;                      break;                  case Intermediate.Instructions.IAQ: //IAQ a | if a is nonzero' interrupts will be added to the queue                      interruptQueueEnabled = value != 0; //instead of triggered. if a is zero' interrupts will be                      break;                              //triggered as normal again                    case Intermediate.Instructions.HWN: //HWN a | sets a to number of connected hardware devices                      AssignToOperand(operandA' (ushort)devices.Count' true);                      break;                  case Intermediate.Instructions.HWQ: //HWQ a | sets A' B' C' X' Y registers to information about hardware a                       registers[(int)Registers.A] = (ushort)(devices[value].HardwareID & 0xFFFF); //A+(B<<16) is a 32 bit word identifying the hardware id                      registers[(int)Registers.B] = (ushort)((devices[value].HardwareID >> 16) & 0xFFFF);                      registers[(int)Registers.C] = devices[value].Version; //C is the hardware version                      registers[(int)Registers.X] = (ushort)(devices[value].ManufacturerID & 0xFFFF); //X+(Y<<16) is a 32 bit word identifying the manufacturer                      registers[(int)Registers.Y] = (ushort)((devices[value].ManufacturerID >> 16) & 0xFFFF);                      break;                  case Intermediate.Instructions.HWI: //HWI a | sends an interrupt to hardware a                      devices[value].OnInterrupt(this);                      break;              }
Magic Number,DCPUB.Testing,Emulator,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Testing\Emulator.cs,Step,The following statement contains a magic number: switch (ins)              {                  case Intermediate.Instructions.SET: //0x01 | SET b' a | sets b to a                      AssignToOperand(operandB' value' false);                      break;                  case Intermediate.Instructions.ADD: //ADD b' a | sets b to b+a' sets EX to 0x0001 if there's an overflow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) + value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.SUB: //SUB b' a | sets b to b-a' sets EX to 0xffff if there's an underflow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) - value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MUL: //MUL b' a | sets b to b*a' sets EX to ((b*a)>>16)&0xffff (treats b' a as unsigned)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) * value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MLI: //MLI b' a | like MUL' but treat b' a as signed                      intermediate = (UInt32)((short)GetOperandValue(operandB' OperandPlace.B) * (short)value);                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.DIV: //DIV b' a | sets b to b/a' sets EX to ((b<<16)/a)&0xffff. if a==0' sets b and EX to 0 instead. (treats b' a as unsigned)                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      intermediate = value == 0 ? 0 : (UInt32)bValue / value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.DVI: //DVI b' a | like DIV' but treat b' a as signed. Rounds towards 0                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      intermediate = value == 0 ? 0 : (UInt32)((short)bValue / (short)value);                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MOD: //MOD b' a | sets b to b%a. if a==0' sets b to 0 instead.                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      AssignToOperand(operandB' value == 0 ? (ushort)0 : (ushort)(bValue % value)' true);                      break;                  case Intermediate.Instructions.MDI: //MDI b' a | like MOD' but treat b' a as signed. (MDI -7' 16 == -7)                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      AssignToOperand(operandB' value == 0 ? (ushort)0 : (ushort)((short)bValue % (short)value)' true);                      break;                  case Intermediate.Instructions.AND: //AND b' a | sets b to b&a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) & value)' true);                      break;                  case Intermediate.Instructions.BOR: //BOR b' a | sets b to b|a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) | value)' true);                      break;                  case Intermediate.Instructions.XOR: //XOR b' a | sets b to b^a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) ^ value));                      break;                  case Intermediate.Instructions.SHR: //SHR b' a | sets b to b>>>a' sets EX to ((b<<16)>>a)&0xffff (logical shift)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)(intermediate >> value)' true);                      AssignToEx((ushort)(intermediate << 16 >> value));                      break;                  case Intermediate.Instructions.ASR: //ASR b' a | sets b to b>>a' sets EX to ((b<<16)>>>a)&0xffff (arithmetic shift) (treats b as signed)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)((int)intermediate >> value)' true);                      AssignToEx((ushort)((int)intermediate << 16 >> value));                      break;                  case Intermediate.Instructions.SHL: //SHL b' a | sets b to b<<a' sets EX to ((b<<a)>>16)&0xffff                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)(intermediate << value)' true);                      AssignToEx((ushort)(intermediate << value >> 16));                      break;                  case Intermediate.Instructions.IFB: //IFB b' a | performs next instruction only if (b&a)!=0                      SkipIf = (GetOperandValue(operandB' OperandPlace.B) & value) != 0;                      break;                  case Intermediate.Instructions.IFC: //IFC b' a | performs next instruction only if (b&a)==0                      SkipIf = (GetOperandValue(operandB' OperandPlace.B) & value) == 0;                      break;                  case Intermediate.Instructions.IFE: //IFE b' a | performs next instruction only if b==a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) == value;                      break;                  case Intermediate.Instructions.IFN: //IFB b' a | performs next instruction only if b!=a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) != value;                      break;                  case Intermediate.Instructions.IFG: //IFG b' a | performs next instruction only if b>a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) > value;                      break;                  case Intermediate.Instructions.IFA: //IFA b' a | performs next instruction only if b>a (signed)                      SkipIf = (int)GetOperandValue(operandB' OperandPlace.B) > (int)value;                      break;                  case Intermediate.Instructions.IFL: //IFL b' a | performs next instruction only if b<a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) < value;                      break;                  case Intermediate.Instructions.IFU: //IFU b' a | performs next instruction only if b<a (signed)                      SkipIf = (int)GetOperandValue(operandB' OperandPlace.B) < (int)value;                      break;                  case Intermediate.Instructions.ADX: //ADX b' a | sets b to b+a+EX' sets EX to 0x0001 if there is an over-flow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) + value + registers[(int)Registers.EX];                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.SBX: //SBX b' a | sets b to b-a+EX' sets EX to 0xFFFF if there is an under-flow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) - value + registers[(int)Registers.EX];                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.STI: //STI b' a | sets b to a' then increases I and J by 1                      AssignToOperand(operandB' value' false);                      registers[(int)Registers.I] += 1;                      registers[(int)Registers.J] += 1;                      break;                  case Intermediate.Instructions.STD: //STI b' a | sets b to a' then decreases I and J by 1                      AssignToOperand(operandB' value' false);                      registers[(int)Registers.I] -= 1;                      registers[(int)Registers.J] -= 1;                      break;                    case Intermediate.Instructions.JSR: //pushes the address of the next instruction to the stack' then sets PC to a                      ram[(ushort)(registers[(int)Registers.SP] - 1)] = registers[(int)Registers.PC];                      registers[(int)Registers.SP] -= 1;                      registers[(int)Registers.PC] = value;                      break;                  case Intermediate.Instructions.HLT:                      throw new Halt();                    case Intermediate.Instructions.INT: //INT a | triggers a software interrupt with message a                      TriggerInterrupt(value);                      break;                  case Intermediate.Instructions.IAG: //IAG a | sets a to IA                       AssignToOperand(operandA' registers[(int)Registers.IA]' true);                      break;                  case Intermediate.Instructions.IAS: //IAS a | sets IA to A                       registers[(int)Registers.IA] = value;                      break;                  case Intermediate.Instructions.RFI: //RFI a | disables interrupt queueing' pops A from the stack' then pops PC from the stack                      protectInterruptQueue.WaitOne();                      interruptQueueEnabled = false;                      registers[(int)Registers.A] = ram[(ushort)(registers[(int)Registers.SP])];                      registers[(int)Registers.PC] = ram[(ushort)(registers[(int)Registers.SP] + 1)];                      registers[(int)Registers.SP] += 2;                      break;                  case Intermediate.Instructions.IAQ: //IAQ a | if a is nonzero' interrupts will be added to the queue                      interruptQueueEnabled = value != 0; //instead of triggered. if a is zero' interrupts will be                      break;                              //triggered as normal again                    case Intermediate.Instructions.HWN: //HWN a | sets a to number of connected hardware devices                      AssignToOperand(operandA' (ushort)devices.Count' true);                      break;                  case Intermediate.Instructions.HWQ: //HWQ a | sets A' B' C' X' Y registers to information about hardware a                       registers[(int)Registers.A] = (ushort)(devices[value].HardwareID & 0xFFFF); //A+(B<<16) is a 32 bit word identifying the hardware id                      registers[(int)Registers.B] = (ushort)((devices[value].HardwareID >> 16) & 0xFFFF);                      registers[(int)Registers.C] = devices[value].Version; //C is the hardware version                      registers[(int)Registers.X] = (ushort)(devices[value].ManufacturerID & 0xFFFF); //X+(Y<<16) is a 32 bit word identifying the manufacturer                      registers[(int)Registers.Y] = (ushort)((devices[value].ManufacturerID >> 16) & 0xFFFF);                      break;                  case Intermediate.Instructions.HWI: //HWI a | sends an interrupt to hardware a                      devices[value].OnInterrupt(this);                      break;              }
Magic Number,DCPUB.Testing,Emulator,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Testing\Emulator.cs,Step,The following statement contains a magic number: switch (ins)              {                  case Intermediate.Instructions.SET: //0x01 | SET b' a | sets b to a                      AssignToOperand(operandB' value' false);                      break;                  case Intermediate.Instructions.ADD: //ADD b' a | sets b to b+a' sets EX to 0x0001 if there's an overflow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) + value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.SUB: //SUB b' a | sets b to b-a' sets EX to 0xffff if there's an underflow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) - value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MUL: //MUL b' a | sets b to b*a' sets EX to ((b*a)>>16)&0xffff (treats b' a as unsigned)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) * value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MLI: //MLI b' a | like MUL' but treat b' a as signed                      intermediate = (UInt32)((short)GetOperandValue(operandB' OperandPlace.B) * (short)value);                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.DIV: //DIV b' a | sets b to b/a' sets EX to ((b<<16)/a)&0xffff. if a==0' sets b and EX to 0 instead. (treats b' a as unsigned)                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      intermediate = value == 0 ? 0 : (UInt32)bValue / value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.DVI: //DVI b' a | like DIV' but treat b' a as signed. Rounds towards 0                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      intermediate = value == 0 ? 0 : (UInt32)((short)bValue / (short)value);                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MOD: //MOD b' a | sets b to b%a. if a==0' sets b to 0 instead.                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      AssignToOperand(operandB' value == 0 ? (ushort)0 : (ushort)(bValue % value)' true);                      break;                  case Intermediate.Instructions.MDI: //MDI b' a | like MOD' but treat b' a as signed. (MDI -7' 16 == -7)                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      AssignToOperand(operandB' value == 0 ? (ushort)0 : (ushort)((short)bValue % (short)value)' true);                      break;                  case Intermediate.Instructions.AND: //AND b' a | sets b to b&a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) & value)' true);                      break;                  case Intermediate.Instructions.BOR: //BOR b' a | sets b to b|a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) | value)' true);                      break;                  case Intermediate.Instructions.XOR: //XOR b' a | sets b to b^a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) ^ value));                      break;                  case Intermediate.Instructions.SHR: //SHR b' a | sets b to b>>>a' sets EX to ((b<<16)>>a)&0xffff (logical shift)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)(intermediate >> value)' true);                      AssignToEx((ushort)(intermediate << 16 >> value));                      break;                  case Intermediate.Instructions.ASR: //ASR b' a | sets b to b>>a' sets EX to ((b<<16)>>>a)&0xffff (arithmetic shift) (treats b as signed)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)((int)intermediate >> value)' true);                      AssignToEx((ushort)((int)intermediate << 16 >> value));                      break;                  case Intermediate.Instructions.SHL: //SHL b' a | sets b to b<<a' sets EX to ((b<<a)>>16)&0xffff                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)(intermediate << value)' true);                      AssignToEx((ushort)(intermediate << value >> 16));                      break;                  case Intermediate.Instructions.IFB: //IFB b' a | performs next instruction only if (b&a)!=0                      SkipIf = (GetOperandValue(operandB' OperandPlace.B) & value) != 0;                      break;                  case Intermediate.Instructions.IFC: //IFC b' a | performs next instruction only if (b&a)==0                      SkipIf = (GetOperandValue(operandB' OperandPlace.B) & value) == 0;                      break;                  case Intermediate.Instructions.IFE: //IFE b' a | performs next instruction only if b==a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) == value;                      break;                  case Intermediate.Instructions.IFN: //IFB b' a | performs next instruction only if b!=a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) != value;                      break;                  case Intermediate.Instructions.IFG: //IFG b' a | performs next instruction only if b>a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) > value;                      break;                  case Intermediate.Instructions.IFA: //IFA b' a | performs next instruction only if b>a (signed)                      SkipIf = (int)GetOperandValue(operandB' OperandPlace.B) > (int)value;                      break;                  case Intermediate.Instructions.IFL: //IFL b' a | performs next instruction only if b<a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) < value;                      break;                  case Intermediate.Instructions.IFU: //IFU b' a | performs next instruction only if b<a (signed)                      SkipIf = (int)GetOperandValue(operandB' OperandPlace.B) < (int)value;                      break;                  case Intermediate.Instructions.ADX: //ADX b' a | sets b to b+a+EX' sets EX to 0x0001 if there is an over-flow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) + value + registers[(int)Registers.EX];                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.SBX: //SBX b' a | sets b to b-a+EX' sets EX to 0xFFFF if there is an under-flow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) - value + registers[(int)Registers.EX];                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.STI: //STI b' a | sets b to a' then increases I and J by 1                      AssignToOperand(operandB' value' false);                      registers[(int)Registers.I] += 1;                      registers[(int)Registers.J] += 1;                      break;                  case Intermediate.Instructions.STD: //STI b' a | sets b to a' then decreases I and J by 1                      AssignToOperand(operandB' value' false);                      registers[(int)Registers.I] -= 1;                      registers[(int)Registers.J] -= 1;                      break;                    case Intermediate.Instructions.JSR: //pushes the address of the next instruction to the stack' then sets PC to a                      ram[(ushort)(registers[(int)Registers.SP] - 1)] = registers[(int)Registers.PC];                      registers[(int)Registers.SP] -= 1;                      registers[(int)Registers.PC] = value;                      break;                  case Intermediate.Instructions.HLT:                      throw new Halt();                    case Intermediate.Instructions.INT: //INT a | triggers a software interrupt with message a                      TriggerInterrupt(value);                      break;                  case Intermediate.Instructions.IAG: //IAG a | sets a to IA                       AssignToOperand(operandA' registers[(int)Registers.IA]' true);                      break;                  case Intermediate.Instructions.IAS: //IAS a | sets IA to A                       registers[(int)Registers.IA] = value;                      break;                  case Intermediate.Instructions.RFI: //RFI a | disables interrupt queueing' pops A from the stack' then pops PC from the stack                      protectInterruptQueue.WaitOne();                      interruptQueueEnabled = false;                      registers[(int)Registers.A] = ram[(ushort)(registers[(int)Registers.SP])];                      registers[(int)Registers.PC] = ram[(ushort)(registers[(int)Registers.SP] + 1)];                      registers[(int)Registers.SP] += 2;                      break;                  case Intermediate.Instructions.IAQ: //IAQ a | if a is nonzero' interrupts will be added to the queue                      interruptQueueEnabled = value != 0; //instead of triggered. if a is zero' interrupts will be                      break;                              //triggered as normal again                    case Intermediate.Instructions.HWN: //HWN a | sets a to number of connected hardware devices                      AssignToOperand(operandA' (ushort)devices.Count' true);                      break;                  case Intermediate.Instructions.HWQ: //HWQ a | sets A' B' C' X' Y registers to information about hardware a                       registers[(int)Registers.A] = (ushort)(devices[value].HardwareID & 0xFFFF); //A+(B<<16) is a 32 bit word identifying the hardware id                      registers[(int)Registers.B] = (ushort)((devices[value].HardwareID >> 16) & 0xFFFF);                      registers[(int)Registers.C] = devices[value].Version; //C is the hardware version                      registers[(int)Registers.X] = (ushort)(devices[value].ManufacturerID & 0xFFFF); //X+(Y<<16) is a 32 bit word identifying the manufacturer                      registers[(int)Registers.Y] = (ushort)((devices[value].ManufacturerID >> 16) & 0xFFFF);                      break;                  case Intermediate.Instructions.HWI: //HWI a | sends an interrupt to hardware a                      devices[value].OnInterrupt(this);                      break;              }
Magic Number,DCPUB.Testing,Emulator,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Testing\Emulator.cs,Step,The following statement contains a magic number: switch (ins)              {                  case Intermediate.Instructions.SET: //0x01 | SET b' a | sets b to a                      AssignToOperand(operandB' value' false);                      break;                  case Intermediate.Instructions.ADD: //ADD b' a | sets b to b+a' sets EX to 0x0001 if there's an overflow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) + value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.SUB: //SUB b' a | sets b to b-a' sets EX to 0xffff if there's an underflow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) - value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MUL: //MUL b' a | sets b to b*a' sets EX to ((b*a)>>16)&0xffff (treats b' a as unsigned)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) * value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MLI: //MLI b' a | like MUL' but treat b' a as signed                      intermediate = (UInt32)((short)GetOperandValue(operandB' OperandPlace.B) * (short)value);                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.DIV: //DIV b' a | sets b to b/a' sets EX to ((b<<16)/a)&0xffff. if a==0' sets b and EX to 0 instead. (treats b' a as unsigned)                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      intermediate = value == 0 ? 0 : (UInt32)bValue / value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.DVI: //DVI b' a | like DIV' but treat b' a as signed. Rounds towards 0                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      intermediate = value == 0 ? 0 : (UInt32)((short)bValue / (short)value);                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MOD: //MOD b' a | sets b to b%a. if a==0' sets b to 0 instead.                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      AssignToOperand(operandB' value == 0 ? (ushort)0 : (ushort)(bValue % value)' true);                      break;                  case Intermediate.Instructions.MDI: //MDI b' a | like MOD' but treat b' a as signed. (MDI -7' 16 == -7)                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      AssignToOperand(operandB' value == 0 ? (ushort)0 : (ushort)((short)bValue % (short)value)' true);                      break;                  case Intermediate.Instructions.AND: //AND b' a | sets b to b&a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) & value)' true);                      break;                  case Intermediate.Instructions.BOR: //BOR b' a | sets b to b|a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) | value)' true);                      break;                  case Intermediate.Instructions.XOR: //XOR b' a | sets b to b^a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) ^ value));                      break;                  case Intermediate.Instructions.SHR: //SHR b' a | sets b to b>>>a' sets EX to ((b<<16)>>a)&0xffff (logical shift)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)(intermediate >> value)' true);                      AssignToEx((ushort)(intermediate << 16 >> value));                      break;                  case Intermediate.Instructions.ASR: //ASR b' a | sets b to b>>a' sets EX to ((b<<16)>>>a)&0xffff (arithmetic shift) (treats b as signed)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)((int)intermediate >> value)' true);                      AssignToEx((ushort)((int)intermediate << 16 >> value));                      break;                  case Intermediate.Instructions.SHL: //SHL b' a | sets b to b<<a' sets EX to ((b<<a)>>16)&0xffff                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)(intermediate << value)' true);                      AssignToEx((ushort)(intermediate << value >> 16));                      break;                  case Intermediate.Instructions.IFB: //IFB b' a | performs next instruction only if (b&a)!=0                      SkipIf = (GetOperandValue(operandB' OperandPlace.B) & value) != 0;                      break;                  case Intermediate.Instructions.IFC: //IFC b' a | performs next instruction only if (b&a)==0                      SkipIf = (GetOperandValue(operandB' OperandPlace.B) & value) == 0;                      break;                  case Intermediate.Instructions.IFE: //IFE b' a | performs next instruction only if b==a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) == value;                      break;                  case Intermediate.Instructions.IFN: //IFB b' a | performs next instruction only if b!=a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) != value;                      break;                  case Intermediate.Instructions.IFG: //IFG b' a | performs next instruction only if b>a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) > value;                      break;                  case Intermediate.Instructions.IFA: //IFA b' a | performs next instruction only if b>a (signed)                      SkipIf = (int)GetOperandValue(operandB' OperandPlace.B) > (int)value;                      break;                  case Intermediate.Instructions.IFL: //IFL b' a | performs next instruction only if b<a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) < value;                      break;                  case Intermediate.Instructions.IFU: //IFU b' a | performs next instruction only if b<a (signed)                      SkipIf = (int)GetOperandValue(operandB' OperandPlace.B) < (int)value;                      break;                  case Intermediate.Instructions.ADX: //ADX b' a | sets b to b+a+EX' sets EX to 0x0001 if there is an over-flow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) + value + registers[(int)Registers.EX];                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.SBX: //SBX b' a | sets b to b-a+EX' sets EX to 0xFFFF if there is an under-flow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) - value + registers[(int)Registers.EX];                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.STI: //STI b' a | sets b to a' then increases I and J by 1                      AssignToOperand(operandB' value' false);                      registers[(int)Registers.I] += 1;                      registers[(int)Registers.J] += 1;                      break;                  case Intermediate.Instructions.STD: //STI b' a | sets b to a' then decreases I and J by 1                      AssignToOperand(operandB' value' false);                      registers[(int)Registers.I] -= 1;                      registers[(int)Registers.J] -= 1;                      break;                    case Intermediate.Instructions.JSR: //pushes the address of the next instruction to the stack' then sets PC to a                      ram[(ushort)(registers[(int)Registers.SP] - 1)] = registers[(int)Registers.PC];                      registers[(int)Registers.SP] -= 1;                      registers[(int)Registers.PC] = value;                      break;                  case Intermediate.Instructions.HLT:                      throw new Halt();                    case Intermediate.Instructions.INT: //INT a | triggers a software interrupt with message a                      TriggerInterrupt(value);                      break;                  case Intermediate.Instructions.IAG: //IAG a | sets a to IA                       AssignToOperand(operandA' registers[(int)Registers.IA]' true);                      break;                  case Intermediate.Instructions.IAS: //IAS a | sets IA to A                       registers[(int)Registers.IA] = value;                      break;                  case Intermediate.Instructions.RFI: //RFI a | disables interrupt queueing' pops A from the stack' then pops PC from the stack                      protectInterruptQueue.WaitOne();                      interruptQueueEnabled = false;                      registers[(int)Registers.A] = ram[(ushort)(registers[(int)Registers.SP])];                      registers[(int)Registers.PC] = ram[(ushort)(registers[(int)Registers.SP] + 1)];                      registers[(int)Registers.SP] += 2;                      break;                  case Intermediate.Instructions.IAQ: //IAQ a | if a is nonzero' interrupts will be added to the queue                      interruptQueueEnabled = value != 0; //instead of triggered. if a is zero' interrupts will be                      break;                              //triggered as normal again                    case Intermediate.Instructions.HWN: //HWN a | sets a to number of connected hardware devices                      AssignToOperand(operandA' (ushort)devices.Count' true);                      break;                  case Intermediate.Instructions.HWQ: //HWQ a | sets A' B' C' X' Y registers to information about hardware a                       registers[(int)Registers.A] = (ushort)(devices[value].HardwareID & 0xFFFF); //A+(B<<16) is a 32 bit word identifying the hardware id                      registers[(int)Registers.B] = (ushort)((devices[value].HardwareID >> 16) & 0xFFFF);                      registers[(int)Registers.C] = devices[value].Version; //C is the hardware version                      registers[(int)Registers.X] = (ushort)(devices[value].ManufacturerID & 0xFFFF); //X+(Y<<16) is a 32 bit word identifying the manufacturer                      registers[(int)Registers.Y] = (ushort)((devices[value].ManufacturerID >> 16) & 0xFFFF);                      break;                  case Intermediate.Instructions.HWI: //HWI a | sends an interrupt to hardware a                      devices[value].OnInterrupt(this);                      break;              }
Magic Number,DCPUB.Testing,Emulator,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Testing\Emulator.cs,Step,The following statement contains a magic number: switch (ins)              {                  case Intermediate.Instructions.SET: //0x01 | SET b' a | sets b to a                      AssignToOperand(operandB' value' false);                      break;                  case Intermediate.Instructions.ADD: //ADD b' a | sets b to b+a' sets EX to 0x0001 if there's an overflow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) + value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.SUB: //SUB b' a | sets b to b-a' sets EX to 0xffff if there's an underflow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) - value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MUL: //MUL b' a | sets b to b*a' sets EX to ((b*a)>>16)&0xffff (treats b' a as unsigned)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) * value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MLI: //MLI b' a | like MUL' but treat b' a as signed                      intermediate = (UInt32)((short)GetOperandValue(operandB' OperandPlace.B) * (short)value);                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.DIV: //DIV b' a | sets b to b/a' sets EX to ((b<<16)/a)&0xffff. if a==0' sets b and EX to 0 instead. (treats b' a as unsigned)                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      intermediate = value == 0 ? 0 : (UInt32)bValue / value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.DVI: //DVI b' a | like DIV' but treat b' a as signed. Rounds towards 0                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      intermediate = value == 0 ? 0 : (UInt32)((short)bValue / (short)value);                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MOD: //MOD b' a | sets b to b%a. if a==0' sets b to 0 instead.                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      AssignToOperand(operandB' value == 0 ? (ushort)0 : (ushort)(bValue % value)' true);                      break;                  case Intermediate.Instructions.MDI: //MDI b' a | like MOD' but treat b' a as signed. (MDI -7' 16 == -7)                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      AssignToOperand(operandB' value == 0 ? (ushort)0 : (ushort)((short)bValue % (short)value)' true);                      break;                  case Intermediate.Instructions.AND: //AND b' a | sets b to b&a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) & value)' true);                      break;                  case Intermediate.Instructions.BOR: //BOR b' a | sets b to b|a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) | value)' true);                      break;                  case Intermediate.Instructions.XOR: //XOR b' a | sets b to b^a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) ^ value));                      break;                  case Intermediate.Instructions.SHR: //SHR b' a | sets b to b>>>a' sets EX to ((b<<16)>>a)&0xffff (logical shift)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)(intermediate >> value)' true);                      AssignToEx((ushort)(intermediate << 16 >> value));                      break;                  case Intermediate.Instructions.ASR: //ASR b' a | sets b to b>>a' sets EX to ((b<<16)>>>a)&0xffff (arithmetic shift) (treats b as signed)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)((int)intermediate >> value)' true);                      AssignToEx((ushort)((int)intermediate << 16 >> value));                      break;                  case Intermediate.Instructions.SHL: //SHL b' a | sets b to b<<a' sets EX to ((b<<a)>>16)&0xffff                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)(intermediate << value)' true);                      AssignToEx((ushort)(intermediate << value >> 16));                      break;                  case Intermediate.Instructions.IFB: //IFB b' a | performs next instruction only if (b&a)!=0                      SkipIf = (GetOperandValue(operandB' OperandPlace.B) & value) != 0;                      break;                  case Intermediate.Instructions.IFC: //IFC b' a | performs next instruction only if (b&a)==0                      SkipIf = (GetOperandValue(operandB' OperandPlace.B) & value) == 0;                      break;                  case Intermediate.Instructions.IFE: //IFE b' a | performs next instruction only if b==a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) == value;                      break;                  case Intermediate.Instructions.IFN: //IFB b' a | performs next instruction only if b!=a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) != value;                      break;                  case Intermediate.Instructions.IFG: //IFG b' a | performs next instruction only if b>a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) > value;                      break;                  case Intermediate.Instructions.IFA: //IFA b' a | performs next instruction only if b>a (signed)                      SkipIf = (int)GetOperandValue(operandB' OperandPlace.B) > (int)value;                      break;                  case Intermediate.Instructions.IFL: //IFL b' a | performs next instruction only if b<a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) < value;                      break;                  case Intermediate.Instructions.IFU: //IFU b' a | performs next instruction only if b<a (signed)                      SkipIf = (int)GetOperandValue(operandB' OperandPlace.B) < (int)value;                      break;                  case Intermediate.Instructions.ADX: //ADX b' a | sets b to b+a+EX' sets EX to 0x0001 if there is an over-flow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) + value + registers[(int)Registers.EX];                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.SBX: //SBX b' a | sets b to b-a+EX' sets EX to 0xFFFF if there is an under-flow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) - value + registers[(int)Registers.EX];                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.STI: //STI b' a | sets b to a' then increases I and J by 1                      AssignToOperand(operandB' value' false);                      registers[(int)Registers.I] += 1;                      registers[(int)Registers.J] += 1;                      break;                  case Intermediate.Instructions.STD: //STI b' a | sets b to a' then decreases I and J by 1                      AssignToOperand(operandB' value' false);                      registers[(int)Registers.I] -= 1;                      registers[(int)Registers.J] -= 1;                      break;                    case Intermediate.Instructions.JSR: //pushes the address of the next instruction to the stack' then sets PC to a                      ram[(ushort)(registers[(int)Registers.SP] - 1)] = registers[(int)Registers.PC];                      registers[(int)Registers.SP] -= 1;                      registers[(int)Registers.PC] = value;                      break;                  case Intermediate.Instructions.HLT:                      throw new Halt();                    case Intermediate.Instructions.INT: //INT a | triggers a software interrupt with message a                      TriggerInterrupt(value);                      break;                  case Intermediate.Instructions.IAG: //IAG a | sets a to IA                       AssignToOperand(operandA' registers[(int)Registers.IA]' true);                      break;                  case Intermediate.Instructions.IAS: //IAS a | sets IA to A                       registers[(int)Registers.IA] = value;                      break;                  case Intermediate.Instructions.RFI: //RFI a | disables interrupt queueing' pops A from the stack' then pops PC from the stack                      protectInterruptQueue.WaitOne();                      interruptQueueEnabled = false;                      registers[(int)Registers.A] = ram[(ushort)(registers[(int)Registers.SP])];                      registers[(int)Registers.PC] = ram[(ushort)(registers[(int)Registers.SP] + 1)];                      registers[(int)Registers.SP] += 2;                      break;                  case Intermediate.Instructions.IAQ: //IAQ a | if a is nonzero' interrupts will be added to the queue                      interruptQueueEnabled = value != 0; //instead of triggered. if a is zero' interrupts will be                      break;                              //triggered as normal again                    case Intermediate.Instructions.HWN: //HWN a | sets a to number of connected hardware devices                      AssignToOperand(operandA' (ushort)devices.Count' true);                      break;                  case Intermediate.Instructions.HWQ: //HWQ a | sets A' B' C' X' Y registers to information about hardware a                       registers[(int)Registers.A] = (ushort)(devices[value].HardwareID & 0xFFFF); //A+(B<<16) is a 32 bit word identifying the hardware id                      registers[(int)Registers.B] = (ushort)((devices[value].HardwareID >> 16) & 0xFFFF);                      registers[(int)Registers.C] = devices[value].Version; //C is the hardware version                      registers[(int)Registers.X] = (ushort)(devices[value].ManufacturerID & 0xFFFF); //X+(Y<<16) is a 32 bit word identifying the manufacturer                      registers[(int)Registers.Y] = (ushort)((devices[value].ManufacturerID >> 16) & 0xFFFF);                      break;                  case Intermediate.Instructions.HWI: //HWI a | sends an interrupt to hardware a                      devices[value].OnInterrupt(this);                      break;              }
Magic Number,DCPUB.Testing,Emulator,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Testing\Emulator.cs,Step,The following statement contains a magic number: switch (ins)              {                  case Intermediate.Instructions.SET: //0x01 | SET b' a | sets b to a                      AssignToOperand(operandB' value' false);                      break;                  case Intermediate.Instructions.ADD: //ADD b' a | sets b to b+a' sets EX to 0x0001 if there's an overflow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) + value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.SUB: //SUB b' a | sets b to b-a' sets EX to 0xffff if there's an underflow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) - value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MUL: //MUL b' a | sets b to b*a' sets EX to ((b*a)>>16)&0xffff (treats b' a as unsigned)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) * value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MLI: //MLI b' a | like MUL' but treat b' a as signed                      intermediate = (UInt32)((short)GetOperandValue(operandB' OperandPlace.B) * (short)value);                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.DIV: //DIV b' a | sets b to b/a' sets EX to ((b<<16)/a)&0xffff. if a==0' sets b and EX to 0 instead. (treats b' a as unsigned)                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      intermediate = value == 0 ? 0 : (UInt32)bValue / value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.DVI: //DVI b' a | like DIV' but treat b' a as signed. Rounds towards 0                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      intermediate = value == 0 ? 0 : (UInt32)((short)bValue / (short)value);                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MOD: //MOD b' a | sets b to b%a. if a==0' sets b to 0 instead.                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      AssignToOperand(operandB' value == 0 ? (ushort)0 : (ushort)(bValue % value)' true);                      break;                  case Intermediate.Instructions.MDI: //MDI b' a | like MOD' but treat b' a as signed. (MDI -7' 16 == -7)                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      AssignToOperand(operandB' value == 0 ? (ushort)0 : (ushort)((short)bValue % (short)value)' true);                      break;                  case Intermediate.Instructions.AND: //AND b' a | sets b to b&a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) & value)' true);                      break;                  case Intermediate.Instructions.BOR: //BOR b' a | sets b to b|a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) | value)' true);                      break;                  case Intermediate.Instructions.XOR: //XOR b' a | sets b to b^a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) ^ value));                      break;                  case Intermediate.Instructions.SHR: //SHR b' a | sets b to b>>>a' sets EX to ((b<<16)>>a)&0xffff (logical shift)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)(intermediate >> value)' true);                      AssignToEx((ushort)(intermediate << 16 >> value));                      break;                  case Intermediate.Instructions.ASR: //ASR b' a | sets b to b>>a' sets EX to ((b<<16)>>>a)&0xffff (arithmetic shift) (treats b as signed)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)((int)intermediate >> value)' true);                      AssignToEx((ushort)((int)intermediate << 16 >> value));                      break;                  case Intermediate.Instructions.SHL: //SHL b' a | sets b to b<<a' sets EX to ((b<<a)>>16)&0xffff                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)(intermediate << value)' true);                      AssignToEx((ushort)(intermediate << value >> 16));                      break;                  case Intermediate.Instructions.IFB: //IFB b' a | performs next instruction only if (b&a)!=0                      SkipIf = (GetOperandValue(operandB' OperandPlace.B) & value) != 0;                      break;                  case Intermediate.Instructions.IFC: //IFC b' a | performs next instruction only if (b&a)==0                      SkipIf = (GetOperandValue(operandB' OperandPlace.B) & value) == 0;                      break;                  case Intermediate.Instructions.IFE: //IFE b' a | performs next instruction only if b==a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) == value;                      break;                  case Intermediate.Instructions.IFN: //IFB b' a | performs next instruction only if b!=a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) != value;                      break;                  case Intermediate.Instructions.IFG: //IFG b' a | performs next instruction only if b>a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) > value;                      break;                  case Intermediate.Instructions.IFA: //IFA b' a | performs next instruction only if b>a (signed)                      SkipIf = (int)GetOperandValue(operandB' OperandPlace.B) > (int)value;                      break;                  case Intermediate.Instructions.IFL: //IFL b' a | performs next instruction only if b<a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) < value;                      break;                  case Intermediate.Instructions.IFU: //IFU b' a | performs next instruction only if b<a (signed)                      SkipIf = (int)GetOperandValue(operandB' OperandPlace.B) < (int)value;                      break;                  case Intermediate.Instructions.ADX: //ADX b' a | sets b to b+a+EX' sets EX to 0x0001 if there is an over-flow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) + value + registers[(int)Registers.EX];                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.SBX: //SBX b' a | sets b to b-a+EX' sets EX to 0xFFFF if there is an under-flow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) - value + registers[(int)Registers.EX];                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.STI: //STI b' a | sets b to a' then increases I and J by 1                      AssignToOperand(operandB' value' false);                      registers[(int)Registers.I] += 1;                      registers[(int)Registers.J] += 1;                      break;                  case Intermediate.Instructions.STD: //STI b' a | sets b to a' then decreases I and J by 1                      AssignToOperand(operandB' value' false);                      registers[(int)Registers.I] -= 1;                      registers[(int)Registers.J] -= 1;                      break;                    case Intermediate.Instructions.JSR: //pushes the address of the next instruction to the stack' then sets PC to a                      ram[(ushort)(registers[(int)Registers.SP] - 1)] = registers[(int)Registers.PC];                      registers[(int)Registers.SP] -= 1;                      registers[(int)Registers.PC] = value;                      break;                  case Intermediate.Instructions.HLT:                      throw new Halt();                    case Intermediate.Instructions.INT: //INT a | triggers a software interrupt with message a                      TriggerInterrupt(value);                      break;                  case Intermediate.Instructions.IAG: //IAG a | sets a to IA                       AssignToOperand(operandA' registers[(int)Registers.IA]' true);                      break;                  case Intermediate.Instructions.IAS: //IAS a | sets IA to A                       registers[(int)Registers.IA] = value;                      break;                  case Intermediate.Instructions.RFI: //RFI a | disables interrupt queueing' pops A from the stack' then pops PC from the stack                      protectInterruptQueue.WaitOne();                      interruptQueueEnabled = false;                      registers[(int)Registers.A] = ram[(ushort)(registers[(int)Registers.SP])];                      registers[(int)Registers.PC] = ram[(ushort)(registers[(int)Registers.SP] + 1)];                      registers[(int)Registers.SP] += 2;                      break;                  case Intermediate.Instructions.IAQ: //IAQ a | if a is nonzero' interrupts will be added to the queue                      interruptQueueEnabled = value != 0; //instead of triggered. if a is zero' interrupts will be                      break;                              //triggered as normal again                    case Intermediate.Instructions.HWN: //HWN a | sets a to number of connected hardware devices                      AssignToOperand(operandA' (ushort)devices.Count' true);                      break;                  case Intermediate.Instructions.HWQ: //HWQ a | sets A' B' C' X' Y registers to information about hardware a                       registers[(int)Registers.A] = (ushort)(devices[value].HardwareID & 0xFFFF); //A+(B<<16) is a 32 bit word identifying the hardware id                      registers[(int)Registers.B] = (ushort)((devices[value].HardwareID >> 16) & 0xFFFF);                      registers[(int)Registers.C] = devices[value].Version; //C is the hardware version                      registers[(int)Registers.X] = (ushort)(devices[value].ManufacturerID & 0xFFFF); //X+(Y<<16) is a 32 bit word identifying the manufacturer                      registers[(int)Registers.Y] = (ushort)((devices[value].ManufacturerID >> 16) & 0xFFFF);                      break;                  case Intermediate.Instructions.HWI: //HWI a | sends an interrupt to hardware a                      devices[value].OnInterrupt(this);                      break;              }
Magic Number,DCPUB.Testing,Emulator,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Testing\Emulator.cs,Step,The following statement contains a magic number: switch (ins)              {                  case Intermediate.Instructions.SET: //0x01 | SET b' a | sets b to a                      AssignToOperand(operandB' value' false);                      break;                  case Intermediate.Instructions.ADD: //ADD b' a | sets b to b+a' sets EX to 0x0001 if there's an overflow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) + value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.SUB: //SUB b' a | sets b to b-a' sets EX to 0xffff if there's an underflow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) - value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MUL: //MUL b' a | sets b to b*a' sets EX to ((b*a)>>16)&0xffff (treats b' a as unsigned)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) * value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MLI: //MLI b' a | like MUL' but treat b' a as signed                      intermediate = (UInt32)((short)GetOperandValue(operandB' OperandPlace.B) * (short)value);                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.DIV: //DIV b' a | sets b to b/a' sets EX to ((b<<16)/a)&0xffff. if a==0' sets b and EX to 0 instead. (treats b' a as unsigned)                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      intermediate = value == 0 ? 0 : (UInt32)bValue / value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.DVI: //DVI b' a | like DIV' but treat b' a as signed. Rounds towards 0                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      intermediate = value == 0 ? 0 : (UInt32)((short)bValue / (short)value);                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MOD: //MOD b' a | sets b to b%a. if a==0' sets b to 0 instead.                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      AssignToOperand(operandB' value == 0 ? (ushort)0 : (ushort)(bValue % value)' true);                      break;                  case Intermediate.Instructions.MDI: //MDI b' a | like MOD' but treat b' a as signed. (MDI -7' 16 == -7)                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      AssignToOperand(operandB' value == 0 ? (ushort)0 : (ushort)((short)bValue % (short)value)' true);                      break;                  case Intermediate.Instructions.AND: //AND b' a | sets b to b&a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) & value)' true);                      break;                  case Intermediate.Instructions.BOR: //BOR b' a | sets b to b|a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) | value)' true);                      break;                  case Intermediate.Instructions.XOR: //XOR b' a | sets b to b^a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) ^ value));                      break;                  case Intermediate.Instructions.SHR: //SHR b' a | sets b to b>>>a' sets EX to ((b<<16)>>a)&0xffff (logical shift)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)(intermediate >> value)' true);                      AssignToEx((ushort)(intermediate << 16 >> value));                      break;                  case Intermediate.Instructions.ASR: //ASR b' a | sets b to b>>a' sets EX to ((b<<16)>>>a)&0xffff (arithmetic shift) (treats b as signed)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)((int)intermediate >> value)' true);                      AssignToEx((ushort)((int)intermediate << 16 >> value));                      break;                  case Intermediate.Instructions.SHL: //SHL b' a | sets b to b<<a' sets EX to ((b<<a)>>16)&0xffff                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)(intermediate << value)' true);                      AssignToEx((ushort)(intermediate << value >> 16));                      break;                  case Intermediate.Instructions.IFB: //IFB b' a | performs next instruction only if (b&a)!=0                      SkipIf = (GetOperandValue(operandB' OperandPlace.B) & value) != 0;                      break;                  case Intermediate.Instructions.IFC: //IFC b' a | performs next instruction only if (b&a)==0                      SkipIf = (GetOperandValue(operandB' OperandPlace.B) & value) == 0;                      break;                  case Intermediate.Instructions.IFE: //IFE b' a | performs next instruction only if b==a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) == value;                      break;                  case Intermediate.Instructions.IFN: //IFB b' a | performs next instruction only if b!=a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) != value;                      break;                  case Intermediate.Instructions.IFG: //IFG b' a | performs next instruction only if b>a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) > value;                      break;                  case Intermediate.Instructions.IFA: //IFA b' a | performs next instruction only if b>a (signed)                      SkipIf = (int)GetOperandValue(operandB' OperandPlace.B) > (int)value;                      break;                  case Intermediate.Instructions.IFL: //IFL b' a | performs next instruction only if b<a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) < value;                      break;                  case Intermediate.Instructions.IFU: //IFU b' a | performs next instruction only if b<a (signed)                      SkipIf = (int)GetOperandValue(operandB' OperandPlace.B) < (int)value;                      break;                  case Intermediate.Instructions.ADX: //ADX b' a | sets b to b+a+EX' sets EX to 0x0001 if there is an over-flow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) + value + registers[(int)Registers.EX];                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.SBX: //SBX b' a | sets b to b-a+EX' sets EX to 0xFFFF if there is an under-flow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) - value + registers[(int)Registers.EX];                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.STI: //STI b' a | sets b to a' then increases I and J by 1                      AssignToOperand(operandB' value' false);                      registers[(int)Registers.I] += 1;                      registers[(int)Registers.J] += 1;                      break;                  case Intermediate.Instructions.STD: //STI b' a | sets b to a' then decreases I and J by 1                      AssignToOperand(operandB' value' false);                      registers[(int)Registers.I] -= 1;                      registers[(int)Registers.J] -= 1;                      break;                    case Intermediate.Instructions.JSR: //pushes the address of the next instruction to the stack' then sets PC to a                      ram[(ushort)(registers[(int)Registers.SP] - 1)] = registers[(int)Registers.PC];                      registers[(int)Registers.SP] -= 1;                      registers[(int)Registers.PC] = value;                      break;                  case Intermediate.Instructions.HLT:                      throw new Halt();                    case Intermediate.Instructions.INT: //INT a | triggers a software interrupt with message a                      TriggerInterrupt(value);                      break;                  case Intermediate.Instructions.IAG: //IAG a | sets a to IA                       AssignToOperand(operandA' registers[(int)Registers.IA]' true);                      break;                  case Intermediate.Instructions.IAS: //IAS a | sets IA to A                       registers[(int)Registers.IA] = value;                      break;                  case Intermediate.Instructions.RFI: //RFI a | disables interrupt queueing' pops A from the stack' then pops PC from the stack                      protectInterruptQueue.WaitOne();                      interruptQueueEnabled = false;                      registers[(int)Registers.A] = ram[(ushort)(registers[(int)Registers.SP])];                      registers[(int)Registers.PC] = ram[(ushort)(registers[(int)Registers.SP] + 1)];                      registers[(int)Registers.SP] += 2;                      break;                  case Intermediate.Instructions.IAQ: //IAQ a | if a is nonzero' interrupts will be added to the queue                      interruptQueueEnabled = value != 0; //instead of triggered. if a is zero' interrupts will be                      break;                              //triggered as normal again                    case Intermediate.Instructions.HWN: //HWN a | sets a to number of connected hardware devices                      AssignToOperand(operandA' (ushort)devices.Count' true);                      break;                  case Intermediate.Instructions.HWQ: //HWQ a | sets A' B' C' X' Y registers to information about hardware a                       registers[(int)Registers.A] = (ushort)(devices[value].HardwareID & 0xFFFF); //A+(B<<16) is a 32 bit word identifying the hardware id                      registers[(int)Registers.B] = (ushort)((devices[value].HardwareID >> 16) & 0xFFFF);                      registers[(int)Registers.C] = devices[value].Version; //C is the hardware version                      registers[(int)Registers.X] = (ushort)(devices[value].ManufacturerID & 0xFFFF); //X+(Y<<16) is a 32 bit word identifying the manufacturer                      registers[(int)Registers.Y] = (ushort)((devices[value].ManufacturerID >> 16) & 0xFFFF);                      break;                  case Intermediate.Instructions.HWI: //HWI a | sends an interrupt to hardware a                      devices[value].OnInterrupt(this);                      break;              }
Magic Number,DCPUB.Testing,Emulator,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Testing\Emulator.cs,Step,The following statement contains a magic number: switch (ins)              {                  case Intermediate.Instructions.SET: //0x01 | SET b' a | sets b to a                      AssignToOperand(operandB' value' false);                      break;                  case Intermediate.Instructions.ADD: //ADD b' a | sets b to b+a' sets EX to 0x0001 if there's an overflow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) + value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.SUB: //SUB b' a | sets b to b-a' sets EX to 0xffff if there's an underflow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) - value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MUL: //MUL b' a | sets b to b*a' sets EX to ((b*a)>>16)&0xffff (treats b' a as unsigned)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) * value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MLI: //MLI b' a | like MUL' but treat b' a as signed                      intermediate = (UInt32)((short)GetOperandValue(operandB' OperandPlace.B) * (short)value);                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.DIV: //DIV b' a | sets b to b/a' sets EX to ((b<<16)/a)&0xffff. if a==0' sets b and EX to 0 instead. (treats b' a as unsigned)                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      intermediate = value == 0 ? 0 : (UInt32)bValue / value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.DVI: //DVI b' a | like DIV' but treat b' a as signed. Rounds towards 0                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      intermediate = value == 0 ? 0 : (UInt32)((short)bValue / (short)value);                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MOD: //MOD b' a | sets b to b%a. if a==0' sets b to 0 instead.                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      AssignToOperand(operandB' value == 0 ? (ushort)0 : (ushort)(bValue % value)' true);                      break;                  case Intermediate.Instructions.MDI: //MDI b' a | like MOD' but treat b' a as signed. (MDI -7' 16 == -7)                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      AssignToOperand(operandB' value == 0 ? (ushort)0 : (ushort)((short)bValue % (short)value)' true);                      break;                  case Intermediate.Instructions.AND: //AND b' a | sets b to b&a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) & value)' true);                      break;                  case Intermediate.Instructions.BOR: //BOR b' a | sets b to b|a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) | value)' true);                      break;                  case Intermediate.Instructions.XOR: //XOR b' a | sets b to b^a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) ^ value));                      break;                  case Intermediate.Instructions.SHR: //SHR b' a | sets b to b>>>a' sets EX to ((b<<16)>>a)&0xffff (logical shift)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)(intermediate >> value)' true);                      AssignToEx((ushort)(intermediate << 16 >> value));                      break;                  case Intermediate.Instructions.ASR: //ASR b' a | sets b to b>>a' sets EX to ((b<<16)>>>a)&0xffff (arithmetic shift) (treats b as signed)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)((int)intermediate >> value)' true);                      AssignToEx((ushort)((int)intermediate << 16 >> value));                      break;                  case Intermediate.Instructions.SHL: //SHL b' a | sets b to b<<a' sets EX to ((b<<a)>>16)&0xffff                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)(intermediate << value)' true);                      AssignToEx((ushort)(intermediate << value >> 16));                      break;                  case Intermediate.Instructions.IFB: //IFB b' a | performs next instruction only if (b&a)!=0                      SkipIf = (GetOperandValue(operandB' OperandPlace.B) & value) != 0;                      break;                  case Intermediate.Instructions.IFC: //IFC b' a | performs next instruction only if (b&a)==0                      SkipIf = (GetOperandValue(operandB' OperandPlace.B) & value) == 0;                      break;                  case Intermediate.Instructions.IFE: //IFE b' a | performs next instruction only if b==a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) == value;                      break;                  case Intermediate.Instructions.IFN: //IFB b' a | performs next instruction only if b!=a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) != value;                      break;                  case Intermediate.Instructions.IFG: //IFG b' a | performs next instruction only if b>a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) > value;                      break;                  case Intermediate.Instructions.IFA: //IFA b' a | performs next instruction only if b>a (signed)                      SkipIf = (int)GetOperandValue(operandB' OperandPlace.B) > (int)value;                      break;                  case Intermediate.Instructions.IFL: //IFL b' a | performs next instruction only if b<a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) < value;                      break;                  case Intermediate.Instructions.IFU: //IFU b' a | performs next instruction only if b<a (signed)                      SkipIf = (int)GetOperandValue(operandB' OperandPlace.B) < (int)value;                      break;                  case Intermediate.Instructions.ADX: //ADX b' a | sets b to b+a+EX' sets EX to 0x0001 if there is an over-flow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) + value + registers[(int)Registers.EX];                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.SBX: //SBX b' a | sets b to b-a+EX' sets EX to 0xFFFF if there is an under-flow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) - value + registers[(int)Registers.EX];                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.STI: //STI b' a | sets b to a' then increases I and J by 1                      AssignToOperand(operandB' value' false);                      registers[(int)Registers.I] += 1;                      registers[(int)Registers.J] += 1;                      break;                  case Intermediate.Instructions.STD: //STI b' a | sets b to a' then decreases I and J by 1                      AssignToOperand(operandB' value' false);                      registers[(int)Registers.I] -= 1;                      registers[(int)Registers.J] -= 1;                      break;                    case Intermediate.Instructions.JSR: //pushes the address of the next instruction to the stack' then sets PC to a                      ram[(ushort)(registers[(int)Registers.SP] - 1)] = registers[(int)Registers.PC];                      registers[(int)Registers.SP] -= 1;                      registers[(int)Registers.PC] = value;                      break;                  case Intermediate.Instructions.HLT:                      throw new Halt();                    case Intermediate.Instructions.INT: //INT a | triggers a software interrupt with message a                      TriggerInterrupt(value);                      break;                  case Intermediate.Instructions.IAG: //IAG a | sets a to IA                       AssignToOperand(operandA' registers[(int)Registers.IA]' true);                      break;                  case Intermediate.Instructions.IAS: //IAS a | sets IA to A                       registers[(int)Registers.IA] = value;                      break;                  case Intermediate.Instructions.RFI: //RFI a | disables interrupt queueing' pops A from the stack' then pops PC from the stack                      protectInterruptQueue.WaitOne();                      interruptQueueEnabled = false;                      registers[(int)Registers.A] = ram[(ushort)(registers[(int)Registers.SP])];                      registers[(int)Registers.PC] = ram[(ushort)(registers[(int)Registers.SP] + 1)];                      registers[(int)Registers.SP] += 2;                      break;                  case Intermediate.Instructions.IAQ: //IAQ a | if a is nonzero' interrupts will be added to the queue                      interruptQueueEnabled = value != 0; //instead of triggered. if a is zero' interrupts will be                      break;                              //triggered as normal again                    case Intermediate.Instructions.HWN: //HWN a | sets a to number of connected hardware devices                      AssignToOperand(operandA' (ushort)devices.Count' true);                      break;                  case Intermediate.Instructions.HWQ: //HWQ a | sets A' B' C' X' Y registers to information about hardware a                       registers[(int)Registers.A] = (ushort)(devices[value].HardwareID & 0xFFFF); //A+(B<<16) is a 32 bit word identifying the hardware id                      registers[(int)Registers.B] = (ushort)((devices[value].HardwareID >> 16) & 0xFFFF);                      registers[(int)Registers.C] = devices[value].Version; //C is the hardware version                      registers[(int)Registers.X] = (ushort)(devices[value].ManufacturerID & 0xFFFF); //X+(Y<<16) is a 32 bit word identifying the manufacturer                      registers[(int)Registers.Y] = (ushort)((devices[value].ManufacturerID >> 16) & 0xFFFF);                      break;                  case Intermediate.Instructions.HWI: //HWI a | sends an interrupt to hardware a                      devices[value].OnInterrupt(this);                      break;              }
Magic Number,DCPUB.Testing,Emulator,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Testing\Emulator.cs,Step,The following statement contains a magic number: switch (ins)              {                  case Intermediate.Instructions.SET: //0x01 | SET b' a | sets b to a                      AssignToOperand(operandB' value' false);                      break;                  case Intermediate.Instructions.ADD: //ADD b' a | sets b to b+a' sets EX to 0x0001 if there's an overflow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) + value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.SUB: //SUB b' a | sets b to b-a' sets EX to 0xffff if there's an underflow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) - value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MUL: //MUL b' a | sets b to b*a' sets EX to ((b*a)>>16)&0xffff (treats b' a as unsigned)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) * value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MLI: //MLI b' a | like MUL' but treat b' a as signed                      intermediate = (UInt32)((short)GetOperandValue(operandB' OperandPlace.B) * (short)value);                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.DIV: //DIV b' a | sets b to b/a' sets EX to ((b<<16)/a)&0xffff. if a==0' sets b and EX to 0 instead. (treats b' a as unsigned)                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      intermediate = value == 0 ? 0 : (UInt32)bValue / value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.DVI: //DVI b' a | like DIV' but treat b' a as signed. Rounds towards 0                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      intermediate = value == 0 ? 0 : (UInt32)((short)bValue / (short)value);                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MOD: //MOD b' a | sets b to b%a. if a==0' sets b to 0 instead.                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      AssignToOperand(operandB' value == 0 ? (ushort)0 : (ushort)(bValue % value)' true);                      break;                  case Intermediate.Instructions.MDI: //MDI b' a | like MOD' but treat b' a as signed. (MDI -7' 16 == -7)                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      AssignToOperand(operandB' value == 0 ? (ushort)0 : (ushort)((short)bValue % (short)value)' true);                      break;                  case Intermediate.Instructions.AND: //AND b' a | sets b to b&a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) & value)' true);                      break;                  case Intermediate.Instructions.BOR: //BOR b' a | sets b to b|a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) | value)' true);                      break;                  case Intermediate.Instructions.XOR: //XOR b' a | sets b to b^a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) ^ value));                      break;                  case Intermediate.Instructions.SHR: //SHR b' a | sets b to b>>>a' sets EX to ((b<<16)>>a)&0xffff (logical shift)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)(intermediate >> value)' true);                      AssignToEx((ushort)(intermediate << 16 >> value));                      break;                  case Intermediate.Instructions.ASR: //ASR b' a | sets b to b>>a' sets EX to ((b<<16)>>>a)&0xffff (arithmetic shift) (treats b as signed)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)((int)intermediate >> value)' true);                      AssignToEx((ushort)((int)intermediate << 16 >> value));                      break;                  case Intermediate.Instructions.SHL: //SHL b' a | sets b to b<<a' sets EX to ((b<<a)>>16)&0xffff                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)(intermediate << value)' true);                      AssignToEx((ushort)(intermediate << value >> 16));                      break;                  case Intermediate.Instructions.IFB: //IFB b' a | performs next instruction only if (b&a)!=0                      SkipIf = (GetOperandValue(operandB' OperandPlace.B) & value) != 0;                      break;                  case Intermediate.Instructions.IFC: //IFC b' a | performs next instruction only if (b&a)==0                      SkipIf = (GetOperandValue(operandB' OperandPlace.B) & value) == 0;                      break;                  case Intermediate.Instructions.IFE: //IFE b' a | performs next instruction only if b==a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) == value;                      break;                  case Intermediate.Instructions.IFN: //IFB b' a | performs next instruction only if b!=a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) != value;                      break;                  case Intermediate.Instructions.IFG: //IFG b' a | performs next instruction only if b>a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) > value;                      break;                  case Intermediate.Instructions.IFA: //IFA b' a | performs next instruction only if b>a (signed)                      SkipIf = (int)GetOperandValue(operandB' OperandPlace.B) > (int)value;                      break;                  case Intermediate.Instructions.IFL: //IFL b' a | performs next instruction only if b<a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) < value;                      break;                  case Intermediate.Instructions.IFU: //IFU b' a | performs next instruction only if b<a (signed)                      SkipIf = (int)GetOperandValue(operandB' OperandPlace.B) < (int)value;                      break;                  case Intermediate.Instructions.ADX: //ADX b' a | sets b to b+a+EX' sets EX to 0x0001 if there is an over-flow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) + value + registers[(int)Registers.EX];                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.SBX: //SBX b' a | sets b to b-a+EX' sets EX to 0xFFFF if there is an under-flow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) - value + registers[(int)Registers.EX];                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.STI: //STI b' a | sets b to a' then increases I and J by 1                      AssignToOperand(operandB' value' false);                      registers[(int)Registers.I] += 1;                      registers[(int)Registers.J] += 1;                      break;                  case Intermediate.Instructions.STD: //STI b' a | sets b to a' then decreases I and J by 1                      AssignToOperand(operandB' value' false);                      registers[(int)Registers.I] -= 1;                      registers[(int)Registers.J] -= 1;                      break;                    case Intermediate.Instructions.JSR: //pushes the address of the next instruction to the stack' then sets PC to a                      ram[(ushort)(registers[(int)Registers.SP] - 1)] = registers[(int)Registers.PC];                      registers[(int)Registers.SP] -= 1;                      registers[(int)Registers.PC] = value;                      break;                  case Intermediate.Instructions.HLT:                      throw new Halt();                    case Intermediate.Instructions.INT: //INT a | triggers a software interrupt with message a                      TriggerInterrupt(value);                      break;                  case Intermediate.Instructions.IAG: //IAG a | sets a to IA                       AssignToOperand(operandA' registers[(int)Registers.IA]' true);                      break;                  case Intermediate.Instructions.IAS: //IAS a | sets IA to A                       registers[(int)Registers.IA] = value;                      break;                  case Intermediate.Instructions.RFI: //RFI a | disables interrupt queueing' pops A from the stack' then pops PC from the stack                      protectInterruptQueue.WaitOne();                      interruptQueueEnabled = false;                      registers[(int)Registers.A] = ram[(ushort)(registers[(int)Registers.SP])];                      registers[(int)Registers.PC] = ram[(ushort)(registers[(int)Registers.SP] + 1)];                      registers[(int)Registers.SP] += 2;                      break;                  case Intermediate.Instructions.IAQ: //IAQ a | if a is nonzero' interrupts will be added to the queue                      interruptQueueEnabled = value != 0; //instead of triggered. if a is zero' interrupts will be                      break;                              //triggered as normal again                    case Intermediate.Instructions.HWN: //HWN a | sets a to number of connected hardware devices                      AssignToOperand(operandA' (ushort)devices.Count' true);                      break;                  case Intermediate.Instructions.HWQ: //HWQ a | sets A' B' C' X' Y registers to information about hardware a                       registers[(int)Registers.A] = (ushort)(devices[value].HardwareID & 0xFFFF); //A+(B<<16) is a 32 bit word identifying the hardware id                      registers[(int)Registers.B] = (ushort)((devices[value].HardwareID >> 16) & 0xFFFF);                      registers[(int)Registers.C] = devices[value].Version; //C is the hardware version                      registers[(int)Registers.X] = (ushort)(devices[value].ManufacturerID & 0xFFFF); //X+(Y<<16) is a 32 bit word identifying the manufacturer                      registers[(int)Registers.Y] = (ushort)((devices[value].ManufacturerID >> 16) & 0xFFFF);                      break;                  case Intermediate.Instructions.HWI: //HWI a | sends an interrupt to hardware a                      devices[value].OnInterrupt(this);                      break;              }
Magic Number,DCPUB.Testing,Emulator,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Testing\Emulator.cs,Step,The following statement contains a magic number: switch (ins)              {                  case Intermediate.Instructions.SET: //0x01 | SET b' a | sets b to a                      AssignToOperand(operandB' value' false);                      break;                  case Intermediate.Instructions.ADD: //ADD b' a | sets b to b+a' sets EX to 0x0001 if there's an overflow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) + value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.SUB: //SUB b' a | sets b to b-a' sets EX to 0xffff if there's an underflow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) - value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MUL: //MUL b' a | sets b to b*a' sets EX to ((b*a)>>16)&0xffff (treats b' a as unsigned)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) * value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MLI: //MLI b' a | like MUL' but treat b' a as signed                      intermediate = (UInt32)((short)GetOperandValue(operandB' OperandPlace.B) * (short)value);                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.DIV: //DIV b' a | sets b to b/a' sets EX to ((b<<16)/a)&0xffff. if a==0' sets b and EX to 0 instead. (treats b' a as unsigned)                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      intermediate = value == 0 ? 0 : (UInt32)bValue / value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.DVI: //DVI b' a | like DIV' but treat b' a as signed. Rounds towards 0                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      intermediate = value == 0 ? 0 : (UInt32)((short)bValue / (short)value);                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MOD: //MOD b' a | sets b to b%a. if a==0' sets b to 0 instead.                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      AssignToOperand(operandB' value == 0 ? (ushort)0 : (ushort)(bValue % value)' true);                      break;                  case Intermediate.Instructions.MDI: //MDI b' a | like MOD' but treat b' a as signed. (MDI -7' 16 == -7)                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      AssignToOperand(operandB' value == 0 ? (ushort)0 : (ushort)((short)bValue % (short)value)' true);                      break;                  case Intermediate.Instructions.AND: //AND b' a | sets b to b&a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) & value)' true);                      break;                  case Intermediate.Instructions.BOR: //BOR b' a | sets b to b|a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) | value)' true);                      break;                  case Intermediate.Instructions.XOR: //XOR b' a | sets b to b^a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) ^ value));                      break;                  case Intermediate.Instructions.SHR: //SHR b' a | sets b to b>>>a' sets EX to ((b<<16)>>a)&0xffff (logical shift)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)(intermediate >> value)' true);                      AssignToEx((ushort)(intermediate << 16 >> value));                      break;                  case Intermediate.Instructions.ASR: //ASR b' a | sets b to b>>a' sets EX to ((b<<16)>>>a)&0xffff (arithmetic shift) (treats b as signed)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)((int)intermediate >> value)' true);                      AssignToEx((ushort)((int)intermediate << 16 >> value));                      break;                  case Intermediate.Instructions.SHL: //SHL b' a | sets b to b<<a' sets EX to ((b<<a)>>16)&0xffff                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)(intermediate << value)' true);                      AssignToEx((ushort)(intermediate << value >> 16));                      break;                  case Intermediate.Instructions.IFB: //IFB b' a | performs next instruction only if (b&a)!=0                      SkipIf = (GetOperandValue(operandB' OperandPlace.B) & value) != 0;                      break;                  case Intermediate.Instructions.IFC: //IFC b' a | performs next instruction only if (b&a)==0                      SkipIf = (GetOperandValue(operandB' OperandPlace.B) & value) == 0;                      break;                  case Intermediate.Instructions.IFE: //IFE b' a | performs next instruction only if b==a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) == value;                      break;                  case Intermediate.Instructions.IFN: //IFB b' a | performs next instruction only if b!=a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) != value;                      break;                  case Intermediate.Instructions.IFG: //IFG b' a | performs next instruction only if b>a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) > value;                      break;                  case Intermediate.Instructions.IFA: //IFA b' a | performs next instruction only if b>a (signed)                      SkipIf = (int)GetOperandValue(operandB' OperandPlace.B) > (int)value;                      break;                  case Intermediate.Instructions.IFL: //IFL b' a | performs next instruction only if b<a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) < value;                      break;                  case Intermediate.Instructions.IFU: //IFU b' a | performs next instruction only if b<a (signed)                      SkipIf = (int)GetOperandValue(operandB' OperandPlace.B) < (int)value;                      break;                  case Intermediate.Instructions.ADX: //ADX b' a | sets b to b+a+EX' sets EX to 0x0001 if there is an over-flow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) + value + registers[(int)Registers.EX];                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.SBX: //SBX b' a | sets b to b-a+EX' sets EX to 0xFFFF if there is an under-flow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) - value + registers[(int)Registers.EX];                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.STI: //STI b' a | sets b to a' then increases I and J by 1                      AssignToOperand(operandB' value' false);                      registers[(int)Registers.I] += 1;                      registers[(int)Registers.J] += 1;                      break;                  case Intermediate.Instructions.STD: //STI b' a | sets b to a' then decreases I and J by 1                      AssignToOperand(operandB' value' false);                      registers[(int)Registers.I] -= 1;                      registers[(int)Registers.J] -= 1;                      break;                    case Intermediate.Instructions.JSR: //pushes the address of the next instruction to the stack' then sets PC to a                      ram[(ushort)(registers[(int)Registers.SP] - 1)] = registers[(int)Registers.PC];                      registers[(int)Registers.SP] -= 1;                      registers[(int)Registers.PC] = value;                      break;                  case Intermediate.Instructions.HLT:                      throw new Halt();                    case Intermediate.Instructions.INT: //INT a | triggers a software interrupt with message a                      TriggerInterrupt(value);                      break;                  case Intermediate.Instructions.IAG: //IAG a | sets a to IA                       AssignToOperand(operandA' registers[(int)Registers.IA]' true);                      break;                  case Intermediate.Instructions.IAS: //IAS a | sets IA to A                       registers[(int)Registers.IA] = value;                      break;                  case Intermediate.Instructions.RFI: //RFI a | disables interrupt queueing' pops A from the stack' then pops PC from the stack                      protectInterruptQueue.WaitOne();                      interruptQueueEnabled = false;                      registers[(int)Registers.A] = ram[(ushort)(registers[(int)Registers.SP])];                      registers[(int)Registers.PC] = ram[(ushort)(registers[(int)Registers.SP] + 1)];                      registers[(int)Registers.SP] += 2;                      break;                  case Intermediate.Instructions.IAQ: //IAQ a | if a is nonzero' interrupts will be added to the queue                      interruptQueueEnabled = value != 0; //instead of triggered. if a is zero' interrupts will be                      break;                              //triggered as normal again                    case Intermediate.Instructions.HWN: //HWN a | sets a to number of connected hardware devices                      AssignToOperand(operandA' (ushort)devices.Count' true);                      break;                  case Intermediate.Instructions.HWQ: //HWQ a | sets A' B' C' X' Y registers to information about hardware a                       registers[(int)Registers.A] = (ushort)(devices[value].HardwareID & 0xFFFF); //A+(B<<16) is a 32 bit word identifying the hardware id                      registers[(int)Registers.B] = (ushort)((devices[value].HardwareID >> 16) & 0xFFFF);                      registers[(int)Registers.C] = devices[value].Version; //C is the hardware version                      registers[(int)Registers.X] = (ushort)(devices[value].ManufacturerID & 0xFFFF); //X+(Y<<16) is a 32 bit word identifying the manufacturer                      registers[(int)Registers.Y] = (ushort)((devices[value].ManufacturerID >> 16) & 0xFFFF);                      break;                  case Intermediate.Instructions.HWI: //HWI a | sends an interrupt to hardware a                      devices[value].OnInterrupt(this);                      break;              }
Magic Number,DCPUB.Testing,Emulator,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Testing\Emulator.cs,Step,The following statement contains a magic number: switch (ins)              {                  case Intermediate.Instructions.SET: //0x01 | SET b' a | sets b to a                      AssignToOperand(operandB' value' false);                      break;                  case Intermediate.Instructions.ADD: //ADD b' a | sets b to b+a' sets EX to 0x0001 if there's an overflow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) + value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.SUB: //SUB b' a | sets b to b-a' sets EX to 0xffff if there's an underflow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) - value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MUL: //MUL b' a | sets b to b*a' sets EX to ((b*a)>>16)&0xffff (treats b' a as unsigned)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) * value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MLI: //MLI b' a | like MUL' but treat b' a as signed                      intermediate = (UInt32)((short)GetOperandValue(operandB' OperandPlace.B) * (short)value);                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.DIV: //DIV b' a | sets b to b/a' sets EX to ((b<<16)/a)&0xffff. if a==0' sets b and EX to 0 instead. (treats b' a as unsigned)                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      intermediate = value == 0 ? 0 : (UInt32)bValue / value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.DVI: //DVI b' a | like DIV' but treat b' a as signed. Rounds towards 0                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      intermediate = value == 0 ? 0 : (UInt32)((short)bValue / (short)value);                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MOD: //MOD b' a | sets b to b%a. if a==0' sets b to 0 instead.                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      AssignToOperand(operandB' value == 0 ? (ushort)0 : (ushort)(bValue % value)' true);                      break;                  case Intermediate.Instructions.MDI: //MDI b' a | like MOD' but treat b' a as signed. (MDI -7' 16 == -7)                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      AssignToOperand(operandB' value == 0 ? (ushort)0 : (ushort)((short)bValue % (short)value)' true);                      break;                  case Intermediate.Instructions.AND: //AND b' a | sets b to b&a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) & value)' true);                      break;                  case Intermediate.Instructions.BOR: //BOR b' a | sets b to b|a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) | value)' true);                      break;                  case Intermediate.Instructions.XOR: //XOR b' a | sets b to b^a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) ^ value));                      break;                  case Intermediate.Instructions.SHR: //SHR b' a | sets b to b>>>a' sets EX to ((b<<16)>>a)&0xffff (logical shift)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)(intermediate >> value)' true);                      AssignToEx((ushort)(intermediate << 16 >> value));                      break;                  case Intermediate.Instructions.ASR: //ASR b' a | sets b to b>>a' sets EX to ((b<<16)>>>a)&0xffff (arithmetic shift) (treats b as signed)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)((int)intermediate >> value)' true);                      AssignToEx((ushort)((int)intermediate << 16 >> value));                      break;                  case Intermediate.Instructions.SHL: //SHL b' a | sets b to b<<a' sets EX to ((b<<a)>>16)&0xffff                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)(intermediate << value)' true);                      AssignToEx((ushort)(intermediate << value >> 16));                      break;                  case Intermediate.Instructions.IFB: //IFB b' a | performs next instruction only if (b&a)!=0                      SkipIf = (GetOperandValue(operandB' OperandPlace.B) & value) != 0;                      break;                  case Intermediate.Instructions.IFC: //IFC b' a | performs next instruction only if (b&a)==0                      SkipIf = (GetOperandValue(operandB' OperandPlace.B) & value) == 0;                      break;                  case Intermediate.Instructions.IFE: //IFE b' a | performs next instruction only if b==a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) == value;                      break;                  case Intermediate.Instructions.IFN: //IFB b' a | performs next instruction only if b!=a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) != value;                      break;                  case Intermediate.Instructions.IFG: //IFG b' a | performs next instruction only if b>a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) > value;                      break;                  case Intermediate.Instructions.IFA: //IFA b' a | performs next instruction only if b>a (signed)                      SkipIf = (int)GetOperandValue(operandB' OperandPlace.B) > (int)value;                      break;                  case Intermediate.Instructions.IFL: //IFL b' a | performs next instruction only if b<a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) < value;                      break;                  case Intermediate.Instructions.IFU: //IFU b' a | performs next instruction only if b<a (signed)                      SkipIf = (int)GetOperandValue(operandB' OperandPlace.B) < (int)value;                      break;                  case Intermediate.Instructions.ADX: //ADX b' a | sets b to b+a+EX' sets EX to 0x0001 if there is an over-flow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) + value + registers[(int)Registers.EX];                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.SBX: //SBX b' a | sets b to b-a+EX' sets EX to 0xFFFF if there is an under-flow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) - value + registers[(int)Registers.EX];                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.STI: //STI b' a | sets b to a' then increases I and J by 1                      AssignToOperand(operandB' value' false);                      registers[(int)Registers.I] += 1;                      registers[(int)Registers.J] += 1;                      break;                  case Intermediate.Instructions.STD: //STI b' a | sets b to a' then decreases I and J by 1                      AssignToOperand(operandB' value' false);                      registers[(int)Registers.I] -= 1;                      registers[(int)Registers.J] -= 1;                      break;                    case Intermediate.Instructions.JSR: //pushes the address of the next instruction to the stack' then sets PC to a                      ram[(ushort)(registers[(int)Registers.SP] - 1)] = registers[(int)Registers.PC];                      registers[(int)Registers.SP] -= 1;                      registers[(int)Registers.PC] = value;                      break;                  case Intermediate.Instructions.HLT:                      throw new Halt();                    case Intermediate.Instructions.INT: //INT a | triggers a software interrupt with message a                      TriggerInterrupt(value);                      break;                  case Intermediate.Instructions.IAG: //IAG a | sets a to IA                       AssignToOperand(operandA' registers[(int)Registers.IA]' true);                      break;                  case Intermediate.Instructions.IAS: //IAS a | sets IA to A                       registers[(int)Registers.IA] = value;                      break;                  case Intermediate.Instructions.RFI: //RFI a | disables interrupt queueing' pops A from the stack' then pops PC from the stack                      protectInterruptQueue.WaitOne();                      interruptQueueEnabled = false;                      registers[(int)Registers.A] = ram[(ushort)(registers[(int)Registers.SP])];                      registers[(int)Registers.PC] = ram[(ushort)(registers[(int)Registers.SP] + 1)];                      registers[(int)Registers.SP] += 2;                      break;                  case Intermediate.Instructions.IAQ: //IAQ a | if a is nonzero' interrupts will be added to the queue                      interruptQueueEnabled = value != 0; //instead of triggered. if a is zero' interrupts will be                      break;                              //triggered as normal again                    case Intermediate.Instructions.HWN: //HWN a | sets a to number of connected hardware devices                      AssignToOperand(operandA' (ushort)devices.Count' true);                      break;                  case Intermediate.Instructions.HWQ: //HWQ a | sets A' B' C' X' Y registers to information about hardware a                       registers[(int)Registers.A] = (ushort)(devices[value].HardwareID & 0xFFFF); //A+(B<<16) is a 32 bit word identifying the hardware id                      registers[(int)Registers.B] = (ushort)((devices[value].HardwareID >> 16) & 0xFFFF);                      registers[(int)Registers.C] = devices[value].Version; //C is the hardware version                      registers[(int)Registers.X] = (ushort)(devices[value].ManufacturerID & 0xFFFF); //X+(Y<<16) is a 32 bit word identifying the manufacturer                      registers[(int)Registers.Y] = (ushort)((devices[value].ManufacturerID >> 16) & 0xFFFF);                      break;                  case Intermediate.Instructions.HWI: //HWI a | sends an interrupt to hardware a                      devices[value].OnInterrupt(this);                      break;              }
Magic Number,DCPUB.Testing,Emulator,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Testing\Emulator.cs,Step,The following statement contains a magic number: switch (ins)              {                  case Intermediate.Instructions.SET: //0x01 | SET b' a | sets b to a                      AssignToOperand(operandB' value' false);                      break;                  case Intermediate.Instructions.ADD: //ADD b' a | sets b to b+a' sets EX to 0x0001 if there's an overflow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) + value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.SUB: //SUB b' a | sets b to b-a' sets EX to 0xffff if there's an underflow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) - value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MUL: //MUL b' a | sets b to b*a' sets EX to ((b*a)>>16)&0xffff (treats b' a as unsigned)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) * value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MLI: //MLI b' a | like MUL' but treat b' a as signed                      intermediate = (UInt32)((short)GetOperandValue(operandB' OperandPlace.B) * (short)value);                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.DIV: //DIV b' a | sets b to b/a' sets EX to ((b<<16)/a)&0xffff. if a==0' sets b and EX to 0 instead. (treats b' a as unsigned)                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      intermediate = value == 0 ? 0 : (UInt32)bValue / value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.DVI: //DVI b' a | like DIV' but treat b' a as signed. Rounds towards 0                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      intermediate = value == 0 ? 0 : (UInt32)((short)bValue / (short)value);                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MOD: //MOD b' a | sets b to b%a. if a==0' sets b to 0 instead.                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      AssignToOperand(operandB' value == 0 ? (ushort)0 : (ushort)(bValue % value)' true);                      break;                  case Intermediate.Instructions.MDI: //MDI b' a | like MOD' but treat b' a as signed. (MDI -7' 16 == -7)                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      AssignToOperand(operandB' value == 0 ? (ushort)0 : (ushort)((short)bValue % (short)value)' true);                      break;                  case Intermediate.Instructions.AND: //AND b' a | sets b to b&a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) & value)' true);                      break;                  case Intermediate.Instructions.BOR: //BOR b' a | sets b to b|a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) | value)' true);                      break;                  case Intermediate.Instructions.XOR: //XOR b' a | sets b to b^a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) ^ value));                      break;                  case Intermediate.Instructions.SHR: //SHR b' a | sets b to b>>>a' sets EX to ((b<<16)>>a)&0xffff (logical shift)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)(intermediate >> value)' true);                      AssignToEx((ushort)(intermediate << 16 >> value));                      break;                  case Intermediate.Instructions.ASR: //ASR b' a | sets b to b>>a' sets EX to ((b<<16)>>>a)&0xffff (arithmetic shift) (treats b as signed)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)((int)intermediate >> value)' true);                      AssignToEx((ushort)((int)intermediate << 16 >> value));                      break;                  case Intermediate.Instructions.SHL: //SHL b' a | sets b to b<<a' sets EX to ((b<<a)>>16)&0xffff                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)(intermediate << value)' true);                      AssignToEx((ushort)(intermediate << value >> 16));                      break;                  case Intermediate.Instructions.IFB: //IFB b' a | performs next instruction only if (b&a)!=0                      SkipIf = (GetOperandValue(operandB' OperandPlace.B) & value) != 0;                      break;                  case Intermediate.Instructions.IFC: //IFC b' a | performs next instruction only if (b&a)==0                      SkipIf = (GetOperandValue(operandB' OperandPlace.B) & value) == 0;                      break;                  case Intermediate.Instructions.IFE: //IFE b' a | performs next instruction only if b==a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) == value;                      break;                  case Intermediate.Instructions.IFN: //IFB b' a | performs next instruction only if b!=a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) != value;                      break;                  case Intermediate.Instructions.IFG: //IFG b' a | performs next instruction only if b>a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) > value;                      break;                  case Intermediate.Instructions.IFA: //IFA b' a | performs next instruction only if b>a (signed)                      SkipIf = (int)GetOperandValue(operandB' OperandPlace.B) > (int)value;                      break;                  case Intermediate.Instructions.IFL: //IFL b' a | performs next instruction only if b<a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) < value;                      break;                  case Intermediate.Instructions.IFU: //IFU b' a | performs next instruction only if b<a (signed)                      SkipIf = (int)GetOperandValue(operandB' OperandPlace.B) < (int)value;                      break;                  case Intermediate.Instructions.ADX: //ADX b' a | sets b to b+a+EX' sets EX to 0x0001 if there is an over-flow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) + value + registers[(int)Registers.EX];                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.SBX: //SBX b' a | sets b to b-a+EX' sets EX to 0xFFFF if there is an under-flow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) - value + registers[(int)Registers.EX];                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.STI: //STI b' a | sets b to a' then increases I and J by 1                      AssignToOperand(operandB' value' false);                      registers[(int)Registers.I] += 1;                      registers[(int)Registers.J] += 1;                      break;                  case Intermediate.Instructions.STD: //STI b' a | sets b to a' then decreases I and J by 1                      AssignToOperand(operandB' value' false);                      registers[(int)Registers.I] -= 1;                      registers[(int)Registers.J] -= 1;                      break;                    case Intermediate.Instructions.JSR: //pushes the address of the next instruction to the stack' then sets PC to a                      ram[(ushort)(registers[(int)Registers.SP] - 1)] = registers[(int)Registers.PC];                      registers[(int)Registers.SP] -= 1;                      registers[(int)Registers.PC] = value;                      break;                  case Intermediate.Instructions.HLT:                      throw new Halt();                    case Intermediate.Instructions.INT: //INT a | triggers a software interrupt with message a                      TriggerInterrupt(value);                      break;                  case Intermediate.Instructions.IAG: //IAG a | sets a to IA                       AssignToOperand(operandA' registers[(int)Registers.IA]' true);                      break;                  case Intermediate.Instructions.IAS: //IAS a | sets IA to A                       registers[(int)Registers.IA] = value;                      break;                  case Intermediate.Instructions.RFI: //RFI a | disables interrupt queueing' pops A from the stack' then pops PC from the stack                      protectInterruptQueue.WaitOne();                      interruptQueueEnabled = false;                      registers[(int)Registers.A] = ram[(ushort)(registers[(int)Registers.SP])];                      registers[(int)Registers.PC] = ram[(ushort)(registers[(int)Registers.SP] + 1)];                      registers[(int)Registers.SP] += 2;                      break;                  case Intermediate.Instructions.IAQ: //IAQ a | if a is nonzero' interrupts will be added to the queue                      interruptQueueEnabled = value != 0; //instead of triggered. if a is zero' interrupts will be                      break;                              //triggered as normal again                    case Intermediate.Instructions.HWN: //HWN a | sets a to number of connected hardware devices                      AssignToOperand(operandA' (ushort)devices.Count' true);                      break;                  case Intermediate.Instructions.HWQ: //HWQ a | sets A' B' C' X' Y registers to information about hardware a                       registers[(int)Registers.A] = (ushort)(devices[value].HardwareID & 0xFFFF); //A+(B<<16) is a 32 bit word identifying the hardware id                      registers[(int)Registers.B] = (ushort)((devices[value].HardwareID >> 16) & 0xFFFF);                      registers[(int)Registers.C] = devices[value].Version; //C is the hardware version                      registers[(int)Registers.X] = (ushort)(devices[value].ManufacturerID & 0xFFFF); //X+(Y<<16) is a 32 bit word identifying the manufacturer                      registers[(int)Registers.Y] = (ushort)((devices[value].ManufacturerID >> 16) & 0xFFFF);                      break;                  case Intermediate.Instructions.HWI: //HWI a | sends an interrupt to hardware a                      devices[value].OnInterrupt(this);                      break;              }
Magic Number,DCPUB.Testing,Emulator,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Testing\Emulator.cs,Step,The following statement contains a magic number: switch (ins)              {                  case Intermediate.Instructions.SET: //0x01 | SET b' a | sets b to a                      AssignToOperand(operandB' value' false);                      break;                  case Intermediate.Instructions.ADD: //ADD b' a | sets b to b+a' sets EX to 0x0001 if there's an overflow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) + value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.SUB: //SUB b' a | sets b to b-a' sets EX to 0xffff if there's an underflow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) - value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MUL: //MUL b' a | sets b to b*a' sets EX to ((b*a)>>16)&0xffff (treats b' a as unsigned)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) * value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MLI: //MLI b' a | like MUL' but treat b' a as signed                      intermediate = (UInt32)((short)GetOperandValue(operandB' OperandPlace.B) * (short)value);                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.DIV: //DIV b' a | sets b to b/a' sets EX to ((b<<16)/a)&0xffff. if a==0' sets b and EX to 0 instead. (treats b' a as unsigned)                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      intermediate = value == 0 ? 0 : (UInt32)bValue / value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.DVI: //DVI b' a | like DIV' but treat b' a as signed. Rounds towards 0                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      intermediate = value == 0 ? 0 : (UInt32)((short)bValue / (short)value);                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MOD: //MOD b' a | sets b to b%a. if a==0' sets b to 0 instead.                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      AssignToOperand(operandB' value == 0 ? (ushort)0 : (ushort)(bValue % value)' true);                      break;                  case Intermediate.Instructions.MDI: //MDI b' a | like MOD' but treat b' a as signed. (MDI -7' 16 == -7)                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      AssignToOperand(operandB' value == 0 ? (ushort)0 : (ushort)((short)bValue % (short)value)' true);                      break;                  case Intermediate.Instructions.AND: //AND b' a | sets b to b&a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) & value)' true);                      break;                  case Intermediate.Instructions.BOR: //BOR b' a | sets b to b|a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) | value)' true);                      break;                  case Intermediate.Instructions.XOR: //XOR b' a | sets b to b^a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) ^ value));                      break;                  case Intermediate.Instructions.SHR: //SHR b' a | sets b to b>>>a' sets EX to ((b<<16)>>a)&0xffff (logical shift)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)(intermediate >> value)' true);                      AssignToEx((ushort)(intermediate << 16 >> value));                      break;                  case Intermediate.Instructions.ASR: //ASR b' a | sets b to b>>a' sets EX to ((b<<16)>>>a)&0xffff (arithmetic shift) (treats b as signed)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)((int)intermediate >> value)' true);                      AssignToEx((ushort)((int)intermediate << 16 >> value));                      break;                  case Intermediate.Instructions.SHL: //SHL b' a | sets b to b<<a' sets EX to ((b<<a)>>16)&0xffff                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)(intermediate << value)' true);                      AssignToEx((ushort)(intermediate << value >> 16));                      break;                  case Intermediate.Instructions.IFB: //IFB b' a | performs next instruction only if (b&a)!=0                      SkipIf = (GetOperandValue(operandB' OperandPlace.B) & value) != 0;                      break;                  case Intermediate.Instructions.IFC: //IFC b' a | performs next instruction only if (b&a)==0                      SkipIf = (GetOperandValue(operandB' OperandPlace.B) & value) == 0;                      break;                  case Intermediate.Instructions.IFE: //IFE b' a | performs next instruction only if b==a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) == value;                      break;                  case Intermediate.Instructions.IFN: //IFB b' a | performs next instruction only if b!=a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) != value;                      break;                  case Intermediate.Instructions.IFG: //IFG b' a | performs next instruction only if b>a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) > value;                      break;                  case Intermediate.Instructions.IFA: //IFA b' a | performs next instruction only if b>a (signed)                      SkipIf = (int)GetOperandValue(operandB' OperandPlace.B) > (int)value;                      break;                  case Intermediate.Instructions.IFL: //IFL b' a | performs next instruction only if b<a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) < value;                      break;                  case Intermediate.Instructions.IFU: //IFU b' a | performs next instruction only if b<a (signed)                      SkipIf = (int)GetOperandValue(operandB' OperandPlace.B) < (int)value;                      break;                  case Intermediate.Instructions.ADX: //ADX b' a | sets b to b+a+EX' sets EX to 0x0001 if there is an over-flow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) + value + registers[(int)Registers.EX];                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.SBX: //SBX b' a | sets b to b-a+EX' sets EX to 0xFFFF if there is an under-flow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) - value + registers[(int)Registers.EX];                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.STI: //STI b' a | sets b to a' then increases I and J by 1                      AssignToOperand(operandB' value' false);                      registers[(int)Registers.I] += 1;                      registers[(int)Registers.J] += 1;                      break;                  case Intermediate.Instructions.STD: //STI b' a | sets b to a' then decreases I and J by 1                      AssignToOperand(operandB' value' false);                      registers[(int)Registers.I] -= 1;                      registers[(int)Registers.J] -= 1;                      break;                    case Intermediate.Instructions.JSR: //pushes the address of the next instruction to the stack' then sets PC to a                      ram[(ushort)(registers[(int)Registers.SP] - 1)] = registers[(int)Registers.PC];                      registers[(int)Registers.SP] -= 1;                      registers[(int)Registers.PC] = value;                      break;                  case Intermediate.Instructions.HLT:                      throw new Halt();                    case Intermediate.Instructions.INT: //INT a | triggers a software interrupt with message a                      TriggerInterrupt(value);                      break;                  case Intermediate.Instructions.IAG: //IAG a | sets a to IA                       AssignToOperand(operandA' registers[(int)Registers.IA]' true);                      break;                  case Intermediate.Instructions.IAS: //IAS a | sets IA to A                       registers[(int)Registers.IA] = value;                      break;                  case Intermediate.Instructions.RFI: //RFI a | disables interrupt queueing' pops A from the stack' then pops PC from the stack                      protectInterruptQueue.WaitOne();                      interruptQueueEnabled = false;                      registers[(int)Registers.A] = ram[(ushort)(registers[(int)Registers.SP])];                      registers[(int)Registers.PC] = ram[(ushort)(registers[(int)Registers.SP] + 1)];                      registers[(int)Registers.SP] += 2;                      break;                  case Intermediate.Instructions.IAQ: //IAQ a | if a is nonzero' interrupts will be added to the queue                      interruptQueueEnabled = value != 0; //instead of triggered. if a is zero' interrupts will be                      break;                              //triggered as normal again                    case Intermediate.Instructions.HWN: //HWN a | sets a to number of connected hardware devices                      AssignToOperand(operandA' (ushort)devices.Count' true);                      break;                  case Intermediate.Instructions.HWQ: //HWQ a | sets A' B' C' X' Y registers to information about hardware a                       registers[(int)Registers.A] = (ushort)(devices[value].HardwareID & 0xFFFF); //A+(B<<16) is a 32 bit word identifying the hardware id                      registers[(int)Registers.B] = (ushort)((devices[value].HardwareID >> 16) & 0xFFFF);                      registers[(int)Registers.C] = devices[value].Version; //C is the hardware version                      registers[(int)Registers.X] = (ushort)(devices[value].ManufacturerID & 0xFFFF); //X+(Y<<16) is a 32 bit word identifying the manufacturer                      registers[(int)Registers.Y] = (ushort)((devices[value].ManufacturerID >> 16) & 0xFFFF);                      break;                  case Intermediate.Instructions.HWI: //HWI a | sends an interrupt to hardware a                      devices[value].OnInterrupt(this);                      break;              }
Magic Number,DCPUB.Testing,Emulator,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Testing\Emulator.cs,Step,The following statement contains a magic number: switch (ins)              {                  case Intermediate.Instructions.SET: //0x01 | SET b' a | sets b to a                      AssignToOperand(operandB' value' false);                      break;                  case Intermediate.Instructions.ADD: //ADD b' a | sets b to b+a' sets EX to 0x0001 if there's an overflow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) + value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.SUB: //SUB b' a | sets b to b-a' sets EX to 0xffff if there's an underflow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) - value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MUL: //MUL b' a | sets b to b*a' sets EX to ((b*a)>>16)&0xffff (treats b' a as unsigned)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) * value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MLI: //MLI b' a | like MUL' but treat b' a as signed                      intermediate = (UInt32)((short)GetOperandValue(operandB' OperandPlace.B) * (short)value);                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.DIV: //DIV b' a | sets b to b/a' sets EX to ((b<<16)/a)&0xffff. if a==0' sets b and EX to 0 instead. (treats b' a as unsigned)                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      intermediate = value == 0 ? 0 : (UInt32)bValue / value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.DVI: //DVI b' a | like DIV' but treat b' a as signed. Rounds towards 0                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      intermediate = value == 0 ? 0 : (UInt32)((short)bValue / (short)value);                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MOD: //MOD b' a | sets b to b%a. if a==0' sets b to 0 instead.                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      AssignToOperand(operandB' value == 0 ? (ushort)0 : (ushort)(bValue % value)' true);                      break;                  case Intermediate.Instructions.MDI: //MDI b' a | like MOD' but treat b' a as signed. (MDI -7' 16 == -7)                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      AssignToOperand(operandB' value == 0 ? (ushort)0 : (ushort)((short)bValue % (short)value)' true);                      break;                  case Intermediate.Instructions.AND: //AND b' a | sets b to b&a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) & value)' true);                      break;                  case Intermediate.Instructions.BOR: //BOR b' a | sets b to b|a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) | value)' true);                      break;                  case Intermediate.Instructions.XOR: //XOR b' a | sets b to b^a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) ^ value));                      break;                  case Intermediate.Instructions.SHR: //SHR b' a | sets b to b>>>a' sets EX to ((b<<16)>>a)&0xffff (logical shift)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)(intermediate >> value)' true);                      AssignToEx((ushort)(intermediate << 16 >> value));                      break;                  case Intermediate.Instructions.ASR: //ASR b' a | sets b to b>>a' sets EX to ((b<<16)>>>a)&0xffff (arithmetic shift) (treats b as signed)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)((int)intermediate >> value)' true);                      AssignToEx((ushort)((int)intermediate << 16 >> value));                      break;                  case Intermediate.Instructions.SHL: //SHL b' a | sets b to b<<a' sets EX to ((b<<a)>>16)&0xffff                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)(intermediate << value)' true);                      AssignToEx((ushort)(intermediate << value >> 16));                      break;                  case Intermediate.Instructions.IFB: //IFB b' a | performs next instruction only if (b&a)!=0                      SkipIf = (GetOperandValue(operandB' OperandPlace.B) & value) != 0;                      break;                  case Intermediate.Instructions.IFC: //IFC b' a | performs next instruction only if (b&a)==0                      SkipIf = (GetOperandValue(operandB' OperandPlace.B) & value) == 0;                      break;                  case Intermediate.Instructions.IFE: //IFE b' a | performs next instruction only if b==a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) == value;                      break;                  case Intermediate.Instructions.IFN: //IFB b' a | performs next instruction only if b!=a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) != value;                      break;                  case Intermediate.Instructions.IFG: //IFG b' a | performs next instruction only if b>a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) > value;                      break;                  case Intermediate.Instructions.IFA: //IFA b' a | performs next instruction only if b>a (signed)                      SkipIf = (int)GetOperandValue(operandB' OperandPlace.B) > (int)value;                      break;                  case Intermediate.Instructions.IFL: //IFL b' a | performs next instruction only if b<a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) < value;                      break;                  case Intermediate.Instructions.IFU: //IFU b' a | performs next instruction only if b<a (signed)                      SkipIf = (int)GetOperandValue(operandB' OperandPlace.B) < (int)value;                      break;                  case Intermediate.Instructions.ADX: //ADX b' a | sets b to b+a+EX' sets EX to 0x0001 if there is an over-flow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) + value + registers[(int)Registers.EX];                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.SBX: //SBX b' a | sets b to b-a+EX' sets EX to 0xFFFF if there is an under-flow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) - value + registers[(int)Registers.EX];                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.STI: //STI b' a | sets b to a' then increases I and J by 1                      AssignToOperand(operandB' value' false);                      registers[(int)Registers.I] += 1;                      registers[(int)Registers.J] += 1;                      break;                  case Intermediate.Instructions.STD: //STI b' a | sets b to a' then decreases I and J by 1                      AssignToOperand(operandB' value' false);                      registers[(int)Registers.I] -= 1;                      registers[(int)Registers.J] -= 1;                      break;                    case Intermediate.Instructions.JSR: //pushes the address of the next instruction to the stack' then sets PC to a                      ram[(ushort)(registers[(int)Registers.SP] - 1)] = registers[(int)Registers.PC];                      registers[(int)Registers.SP] -= 1;                      registers[(int)Registers.PC] = value;                      break;                  case Intermediate.Instructions.HLT:                      throw new Halt();                    case Intermediate.Instructions.INT: //INT a | triggers a software interrupt with message a                      TriggerInterrupt(value);                      break;                  case Intermediate.Instructions.IAG: //IAG a | sets a to IA                       AssignToOperand(operandA' registers[(int)Registers.IA]' true);                      break;                  case Intermediate.Instructions.IAS: //IAS a | sets IA to A                       registers[(int)Registers.IA] = value;                      break;                  case Intermediate.Instructions.RFI: //RFI a | disables interrupt queueing' pops A from the stack' then pops PC from the stack                      protectInterruptQueue.WaitOne();                      interruptQueueEnabled = false;                      registers[(int)Registers.A] = ram[(ushort)(registers[(int)Registers.SP])];                      registers[(int)Registers.PC] = ram[(ushort)(registers[(int)Registers.SP] + 1)];                      registers[(int)Registers.SP] += 2;                      break;                  case Intermediate.Instructions.IAQ: //IAQ a | if a is nonzero' interrupts will be added to the queue                      interruptQueueEnabled = value != 0; //instead of triggered. if a is zero' interrupts will be                      break;                              //triggered as normal again                    case Intermediate.Instructions.HWN: //HWN a | sets a to number of connected hardware devices                      AssignToOperand(operandA' (ushort)devices.Count' true);                      break;                  case Intermediate.Instructions.HWQ: //HWQ a | sets A' B' C' X' Y registers to information about hardware a                       registers[(int)Registers.A] = (ushort)(devices[value].HardwareID & 0xFFFF); //A+(B<<16) is a 32 bit word identifying the hardware id                      registers[(int)Registers.B] = (ushort)((devices[value].HardwareID >> 16) & 0xFFFF);                      registers[(int)Registers.C] = devices[value].Version; //C is the hardware version                      registers[(int)Registers.X] = (ushort)(devices[value].ManufacturerID & 0xFFFF); //X+(Y<<16) is a 32 bit word identifying the manufacturer                      registers[(int)Registers.Y] = (ushort)((devices[value].ManufacturerID >> 16) & 0xFFFF);                      break;                  case Intermediate.Instructions.HWI: //HWI a | sends an interrupt to hardware a                      devices[value].OnInterrupt(this);                      break;              }
Magic Number,DCPUB,Grammar,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Grammar.cs,Grammar,The following statement contains a magic number: this.RegisterOperators(2' Associativity.Left' "=="' "!="' ">"' "<"' "->"' "-<");
Magic Number,DCPUB,Grammar,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Grammar.cs,Grammar,The following statement contains a magic number: this.RegisterOperators(3' Associativity.Right' "="' "+="' "-="' "*="' "/="' "%="' "^="' "<<="' ">>="' "&="' "|="' "-*="' "-/="' "-%=");
Magic Number,DCPUB,Grammar,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Grammar.cs,Grammar,The following statement contains a magic number: this.RegisterOperators(4' Associativity.Left' "+"' "-");
Magic Number,DCPUB,Grammar,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Grammar.cs,Grammar,The following statement contains a magic number: this.RegisterOperators(5' Associativity.Left' "*"' "/"' "%");
Magic Number,DCPUB,Grammar,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Grammar.cs,Grammar,The following statement contains a magic number: this.RegisterOperators(5' Associativity.Left' "-*"' "-/"' "-%");
Magic Number,DCPUB,Grammar,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Grammar.cs,Grammar,The following statement contains a magic number: this.RegisterOperators(6' Associativity.Left' "<<"' ">>"' "&"' "|"' "^"' "!");
Magic Number,DCPUB,Grammar,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Grammar.cs,Grammar,The following statement contains a magic number: this.RegisterOperators(7' Associativity.Left' ":");
Magic Number,DCPUB,Grammar,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Grammar.cs,Grammar,The following statement contains a magic number: this.RegisterOperators(8' Associativity.Left' "{"' "}"' "["' "]");
Magic Number,DCPUB.Ast.Assembly,InstructionAstNode,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Ast\Assembly\InstructionAstNode.cs,ParseInstruction,The following statement contains a magic number: iNode.secondOperand = OperandAstNode.ParseOperand(treeNode.ChildNodes[2].FirstChild.FirstChild);
Magic Number,DCPUB.Ast.Assembly,InstructionAstNode,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Ast\Assembly\InstructionAstNode.cs,ParseInstruction,The following statement contains a magic number: treeNode.ChildNodes.Count >= 3
Magic Number,DCPUB.Ast.Assembly,OperandAstNode,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Ast\Assembly\OperandAstNode.cs,ParseOperand,The following statement contains a magic number: r.constant = Convert.ToUInt16(constant.Substring(2)' 16);
Magic Number,DCPUB.Ast.Assembly,OperandAstNode,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Ast\Assembly\OperandAstNode.cs,ParseOperand,The following statement contains a magic number: r.constant = Convert.ToUInt16(constant.Substring(2)' 16);
Magic Number,DCPUB.Intermediate.Peephole,Grammar,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Intermediate\Peephole\Grammar.cs,Grammar,The following statement contains a magic number: this.RegisterOperators(4' Associativity.Left' "/");
Magic Number,DCPUB.Intermediate.Peephole,Grammar,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Intermediate\Peephole\Grammar.cs,Grammar,The following statement contains a magic number: this.RegisterOperators(5' Associativity.Left' "&"' "|");
Magic Number,DCPUB.Intermediate.Peephole,Grammar,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Intermediate\Peephole\Grammar.cs,Grammar,The following statement contains a magic number: this.RegisterOperators(6' Associativity.Left' "{"' "}"' "["' "]"' "<"' ">");
Magic Number,DCPUB.Intermediate.Peephole,ReplacementRaw,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Intermediate\Peephole\Replacement.cs,Init,The following statement contains a magic number: rawValue = rawValue.Substring(1' rawValue.Length - 2);
Magic Number,DCPUB.Intermediate.Peephole,ReplacementInstruction,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Intermediate\Peephole\Replacement.cs,Init,The following statement contains a magic number: AddChild("secondOperand"' treeNode.ChildNodes[2]);
Magic Number,DCPUB.Intermediate.Peephole,WholeInstructionMatchRaw,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Intermediate\Peephole\WholeInstructionMatcher.cs,Init,The following statement contains a magic number: AddChild("secondOperand"' treeNode.ChildNodes[2]);
Magic Number,DCPUB.Intermediate.Peephole,WholeInstructionMatchRaw,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Intermediate\Peephole\WholeInstructionMatcher.cs,Match,The following statement contains a magic number: return (ChildNodes[0] as InstructionMatcher).Match(ins) &&                  (ChildNodes[1] as OperandMatcher).Match(ins.firstOperand' values) &&                  (ChildNodes[2] as OperandMatcher).Match(ins.secondOperand' values);
Magic Number,DCPUB.Intermediate.Peephole,OperandMatchRaw,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Intermediate\Peephole\OperandMatcher.cs,Init,The following statement contains a magic number: rawValue = rawValue.Substring(1' rawValue.Length - 2);
Magic Number,DCPUB.Ast,OffsetOfNode,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Ast\OffsetOfNode.cs,Init,The following statement contains a magic number: typeName = treeNode.ChildNodes[3].FindTokenAndGetText();
Magic Number,DCPUB.Ast,StringLiteralNode,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Ast\StringLiteralNode.cs,UnescapeString,The following statement contains a magic number: place += 2;
Magic Number,DCPUB.Ast,StringLiteralNode,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Ast\StringLiteralNode.cs,Init,The following statement contains a magic number: value = value.Substring(1' value.Length - 2);
Magic Number,DCPUB.Ast,MemberAccessNode,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Ast\MemberAccessNode.cs,Init,The following statement contains a magic number: memberName = treeNode.ChildNodes[2].FindTokenAndGetText();
Magic Number,DCPUB.Ast,MemberNode,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Ast\StructDeclarationNode.cs,Init,The following statement contains a magic number: AddChild("array size"' treeNode.ChildNodes[2].FirstChild.FirstChild);
Magic Number,DCPUB.Ast,MemberNode,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Ast\StructDeclarationNode.cs,Init,The following statement contains a magic number: treeNode.ChildNodes[2].FirstChild.ChildNodes.Count > 0
Magic Number,DCPUB.Ast,StructDeclarationNode,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Ast\StructDeclarationNode.cs,Init,The following statement contains a magic number: treeNode.ChildNodes[2].ChildNodes
Magic Number,DCPUB.Ast,AssignmentNode,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Ast\AssignmentNode.cs,Init,The following statement contains a magic number: AddChild("RValue"' treeNode.ChildNodes[2]);
Magic Number,DCPUB.Ast,BinaryOperationNode,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Ast\BinaryOperationNode.cs,Init,The following statement contains a magic number: AddChild("Parameter"' treeNode.ChildNodes[2]);
Magic Number,DCPUB.Ast,WhileStatementNode,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Ast\WhileStatementNode.cs,Init,The following statement contains a magic number: AddChild("Block"' treeNode.ChildNodes[2]);
Magic Number,DCPUB.Ast,FunctionDeclarationNode,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Ast\FunctionDeclarationNode.cs,Init,The following statement contains a magic number: headerSpan = new Irony.Parsing.SourceSpan(this.Span.Location'                  treeNode.ChildNodes[2].Span.EndPosition - this.Span.Location.Position);
Magic Number,DCPUB.Ast,FunctionDeclarationNode,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Ast\FunctionDeclarationNode.cs,Init,The following statement contains a magic number: AddChild("Block"' treeNode.ChildNodes[4]);
Magic Number,DCPUB.Ast,FunctionDeclarationNode,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Ast\FunctionDeclarationNode.cs,Init,The following statement contains a magic number: treeNode.ChildNodes[2].ChildNodes
Magic Number,DCPUB.Ast,FunctionDeclarationNode,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Ast\FunctionDeclarationNode.cs,Init,The following statement contains a magic number: function.returnType = treeNode.ChildNodes[3].FindTokenAndGetText();
Magic Number,DCPUB.Ast,FunctionDeclarationNode,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Ast\FunctionDeclarationNode.cs,GatherSymbols,The following statement contains a magic number: variable.stackOffset = i + 2;
Magic Number,DCPUB.Ast,FunctionDeclarationNode,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Ast\FunctionDeclarationNode.cs,CompileFunction,The following statement contains a magic number: used = registers.Count((rs) => rs == true) - 2;
Magic Number,DCPUB.Ast,FunctionDeclarationNode,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Ast\FunctionDeclarationNode.cs,CompileFunction,The following statement contains a magic number: i < 7
Magic Number,DCPUB.Ast,IfStatementNode,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Ast\IfStatementNode.cs,Init,The following statement contains a magic number: AddChild("then"' treeNode.ChildNodes[0].ChildNodes[2]);
Magic Number,DCPUB.Ast,IfStatementNode,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Ast\IfStatementNode.cs,Init,The following statement contains a magic number: AddChild("else"' treeNode.ChildNodes[2]);
Magic Number,DCPUB.Ast,IfStatementNode,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Ast\IfStatementNode.cs,Init,The following statement contains a magic number: ChildNodes[2] = BlockNode.Wrap(Child(2));
Magic Number,DCPUB.Ast,IfStatementNode,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Ast\IfStatementNode.cs,Init,The following statement contains a magic number: ChildNodes[2] = BlockNode.Wrap(Child(2));
Magic Number,DCPUB.Ast,IfStatementNode,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Ast\IfStatementNode.cs,Init,The following statement contains a magic number: ChildNodes.Count == 3
Magic Number,DCPUB.Ast,IfStatementNode,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Ast\IfStatementNode.cs,Emit,The following statement contains a magic number: switch (clauseOrder)              {                  case ClauseOrder.ConstantPass:                      r.AddChild(EmitBlock(context' scope' Child(1)));                      break;                  case ClauseOrder.ConstantFail:                      if (ChildNodes.Count == 3) r.AddChild(EmitBlock(context' scope' Child(2)));                      break;                  case ClauseOrder.FailFirst: //Only actual valid order.                      {                          var thenClauseAssembly = EmitBlock(context' scope' Child(1));                          Intermediate.IRNode elseClauseAssembly = ChildNodes.Count == 3 ? EmitBlock(context' scope' Child(2)) : null;                            if (thenClauseAssembly.InstructionCount() == 1 &&                              (elseClauseAssembly == null || elseClauseAssembly.InstructionCount() == 0))                          {                              r.AddChild(thenClauseAssembly);                          }                          else                          {                              var thenLabel = Intermediate.Label.Make("THEN");                              var endLabel = Intermediate.Label.Make("END");                                r.AddInstruction(Instructions.SET' Operand("PC")' Label(thenLabel));                              if (elseClauseAssembly != null) r.AddChild(elseClauseAssembly);                              r.AddInstruction(Instructions.SET' Operand("PC")' Label(endLabel));                              r.AddLabel(thenLabel);                                r.AddChild(thenClauseAssembly);                              r.AddLabel(endLabel);                          }                      }                      break;                  default:                      throw new InternalError("IF !FailFirst Not implemented");              }
Magic Number,DCPUB.Ast,IfStatementNode,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Ast\IfStatementNode.cs,Emit,The following statement contains a magic number: switch (clauseOrder)              {                  case ClauseOrder.ConstantPass:                      r.AddChild(EmitBlock(context' scope' Child(1)));                      break;                  case ClauseOrder.ConstantFail:                      if (ChildNodes.Count == 3) r.AddChild(EmitBlock(context' scope' Child(2)));                      break;                  case ClauseOrder.FailFirst: //Only actual valid order.                      {                          var thenClauseAssembly = EmitBlock(context' scope' Child(1));                          Intermediate.IRNode elseClauseAssembly = ChildNodes.Count == 3 ? EmitBlock(context' scope' Child(2)) : null;                            if (thenClauseAssembly.InstructionCount() == 1 &&                              (elseClauseAssembly == null || elseClauseAssembly.InstructionCount() == 0))                          {                              r.AddChild(thenClauseAssembly);                          }                          else                          {                              var thenLabel = Intermediate.Label.Make("THEN");                              var endLabel = Intermediate.Label.Make("END");                                r.AddInstruction(Instructions.SET' Operand("PC")' Label(thenLabel));                              if (elseClauseAssembly != null) r.AddChild(elseClauseAssembly);                              r.AddInstruction(Instructions.SET' Operand("PC")' Label(endLabel));                              r.AddLabel(thenLabel);                                r.AddChild(thenClauseAssembly);                              r.AddLabel(endLabel);                          }                      }                      break;                  default:                      throw new InternalError("IF !FailFirst Not implemented");              }
Magic Number,DCPUB.Ast,IfStatementNode,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Ast\IfStatementNode.cs,Emit,The following statement contains a magic number: switch (clauseOrder)              {                  case ClauseOrder.ConstantPass:                      r.AddChild(EmitBlock(context' scope' Child(1)));                      break;                  case ClauseOrder.ConstantFail:                      if (ChildNodes.Count == 3) r.AddChild(EmitBlock(context' scope' Child(2)));                      break;                  case ClauseOrder.FailFirst: //Only actual valid order.                      {                          var thenClauseAssembly = EmitBlock(context' scope' Child(1));                          Intermediate.IRNode elseClauseAssembly = ChildNodes.Count == 3 ? EmitBlock(context' scope' Child(2)) : null;                            if (thenClauseAssembly.InstructionCount() == 1 &&                              (elseClauseAssembly == null || elseClauseAssembly.InstructionCount() == 0))                          {                              r.AddChild(thenClauseAssembly);                          }                          else                          {                              var thenLabel = Intermediate.Label.Make("THEN");                              var endLabel = Intermediate.Label.Make("END");                                r.AddInstruction(Instructions.SET' Operand("PC")' Label(thenLabel));                              if (elseClauseAssembly != null) r.AddChild(elseClauseAssembly);                              r.AddInstruction(Instructions.SET' Operand("PC")' Label(endLabel));                              r.AddLabel(thenLabel);                                r.AddChild(thenClauseAssembly);                              r.AddLabel(endLabel);                          }                      }                      break;                  default:                      throw new InternalError("IF !FailFirst Not implemented");              }
Magic Number,DCPUB.Ast,IfStatementNode,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Ast\IfStatementNode.cs,Emit,The following statement contains a magic number: switch (clauseOrder)              {                  case ClauseOrder.ConstantPass:                      r.AddChild(EmitBlock(context' scope' Child(1)));                      break;                  case ClauseOrder.ConstantFail:                      if (ChildNodes.Count == 3) r.AddChild(EmitBlock(context' scope' Child(2)));                      break;                  case ClauseOrder.FailFirst: //Only actual valid order.                      {                          var thenClauseAssembly = EmitBlock(context' scope' Child(1));                          Intermediate.IRNode elseClauseAssembly = ChildNodes.Count == 3 ? EmitBlock(context' scope' Child(2)) : null;                            if (thenClauseAssembly.InstructionCount() == 1 &&                              (elseClauseAssembly == null || elseClauseAssembly.InstructionCount() == 0))                          {                              r.AddChild(thenClauseAssembly);                          }                          else                          {                              var thenLabel = Intermediate.Label.Make("THEN");                              var endLabel = Intermediate.Label.Make("END");                                r.AddInstruction(Instructions.SET' Operand("PC")' Label(thenLabel));                              if (elseClauseAssembly != null) r.AddChild(elseClauseAssembly);                              r.AddInstruction(Instructions.SET' Operand("PC")' Label(endLabel));                              r.AddLabel(thenLabel);                                r.AddChild(thenClauseAssembly);                              r.AddLabel(endLabel);                          }                      }                      break;                  default:                      throw new InternalError("IF !FailFirst Not implemented");              }
Magic Number,DCPUB.Ast,InlineASMNode,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Ast\InlineASMNode.cs,Init,The following statement contains a magic number: rawAssembly = treeNode.ChildNodes[2].FindTokenAndGetText();
Magic Number,DCPUB.Ast,InlineASMNode,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Ast\InlineASMNode.cs,Emit,The following statement contains a magic number: context.ReportError(new Irony.Parsing.SourceSpan(error.Location + this.Location' 20)' error.Message);
Magic Number,DCPUB.Ast,NumberLiteralNode,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Ast\NumberLiteralNode.cs,Init,The following statement contains a magic number: Value = Convert.ToUInt16(AsString.Substring(2)' 16);
Magic Number,DCPUB.Ast,NumberLiteralNode,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Ast\NumberLiteralNode.cs,Init,The following statement contains a magic number: Value = Convert.ToUInt16(AsString.Substring(2)' 16);
Magic Number,DCPUB.Ast,VariableDeclarationNode,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Ast\VariableDeclarationNode.cs,Init,The following statement contains a magic number: AddChild("Value"' treeNode.ChildNodes[4].FirstChild.LastChild.FirstChild);
Magic Number,DCPUB.Ast,VariableDeclarationNode,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Ast\VariableDeclarationNode.cs,Init,The following statement contains a magic number: treeNode.ChildNodes[4].FirstChild.ChildNodes.Count > 0
Magic Number,DCPUB.Ast,VariableDeclarationNode,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Ast\VariableDeclarationNode.cs,Init,The following statement contains a magic number: AddChild("Size"' treeNode.ChildNodes[3].FirstChild.FirstChild);
Magic Number,DCPUB.Ast,VariableDeclarationNode,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Ast\VariableDeclarationNode.cs,Init,The following statement contains a magic number: treeNode.ChildNodes[3].FirstChild.ChildNodes.Count > 0
Magic Number,DCPUB.Ast,VariableDeclarationNode,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Ast\VariableDeclarationNode.cs,Init,The following statement contains a magic number: variable.typeSpecifier = treeNode.ChildNodes[2].FindTokenAndGetText();
Missing Default,DCPUB.Testing,Emulator,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Testing\Emulator.cs,Step,The following switch statement is missing a default case: switch (ins)              {                  case Intermediate.Instructions.SET: //0x01 | SET b' a | sets b to a                      AssignToOperand(operandB' value' false);                      break;                  case Intermediate.Instructions.ADD: //ADD b' a | sets b to b+a' sets EX to 0x0001 if there's an overflow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) + value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.SUB: //SUB b' a | sets b to b-a' sets EX to 0xffff if there's an underflow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) - value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MUL: //MUL b' a | sets b to b*a' sets EX to ((b*a)>>16)&0xffff (treats b' a as unsigned)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) * value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MLI: //MLI b' a | like MUL' but treat b' a as signed                      intermediate = (UInt32)((short)GetOperandValue(operandB' OperandPlace.B) * (short)value);                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.DIV: //DIV b' a | sets b to b/a' sets EX to ((b<<16)/a)&0xffff. if a==0' sets b and EX to 0 instead. (treats b' a as unsigned)                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      intermediate = value == 0 ? 0 : (UInt32)bValue / value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.DVI: //DVI b' a | like DIV' but treat b' a as signed. Rounds towards 0                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      intermediate = value == 0 ? 0 : (UInt32)((short)bValue / (short)value);                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MOD: //MOD b' a | sets b to b%a. if a==0' sets b to 0 instead.                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      AssignToOperand(operandB' value == 0 ? (ushort)0 : (ushort)(bValue % value)' true);                      break;                  case Intermediate.Instructions.MDI: //MDI b' a | like MOD' but treat b' a as signed. (MDI -7' 16 == -7)                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      AssignToOperand(operandB' value == 0 ? (ushort)0 : (ushort)((short)bValue % (short)value)' true);                      break;                  case Intermediate.Instructions.AND: //AND b' a | sets b to b&a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) & value)' true);                      break;                  case Intermediate.Instructions.BOR: //BOR b' a | sets b to b|a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) | value)' true);                      break;                  case Intermediate.Instructions.XOR: //XOR b' a | sets b to b^a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) ^ value));                      break;                  case Intermediate.Instructions.SHR: //SHR b' a | sets b to b>>>a' sets EX to ((b<<16)>>a)&0xffff (logical shift)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)(intermediate >> value)' true);                      AssignToEx((ushort)(intermediate << 16 >> value));                      break;                  case Intermediate.Instructions.ASR: //ASR b' a | sets b to b>>a' sets EX to ((b<<16)>>>a)&0xffff (arithmetic shift) (treats b as signed)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)((int)intermediate >> value)' true);                      AssignToEx((ushort)((int)intermediate << 16 >> value));                      break;                  case Intermediate.Instructions.SHL: //SHL b' a | sets b to b<<a' sets EX to ((b<<a)>>16)&0xffff                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)(intermediate << value)' true);                      AssignToEx((ushort)(intermediate << value >> 16));                      break;                  case Intermediate.Instructions.IFB: //IFB b' a | performs next instruction only if (b&a)!=0                      SkipIf = (GetOperandValue(operandB' OperandPlace.B) & value) != 0;                      break;                  case Intermediate.Instructions.IFC: //IFC b' a | performs next instruction only if (b&a)==0                      SkipIf = (GetOperandValue(operandB' OperandPlace.B) & value) == 0;                      break;                  case Intermediate.Instructions.IFE: //IFE b' a | performs next instruction only if b==a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) == value;                      break;                  case Intermediate.Instructions.IFN: //IFB b' a | performs next instruction only if b!=a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) != value;                      break;                  case Intermediate.Instructions.IFG: //IFG b' a | performs next instruction only if b>a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) > value;                      break;                  case Intermediate.Instructions.IFA: //IFA b' a | performs next instruction only if b>a (signed)                      SkipIf = (int)GetOperandValue(operandB' OperandPlace.B) > (int)value;                      break;                  case Intermediate.Instructions.IFL: //IFL b' a | performs next instruction only if b<a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) < value;                      break;                  case Intermediate.Instructions.IFU: //IFU b' a | performs next instruction only if b<a (signed)                      SkipIf = (int)GetOperandValue(operandB' OperandPlace.B) < (int)value;                      break;                  case Intermediate.Instructions.ADX: //ADX b' a | sets b to b+a+EX' sets EX to 0x0001 if there is an over-flow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) + value + registers[(int)Registers.EX];                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.SBX: //SBX b' a | sets b to b-a+EX' sets EX to 0xFFFF if there is an under-flow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) - value + registers[(int)Registers.EX];                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.STI: //STI b' a | sets b to a' then increases I and J by 1                      AssignToOperand(operandB' value' false);                      registers[(int)Registers.I] += 1;                      registers[(int)Registers.J] += 1;                      break;                  case Intermediate.Instructions.STD: //STI b' a | sets b to a' then decreases I and J by 1                      AssignToOperand(operandB' value' false);                      registers[(int)Registers.I] -= 1;                      registers[(int)Registers.J] -= 1;                      break;                    case Intermediate.Instructions.JSR: //pushes the address of the next instruction to the stack' then sets PC to a                      ram[(ushort)(registers[(int)Registers.SP] - 1)] = registers[(int)Registers.PC];                      registers[(int)Registers.SP] -= 1;                      registers[(int)Registers.PC] = value;                      break;                  case Intermediate.Instructions.HLT:                      throw new Halt();                    case Intermediate.Instructions.INT: //INT a | triggers a software interrupt with message a                      TriggerInterrupt(value);                      break;                  case Intermediate.Instructions.IAG: //IAG a | sets a to IA                       AssignToOperand(operandA' registers[(int)Registers.IA]' true);                      break;                  case Intermediate.Instructions.IAS: //IAS a | sets IA to A                       registers[(int)Registers.IA] = value;                      break;                  case Intermediate.Instructions.RFI: //RFI a | disables interrupt queueing' pops A from the stack' then pops PC from the stack                      protectInterruptQueue.WaitOne();                      interruptQueueEnabled = false;                      registers[(int)Registers.A] = ram[(ushort)(registers[(int)Registers.SP])];                      registers[(int)Registers.PC] = ram[(ushort)(registers[(int)Registers.SP] + 1)];                      registers[(int)Registers.SP] += 2;                      break;                  case Intermediate.Instructions.IAQ: //IAQ a | if a is nonzero' interrupts will be added to the queue                      interruptQueueEnabled = value != 0; //instead of triggered. if a is zero' interrupts will be                      break;                              //triggered as normal again                    case Intermediate.Instructions.HWN: //HWN a | sets a to number of connected hardware devices                      AssignToOperand(operandA' (ushort)devices.Count' true);                      break;                  case Intermediate.Instructions.HWQ: //HWQ a | sets A' B' C' X' Y registers to information about hardware a                       registers[(int)Registers.A] = (ushort)(devices[value].HardwareID & 0xFFFF); //A+(B<<16) is a 32 bit word identifying the hardware id                      registers[(int)Registers.B] = (ushort)((devices[value].HardwareID >> 16) & 0xFFFF);                      registers[(int)Registers.C] = devices[value].Version; //C is the hardware version                      registers[(int)Registers.X] = (ushort)(devices[value].ManufacturerID & 0xFFFF); //X+(Y<<16) is a 32 bit word identifying the manufacturer                      registers[(int)Registers.Y] = (ushort)((devices[value].ManufacturerID >> 16) & 0xFFFF);                      break;                  case Intermediate.Instructions.HWI: //HWI a | sends an interrupt to hardware a                      devices[value].OnInterrupt(this);                      break;              }
Missing Default,DCPUB.Ast,Target,D:\research\architectureSmells\repos\Blecki_DCPUB\DCPUB\Ast\Target.cs,GetOperand,The following switch statement is missing a default case: switch (usage)                  {                      case TargetUsage.Peek: return CompilableNode.Operand("PEEK"' semantics' offset);                      case TargetUsage.Push: return CompilableNode.Operand("PUSH"' semantics' offset);                      case TargetUsage.Pop: return CompilableNode.Operand("POP"' semantics' offset);                  }
