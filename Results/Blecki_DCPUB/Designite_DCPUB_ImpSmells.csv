Implementation smell,Namespace,Class,File,Method,Description
Long Method,DCPUB.Intermediate,StatementNode,C:\repos\Blecki_DCPUB\DCPUB\Intermediate\StatementNode_SSA.cs,__ApplySSA,The method has 204 lines of code.
Long Method,DCPUB.Testing,Emulator,C:\repos\Blecki_DCPUB\DCPUB\Testing\Emulator.cs,Step,The method has 209 lines of code.
Long Method,DCPUB,Grammar,C:\repos\Blecki_DCPUB\DCPUB\Grammar.cs,Grammar,The method has 131 lines of code.
Complex Method,DCPUB.Intermediate,Instruction,C:\repos\Blecki_DCPUB\DCPUB\Intermediate\Instruction_EncodeOperand.cs,EncodeOperand,Cyclomatic complexity of the method is 17
Complex Method,DCPUB.Intermediate,StatementNode,C:\repos\Blecki_DCPUB\DCPUB\Intermediate\StatementNode_SSA.cs,AssignRealRegisterToOperand,Cyclomatic complexity of the method is 8
Complex Method,DCPUB.Intermediate,Operand,C:\repos\Blecki_DCPUB\DCPUB\Intermediate\Operand.cs,OperandsEqual,Cyclomatic complexity of the method is 11
Complex Method,DCPUB.Preprocessor,Parser,C:\repos\Blecki_DCPUB\DCPUB\Preprocessor\Parser.cs,ParseDirective,Cyclomatic complexity of the method is 9
Complex Method,DCPUB.Testing,Emulator,C:\repos\Blecki_DCPUB\DCPUB\Testing\Emulator.cs,Step,Cyclomatic complexity of the method is 9
Complex Method,DCPUB.Ast,AddressOfNode,C:\repos\Blecki_DCPUB\DCPUB\Ast\AddressOfNode.cs,ResolveTypes,Cyclomatic complexity of the method is 8
Complex Method,DCPUB.Ast,FunctionDeclarationNode,C:\repos\Blecki_DCPUB\DCPUB\Ast\FunctionDeclarationNode.cs,CompileFunction,Cyclomatic complexity of the method is 13
Complex Method,DCPUB.Ast,VariableDeclarationNode,C:\repos\Blecki_DCPUB\DCPUB\Ast\VariableDeclarationNode.cs,ResolveTypes,Cyclomatic complexity of the method is 9
Long Parameter List,DCPUB.Ast,BinaryOperator,C:\repos\Blecki_DCPUB\DCPUB\Ast\BinaryOperationNode.cs,Emit,The method has 5 parameters. Parameters: Context' Scope' Target' Lhs' Rhs
Long Parameter List,DCPUB.Ast,BasicBinaryOperator,C:\repos\Blecki_DCPUB\DCPUB\Ast\BinaryOperationNode.cs,Emit,The method has 5 parameters. Parameters: Context' Scope' Target' Lhs' Rhs
Long Parameter List,DCPUB.Ast,ComparisonBinaryOperator,C:\repos\Blecki_DCPUB\DCPUB\Ast\BinaryOperationNode.cs,Emit,The method has 5 parameters. Parameters: Context' Scope' Target' Lhs' Rhs
Long Parameter List,DCPUB.Ast,LogicalBinaryOperator,C:\repos\Blecki_DCPUB\DCPUB\Ast\BinaryOperationNode.cs,Emit,The method has 5 parameters. Parameters: Context' Scope' Target' Lhs' Rhs
Long Statement,DCPUB.Intermediate,StatementNode,C:\repos\Blecki_DCPUB\DCPUB\Intermediate\StatementNode_SSA.cs,__ApplySSA,The length of the statement  "                            ssa_instructions.AddInstruction(Instructions.SET' CompilableNode.Virtual(first_operand.virtual_register)' ori_first_operand); " is 125.
Long Statement,DCPUB.Intermediate,StatementNode,C:\repos\Blecki_DCPUB\DCPUB\Intermediate\StatementNode_SSA.cs,__ApplySSA,The length of the statement  "                            ssa_instructions.AddInstruction(ins.instruction' CompilableNode.Virtual(first_operand.virtual_register)' second_operand); " is 121.
Long Statement,DCPUB.Intermediate,StatementNode,C:\repos\Blecki_DCPUB\DCPUB\Intermediate\StatementNode_SSA.cs,AssignRegisters,The length of the statement  "                    if (instruction.secondOperand != null) AssignRealRegisterToOperand(mapping' usedRegisters' (i * 2) + 1' instruction.secondOperand); " is 131.
Long Statement,DCPUB.Preprocessor,Parser,C:\repos\Blecki_DCPUB\DCPUB\Preprocessor\Parser.cs,ParseDirective,The length of the statement  "                state.LineLocationTable.AddLocation(state.filename' state.totalLinesInResult + result.Item2.totalLinesInResult' state.currentLineInFile); " is 137.
Long Statement,DCPUB.Testing,Emulator,C:\repos\Blecki_DCPUB\DCPUB\Testing\Emulator.cs,Step,The length of the statement  "                case Intermediate.Instructions.SUB: //SUB b' a | sets b to b-a' sets EX to 0xffff if there's an underflow' 0x0 otherwise " is 120.
Long Statement,DCPUB.Testing,Emulator,C:\repos\Blecki_DCPUB\DCPUB\Testing\Emulator.cs,Step,The length of the statement  "                case Intermediate.Instructions.DIV: //DIV b' a | sets b to b/a' sets EX to ((b<<16)/a)&0xffff. if a==0' sets b and EX to 0 instead. (treats b' a as unsigned) " is 157.
Long Statement,DCPUB.Testing,Emulator,C:\repos\Blecki_DCPUB\DCPUB\Testing\Emulator.cs,Step,The length of the statement  "                case Intermediate.Instructions.ASR: //ASR b' a | sets b to b>>a' sets EX to ((b<<16)>>>a)&0xffff (arithmetic shift) (treats b as signed) " is 136.
Long Statement,DCPUB.Testing,Emulator,C:\repos\Blecki_DCPUB\DCPUB\Testing\Emulator.cs,Step,The length of the statement  "                case Intermediate.Instructions.ADX: //ADX b' a | sets b to b+a+EX' sets EX to 0x0001 if there is an over-flow' 0x0 otherwise " is 124.
Long Statement,DCPUB.Testing,Emulator,C:\repos\Blecki_DCPUB\DCPUB\Testing\Emulator.cs,Step,The length of the statement  "                case Intermediate.Instructions.SBX: //SBX b' a | sets b to b-a+EX' sets EX to 0xFFFF if there is an under-flow' 0x0 otherwise " is 125.
Long Statement,DCPUB.Testing,Emulator,C:\repos\Blecki_DCPUB\DCPUB\Testing\Emulator.cs,Step,The length of the statement  "                case Intermediate.Instructions.RFI: //RFI a | disables interrupt queueing' pops A from the stack' then pops PC from the stack " is 125.
Long Statement,DCPUB.Testing,Emulator,C:\repos\Blecki_DCPUB\DCPUB\Testing\Emulator.cs,Step,The length of the statement  "                    registers[(int)Registers.A] = (ushort)(devices[value].HardwareID & 0xFFFF); //A+(B<<16) is a 32 bit word identifying the hardware id " is 132.
Long Statement,DCPUB.Testing,Emulator,C:\repos\Blecki_DCPUB\DCPUB\Testing\Emulator.cs,Step,The length of the statement  "                    registers[(int)Registers.X] = (ushort)(devices[value].ManufacturerID & 0xFFFF); //X+(Y<<16) is a 32 bit word identifying the manufacturer " is 137.
Long Statement,DCPUB,CompileContext,C:\repos\Blecki_DCPUB\DCPUB\CompileContext.cs,Parse,The length of the statement  "                    onError("%PARSER " + msg.Level + ": " + msg.Message + " [line:" + msg.Location.Line + " column:" + msg.Location.Column + "]\r\n"); " is 130.
Long Statement,DCPUB,CompileContext,C:\repos\Blecki_DCPUB\DCPUB\CompileContext.cs,Compile,The length of the statement  "            globalScope.variables.Add(new Model.Variable { type = Model.VariableType.ConstantLabel' name = "__endofprogram"' staticLabel = end_label }); " is 140.
Long Statement,DCPUB,CompileContext,C:\repos\Blecki_DCPUB\DCPUB\CompileContext.cs,Compile,The length of the statement  "            globalScope.variables.Add(new Model.Variable { name = "false"' type = Model.VariableType.Constant' constantValue = 0 }); " is 120.
Long Statement,DCPUB.Ast,AddressOfNode,C:\repos\Blecki_DCPUB\DCPUB\Ast\AddressOfNode.cs,Emit,The length of the statement  "                    r.AddInstruction(Instructions.SET' target.GetOperand(TargetUsage.Push)' target.GetOperand(TargetUsage.Peek' OperandSemantics.Dereference)); " is 139.
Long Statement,DCPUB.Ast,LogicalBinaryOperator,C:\repos\Blecki_DCPUB\DCPUB\Ast\BinaryOperationNode.cs,Emit,The length of the statement  "                r.AddInstruction(Instructions.IFN' intermediate.GetOperand(TargetUsage.Peek)' secondTarget.GetOperand(TargetUsage.Peek)); " is 121.
Long Statement,DCPUB.Ast,BinaryOperationNode,C:\repos\Blecki_DCPUB\DCPUB\Ast\BinaryOperationNode.cs,Init,The length of the statement  "            //Console.WriteLine("{0} {1} {2}\n"' treeNode.ChildNodes[0].ToString()' treeNode.ChildNodes[1].ToString()' treeNode.ChildNodes[2].ToString()); " is 142.
Long Statement,DCPUB.Ast,BlockNode,C:\repos\Blecki_DCPUB\DCPUB\Ast\BlockNode.cs,Emit,The length of the statement  "                    r.AddInstruction(Instructions.ADD' Operand("SP")' Constant((ushort)(blockScope.variablesOnStack - scope.variablesOnStack))); " is 124.
Long Statement,DCPUB.Ast,VariableNameNode,C:\repos\Blecki_DCPUB\DCPUB\Ast\VariableNameNode.cs,Emit,The length of the statement  "                r.AddInstruction(Instructions.SET' target.GetOperand(TargetUsage.Peek)' target.GetOperand(TargetUsage.Peek' Intermediate.OperandSemantics.Dereference)); " is 152.
Long Statement,DCPUB.Ast,VariableNameNode,C:\repos\Blecki_DCPUB\DCPUB\Ast\VariableNameNode.cs,Emit,The length of the statement  "                r.AddInstruction(Instructions.SET' target.GetOperand(TargetUsage.Peek)' target.GetOperand(TargetUsage.Peek' Intermediate.OperandSemantics.Dereference)); " is 152.
Complex Conditional,DCPUB.Intermediate,StatementNode,C:\repos\Blecki_DCPUB\DCPUB\Intermediate\StatementNode_SSA.cs,__ApplySSA,The conditional expression  "c_ins.secondOperand != null                              && c_ins.secondOperand.semantics == OperandSemantics.None                              && c_ins.secondOperand.register == OperandRegister.VIRTUAL                              && c_ins.secondOperand.virtual_register == valueName.virtual_register"  is complex.
Complex Conditional,DCPUB.Intermediate,StatementNode,C:\repos\Blecki_DCPUB\DCPUB\Intermediate\StatementNode_SSA.cs,__ApplySSA,The conditional expression  "c_ins.firstOperand.semantics == OperandSemantics.None                              && c_ins.firstOperand.register == OperandRegister.VIRTUAL                              && c_ins.firstOperand.virtual_register == valueName.virtual_register                              // But don't fuck with J                              && !(value.semantics == OperandSemantics.None && value.register == OperandRegister.J)"  is complex.
Complex Conditional,DCPUB.Ast,BinaryOperationNode,C:\repos\Blecki_DCPUB\DCPUB\Ast\BinaryOperationNode.cs,GetFetchToken,The conditional expression  "A != null && (A.semantics & Intermediate.OperandSemantics.Constant) == Intermediate.OperandSemantics.Constant                  && B != null && (B.semantics & Intermediate.OperandSemantics.Constant) == Intermediate.OperandSemantics.Constant"  is complex.
Magic Number,DCPUB.Intermediate,Instruction,C:\repos\Blecki_DCPUB\DCPUB\Intermediate\Instruction_EncodeOperand.cs,EncodeOperand,The following statement contains a magic number: if ((op.semantics & OperandSemantics.Constant) == OperandSemantics.Constant)              {                  if ((op.semantics & OperandSemantics.Dereference) == OperandSemantics.Dereference)                      return new Tuple<ushort' Box<ushort>>(0x1e' new Box<ushort> { data = op.constant });                                        if (usage == OperandUsage.A && op.constant == 0xFFFF)                      return new Tuple<ushort' Box<ushort>>(0x20' null);                  if (usage == OperandUsage.A && op.constant <= 30)                      return new Tuple<ushort' Box<ushort>>((ushort)(0x21u + op.constant)' null);                    return new Tuple<ushort' Box<ushort>>(0x1f' new Box<ushort> { data = op.constant });              }
Magic Number,DCPUB.Intermediate,Instruction,C:\repos\Blecki_DCPUB\DCPUB\Intermediate\Instruction_EncodeOperand.cs,EncodeOperand,The following statement contains a magic number: if ((op.semantics & OperandSemantics.Dereference) == OperandSemantics.Dereference)              {                  r += 8;                  if ((op.semantics & OperandSemantics.Offset) == OperandSemantics.Offset)                  {                      r += 8;                      return new Tuple<ushort'Box<ushort>>(r' new Box<ushort>{ data = op.constant });                  }                  else                      return new Tuple<ushort'Box<ushort>>(r' null);              }              else                  return new Tuple<ushort'Box<ushort>>(r' null);
Magic Number,DCPUB.Intermediate,Instruction,C:\repos\Blecki_DCPUB\DCPUB\Intermediate\Instruction_EncodeOperand.cs,EncodeOperand,The following statement contains a magic number: if ((op.semantics & OperandSemantics.Dereference) == OperandSemantics.Dereference)              {                  r += 8;                  if ((op.semantics & OperandSemantics.Offset) == OperandSemantics.Offset)                  {                      r += 8;                      return new Tuple<ushort'Box<ushort>>(r' new Box<ushort>{ data = op.constant });                  }                  else                      return new Tuple<ushort'Box<ushort>>(r' null);              }              else                  return new Tuple<ushort'Box<ushort>>(r' null);
Magic Number,DCPUB.Intermediate,Instruction,C:\repos\Blecki_DCPUB\DCPUB\Intermediate\Instruction_EncodeOperand.cs,ErrorCheck,The following statement contains a magic number: if (firstOperand == null)                  Context.ReportError(Ast' "No operands for instruction");              else if (instruction.GetOperandCount() == 1 && secondOperand != null)                  Context.ReportError(Ast' "Instruction takes one argument - " + instruction.ToString());              else if (instruction.GetOperandCount() == 2 && secondOperand == null)                  Context.ReportError(Ast' "Instruction takes two arguments - " + instruction.ToString());
Magic Number,DCPUB.Intermediate,Instruction,C:\repos\Blecki_DCPUB\DCPUB\Intermediate\Instruction_EncodeOperand.cs,EmitBinary,The following statement contains a magic number: if (instruction == Instructions.HLT)              {                  ins.data += (ushort)(((ushort)instruction - (ushort)Instructions.SINGLE_OPERAND_INSTRUCTIONS) << 5);              }              else if (instruction < Instructions.SINGLE_OPERAND_INSTRUCTIONS)              {                  var A = EncodeOperand(secondOperand' OperandUsage.A);                  if (A.Item2 != null) binary.Add(A.Item2);                  ins.data += (ushort)(A.Item1 << 10);                    var B = EncodeOperand(firstOperand' OperandUsage.B);                  if (B.Item2 != null) binary.Add(B.Item2);                  ins.data += (ushort)(B.Item1 << 5);                    ins.data += (ushort)instruction;              }              else              {                  var A = EncodeOperand(firstOperand' OperandUsage.A);                  if (A.Item2 != null) binary.Add(A.Item2);                  ins.data += (ushort)(A.Item1 << 10);                    ins.data += (ushort)(((ushort)instruction - (ushort)Instructions.SINGLE_OPERAND_INSTRUCTIONS) << 5);              }
Magic Number,DCPUB.Intermediate,Instruction,C:\repos\Blecki_DCPUB\DCPUB\Intermediate\Instruction_EncodeOperand.cs,EmitBinary,The following statement contains a magic number: if (instruction == Instructions.HLT)              {                  ins.data += (ushort)(((ushort)instruction - (ushort)Instructions.SINGLE_OPERAND_INSTRUCTIONS) << 5);              }              else if (instruction < Instructions.SINGLE_OPERAND_INSTRUCTIONS)              {                  var A = EncodeOperand(secondOperand' OperandUsage.A);                  if (A.Item2 != null) binary.Add(A.Item2);                  ins.data += (ushort)(A.Item1 << 10);                    var B = EncodeOperand(firstOperand' OperandUsage.B);                  if (B.Item2 != null) binary.Add(B.Item2);                  ins.data += (ushort)(B.Item1 << 5);                    ins.data += (ushort)instruction;              }              else              {                  var A = EncodeOperand(firstOperand' OperandUsage.A);                  if (A.Item2 != null) binary.Add(A.Item2);                  ins.data += (ushort)(A.Item1 << 10);                    ins.data += (ushort)(((ushort)instruction - (ushort)Instructions.SINGLE_OPERAND_INSTRUCTIONS) << 5);              }
Magic Number,DCPUB.Intermediate,Instruction,C:\repos\Blecki_DCPUB\DCPUB\Intermediate\Instruction_EncodeOperand.cs,EmitBinary,The following statement contains a magic number: if (instruction == Instructions.HLT)              {                  ins.data += (ushort)(((ushort)instruction - (ushort)Instructions.SINGLE_OPERAND_INSTRUCTIONS) << 5);              }              else if (instruction < Instructions.SINGLE_OPERAND_INSTRUCTIONS)              {                  var A = EncodeOperand(secondOperand' OperandUsage.A);                  if (A.Item2 != null) binary.Add(A.Item2);                  ins.data += (ushort)(A.Item1 << 10);                    var B = EncodeOperand(firstOperand' OperandUsage.B);                  if (B.Item2 != null) binary.Add(B.Item2);                  ins.data += (ushort)(B.Item1 << 5);                    ins.data += (ushort)instruction;              }              else              {                  var A = EncodeOperand(firstOperand' OperandUsage.A);                  if (A.Item2 != null) binary.Add(A.Item2);                  ins.data += (ushort)(A.Item1 << 10);                    ins.data += (ushort)(((ushort)instruction - (ushort)Instructions.SINGLE_OPERAND_INSTRUCTIONS) << 5);              }
Magic Number,DCPUB.Intermediate,Instruction,C:\repos\Blecki_DCPUB\DCPUB\Intermediate\Instruction_EncodeOperand.cs,EmitBinary,The following statement contains a magic number: if (instruction == Instructions.HLT)              {                  ins.data += (ushort)(((ushort)instruction - (ushort)Instructions.SINGLE_OPERAND_INSTRUCTIONS) << 5);              }              else if (instruction < Instructions.SINGLE_OPERAND_INSTRUCTIONS)              {                  var A = EncodeOperand(secondOperand' OperandUsage.A);                  if (A.Item2 != null) binary.Add(A.Item2);                  ins.data += (ushort)(A.Item1 << 10);                    var B = EncodeOperand(firstOperand' OperandUsage.B);                  if (B.Item2 != null) binary.Add(B.Item2);                  ins.data += (ushort)(B.Item1 << 5);                    ins.data += (ushort)instruction;              }              else              {                  var A = EncodeOperand(firstOperand' OperandUsage.A);                  if (A.Item2 != null) binary.Add(A.Item2);                  ins.data += (ushort)(A.Item1 << 10);                    ins.data += (ushort)(((ushort)instruction - (ushort)Instructions.SINGLE_OPERAND_INSTRUCTIONS) << 5);              }
Magic Number,DCPUB.Intermediate,Instruction,C:\repos\Blecki_DCPUB\DCPUB\Intermediate\Instruction_EncodeOperand.cs,EmitBinary,The following statement contains a magic number: if (instruction == Instructions.HLT)              {                  ins.data += (ushort)(((ushort)instruction - (ushort)Instructions.SINGLE_OPERAND_INSTRUCTIONS) << 5);              }              else if (instruction < Instructions.SINGLE_OPERAND_INSTRUCTIONS)              {                  var A = EncodeOperand(secondOperand' OperandUsage.A);                  if (A.Item2 != null) binary.Add(A.Item2);                  ins.data += (ushort)(A.Item1 << 10);                    var B = EncodeOperand(firstOperand' OperandUsage.B);                  if (B.Item2 != null) binary.Add(B.Item2);                  ins.data += (ushort)(B.Item1 << 5);                    ins.data += (ushort)instruction;              }              else              {                  var A = EncodeOperand(firstOperand' OperandUsage.A);                  if (A.Item2 != null) binary.Add(A.Item2);                  ins.data += (ushort)(A.Item1 << 10);                    ins.data += (ushort)(((ushort)instruction - (ushort)Instructions.SINGLE_OPERAND_INSTRUCTIONS) << 5);              }
Magic Number,DCPUB.Intermediate,StatementNode,C:\repos\Blecki_DCPUB\DCPUB\Intermediate\StatementNode_SSA.cs,AssignRealRegisterToOperand,The following statement contains a magic number: if (operand.register == OperandRegister.VIRTUAL)              {                  if (!mapping.ContainsKey(operand.virtual_register)) throw new InternalError("Virtual register not marked.");                  if (mapping[operand.virtual_register].assignedRegister == OperandRegister.A)                  {                      //Assign a register to this virtual register.                      int reg = -1;                      for (int r = 0; r < 6; ++r)                          if (usedRegisters[r] == false) reg = r;                      if (reg == -1) throw new InternalError("Register spill.");                      mapping[operand.virtual_register].assignedRegister = (OperandRegister)(reg + 1);                      usedRegisters[reg] = true;                  }                  operand.register = mapping[operand.virtual_register].assignedRegister;                  if (mapping[operand.virtual_register].last_instruction == i)                      usedRegisters[(int)(mapping[operand.virtual_register].assignedRegister) - 1] = false;              }
Magic Number,DCPUB.Intermediate,StatementNode,C:\repos\Blecki_DCPUB\DCPUB\Intermediate\StatementNode_SSA.cs,AssignRegisters,The following statement contains a magic number: for (int i = 0; i < children.Count; ++i)              {                                 if (children[i] is Instruction)                  {                      var instruction = children[i] as Instruction;                      MarkVirtualRegisterLifetime(mapping' i * 2' instruction.firstOperand);                      if (instruction.secondOperand != null) MarkVirtualRegisterLifetime(mapping' (i * 2) + 1' instruction.secondOperand);                  }              }
Magic Number,DCPUB.Intermediate,StatementNode,C:\repos\Blecki_DCPUB\DCPUB\Intermediate\StatementNode_SSA.cs,AssignRegisters,The following statement contains a magic number: for (int i = 0; i < children.Count; ++i)              {                                 if (children[i] is Instruction)                  {                      var instruction = children[i] as Instruction;                      MarkVirtualRegisterLifetime(mapping' i * 2' instruction.firstOperand);                      if (instruction.secondOperand != null) MarkVirtualRegisterLifetime(mapping' (i * 2) + 1' instruction.secondOperand);                  }              }
Magic Number,DCPUB.Intermediate,StatementNode,C:\repos\Blecki_DCPUB\DCPUB\Intermediate\StatementNode_SSA.cs,AssignRegisters,The following statement contains a magic number: bool[] usedRegisters = new bool[6] { false' false' false' false' false' false };
Magic Number,DCPUB.Intermediate,StatementNode,C:\repos\Blecki_DCPUB\DCPUB\Intermediate\StatementNode_SSA.cs,AssignRegisters,The following statement contains a magic number: for (int i = 0; i < children.Count; ++i)              {                  if (children[i] is Instruction)                  {                      var instruction = children[i] as Instruction;                        // Assigning registers in reverse allows the from register to un-mark it's real register.                      // Then the destination register can recycle it in the same instruction.                      // TODO: Make this change after some validation that it won't break things.                      AssignRealRegisterToOperand(mapping' usedRegisters' i * 2' instruction.firstOperand);                        if (instruction.secondOperand != null) AssignRealRegisterToOperand(mapping' usedRegisters' (i * 2) + 1' instruction.secondOperand);                    }              }
Magic Number,DCPUB.Intermediate,StatementNode,C:\repos\Blecki_DCPUB\DCPUB\Intermediate\StatementNode_SSA.cs,AssignRegisters,The following statement contains a magic number: for (int i = 0; i < children.Count; ++i)              {                  if (children[i] is Instruction)                  {                      var instruction = children[i] as Instruction;                        // Assigning registers in reverse allows the from register to un-mark it's real register.                      // Then the destination register can recycle it in the same instruction.                      // TODO: Make this change after some validation that it won't break things.                      AssignRealRegisterToOperand(mapping' usedRegisters' i * 2' instruction.firstOperand);                        if (instruction.secondOperand != null) AssignRealRegisterToOperand(mapping' usedRegisters' (i * 2) + 1' instruction.secondOperand);                    }              }
Magic Number,DCPUB.Intermediate,InlineStaticData,C:\repos\Blecki_DCPUB\DCPUB\Intermediate\InlineStaticDataNode.cs,EmitBinary,The following statement contains a magic number: foreach (var op in data)              {                  if ((op.semantics & OperandSemantics.Label) == OperandSemantics.Label)                  {                      if (op.label.rawLabel[0] == '\"')                          foreach (var c in op.label.rawLabel.Substring(1' op.label.rawLabel.Length - 2))                              binary.Add(new Box<ushort> { data = (ushort)c });                      else                          binary.Add(op.label.position);                  }                  else                      binary.Add(new Box<ushort> { data = op.constant });              }
Magic Number,DCPUB.Intermediate,InstructionExtension,C:\repos\Blecki_DCPUB\DCPUB\Intermediate\Instructions.cs,GetOperandCount,The following statement contains a magic number: return 2;
Magic Number,DCPUB.Intermediate,LabelNode,C:\repos\Blecki_DCPUB\DCPUB\Intermediate\LabelNode.cs,Emit,The following statement contains a magic number: stream.WriteLine(new String(' '' stream.indentDepth * 3) + ":" + label);
Magic Number,DCPUB.Testing,Emulator,C:\repos\Blecki_DCPUB\DCPUB\Testing\Emulator.cs,Disassemble,The following statement contains a magic number: ushort operandA = (ushort)((instruction & 0xFC00) >> 10);
Magic Number,DCPUB.Testing,Emulator,C:\repos\Blecki_DCPUB\DCPUB\Testing\Emulator.cs,Disassemble,The following statement contains a magic number: ushort operandB = (ushort)((instruction >> 5) & 0x1F);
Magic Number,DCPUB.Testing,Emulator,C:\repos\Blecki_DCPUB\DCPUB\Testing\Emulator.cs,Step,The following statement contains a magic number: if (!interruptQueueEnabled && queuedInterrupts.Count > 0)              {                  var interruptCode = queuedInterrupts[0];                  queuedInterrupts.RemoveAt(0);                    if (registers[(int)Registers.IA] != 0)                  {                      interruptQueueEnabled = true;                      ram[(ushort)(registers[(int)Registers.SP] - 1)] = registers[(int)Registers.PC];                      ram[(ushort)(registers[(int)Registers.SP] - 2)] = registers[(int)Registers.A];                      registers[(int)Registers.SP] -= 2;                      registers[(int)Registers.PC] = registers[(int)Registers.IA];                      registers[(int)Registers.A] = interruptCode;                  }                }
Magic Number,DCPUB.Testing,Emulator,C:\repos\Blecki_DCPUB\DCPUB\Testing\Emulator.cs,Step,The following statement contains a magic number: if (!interruptQueueEnabled && queuedInterrupts.Count > 0)              {                  var interruptCode = queuedInterrupts[0];                  queuedInterrupts.RemoveAt(0);                    if (registers[(int)Registers.IA] != 0)                  {                      interruptQueueEnabled = true;                      ram[(ushort)(registers[(int)Registers.SP] - 1)] = registers[(int)Registers.PC];                      ram[(ushort)(registers[(int)Registers.SP] - 2)] = registers[(int)Registers.A];                      registers[(int)Registers.SP] -= 2;                      registers[(int)Registers.PC] = registers[(int)Registers.IA];                      registers[(int)Registers.A] = interruptCode;                  }                }
Magic Number,DCPUB.Testing,Emulator,C:\repos\Blecki_DCPUB\DCPUB\Testing\Emulator.cs,Step,The following statement contains a magic number: ushort operandA = (ushort)((instruction & 0xFC00) >> 10);
Magic Number,DCPUB.Testing,Emulator,C:\repos\Blecki_DCPUB\DCPUB\Testing\Emulator.cs,Step,The following statement contains a magic number: ushort operandB = (ushort)((instruction >> 5) & 0x1F);
Magic Number,DCPUB.Testing,Emulator,C:\repos\Blecki_DCPUB\DCPUB\Testing\Emulator.cs,Step,The following statement contains a magic number: switch (ins)              {                  case Intermediate.Instructions.SET: //0x01 | SET b' a | sets b to a                      AssignToOperand(operandB' value' false);                      break;                  case Intermediate.Instructions.ADD: //ADD b' a | sets b to b+a' sets EX to 0x0001 if there's an overflow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) + value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.SUB: //SUB b' a | sets b to b-a' sets EX to 0xffff if there's an underflow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) - value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MUL: //MUL b' a | sets b to b*a' sets EX to ((b*a)>>16)&0xffff (treats b' a as unsigned)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) * value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MLI: //MLI b' a | like MUL' but treat b' a as signed                      intermediate = (UInt32)((short)GetOperandValue(operandB' OperandPlace.B) * (short)value);                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.DIV: //DIV b' a | sets b to b/a' sets EX to ((b<<16)/a)&0xffff. if a==0' sets b and EX to 0 instead. (treats b' a as unsigned)                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      intermediate = value == 0 ? 0 : (UInt32)bValue / value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.DVI: //DVI b' a | like DIV' but treat b' a as signed. Rounds towards 0                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      intermediate = value == 0 ? 0 : (UInt32)((short)bValue / (short)value);                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MOD: //MOD b' a | sets b to b%a. if a==0' sets b to 0 instead.                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      AssignToOperand(operandB' value == 0 ? (ushort)0 : (ushort)(bValue % value)' true);                      break;                  case Intermediate.Instructions.MDI: //MDI b' a | like MOD' but treat b' a as signed. (MDI -7' 16 == -7)                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      AssignToOperand(operandB' value == 0 ? (ushort)0 : (ushort)((short)bValue % (short)value)' true);                      break;                  case Intermediate.Instructions.AND: //AND b' a | sets b to b&a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) & value)' true);                      break;                  case Intermediate.Instructions.BOR: //BOR b' a | sets b to b|a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) | value)' true);                      break;                  case Intermediate.Instructions.XOR: //XOR b' a | sets b to b^a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) ^ value));                      break;                  case Intermediate.Instructions.SHR: //SHR b' a | sets b to b>>>a' sets EX to ((b<<16)>>a)&0xffff (logical shift)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)(intermediate >> value)' true);                      AssignToEx((ushort)(intermediate << 16 >> value));                      break;                  case Intermediate.Instructions.ASR: //ASR b' a | sets b to b>>a' sets EX to ((b<<16)>>>a)&0xffff (arithmetic shift) (treats b as signed)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)((int)intermediate >> value)' true);                      AssignToEx((ushort)((int)intermediate << 16 >> value));                      break;                  case Intermediate.Instructions.SHL: //SHL b' a | sets b to b<<a' sets EX to ((b<<a)>>16)&0xffff                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)(intermediate << value)' true);                      AssignToEx((ushort)(intermediate << value >> 16));                      break;                  case Intermediate.Instructions.IFB: //IFB b' a | performs next instruction only if (b&a)!=0                      SkipIf = (GetOperandValue(operandB' OperandPlace.B) & value) != 0;                      break;                  case Intermediate.Instructions.IFC: //IFC b' a | performs next instruction only if (b&a)==0                      SkipIf = (GetOperandValue(operandB' OperandPlace.B) & value) == 0;                      break;                  case Intermediate.Instructions.IFE: //IFE b' a | performs next instruction only if b==a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) == value;                      break;                  case Intermediate.Instructions.IFN: //IFB b' a | performs next instruction only if b!=a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) != value;                      break;                  case Intermediate.Instructions.IFG: //IFG b' a | performs next instruction only if b>a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) > value;                      break;                  case Intermediate.Instructions.IFA: //IFA b' a | performs next instruction only if b>a (signed)                      SkipIf = (int)GetOperandValue(operandB' OperandPlace.B) > (int)value;                      break;                  case Intermediate.Instructions.IFL: //IFL b' a | performs next instruction only if b<a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) < value;                      break;                  case Intermediate.Instructions.IFU: //IFU b' a | performs next instruction only if b<a (signed)                      SkipIf = (int)GetOperandValue(operandB' OperandPlace.B) < (int)value;                      break;                  case Intermediate.Instructions.ADX: //ADX b' a | sets b to b+a+EX' sets EX to 0x0001 if there is an over-flow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) + value + registers[(int)Registers.EX];                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.SBX: //SBX b' a | sets b to b-a+EX' sets EX to 0xFFFF if there is an under-flow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) - value + registers[(int)Registers.EX];                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.STI: //STI b' a | sets b to a' then increases I and J by 1                      AssignToOperand(operandB' value' false);                      registers[(int)Registers.I] += 1;                      registers[(int)Registers.J] += 1;                      break;                  case Intermediate.Instructions.STD: //STI b' a | sets b to a' then decreases I and J by 1                      AssignToOperand(operandB' value' false);                      registers[(int)Registers.I] -= 1;                      registers[(int)Registers.J] -= 1;                      break;                    case Intermediate.Instructions.JSR: //pushes the address of the next instruction to the stack' then sets PC to a                      ram[(ushort)(registers[(int)Registers.SP] - 1)] = registers[(int)Registers.PC];                      registers[(int)Registers.SP] -= 1;                      registers[(int)Registers.PC] = value;                      break;                  case Intermediate.Instructions.HLT:                      throw new Halt();                    case Intermediate.Instructions.INT: //INT a | triggers a software interrupt with message a                      TriggerInterrupt(value);                      break;                  case Intermediate.Instructions.IAG: //IAG a | sets a to IA                       AssignToOperand(operandA' registers[(int)Registers.IA]' true);                      break;                  case Intermediate.Instructions.IAS: //IAS a | sets IA to A                       registers[(int)Registers.IA] = value;                      break;                  case Intermediate.Instructions.RFI: //RFI a | disables interrupt queueing' pops A from the stack' then pops PC from the stack                      protectInterruptQueue.WaitOne();                      interruptQueueEnabled = false;                      registers[(int)Registers.A] = ram[(ushort)(registers[(int)Registers.SP])];                      registers[(int)Registers.PC] = ram[(ushort)(registers[(int)Registers.SP] + 1)];                      registers[(int)Registers.SP] += 2;                      break;                  case Intermediate.Instructions.IAQ: //IAQ a | if a is nonzero' interrupts will be added to the queue                      interruptQueueEnabled = value != 0; //instead of triggered. if a is zero' interrupts will be                      break;                              //triggered as normal again                    case Intermediate.Instructions.HWN: //HWN a | sets a to number of connected hardware devices                      AssignToOperand(operandA' (ushort)devices.Count' true);                      break;                  case Intermediate.Instructions.HWQ: //HWQ a | sets A' B' C' X' Y registers to information about hardware a                       registers[(int)Registers.A] = (ushort)(devices[value].HardwareID & 0xFFFF); //A+(B<<16) is a 32 bit word identifying the hardware id                      registers[(int)Registers.B] = (ushort)((devices[value].HardwareID >> 16) & 0xFFFF);                      registers[(int)Registers.C] = devices[value].Version; //C is the hardware version                      registers[(int)Registers.X] = (ushort)(devices[value].ManufacturerID & 0xFFFF); //X+(Y<<16) is a 32 bit word identifying the manufacturer                      registers[(int)Registers.Y] = (ushort)((devices[value].ManufacturerID >> 16) & 0xFFFF);                      break;                  case Intermediate.Instructions.HWI: //HWI a | sends an interrupt to hardware a                      devices[value].OnInterrupt(this);                      break;              }
Magic Number,DCPUB.Testing,Emulator,C:\repos\Blecki_DCPUB\DCPUB\Testing\Emulator.cs,Step,The following statement contains a magic number: switch (ins)              {                  case Intermediate.Instructions.SET: //0x01 | SET b' a | sets b to a                      AssignToOperand(operandB' value' false);                      break;                  case Intermediate.Instructions.ADD: //ADD b' a | sets b to b+a' sets EX to 0x0001 if there's an overflow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) + value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.SUB: //SUB b' a | sets b to b-a' sets EX to 0xffff if there's an underflow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) - value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MUL: //MUL b' a | sets b to b*a' sets EX to ((b*a)>>16)&0xffff (treats b' a as unsigned)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) * value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MLI: //MLI b' a | like MUL' but treat b' a as signed                      intermediate = (UInt32)((short)GetOperandValue(operandB' OperandPlace.B) * (short)value);                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.DIV: //DIV b' a | sets b to b/a' sets EX to ((b<<16)/a)&0xffff. if a==0' sets b and EX to 0 instead. (treats b' a as unsigned)                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      intermediate = value == 0 ? 0 : (UInt32)bValue / value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.DVI: //DVI b' a | like DIV' but treat b' a as signed. Rounds towards 0                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      intermediate = value == 0 ? 0 : (UInt32)((short)bValue / (short)value);                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MOD: //MOD b' a | sets b to b%a. if a==0' sets b to 0 instead.                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      AssignToOperand(operandB' value == 0 ? (ushort)0 : (ushort)(bValue % value)' true);                      break;                  case Intermediate.Instructions.MDI: //MDI b' a | like MOD' but treat b' a as signed. (MDI -7' 16 == -7)                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      AssignToOperand(operandB' value == 0 ? (ushort)0 : (ushort)((short)bValue % (short)value)' true);                      break;                  case Intermediate.Instructions.AND: //AND b' a | sets b to b&a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) & value)' true);                      break;                  case Intermediate.Instructions.BOR: //BOR b' a | sets b to b|a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) | value)' true);                      break;                  case Intermediate.Instructions.XOR: //XOR b' a | sets b to b^a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) ^ value));                      break;                  case Intermediate.Instructions.SHR: //SHR b' a | sets b to b>>>a' sets EX to ((b<<16)>>a)&0xffff (logical shift)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)(intermediate >> value)' true);                      AssignToEx((ushort)(intermediate << 16 >> value));                      break;                  case Intermediate.Instructions.ASR: //ASR b' a | sets b to b>>a' sets EX to ((b<<16)>>>a)&0xffff (arithmetic shift) (treats b as signed)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)((int)intermediate >> value)' true);                      AssignToEx((ushort)((int)intermediate << 16 >> value));                      break;                  case Intermediate.Instructions.SHL: //SHL b' a | sets b to b<<a' sets EX to ((b<<a)>>16)&0xffff                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)(intermediate << value)' true);                      AssignToEx((ushort)(intermediate << value >> 16));                      break;                  case Intermediate.Instructions.IFB: //IFB b' a | performs next instruction only if (b&a)!=0                      SkipIf = (GetOperandValue(operandB' OperandPlace.B) & value) != 0;                      break;                  case Intermediate.Instructions.IFC: //IFC b' a | performs next instruction only if (b&a)==0                      SkipIf = (GetOperandValue(operandB' OperandPlace.B) & value) == 0;                      break;                  case Intermediate.Instructions.IFE: //IFE b' a | performs next instruction only if b==a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) == value;                      break;                  case Intermediate.Instructions.IFN: //IFB b' a | performs next instruction only if b!=a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) != value;                      break;                  case Intermediate.Instructions.IFG: //IFG b' a | performs next instruction only if b>a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) > value;                      break;                  case Intermediate.Instructions.IFA: //IFA b' a | performs next instruction only if b>a (signed)                      SkipIf = (int)GetOperandValue(operandB' OperandPlace.B) > (int)value;                      break;                  case Intermediate.Instructions.IFL: //IFL b' a | performs next instruction only if b<a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) < value;                      break;                  case Intermediate.Instructions.IFU: //IFU b' a | performs next instruction only if b<a (signed)                      SkipIf = (int)GetOperandValue(operandB' OperandPlace.B) < (int)value;                      break;                  case Intermediate.Instructions.ADX: //ADX b' a | sets b to b+a+EX' sets EX to 0x0001 if there is an over-flow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) + value + registers[(int)Registers.EX];                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.SBX: //SBX b' a | sets b to b-a+EX' sets EX to 0xFFFF if there is an under-flow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) - value + registers[(int)Registers.EX];                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.STI: //STI b' a | sets b to a' then increases I and J by 1                      AssignToOperand(operandB' value' false);                      registers[(int)Registers.I] += 1;                      registers[(int)Registers.J] += 1;                      break;                  case Intermediate.Instructions.STD: //STI b' a | sets b to a' then decreases I and J by 1                      AssignToOperand(operandB' value' false);                      registers[(int)Registers.I] -= 1;                      registers[(int)Registers.J] -= 1;                      break;                    case Intermediate.Instructions.JSR: //pushes the address of the next instruction to the stack' then sets PC to a                      ram[(ushort)(registers[(int)Registers.SP] - 1)] = registers[(int)Registers.PC];                      registers[(int)Registers.SP] -= 1;                      registers[(int)Registers.PC] = value;                      break;                  case Intermediate.Instructions.HLT:                      throw new Halt();                    case Intermediate.Instructions.INT: //INT a | triggers a software interrupt with message a                      TriggerInterrupt(value);                      break;                  case Intermediate.Instructions.IAG: //IAG a | sets a to IA                       AssignToOperand(operandA' registers[(int)Registers.IA]' true);                      break;                  case Intermediate.Instructions.IAS: //IAS a | sets IA to A                       registers[(int)Registers.IA] = value;                      break;                  case Intermediate.Instructions.RFI: //RFI a | disables interrupt queueing' pops A from the stack' then pops PC from the stack                      protectInterruptQueue.WaitOne();                      interruptQueueEnabled = false;                      registers[(int)Registers.A] = ram[(ushort)(registers[(int)Registers.SP])];                      registers[(int)Registers.PC] = ram[(ushort)(registers[(int)Registers.SP] + 1)];                      registers[(int)Registers.SP] += 2;                      break;                  case Intermediate.Instructions.IAQ: //IAQ a | if a is nonzero' interrupts will be added to the queue                      interruptQueueEnabled = value != 0; //instead of triggered. if a is zero' interrupts will be                      break;                              //triggered as normal again                    case Intermediate.Instructions.HWN: //HWN a | sets a to number of connected hardware devices                      AssignToOperand(operandA' (ushort)devices.Count' true);                      break;                  case Intermediate.Instructions.HWQ: //HWQ a | sets A' B' C' X' Y registers to information about hardware a                       registers[(int)Registers.A] = (ushort)(devices[value].HardwareID & 0xFFFF); //A+(B<<16) is a 32 bit word identifying the hardware id                      registers[(int)Registers.B] = (ushort)((devices[value].HardwareID >> 16) & 0xFFFF);                      registers[(int)Registers.C] = devices[value].Version; //C is the hardware version                      registers[(int)Registers.X] = (ushort)(devices[value].ManufacturerID & 0xFFFF); //X+(Y<<16) is a 32 bit word identifying the manufacturer                      registers[(int)Registers.Y] = (ushort)((devices[value].ManufacturerID >> 16) & 0xFFFF);                      break;                  case Intermediate.Instructions.HWI: //HWI a | sends an interrupt to hardware a                      devices[value].OnInterrupt(this);                      break;              }
Magic Number,DCPUB.Testing,Emulator,C:\repos\Blecki_DCPUB\DCPUB\Testing\Emulator.cs,Step,The following statement contains a magic number: switch (ins)              {                  case Intermediate.Instructions.SET: //0x01 | SET b' a | sets b to a                      AssignToOperand(operandB' value' false);                      break;                  case Intermediate.Instructions.ADD: //ADD b' a | sets b to b+a' sets EX to 0x0001 if there's an overflow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) + value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.SUB: //SUB b' a | sets b to b-a' sets EX to 0xffff if there's an underflow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) - value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MUL: //MUL b' a | sets b to b*a' sets EX to ((b*a)>>16)&0xffff (treats b' a as unsigned)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) * value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MLI: //MLI b' a | like MUL' but treat b' a as signed                      intermediate = (UInt32)((short)GetOperandValue(operandB' OperandPlace.B) * (short)value);                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.DIV: //DIV b' a | sets b to b/a' sets EX to ((b<<16)/a)&0xffff. if a==0' sets b and EX to 0 instead. (treats b' a as unsigned)                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      intermediate = value == 0 ? 0 : (UInt32)bValue / value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.DVI: //DVI b' a | like DIV' but treat b' a as signed. Rounds towards 0                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      intermediate = value == 0 ? 0 : (UInt32)((short)bValue / (short)value);                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MOD: //MOD b' a | sets b to b%a. if a==0' sets b to 0 instead.                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      AssignToOperand(operandB' value == 0 ? (ushort)0 : (ushort)(bValue % value)' true);                      break;                  case Intermediate.Instructions.MDI: //MDI b' a | like MOD' but treat b' a as signed. (MDI -7' 16 == -7)                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      AssignToOperand(operandB' value == 0 ? (ushort)0 : (ushort)((short)bValue % (short)value)' true);                      break;                  case Intermediate.Instructions.AND: //AND b' a | sets b to b&a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) & value)' true);                      break;                  case Intermediate.Instructions.BOR: //BOR b' a | sets b to b|a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) | value)' true);                      break;                  case Intermediate.Instructions.XOR: //XOR b' a | sets b to b^a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) ^ value));                      break;                  case Intermediate.Instructions.SHR: //SHR b' a | sets b to b>>>a' sets EX to ((b<<16)>>a)&0xffff (logical shift)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)(intermediate >> value)' true);                      AssignToEx((ushort)(intermediate << 16 >> value));                      break;                  case Intermediate.Instructions.ASR: //ASR b' a | sets b to b>>a' sets EX to ((b<<16)>>>a)&0xffff (arithmetic shift) (treats b as signed)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)((int)intermediate >> value)' true);                      AssignToEx((ushort)((int)intermediate << 16 >> value));                      break;                  case Intermediate.Instructions.SHL: //SHL b' a | sets b to b<<a' sets EX to ((b<<a)>>16)&0xffff                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)(intermediate << value)' true);                      AssignToEx((ushort)(intermediate << value >> 16));                      break;                  case Intermediate.Instructions.IFB: //IFB b' a | performs next instruction only if (b&a)!=0                      SkipIf = (GetOperandValue(operandB' OperandPlace.B) & value) != 0;                      break;                  case Intermediate.Instructions.IFC: //IFC b' a | performs next instruction only if (b&a)==0                      SkipIf = (GetOperandValue(operandB' OperandPlace.B) & value) == 0;                      break;                  case Intermediate.Instructions.IFE: //IFE b' a | performs next instruction only if b==a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) == value;                      break;                  case Intermediate.Instructions.IFN: //IFB b' a | performs next instruction only if b!=a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) != value;                      break;                  case Intermediate.Instructions.IFG: //IFG b' a | performs next instruction only if b>a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) > value;                      break;                  case Intermediate.Instructions.IFA: //IFA b' a | performs next instruction only if b>a (signed)                      SkipIf = (int)GetOperandValue(operandB' OperandPlace.B) > (int)value;                      break;                  case Intermediate.Instructions.IFL: //IFL b' a | performs next instruction only if b<a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) < value;                      break;                  case Intermediate.Instructions.IFU: //IFU b' a | performs next instruction only if b<a (signed)                      SkipIf = (int)GetOperandValue(operandB' OperandPlace.B) < (int)value;                      break;                  case Intermediate.Instructions.ADX: //ADX b' a | sets b to b+a+EX' sets EX to 0x0001 if there is an over-flow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) + value + registers[(int)Registers.EX];                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.SBX: //SBX b' a | sets b to b-a+EX' sets EX to 0xFFFF if there is an under-flow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) - value + registers[(int)Registers.EX];                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.STI: //STI b' a | sets b to a' then increases I and J by 1                      AssignToOperand(operandB' value' false);                      registers[(int)Registers.I] += 1;                      registers[(int)Registers.J] += 1;                      break;                  case Intermediate.Instructions.STD: //STI b' a | sets b to a' then decreases I and J by 1                      AssignToOperand(operandB' value' false);                      registers[(int)Registers.I] -= 1;                      registers[(int)Registers.J] -= 1;                      break;                    case Intermediate.Instructions.JSR: //pushes the address of the next instruction to the stack' then sets PC to a                      ram[(ushort)(registers[(int)Registers.SP] - 1)] = registers[(int)Registers.PC];                      registers[(int)Registers.SP] -= 1;                      registers[(int)Registers.PC] = value;                      break;                  case Intermediate.Instructions.HLT:                      throw new Halt();                    case Intermediate.Instructions.INT: //INT a | triggers a software interrupt with message a                      TriggerInterrupt(value);                      break;                  case Intermediate.Instructions.IAG: //IAG a | sets a to IA                       AssignToOperand(operandA' registers[(int)Registers.IA]' true);                      break;                  case Intermediate.Instructions.IAS: //IAS a | sets IA to A                       registers[(int)Registers.IA] = value;                      break;                  case Intermediate.Instructions.RFI: //RFI a | disables interrupt queueing' pops A from the stack' then pops PC from the stack                      protectInterruptQueue.WaitOne();                      interruptQueueEnabled = false;                      registers[(int)Registers.A] = ram[(ushort)(registers[(int)Registers.SP])];                      registers[(int)Registers.PC] = ram[(ushort)(registers[(int)Registers.SP] + 1)];                      registers[(int)Registers.SP] += 2;                      break;                  case Intermediate.Instructions.IAQ: //IAQ a | if a is nonzero' interrupts will be added to the queue                      interruptQueueEnabled = value != 0; //instead of triggered. if a is zero' interrupts will be                      break;                              //triggered as normal again                    case Intermediate.Instructions.HWN: //HWN a | sets a to number of connected hardware devices                      AssignToOperand(operandA' (ushort)devices.Count' true);                      break;                  case Intermediate.Instructions.HWQ: //HWQ a | sets A' B' C' X' Y registers to information about hardware a                       registers[(int)Registers.A] = (ushort)(devices[value].HardwareID & 0xFFFF); //A+(B<<16) is a 32 bit word identifying the hardware id                      registers[(int)Registers.B] = (ushort)((devices[value].HardwareID >> 16) & 0xFFFF);                      registers[(int)Registers.C] = devices[value].Version; //C is the hardware version                      registers[(int)Registers.X] = (ushort)(devices[value].ManufacturerID & 0xFFFF); //X+(Y<<16) is a 32 bit word identifying the manufacturer                      registers[(int)Registers.Y] = (ushort)((devices[value].ManufacturerID >> 16) & 0xFFFF);                      break;                  case Intermediate.Instructions.HWI: //HWI a | sends an interrupt to hardware a                      devices[value].OnInterrupt(this);                      break;              }
Magic Number,DCPUB.Testing,Emulator,C:\repos\Blecki_DCPUB\DCPUB\Testing\Emulator.cs,Step,The following statement contains a magic number: switch (ins)              {                  case Intermediate.Instructions.SET: //0x01 | SET b' a | sets b to a                      AssignToOperand(operandB' value' false);                      break;                  case Intermediate.Instructions.ADD: //ADD b' a | sets b to b+a' sets EX to 0x0001 if there's an overflow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) + value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.SUB: //SUB b' a | sets b to b-a' sets EX to 0xffff if there's an underflow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) - value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MUL: //MUL b' a | sets b to b*a' sets EX to ((b*a)>>16)&0xffff (treats b' a as unsigned)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) * value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MLI: //MLI b' a | like MUL' but treat b' a as signed                      intermediate = (UInt32)((short)GetOperandValue(operandB' OperandPlace.B) * (short)value);                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.DIV: //DIV b' a | sets b to b/a' sets EX to ((b<<16)/a)&0xffff. if a==0' sets b and EX to 0 instead. (treats b' a as unsigned)                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      intermediate = value == 0 ? 0 : (UInt32)bValue / value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.DVI: //DVI b' a | like DIV' but treat b' a as signed. Rounds towards 0                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      intermediate = value == 0 ? 0 : (UInt32)((short)bValue / (short)value);                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MOD: //MOD b' a | sets b to b%a. if a==0' sets b to 0 instead.                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      AssignToOperand(operandB' value == 0 ? (ushort)0 : (ushort)(bValue % value)' true);                      break;                  case Intermediate.Instructions.MDI: //MDI b' a | like MOD' but treat b' a as signed. (MDI -7' 16 == -7)                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      AssignToOperand(operandB' value == 0 ? (ushort)0 : (ushort)((short)bValue % (short)value)' true);                      break;                  case Intermediate.Instructions.AND: //AND b' a | sets b to b&a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) & value)' true);                      break;                  case Intermediate.Instructions.BOR: //BOR b' a | sets b to b|a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) | value)' true);                      break;                  case Intermediate.Instructions.XOR: //XOR b' a | sets b to b^a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) ^ value));                      break;                  case Intermediate.Instructions.SHR: //SHR b' a | sets b to b>>>a' sets EX to ((b<<16)>>a)&0xffff (logical shift)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)(intermediate >> value)' true);                      AssignToEx((ushort)(intermediate << 16 >> value));                      break;                  case Intermediate.Instructions.ASR: //ASR b' a | sets b to b>>a' sets EX to ((b<<16)>>>a)&0xffff (arithmetic shift) (treats b as signed)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)((int)intermediate >> value)' true);                      AssignToEx((ushort)((int)intermediate << 16 >> value));                      break;                  case Intermediate.Instructions.SHL: //SHL b' a | sets b to b<<a' sets EX to ((b<<a)>>16)&0xffff                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)(intermediate << value)' true);                      AssignToEx((ushort)(intermediate << value >> 16));                      break;                  case Intermediate.Instructions.IFB: //IFB b' a | performs next instruction only if (b&a)!=0                      SkipIf = (GetOperandValue(operandB' OperandPlace.B) & value) != 0;                      break;                  case Intermediate.Instructions.IFC: //IFC b' a | performs next instruction only if (b&a)==0                      SkipIf = (GetOperandValue(operandB' OperandPlace.B) & value) == 0;                      break;                  case Intermediate.Instructions.IFE: //IFE b' a | performs next instruction only if b==a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) == value;                      break;                  case Intermediate.Instructions.IFN: //IFB b' a | performs next instruction only if b!=a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) != value;                      break;                  case Intermediate.Instructions.IFG: //IFG b' a | performs next instruction only if b>a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) > value;                      break;                  case Intermediate.Instructions.IFA: //IFA b' a | performs next instruction only if b>a (signed)                      SkipIf = (int)GetOperandValue(operandB' OperandPlace.B) > (int)value;                      break;                  case Intermediate.Instructions.IFL: //IFL b' a | performs next instruction only if b<a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) < value;                      break;                  case Intermediate.Instructions.IFU: //IFU b' a | performs next instruction only if b<a (signed)                      SkipIf = (int)GetOperandValue(operandB' OperandPlace.B) < (int)value;                      break;                  case Intermediate.Instructions.ADX: //ADX b' a | sets b to b+a+EX' sets EX to 0x0001 if there is an over-flow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) + value + registers[(int)Registers.EX];                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.SBX: //SBX b' a | sets b to b-a+EX' sets EX to 0xFFFF if there is an under-flow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) - value + registers[(int)Registers.EX];                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.STI: //STI b' a | sets b to a' then increases I and J by 1                      AssignToOperand(operandB' value' false);                      registers[(int)Registers.I] += 1;                      registers[(int)Registers.J] += 1;                      break;                  case Intermediate.Instructions.STD: //STI b' a | sets b to a' then decreases I and J by 1                      AssignToOperand(operandB' value' false);                      registers[(int)Registers.I] -= 1;                      registers[(int)Registers.J] -= 1;                      break;                    case Intermediate.Instructions.JSR: //pushes the address of the next instruction to the stack' then sets PC to a                      ram[(ushort)(registers[(int)Registers.SP] - 1)] = registers[(int)Registers.PC];                      registers[(int)Registers.SP] -= 1;                      registers[(int)Registers.PC] = value;                      break;                  case Intermediate.Instructions.HLT:                      throw new Halt();                    case Intermediate.Instructions.INT: //INT a | triggers a software interrupt with message a                      TriggerInterrupt(value);                      break;                  case Intermediate.Instructions.IAG: //IAG a | sets a to IA                       AssignToOperand(operandA' registers[(int)Registers.IA]' true);                      break;                  case Intermediate.Instructions.IAS: //IAS a | sets IA to A                       registers[(int)Registers.IA] = value;                      break;                  case Intermediate.Instructions.RFI: //RFI a | disables interrupt queueing' pops A from the stack' then pops PC from the stack                      protectInterruptQueue.WaitOne();                      interruptQueueEnabled = false;                      registers[(int)Registers.A] = ram[(ushort)(registers[(int)Registers.SP])];                      registers[(int)Registers.PC] = ram[(ushort)(registers[(int)Registers.SP] + 1)];                      registers[(int)Registers.SP] += 2;                      break;                  case Intermediate.Instructions.IAQ: //IAQ a | if a is nonzero' interrupts will be added to the queue                      interruptQueueEnabled = value != 0; //instead of triggered. if a is zero' interrupts will be                      break;                              //triggered as normal again                    case Intermediate.Instructions.HWN: //HWN a | sets a to number of connected hardware devices                      AssignToOperand(operandA' (ushort)devices.Count' true);                      break;                  case Intermediate.Instructions.HWQ: //HWQ a | sets A' B' C' X' Y registers to information about hardware a                       registers[(int)Registers.A] = (ushort)(devices[value].HardwareID & 0xFFFF); //A+(B<<16) is a 32 bit word identifying the hardware id                      registers[(int)Registers.B] = (ushort)((devices[value].HardwareID >> 16) & 0xFFFF);                      registers[(int)Registers.C] = devices[value].Version; //C is the hardware version                      registers[(int)Registers.X] = (ushort)(devices[value].ManufacturerID & 0xFFFF); //X+(Y<<16) is a 32 bit word identifying the manufacturer                      registers[(int)Registers.Y] = (ushort)((devices[value].ManufacturerID >> 16) & 0xFFFF);                      break;                  case Intermediate.Instructions.HWI: //HWI a | sends an interrupt to hardware a                      devices[value].OnInterrupt(this);                      break;              }
Magic Number,DCPUB.Testing,Emulator,C:\repos\Blecki_DCPUB\DCPUB\Testing\Emulator.cs,Step,The following statement contains a magic number: switch (ins)              {                  case Intermediate.Instructions.SET: //0x01 | SET b' a | sets b to a                      AssignToOperand(operandB' value' false);                      break;                  case Intermediate.Instructions.ADD: //ADD b' a | sets b to b+a' sets EX to 0x0001 if there's an overflow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) + value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.SUB: //SUB b' a | sets b to b-a' sets EX to 0xffff if there's an underflow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) - value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MUL: //MUL b' a | sets b to b*a' sets EX to ((b*a)>>16)&0xffff (treats b' a as unsigned)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) * value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MLI: //MLI b' a | like MUL' but treat b' a as signed                      intermediate = (UInt32)((short)GetOperandValue(operandB' OperandPlace.B) * (short)value);                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.DIV: //DIV b' a | sets b to b/a' sets EX to ((b<<16)/a)&0xffff. if a==0' sets b and EX to 0 instead. (treats b' a as unsigned)                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      intermediate = value == 0 ? 0 : (UInt32)bValue / value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.DVI: //DVI b' a | like DIV' but treat b' a as signed. Rounds towards 0                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      intermediate = value == 0 ? 0 : (UInt32)((short)bValue / (short)value);                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MOD: //MOD b' a | sets b to b%a. if a==0' sets b to 0 instead.                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      AssignToOperand(operandB' value == 0 ? (ushort)0 : (ushort)(bValue % value)' true);                      break;                  case Intermediate.Instructions.MDI: //MDI b' a | like MOD' but treat b' a as signed. (MDI -7' 16 == -7)                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      AssignToOperand(operandB' value == 0 ? (ushort)0 : (ushort)((short)bValue % (short)value)' true);                      break;                  case Intermediate.Instructions.AND: //AND b' a | sets b to b&a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) & value)' true);                      break;                  case Intermediate.Instructions.BOR: //BOR b' a | sets b to b|a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) | value)' true);                      break;                  case Intermediate.Instructions.XOR: //XOR b' a | sets b to b^a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) ^ value));                      break;                  case Intermediate.Instructions.SHR: //SHR b' a | sets b to b>>>a' sets EX to ((b<<16)>>a)&0xffff (logical shift)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)(intermediate >> value)' true);                      AssignToEx((ushort)(intermediate << 16 >> value));                      break;                  case Intermediate.Instructions.ASR: //ASR b' a | sets b to b>>a' sets EX to ((b<<16)>>>a)&0xffff (arithmetic shift) (treats b as signed)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)((int)intermediate >> value)' true);                      AssignToEx((ushort)((int)intermediate << 16 >> value));                      break;                  case Intermediate.Instructions.SHL: //SHL b' a | sets b to b<<a' sets EX to ((b<<a)>>16)&0xffff                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)(intermediate << value)' true);                      AssignToEx((ushort)(intermediate << value >> 16));                      break;                  case Intermediate.Instructions.IFB: //IFB b' a | performs next instruction only if (b&a)!=0                      SkipIf = (GetOperandValue(operandB' OperandPlace.B) & value) != 0;                      break;                  case Intermediate.Instructions.IFC: //IFC b' a | performs next instruction only if (b&a)==0                      SkipIf = (GetOperandValue(operandB' OperandPlace.B) & value) == 0;                      break;                  case Intermediate.Instructions.IFE: //IFE b' a | performs next instruction only if b==a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) == value;                      break;                  case Intermediate.Instructions.IFN: //IFB b' a | performs next instruction only if b!=a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) != value;                      break;                  case Intermediate.Instructions.IFG: //IFG b' a | performs next instruction only if b>a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) > value;                      break;                  case Intermediate.Instructions.IFA: //IFA b' a | performs next instruction only if b>a (signed)                      SkipIf = (int)GetOperandValue(operandB' OperandPlace.B) > (int)value;                      break;                  case Intermediate.Instructions.IFL: //IFL b' a | performs next instruction only if b<a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) < value;                      break;                  case Intermediate.Instructions.IFU: //IFU b' a | performs next instruction only if b<a (signed)                      SkipIf = (int)GetOperandValue(operandB' OperandPlace.B) < (int)value;                      break;                  case Intermediate.Instructions.ADX: //ADX b' a | sets b to b+a+EX' sets EX to 0x0001 if there is an over-flow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) + value + registers[(int)Registers.EX];                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.SBX: //SBX b' a | sets b to b-a+EX' sets EX to 0xFFFF if there is an under-flow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) - value + registers[(int)Registers.EX];                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.STI: //STI b' a | sets b to a' then increases I and J by 1                      AssignToOperand(operandB' value' false);                      registers[(int)Registers.I] += 1;                      registers[(int)Registers.J] += 1;                      break;                  case Intermediate.Instructions.STD: //STI b' a | sets b to a' then decreases I and J by 1                      AssignToOperand(operandB' value' false);                      registers[(int)Registers.I] -= 1;                      registers[(int)Registers.J] -= 1;                      break;                    case Intermediate.Instructions.JSR: //pushes the address of the next instruction to the stack' then sets PC to a                      ram[(ushort)(registers[(int)Registers.SP] - 1)] = registers[(int)Registers.PC];                      registers[(int)Registers.SP] -= 1;                      registers[(int)Registers.PC] = value;                      break;                  case Intermediate.Instructions.HLT:                      throw new Halt();                    case Intermediate.Instructions.INT: //INT a | triggers a software interrupt with message a                      TriggerInterrupt(value);                      break;                  case Intermediate.Instructions.IAG: //IAG a | sets a to IA                       AssignToOperand(operandA' registers[(int)Registers.IA]' true);                      break;                  case Intermediate.Instructions.IAS: //IAS a | sets IA to A                       registers[(int)Registers.IA] = value;                      break;                  case Intermediate.Instructions.RFI: //RFI a | disables interrupt queueing' pops A from the stack' then pops PC from the stack                      protectInterruptQueue.WaitOne();                      interruptQueueEnabled = false;                      registers[(int)Registers.A] = ram[(ushort)(registers[(int)Registers.SP])];                      registers[(int)Registers.PC] = ram[(ushort)(registers[(int)Registers.SP] + 1)];                      registers[(int)Registers.SP] += 2;                      break;                  case Intermediate.Instructions.IAQ: //IAQ a | if a is nonzero' interrupts will be added to the queue                      interruptQueueEnabled = value != 0; //instead of triggered. if a is zero' interrupts will be                      break;                              //triggered as normal again                    case Intermediate.Instructions.HWN: //HWN a | sets a to number of connected hardware devices                      AssignToOperand(operandA' (ushort)devices.Count' true);                      break;                  case Intermediate.Instructions.HWQ: //HWQ a | sets A' B' C' X' Y registers to information about hardware a                       registers[(int)Registers.A] = (ushort)(devices[value].HardwareID & 0xFFFF); //A+(B<<16) is a 32 bit word identifying the hardware id                      registers[(int)Registers.B] = (ushort)((devices[value].HardwareID >> 16) & 0xFFFF);                      registers[(int)Registers.C] = devices[value].Version; //C is the hardware version                      registers[(int)Registers.X] = (ushort)(devices[value].ManufacturerID & 0xFFFF); //X+(Y<<16) is a 32 bit word identifying the manufacturer                      registers[(int)Registers.Y] = (ushort)((devices[value].ManufacturerID >> 16) & 0xFFFF);                      break;                  case Intermediate.Instructions.HWI: //HWI a | sends an interrupt to hardware a                      devices[value].OnInterrupt(this);                      break;              }
Magic Number,DCPUB.Testing,Emulator,C:\repos\Blecki_DCPUB\DCPUB\Testing\Emulator.cs,Step,The following statement contains a magic number: switch (ins)              {                  case Intermediate.Instructions.SET: //0x01 | SET b' a | sets b to a                      AssignToOperand(operandB' value' false);                      break;                  case Intermediate.Instructions.ADD: //ADD b' a | sets b to b+a' sets EX to 0x0001 if there's an overflow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) + value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.SUB: //SUB b' a | sets b to b-a' sets EX to 0xffff if there's an underflow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) - value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MUL: //MUL b' a | sets b to b*a' sets EX to ((b*a)>>16)&0xffff (treats b' a as unsigned)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) * value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MLI: //MLI b' a | like MUL' but treat b' a as signed                      intermediate = (UInt32)((short)GetOperandValue(operandB' OperandPlace.B) * (short)value);                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.DIV: //DIV b' a | sets b to b/a' sets EX to ((b<<16)/a)&0xffff. if a==0' sets b and EX to 0 instead. (treats b' a as unsigned)                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      intermediate = value == 0 ? 0 : (UInt32)bValue / value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.DVI: //DVI b' a | like DIV' but treat b' a as signed. Rounds towards 0                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      intermediate = value == 0 ? 0 : (UInt32)((short)bValue / (short)value);                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MOD: //MOD b' a | sets b to b%a. if a==0' sets b to 0 instead.                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      AssignToOperand(operandB' value == 0 ? (ushort)0 : (ushort)(bValue % value)' true);                      break;                  case Intermediate.Instructions.MDI: //MDI b' a | like MOD' but treat b' a as signed. (MDI -7' 16 == -7)                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      AssignToOperand(operandB' value == 0 ? (ushort)0 : (ushort)((short)bValue % (short)value)' true);                      break;                  case Intermediate.Instructions.AND: //AND b' a | sets b to b&a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) & value)' true);                      break;                  case Intermediate.Instructions.BOR: //BOR b' a | sets b to b|a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) | value)' true);                      break;                  case Intermediate.Instructions.XOR: //XOR b' a | sets b to b^a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) ^ value));                      break;                  case Intermediate.Instructions.SHR: //SHR b' a | sets b to b>>>a' sets EX to ((b<<16)>>a)&0xffff (logical shift)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)(intermediate >> value)' true);                      AssignToEx((ushort)(intermediate << 16 >> value));                      break;                  case Intermediate.Instructions.ASR: //ASR b' a | sets b to b>>a' sets EX to ((b<<16)>>>a)&0xffff (arithmetic shift) (treats b as signed)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)((int)intermediate >> value)' true);                      AssignToEx((ushort)((int)intermediate << 16 >> value));                      break;                  case Intermediate.Instructions.SHL: //SHL b' a | sets b to b<<a' sets EX to ((b<<a)>>16)&0xffff                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)(intermediate << value)' true);                      AssignToEx((ushort)(intermediate << value >> 16));                      break;                  case Intermediate.Instructions.IFB: //IFB b' a | performs next instruction only if (b&a)!=0                      SkipIf = (GetOperandValue(operandB' OperandPlace.B) & value) != 0;                      break;                  case Intermediate.Instructions.IFC: //IFC b' a | performs next instruction only if (b&a)==0                      SkipIf = (GetOperandValue(operandB' OperandPlace.B) & value) == 0;                      break;                  case Intermediate.Instructions.IFE: //IFE b' a | performs next instruction only if b==a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) == value;                      break;                  case Intermediate.Instructions.IFN: //IFB b' a | performs next instruction only if b!=a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) != value;                      break;                  case Intermediate.Instructions.IFG: //IFG b' a | performs next instruction only if b>a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) > value;                      break;                  case Intermediate.Instructions.IFA: //IFA b' a | performs next instruction only if b>a (signed)                      SkipIf = (int)GetOperandValue(operandB' OperandPlace.B) > (int)value;                      break;                  case Intermediate.Instructions.IFL: //IFL b' a | performs next instruction only if b<a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) < value;                      break;                  case Intermediate.Instructions.IFU: //IFU b' a | performs next instruction only if b<a (signed)                      SkipIf = (int)GetOperandValue(operandB' OperandPlace.B) < (int)value;                      break;                  case Intermediate.Instructions.ADX: //ADX b' a | sets b to b+a+EX' sets EX to 0x0001 if there is an over-flow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) + value + registers[(int)Registers.EX];                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.SBX: //SBX b' a | sets b to b-a+EX' sets EX to 0xFFFF if there is an under-flow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) - value + registers[(int)Registers.EX];                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.STI: //STI b' a | sets b to a' then increases I and J by 1                      AssignToOperand(operandB' value' false);                      registers[(int)Registers.I] += 1;                      registers[(int)Registers.J] += 1;                      break;                  case Intermediate.Instructions.STD: //STI b' a | sets b to a' then decreases I and J by 1                      AssignToOperand(operandB' value' false);                      registers[(int)Registers.I] -= 1;                      registers[(int)Registers.J] -= 1;                      break;                    case Intermediate.Instructions.JSR: //pushes the address of the next instruction to the stack' then sets PC to a                      ram[(ushort)(registers[(int)Registers.SP] - 1)] = registers[(int)Registers.PC];                      registers[(int)Registers.SP] -= 1;                      registers[(int)Registers.PC] = value;                      break;                  case Intermediate.Instructions.HLT:                      throw new Halt();                    case Intermediate.Instructions.INT: //INT a | triggers a software interrupt with message a                      TriggerInterrupt(value);                      break;                  case Intermediate.Instructions.IAG: //IAG a | sets a to IA                       AssignToOperand(operandA' registers[(int)Registers.IA]' true);                      break;                  case Intermediate.Instructions.IAS: //IAS a | sets IA to A                       registers[(int)Registers.IA] = value;                      break;                  case Intermediate.Instructions.RFI: //RFI a | disables interrupt queueing' pops A from the stack' then pops PC from the stack                      protectInterruptQueue.WaitOne();                      interruptQueueEnabled = false;                      registers[(int)Registers.A] = ram[(ushort)(registers[(int)Registers.SP])];                      registers[(int)Registers.PC] = ram[(ushort)(registers[(int)Registers.SP] + 1)];                      registers[(int)Registers.SP] += 2;                      break;                  case Intermediate.Instructions.IAQ: //IAQ a | if a is nonzero' interrupts will be added to the queue                      interruptQueueEnabled = value != 0; //instead of triggered. if a is zero' interrupts will be                      break;                              //triggered as normal again                    case Intermediate.Instructions.HWN: //HWN a | sets a to number of connected hardware devices                      AssignToOperand(operandA' (ushort)devices.Count' true);                      break;                  case Intermediate.Instructions.HWQ: //HWQ a | sets A' B' C' X' Y registers to information about hardware a                       registers[(int)Registers.A] = (ushort)(devices[value].HardwareID & 0xFFFF); //A+(B<<16) is a 32 bit word identifying the hardware id                      registers[(int)Registers.B] = (ushort)((devices[value].HardwareID >> 16) & 0xFFFF);                      registers[(int)Registers.C] = devices[value].Version; //C is the hardware version                      registers[(int)Registers.X] = (ushort)(devices[value].ManufacturerID & 0xFFFF); //X+(Y<<16) is a 32 bit word identifying the manufacturer                      registers[(int)Registers.Y] = (ushort)((devices[value].ManufacturerID >> 16) & 0xFFFF);                      break;                  case Intermediate.Instructions.HWI: //HWI a | sends an interrupt to hardware a                      devices[value].OnInterrupt(this);                      break;              }
Magic Number,DCPUB.Testing,Emulator,C:\repos\Blecki_DCPUB\DCPUB\Testing\Emulator.cs,Step,The following statement contains a magic number: switch (ins)              {                  case Intermediate.Instructions.SET: //0x01 | SET b' a | sets b to a                      AssignToOperand(operandB' value' false);                      break;                  case Intermediate.Instructions.ADD: //ADD b' a | sets b to b+a' sets EX to 0x0001 if there's an overflow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) + value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.SUB: //SUB b' a | sets b to b-a' sets EX to 0xffff if there's an underflow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) - value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MUL: //MUL b' a | sets b to b*a' sets EX to ((b*a)>>16)&0xffff (treats b' a as unsigned)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) * value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MLI: //MLI b' a | like MUL' but treat b' a as signed                      intermediate = (UInt32)((short)GetOperandValue(operandB' OperandPlace.B) * (short)value);                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.DIV: //DIV b' a | sets b to b/a' sets EX to ((b<<16)/a)&0xffff. if a==0' sets b and EX to 0 instead. (treats b' a as unsigned)                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      intermediate = value == 0 ? 0 : (UInt32)bValue / value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.DVI: //DVI b' a | like DIV' but treat b' a as signed. Rounds towards 0                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      intermediate = value == 0 ? 0 : (UInt32)((short)bValue / (short)value);                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MOD: //MOD b' a | sets b to b%a. if a==0' sets b to 0 instead.                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      AssignToOperand(operandB' value == 0 ? (ushort)0 : (ushort)(bValue % value)' true);                      break;                  case Intermediate.Instructions.MDI: //MDI b' a | like MOD' but treat b' a as signed. (MDI -7' 16 == -7)                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      AssignToOperand(operandB' value == 0 ? (ushort)0 : (ushort)((short)bValue % (short)value)' true);                      break;                  case Intermediate.Instructions.AND: //AND b' a | sets b to b&a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) & value)' true);                      break;                  case Intermediate.Instructions.BOR: //BOR b' a | sets b to b|a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) | value)' true);                      break;                  case Intermediate.Instructions.XOR: //XOR b' a | sets b to b^a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) ^ value));                      break;                  case Intermediate.Instructions.SHR: //SHR b' a | sets b to b>>>a' sets EX to ((b<<16)>>a)&0xffff (logical shift)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)(intermediate >> value)' true);                      AssignToEx((ushort)(intermediate << 16 >> value));                      break;                  case Intermediate.Instructions.ASR: //ASR b' a | sets b to b>>a' sets EX to ((b<<16)>>>a)&0xffff (arithmetic shift) (treats b as signed)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)((int)intermediate >> value)' true);                      AssignToEx((ushort)((int)intermediate << 16 >> value));                      break;                  case Intermediate.Instructions.SHL: //SHL b' a | sets b to b<<a' sets EX to ((b<<a)>>16)&0xffff                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)(intermediate << value)' true);                      AssignToEx((ushort)(intermediate << value >> 16));                      break;                  case Intermediate.Instructions.IFB: //IFB b' a | performs next instruction only if (b&a)!=0                      SkipIf = (GetOperandValue(operandB' OperandPlace.B) & value) != 0;                      break;                  case Intermediate.Instructions.IFC: //IFC b' a | performs next instruction only if (b&a)==0                      SkipIf = (GetOperandValue(operandB' OperandPlace.B) & value) == 0;                      break;                  case Intermediate.Instructions.IFE: //IFE b' a | performs next instruction only if b==a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) == value;                      break;                  case Intermediate.Instructions.IFN: //IFB b' a | performs next instruction only if b!=a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) != value;                      break;                  case Intermediate.Instructions.IFG: //IFG b' a | performs next instruction only if b>a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) > value;                      break;                  case Intermediate.Instructions.IFA: //IFA b' a | performs next instruction only if b>a (signed)                      SkipIf = (int)GetOperandValue(operandB' OperandPlace.B) > (int)value;                      break;                  case Intermediate.Instructions.IFL: //IFL b' a | performs next instruction only if b<a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) < value;                      break;                  case Intermediate.Instructions.IFU: //IFU b' a | performs next instruction only if b<a (signed)                      SkipIf = (int)GetOperandValue(operandB' OperandPlace.B) < (int)value;                      break;                  case Intermediate.Instructions.ADX: //ADX b' a | sets b to b+a+EX' sets EX to 0x0001 if there is an over-flow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) + value + registers[(int)Registers.EX];                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.SBX: //SBX b' a | sets b to b-a+EX' sets EX to 0xFFFF if there is an under-flow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) - value + registers[(int)Registers.EX];                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.STI: //STI b' a | sets b to a' then increases I and J by 1                      AssignToOperand(operandB' value' false);                      registers[(int)Registers.I] += 1;                      registers[(int)Registers.J] += 1;                      break;                  case Intermediate.Instructions.STD: //STI b' a | sets b to a' then decreases I and J by 1                      AssignToOperand(operandB' value' false);                      registers[(int)Registers.I] -= 1;                      registers[(int)Registers.J] -= 1;                      break;                    case Intermediate.Instructions.JSR: //pushes the address of the next instruction to the stack' then sets PC to a                      ram[(ushort)(registers[(int)Registers.SP] - 1)] = registers[(int)Registers.PC];                      registers[(int)Registers.SP] -= 1;                      registers[(int)Registers.PC] = value;                      break;                  case Intermediate.Instructions.HLT:                      throw new Halt();                    case Intermediate.Instructions.INT: //INT a | triggers a software interrupt with message a                      TriggerInterrupt(value);                      break;                  case Intermediate.Instructions.IAG: //IAG a | sets a to IA                       AssignToOperand(operandA' registers[(int)Registers.IA]' true);                      break;                  case Intermediate.Instructions.IAS: //IAS a | sets IA to A                       registers[(int)Registers.IA] = value;                      break;                  case Intermediate.Instructions.RFI: //RFI a | disables interrupt queueing' pops A from the stack' then pops PC from the stack                      protectInterruptQueue.WaitOne();                      interruptQueueEnabled = false;                      registers[(int)Registers.A] = ram[(ushort)(registers[(int)Registers.SP])];                      registers[(int)Registers.PC] = ram[(ushort)(registers[(int)Registers.SP] + 1)];                      registers[(int)Registers.SP] += 2;                      break;                  case Intermediate.Instructions.IAQ: //IAQ a | if a is nonzero' interrupts will be added to the queue                      interruptQueueEnabled = value != 0; //instead of triggered. if a is zero' interrupts will be                      break;                              //triggered as normal again                    case Intermediate.Instructions.HWN: //HWN a | sets a to number of connected hardware devices                      AssignToOperand(operandA' (ushort)devices.Count' true);                      break;                  case Intermediate.Instructions.HWQ: //HWQ a | sets A' B' C' X' Y registers to information about hardware a                       registers[(int)Registers.A] = (ushort)(devices[value].HardwareID & 0xFFFF); //A+(B<<16) is a 32 bit word identifying the hardware id                      registers[(int)Registers.B] = (ushort)((devices[value].HardwareID >> 16) & 0xFFFF);                      registers[(int)Registers.C] = devices[value].Version; //C is the hardware version                      registers[(int)Registers.X] = (ushort)(devices[value].ManufacturerID & 0xFFFF); //X+(Y<<16) is a 32 bit word identifying the manufacturer                      registers[(int)Registers.Y] = (ushort)((devices[value].ManufacturerID >> 16) & 0xFFFF);                      break;                  case Intermediate.Instructions.HWI: //HWI a | sends an interrupt to hardware a                      devices[value].OnInterrupt(this);                      break;              }
Magic Number,DCPUB.Testing,Emulator,C:\repos\Blecki_DCPUB\DCPUB\Testing\Emulator.cs,Step,The following statement contains a magic number: switch (ins)              {                  case Intermediate.Instructions.SET: //0x01 | SET b' a | sets b to a                      AssignToOperand(operandB' value' false);                      break;                  case Intermediate.Instructions.ADD: //ADD b' a | sets b to b+a' sets EX to 0x0001 if there's an overflow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) + value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.SUB: //SUB b' a | sets b to b-a' sets EX to 0xffff if there's an underflow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) - value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MUL: //MUL b' a | sets b to b*a' sets EX to ((b*a)>>16)&0xffff (treats b' a as unsigned)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) * value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MLI: //MLI b' a | like MUL' but treat b' a as signed                      intermediate = (UInt32)((short)GetOperandValue(operandB' OperandPlace.B) * (short)value);                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.DIV: //DIV b' a | sets b to b/a' sets EX to ((b<<16)/a)&0xffff. if a==0' sets b and EX to 0 instead. (treats b' a as unsigned)                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      intermediate = value == 0 ? 0 : (UInt32)bValue / value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.DVI: //DVI b' a | like DIV' but treat b' a as signed. Rounds towards 0                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      intermediate = value == 0 ? 0 : (UInt32)((short)bValue / (short)value);                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MOD: //MOD b' a | sets b to b%a. if a==0' sets b to 0 instead.                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      AssignToOperand(operandB' value == 0 ? (ushort)0 : (ushort)(bValue % value)' true);                      break;                  case Intermediate.Instructions.MDI: //MDI b' a | like MOD' but treat b' a as signed. (MDI -7' 16 == -7)                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      AssignToOperand(operandB' value == 0 ? (ushort)0 : (ushort)((short)bValue % (short)value)' true);                      break;                  case Intermediate.Instructions.AND: //AND b' a | sets b to b&a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) & value)' true);                      break;                  case Intermediate.Instructions.BOR: //BOR b' a | sets b to b|a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) | value)' true);                      break;                  case Intermediate.Instructions.XOR: //XOR b' a | sets b to b^a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) ^ value));                      break;                  case Intermediate.Instructions.SHR: //SHR b' a | sets b to b>>>a' sets EX to ((b<<16)>>a)&0xffff (logical shift)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)(intermediate >> value)' true);                      AssignToEx((ushort)(intermediate << 16 >> value));                      break;                  case Intermediate.Instructions.ASR: //ASR b' a | sets b to b>>a' sets EX to ((b<<16)>>>a)&0xffff (arithmetic shift) (treats b as signed)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)((int)intermediate >> value)' true);                      AssignToEx((ushort)((int)intermediate << 16 >> value));                      break;                  case Intermediate.Instructions.SHL: //SHL b' a | sets b to b<<a' sets EX to ((b<<a)>>16)&0xffff                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)(intermediate << value)' true);                      AssignToEx((ushort)(intermediate << value >> 16));                      break;                  case Intermediate.Instructions.IFB: //IFB b' a | performs next instruction only if (b&a)!=0                      SkipIf = (GetOperandValue(operandB' OperandPlace.B) & value) != 0;                      break;                  case Intermediate.Instructions.IFC: //IFC b' a | performs next instruction only if (b&a)==0                      SkipIf = (GetOperandValue(operandB' OperandPlace.B) & value) == 0;                      break;                  case Intermediate.Instructions.IFE: //IFE b' a | performs next instruction only if b==a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) == value;                      break;                  case Intermediate.Instructions.IFN: //IFB b' a | performs next instruction only if b!=a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) != value;                      break;                  case Intermediate.Instructions.IFG: //IFG b' a | performs next instruction only if b>a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) > value;                      break;                  case Intermediate.Instructions.IFA: //IFA b' a | performs next instruction only if b>a (signed)                      SkipIf = (int)GetOperandValue(operandB' OperandPlace.B) > (int)value;                      break;                  case Intermediate.Instructions.IFL: //IFL b' a | performs next instruction only if b<a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) < value;                      break;                  case Intermediate.Instructions.IFU: //IFU b' a | performs next instruction only if b<a (signed)                      SkipIf = (int)GetOperandValue(operandB' OperandPlace.B) < (int)value;                      break;                  case Intermediate.Instructions.ADX: //ADX b' a | sets b to b+a+EX' sets EX to 0x0001 if there is an over-flow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) + value + registers[(int)Registers.EX];                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.SBX: //SBX b' a | sets b to b-a+EX' sets EX to 0xFFFF if there is an under-flow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) - value + registers[(int)Registers.EX];                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.STI: //STI b' a | sets b to a' then increases I and J by 1                      AssignToOperand(operandB' value' false);                      registers[(int)Registers.I] += 1;                      registers[(int)Registers.J] += 1;                      break;                  case Intermediate.Instructions.STD: //STI b' a | sets b to a' then decreases I and J by 1                      AssignToOperand(operandB' value' false);                      registers[(int)Registers.I] -= 1;                      registers[(int)Registers.J] -= 1;                      break;                    case Intermediate.Instructions.JSR: //pushes the address of the next instruction to the stack' then sets PC to a                      ram[(ushort)(registers[(int)Registers.SP] - 1)] = registers[(int)Registers.PC];                      registers[(int)Registers.SP] -= 1;                      registers[(int)Registers.PC] = value;                      break;                  case Intermediate.Instructions.HLT:                      throw new Halt();                    case Intermediate.Instructions.INT: //INT a | triggers a software interrupt with message a                      TriggerInterrupt(value);                      break;                  case Intermediate.Instructions.IAG: //IAG a | sets a to IA                       AssignToOperand(operandA' registers[(int)Registers.IA]' true);                      break;                  case Intermediate.Instructions.IAS: //IAS a | sets IA to A                       registers[(int)Registers.IA] = value;                      break;                  case Intermediate.Instructions.RFI: //RFI a | disables interrupt queueing' pops A from the stack' then pops PC from the stack                      protectInterruptQueue.WaitOne();                      interruptQueueEnabled = false;                      registers[(int)Registers.A] = ram[(ushort)(registers[(int)Registers.SP])];                      registers[(int)Registers.PC] = ram[(ushort)(registers[(int)Registers.SP] + 1)];                      registers[(int)Registers.SP] += 2;                      break;                  case Intermediate.Instructions.IAQ: //IAQ a | if a is nonzero' interrupts will be added to the queue                      interruptQueueEnabled = value != 0; //instead of triggered. if a is zero' interrupts will be                      break;                              //triggered as normal again                    case Intermediate.Instructions.HWN: //HWN a | sets a to number of connected hardware devices                      AssignToOperand(operandA' (ushort)devices.Count' true);                      break;                  case Intermediate.Instructions.HWQ: //HWQ a | sets A' B' C' X' Y registers to information about hardware a                       registers[(int)Registers.A] = (ushort)(devices[value].HardwareID & 0xFFFF); //A+(B<<16) is a 32 bit word identifying the hardware id                      registers[(int)Registers.B] = (ushort)((devices[value].HardwareID >> 16) & 0xFFFF);                      registers[(int)Registers.C] = devices[value].Version; //C is the hardware version                      registers[(int)Registers.X] = (ushort)(devices[value].ManufacturerID & 0xFFFF); //X+(Y<<16) is a 32 bit word identifying the manufacturer                      registers[(int)Registers.Y] = (ushort)((devices[value].ManufacturerID >> 16) & 0xFFFF);                      break;                  case Intermediate.Instructions.HWI: //HWI a | sends an interrupt to hardware a                      devices[value].OnInterrupt(this);                      break;              }
Magic Number,DCPUB.Testing,Emulator,C:\repos\Blecki_DCPUB\DCPUB\Testing\Emulator.cs,Step,The following statement contains a magic number: switch (ins)              {                  case Intermediate.Instructions.SET: //0x01 | SET b' a | sets b to a                      AssignToOperand(operandB' value' false);                      break;                  case Intermediate.Instructions.ADD: //ADD b' a | sets b to b+a' sets EX to 0x0001 if there's an overflow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) + value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.SUB: //SUB b' a | sets b to b-a' sets EX to 0xffff if there's an underflow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) - value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MUL: //MUL b' a | sets b to b*a' sets EX to ((b*a)>>16)&0xffff (treats b' a as unsigned)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) * value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MLI: //MLI b' a | like MUL' but treat b' a as signed                      intermediate = (UInt32)((short)GetOperandValue(operandB' OperandPlace.B) * (short)value);                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.DIV: //DIV b' a | sets b to b/a' sets EX to ((b<<16)/a)&0xffff. if a==0' sets b and EX to 0 instead. (treats b' a as unsigned)                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      intermediate = value == 0 ? 0 : (UInt32)bValue / value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.DVI: //DVI b' a | like DIV' but treat b' a as signed. Rounds towards 0                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      intermediate = value == 0 ? 0 : (UInt32)((short)bValue / (short)value);                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MOD: //MOD b' a | sets b to b%a. if a==0' sets b to 0 instead.                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      AssignToOperand(operandB' value == 0 ? (ushort)0 : (ushort)(bValue % value)' true);                      break;                  case Intermediate.Instructions.MDI: //MDI b' a | like MOD' but treat b' a as signed. (MDI -7' 16 == -7)                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      AssignToOperand(operandB' value == 0 ? (ushort)0 : (ushort)((short)bValue % (short)value)' true);                      break;                  case Intermediate.Instructions.AND: //AND b' a | sets b to b&a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) & value)' true);                      break;                  case Intermediate.Instructions.BOR: //BOR b' a | sets b to b|a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) | value)' true);                      break;                  case Intermediate.Instructions.XOR: //XOR b' a | sets b to b^a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) ^ value));                      break;                  case Intermediate.Instructions.SHR: //SHR b' a | sets b to b>>>a' sets EX to ((b<<16)>>a)&0xffff (logical shift)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)(intermediate >> value)' true);                      AssignToEx((ushort)(intermediate << 16 >> value));                      break;                  case Intermediate.Instructions.ASR: //ASR b' a | sets b to b>>a' sets EX to ((b<<16)>>>a)&0xffff (arithmetic shift) (treats b as signed)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)((int)intermediate >> value)' true);                      AssignToEx((ushort)((int)intermediate << 16 >> value));                      break;                  case Intermediate.Instructions.SHL: //SHL b' a | sets b to b<<a' sets EX to ((b<<a)>>16)&0xffff                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)(intermediate << value)' true);                      AssignToEx((ushort)(intermediate << value >> 16));                      break;                  case Intermediate.Instructions.IFB: //IFB b' a | performs next instruction only if (b&a)!=0                      SkipIf = (GetOperandValue(operandB' OperandPlace.B) & value) != 0;                      break;                  case Intermediate.Instructions.IFC: //IFC b' a | performs next instruction only if (b&a)==0                      SkipIf = (GetOperandValue(operandB' OperandPlace.B) & value) == 0;                      break;                  case Intermediate.Instructions.IFE: //IFE b' a | performs next instruction only if b==a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) == value;                      break;                  case Intermediate.Instructions.IFN: //IFB b' a | performs next instruction only if b!=a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) != value;                      break;                  case Intermediate.Instructions.IFG: //IFG b' a | performs next instruction only if b>a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) > value;                      break;                  case Intermediate.Instructions.IFA: //IFA b' a | performs next instruction only if b>a (signed)                      SkipIf = (int)GetOperandValue(operandB' OperandPlace.B) > (int)value;                      break;                  case Intermediate.Instructions.IFL: //IFL b' a | performs next instruction only if b<a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) < value;                      break;                  case Intermediate.Instructions.IFU: //IFU b' a | performs next instruction only if b<a (signed)                      SkipIf = (int)GetOperandValue(operandB' OperandPlace.B) < (int)value;                      break;                  case Intermediate.Instructions.ADX: //ADX b' a | sets b to b+a+EX' sets EX to 0x0001 if there is an over-flow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) + value + registers[(int)Registers.EX];                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.SBX: //SBX b' a | sets b to b-a+EX' sets EX to 0xFFFF if there is an under-flow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) - value + registers[(int)Registers.EX];                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.STI: //STI b' a | sets b to a' then increases I and J by 1                      AssignToOperand(operandB' value' false);                      registers[(int)Registers.I] += 1;                      registers[(int)Registers.J] += 1;                      break;                  case Intermediate.Instructions.STD: //STI b' a | sets b to a' then decreases I and J by 1                      AssignToOperand(operandB' value' false);                      registers[(int)Registers.I] -= 1;                      registers[(int)Registers.J] -= 1;                      break;                    case Intermediate.Instructions.JSR: //pushes the address of the next instruction to the stack' then sets PC to a                      ram[(ushort)(registers[(int)Registers.SP] - 1)] = registers[(int)Registers.PC];                      registers[(int)Registers.SP] -= 1;                      registers[(int)Registers.PC] = value;                      break;                  case Intermediate.Instructions.HLT:                      throw new Halt();                    case Intermediate.Instructions.INT: //INT a | triggers a software interrupt with message a                      TriggerInterrupt(value);                      break;                  case Intermediate.Instructions.IAG: //IAG a | sets a to IA                       AssignToOperand(operandA' registers[(int)Registers.IA]' true);                      break;                  case Intermediate.Instructions.IAS: //IAS a | sets IA to A                       registers[(int)Registers.IA] = value;                      break;                  case Intermediate.Instructions.RFI: //RFI a | disables interrupt queueing' pops A from the stack' then pops PC from the stack                      protectInterruptQueue.WaitOne();                      interruptQueueEnabled = false;                      registers[(int)Registers.A] = ram[(ushort)(registers[(int)Registers.SP])];                      registers[(int)Registers.PC] = ram[(ushort)(registers[(int)Registers.SP] + 1)];                      registers[(int)Registers.SP] += 2;                      break;                  case Intermediate.Instructions.IAQ: //IAQ a | if a is nonzero' interrupts will be added to the queue                      interruptQueueEnabled = value != 0; //instead of triggered. if a is zero' interrupts will be                      break;                              //triggered as normal again                    case Intermediate.Instructions.HWN: //HWN a | sets a to number of connected hardware devices                      AssignToOperand(operandA' (ushort)devices.Count' true);                      break;                  case Intermediate.Instructions.HWQ: //HWQ a | sets A' B' C' X' Y registers to information about hardware a                       registers[(int)Registers.A] = (ushort)(devices[value].HardwareID & 0xFFFF); //A+(B<<16) is a 32 bit word identifying the hardware id                      registers[(int)Registers.B] = (ushort)((devices[value].HardwareID >> 16) & 0xFFFF);                      registers[(int)Registers.C] = devices[value].Version; //C is the hardware version                      registers[(int)Registers.X] = (ushort)(devices[value].ManufacturerID & 0xFFFF); //X+(Y<<16) is a 32 bit word identifying the manufacturer                      registers[(int)Registers.Y] = (ushort)((devices[value].ManufacturerID >> 16) & 0xFFFF);                      break;                  case Intermediate.Instructions.HWI: //HWI a | sends an interrupt to hardware a                      devices[value].OnInterrupt(this);                      break;              }
Magic Number,DCPUB.Testing,Emulator,C:\repos\Blecki_DCPUB\DCPUB\Testing\Emulator.cs,Step,The following statement contains a magic number: switch (ins)              {                  case Intermediate.Instructions.SET: //0x01 | SET b' a | sets b to a                      AssignToOperand(operandB' value' false);                      break;                  case Intermediate.Instructions.ADD: //ADD b' a | sets b to b+a' sets EX to 0x0001 if there's an overflow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) + value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.SUB: //SUB b' a | sets b to b-a' sets EX to 0xffff if there's an underflow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) - value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MUL: //MUL b' a | sets b to b*a' sets EX to ((b*a)>>16)&0xffff (treats b' a as unsigned)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) * value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MLI: //MLI b' a | like MUL' but treat b' a as signed                      intermediate = (UInt32)((short)GetOperandValue(operandB' OperandPlace.B) * (short)value);                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.DIV: //DIV b' a | sets b to b/a' sets EX to ((b<<16)/a)&0xffff. if a==0' sets b and EX to 0 instead. (treats b' a as unsigned)                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      intermediate = value == 0 ? 0 : (UInt32)bValue / value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.DVI: //DVI b' a | like DIV' but treat b' a as signed. Rounds towards 0                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      intermediate = value == 0 ? 0 : (UInt32)((short)bValue / (short)value);                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MOD: //MOD b' a | sets b to b%a. if a==0' sets b to 0 instead.                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      AssignToOperand(operandB' value == 0 ? (ushort)0 : (ushort)(bValue % value)' true);                      break;                  case Intermediate.Instructions.MDI: //MDI b' a | like MOD' but treat b' a as signed. (MDI -7' 16 == -7)                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      AssignToOperand(operandB' value == 0 ? (ushort)0 : (ushort)((short)bValue % (short)value)' true);                      break;                  case Intermediate.Instructions.AND: //AND b' a | sets b to b&a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) & value)' true);                      break;                  case Intermediate.Instructions.BOR: //BOR b' a | sets b to b|a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) | value)' true);                      break;                  case Intermediate.Instructions.XOR: //XOR b' a | sets b to b^a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) ^ value));                      break;                  case Intermediate.Instructions.SHR: //SHR b' a | sets b to b>>>a' sets EX to ((b<<16)>>a)&0xffff (logical shift)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)(intermediate >> value)' true);                      AssignToEx((ushort)(intermediate << 16 >> value));                      break;                  case Intermediate.Instructions.ASR: //ASR b' a | sets b to b>>a' sets EX to ((b<<16)>>>a)&0xffff (arithmetic shift) (treats b as signed)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)((int)intermediate >> value)' true);                      AssignToEx((ushort)((int)intermediate << 16 >> value));                      break;                  case Intermediate.Instructions.SHL: //SHL b' a | sets b to b<<a' sets EX to ((b<<a)>>16)&0xffff                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)(intermediate << value)' true);                      AssignToEx((ushort)(intermediate << value >> 16));                      break;                  case Intermediate.Instructions.IFB: //IFB b' a | performs next instruction only if (b&a)!=0                      SkipIf = (GetOperandValue(operandB' OperandPlace.B) & value) != 0;                      break;                  case Intermediate.Instructions.IFC: //IFC b' a | performs next instruction only if (b&a)==0                      SkipIf = (GetOperandValue(operandB' OperandPlace.B) & value) == 0;                      break;                  case Intermediate.Instructions.IFE: //IFE b' a | performs next instruction only if b==a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) == value;                      break;                  case Intermediate.Instructions.IFN: //IFB b' a | performs next instruction only if b!=a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) != value;                      break;                  case Intermediate.Instructions.IFG: //IFG b' a | performs next instruction only if b>a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) > value;                      break;                  case Intermediate.Instructions.IFA: //IFA b' a | performs next instruction only if b>a (signed)                      SkipIf = (int)GetOperandValue(operandB' OperandPlace.B) > (int)value;                      break;                  case Intermediate.Instructions.IFL: //IFL b' a | performs next instruction only if b<a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) < value;                      break;                  case Intermediate.Instructions.IFU: //IFU b' a | performs next instruction only if b<a (signed)                      SkipIf = (int)GetOperandValue(operandB' OperandPlace.B) < (int)value;                      break;                  case Intermediate.Instructions.ADX: //ADX b' a | sets b to b+a+EX' sets EX to 0x0001 if there is an over-flow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) + value + registers[(int)Registers.EX];                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.SBX: //SBX b' a | sets b to b-a+EX' sets EX to 0xFFFF if there is an under-flow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) - value + registers[(int)Registers.EX];                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.STI: //STI b' a | sets b to a' then increases I and J by 1                      AssignToOperand(operandB' value' false);                      registers[(int)Registers.I] += 1;                      registers[(int)Registers.J] += 1;                      break;                  case Intermediate.Instructions.STD: //STI b' a | sets b to a' then decreases I and J by 1                      AssignToOperand(operandB' value' false);                      registers[(int)Registers.I] -= 1;                      registers[(int)Registers.J] -= 1;                      break;                    case Intermediate.Instructions.JSR: //pushes the address of the next instruction to the stack' then sets PC to a                      ram[(ushort)(registers[(int)Registers.SP] - 1)] = registers[(int)Registers.PC];                      registers[(int)Registers.SP] -= 1;                      registers[(int)Registers.PC] = value;                      break;                  case Intermediate.Instructions.HLT:                      throw new Halt();                    case Intermediate.Instructions.INT: //INT a | triggers a software interrupt with message a                      TriggerInterrupt(value);                      break;                  case Intermediate.Instructions.IAG: //IAG a | sets a to IA                       AssignToOperand(operandA' registers[(int)Registers.IA]' true);                      break;                  case Intermediate.Instructions.IAS: //IAS a | sets IA to A                       registers[(int)Registers.IA] = value;                      break;                  case Intermediate.Instructions.RFI: //RFI a | disables interrupt queueing' pops A from the stack' then pops PC from the stack                      protectInterruptQueue.WaitOne();                      interruptQueueEnabled = false;                      registers[(int)Registers.A] = ram[(ushort)(registers[(int)Registers.SP])];                      registers[(int)Registers.PC] = ram[(ushort)(registers[(int)Registers.SP] + 1)];                      registers[(int)Registers.SP] += 2;                      break;                  case Intermediate.Instructions.IAQ: //IAQ a | if a is nonzero' interrupts will be added to the queue                      interruptQueueEnabled = value != 0; //instead of triggered. if a is zero' interrupts will be                      break;                              //triggered as normal again                    case Intermediate.Instructions.HWN: //HWN a | sets a to number of connected hardware devices                      AssignToOperand(operandA' (ushort)devices.Count' true);                      break;                  case Intermediate.Instructions.HWQ: //HWQ a | sets A' B' C' X' Y registers to information about hardware a                       registers[(int)Registers.A] = (ushort)(devices[value].HardwareID & 0xFFFF); //A+(B<<16) is a 32 bit word identifying the hardware id                      registers[(int)Registers.B] = (ushort)((devices[value].HardwareID >> 16) & 0xFFFF);                      registers[(int)Registers.C] = devices[value].Version; //C is the hardware version                      registers[(int)Registers.X] = (ushort)(devices[value].ManufacturerID & 0xFFFF); //X+(Y<<16) is a 32 bit word identifying the manufacturer                      registers[(int)Registers.Y] = (ushort)((devices[value].ManufacturerID >> 16) & 0xFFFF);                      break;                  case Intermediate.Instructions.HWI: //HWI a | sends an interrupt to hardware a                      devices[value].OnInterrupt(this);                      break;              }
Magic Number,DCPUB.Testing,Emulator,C:\repos\Blecki_DCPUB\DCPUB\Testing\Emulator.cs,Step,The following statement contains a magic number: switch (ins)              {                  case Intermediate.Instructions.SET: //0x01 | SET b' a | sets b to a                      AssignToOperand(operandB' value' false);                      break;                  case Intermediate.Instructions.ADD: //ADD b' a | sets b to b+a' sets EX to 0x0001 if there's an overflow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) + value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.SUB: //SUB b' a | sets b to b-a' sets EX to 0xffff if there's an underflow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) - value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MUL: //MUL b' a | sets b to b*a' sets EX to ((b*a)>>16)&0xffff (treats b' a as unsigned)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) * value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MLI: //MLI b' a | like MUL' but treat b' a as signed                      intermediate = (UInt32)((short)GetOperandValue(operandB' OperandPlace.B) * (short)value);                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.DIV: //DIV b' a | sets b to b/a' sets EX to ((b<<16)/a)&0xffff. if a==0' sets b and EX to 0 instead. (treats b' a as unsigned)                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      intermediate = value == 0 ? 0 : (UInt32)bValue / value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.DVI: //DVI b' a | like DIV' but treat b' a as signed. Rounds towards 0                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      intermediate = value == 0 ? 0 : (UInt32)((short)bValue / (short)value);                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MOD: //MOD b' a | sets b to b%a. if a==0' sets b to 0 instead.                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      AssignToOperand(operandB' value == 0 ? (ushort)0 : (ushort)(bValue % value)' true);                      break;                  case Intermediate.Instructions.MDI: //MDI b' a | like MOD' but treat b' a as signed. (MDI -7' 16 == -7)                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      AssignToOperand(operandB' value == 0 ? (ushort)0 : (ushort)((short)bValue % (short)value)' true);                      break;                  case Intermediate.Instructions.AND: //AND b' a | sets b to b&a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) & value)' true);                      break;                  case Intermediate.Instructions.BOR: //BOR b' a | sets b to b|a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) | value)' true);                      break;                  case Intermediate.Instructions.XOR: //XOR b' a | sets b to b^a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) ^ value));                      break;                  case Intermediate.Instructions.SHR: //SHR b' a | sets b to b>>>a' sets EX to ((b<<16)>>a)&0xffff (logical shift)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)(intermediate >> value)' true);                      AssignToEx((ushort)(intermediate << 16 >> value));                      break;                  case Intermediate.Instructions.ASR: //ASR b' a | sets b to b>>a' sets EX to ((b<<16)>>>a)&0xffff (arithmetic shift) (treats b as signed)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)((int)intermediate >> value)' true);                      AssignToEx((ushort)((int)intermediate << 16 >> value));                      break;                  case Intermediate.Instructions.SHL: //SHL b' a | sets b to b<<a' sets EX to ((b<<a)>>16)&0xffff                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)(intermediate << value)' true);                      AssignToEx((ushort)(intermediate << value >> 16));                      break;                  case Intermediate.Instructions.IFB: //IFB b' a | performs next instruction only if (b&a)!=0                      SkipIf = (GetOperandValue(operandB' OperandPlace.B) & value) != 0;                      break;                  case Intermediate.Instructions.IFC: //IFC b' a | performs next instruction only if (b&a)==0                      SkipIf = (GetOperandValue(operandB' OperandPlace.B) & value) == 0;                      break;                  case Intermediate.Instructions.IFE: //IFE b' a | performs next instruction only if b==a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) == value;                      break;                  case Intermediate.Instructions.IFN: //IFB b' a | performs next instruction only if b!=a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) != value;                      break;                  case Intermediate.Instructions.IFG: //IFG b' a | performs next instruction only if b>a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) > value;                      break;                  case Intermediate.Instructions.IFA: //IFA b' a | performs next instruction only if b>a (signed)                      SkipIf = (int)GetOperandValue(operandB' OperandPlace.B) > (int)value;                      break;                  case Intermediate.Instructions.IFL: //IFL b' a | performs next instruction only if b<a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) < value;                      break;                  case Intermediate.Instructions.IFU: //IFU b' a | performs next instruction only if b<a (signed)                      SkipIf = (int)GetOperandValue(operandB' OperandPlace.B) < (int)value;                      break;                  case Intermediate.Instructions.ADX: //ADX b' a | sets b to b+a+EX' sets EX to 0x0001 if there is an over-flow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) + value + registers[(int)Registers.EX];                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.SBX: //SBX b' a | sets b to b-a+EX' sets EX to 0xFFFF if there is an under-flow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) - value + registers[(int)Registers.EX];                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.STI: //STI b' a | sets b to a' then increases I and J by 1                      AssignToOperand(operandB' value' false);                      registers[(int)Registers.I] += 1;                      registers[(int)Registers.J] += 1;                      break;                  case Intermediate.Instructions.STD: //STI b' a | sets b to a' then decreases I and J by 1                      AssignToOperand(operandB' value' false);                      registers[(int)Registers.I] -= 1;                      registers[(int)Registers.J] -= 1;                      break;                    case Intermediate.Instructions.JSR: //pushes the address of the next instruction to the stack' then sets PC to a                      ram[(ushort)(registers[(int)Registers.SP] - 1)] = registers[(int)Registers.PC];                      registers[(int)Registers.SP] -= 1;                      registers[(int)Registers.PC] = value;                      break;                  case Intermediate.Instructions.HLT:                      throw new Halt();                    case Intermediate.Instructions.INT: //INT a | triggers a software interrupt with message a                      TriggerInterrupt(value);                      break;                  case Intermediate.Instructions.IAG: //IAG a | sets a to IA                       AssignToOperand(operandA' registers[(int)Registers.IA]' true);                      break;                  case Intermediate.Instructions.IAS: //IAS a | sets IA to A                       registers[(int)Registers.IA] = value;                      break;                  case Intermediate.Instructions.RFI: //RFI a | disables interrupt queueing' pops A from the stack' then pops PC from the stack                      protectInterruptQueue.WaitOne();                      interruptQueueEnabled = false;                      registers[(int)Registers.A] = ram[(ushort)(registers[(int)Registers.SP])];                      registers[(int)Registers.PC] = ram[(ushort)(registers[(int)Registers.SP] + 1)];                      registers[(int)Registers.SP] += 2;                      break;                  case Intermediate.Instructions.IAQ: //IAQ a | if a is nonzero' interrupts will be added to the queue                      interruptQueueEnabled = value != 0; //instead of triggered. if a is zero' interrupts will be                      break;                              //triggered as normal again                    case Intermediate.Instructions.HWN: //HWN a | sets a to number of connected hardware devices                      AssignToOperand(operandA' (ushort)devices.Count' true);                      break;                  case Intermediate.Instructions.HWQ: //HWQ a | sets A' B' C' X' Y registers to information about hardware a                       registers[(int)Registers.A] = (ushort)(devices[value].HardwareID & 0xFFFF); //A+(B<<16) is a 32 bit word identifying the hardware id                      registers[(int)Registers.B] = (ushort)((devices[value].HardwareID >> 16) & 0xFFFF);                      registers[(int)Registers.C] = devices[value].Version; //C is the hardware version                      registers[(int)Registers.X] = (ushort)(devices[value].ManufacturerID & 0xFFFF); //X+(Y<<16) is a 32 bit word identifying the manufacturer                      registers[(int)Registers.Y] = (ushort)((devices[value].ManufacturerID >> 16) & 0xFFFF);                      break;                  case Intermediate.Instructions.HWI: //HWI a | sends an interrupt to hardware a                      devices[value].OnInterrupt(this);                      break;              }
Magic Number,DCPUB.Testing,Emulator,C:\repos\Blecki_DCPUB\DCPUB\Testing\Emulator.cs,Step,The following statement contains a magic number: switch (ins)              {                  case Intermediate.Instructions.SET: //0x01 | SET b' a | sets b to a                      AssignToOperand(operandB' value' false);                      break;                  case Intermediate.Instructions.ADD: //ADD b' a | sets b to b+a' sets EX to 0x0001 if there's an overflow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) + value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.SUB: //SUB b' a | sets b to b-a' sets EX to 0xffff if there's an underflow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) - value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MUL: //MUL b' a | sets b to b*a' sets EX to ((b*a)>>16)&0xffff (treats b' a as unsigned)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) * value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MLI: //MLI b' a | like MUL' but treat b' a as signed                      intermediate = (UInt32)((short)GetOperandValue(operandB' OperandPlace.B) * (short)value);                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.DIV: //DIV b' a | sets b to b/a' sets EX to ((b<<16)/a)&0xffff. if a==0' sets b and EX to 0 instead. (treats b' a as unsigned)                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      intermediate = value == 0 ? 0 : (UInt32)bValue / value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.DVI: //DVI b' a | like DIV' but treat b' a as signed. Rounds towards 0                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      intermediate = value == 0 ? 0 : (UInt32)((short)bValue / (short)value);                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MOD: //MOD b' a | sets b to b%a. if a==0' sets b to 0 instead.                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      AssignToOperand(operandB' value == 0 ? (ushort)0 : (ushort)(bValue % value)' true);                      break;                  case Intermediate.Instructions.MDI: //MDI b' a | like MOD' but treat b' a as signed. (MDI -7' 16 == -7)                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      AssignToOperand(operandB' value == 0 ? (ushort)0 : (ushort)((short)bValue % (short)value)' true);                      break;                  case Intermediate.Instructions.AND: //AND b' a | sets b to b&a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) & value)' true);                      break;                  case Intermediate.Instructions.BOR: //BOR b' a | sets b to b|a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) | value)' true);                      break;                  case Intermediate.Instructions.XOR: //XOR b' a | sets b to b^a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) ^ value));                      break;                  case Intermediate.Instructions.SHR: //SHR b' a | sets b to b>>>a' sets EX to ((b<<16)>>a)&0xffff (logical shift)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)(intermediate >> value)' true);                      AssignToEx((ushort)(intermediate << 16 >> value));                      break;                  case Intermediate.Instructions.ASR: //ASR b' a | sets b to b>>a' sets EX to ((b<<16)>>>a)&0xffff (arithmetic shift) (treats b as signed)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)((int)intermediate >> value)' true);                      AssignToEx((ushort)((int)intermediate << 16 >> value));                      break;                  case Intermediate.Instructions.SHL: //SHL b' a | sets b to b<<a' sets EX to ((b<<a)>>16)&0xffff                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)(intermediate << value)' true);                      AssignToEx((ushort)(intermediate << value >> 16));                      break;                  case Intermediate.Instructions.IFB: //IFB b' a | performs next instruction only if (b&a)!=0                      SkipIf = (GetOperandValue(operandB' OperandPlace.B) & value) != 0;                      break;                  case Intermediate.Instructions.IFC: //IFC b' a | performs next instruction only if (b&a)==0                      SkipIf = (GetOperandValue(operandB' OperandPlace.B) & value) == 0;                      break;                  case Intermediate.Instructions.IFE: //IFE b' a | performs next instruction only if b==a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) == value;                      break;                  case Intermediate.Instructions.IFN: //IFB b' a | performs next instruction only if b!=a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) != value;                      break;                  case Intermediate.Instructions.IFG: //IFG b' a | performs next instruction only if b>a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) > value;                      break;                  case Intermediate.Instructions.IFA: //IFA b' a | performs next instruction only if b>a (signed)                      SkipIf = (int)GetOperandValue(operandB' OperandPlace.B) > (int)value;                      break;                  case Intermediate.Instructions.IFL: //IFL b' a | performs next instruction only if b<a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) < value;                      break;                  case Intermediate.Instructions.IFU: //IFU b' a | performs next instruction only if b<a (signed)                      SkipIf = (int)GetOperandValue(operandB' OperandPlace.B) < (int)value;                      break;                  case Intermediate.Instructions.ADX: //ADX b' a | sets b to b+a+EX' sets EX to 0x0001 if there is an over-flow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) + value + registers[(int)Registers.EX];                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.SBX: //SBX b' a | sets b to b-a+EX' sets EX to 0xFFFF if there is an under-flow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) - value + registers[(int)Registers.EX];                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.STI: //STI b' a | sets b to a' then increases I and J by 1                      AssignToOperand(operandB' value' false);                      registers[(int)Registers.I] += 1;                      registers[(int)Registers.J] += 1;                      break;                  case Intermediate.Instructions.STD: //STI b' a | sets b to a' then decreases I and J by 1                      AssignToOperand(operandB' value' false);                      registers[(int)Registers.I] -= 1;                      registers[(int)Registers.J] -= 1;                      break;                    case Intermediate.Instructions.JSR: //pushes the address of the next instruction to the stack' then sets PC to a                      ram[(ushort)(registers[(int)Registers.SP] - 1)] = registers[(int)Registers.PC];                      registers[(int)Registers.SP] -= 1;                      registers[(int)Registers.PC] = value;                      break;                  case Intermediate.Instructions.HLT:                      throw new Halt();                    case Intermediate.Instructions.INT: //INT a | triggers a software interrupt with message a                      TriggerInterrupt(value);                      break;                  case Intermediate.Instructions.IAG: //IAG a | sets a to IA                       AssignToOperand(operandA' registers[(int)Registers.IA]' true);                      break;                  case Intermediate.Instructions.IAS: //IAS a | sets IA to A                       registers[(int)Registers.IA] = value;                      break;                  case Intermediate.Instructions.RFI: //RFI a | disables interrupt queueing' pops A from the stack' then pops PC from the stack                      protectInterruptQueue.WaitOne();                      interruptQueueEnabled = false;                      registers[(int)Registers.A] = ram[(ushort)(registers[(int)Registers.SP])];                      registers[(int)Registers.PC] = ram[(ushort)(registers[(int)Registers.SP] + 1)];                      registers[(int)Registers.SP] += 2;                      break;                  case Intermediate.Instructions.IAQ: //IAQ a | if a is nonzero' interrupts will be added to the queue                      interruptQueueEnabled = value != 0; //instead of triggered. if a is zero' interrupts will be                      break;                              //triggered as normal again                    case Intermediate.Instructions.HWN: //HWN a | sets a to number of connected hardware devices                      AssignToOperand(operandA' (ushort)devices.Count' true);                      break;                  case Intermediate.Instructions.HWQ: //HWQ a | sets A' B' C' X' Y registers to information about hardware a                       registers[(int)Registers.A] = (ushort)(devices[value].HardwareID & 0xFFFF); //A+(B<<16) is a 32 bit word identifying the hardware id                      registers[(int)Registers.B] = (ushort)((devices[value].HardwareID >> 16) & 0xFFFF);                      registers[(int)Registers.C] = devices[value].Version; //C is the hardware version                      registers[(int)Registers.X] = (ushort)(devices[value].ManufacturerID & 0xFFFF); //X+(Y<<16) is a 32 bit word identifying the manufacturer                      registers[(int)Registers.Y] = (ushort)((devices[value].ManufacturerID >> 16) & 0xFFFF);                      break;                  case Intermediate.Instructions.HWI: //HWI a | sends an interrupt to hardware a                      devices[value].OnInterrupt(this);                      break;              }
Magic Number,DCPUB.Testing,Emulator,C:\repos\Blecki_DCPUB\DCPUB\Testing\Emulator.cs,Step,The following statement contains a magic number: switch (ins)              {                  case Intermediate.Instructions.SET: //0x01 | SET b' a | sets b to a                      AssignToOperand(operandB' value' false);                      break;                  case Intermediate.Instructions.ADD: //ADD b' a | sets b to b+a' sets EX to 0x0001 if there's an overflow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) + value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.SUB: //SUB b' a | sets b to b-a' sets EX to 0xffff if there's an underflow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) - value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MUL: //MUL b' a | sets b to b*a' sets EX to ((b*a)>>16)&0xffff (treats b' a as unsigned)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) * value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MLI: //MLI b' a | like MUL' but treat b' a as signed                      intermediate = (UInt32)((short)GetOperandValue(operandB' OperandPlace.B) * (short)value);                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.DIV: //DIV b' a | sets b to b/a' sets EX to ((b<<16)/a)&0xffff. if a==0' sets b and EX to 0 instead. (treats b' a as unsigned)                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      intermediate = value == 0 ? 0 : (UInt32)bValue / value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.DVI: //DVI b' a | like DIV' but treat b' a as signed. Rounds towards 0                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      intermediate = value == 0 ? 0 : (UInt32)((short)bValue / (short)value);                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MOD: //MOD b' a | sets b to b%a. if a==0' sets b to 0 instead.                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      AssignToOperand(operandB' value == 0 ? (ushort)0 : (ushort)(bValue % value)' true);                      break;                  case Intermediate.Instructions.MDI: //MDI b' a | like MOD' but treat b' a as signed. (MDI -7' 16 == -7)                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      AssignToOperand(operandB' value == 0 ? (ushort)0 : (ushort)((short)bValue % (short)value)' true);                      break;                  case Intermediate.Instructions.AND: //AND b' a | sets b to b&a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) & value)' true);                      break;                  case Intermediate.Instructions.BOR: //BOR b' a | sets b to b|a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) | value)' true);                      break;                  case Intermediate.Instructions.XOR: //XOR b' a | sets b to b^a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) ^ value));                      break;                  case Intermediate.Instructions.SHR: //SHR b' a | sets b to b>>>a' sets EX to ((b<<16)>>a)&0xffff (logical shift)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)(intermediate >> value)' true);                      AssignToEx((ushort)(intermediate << 16 >> value));                      break;                  case Intermediate.Instructions.ASR: //ASR b' a | sets b to b>>a' sets EX to ((b<<16)>>>a)&0xffff (arithmetic shift) (treats b as signed)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)((int)intermediate >> value)' true);                      AssignToEx((ushort)((int)intermediate << 16 >> value));                      break;                  case Intermediate.Instructions.SHL: //SHL b' a | sets b to b<<a' sets EX to ((b<<a)>>16)&0xffff                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)(intermediate << value)' true);                      AssignToEx((ushort)(intermediate << value >> 16));                      break;                  case Intermediate.Instructions.IFB: //IFB b' a | performs next instruction only if (b&a)!=0                      SkipIf = (GetOperandValue(operandB' OperandPlace.B) & value) != 0;                      break;                  case Intermediate.Instructions.IFC: //IFC b' a | performs next instruction only if (b&a)==0                      SkipIf = (GetOperandValue(operandB' OperandPlace.B) & value) == 0;                      break;                  case Intermediate.Instructions.IFE: //IFE b' a | performs next instruction only if b==a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) == value;                      break;                  case Intermediate.Instructions.IFN: //IFB b' a | performs next instruction only if b!=a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) != value;                      break;                  case Intermediate.Instructions.IFG: //IFG b' a | performs next instruction only if b>a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) > value;                      break;                  case Intermediate.Instructions.IFA: //IFA b' a | performs next instruction only if b>a (signed)                      SkipIf = (int)GetOperandValue(operandB' OperandPlace.B) > (int)value;                      break;                  case Intermediate.Instructions.IFL: //IFL b' a | performs next instruction only if b<a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) < value;                      break;                  case Intermediate.Instructions.IFU: //IFU b' a | performs next instruction only if b<a (signed)                      SkipIf = (int)GetOperandValue(operandB' OperandPlace.B) < (int)value;                      break;                  case Intermediate.Instructions.ADX: //ADX b' a | sets b to b+a+EX' sets EX to 0x0001 if there is an over-flow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) + value + registers[(int)Registers.EX];                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.SBX: //SBX b' a | sets b to b-a+EX' sets EX to 0xFFFF if there is an under-flow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) - value + registers[(int)Registers.EX];                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.STI: //STI b' a | sets b to a' then increases I and J by 1                      AssignToOperand(operandB' value' false);                      registers[(int)Registers.I] += 1;                      registers[(int)Registers.J] += 1;                      break;                  case Intermediate.Instructions.STD: //STI b' a | sets b to a' then decreases I and J by 1                      AssignToOperand(operandB' value' false);                      registers[(int)Registers.I] -= 1;                      registers[(int)Registers.J] -= 1;                      break;                    case Intermediate.Instructions.JSR: //pushes the address of the next instruction to the stack' then sets PC to a                      ram[(ushort)(registers[(int)Registers.SP] - 1)] = registers[(int)Registers.PC];                      registers[(int)Registers.SP] -= 1;                      registers[(int)Registers.PC] = value;                      break;                  case Intermediate.Instructions.HLT:                      throw new Halt();                    case Intermediate.Instructions.INT: //INT a | triggers a software interrupt with message a                      TriggerInterrupt(value);                      break;                  case Intermediate.Instructions.IAG: //IAG a | sets a to IA                       AssignToOperand(operandA' registers[(int)Registers.IA]' true);                      break;                  case Intermediate.Instructions.IAS: //IAS a | sets IA to A                       registers[(int)Registers.IA] = value;                      break;                  case Intermediate.Instructions.RFI: //RFI a | disables interrupt queueing' pops A from the stack' then pops PC from the stack                      protectInterruptQueue.WaitOne();                      interruptQueueEnabled = false;                      registers[(int)Registers.A] = ram[(ushort)(registers[(int)Registers.SP])];                      registers[(int)Registers.PC] = ram[(ushort)(registers[(int)Registers.SP] + 1)];                      registers[(int)Registers.SP] += 2;                      break;                  case Intermediate.Instructions.IAQ: //IAQ a | if a is nonzero' interrupts will be added to the queue                      interruptQueueEnabled = value != 0; //instead of triggered. if a is zero' interrupts will be                      break;                              //triggered as normal again                    case Intermediate.Instructions.HWN: //HWN a | sets a to number of connected hardware devices                      AssignToOperand(operandA' (ushort)devices.Count' true);                      break;                  case Intermediate.Instructions.HWQ: //HWQ a | sets A' B' C' X' Y registers to information about hardware a                       registers[(int)Registers.A] = (ushort)(devices[value].HardwareID & 0xFFFF); //A+(B<<16) is a 32 bit word identifying the hardware id                      registers[(int)Registers.B] = (ushort)((devices[value].HardwareID >> 16) & 0xFFFF);                      registers[(int)Registers.C] = devices[value].Version; //C is the hardware version                      registers[(int)Registers.X] = (ushort)(devices[value].ManufacturerID & 0xFFFF); //X+(Y<<16) is a 32 bit word identifying the manufacturer                      registers[(int)Registers.Y] = (ushort)((devices[value].ManufacturerID >> 16) & 0xFFFF);                      break;                  case Intermediate.Instructions.HWI: //HWI a | sends an interrupt to hardware a                      devices[value].OnInterrupt(this);                      break;              }
Magic Number,DCPUB.Testing,Emulator,C:\repos\Blecki_DCPUB\DCPUB\Testing\Emulator.cs,Step,The following statement contains a magic number: switch (ins)              {                  case Intermediate.Instructions.SET: //0x01 | SET b' a | sets b to a                      AssignToOperand(operandB' value' false);                      break;                  case Intermediate.Instructions.ADD: //ADD b' a | sets b to b+a' sets EX to 0x0001 if there's an overflow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) + value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.SUB: //SUB b' a | sets b to b-a' sets EX to 0xffff if there's an underflow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) - value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MUL: //MUL b' a | sets b to b*a' sets EX to ((b*a)>>16)&0xffff (treats b' a as unsigned)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) * value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MLI: //MLI b' a | like MUL' but treat b' a as signed                      intermediate = (UInt32)((short)GetOperandValue(operandB' OperandPlace.B) * (short)value);                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.DIV: //DIV b' a | sets b to b/a' sets EX to ((b<<16)/a)&0xffff. if a==0' sets b and EX to 0 instead. (treats b' a as unsigned)                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      intermediate = value == 0 ? 0 : (UInt32)bValue / value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.DVI: //DVI b' a | like DIV' but treat b' a as signed. Rounds towards 0                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      intermediate = value == 0 ? 0 : (UInt32)((short)bValue / (short)value);                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MOD: //MOD b' a | sets b to b%a. if a==0' sets b to 0 instead.                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      AssignToOperand(operandB' value == 0 ? (ushort)0 : (ushort)(bValue % value)' true);                      break;                  case Intermediate.Instructions.MDI: //MDI b' a | like MOD' but treat b' a as signed. (MDI -7' 16 == -7)                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      AssignToOperand(operandB' value == 0 ? (ushort)0 : (ushort)((short)bValue % (short)value)' true);                      break;                  case Intermediate.Instructions.AND: //AND b' a | sets b to b&a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) & value)' true);                      break;                  case Intermediate.Instructions.BOR: //BOR b' a | sets b to b|a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) | value)' true);                      break;                  case Intermediate.Instructions.XOR: //XOR b' a | sets b to b^a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) ^ value));                      break;                  case Intermediate.Instructions.SHR: //SHR b' a | sets b to b>>>a' sets EX to ((b<<16)>>a)&0xffff (logical shift)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)(intermediate >> value)' true);                      AssignToEx((ushort)(intermediate << 16 >> value));                      break;                  case Intermediate.Instructions.ASR: //ASR b' a | sets b to b>>a' sets EX to ((b<<16)>>>a)&0xffff (arithmetic shift) (treats b as signed)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)((int)intermediate >> value)' true);                      AssignToEx((ushort)((int)intermediate << 16 >> value));                      break;                  case Intermediate.Instructions.SHL: //SHL b' a | sets b to b<<a' sets EX to ((b<<a)>>16)&0xffff                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)(intermediate << value)' true);                      AssignToEx((ushort)(intermediate << value >> 16));                      break;                  case Intermediate.Instructions.IFB: //IFB b' a | performs next instruction only if (b&a)!=0                      SkipIf = (GetOperandValue(operandB' OperandPlace.B) & value) != 0;                      break;                  case Intermediate.Instructions.IFC: //IFC b' a | performs next instruction only if (b&a)==0                      SkipIf = (GetOperandValue(operandB' OperandPlace.B) & value) == 0;                      break;                  case Intermediate.Instructions.IFE: //IFE b' a | performs next instruction only if b==a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) == value;                      break;                  case Intermediate.Instructions.IFN: //IFB b' a | performs next instruction only if b!=a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) != value;                      break;                  case Intermediate.Instructions.IFG: //IFG b' a | performs next instruction only if b>a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) > value;                      break;                  case Intermediate.Instructions.IFA: //IFA b' a | performs next instruction only if b>a (signed)                      SkipIf = (int)GetOperandValue(operandB' OperandPlace.B) > (int)value;                      break;                  case Intermediate.Instructions.IFL: //IFL b' a | performs next instruction only if b<a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) < value;                      break;                  case Intermediate.Instructions.IFU: //IFU b' a | performs next instruction only if b<a (signed)                      SkipIf = (int)GetOperandValue(operandB' OperandPlace.B) < (int)value;                      break;                  case Intermediate.Instructions.ADX: //ADX b' a | sets b to b+a+EX' sets EX to 0x0001 if there is an over-flow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) + value + registers[(int)Registers.EX];                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.SBX: //SBX b' a | sets b to b-a+EX' sets EX to 0xFFFF if there is an under-flow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) - value + registers[(int)Registers.EX];                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.STI: //STI b' a | sets b to a' then increases I and J by 1                      AssignToOperand(operandB' value' false);                      registers[(int)Registers.I] += 1;                      registers[(int)Registers.J] += 1;                      break;                  case Intermediate.Instructions.STD: //STI b' a | sets b to a' then decreases I and J by 1                      AssignToOperand(operandB' value' false);                      registers[(int)Registers.I] -= 1;                      registers[(int)Registers.J] -= 1;                      break;                    case Intermediate.Instructions.JSR: //pushes the address of the next instruction to the stack' then sets PC to a                      ram[(ushort)(registers[(int)Registers.SP] - 1)] = registers[(int)Registers.PC];                      registers[(int)Registers.SP] -= 1;                      registers[(int)Registers.PC] = value;                      break;                  case Intermediate.Instructions.HLT:                      throw new Halt();                    case Intermediate.Instructions.INT: //INT a | triggers a software interrupt with message a                      TriggerInterrupt(value);                      break;                  case Intermediate.Instructions.IAG: //IAG a | sets a to IA                       AssignToOperand(operandA' registers[(int)Registers.IA]' true);                      break;                  case Intermediate.Instructions.IAS: //IAS a | sets IA to A                       registers[(int)Registers.IA] = value;                      break;                  case Intermediate.Instructions.RFI: //RFI a | disables interrupt queueing' pops A from the stack' then pops PC from the stack                      protectInterruptQueue.WaitOne();                      interruptQueueEnabled = false;                      registers[(int)Registers.A] = ram[(ushort)(registers[(int)Registers.SP])];                      registers[(int)Registers.PC] = ram[(ushort)(registers[(int)Registers.SP] + 1)];                      registers[(int)Registers.SP] += 2;                      break;                  case Intermediate.Instructions.IAQ: //IAQ a | if a is nonzero' interrupts will be added to the queue                      interruptQueueEnabled = value != 0; //instead of triggered. if a is zero' interrupts will be                      break;                              //triggered as normal again                    case Intermediate.Instructions.HWN: //HWN a | sets a to number of connected hardware devices                      AssignToOperand(operandA' (ushort)devices.Count' true);                      break;                  case Intermediate.Instructions.HWQ: //HWQ a | sets A' B' C' X' Y registers to information about hardware a                       registers[(int)Registers.A] = (ushort)(devices[value].HardwareID & 0xFFFF); //A+(B<<16) is a 32 bit word identifying the hardware id                      registers[(int)Registers.B] = (ushort)((devices[value].HardwareID >> 16) & 0xFFFF);                      registers[(int)Registers.C] = devices[value].Version; //C is the hardware version                      registers[(int)Registers.X] = (ushort)(devices[value].ManufacturerID & 0xFFFF); //X+(Y<<16) is a 32 bit word identifying the manufacturer                      registers[(int)Registers.Y] = (ushort)((devices[value].ManufacturerID >> 16) & 0xFFFF);                      break;                  case Intermediate.Instructions.HWI: //HWI a | sends an interrupt to hardware a                      devices[value].OnInterrupt(this);                      break;              }
Magic Number,DCPUB,Grammar,C:\repos\Blecki_DCPUB\DCPUB\Grammar.cs,Grammar,The following statement contains a magic number: this.RegisterOperators(2' Associativity.Left' "=="' "!="' ">"' "<"' "->"' "-<");
Magic Number,DCPUB,Grammar,C:\repos\Blecki_DCPUB\DCPUB\Grammar.cs,Grammar,The following statement contains a magic number: this.RegisterOperators(3' Associativity.Right' "="' "+="' "-="' "*="' "/="' "%="' "^="' "<<="' ">>="' "&="' "|="' "-*="' "-/="' "-%=");
Magic Number,DCPUB,Grammar,C:\repos\Blecki_DCPUB\DCPUB\Grammar.cs,Grammar,The following statement contains a magic number: this.RegisterOperators(4' Associativity.Left' "+"' "-");
Magic Number,DCPUB,Grammar,C:\repos\Blecki_DCPUB\DCPUB\Grammar.cs,Grammar,The following statement contains a magic number: this.RegisterOperators(5' Associativity.Left' "*"' "/"' "%");
Magic Number,DCPUB,Grammar,C:\repos\Blecki_DCPUB\DCPUB\Grammar.cs,Grammar,The following statement contains a magic number: this.RegisterOperators(5' Associativity.Left' "-*"' "-/"' "-%");
Magic Number,DCPUB,Grammar,C:\repos\Blecki_DCPUB\DCPUB\Grammar.cs,Grammar,The following statement contains a magic number: this.RegisterOperators(6' Associativity.Left' "<<"' ">>"' "&"' "|"' "^"' "!");
Magic Number,DCPUB,Grammar,C:\repos\Blecki_DCPUB\DCPUB\Grammar.cs,Grammar,The following statement contains a magic number: this.RegisterOperators(7' Associativity.Left' ":");
Magic Number,DCPUB,Grammar,C:\repos\Blecki_DCPUB\DCPUB\Grammar.cs,Grammar,The following statement contains a magic number: this.RegisterOperators(8' Associativity.Left' "{"' "}"' "["' "]");
Magic Number,DCPUB.Ast.Assembly,InstructionAstNode,C:\repos\Blecki_DCPUB\DCPUB\Ast\Assembly\InstructionAstNode.cs,ParseInstruction,The following statement contains a magic number: if (treeNode.Term.Name == "instruction")              {                  var iNode = new Instruction();                  iNode.instruction = (Instructions)Enum.Parse(typeof(Instructions)' treeNode.FirstChild.FindTokenAndGetText());                  iNode.firstOperand = OperandAstNode.ParseOperand(treeNode.ChildNodes[1].FirstChild);                    if (iNode.instruction <= Instructions.SINGLE_OPERAND_INSTRUCTIONS)                  {                      if (treeNode.ChildNodes.Count >= 3)                          iNode.secondOperand = OperandAstNode.ParseOperand(treeNode.ChildNodes[2].FirstChild.FirstChild);                  }                    return iNode;              }              else if (treeNode.Term.Name == "label")              {                  var lNode = new Intermediate.LabelNode();                  lNode.label = new Intermediate.Label(treeNode.ChildNodes[0].FindTokenAndGetText());                  return lNode;              }              else if (treeNode.Term.Name == "dat")              {                  var dNode = new InlineStaticData();                    for (int i = 0; i < treeNode.ChildNodes[1].ChildNodes.Count; ++i)                  {                      var token = treeNode.ChildNodes[1].ChildNodes[i].FindTokenAndGetText();                      var dataNode = new Operand();                      if (token[0] == '\"')                      {                          dataNode.semantics |= OperandSemantics.Label;                          dataNode.label = new Intermediate.Label(token);                      }                      else if (token[0] == '\'')                      {                          dataNode.semantics |= OperandSemantics.Constant;                          dataNode.constant = (ushort)token[1];                      }                      else if (token.StartsWith("0x"))                      {                          dataNode.semantics |= OperandSemantics.Constant;                          dataNode.constant = Convert.ToUInt16(token.Substring(2)' 16);                      }                      else                      {                          try {                              dataNode.constant = Convert.ToUInt16(token);                              dataNode.semantics |= OperandSemantics.Constant;                          } catch (Exception)                          {                              dataNode.semantics |= OperandSemantics.Label;                              dataNode.label = new Intermediate.Label(token);                          }                      }                      dNode.data.Add(dataNode);                  }                    return dNode;                }              else                  throw new InternalError("Error parsing inline ASM");
Magic Number,DCPUB.Ast.Assembly,InstructionAstNode,C:\repos\Blecki_DCPUB\DCPUB\Ast\Assembly\InstructionAstNode.cs,ParseInstruction,The following statement contains a magic number: if (treeNode.Term.Name == "instruction")              {                  var iNode = new Instruction();                  iNode.instruction = (Instructions)Enum.Parse(typeof(Instructions)' treeNode.FirstChild.FindTokenAndGetText());                  iNode.firstOperand = OperandAstNode.ParseOperand(treeNode.ChildNodes[1].FirstChild);                    if (iNode.instruction <= Instructions.SINGLE_OPERAND_INSTRUCTIONS)                  {                      if (treeNode.ChildNodes.Count >= 3)                          iNode.secondOperand = OperandAstNode.ParseOperand(treeNode.ChildNodes[2].FirstChild.FirstChild);                  }                    return iNode;              }              else if (treeNode.Term.Name == "label")              {                  var lNode = new Intermediate.LabelNode();                  lNode.label = new Intermediate.Label(treeNode.ChildNodes[0].FindTokenAndGetText());                  return lNode;              }              else if (treeNode.Term.Name == "dat")              {                  var dNode = new InlineStaticData();                    for (int i = 0; i < treeNode.ChildNodes[1].ChildNodes.Count; ++i)                  {                      var token = treeNode.ChildNodes[1].ChildNodes[i].FindTokenAndGetText();                      var dataNode = new Operand();                      if (token[0] == '\"')                      {                          dataNode.semantics |= OperandSemantics.Label;                          dataNode.label = new Intermediate.Label(token);                      }                      else if (token[0] == '\'')                      {                          dataNode.semantics |= OperandSemantics.Constant;                          dataNode.constant = (ushort)token[1];                      }                      else if (token.StartsWith("0x"))                      {                          dataNode.semantics |= OperandSemantics.Constant;                          dataNode.constant = Convert.ToUInt16(token.Substring(2)' 16);                      }                      else                      {                          try {                              dataNode.constant = Convert.ToUInt16(token);                              dataNode.semantics |= OperandSemantics.Constant;                          } catch (Exception)                          {                              dataNode.semantics |= OperandSemantics.Label;                              dataNode.label = new Intermediate.Label(token);                          }                      }                      dNode.data.Add(dataNode);                  }                    return dNode;                }              else                  throw new InternalError("Error parsing inline ASM");
Magic Number,DCPUB.Ast.Assembly,InstructionAstNode,C:\repos\Blecki_DCPUB\DCPUB\Ast\Assembly\InstructionAstNode.cs,ParseInstruction,The following statement contains a magic number: if (treeNode.Term.Name == "instruction")              {                  var iNode = new Instruction();                  iNode.instruction = (Instructions)Enum.Parse(typeof(Instructions)' treeNode.FirstChild.FindTokenAndGetText());                  iNode.firstOperand = OperandAstNode.ParseOperand(treeNode.ChildNodes[1].FirstChild);                    if (iNode.instruction <= Instructions.SINGLE_OPERAND_INSTRUCTIONS)                  {                      if (treeNode.ChildNodes.Count >= 3)                          iNode.secondOperand = OperandAstNode.ParseOperand(treeNode.ChildNodes[2].FirstChild.FirstChild);                  }                    return iNode;              }              else if (treeNode.Term.Name == "label")              {                  var lNode = new Intermediate.LabelNode();                  lNode.label = new Intermediate.Label(treeNode.ChildNodes[0].FindTokenAndGetText());                  return lNode;              }              else if (treeNode.Term.Name == "dat")              {                  var dNode = new InlineStaticData();                    for (int i = 0; i < treeNode.ChildNodes[1].ChildNodes.Count; ++i)                  {                      var token = treeNode.ChildNodes[1].ChildNodes[i].FindTokenAndGetText();                      var dataNode = new Operand();                      if (token[0] == '\"')                      {                          dataNode.semantics |= OperandSemantics.Label;                          dataNode.label = new Intermediate.Label(token);                      }                      else if (token[0] == '\'')                      {                          dataNode.semantics |= OperandSemantics.Constant;                          dataNode.constant = (ushort)token[1];                      }                      else if (token.StartsWith("0x"))                      {                          dataNode.semantics |= OperandSemantics.Constant;                          dataNode.constant = Convert.ToUInt16(token.Substring(2)' 16);                      }                      else                      {                          try {                              dataNode.constant = Convert.ToUInt16(token);                              dataNode.semantics |= OperandSemantics.Constant;                          } catch (Exception)                          {                              dataNode.semantics |= OperandSemantics.Label;                              dataNode.label = new Intermediate.Label(token);                          }                      }                      dNode.data.Add(dataNode);                  }                    return dNode;                }              else                  throw new InternalError("Error parsing inline ASM");
Magic Number,DCPUB.Ast.Assembly,InstructionAstNode,C:\repos\Blecki_DCPUB\DCPUB\Ast\Assembly\InstructionAstNode.cs,ParseInstruction,The following statement contains a magic number: if (treeNode.Term.Name == "instruction")              {                  var iNode = new Instruction();                  iNode.instruction = (Instructions)Enum.Parse(typeof(Instructions)' treeNode.FirstChild.FindTokenAndGetText());                  iNode.firstOperand = OperandAstNode.ParseOperand(treeNode.ChildNodes[1].FirstChild);                    if (iNode.instruction <= Instructions.SINGLE_OPERAND_INSTRUCTIONS)                  {                      if (treeNode.ChildNodes.Count >= 3)                          iNode.secondOperand = OperandAstNode.ParseOperand(treeNode.ChildNodes[2].FirstChild.FirstChild);                  }                    return iNode;              }              else if (treeNode.Term.Name == "label")              {                  var lNode = new Intermediate.LabelNode();                  lNode.label = new Intermediate.Label(treeNode.ChildNodes[0].FindTokenAndGetText());                  return lNode;              }              else if (treeNode.Term.Name == "dat")              {                  var dNode = new InlineStaticData();                    for (int i = 0; i < treeNode.ChildNodes[1].ChildNodes.Count; ++i)                  {                      var token = treeNode.ChildNodes[1].ChildNodes[i].FindTokenAndGetText();                      var dataNode = new Operand();                      if (token[0] == '\"')                      {                          dataNode.semantics |= OperandSemantics.Label;                          dataNode.label = new Intermediate.Label(token);                      }                      else if (token[0] == '\'')                      {                          dataNode.semantics |= OperandSemantics.Constant;                          dataNode.constant = (ushort)token[1];                      }                      else if (token.StartsWith("0x"))                      {                          dataNode.semantics |= OperandSemantics.Constant;                          dataNode.constant = Convert.ToUInt16(token.Substring(2)' 16);                      }                      else                      {                          try {                              dataNode.constant = Convert.ToUInt16(token);                              dataNode.semantics |= OperandSemantics.Constant;                          } catch (Exception)                          {                              dataNode.semantics |= OperandSemantics.Label;                              dataNode.label = new Intermediate.Label(token);                          }                      }                      dNode.data.Add(dataNode);                  }                    return dNode;                }              else                  throw new InternalError("Error parsing inline ASM");
Magic Number,DCPUB.Ast.Assembly,OperandAstNode,C:\repos\Blecki_DCPUB\DCPUB\Ast\Assembly\OperandAstNode.cs,ParseOperand,The following statement contains a magic number: if (root.Term.Name == "offset")              {                  r.semantics |= OperandSemantics.Offset;                  string constant = "";                  string reg = "";                  if (root.FirstChild.Term.Name == "integer")                  {                      constant = root.FirstChild.FindTokenAndGetText();                      reg = root.LastChild.FindTokenAndGetText();                  }                  else                  {                      constant = root.LastChild.FindTokenAndGetText();                      reg = root.FirstChild.FindTokenAndGetText();                  }                  r.register = (OperandRegister)Enum.Parse(typeof(OperandRegister)' reg);                  if (constant.StartsWith("0x"))                       r.constant = Convert.ToUInt16(constant.Substring(2)' 16);                  else r.constant = Convert.ToUInt16(constant);              }              else if (root.Term.Name == "integer")              {                  r.semantics |= OperandSemantics.Constant;                  var constant = root.FindTokenAndGetText();                  if (constant.StartsWith("0x"))                      r.constant = Convert.ToUInt16(constant.Substring(2)' 16);                  else r.constant = Convert.ToUInt16(constant);              }                           else              {                  var reg = root.FindTokenAndGetText();                    try                  {                      r.register = (OperandRegister)Enum.Parse(typeof(OperandRegister)' reg);                  }                  catch (Exception)                  {                      r.semantics |= OperandSemantics.Label;                      r.label = new Intermediate.Label(reg);                  }              }
Magic Number,DCPUB.Ast.Assembly,OperandAstNode,C:\repos\Blecki_DCPUB\DCPUB\Ast\Assembly\OperandAstNode.cs,ParseOperand,The following statement contains a magic number: if (root.Term.Name == "offset")              {                  r.semantics |= OperandSemantics.Offset;                  string constant = "";                  string reg = "";                  if (root.FirstChild.Term.Name == "integer")                  {                      constant = root.FirstChild.FindTokenAndGetText();                      reg = root.LastChild.FindTokenAndGetText();                  }                  else                  {                      constant = root.LastChild.FindTokenAndGetText();                      reg = root.FirstChild.FindTokenAndGetText();                  }                  r.register = (OperandRegister)Enum.Parse(typeof(OperandRegister)' reg);                  if (constant.StartsWith("0x"))                       r.constant = Convert.ToUInt16(constant.Substring(2)' 16);                  else r.constant = Convert.ToUInt16(constant);              }              else if (root.Term.Name == "integer")              {                  r.semantics |= OperandSemantics.Constant;                  var constant = root.FindTokenAndGetText();                  if (constant.StartsWith("0x"))                      r.constant = Convert.ToUInt16(constant.Substring(2)' 16);                  else r.constant = Convert.ToUInt16(constant);              }                           else              {                  var reg = root.FindTokenAndGetText();                    try                  {                      r.register = (OperandRegister)Enum.Parse(typeof(OperandRegister)' reg);                  }                  catch (Exception)                  {                      r.semantics |= OperandSemantics.Label;                      r.label = new Intermediate.Label(reg);                  }              }
Magic Number,DCPUB.Ast.Assembly,OperandAstNode,C:\repos\Blecki_DCPUB\DCPUB\Ast\Assembly\OperandAstNode.cs,ParseOperand,The following statement contains a magic number: if (root.Term.Name == "offset")              {                  r.semantics |= OperandSemantics.Offset;                  string constant = "";                  string reg = "";                  if (root.FirstChild.Term.Name == "integer")                  {                      constant = root.FirstChild.FindTokenAndGetText();                      reg = root.LastChild.FindTokenAndGetText();                  }                  else                  {                      constant = root.LastChild.FindTokenAndGetText();                      reg = root.FirstChild.FindTokenAndGetText();                  }                  r.register = (OperandRegister)Enum.Parse(typeof(OperandRegister)' reg);                  if (constant.StartsWith("0x"))                       r.constant = Convert.ToUInt16(constant.Substring(2)' 16);                  else r.constant = Convert.ToUInt16(constant);              }              else if (root.Term.Name == "integer")              {                  r.semantics |= OperandSemantics.Constant;                  var constant = root.FindTokenAndGetText();                  if (constant.StartsWith("0x"))                      r.constant = Convert.ToUInt16(constant.Substring(2)' 16);                  else r.constant = Convert.ToUInt16(constant);              }                           else              {                  var reg = root.FindTokenAndGetText();                    try                  {                      r.register = (OperandRegister)Enum.Parse(typeof(OperandRegister)' reg);                  }                  catch (Exception)                  {                      r.semantics |= OperandSemantics.Label;                      r.label = new Intermediate.Label(reg);                  }              }
Magic Number,DCPUB.Ast.Assembly,OperandAstNode,C:\repos\Blecki_DCPUB\DCPUB\Ast\Assembly\OperandAstNode.cs,ParseOperand,The following statement contains a magic number: if (root.Term.Name == "offset")              {                  r.semantics |= OperandSemantics.Offset;                  string constant = "";                  string reg = "";                  if (root.FirstChild.Term.Name == "integer")                  {                      constant = root.FirstChild.FindTokenAndGetText();                      reg = root.LastChild.FindTokenAndGetText();                  }                  else                  {                      constant = root.LastChild.FindTokenAndGetText();                      reg = root.FirstChild.FindTokenAndGetText();                  }                  r.register = (OperandRegister)Enum.Parse(typeof(OperandRegister)' reg);                  if (constant.StartsWith("0x"))                       r.constant = Convert.ToUInt16(constant.Substring(2)' 16);                  else r.constant = Convert.ToUInt16(constant);              }              else if (root.Term.Name == "integer")              {                  r.semantics |= OperandSemantics.Constant;                  var constant = root.FindTokenAndGetText();                  if (constant.StartsWith("0x"))                      r.constant = Convert.ToUInt16(constant.Substring(2)' 16);                  else r.constant = Convert.ToUInt16(constant);              }                           else              {                  var reg = root.FindTokenAndGetText();                    try                  {                      r.register = (OperandRegister)Enum.Parse(typeof(OperandRegister)' reg);                  }                  catch (Exception)                  {                      r.semantics |= OperandSemantics.Label;                      r.label = new Intermediate.Label(reg);                  }              }
Magic Number,DCPUB.Intermediate.Peephole,Grammar,C:\repos\Blecki_DCPUB\DCPUB\Intermediate\Peephole\Grammar.cs,Grammar,The following statement contains a magic number: this.RegisterOperators(4' Associativity.Left' "/");
Magic Number,DCPUB.Intermediate.Peephole,Grammar,C:\repos\Blecki_DCPUB\DCPUB\Intermediate\Peephole\Grammar.cs,Grammar,The following statement contains a magic number: this.RegisterOperators(5' Associativity.Left' "&"' "|");
Magic Number,DCPUB.Intermediate.Peephole,Grammar,C:\repos\Blecki_DCPUB\DCPUB\Intermediate\Peephole\Grammar.cs,Grammar,The following statement contains a magic number: this.RegisterOperators(6' Associativity.Left' "{"' "}"' "["' "]"' "<"' ">");
Magic Number,DCPUB.Intermediate.Peephole,ReplacementRaw,C:\repos\Blecki_DCPUB\DCPUB\Intermediate\Peephole\Replacement.cs,Init,The following statement contains a magic number: rawValue = rawValue.Substring(1' rawValue.Length - 2);
Magic Number,DCPUB.Intermediate.Peephole,ReplacementInstruction,C:\repos\Blecki_DCPUB\DCPUB\Intermediate\Peephole\Replacement.cs,Init,The following statement contains a magic number: AddChild("secondOperand"' treeNode.ChildNodes[2]);
Magic Number,DCPUB.Intermediate.Peephole,WholeInstructionMatchRaw,C:\repos\Blecki_DCPUB\DCPUB\Intermediate\Peephole\WholeInstructionMatcher.cs,Init,The following statement contains a magic number: AddChild("secondOperand"' treeNode.ChildNodes[2]);
Magic Number,DCPUB.Intermediate.Peephole,WholeInstructionMatchRaw,C:\repos\Blecki_DCPUB\DCPUB\Intermediate\Peephole\WholeInstructionMatcher.cs,Match,The following statement contains a magic number: return (ChildNodes[0] as InstructionMatcher).Match(ins) &&                  (ChildNodes[1] as OperandMatcher).Match(ins.firstOperand' values) &&                  (ChildNodes[2] as OperandMatcher).Match(ins.secondOperand' values);
Magic Number,DCPUB.Intermediate.Peephole,OperandMatchRaw,C:\repos\Blecki_DCPUB\DCPUB\Intermediate\Peephole\OperandMatcher.cs,Init,The following statement contains a magic number: rawValue = rawValue.Substring(1' rawValue.Length - 2);
Magic Number,DCPUB.Ast,OffsetOfNode,C:\repos\Blecki_DCPUB\DCPUB\Ast\OffsetOfNode.cs,Init,The following statement contains a magic number: typeName = treeNode.ChildNodes[3].FindTokenAndGetText();
Magic Number,DCPUB.Ast,StringLiteralNode,C:\repos\Blecki_DCPUB\DCPUB\Ast\StringLiteralNode.cs,UnescapeString,The following statement contains a magic number: while (place < s.Length)              {                  if (s[place] == '\\')                  {                      if (place < s.Length - 1 && s[place + 1] == 'n')                          r += '\n';                      place += 2;                  }                  else                  {                      r += s[place];                      ++place;                  }              }
Magic Number,DCPUB.Ast,StringLiteralNode,C:\repos\Blecki_DCPUB\DCPUB\Ast\StringLiteralNode.cs,Init,The following statement contains a magic number: value = value.Substring(1' value.Length - 2);
Magic Number,DCPUB.Ast,MemberAccessNode,C:\repos\Blecki_DCPUB\DCPUB\Ast\MemberAccessNode.cs,Init,The following statement contains a magic number: memberName = treeNode.ChildNodes[2].FindTokenAndGetText();
Magic Number,DCPUB.Ast,MemberNode,C:\repos\Blecki_DCPUB\DCPUB\Ast\StructDeclarationNode.cs,Init,The following statement contains a magic number: if (treeNode.ChildNodes[2].FirstChild.ChildNodes.Count > 0)                  AddChild("array size"' treeNode.ChildNodes[2].FirstChild.FirstChild);
Magic Number,DCPUB.Ast,MemberNode,C:\repos\Blecki_DCPUB\DCPUB\Ast\StructDeclarationNode.cs,Init,The following statement contains a magic number: if (treeNode.ChildNodes[2].FirstChild.ChildNodes.Count > 0)                  AddChild("array size"' treeNode.ChildNodes[2].FirstChild.FirstChild);
Magic Number,DCPUB.Ast,StructDeclarationNode,C:\repos\Blecki_DCPUB\DCPUB\Ast\StructDeclarationNode.cs,Init,The following statement contains a magic number: foreach (var member in treeNode.ChildNodes[2].ChildNodes)                  AddChild("member"' member);
Magic Number,DCPUB.Ast,AssignmentNode,C:\repos\Blecki_DCPUB\DCPUB\Ast\AssignmentNode.cs,Init,The following statement contains a magic number: AddChild("RValue"' treeNode.ChildNodes[2]);
Magic Number,DCPUB.Ast,BinaryOperationNode,C:\repos\Blecki_DCPUB\DCPUB\Ast\BinaryOperationNode.cs,Init,The following statement contains a magic number: AddChild("Parameter"' treeNode.ChildNodes[2]);
Magic Number,DCPUB.Ast,WhileStatementNode,C:\repos\Blecki_DCPUB\DCPUB\Ast\WhileStatementNode.cs,Init,The following statement contains a magic number: AddChild("Block"' treeNode.ChildNodes[2]);
Magic Number,DCPUB.Ast,FunctionDeclarationNode,C:\repos\Blecki_DCPUB\DCPUB\Ast\FunctionDeclarationNode.cs,Init,The following statement contains a magic number: headerSpan = new Irony.Parsing.SourceSpan(this.Span.Location'                  treeNode.ChildNodes[2].Span.EndPosition - this.Span.Location.Position);
Magic Number,DCPUB.Ast,FunctionDeclarationNode,C:\repos\Blecki_DCPUB\DCPUB\Ast\FunctionDeclarationNode.cs,Init,The following statement contains a magic number: AddChild("Block"' treeNode.ChildNodes[4]);
Magic Number,DCPUB.Ast,FunctionDeclarationNode,C:\repos\Blecki_DCPUB\DCPUB\Ast\FunctionDeclarationNode.cs,Init,The following statement contains a magic number: foreach (var parameter in treeNode.ChildNodes[2].ChildNodes)              {                  var name = parameter.ChildNodes[0].FindTokenAndGetText();                  var type = parameter.ChildNodes[1].FindTokenAndGetText();                  parameters.Add(new Tuple<string' string>(name' type));              }
Magic Number,DCPUB.Ast,FunctionDeclarationNode,C:\repos\Blecki_DCPUB\DCPUB\Ast\FunctionDeclarationNode.cs,Init,The following statement contains a magic number: function.returnType = treeNode.ChildNodes[3].FindTokenAndGetText();
Magic Number,DCPUB.Ast,FunctionDeclarationNode,C:\repos\Blecki_DCPUB\DCPUB\Ast\FunctionDeclarationNode.cs,GatherSymbols,The following statement contains a magic number: for (int i = parameters.Count - 1; i >= 0; --i)              {                  var variable = new Model.Variable();                  variable.scope = function.localScope;                  variable.name = parameters[i].Item1;                  variable.typeSpecifier = parameters[i].Item2;                  if (variable.typeSpecifier == null) variable.typeSpecifier = "word";                  function.localScope.variables.Add(variable);                  variable.type = Model.VariableType.Local;                                        variable.stackOffset = i + 2; //Need an extra space for the return pointer and stored frame pointer                      //function.localScope.variablesOnStack += 1;                                }
Magic Number,DCPUB.Ast,FunctionDeclarationNode,C:\repos\Blecki_DCPUB\DCPUB\Ast\FunctionDeclarationNode.cs,CompileFunction,The following statement contains a magic number: if (!context.options.emit_ir)              {                  body.AssignRegisters(null);                  body.MarkUsedRealRegisters(registers);                  used = registers.Count((rs) => rs == true) - 2; //Why -2? Don't preserve A or J.                  body.CorrectVariableOffsets(-used);              }
Magic Number,DCPUB.Ast,FunctionDeclarationNode,C:\repos\Blecki_DCPUB\DCPUB\Ast\FunctionDeclarationNode.cs,CompileFunction,The following statement contains a magic number: for (int i = 1; i < 7; ++i)                  if (registers[i])                      r.AddInstruction(Intermediate.Instructions.SET' Operand("PUSH")' Operand((Model.Register)i));
Magic Number,DCPUB.Ast,FunctionDeclarationNode,C:\repos\Blecki_DCPUB\DCPUB\Ast\FunctionDeclarationNode.cs,CompileFunction,The following statement contains a magic number: for (int i = 6; i >= 1; --i)                  if (registers[i])                      r.AddInstruction(Intermediate.Instructions.SET' Operand((Model.Register)i)' Operand("POP"));
Magic Number,DCPUB.Ast,IfStatementNode,C:\repos\Blecki_DCPUB\DCPUB\Ast\IfStatementNode.cs,Init,The following statement contains a magic number: if (treeNode.Term.Name == "IfElse")              {                  AddChild("condition"' treeNode.ChildNodes[0].ChildNodes[1]);                  AddChild("then"' treeNode.ChildNodes[0].ChildNodes[2]);                  AddChild("else"' treeNode.ChildNodes[2]);                  headerSpan = new Irony.Parsing.SourceSpan(this.Span.Location'                      treeNode.ChildNodes[0].ChildNodes[1].Span.EndPosition - this.Span.Location.Position);              }              else              {                  AddChild("Expression"' treeNode.ChildNodes[1]);                  AddChild("Block"' treeNode.ChildNodes[2]);                  if (treeNode.ChildNodes.Count == 5) AddChild("Else"' treeNode.ChildNodes[4]);                  headerSpan = new Irony.Parsing.SourceSpan(this.Span.Location'                      treeNode.ChildNodes[1].Span.EndPosition - this.Span.Location.Position);              }
Magic Number,DCPUB.Ast,IfStatementNode,C:\repos\Blecki_DCPUB\DCPUB\Ast\IfStatementNode.cs,Init,The following statement contains a magic number: if (treeNode.Term.Name == "IfElse")              {                  AddChild("condition"' treeNode.ChildNodes[0].ChildNodes[1]);                  AddChild("then"' treeNode.ChildNodes[0].ChildNodes[2]);                  AddChild("else"' treeNode.ChildNodes[2]);                  headerSpan = new Irony.Parsing.SourceSpan(this.Span.Location'                      treeNode.ChildNodes[0].ChildNodes[1].Span.EndPosition - this.Span.Location.Position);              }              else              {                  AddChild("Expression"' treeNode.ChildNodes[1]);                  AddChild("Block"' treeNode.ChildNodes[2]);                  if (treeNode.ChildNodes.Count == 5) AddChild("Else"' treeNode.ChildNodes[4]);                  headerSpan = new Irony.Parsing.SourceSpan(this.Span.Location'                      treeNode.ChildNodes[1].Span.EndPosition - this.Span.Location.Position);              }
Magic Number,DCPUB.Ast,IfStatementNode,C:\repos\Blecki_DCPUB\DCPUB\Ast\IfStatementNode.cs,Init,The following statement contains a magic number: if (treeNode.Term.Name == "IfElse")              {                  AddChild("condition"' treeNode.ChildNodes[0].ChildNodes[1]);                  AddChild("then"' treeNode.ChildNodes[0].ChildNodes[2]);                  AddChild("else"' treeNode.ChildNodes[2]);                  headerSpan = new Irony.Parsing.SourceSpan(this.Span.Location'                      treeNode.ChildNodes[0].ChildNodes[1].Span.EndPosition - this.Span.Location.Position);              }              else              {                  AddChild("Expression"' treeNode.ChildNodes[1]);                  AddChild("Block"' treeNode.ChildNodes[2]);                  if (treeNode.ChildNodes.Count == 5) AddChild("Else"' treeNode.ChildNodes[4]);                  headerSpan = new Irony.Parsing.SourceSpan(this.Span.Location'                      treeNode.ChildNodes[1].Span.EndPosition - this.Span.Location.Position);              }
Magic Number,DCPUB.Ast,IfStatementNode,C:\repos\Blecki_DCPUB\DCPUB\Ast\IfStatementNode.cs,Init,The following statement contains a magic number: if (treeNode.Term.Name == "IfElse")              {                  AddChild("condition"' treeNode.ChildNodes[0].ChildNodes[1]);                  AddChild("then"' treeNode.ChildNodes[0].ChildNodes[2]);                  AddChild("else"' treeNode.ChildNodes[2]);                  headerSpan = new Irony.Parsing.SourceSpan(this.Span.Location'                      treeNode.ChildNodes[0].ChildNodes[1].Span.EndPosition - this.Span.Location.Position);              }              else              {                  AddChild("Expression"' treeNode.ChildNodes[1]);                  AddChild("Block"' treeNode.ChildNodes[2]);                  if (treeNode.ChildNodes.Count == 5) AddChild("Else"' treeNode.ChildNodes[4]);                  headerSpan = new Irony.Parsing.SourceSpan(this.Span.Location'                      treeNode.ChildNodes[1].Span.EndPosition - this.Span.Location.Position);              }
Magic Number,DCPUB.Ast,IfStatementNode,C:\repos\Blecki_DCPUB\DCPUB\Ast\IfStatementNode.cs,Init,The following statement contains a magic number: if (treeNode.Term.Name == "IfElse")              {                  AddChild("condition"' treeNode.ChildNodes[0].ChildNodes[1]);                  AddChild("then"' treeNode.ChildNodes[0].ChildNodes[2]);                  AddChild("else"' treeNode.ChildNodes[2]);                  headerSpan = new Irony.Parsing.SourceSpan(this.Span.Location'                      treeNode.ChildNodes[0].ChildNodes[1].Span.EndPosition - this.Span.Location.Position);              }              else              {                  AddChild("Expression"' treeNode.ChildNodes[1]);                  AddChild("Block"' treeNode.ChildNodes[2]);                  if (treeNode.ChildNodes.Count == 5) AddChild("Else"' treeNode.ChildNodes[4]);                  headerSpan = new Irony.Parsing.SourceSpan(this.Span.Location'                      treeNode.ChildNodes[1].Span.EndPosition - this.Span.Location.Position);              }
Magic Number,DCPUB.Ast,IfStatementNode,C:\repos\Blecki_DCPUB\DCPUB\Ast\IfStatementNode.cs,Init,The following statement contains a magic number: if (ChildNodes.Count == 3) ChildNodes[2] = BlockNode.Wrap(Child(2));
Magic Number,DCPUB.Ast,IfStatementNode,C:\repos\Blecki_DCPUB\DCPUB\Ast\IfStatementNode.cs,Init,The following statement contains a magic number: if (ChildNodes.Count == 3) ChildNodes[2] = BlockNode.Wrap(Child(2));
Magic Number,DCPUB.Ast,IfStatementNode,C:\repos\Blecki_DCPUB\DCPUB\Ast\IfStatementNode.cs,Init,The following statement contains a magic number: if (ChildNodes.Count == 3) ChildNodes[2] = BlockNode.Wrap(Child(2));
Magic Number,DCPUB.Ast,IfStatementNode,C:\repos\Blecki_DCPUB\DCPUB\Ast\IfStatementNode.cs,Emit,The following statement contains a magic number: switch (clauseOrder)              {                  case ClauseOrder.ConstantPass:                      r.AddChild(EmitBlock(context' scope' Child(1)));                      break;                  case ClauseOrder.ConstantFail:                      if (ChildNodes.Count == 3) r.AddChild(EmitBlock(context' scope' Child(2)));                      break;                  case ClauseOrder.FailFirst: //Only actual valid order.                      {                          var thenClauseAssembly = EmitBlock(context' scope' Child(1));                          Intermediate.IRNode elseClauseAssembly = ChildNodes.Count == 3 ? EmitBlock(context' scope' Child(2)) : null;                            if (thenClauseAssembly.InstructionCount() == 1 &&                              (elseClauseAssembly == null || elseClauseAssembly.InstructionCount() == 0))                          {                              r.AddChild(thenClauseAssembly);                          }                          else                          {                              var thenLabel = Intermediate.Label.Make("THEN");                              var endLabel = Intermediate.Label.Make("END");                                r.AddInstruction(Instructions.SET' Operand("PC")' Label(thenLabel));                              if (elseClauseAssembly != null) r.AddChild(elseClauseAssembly);                              r.AddInstruction(Instructions.SET' Operand("PC")' Label(endLabel));                              r.AddLabel(thenLabel);                                r.AddChild(thenClauseAssembly);                              r.AddLabel(endLabel);                          }                      }                      break;                  default:                      throw new InternalError("IF !FailFirst Not implemented");              }
Magic Number,DCPUB.Ast,IfStatementNode,C:\repos\Blecki_DCPUB\DCPUB\Ast\IfStatementNode.cs,Emit,The following statement contains a magic number: switch (clauseOrder)              {                  case ClauseOrder.ConstantPass:                      r.AddChild(EmitBlock(context' scope' Child(1)));                      break;                  case ClauseOrder.ConstantFail:                      if (ChildNodes.Count == 3) r.AddChild(EmitBlock(context' scope' Child(2)));                      break;                  case ClauseOrder.FailFirst: //Only actual valid order.                      {                          var thenClauseAssembly = EmitBlock(context' scope' Child(1));                          Intermediate.IRNode elseClauseAssembly = ChildNodes.Count == 3 ? EmitBlock(context' scope' Child(2)) : null;                            if (thenClauseAssembly.InstructionCount() == 1 &&                              (elseClauseAssembly == null || elseClauseAssembly.InstructionCount() == 0))                          {                              r.AddChild(thenClauseAssembly);                          }                          else                          {                              var thenLabel = Intermediate.Label.Make("THEN");                              var endLabel = Intermediate.Label.Make("END");                                r.AddInstruction(Instructions.SET' Operand("PC")' Label(thenLabel));                              if (elseClauseAssembly != null) r.AddChild(elseClauseAssembly);                              r.AddInstruction(Instructions.SET' Operand("PC")' Label(endLabel));                              r.AddLabel(thenLabel);                                r.AddChild(thenClauseAssembly);                              r.AddLabel(endLabel);                          }                      }                      break;                  default:                      throw new InternalError("IF !FailFirst Not implemented");              }
Magic Number,DCPUB.Ast,IfStatementNode,C:\repos\Blecki_DCPUB\DCPUB\Ast\IfStatementNode.cs,Emit,The following statement contains a magic number: switch (clauseOrder)              {                  case ClauseOrder.ConstantPass:                      r.AddChild(EmitBlock(context' scope' Child(1)));                      break;                  case ClauseOrder.ConstantFail:                      if (ChildNodes.Count == 3) r.AddChild(EmitBlock(context' scope' Child(2)));                      break;                  case ClauseOrder.FailFirst: //Only actual valid order.                      {                          var thenClauseAssembly = EmitBlock(context' scope' Child(1));                          Intermediate.IRNode elseClauseAssembly = ChildNodes.Count == 3 ? EmitBlock(context' scope' Child(2)) : null;                            if (thenClauseAssembly.InstructionCount() == 1 &&                              (elseClauseAssembly == null || elseClauseAssembly.InstructionCount() == 0))                          {                              r.AddChild(thenClauseAssembly);                          }                          else                          {                              var thenLabel = Intermediate.Label.Make("THEN");                              var endLabel = Intermediate.Label.Make("END");                                r.AddInstruction(Instructions.SET' Operand("PC")' Label(thenLabel));                              if (elseClauseAssembly != null) r.AddChild(elseClauseAssembly);                              r.AddInstruction(Instructions.SET' Operand("PC")' Label(endLabel));                              r.AddLabel(thenLabel);                                r.AddChild(thenClauseAssembly);                              r.AddLabel(endLabel);                          }                      }                      break;                  default:                      throw new InternalError("IF !FailFirst Not implemented");              }
Magic Number,DCPUB.Ast,IfStatementNode,C:\repos\Blecki_DCPUB\DCPUB\Ast\IfStatementNode.cs,Emit,The following statement contains a magic number: switch (clauseOrder)              {                  case ClauseOrder.ConstantPass:                      r.AddChild(EmitBlock(context' scope' Child(1)));                      break;                  case ClauseOrder.ConstantFail:                      if (ChildNodes.Count == 3) r.AddChild(EmitBlock(context' scope' Child(2)));                      break;                  case ClauseOrder.FailFirst: //Only actual valid order.                      {                          var thenClauseAssembly = EmitBlock(context' scope' Child(1));                          Intermediate.IRNode elseClauseAssembly = ChildNodes.Count == 3 ? EmitBlock(context' scope' Child(2)) : null;                            if (thenClauseAssembly.InstructionCount() == 1 &&                              (elseClauseAssembly == null || elseClauseAssembly.InstructionCount() == 0))                          {                              r.AddChild(thenClauseAssembly);                          }                          else                          {                              var thenLabel = Intermediate.Label.Make("THEN");                              var endLabel = Intermediate.Label.Make("END");                                r.AddInstruction(Instructions.SET' Operand("PC")' Label(thenLabel));                              if (elseClauseAssembly != null) r.AddChild(elseClauseAssembly);                              r.AddInstruction(Instructions.SET' Operand("PC")' Label(endLabel));                              r.AddLabel(thenLabel);                                r.AddChild(thenClauseAssembly);                              r.AddLabel(endLabel);                          }                      }                      break;                  default:                      throw new InternalError("IF !FailFirst Not implemented");              }
Magic Number,DCPUB.Ast,InlineASMNode,C:\repos\Blecki_DCPUB\DCPUB\Ast\InlineASMNode.cs,Init,The following statement contains a magic number: rawAssembly = treeNode.ChildNodes[2].FindTokenAndGetText();
Magic Number,DCPUB.Ast,InlineASMNode,C:\repos\Blecki_DCPUB\DCPUB\Ast\InlineASMNode.cs,Emit,The following statement contains a magic number: if (ParsedAssembly.HasErrors())              {                  foreach (var error in ParsedAssembly.ParserMessages)                      context.ReportError(new Irony.Parsing.SourceSpan(error.Location + this.Location' 20)' error.Message);                  return r;              }
Magic Number,DCPUB.Ast,NumberLiteralNode,C:\repos\Blecki_DCPUB\DCPUB\Ast\NumberLiteralNode.cs,Init,The following statement contains a magic number: if (AsString.StartsWith("0x"))              {                  Value = Convert.ToUInt16(AsString.Substring(2)' 16);                  ResultType = "word";              }              else if (AsString.StartsWith("0b"))              {                  if (AsString.Length > 18) Error = "Binary literals cannot be longer than 16 bits.";                  Value = Convert.ToUInt16(AsString.Substring(2' Math.Min(AsString.Length - 2' 16))' 2);                  ResultType = "word";              }              else if (AsString.StartsWith("'"))              {                  if (AsString.StartsWith("'\\"))                  {                      if (AsString[2] == 'n') Value = '\n';                      else Value = AsString[2];                  }                  else                      Value = AsString[1];                  ResultType = "word";              }              else              {                  Value = Convert.ToInt16(AsString);                  ResultType = "word";              }
Magic Number,DCPUB.Ast,NumberLiteralNode,C:\repos\Blecki_DCPUB\DCPUB\Ast\NumberLiteralNode.cs,Init,The following statement contains a magic number: if (AsString.StartsWith("0x"))              {                  Value = Convert.ToUInt16(AsString.Substring(2)' 16);                  ResultType = "word";              }              else if (AsString.StartsWith("0b"))              {                  if (AsString.Length > 18) Error = "Binary literals cannot be longer than 16 bits.";                  Value = Convert.ToUInt16(AsString.Substring(2' Math.Min(AsString.Length - 2' 16))' 2);                  ResultType = "word";              }              else if (AsString.StartsWith("'"))              {                  if (AsString.StartsWith("'\\"))                  {                      if (AsString[2] == 'n') Value = '\n';                      else Value = AsString[2];                  }                  else                      Value = AsString[1];                  ResultType = "word";              }              else              {                  Value = Convert.ToInt16(AsString);                  ResultType = "word";              }
Magic Number,DCPUB.Ast,NumberLiteralNode,C:\repos\Blecki_DCPUB\DCPUB\Ast\NumberLiteralNode.cs,Init,The following statement contains a magic number: if (AsString.StartsWith("0x"))              {                  Value = Convert.ToUInt16(AsString.Substring(2)' 16);                  ResultType = "word";              }              else if (AsString.StartsWith("0b"))              {                  if (AsString.Length > 18) Error = "Binary literals cannot be longer than 16 bits.";                  Value = Convert.ToUInt16(AsString.Substring(2' Math.Min(AsString.Length - 2' 16))' 2);                  ResultType = "word";              }              else if (AsString.StartsWith("'"))              {                  if (AsString.StartsWith("'\\"))                  {                      if (AsString[2] == 'n') Value = '\n';                      else Value = AsString[2];                  }                  else                      Value = AsString[1];                  ResultType = "word";              }              else              {                  Value = Convert.ToInt16(AsString);                  ResultType = "word";              }
Magic Number,DCPUB.Ast,NumberLiteralNode,C:\repos\Blecki_DCPUB\DCPUB\Ast\NumberLiteralNode.cs,Init,The following statement contains a magic number: if (AsString.StartsWith("0x"))              {                  Value = Convert.ToUInt16(AsString.Substring(2)' 16);                  ResultType = "word";              }              else if (AsString.StartsWith("0b"))              {                  if (AsString.Length > 18) Error = "Binary literals cannot be longer than 16 bits.";                  Value = Convert.ToUInt16(AsString.Substring(2' Math.Min(AsString.Length - 2' 16))' 2);                  ResultType = "word";              }              else if (AsString.StartsWith("'"))              {                  if (AsString.StartsWith("'\\"))                  {                      if (AsString[2] == 'n') Value = '\n';                      else Value = AsString[2];                  }                  else                      Value = AsString[1];                  ResultType = "word";              }              else              {                  Value = Convert.ToInt16(AsString);                  ResultType = "word";              }
Magic Number,DCPUB.Ast,NumberLiteralNode,C:\repos\Blecki_DCPUB\DCPUB\Ast\NumberLiteralNode.cs,Init,The following statement contains a magic number: if (AsString.StartsWith("0x"))              {                  Value = Convert.ToUInt16(AsString.Substring(2)' 16);                  ResultType = "word";              }              else if (AsString.StartsWith("0b"))              {                  if (AsString.Length > 18) Error = "Binary literals cannot be longer than 16 bits.";                  Value = Convert.ToUInt16(AsString.Substring(2' Math.Min(AsString.Length - 2' 16))' 2);                  ResultType = "word";              }              else if (AsString.StartsWith("'"))              {                  if (AsString.StartsWith("'\\"))                  {                      if (AsString[2] == 'n') Value = '\n';                      else Value = AsString[2];                  }                  else                      Value = AsString[1];                  ResultType = "word";              }              else              {                  Value = Convert.ToInt16(AsString);                  ResultType = "word";              }
Magic Number,DCPUB.Ast,NumberLiteralNode,C:\repos\Blecki_DCPUB\DCPUB\Ast\NumberLiteralNode.cs,Init,The following statement contains a magic number: if (AsString.StartsWith("0x"))              {                  Value = Convert.ToUInt16(AsString.Substring(2)' 16);                  ResultType = "word";              }              else if (AsString.StartsWith("0b"))              {                  if (AsString.Length > 18) Error = "Binary literals cannot be longer than 16 bits.";                  Value = Convert.ToUInt16(AsString.Substring(2' Math.Min(AsString.Length - 2' 16))' 2);                  ResultType = "word";              }              else if (AsString.StartsWith("'"))              {                  if (AsString.StartsWith("'\\"))                  {                      if (AsString[2] == 'n') Value = '\n';                      else Value = AsString[2];                  }                  else                      Value = AsString[1];                  ResultType = "word";              }              else              {                  Value = Convert.ToInt16(AsString);                  ResultType = "word";              }
Magic Number,DCPUB.Ast,NumberLiteralNode,C:\repos\Blecki_DCPUB\DCPUB\Ast\NumberLiteralNode.cs,Init,The following statement contains a magic number: if (AsString.StartsWith("0x"))              {                  Value = Convert.ToUInt16(AsString.Substring(2)' 16);                  ResultType = "word";              }              else if (AsString.StartsWith("0b"))              {                  if (AsString.Length > 18) Error = "Binary literals cannot be longer than 16 bits.";                  Value = Convert.ToUInt16(AsString.Substring(2' Math.Min(AsString.Length - 2' 16))' 2);                  ResultType = "word";              }              else if (AsString.StartsWith("'"))              {                  if (AsString.StartsWith("'\\"))                  {                      if (AsString[2] == 'n') Value = '\n';                      else Value = AsString[2];                  }                  else                      Value = AsString[1];                  ResultType = "word";              }              else              {                  Value = Convert.ToInt16(AsString);                  ResultType = "word";              }
Magic Number,DCPUB.Ast,NumberLiteralNode,C:\repos\Blecki_DCPUB\DCPUB\Ast\NumberLiteralNode.cs,Init,The following statement contains a magic number: if (AsString.StartsWith("0x"))              {                  Value = Convert.ToUInt16(AsString.Substring(2)' 16);                  ResultType = "word";              }              else if (AsString.StartsWith("0b"))              {                  if (AsString.Length > 18) Error = "Binary literals cannot be longer than 16 bits.";                  Value = Convert.ToUInt16(AsString.Substring(2' Math.Min(AsString.Length - 2' 16))' 2);                  ResultType = "word";              }              else if (AsString.StartsWith("'"))              {                  if (AsString.StartsWith("'\\"))                  {                      if (AsString[2] == 'n') Value = '\n';                      else Value = AsString[2];                  }                  else                      Value = AsString[1];                  ResultType = "word";              }              else              {                  Value = Convert.ToInt16(AsString);                  ResultType = "word";              }
Magic Number,DCPUB.Ast,NumberLiteralNode,C:\repos\Blecki_DCPUB\DCPUB\Ast\NumberLiteralNode.cs,Init,The following statement contains a magic number: if (AsString.StartsWith("0x"))              {                  Value = Convert.ToUInt16(AsString.Substring(2)' 16);                  ResultType = "word";              }              else if (AsString.StartsWith("0b"))              {                  if (AsString.Length > 18) Error = "Binary literals cannot be longer than 16 bits.";                  Value = Convert.ToUInt16(AsString.Substring(2' Math.Min(AsString.Length - 2' 16))' 2);                  ResultType = "word";              }              else if (AsString.StartsWith("'"))              {                  if (AsString.StartsWith("'\\"))                  {                      if (AsString[2] == 'n') Value = '\n';                      else Value = AsString[2];                  }                  else                      Value = AsString[1];                  ResultType = "word";              }              else              {                  Value = Convert.ToInt16(AsString);                  ResultType = "word";              }
Magic Number,DCPUB.Ast,VariableDeclarationNode,C:\repos\Blecki_DCPUB\DCPUB\Ast\VariableDeclarationNode.cs,Init,The following statement contains a magic number: if (treeNode.ChildNodes[4].FirstChild.ChildNodes.Count > 0)              {                  AddChild("Value"' treeNode.ChildNodes[4].FirstChild.LastChild.FirstChild);                  hasInitialValue = true;              }              else              {                  var newNode = new NumberLiteralNode();                  newNode.Value = 0;                  ChildNodes.Add(newNode);              }
Magic Number,DCPUB.Ast,VariableDeclarationNode,C:\repos\Blecki_DCPUB\DCPUB\Ast\VariableDeclarationNode.cs,Init,The following statement contains a magic number: if (treeNode.ChildNodes[4].FirstChild.ChildNodes.Count > 0)              {                  AddChild("Value"' treeNode.ChildNodes[4].FirstChild.LastChild.FirstChild);                  hasInitialValue = true;              }              else              {                  var newNode = new NumberLiteralNode();                  newNode.Value = 0;                  ChildNodes.Add(newNode);              }
Magic Number,DCPUB.Ast,VariableDeclarationNode,C:\repos\Blecki_DCPUB\DCPUB\Ast\VariableDeclarationNode.cs,Init,The following statement contains a magic number: if (treeNode.ChildNodes[3].FirstChild.ChildNodes.Count > 0)              {                  AddChild("Size"' treeNode.ChildNodes[3].FirstChild.FirstChild);                  isArray = true;              }
Magic Number,DCPUB.Ast,VariableDeclarationNode,C:\repos\Blecki_DCPUB\DCPUB\Ast\VariableDeclarationNode.cs,Init,The following statement contains a magic number: if (treeNode.ChildNodes[3].FirstChild.ChildNodes.Count > 0)              {                  AddChild("Size"' treeNode.ChildNodes[3].FirstChild.FirstChild);                  isArray = true;              }
Magic Number,DCPUB.Ast,VariableDeclarationNode,C:\repos\Blecki_DCPUB\DCPUB\Ast\VariableDeclarationNode.cs,Init,The following statement contains a magic number: variable.typeSpecifier = treeNode.ChildNodes[2].FindTokenAndGetText();
Missing Default,DCPUB.Testing,Emulator,C:\repos\Blecki_DCPUB\DCPUB\Testing\Emulator.cs,Step,The following switch statement is missing a default case: switch (ins)              {                  case Intermediate.Instructions.SET: //0x01 | SET b' a | sets b to a                      AssignToOperand(operandB' value' false);                      break;                  case Intermediate.Instructions.ADD: //ADD b' a | sets b to b+a' sets EX to 0x0001 if there's an overflow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) + value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.SUB: //SUB b' a | sets b to b-a' sets EX to 0xffff if there's an underflow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) - value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MUL: //MUL b' a | sets b to b*a' sets EX to ((b*a)>>16)&0xffff (treats b' a as unsigned)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) * value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MLI: //MLI b' a | like MUL' but treat b' a as signed                      intermediate = (UInt32)((short)GetOperandValue(operandB' OperandPlace.B) * (short)value);                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.DIV: //DIV b' a | sets b to b/a' sets EX to ((b<<16)/a)&0xffff. if a==0' sets b and EX to 0 instead. (treats b' a as unsigned)                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      intermediate = value == 0 ? 0 : (UInt32)bValue / value;                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.DVI: //DVI b' a | like DIV' but treat b' a as signed. Rounds towards 0                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      intermediate = value == 0 ? 0 : (UInt32)((short)bValue / (short)value);                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.MOD: //MOD b' a | sets b to b%a. if a==0' sets b to 0 instead.                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      AssignToOperand(operandB' value == 0 ? (ushort)0 : (ushort)(bValue % value)' true);                      break;                  case Intermediate.Instructions.MDI: //MDI b' a | like MOD' but treat b' a as signed. (MDI -7' 16 == -7)                      bValue = GetOperandValue(operandB' OperandPlace.B' false);                      AssignToOperand(operandB' value == 0 ? (ushort)0 : (ushort)((short)bValue % (short)value)' true);                      break;                  case Intermediate.Instructions.AND: //AND b' a | sets b to b&a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) & value)' true);                      break;                  case Intermediate.Instructions.BOR: //BOR b' a | sets b to b|a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) | value)' true);                      break;                  case Intermediate.Instructions.XOR: //XOR b' a | sets b to b^a                      AssignToOperand(operandB' (ushort)(GetOperandValue(operandB' OperandPlace.B) ^ value));                      break;                  case Intermediate.Instructions.SHR: //SHR b' a | sets b to b>>>a' sets EX to ((b<<16)>>a)&0xffff (logical shift)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)(intermediate >> value)' true);                      AssignToEx((ushort)(intermediate << 16 >> value));                      break;                  case Intermediate.Instructions.ASR: //ASR b' a | sets b to b>>a' sets EX to ((b<<16)>>>a)&0xffff (arithmetic shift) (treats b as signed)                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)((int)intermediate >> value)' true);                      AssignToEx((ushort)((int)intermediate << 16 >> value));                      break;                  case Intermediate.Instructions.SHL: //SHL b' a | sets b to b<<a' sets EX to ((b<<a)>>16)&0xffff                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B);                      AssignToOperand(operandB' (ushort)(intermediate << value)' true);                      AssignToEx((ushort)(intermediate << value >> 16));                      break;                  case Intermediate.Instructions.IFB: //IFB b' a | performs next instruction only if (b&a)!=0                      SkipIf = (GetOperandValue(operandB' OperandPlace.B) & value) != 0;                      break;                  case Intermediate.Instructions.IFC: //IFC b' a | performs next instruction only if (b&a)==0                      SkipIf = (GetOperandValue(operandB' OperandPlace.B) & value) == 0;                      break;                  case Intermediate.Instructions.IFE: //IFE b' a | performs next instruction only if b==a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) == value;                      break;                  case Intermediate.Instructions.IFN: //IFB b' a | performs next instruction only if b!=a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) != value;                      break;                  case Intermediate.Instructions.IFG: //IFG b' a | performs next instruction only if b>a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) > value;                      break;                  case Intermediate.Instructions.IFA: //IFA b' a | performs next instruction only if b>a (signed)                      SkipIf = (int)GetOperandValue(operandB' OperandPlace.B) > (int)value;                      break;                  case Intermediate.Instructions.IFL: //IFL b' a | performs next instruction only if b<a                       SkipIf = GetOperandValue(operandB' OperandPlace.B) < value;                      break;                  case Intermediate.Instructions.IFU: //IFU b' a | performs next instruction only if b<a (signed)                      SkipIf = (int)GetOperandValue(operandB' OperandPlace.B) < (int)value;                      break;                  case Intermediate.Instructions.ADX: //ADX b' a | sets b to b+a+EX' sets EX to 0x0001 if there is an over-flow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) + value + registers[(int)Registers.EX];                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.SBX: //SBX b' a | sets b to b-a+EX' sets EX to 0xFFFF if there is an under-flow' 0x0 otherwise                      intermediate = (UInt32)GetOperandValue(operandB' OperandPlace.B) - value + registers[(int)Registers.EX];                      AssignToOperand(operandB' (ushort)intermediate' true);                      AssignToEx(intermediate >> 16);                      break;                  case Intermediate.Instructions.STI: //STI b' a | sets b to a' then increases I and J by 1                      AssignToOperand(operandB' value' false);                      registers[(int)Registers.I] += 1;                      registers[(int)Registers.J] += 1;                      break;                  case Intermediate.Instructions.STD: //STI b' a | sets b to a' then decreases I and J by 1                      AssignToOperand(operandB' value' false);                      registers[(int)Registers.I] -= 1;                      registers[(int)Registers.J] -= 1;                      break;                    case Intermediate.Instructions.JSR: //pushes the address of the next instruction to the stack' then sets PC to a                      ram[(ushort)(registers[(int)Registers.SP] - 1)] = registers[(int)Registers.PC];                      registers[(int)Registers.SP] -= 1;                      registers[(int)Registers.PC] = value;                      break;                  case Intermediate.Instructions.HLT:                      throw new Halt();                    case Intermediate.Instructions.INT: //INT a | triggers a software interrupt with message a                      TriggerInterrupt(value);                      break;                  case Intermediate.Instructions.IAG: //IAG a | sets a to IA                       AssignToOperand(operandA' registers[(int)Registers.IA]' true);                      break;                  case Intermediate.Instructions.IAS: //IAS a | sets IA to A                       registers[(int)Registers.IA] = value;                      break;                  case Intermediate.Instructions.RFI: //RFI a | disables interrupt queueing' pops A from the stack' then pops PC from the stack                      protectInterruptQueue.WaitOne();                      interruptQueueEnabled = false;                      registers[(int)Registers.A] = ram[(ushort)(registers[(int)Registers.SP])];                      registers[(int)Registers.PC] = ram[(ushort)(registers[(int)Registers.SP] + 1)];                      registers[(int)Registers.SP] += 2;                      break;                  case Intermediate.Instructions.IAQ: //IAQ a | if a is nonzero' interrupts will be added to the queue                      interruptQueueEnabled = value != 0; //instead of triggered. if a is zero' interrupts will be                      break;                              //triggered as normal again                    case Intermediate.Instructions.HWN: //HWN a | sets a to number of connected hardware devices                      AssignToOperand(operandA' (ushort)devices.Count' true);                      break;                  case Intermediate.Instructions.HWQ: //HWQ a | sets A' B' C' X' Y registers to information about hardware a                       registers[(int)Registers.A] = (ushort)(devices[value].HardwareID & 0xFFFF); //A+(B<<16) is a 32 bit word identifying the hardware id                      registers[(int)Registers.B] = (ushort)((devices[value].HardwareID >> 16) & 0xFFFF);                      registers[(int)Registers.C] = devices[value].Version; //C is the hardware version                      registers[(int)Registers.X] = (ushort)(devices[value].ManufacturerID & 0xFFFF); //X+(Y<<16) is a 32 bit word identifying the manufacturer                      registers[(int)Registers.Y] = (ushort)((devices[value].ManufacturerID >> 16) & 0xFFFF);                      break;                  case Intermediate.Instructions.HWI: //HWI a | sends an interrupt to hardware a                      devices[value].OnInterrupt(this);                      break;              }
Missing Default,DCPUB.Ast,Target,C:\repos\Blecki_DCPUB\DCPUB\Ast\Target.cs,GetOperand,The following switch statement is missing a default case: switch (usage)                  {                      case TargetUsage.Peek: return CompilableNode.Operand("PEEK"' semantics' offset);                      case TargetUsage.Push: return CompilableNode.Operand("PUSH"' semantics' offset);                      case TargetUsage.Pop: return CompilableNode.Operand("POP"' semantics' offset);                  }
