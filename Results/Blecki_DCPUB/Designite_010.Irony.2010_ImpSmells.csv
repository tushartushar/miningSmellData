Implementation smell,Namespace,Class,File,Method,Description
Long Method,Irony.Interpreter,LanguageRuntime,C:\repos\Blecki_DCPUB\Irony\Interpreter\LanguageRuntime_Init.cs,InitOperatorImplementations,The method has 166 lines of code.
Complex Method,Irony.Parsing,RegExLiteral,C:\repos\Blecki_DCPUB\Irony\Parsing\Terminals\RegExLiteral.cs,TryMatch,Cyclomatic complexity of the method is 10
Complex Method,Irony.Parsing,ParserDataPrinter,C:\repos\Blecki_DCPUB\Irony\Parsing\Diagnostics\ParserDataPrinter.cs,PrintStateList,Cyclomatic complexity of the method is 13
Complex Method,Irony.Parsing,CompoundTerminalBase,C:\repos\Blecki_DCPUB\Irony\Parsing\Terminals\CompoundTerminalBase.cs,TryMatch,Cyclomatic complexity of the method is 8
Complex Method,Irony.Parsing,NumberLiteral,C:\repos\Blecki_DCPUB\Irony\Parsing\Terminals\NumberLiteral.cs,ReadBody,Cyclomatic complexity of the method is 13
Complex Method,Irony.Parsing,StringLiteral,C:\repos\Blecki_DCPUB\Irony\Parsing\Terminals\StringLiteral.cs,Init,Cyclomatic complexity of the method is 11
Complex Method,Irony.Parsing,StringLiteral,C:\repos\Blecki_DCPUB\Irony\Parsing\Terminals\StringLiteral.cs,CompleteReadBody,Cyclomatic complexity of the method is 9
Complex Method,Irony.Parsing,StringLiteral,C:\repos\Blecki_DCPUB\Irony\Parsing\Terminals\StringLiteral.cs,ConvertValue,Cyclomatic complexity of the method is 9
Complex Method,Irony.Parsing,IdentifierTerminal,C:\repos\Blecki_DCPUB\Irony\Parsing\Terminals\IdentifierTerminal.cs,ReadBody,Cyclomatic complexity of the method is 9
Complex Method,Irony.Parsing,CodeOutlineFilter,C:\repos\Blecki_DCPUB\Irony\Parsing\TokenFilters\CodeOutlineFilter.cs,ProcessToken,Cyclomatic complexity of the method is 10
Complex Method,Irony.Interpreter.Ast,StringTemplateNode,C:\repos\Blecki_DCPUB\Irony\Interpreter\Ast\PrimitiveNodes\StringTemplateNode.cs,ParseSegments,Cyclomatic complexity of the method is 8
Complex Method,Irony.Interpreter,LanguageRuntime,C:\repos\Blecki_DCPUB\Irony\Interpreter\LanguageRuntime_Init.cs,InitTypeConverters,Cyclomatic complexity of the method is 8
Complex Method,Irony.Interpreter,LanguageRuntime,C:\repos\Blecki_DCPUB\Irony\Interpreter\LanguageRuntime_Init.cs,GetBaseTypeForExpression,Cyclomatic complexity of the method is 15
Complex Method,Irony.Parsing.Construction,GrammarDataBuilder,C:\repos\Blecki_DCPUB\Irony\Parsing\Data\Construction\GrammarDataBuilder.cs,CollectTermsRecursive,Cyclomatic complexity of the method is 10
Complex Method,Irony.Parsing.Construction,GrammarDataBuilder,C:\repos\Blecki_DCPUB\Irony\Parsing\Data\Construction\GrammarDataBuilder.cs,InitTermLists,Cyclomatic complexity of the method is 8
Complex Method,Irony.Parsing.Construction,GrammarDataBuilder,C:\repos\Blecki_DCPUB\Irony\Parsing\Data\Construction\GrammarDataBuilder.cs,ValidateGrammar,Cyclomatic complexity of the method is 12
Complex Method,Irony.Parsing.Construction,ParserStateData,C:\repos\Blecki_DCPUB\Irony\Parsing\Data\Construction\ParserDataBuilder_HelperClasses.cs,AddItem,Cyclomatic complexity of the method is 9
Complex Method,Irony.Parsing.Construction,ParserDataBuilder,C:\repos\Blecki_DCPUB\Irony\Parsing\Data\Construction\ParserDataBuilder.cs,CreateLookbackTransitions,Cyclomatic complexity of the method is 9
Complex Method,Irony.Parsing.Construction,ParserDataBuilder,C:\repos\Blecki_DCPUB\Irony\Parsing\Data\Construction\ParserDataBuilder.cs,ComputeAndResolveConflicts,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.Scripting.Math,BigInteger,C:\repos\Blecki_DCPUB\Irony\Microsoft\BigInteger.cs,Create,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.Scripting.Math,BigInteger,C:\repos\Blecki_DCPUB\Irony\Microsoft\BigInteger.cs,sub,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Scripting.Math,BigInteger,C:\repos\Blecki_DCPUB\Irony\Microsoft\BigInteger.cs,ToByteArray,Cyclomatic complexity of the method is 8
Long Parameter List,Irony.Parsing,ParserTraceEntry,C:\repos\Blecki_DCPUB\Irony\Parsing\Diagnostics\ParserTrace.cs,ParserTraceEntry,The method has 5 parameters. Parameters: state' stackTop' input' message' isError
Long Parameter List,Irony.Parsing,WikiBlockTerminal,C:\repos\Blecki_DCPUB\Irony\Parsing\Terminals\WikiTerminals\WikiBlockTerminal.cs,WikiBlockTerminal,The method has 5 parameters. Parameters: name' blockType' openTag' closeTag' htmlElementName
Long Parameter List,Irony.Parsing,WikiTagTerminal,C:\repos\Blecki_DCPUB\Irony\Parsing\Terminals\WikiTerminals\WikiTagTerminal.cs,WikiTagTerminal,The method has 5 parameters. Parameters: name' termType' openTag' closeTag' htmlElementName
Long Parameter List,Irony.Parsing,WikiTerminalBase,C:\repos\Blecki_DCPUB\Irony\Parsing\Terminals\WikiTerminals\_WikiTerminalBase.cs,WikiTerminalBase,The method has 5 parameters. Parameters: name' termType' openTag' closeTag' htmlElementName
Long Parameter List,Irony.Parsing,ParseTreeNode,C:\repos\Blecki_DCPUB\Irony\Parsing\Parser\ParseTree.cs,ParseTreeNode,The method has 5 parameters. Parameters: node' term' precedence' associativity' span
Long Parameter List,Irony.Parsing,SourceStream,C:\repos\Blecki_DCPUB\Irony\Parsing\Scanner\SourceStream.cs,CountCharsInText,The method has 6 parameters. Parameters: text' chars' from' until' count' lastCharOccurrencePosition
Long Parameter List,Irony.Interpreter,OperatorImplementation,C:\repos\Blecki_DCPUB\Irony\Interpreter\DynamicCallDispatcher.cs,OperatorImplementation,The method has 6 parameters. Parameters: key' baseType' baseMethod' arg1Converter' arg2Converter' resultConverter
Long Parameter List,Microsoft.Scripting.Math,BigInteger,C:\repos\Blecki_DCPUB\Irony\Microsoft\BigInteger.cs,TestDivisionStep,The method has 5 parameters. Parameters: un' vn' q' u' v
Long Parameter List,Microsoft.Scripting.Math,BigInteger,C:\repos\Blecki_DCPUB\Irony\Microsoft\BigInteger.cs,AppendRadix,The method has 5 parameters. Parameters: rem' radix' tmp' buf' leadingZeros
Long Statement,Irony.Parsing,CoreParser,C:\repos\Blecki_DCPUB\Irony\Parsing\Parser\CoreParser_ErrorHandling.cs,FindErrorShiftActionInStack,The length of the statement  "        if (Context.CurrentParserState.Actions.TryGetValue(_grammar.SyntaxError' out errorShiftAction) && errorShiftAction.ActionType == ParserActionType.Shift) " is 152.
Long Statement,Irony.Parsing,CoreParser,C:\repos\Blecki_DCPUB\Irony\Parsing\Parser\CoreParser_ErrorHandling.cs,ComputeGroupedExpectedSetForState,The length of the statement  "        if(group.GroupType == TermReportGroupType.Normal || group.GroupType == TermReportGroupType.Operator && terms.Overlaps(group.Terminals)) { " is 137.
Long Statement,Irony.Parsing,CoreParser,C:\repos\Blecki_DCPUB\Irony\Parsing\Parser\CoreParser_ErrorHandling.cs,ReduceListContainer,The length of the statement  "        var listNode = Context.ParserStack[firstChildIndex]; //get the transient list with all members - it is the first child node " is 123.
Long Statement,Irony.Parsing,CoreParser,C:\repos\Blecki_DCPUB\Irony\Parsing\Parser\CoreParser_ErrorHandling.cs,CheckCreateAstNode,The length of the statement  "        Context.AddParserMessage(ParserErrorLevel.Error' parseNode.Span.Location' Resources.ErrFailedCreateNode' parseNode.Term.Name' ex.Message);  " is 138.
Long Statement,Irony.Parsing,QuotedValueLiteral,C:\repos\Blecki_DCPUB\Irony\Parsing\Terminals\QuotedValueLiteral.cs,ReadBody,The length of the statement  "      if (!source.MatchSymbol(StartSymbol' !Grammar.CaseSensitive)) return null; //this will result in null returned from TryMatch' no token " is 134.
Long Statement,Irony.Parsing,RegExLiteral,C:\repos\Blecki_DCPUB\Irony\Parsing\Terminals\RegExLiteral.cs,TryMatch,The length of the statement  "          return source.CreateErrorToken(Resources.ErrDupRegexSwitch' source.PreviewChar); // "Duplicate switch '{0}' for regular expression"  " is 131.
Long Statement,Irony.Parsing,ParserAction,C:\repos\Blecki_DCPUB\Irony\Parsing\Data\ParserData.cs,ToString,The length of the statement  "        case ParserActionType.Operator: return string.Format(Resources.LabelActionOp' NewState.Name' ReduceProduction.ToStringQuoted()); " is 128.
Long Statement,Irony.Parsing,ParseTree,C:\repos\Blecki_DCPUB\Irony\Parsing\Parser\ParseTree.cs,CopyMessages,The length of the statement  "        this.ParserMessages.Add(new ParserMessage(other.Level' baseLocation + other.Location' messagePrefix + other.Message' other.ParserState));  " is 137.
Long Statement,Irony.Parsing,ParsingContext,C:\repos\Blecki_DCPUB\Irony\Parsing\Parser\ParsingContext.cs,GetExpectedTermSet,The length of the statement  "        CurrentParserState.ReportedExpectedSet = CoreParser.ComputeGroupedExpectedSetForState(Language.Grammar' CurrentParserState); " is 124.
Long Statement,Irony.Parsing,SourceStream,C:\repos\Blecki_DCPUB\Irony\Parsing\Scanner\SourceStream.cs,MoveLocationToPreviewPosition,The length of the statement  "      CountCharsInText(Text' _scannerData.LineTerminatorsArray' lineStart + 1' PreviewPosition - 1' ref nlCount' ref lineStart); " is 122.
Long Statement,Irony.Parsing,NumberLiteral,C:\repos\Blecki_DCPUB\Irony\Parsing\Terminals\NumberLiteral.cs,InvokeValidateToken,The length of the statement  "          context.CurrentToken = context.Source.CreateErrorToken(Resources.ErrNoLetterAfterNum); // "Number cannot be followed by a letter."  " is 130.
Long Statement,Irony.Parsing,NumberLiteral,C:\repos\Blecki_DCPUB\Irony\Parsing\Terminals\NumberLiteral.cs,ConvertValue,The length of the statement  "              TryConvertToLong(details' typeCode == TypeCode.UInt64); //try to convert to Long/Ulong and place the result into details.Value field; " is 133.
Long Statement,Irony.Parsing,NumberLiteral,C:\repos\Blecki_DCPUB\Irony\Parsing\Terminals\NumberLiteral.cs,QuickConvertToInt32,The length of the statement  "      if (radix == 10 && details.Body.Length > 10) return false;    //10 digits is maximum for int32; int32.MaxValue = 2 147 483 647 " is 126.
Long Statement,Irony.Parsing,NumberLiteral,C:\repos\Blecki_DCPUB\Irony\Parsing\Terminals\NumberLiteral.cs,QuickConvertToDouble,The length of the statement  "      if (!double.TryParse(details.Body' NumberStyles.AllowDecimalPoint' CultureInfo.InvariantCulture' out dvalue)) return false; " is 123.
Long Statement,Irony.Parsing,StringLiteral,C:\repos\Blecki_DCPUB\Irony\Parsing\Terminals\StringLiteral.cs,Init,The length of the statement  "        grammarData.Language.Errors.Add(GrammarErrorLevel.Error' null' Resources.ErrInvStrDef' this.Name); //"Error in string literal [{0}]: No start/end symbols specified." " is 165.
Long Statement,Irony.Parsing,StringLiteral,C:\repos\Blecki_DCPUB\Irony\Parsing\Terminals\StringLiteral.cs,Init,The length of the statement  "          grammarData.Language.Errors.Add(GrammarErrorLevel.Error' null' Resources.ErrTemplNoSettings' this.Name); //"Error in string literal [{0}]: IsTemplate flag is set' but TemplateSettings is not provided." " is 201.
Long Statement,Irony.Parsing,StringLiteral,C:\repos\Blecki_DCPUB\Irony\Parsing\Terminals\StringLiteral.cs,HandleSpecialEscape,The length of the statement  "              details.Error = string.Format(Resources.ErrBadUnEscape' segment.Substring(len + 1)' len);// "Invalid unicode escape ({0})' expected {1} hex digits." " is 148.
Long Statement,Irony.Parsing,KeyTerm,C:\repos\Blecki_DCPUB\Irony\Parsing\Terminals\KeyTerm.cs,Init,The length of the statement  "      // Priority - determines the order in which multiple terminals try to match input for a given current char in the input. " is 120.
Long Statement,Irony.Parsing,KeyTerm,C:\repos\Blecki_DCPUB\Irony\Parsing\Terminals\KeyTerm.cs,Init,The length of the statement  "      // For a given input char the scanner looks up the collection of terminals that may match this input symbol. It is the order " is 124.
Long Statement,Irony.Parsing,KeyTerm,C:\repos\Blecki_DCPUB\Irony\Parsing\Terminals\KeyTerm.cs,Init,The length of the statement  "      // in this collection that is determined by Priority value - the higher the priority' the earlier the terminal gets a chance  " is 124.
Long Statement,Irony.Parsing,KeyTerm,C:\repos\Blecki_DCPUB\Irony\Parsing\Terminals\KeyTerm.cs,Init,The length of the statement  "      // Keywords found in grammar by default have lowest priority to allow other terminals (like identifiers)to check the input first. " is 129.
Long Statement,Irony.Parsing,KeyTerm,C:\repos\Blecki_DCPUB\Irony\Parsing\Terminals\KeyTerm.cs,Init,The length of the statement  "      // Additionally' longer symbols have higher priority' so symbols like "+=" should have higher priority value than "+" symbol.  " is 125.
Long Statement,Irony.Parsing,KeyTerm,C:\repos\Blecki_DCPUB\Irony\Parsing\Terminals\KeyTerm.cs,TokenToString,The length of the statement  "      var keyw = FlagIsSet(TermFlags.IsKeyword)? Resources.LabelKeyword : Resources.LabelKeySymbol ; //"(Keyword)" : "(Key symbol)" " is 125.
Long Statement,Irony.Interpreter.Ast,AssignmentNode,C:\repos\Blecki_DCPUB\Irony\Interpreter\Ast\Statements\AssignmentNode.cs,Init,The length of the statement  "      //There maybe an "=" sign in the middle' or not - if it is marked as punctuation; so we just take the last node in child list " is 125.
Long Statement,Irony.Interpreter.Ast,StringTemplateNode,C:\repos\Blecki_DCPUB\Irony\Interpreter\Ast\PrimitiveNodes\StringTemplateNode.cs,ParseSegments,The length of the statement  "      // As we go along the "value text" (that has all escapes done)' we track the position in raw token text  in the variable exprPosInTokenText. " is 140.
Long Statement,Irony.Interpreter.Ast,StringTemplateNode,C:\repos\Blecki_DCPUB\Irony\Interpreter\Ast\PrimitiveNodes\StringTemplateNode.cs,ParseSegments,The length of the statement  "      // This position is position in original text in source code' including original escaping sequences and open/close quotes.  " is 122.
Long Statement,Irony.Interpreter.Ast,StringTemplateNode,C:\repos\Blecki_DCPUB\Irony\Interpreter\Ast\PrimitiveNodes\StringTemplateNode.cs,ParseSegments,The length of the statement  "      // It will be passed to segment constructor' and maybe used later to compute the exact position of runtime error when it occurs.  " is 128.
Long Statement,Irony.Interpreter.Ast,StringTemplateNode,C:\repos\Blecki_DCPUB\Irony\Interpreter\Ast\PrimitiveNodes\StringTemplateNode.cs,ParseSegments,The length of the statement  "          context.AddParserError(Resources.ErrNoEndTagInEmbExpr' _templateSettings.EndTag);//"No ending tag '{0}' found in embedded expression." " is 134.
Long Statement,Irony.Interpreter.Ast,StringTemplateNode,C:\repos\Blecki_DCPUB\Irony\Interpreter\Ast\PrimitiveNodes\StringTemplateNode.cs,ParseSegments,The length of the statement  "            //we use original search in token text instead of currentPos in template to avoid distortions caused by opening quote and escaped sequences " is 139.
Long Statement,Irony.Interpreter.Ast,StringTemplateNode,C:\repos\Blecki_DCPUB\Irony\Interpreter\Ast\PrimitiveNodes\StringTemplateNode.cs,ParseSegments,The length of the statement  "          exprPosInTokenText = _tokenText.IndexOf(_templateSettings.StartTag' exprPosInTokenText) + _templateSettings.StartTag.Length; " is 124.
Long Statement,Irony.Interpreter.Ast,AstNode,C:\repos\Blecki_DCPUB\Irony\Interpreter\Ast\Base\AstNode.cs,AddChild,The length of the statement  "          child = new NullNode(childParseNode.Term); //put a stub to throw an exception with clear message on attempt to evaluate.  " is 120.
Long Statement,Irony.Interpreter,OperatorDispatchKey,C:\repos\Blecki_DCPUB\Irony\Interpreter\DynamicCallDispatcher.cs,CreateFromArgs,The length of the statement  "      return new OperatorDispatchKey(opSymbol' (arg1 == null ? null : arg1.GetType())' (arg2 == null ? null : arg2.GetType())); " is 121.
Long Statement,Irony.Interpreter,OperatorDispatchKey,C:\repos\Blecki_DCPUB\Irony\Interpreter\DynamicCallDispatcher.cs,Equals,The length of the statement  "      return HashCode == other.HashCode && OpSymbol == other.OpSymbol && Arg1Type == other.Arg1Type && Arg2Type == other.Arg2Type; " is 124.
Long Statement,Irony.Interpreter,LanguageRuntime,C:\repos\Blecki_DCPUB\Irony\Interpreter\LanguageRuntime_Init.cs,InitBaseTypeList,The length of the statement  "        typeof(UInt64)' typeof(Int64)' typeof(UInt32)' typeof(Int32)' typeof(UInt16)' typeof(Int16)' typeof(byte)' typeof(sbyte)' typeof(bool)  " is 134.
Long Statement,Irony.Interpreter,LanguageRuntime,C:\repos\Blecki_DCPUB\Irony\Interpreter\LanguageRuntime_Init.cs,InitOperatorImplementations,The length of the statement  "      // For each operator' we add a series of implementation methods for same-type operands. They are saved as DispatchRecords in  " is 124.
Long Statement,Irony.Interpreter,LanguageRuntime,C:\repos\Blecki_DCPUB\Irony\Interpreter\LanguageRuntime_Init.cs,InitOperatorImplementations,The length of the statement  "      // operator dispatchers. This happens at initialization time. Dispatch records for mismatched argument types (ex: int + double) " is 127.
Long Statement,Irony.Interpreter,LanguageRuntime,C:\repos\Blecki_DCPUB\Irony\Interpreter\LanguageRuntime_Init.cs,AddOperatorImplementation,The length of the statement  "        throw new Exception(string.Format(Resources.ErrOpNotDefinedForTypes' forKey.OpSymbol' forKey.Arg1Type' forKey.Arg2Type)); " is 121.
Long Statement,Irony.Interpreter,LanguageRuntime,C:\repos\Blecki_DCPUB\Irony\Interpreter\LanguageRuntime_Init.cs,AddOperatorImplementation,The length of the statement  "      var impl = new OperatorImplementation(forKey' baseType' baseImpl.BaseMethod' arg1Converter' arg2Converter' baseImpl.ResultConverter); " is 133.
Long Statement,Irony.Parsing.Construction,GrammarDataBuilder,C:\repos\Blecki_DCPUB\Irony\Parsing\Data\Construction\GrammarDataBuilder.cs,InitTermLists,The length of the statement  "      foreach (BnfTerm term in _grammarData.AllTerms) {  //remember - we may have hints' so it's not only terminals and non-terminals " is 127.
Long Statement,Irony.Parsing.Construction,GrammarDataBuilder,C:\repos\Blecki_DCPUB\Irony\Parsing\Data\Construction\GrammarDataBuilder.cs,ValidateGrammar,The length of the statement  "        _language.Errors.Add(GrammarErrorLevel.Error' null' Resources.ErrTransientNtMustHaveOneTerm'invalidTransSet.ToString()); " is 120.
Long Statement,Irony.Parsing.Construction,ParserDataBuilder,C:\repos\Blecki_DCPUB\Irony\Parsing\Data\Construction\ParserDataBuilder.cs,ComputeLookaheads,The length of the statement  "          _language.Errors.Add(GrammarErrorLevel.InternalError' reduceItem.State' "Reduce item '{0}' in state {1} has no lookaheads."' reduceItem.Core' reduceItem.State); " is 160.
Long Statement,Irony.Parsing.Construction,ParserDataBuilder,C:\repos\Blecki_DCPUB\Irony\Parsing\Data\Construction\ParserDataBuilder.cs,ReportAndCreateDefaultActionsForConflicts,The length of the statement  "        _language.Errors.Add(GrammarErrorLevel.Conflict' state' Resources.ErrSRConflict' state' shiftReduceConflicts.ToString()); " is 121.
Long Statement,Irony.Parsing.Construction,ParserDataBuilder,C:\repos\Blecki_DCPUB\Irony\Parsing\Data\Construction\ParserDataBuilder.cs,ReportAndCreateDefaultActionsForConflicts,The length of the statement  "        _language.Errors.Add(GrammarErrorLevel.Conflict' state' Resources.ErrRRConflict' state' reduceReduceConflicts.ToString()); " is 122.
Long Statement,Microsoft.Scripting.Math,Complex64,C:\repos\Blecki_DCPUB\Irony\Microsoft\Complex64.cs,ToString,The length of the statement  "            else if (imag < 0.0) return string.Format(System.Globalization.CultureInfo.InvariantCulture.NumberFormat' "({0}{1}j)"' real' imag); " is 131.
Complex Conditional,Irony.Parsing,CoreParser,C:\repos\Blecki_DCPUB\Irony\Parsing\Parser\CoreParser_ErrorHandling.cs,GetShiftActionInCurrentState,The conditional expression  "Context.CurrentParserState.Actions.TryGetValue(Context.CurrentParserInput.Term' out result) ||           Context.CurrentParserInput.Token != null && Context.CurrentParserInput.Token.KeyTerm != null &&               Context.CurrentParserState.Actions.TryGetValue(Context.CurrentParserInput.Token.KeyTerm' out result)"  is complex.
Complex Conditional,Irony.Parsing,NumberLiteral,C:\repos\Blecki_DCPUB\Irony\Parsing\Terminals\NumberLiteral.cs,ReadBody,The conditional expression  "!allowFloat && foundDigits && (isDot || isExpSymbol)"  is complex.
Complex Conditional,Irony.Parsing,Scanner,C:\repos\Blecki_DCPUB\Irony\Parsing\Scanner\Scanner.cs,ComputeCurrentTerminals,The conditional expression  "Context.Status == ParserStatus.Recovering || Context.Status == ParserStatus.Previewing             || Context.CurrentParserState == null || _grammar.FlagIsSet(LanguageFlags.DisableScannerParserLink)            || Context.Mode == ParseMode.VsLineScan"  is complex.
Complex Conditional,Irony.Parsing.Construction,GrammarDataBuilder,C:\repos\Blecki_DCPUB\Irony\Parsing\Data\Construction\GrammarDataBuilder.cs,ValidateGrammar,The conditional expression  "createAst && nt.AstNodeCreator == null && nt.AstNodeType == null && !nt.FlagIsSet(TermFlags.NoAstNode)"  is complex.
Virtual Method Call from Constructor,Irony.Parsing,Scanner,C:\repos\Blecki_DCPUB\Irony\Parsing\Scanner\Scanner.cs,Scanner,The constructor "Scanner" calls a virtual method "CreateTokenFilters".
Virtual Method Call from Constructor,Irony.Parsing,Scanner,C:\repos\Blecki_DCPUB\Irony\Parsing\Scanner\Scanner.cs,Scanner,The constructor "Scanner" calls a virtual method "BeginFiltering".
Virtual Method Call from Constructor,Irony.Interpreter,ScriptInterpreter,C:\repos\Blecki_DCPUB\Irony\Interpreter\ScriptInterpreter.cs,ScriptInterpreter,The constructor "ScriptInterpreter" calls a virtual method "CreateRuntime".
Virtual Method Call from Constructor,Irony.Interpreter,LanguageRuntime,C:\repos\Blecki_DCPUB\Irony\Interpreter\LanguageRuntime_Init.cs,LanguageRuntime,The constructor "LanguageRuntime" calls a virtual method "Init".
Empty Catch Block,Irony.Parsing,StringList,C:\repos\Blecki_DCPUB\Irony\Common\StringUtils.cs,LongerFirst,The method has an empty catch block.
Empty Catch Block,Irony.Parsing,StringSubType,C:\repos\Blecki_DCPUB\Irony\Parsing\Terminals\StringLiteral.cs,LongerStartFirst,The method has an empty catch block.
Empty Catch Block,Irony.Interpreter,ScriptInterpreter,C:\repos\Blecki_DCPUB\Irony\Interpreter\ScriptInterpreter.cs,Abort,The method has an empty catch block.
Magic Number,Irony.Parsing,DataLiteralBase,C:\repos\Blecki_DCPUB\Irony\Parsing\Terminals\DataLiteralBase.cs,ConvertValue,The following statement contains a magic number: switch(DataType) {          case TypeCode.String:   return textValue;           case TypeCode.DateTime: return DateTime.ParseExact(textValue' DateTimeFormat' context.Culture);          case TypeCode.Single:          case TypeCode.Double:            var dValue = Convert.ToDouble(textValue' context.Culture);             if (DataType == TypeCode.Double)  return dValue;             return Convert.ChangeType(dValue' DataType' context.Culture);            default: //integer types            var iValue = (IntRadix == 10)? Convert.ToInt64(textValue' context.Culture) : Convert.ToInt64(textValue' IntRadix);            if (DataType == TypeCode.Int64)  return iValue;             return Convert.ChangeType(iValue' DataType' context.Culture);        }
Magic Number,Irony.Parsing,DsvLiteral,C:\repos\Blecki_DCPUB\Irony\Parsing\Terminals\DsvLiteral.cs,ReadQuotedBody,The following statement contains a magic number: while(true) {          var until  = source.Text.IndexOf(dQuoute' from);          if (until < 0)            throw new Exception(Resources.ErrDsvNoClosingQuote); // "Could not find a closing quote for quoted value."          source.PreviewPosition = until; //now points at double-quote          var piece = source.Text.Substring(from' until - from);          source.PreviewPosition++; //move after double quote          if (source.PreviewChar != dQuoute && sb == null)            return piece; //quick path - if sb (string builder) was not created yet' we are looking at the very first segment;                          // and if we found a standalone dquote' then we are done - the "piece" is the result.           if (sb == null)            sb = new StringBuilder(100);          sb.Append(piece);          if (source.PreviewChar != dQuoute)            return sb.ToString();          //we have doubled double-quote; add a single double-quoute char to the result and move over both symbols          sb.Append(dQuoute);          from = source.PreviewPosition + 1;                }
Magic Number,Irony.Parsing,RegExLiteral,C:\repos\Blecki_DCPUB\Irony\Parsing\Terminals\RegExLiteral.cs,TryMatch,The following statement contains a magic number: var patternLen = source.PreviewPosition - source.Location.Position - 2;
Magic Number,Irony.Parsing,WikiTextTerminal,C:\repos\Blecki_DCPUB\Irony\Parsing\Terminals\WikiTerminals\WikiTextTerminal.cs,TryMatch,The following statement contains a magic number: if(isEscape) {          //return a token containing only escaped char          var value = source.NextPreviewChar.ToString();           source.PreviewPosition += 2;           return source.CreateToken(this.OutputTerminal' value);          }
Magic Number,Irony.Parsing,SourceStream,C:\repos\Blecki_DCPUB\Irony\Parsing\Scanner\SourceStream.cs,ToString,The following statement contains a magic number: try {          //show just 20 chars from current position          if (Location.Position + 20 < Text.Length)            result = Text.Substring(Location.Position' 20) + Resources.LabelSrcHaveMore;// " ..."          else            result = Text.Substring(Location.Position) + Resources.LabelEofMark; //"(EOF)"        } catch (Exception) {          result = PreviewChar + Resources.LabelSrcHaveMore;        }
Magic Number,Irony.Parsing,SourceStream,C:\repos\Blecki_DCPUB\Irony\Parsing\Scanner\SourceStream.cs,ToString,The following statement contains a magic number: try {          //show just 20 chars from current position          if (Location.Position + 20 < Text.Length)            result = Text.Substring(Location.Position' 20) + Resources.LabelSrcHaveMore;// " ..."          else            result = Text.Substring(Location.Position) + Resources.LabelEofMark; //"(EOF)"        } catch (Exception) {          result = PreviewChar + Resources.LabelSrcHaveMore;        }
Magic Number,Irony.Parsing,NonTerminal,C:\repos\Blecki_DCPUB\Irony\Parsing\Grammar\NonTerminal.cs,ConvertNodeCaptionTemplate,The following statement contains a magic number: while(index < 100) {          var strParam = "#{" + index + "}";          if(_convertedTemplate.Contains(strParam)) {            _convertedTemplate = _convertedTemplate.Replace(strParam' "{" + _captionParameters.Count + "}");             _captionParameters.Add(index);          }          if (!_convertedTemplate.Contains("#{")) return;          index++;         }
Magic Number,Irony.Parsing,NumberLiteral,C:\repos\Blecki_DCPUB\Irony\Parsing\Terminals\NumberLiteral.cs,QuickConvertToInt32,The following statement contains a magic number: if (radix == 10 && details.Body.Length > 10) return false;
Magic Number,Irony.Parsing,NumberLiteral,C:\repos\Blecki_DCPUB\Irony\Parsing\Terminals\NumberLiteral.cs,QuickConvertToInt32,The following statement contains a magic number: if (radix == 10 && details.Body.Length > 10) return false;
Magic Number,Irony.Parsing,NumberLiteral,C:\repos\Blecki_DCPUB\Irony\Parsing\Terminals\NumberLiteral.cs,QuickConvertToInt32,The following statement contains a magic number: try {          //workaround for .Net FX bug: http://connect.microsoft.com/VisualStudio/feedback/ViewFeedback.aspx?FeedbackID=278448          int iValue = 0;          if (radix == 10)            iValue =  Convert.ToInt32(details.Body' CultureInfo.InvariantCulture);          else            iValue = Convert.ToInt32(details.Body' radix);          details.Value = iValue;          return true;        } catch {          return false;        }
Magic Number,Irony.Parsing,NumberLiteral,C:\repos\Blecki_DCPUB\Irony\Parsing\Terminals\NumberLiteral.cs,TryConvertToLong,The following statement contains a magic number: try {          int radix = GetRadix(details);          //workaround for .Net FX bug: http://connect.microsoft.com/VisualStudio/feedback/ViewFeedback.aspx?FeedbackID=278448          if (radix == 10)              if (useULong)                details.Value = Convert.ToUInt64(details.Body' CultureInfo.InvariantCulture);              else                details.Value = Convert.ToInt64(details.Body' CultureInfo.InvariantCulture);          else              if (useULong)                details.Value = Convert.ToUInt64(details.Body' radix);              else                details.Value = Convert.ToInt64(details.Body' radix);          return true;         } catch(OverflowException) {          details.Error = string.Format(Resources.ErrCannotConvertValueToType' details.Value' TypeCode.Int64.ToString());          return false;        }
Magic Number,Irony.Parsing,NumberLiteral,C:\repos\Blecki_DCPUB\Irony\Parsing\Terminals\NumberLiteral.cs,ConvertToBigInteger,The following statement contains a magic number: try {          int startIndex = details.Body.Length - wordLength;          for (int sectionIndex = sectionCount - 1; sectionIndex >= 0; sectionIndex--) {            if (startIndex < 0) {              wordLength += startIndex;              startIndex = 0;            }            //workaround for .Net FX bug: http://connect.microsoft.com/VisualStudio/feedback/ViewFeedback.aspx?FeedbackID=278448            if (radix == 10)              numberSections[sectionIndex] = Convert.ToUInt64(details.Body.Substring(startIndex' wordLength));            else              numberSections[sectionIndex] = Convert.ToUInt64(details.Body.Substring(startIndex' wordLength)' radix);              startIndex -= wordLength;          }        } catch {          details.Error = Resources.ErrInvNumber;//  "Invalid number.";          return false;        }
Magic Number,Irony.Parsing,NumberLiteral,C:\repos\Blecki_DCPUB\Irony\Parsing\Terminals\NumberLiteral.cs,GetRadix,The following statement contains a magic number: if (details.IsSet((short)NumberOptions.Hex))          return 16;
Magic Number,Irony.Parsing,NumberLiteral,C:\repos\Blecki_DCPUB\Irony\Parsing\Terminals\NumberLiteral.cs,GetRadix,The following statement contains a magic number: if (details.IsSet((short)NumberOptions.Octal))          return 8;
Magic Number,Irony.Parsing,NumberLiteral,C:\repos\Blecki_DCPUB\Irony\Parsing\Terminals\NumberLiteral.cs,GetRadix,The following statement contains a magic number: if (details.IsSet((short)NumberOptions.Binary))          return 2;
Magic Number,Irony.Parsing,NumberLiteral,C:\repos\Blecki_DCPUB\Irony\Parsing\Terminals\NumberLiteral.cs,GetRadix,The following statement contains a magic number: return 10;
Magic Number,Irony.Parsing,NumberLiteral,C:\repos\Blecki_DCPUB\Irony\Parsing\Terminals\NumberLiteral.cs,GetSafeWordLength,The following statement contains a magic number: if (details.IsSet((short)NumberOptions.Hex))          return 15;
Magic Number,Irony.Parsing,NumberLiteral,C:\repos\Blecki_DCPUB\Irony\Parsing\Terminals\NumberLiteral.cs,GetSafeWordLength,The following statement contains a magic number: if (details.IsSet((short)NumberOptions.Octal))          return 21;
Magic Number,Irony.Parsing,NumberLiteral,C:\repos\Blecki_DCPUB\Irony\Parsing\Terminals\NumberLiteral.cs,GetSafeWordLength,The following statement contains a magic number: if (details.IsSet((short)NumberOptions.Binary))          return 63;
Magic Number,Irony.Parsing,NumberLiteral,C:\repos\Blecki_DCPUB\Irony\Parsing\Terminals\NumberLiteral.cs,GetSafeWordLength,The following statement contains a magic number: return 19;
Magic Number,Irony.Parsing,NumberLiteral,C:\repos\Blecki_DCPUB\Irony\Parsing\Terminals\NumberLiteral.cs,GetSafeWordRadix,The following statement contains a magic number: if (details.IsSet((short)NumberOptions.Hex))          return 1152921504606846976;
Magic Number,Irony.Parsing,NumberLiteral,C:\repos\Blecki_DCPUB\Irony\Parsing\Terminals\NumberLiteral.cs,GetSafeWordRadix,The following statement contains a magic number: if (details.IsSet((short)NumberOptions.Octal))          return 9223372036854775808;
Magic Number,Irony.Parsing,NumberLiteral,C:\repos\Blecki_DCPUB\Irony\Parsing\Terminals\NumberLiteral.cs,GetSafeWordRadix,The following statement contains a magic number: if (details.IsSet((short) NumberOptions.Binary))          return 9223372036854775808;
Magic Number,Irony.Parsing,NumberLiteral,C:\repos\Blecki_DCPUB\Irony\Parsing\Terminals\NumberLiteral.cs,GetSafeWordRadix,The following statement contains a magic number: return 10000000000000000000;
Magic Number,Irony.Parsing,StringLiteral,C:\repos\Blecki_DCPUB\Irony\Parsing\Terminals\StringLiteral.cs,HandleSpecialEscape,The following statement contains a magic number: switch (first) {          case 'u':          case 'U':            if (details.IsSet((short)StringOptions.AllowsUEscapes)) {              len = (first == 'u' ? 4 : 8);              if (segment.Length < len + 1) {                details.Error = string.Format(Resources.ErrBadUnEscape' segment.Substring(len + 1)' len);// "Invalid unicode escape ({0})' expected {1} hex digits."                return segment;              }              digits = segment.Substring(1' len);              ch = (char) Convert.ToUInt32(digits' 16);              result = ch + segment.Substring(len + 1);              return result;             }//if            break;          case 'x':            if (details.IsSet((short)StringOptions.AllowsXEscapes)) {              //x-escape allows variable number of digits' from one to 4; let's count them              p = 1; //current position              while (p < 5 && p < segment.Length) {                if (Strings.HexDigits.IndexOf(segment[p]) < 0) break;                p++;              }              //p now point to char right after the last digit              if (p <= 1) {                details.Error = Resources.ErrBadXEscape; // @"Invalid \x escape' at least one digit expected.";                return segment;              }              digits = segment.Substring(1' p - 1);              ch = (char) Convert.ToUInt32(digits' 16);              result = ch + segment.Substring(p);              return result;            }//if            break;          case '0':  case '1':  case '2':  case '3':  case '4':  case '5':   case '6': case '7':            if (details.IsSet((short)StringOptions.AllowsOctalEscapes)) {              //octal escape allows variable number of digits' from one to 3; let's count them              p = 0; //current position              while (p < 3 && p < segment.Length) {                if (Strings.OctalDigits.IndexOf(segment[p]) < 0) break;                p++;              }              //p now point to char right after the last digit              digits = segment.Substring(0' p);              ch = (char)Convert.ToUInt32(digits' 8);              result = ch + segment.Substring(p);              return result;            }//if            break;        }
Magic Number,Irony.Parsing,StringLiteral,C:\repos\Blecki_DCPUB\Irony\Parsing\Terminals\StringLiteral.cs,HandleSpecialEscape,The following statement contains a magic number: switch (first) {          case 'u':          case 'U':            if (details.IsSet((short)StringOptions.AllowsUEscapes)) {              len = (first == 'u' ? 4 : 8);              if (segment.Length < len + 1) {                details.Error = string.Format(Resources.ErrBadUnEscape' segment.Substring(len + 1)' len);// "Invalid unicode escape ({0})' expected {1} hex digits."                return segment;              }              digits = segment.Substring(1' len);              ch = (char) Convert.ToUInt32(digits' 16);              result = ch + segment.Substring(len + 1);              return result;             }//if            break;          case 'x':            if (details.IsSet((short)StringOptions.AllowsXEscapes)) {              //x-escape allows variable number of digits' from one to 4; let's count them              p = 1; //current position              while (p < 5 && p < segment.Length) {                if (Strings.HexDigits.IndexOf(segment[p]) < 0) break;                p++;              }              //p now point to char right after the last digit              if (p <= 1) {                details.Error = Resources.ErrBadXEscape; // @"Invalid \x escape' at least one digit expected.";                return segment;              }              digits = segment.Substring(1' p - 1);              ch = (char) Convert.ToUInt32(digits' 16);              result = ch + segment.Substring(p);              return result;            }//if            break;          case '0':  case '1':  case '2':  case '3':  case '4':  case '5':   case '6': case '7':            if (details.IsSet((short)StringOptions.AllowsOctalEscapes)) {              //octal escape allows variable number of digits' from one to 3; let's count them              p = 0; //current position              while (p < 3 && p < segment.Length) {                if (Strings.OctalDigits.IndexOf(segment[p]) < 0) break;                p++;              }              //p now point to char right after the last digit              digits = segment.Substring(0' p);              ch = (char)Convert.ToUInt32(digits' 8);              result = ch + segment.Substring(p);              return result;            }//if            break;        }
Magic Number,Irony.Parsing,StringLiteral,C:\repos\Blecki_DCPUB\Irony\Parsing\Terminals\StringLiteral.cs,HandleSpecialEscape,The following statement contains a magic number: switch (first) {          case 'u':          case 'U':            if (details.IsSet((short)StringOptions.AllowsUEscapes)) {              len = (first == 'u' ? 4 : 8);              if (segment.Length < len + 1) {                details.Error = string.Format(Resources.ErrBadUnEscape' segment.Substring(len + 1)' len);// "Invalid unicode escape ({0})' expected {1} hex digits."                return segment;              }              digits = segment.Substring(1' len);              ch = (char) Convert.ToUInt32(digits' 16);              result = ch + segment.Substring(len + 1);              return result;             }//if            break;          case 'x':            if (details.IsSet((short)StringOptions.AllowsXEscapes)) {              //x-escape allows variable number of digits' from one to 4; let's count them              p = 1; //current position              while (p < 5 && p < segment.Length) {                if (Strings.HexDigits.IndexOf(segment[p]) < 0) break;                p++;              }              //p now point to char right after the last digit              if (p <= 1) {                details.Error = Resources.ErrBadXEscape; // @"Invalid \x escape' at least one digit expected.";                return segment;              }              digits = segment.Substring(1' p - 1);              ch = (char) Convert.ToUInt32(digits' 16);              result = ch + segment.Substring(p);              return result;            }//if            break;          case '0':  case '1':  case '2':  case '3':  case '4':  case '5':   case '6': case '7':            if (details.IsSet((short)StringOptions.AllowsOctalEscapes)) {              //octal escape allows variable number of digits' from one to 3; let's count them              p = 0; //current position              while (p < 3 && p < segment.Length) {                if (Strings.OctalDigits.IndexOf(segment[p]) < 0) break;                p++;              }              //p now point to char right after the last digit              digits = segment.Substring(0' p);              ch = (char)Convert.ToUInt32(digits' 8);              result = ch + segment.Substring(p);              return result;            }//if            break;        }
Magic Number,Irony.Parsing,StringLiteral,C:\repos\Blecki_DCPUB\Irony\Parsing\Terminals\StringLiteral.cs,HandleSpecialEscape,The following statement contains a magic number: switch (first) {          case 'u':          case 'U':            if (details.IsSet((short)StringOptions.AllowsUEscapes)) {              len = (first == 'u' ? 4 : 8);              if (segment.Length < len + 1) {                details.Error = string.Format(Resources.ErrBadUnEscape' segment.Substring(len + 1)' len);// "Invalid unicode escape ({0})' expected {1} hex digits."                return segment;              }              digits = segment.Substring(1' len);              ch = (char) Convert.ToUInt32(digits' 16);              result = ch + segment.Substring(len + 1);              return result;             }//if            break;          case 'x':            if (details.IsSet((short)StringOptions.AllowsXEscapes)) {              //x-escape allows variable number of digits' from one to 4; let's count them              p = 1; //current position              while (p < 5 && p < segment.Length) {                if (Strings.HexDigits.IndexOf(segment[p]) < 0) break;                p++;              }              //p now point to char right after the last digit              if (p <= 1) {                details.Error = Resources.ErrBadXEscape; // @"Invalid \x escape' at least one digit expected.";                return segment;              }              digits = segment.Substring(1' p - 1);              ch = (char) Convert.ToUInt32(digits' 16);              result = ch + segment.Substring(p);              return result;            }//if            break;          case '0':  case '1':  case '2':  case '3':  case '4':  case '5':   case '6': case '7':            if (details.IsSet((short)StringOptions.AllowsOctalEscapes)) {              //octal escape allows variable number of digits' from one to 3; let's count them              p = 0; //current position              while (p < 3 && p < segment.Length) {                if (Strings.OctalDigits.IndexOf(segment[p]) < 0) break;                p++;              }              //p now point to char right after the last digit              digits = segment.Substring(0' p);              ch = (char)Convert.ToUInt32(digits' 8);              result = ch + segment.Substring(p);              return result;            }//if            break;        }
Magic Number,Irony.Parsing,StringLiteral,C:\repos\Blecki_DCPUB\Irony\Parsing\Terminals\StringLiteral.cs,HandleSpecialEscape,The following statement contains a magic number: switch (first) {          case 'u':          case 'U':            if (details.IsSet((short)StringOptions.AllowsUEscapes)) {              len = (first == 'u' ? 4 : 8);              if (segment.Length < len + 1) {                details.Error = string.Format(Resources.ErrBadUnEscape' segment.Substring(len + 1)' len);// "Invalid unicode escape ({0})' expected {1} hex digits."                return segment;              }              digits = segment.Substring(1' len);              ch = (char) Convert.ToUInt32(digits' 16);              result = ch + segment.Substring(len + 1);              return result;             }//if            break;          case 'x':            if (details.IsSet((short)StringOptions.AllowsXEscapes)) {              //x-escape allows variable number of digits' from one to 4; let's count them              p = 1; //current position              while (p < 5 && p < segment.Length) {                if (Strings.HexDigits.IndexOf(segment[p]) < 0) break;                p++;              }              //p now point to char right after the last digit              if (p <= 1) {                details.Error = Resources.ErrBadXEscape; // @"Invalid \x escape' at least one digit expected.";                return segment;              }              digits = segment.Substring(1' p - 1);              ch = (char) Convert.ToUInt32(digits' 16);              result = ch + segment.Substring(p);              return result;            }//if            break;          case '0':  case '1':  case '2':  case '3':  case '4':  case '5':   case '6': case '7':            if (details.IsSet((short)StringOptions.AllowsOctalEscapes)) {              //octal escape allows variable number of digits' from one to 3; let's count them              p = 0; //current position              while (p < 3 && p < segment.Length) {                if (Strings.OctalDigits.IndexOf(segment[p]) < 0) break;                p++;              }              //p now point to char right after the last digit              digits = segment.Substring(0' p);              ch = (char)Convert.ToUInt32(digits' 8);              result = ch + segment.Substring(p);              return result;            }//if            break;        }
Magic Number,Irony.Parsing,StringLiteral,C:\repos\Blecki_DCPUB\Irony\Parsing\Terminals\StringLiteral.cs,HandleSpecialEscape,The following statement contains a magic number: switch (first) {          case 'u':          case 'U':            if (details.IsSet((short)StringOptions.AllowsUEscapes)) {              len = (first == 'u' ? 4 : 8);              if (segment.Length < len + 1) {                details.Error = string.Format(Resources.ErrBadUnEscape' segment.Substring(len + 1)' len);// "Invalid unicode escape ({0})' expected {1} hex digits."                return segment;              }              digits = segment.Substring(1' len);              ch = (char) Convert.ToUInt32(digits' 16);              result = ch + segment.Substring(len + 1);              return result;             }//if            break;          case 'x':            if (details.IsSet((short)StringOptions.AllowsXEscapes)) {              //x-escape allows variable number of digits' from one to 4; let's count them              p = 1; //current position              while (p < 5 && p < segment.Length) {                if (Strings.HexDigits.IndexOf(segment[p]) < 0) break;                p++;              }              //p now point to char right after the last digit              if (p <= 1) {                details.Error = Resources.ErrBadXEscape; // @"Invalid \x escape' at least one digit expected.";                return segment;              }              digits = segment.Substring(1' p - 1);              ch = (char) Convert.ToUInt32(digits' 16);              result = ch + segment.Substring(p);              return result;            }//if            break;          case '0':  case '1':  case '2':  case '3':  case '4':  case '5':   case '6': case '7':            if (details.IsSet((short)StringOptions.AllowsOctalEscapes)) {              //octal escape allows variable number of digits' from one to 3; let's count them              p = 0; //current position              while (p < 3 && p < segment.Length) {                if (Strings.OctalDigits.IndexOf(segment[p]) < 0) break;                p++;              }              //p now point to char right after the last digit              digits = segment.Substring(0' p);              ch = (char)Convert.ToUInt32(digits' 8);              result = ch + segment.Substring(p);              return result;            }//if            break;        }
Magic Number,Irony.Parsing,StringLiteral,C:\repos\Blecki_DCPUB\Irony\Parsing\Terminals\StringLiteral.cs,HandleSpecialEscape,The following statement contains a magic number: switch (first) {          case 'u':          case 'U':            if (details.IsSet((short)StringOptions.AllowsUEscapes)) {              len = (first == 'u' ? 4 : 8);              if (segment.Length < len + 1) {                details.Error = string.Format(Resources.ErrBadUnEscape' segment.Substring(len + 1)' len);// "Invalid unicode escape ({0})' expected {1} hex digits."                return segment;              }              digits = segment.Substring(1' len);              ch = (char) Convert.ToUInt32(digits' 16);              result = ch + segment.Substring(len + 1);              return result;             }//if            break;          case 'x':            if (details.IsSet((short)StringOptions.AllowsXEscapes)) {              //x-escape allows variable number of digits' from one to 4; let's count them              p = 1; //current position              while (p < 5 && p < segment.Length) {                if (Strings.HexDigits.IndexOf(segment[p]) < 0) break;                p++;              }              //p now point to char right after the last digit              if (p <= 1) {                details.Error = Resources.ErrBadXEscape; // @"Invalid \x escape' at least one digit expected.";                return segment;              }              digits = segment.Substring(1' p - 1);              ch = (char) Convert.ToUInt32(digits' 16);              result = ch + segment.Substring(p);              return result;            }//if            break;          case '0':  case '1':  case '2':  case '3':  case '4':  case '5':   case '6': case '7':            if (details.IsSet((short)StringOptions.AllowsOctalEscapes)) {              //octal escape allows variable number of digits' from one to 3; let's count them              p = 0; //current position              while (p < 3 && p < segment.Length) {                if (Strings.OctalDigits.IndexOf(segment[p]) < 0) break;                p++;              }              //p now point to char right after the last digit              digits = segment.Substring(0' p);              ch = (char)Convert.ToUInt32(digits' 8);              result = ch + segment.Substring(p);              return result;            }//if            break;        }
Magic Number,Irony.Parsing,IdentifierTerminal,C:\repos\Blecki_DCPUB\Irony\Parsing\Terminals\IdentifierTerminal.cs,ReadUnicodeEscape,The following statement contains a magic number: switch (source.PreviewChar) {          case 'u': len = 4; break;          case 'U': len = 8; break;           default:            details.Error = Resources.ErrInvEscSymbol; // "Invalid escape symbol' expected 'u' or 'U' only."            return '\0';         }
Magic Number,Irony.Parsing,IdentifierTerminal,C:\repos\Blecki_DCPUB\Irony\Parsing\Terminals\IdentifierTerminal.cs,ReadUnicodeEscape,The following statement contains a magic number: switch (source.PreviewChar) {          case 'u': len = 4; break;          case 'U': len = 8; break;           default:            details.Error = Resources.ErrInvEscSymbol; // "Invalid escape symbol' expected 'u' or 'U' only."            return '\0';         }
Magic Number,Irony.Parsing,IdentifierTerminal,C:\repos\Blecki_DCPUB\Irony\Parsing\Terminals\IdentifierTerminal.cs,ReadUnicodeEscape,The following statement contains a magic number: char result = (char)Convert.ToUInt32(digits' 16);
Magic Number,Irony.Interpreter.Ast,FunctionDefNode,C:\repos\Blecki_DCPUB\Irony\Interpreter\Ast\Functions\FunctionDefNode.cs,Init,The following statement contains a magic number: Parameters = AddChild("Parameters"' treeNode.ChildNodes[2]);
Magic Number,Irony.Interpreter.Ast,FunctionDefNode,C:\repos\Blecki_DCPUB\Irony\Interpreter\Ast\Functions\FunctionDefNode.cs,Init,The following statement contains a magic number: Body = AddChild("Body"' treeNode.ChildNodes[3]);
Magic Number,Irony.Interpreter.Ast,IfNode,C:\repos\Blecki_DCPUB\Irony\Interpreter\Ast\Statements\IfNode.cs,Init,The following statement contains a magic number: if (treeNode.ChildNodes.Count > 2)          IfFalse = AddChild("IfFalse"' treeNode.ChildNodes[2]);
Magic Number,Irony.Interpreter.Ast,IfNode,C:\repos\Blecki_DCPUB\Irony\Interpreter\Ast\Statements\IfNode.cs,Init,The following statement contains a magic number: if (treeNode.ChildNodes.Count > 2)          IfFalse = AddChild("IfFalse"' treeNode.ChildNodes[2]);
Magic Number,Irony.Interpreter.Ast,BinaryOperationNode,C:\repos\Blecki_DCPUB\Irony\Interpreter\Ast\Expressions\BinaryOperationNode.cs,Init,The following statement contains a magic number: Right = AddChild("Arg"' treeNode.ChildNodes[2]);
Magic Number,Irony.Interpreter,CommandLine,C:\repos\Blecki_DCPUB\Irony\Interpreter\CommandLine.cs,RunImpl,The following statement contains a magic number: while (true) {          Console.ForegroundColor = ConsoleColor.White;          string prompt = (Interpreter.Status == InterpreterStatus.WaitingMoreInput ? PromptMoreInput : Prompt);          Console.Write(prompt);          var result = ReadInput(out input);          //Check the result type - it may be the response to "Abort?" question' not a script to execute.           switch (result) {            case ReadResult.AbortYes: return; //exit            case ReadResult.AbortNo: continue; //while loop            case ReadResult.Script: break; //do nothing' continue to evaluate script          }          Interpreter.ClearOutputBuffer();           Interpreter.EvaluateAsync(input);          while (Interpreter.IsBusy())            Thread.Sleep(50);          switch (Interpreter.Status) {            case InterpreterStatus.Ready: //success              Console.WriteLine(Interpreter.GetOutput());              break;            case  InterpreterStatus.SyntaxError:              Console.WriteLine(Interpreter.GetOutput()); //write all output we have              Console.ForegroundColor = ConsoleColor.Red;              foreach (var err in Interpreter.ParsedScript.ParserMessages) {                Console.WriteLine(string.Empty.PadRight(prompt.Length + err.Location.Column) + "^"); //show err location                Console.WriteLine(err.Message); //print message              }              break;            case InterpreterStatus.RuntimeError:              ReportException();               break;            default: break;          }//switch        }
Magic Number,Irony.Interpreter,DynamicCallDispatcher,C:\repos\Blecki_DCPUB\Irony\Interpreter\DynamicCallDispatcher.cs,ExecuteBinaryOperator,The following statement contains a magic number: if (opImpl != null) {          try {            var result = opImpl.Evaluate(arg1' arg2);            _context.Data.Replace(2' result);            return;          } catch (OverflowException) {            if (TryConvertArgsOnOverflow(opImpl.BaseType)) {              ExecuteBinaryOperator(op); //call self recursively' now with new arg types              return;            }            throw;           }//catch        }
Magic Number,Irony.Interpreter,ScriptInterpreter,C:\repos\Blecki_DCPUB\Irony\Interpreter\ScriptInterpreter.cs,Abort,The following statement contains a magic number: try {          if (WorkerThread == null) return;          WorkerThread.Abort();          WorkerThread.Join(50);        } catch { }
Magic Number,Irony.Interpreter,EvaluationContext,C:\repos\Blecki_DCPUB\Irony\Interpreter\EvaluationContext.cs,EvaluationContext,The following statement contains a magic number: Globals = new ValuesTable(100);
Magic Number,Irony.Interpreter,StackFrame,C:\repos\Blecki_DCPUB\Irony\Interpreter\StackFrame.cs,StackFrame,The following statement contains a magic number: if (Values == null)          Values = new ValuesTable(100);
Magic Number,Irony.Interpreter,StackFrame,C:\repos\Blecki_DCPUB\Irony\Interpreter\StackFrame.cs,StackFrame,The following statement contains a magic number: Values = new ValuesTable(8);
Magic Number,Irony.Parsing.Construction,ParserDataBuilder,C:\repos\Blecki_DCPUB\Irony\Parsing\Data\Construction\ParserDataBuilder.cs,ComputeLR0ItemSetKey,The following statement contains a magic number: StringBuilder sb = new StringBuilder(100);
Magic Number,Microsoft.Scripting.Math,Complex64,C:\repos\Blecki_DCPUB\Irony\Microsoft\Complex64.cs,Power,The following statement contains a magic number: if (power == c && power >= 0 && d == .0) {                  Complex64 result = new Complex64(1.0);                  if (power == 0) return result;                  Complex64 factor = this;                  while (power != 0) {                      if ((power & 1) != 0) {                          result = result * factor;                      }                      factor = factor * factor;                      power >>= 1;                  }                  return result;              } else if (IsZero) {                  return y.IsZero ? Complex64.MakeReal(1.0) : Complex64.MakeReal(0.0);              } else {                  double a = real;                  double b = imag;                  double powers = a * a + b * b;                  double arg = System.Math.Atan2(b' a);                  double mul = System.Math.Pow(powers' c / 2) * System.Math.Exp(-d * arg);                  double common = c * arg + .5 * d * System.Math.Log(powers);                  return new Complex64(mul * System.Math.Cos(common)' mul * System.Math.Sin(common));              }
Magic Number,Microsoft.Scripting.Math,Complex64,C:\repos\Blecki_DCPUB\Irony\Microsoft\Complex64.cs,Power,The following statement contains a magic number: if (power == c && power >= 0 && d == .0) {                  Complex64 result = new Complex64(1.0);                  if (power == 0) return result;                  Complex64 factor = this;                  while (power != 0) {                      if ((power & 1) != 0) {                          result = result * factor;                      }                      factor = factor * factor;                      power >>= 1;                  }                  return result;              } else if (IsZero) {                  return y.IsZero ? Complex64.MakeReal(1.0) : Complex64.MakeReal(0.0);              } else {                  double a = real;                  double b = imag;                  double powers = a * a + b * b;                  double arg = System.Math.Atan2(b' a);                  double mul = System.Math.Pow(powers' c / 2) * System.Math.Exp(-d * arg);                  double common = c * arg + .5 * d * System.Math.Log(powers);                  return new Complex64(mul * System.Math.Cos(common)' mul * System.Math.Sin(common));              }
Magic Number,Microsoft.Scripting.Math,Complex64,C:\repos\Blecki_DCPUB\Irony\Microsoft\Complex64.cs,GetHashCode,The following statement contains a magic number: return (int)real + (int)imag * 1000003;
Magic Number,Microsoft.Scripting.Math,BigInteger,C:\repos\Blecki_DCPUB\Irony\Microsoft\BigInteger.cs,Create,The following statement contains a magic number: Debug.Assert(bits.Length == 4 && (bits[3] & DecimalScaleFactorMask) == 0);
Magic Number,Microsoft.Scripting.Math,BigInteger,C:\repos\Blecki_DCPUB\Irony\Microsoft\BigInteger.cs,Create,The following statement contains a magic number: Debug.Assert(bits.Length == 4 && (bits[3] & DecimalScaleFactorMask) == 0);
Magic Number,Microsoft.Scripting.Math,BigInteger,C:\repos\Blecki_DCPUB\Irony\Microsoft\BigInteger.cs,Create,The following statement contains a magic number: int size = 3;
Magic Number,Microsoft.Scripting.Math,BigInteger,C:\repos\Blecki_DCPUB\Irony\Microsoft\BigInteger.cs,Create,The following statement contains a magic number: if (size > 2) array[2] = (UInt32)bits[2];
Magic Number,Microsoft.Scripting.Math,BigInteger,C:\repos\Blecki_DCPUB\Irony\Microsoft\BigInteger.cs,Create,The following statement contains a magic number: if (size > 2) array[2] = (UInt32)bits[2];
Magic Number,Microsoft.Scripting.Math,BigInteger,C:\repos\Blecki_DCPUB\Irony\Microsoft\BigInteger.cs,Create,The following statement contains a magic number: if (size > 2) array[2] = (UInt32)bits[2];
Magic Number,Microsoft.Scripting.Math,BigInteger,C:\repos\Blecki_DCPUB\Irony\Microsoft\BigInteger.cs,Create,The following statement contains a magic number: return new BigInteger(((bits[3] & DecimalSignMask) != 0) ? -1 : +1' array);
Magic Number,Microsoft.Scripting.Math,BigInteger,C:\repos\Blecki_DCPUB\Irony\Microsoft\BigInteger.cs,Create,The following statement contains a magic number: int unalignedBytes = byteCount % 4;
Magic Number,Microsoft.Scripting.Math,BigInteger,C:\repos\Blecki_DCPUB\Irony\Microsoft\BigInteger.cs,Create,The following statement contains a magic number: int dwordCount = byteCount / 4 + (unalignedBytes == 0 ? 0 : 1);
Magic Number,Microsoft.Scripting.Math,BigInteger,C:\repos\Blecki_DCPUB\Irony\Microsoft\BigInteger.cs,Create,The following statement contains a magic number: curByte = 3;
Magic Number,Microsoft.Scripting.Math,BigInteger,C:\repos\Blecki_DCPUB\Irony\Microsoft\BigInteger.cs,Create,The following statement contains a magic number: for (curDword = 0; curDword < dwordCount - (unalignedBytes == 0 ? 0 : 1); curDword++) {          byteInDword = 0;          while (byteInDword < 4) {            if (v[curByte] != 0x00) isZero = false;            data[curDword] <<= 8;            data[curDword] |= v[curByte];            curByte--;            byteInDword++;          }          curByte += 8;        }
Magic Number,Microsoft.Scripting.Math,BigInteger,C:\repos\Blecki_DCPUB\Irony\Microsoft\BigInteger.cs,Create,The following statement contains a magic number: for (curDword = 0; curDword < dwordCount - (unalignedBytes == 0 ? 0 : 1); curDword++) {          byteInDword = 0;          while (byteInDword < 4) {            if (v[curByte] != 0x00) isZero = false;            data[curDword] <<= 8;            data[curDword] |= v[curByte];            curByte--;            byteInDword++;          }          curByte += 8;        }
Magic Number,Microsoft.Scripting.Math,BigInteger,C:\repos\Blecki_DCPUB\Irony\Microsoft\BigInteger.cs,Create,The following statement contains a magic number: for (curDword = 0; curDword < dwordCount - (unalignedBytes == 0 ? 0 : 1); curDword++) {          byteInDword = 0;          while (byteInDword < 4) {            if (v[curByte] != 0x00) isZero = false;            data[curDword] <<= 8;            data[curDword] |= v[curByte];            curByte--;            byteInDword++;          }          curByte += 8;        }
Magic Number,Microsoft.Scripting.Math,BigInteger,C:\repos\Blecki_DCPUB\Irony\Microsoft\BigInteger.cs,Create,The following statement contains a magic number: if (unalignedBytes != 0) {          if (isNegative) data[dwordCount - 1] = 0xffffffff;          for (curByte = byteCount - 1; curByte >= byteCount - unalignedBytes; curByte--) {            if (v[curByte] != 0x00) isZero = false;            data[curDword] <<= 8;            data[curDword] |= v[curByte];          }        }
Magic Number,Microsoft.Scripting.Math,BigInteger,C:\repos\Blecki_DCPUB\Irony\Microsoft\BigInteger.cs,Negative,The following statement contains a magic number: return ((v[7] & 0x80) != 0);
Magic Number,Microsoft.Scripting.Math,BigInteger,C:\repos\Blecki_DCPUB\Irony\Microsoft\BigInteger.cs,Exponent,The following statement contains a magic number: return (ushort)((((ushort)(v[7] & 0x7F)) << (ushort)4) | (((ushort)(v[6] & 0xF0)) >> 4));
Magic Number,Microsoft.Scripting.Math,BigInteger,C:\repos\Blecki_DCPUB\Irony\Microsoft\BigInteger.cs,Exponent,The following statement contains a magic number: return (ushort)((((ushort)(v[7] & 0x7F)) << (ushort)4) | (((ushort)(v[6] & 0xF0)) >> 4));
Magic Number,Microsoft.Scripting.Math,BigInteger,C:\repos\Blecki_DCPUB\Irony\Microsoft\BigInteger.cs,Exponent,The following statement contains a magic number: return (ushort)((((ushort)(v[7] & 0x7F)) << (ushort)4) | (((ushort)(v[6] & 0xF0)) >> 4));
Magic Number,Microsoft.Scripting.Math,BigInteger,C:\repos\Blecki_DCPUB\Irony\Microsoft\BigInteger.cs,Exponent,The following statement contains a magic number: return (ushort)((((ushort)(v[7] & 0x7F)) << (ushort)4) | (((ushort)(v[6] & 0xF0)) >> 4));
Magic Number,Microsoft.Scripting.Math,BigInteger,C:\repos\Blecki_DCPUB\Irony\Microsoft\BigInteger.cs,Mantissa,The following statement contains a magic number: uint i1 = ((uint)v[0] | ((uint)v[1] << 8) | ((uint)v[2] << 16) | ((uint)v[3] << 24));
Magic Number,Microsoft.Scripting.Math,BigInteger,C:\repos\Blecki_DCPUB\Irony\Microsoft\BigInteger.cs,Mantissa,The following statement contains a magic number: uint i1 = ((uint)v[0] | ((uint)v[1] << 8) | ((uint)v[2] << 16) | ((uint)v[3] << 24));
Magic Number,Microsoft.Scripting.Math,BigInteger,C:\repos\Blecki_DCPUB\Irony\Microsoft\BigInteger.cs,Mantissa,The following statement contains a magic number: uint i1 = ((uint)v[0] | ((uint)v[1] << 8) | ((uint)v[2] << 16) | ((uint)v[3] << 24));
Magic Number,Microsoft.Scripting.Math,BigInteger,C:\repos\Blecki_DCPUB\Irony\Microsoft\BigInteger.cs,Mantissa,The following statement contains a magic number: uint i1 = ((uint)v[0] | ((uint)v[1] << 8) | ((uint)v[2] << 16) | ((uint)v[3] << 24));
Magic Number,Microsoft.Scripting.Math,BigInteger,C:\repos\Blecki_DCPUB\Irony\Microsoft\BigInteger.cs,Mantissa,The following statement contains a magic number: uint i1 = ((uint)v[0] | ((uint)v[1] << 8) | ((uint)v[2] << 16) | ((uint)v[3] << 24));
Magic Number,Microsoft.Scripting.Math,BigInteger,C:\repos\Blecki_DCPUB\Irony\Microsoft\BigInteger.cs,Mantissa,The following statement contains a magic number: uint i2 = ((uint)v[4] | ((uint)v[5] << 8) | ((uint)(v[6] & 0xF) << 16));
Magic Number,Microsoft.Scripting.Math,BigInteger,C:\repos\Blecki_DCPUB\Irony\Microsoft\BigInteger.cs,Mantissa,The following statement contains a magic number: uint i2 = ((uint)v[4] | ((uint)v[5] << 8) | ((uint)(v[6] & 0xF) << 16));
Magic Number,Microsoft.Scripting.Math,BigInteger,C:\repos\Blecki_DCPUB\Irony\Microsoft\BigInteger.cs,Mantissa,The following statement contains a magic number: uint i2 = ((uint)v[4] | ((uint)v[5] << 8) | ((uint)(v[6] & 0xF) << 16));
Magic Number,Microsoft.Scripting.Math,BigInteger,C:\repos\Blecki_DCPUB\Irony\Microsoft\BigInteger.cs,Mantissa,The following statement contains a magic number: uint i2 = ((uint)v[4] | ((uint)v[5] << 8) | ((uint)(v[6] & 0xF) << 16));
Magic Number,Microsoft.Scripting.Math,BigInteger,C:\repos\Blecki_DCPUB\Irony\Microsoft\BigInteger.cs,Mantissa,The following statement contains a magic number: uint i2 = ((uint)v[4] | ((uint)v[5] << 8) | ((uint)(v[6] & 0xF) << 16));
Magic Number,Microsoft.Scripting.Math,BigInteger,C:\repos\Blecki_DCPUB\Irony\Microsoft\BigInteger.cs,Mantissa,The following statement contains a magic number: return (ulong)((ulong)i1 | ((ulong)i2 << 32));
Magic Number,Microsoft.Scripting.Math,BigInteger,C:\repos\Blecki_DCPUB\Irony\Microsoft\BigInteger.cs,AsInt64,The following statement contains a magic number: if (Length > 2) return false;
Magic Number,Microsoft.Scripting.Math,BigInteger,C:\repos\Blecki_DCPUB\Irony\Microsoft\BigInteger.cs,AsInt64,The following statement contains a magic number: ulong tmp = (((ulong)data[1]) << 32 | (ulong)data[0]);
Magic Number,Microsoft.Scripting.Math,BigInteger,C:\repos\Blecki_DCPUB\Irony\Microsoft\BigInteger.cs,AsUInt64,The following statement contains a magic number: if (Length > 2) return false;
Magic Number,Microsoft.Scripting.Math,BigInteger,C:\repos\Blecki_DCPUB\Irony\Microsoft\BigInteger.cs,AsUInt64,The following statement contains a magic number: if (data.Length > 1) {          ret |= ((ulong)data[1]) << 32;        }
Magic Number,Microsoft.Scripting.Math,BigInteger,C:\repos\Blecki_DCPUB\Irony\Microsoft\BigInteger.cs,AsDecimal,The following statement contains a magic number: while (length > 3) {          if (scale >= 28) {            ret = default(decimal);            return false;          }          bi = bi / 10;          scale++;            length = bi.Length;        }
Magic Number,Microsoft.Scripting.Math,BigInteger,C:\repos\Blecki_DCPUB\Irony\Microsoft\BigInteger.cs,AsDecimal,The following statement contains a magic number: while (length > 3) {          if (scale >= 28) {            ret = default(decimal);            return false;          }          bi = bi / 10;          scale++;            length = bi.Length;        }
Magic Number,Microsoft.Scripting.Math,BigInteger,C:\repos\Blecki_DCPUB\Irony\Microsoft\BigInteger.cs,AsDecimal,The following statement contains a magic number: while (length > 3) {          if (scale >= 28) {            ret = default(decimal);            return false;          }          bi = bi / 10;          scale++;            length = bi.Length;        }
Magic Number,Microsoft.Scripting.Math,BigInteger,C:\repos\Blecki_DCPUB\Irony\Microsoft\BigInteger.cs,AsDecimal,The following statement contains a magic number: if (length > 2) hi = (Int32)bi.data[2];
Magic Number,Microsoft.Scripting.Math,BigInteger,C:\repos\Blecki_DCPUB\Irony\Microsoft\BigInteger.cs,AsDecimal,The following statement contains a magic number: if (length > 2) hi = (Int32)bi.data[2];
Magic Number,Microsoft.Scripting.Math,BigInteger,C:\repos\Blecki_DCPUB\Irony\Microsoft\BigInteger.cs,TryToFloat64,The following statement contains a magic number: return double.TryParse(ToString(10)'            System.Globalization.NumberStyles.Number'            System.Globalization.CultureInfo.InvariantCulture.NumberFormat'            out result);
Magic Number,Microsoft.Scripting.Math,BigInteger,C:\repos\Blecki_DCPUB\Irony\Microsoft\BigInteger.cs,ToFloat64,The following statement contains a magic number: return double.Parse(            ToString(10)'            System.Globalization.CultureInfo.InvariantCulture.NumberFormat            );
Magic Number,Microsoft.Scripting.Math,BigInteger,C:\repos\Blecki_DCPUB\Irony\Microsoft\BigInteger.cs,GetNormalizeShift,The following statement contains a magic number: if ((value & 0xFFFF0000) == 0) { value <<= 16; shift += 16; }
Magic Number,Microsoft.Scripting.Math,BigInteger,C:\repos\Blecki_DCPUB\Irony\Microsoft\BigInteger.cs,GetNormalizeShift,The following statement contains a magic number: if ((value & 0xFFFF0000) == 0) { value <<= 16; shift += 16; }
Magic Number,Microsoft.Scripting.Math,BigInteger,C:\repos\Blecki_DCPUB\Irony\Microsoft\BigInteger.cs,GetNormalizeShift,The following statement contains a magic number: if ((value & 0xFF000000) == 0) { value <<= 8; shift += 8; }
Magic Number,Microsoft.Scripting.Math,BigInteger,C:\repos\Blecki_DCPUB\Irony\Microsoft\BigInteger.cs,GetNormalizeShift,The following statement contains a magic number: if ((value & 0xFF000000) == 0) { value <<= 8; shift += 8; }
Magic Number,Microsoft.Scripting.Math,BigInteger,C:\repos\Blecki_DCPUB\Irony\Microsoft\BigInteger.cs,GetNormalizeShift,The following statement contains a magic number: if ((value & 0xF0000000) == 0) { value <<= 4; shift += 4; }
Magic Number,Microsoft.Scripting.Math,BigInteger,C:\repos\Blecki_DCPUB\Irony\Microsoft\BigInteger.cs,GetNormalizeShift,The following statement contains a magic number: if ((value & 0xF0000000) == 0) { value <<= 4; shift += 4; }
Magic Number,Microsoft.Scripting.Math,BigInteger,C:\repos\Blecki_DCPUB\Irony\Microsoft\BigInteger.cs,GetNormalizeShift,The following statement contains a magic number: if ((value & 0xC0000000) == 0) { value <<= 2; shift += 2; }
Magic Number,Microsoft.Scripting.Math,BigInteger,C:\repos\Blecki_DCPUB\Irony\Microsoft\BigInteger.cs,GetNormalizeShift,The following statement contains a magic number: if ((value & 0xC0000000) == 0) { value <<= 2; shift += 2; }
Magic Number,Microsoft.Scripting.Math,BigInteger,C:\repos\Blecki_DCPUB\Irony\Microsoft\BigInteger.cs,Normalize,The following statement contains a magic number: Debug.Assert(0 <= shift && shift < 32);
Magic Number,Microsoft.Scripting.Math,BigInteger,C:\repos\Blecki_DCPUB\Irony\Microsoft\BigInteger.cs,Unnormalize,The following statement contains a magic number: Debug.Assert(0 <= shift && shift < 32);
Magic Number,Microsoft.Scripting.Math,BigInteger,C:\repos\Blecki_DCPUB\Irony\Microsoft\BigInteger.cs,Unnormalize,The following statement contains a magic number: if (shift > 0) {          int lshift = 32 - shift;          uint carry = 0;          for (int i = length - 1; i >= 0; i--) {            uint uni = un[i];            r[i] = (uni >> shift) | carry;            carry = (uni << lshift);          }        } else {          for (int i = 0; i < length; i++) {            r[i] = un[i];          }        }
Magic Number,Microsoft.Scripting.Math,BigInteger,C:\repos\Blecki_DCPUB\Irony\Microsoft\BigInteger.cs,DivModUnsigned,The following statement contains a magic number: if (n <= 1) {          if (n == 0) {            throw new DivideByZeroException();          }            //  Divide by single digit          //          ulong rem = 0;          uint v0 = v[0];          q = new uint[m];          r = new uint[1];            for (int j = m - 1; j >= 0; j--) {            rem *= Base;            rem += u[j];              ulong div = rem / v0;            rem -= div * v0;            q[j] = (uint)div;          }          r[0] = (uint)rem;        } else if (m >= n) {          int shift = GetNormalizeShift(v[n - 1]);            uint[] un = new uint[m + 1];          uint[] vn = new uint[n];            Normalize(u' m' un' shift);          Normalize(v' n' vn' shift);            q = new uint[m - n + 1];          r = null;            TestDivisionStep(un' vn' q' u' v);            //  Main division loop          //          for (int j = m - n; j >= 0; j--) {            ulong rr' qq;            int i;              rr = Base * un[j + n] + un[j + n - 1];            qq = rr / vn[n - 1];            rr -= qq * vn[n - 1];              Debug.Assert((Base * un[j + n] + un[j + n - 1]) == qq * vn[n - 1] + rr);              for (; ; ) {              // Estimate too big ?              //              if ((qq >= Base) || (qq * vn[n - 2] > (rr * Base + un[j + n - 2]))) {                qq--;                rr += (ulong)vn[n - 1];                if (rr < Base) continue;              }              break;            }              Debug.Assert((Base * un[j + n] + un[j + n - 1]) == qq * vn[n - 1] + rr);              //  Multiply and subtract            //            long b = 0;            long t = 0;            for (i = 0; i < n; i++) {              ulong p = vn[i] * qq;              t = (long)un[i + j] - (long)(uint)p - b;              un[i + j] = (uint)t;              p >>= 32;              t >>= 32;              Debug.Assert(t == 0 || t == -1 || t == -2);              b = (long)p - t;            }            t = (long)un[j + n] - b;            un[j + n] = (uint)t;              //  Store the calculated value            //            q[j] = (uint)qq;              //  Add back vn[0..n] to un[j..j+n]            //            if (t < 0) {              q[j]--;              ulong c = 0;              for (i = 0; i < n; i++) {                c = (ulong)vn[i] + un[j + i] + c;                un[j + i] = (uint)c;                c >>= 32;              }              c += (ulong)un[j + n];              un[j + n] = (uint)c;            }              TestDivisionStep(un' vn' q' u' v);          }            Unnormalize(un' out r' shift);            //  Test normalized value ... Call TestNormalize          //  only pass the values in different order.          //          TestNormalize(r' un' shift);        } else {          q = new uint[] { 0 };          r = u;        }
Magic Number,Microsoft.Scripting.Math,BigInteger,C:\repos\Blecki_DCPUB\Irony\Microsoft\BigInteger.cs,DivModUnsigned,The following statement contains a magic number: if (n <= 1) {          if (n == 0) {            throw new DivideByZeroException();          }            //  Divide by single digit          //          ulong rem = 0;          uint v0 = v[0];          q = new uint[m];          r = new uint[1];            for (int j = m - 1; j >= 0; j--) {            rem *= Base;            rem += u[j];              ulong div = rem / v0;            rem -= div * v0;            q[j] = (uint)div;          }          r[0] = (uint)rem;        } else if (m >= n) {          int shift = GetNormalizeShift(v[n - 1]);            uint[] un = new uint[m + 1];          uint[] vn = new uint[n];            Normalize(u' m' un' shift);          Normalize(v' n' vn' shift);            q = new uint[m - n + 1];          r = null;            TestDivisionStep(un' vn' q' u' v);            //  Main division loop          //          for (int j = m - n; j >= 0; j--) {            ulong rr' qq;            int i;              rr = Base * un[j + n] + un[j + n - 1];            qq = rr / vn[n - 1];            rr -= qq * vn[n - 1];              Debug.Assert((Base * un[j + n] + un[j + n - 1]) == qq * vn[n - 1] + rr);              for (; ; ) {              // Estimate too big ?              //              if ((qq >= Base) || (qq * vn[n - 2] > (rr * Base + un[j + n - 2]))) {                qq--;                rr += (ulong)vn[n - 1];                if (rr < Base) continue;              }              break;            }              Debug.Assert((Base * un[j + n] + un[j + n - 1]) == qq * vn[n - 1] + rr);              //  Multiply and subtract            //            long b = 0;            long t = 0;            for (i = 0; i < n; i++) {              ulong p = vn[i] * qq;              t = (long)un[i + j] - (long)(uint)p - b;              un[i + j] = (uint)t;              p >>= 32;              t >>= 32;              Debug.Assert(t == 0 || t == -1 || t == -2);              b = (long)p - t;            }            t = (long)un[j + n] - b;            un[j + n] = (uint)t;              //  Store the calculated value            //            q[j] = (uint)qq;              //  Add back vn[0..n] to un[j..j+n]            //            if (t < 0) {              q[j]--;              ulong c = 0;              for (i = 0; i < n; i++) {                c = (ulong)vn[i] + un[j + i] + c;                un[j + i] = (uint)c;                c >>= 32;              }              c += (ulong)un[j + n];              un[j + n] = (uint)c;            }              TestDivisionStep(un' vn' q' u' v);          }            Unnormalize(un' out r' shift);            //  Test normalized value ... Call TestNormalize          //  only pass the values in different order.          //          TestNormalize(r' un' shift);        } else {          q = new uint[] { 0 };          r = u;        }
Magic Number,Microsoft.Scripting.Math,BigInteger,C:\repos\Blecki_DCPUB\Irony\Microsoft\BigInteger.cs,DivModUnsigned,The following statement contains a magic number: if (n <= 1) {          if (n == 0) {            throw new DivideByZeroException();          }            //  Divide by single digit          //          ulong rem = 0;          uint v0 = v[0];          q = new uint[m];          r = new uint[1];            for (int j = m - 1; j >= 0; j--) {            rem *= Base;            rem += u[j];              ulong div = rem / v0;            rem -= div * v0;            q[j] = (uint)div;          }          r[0] = (uint)rem;        } else if (m >= n) {          int shift = GetNormalizeShift(v[n - 1]);            uint[] un = new uint[m + 1];          uint[] vn = new uint[n];            Normalize(u' m' un' shift);          Normalize(v' n' vn' shift);            q = new uint[m - n + 1];          r = null;            TestDivisionStep(un' vn' q' u' v);            //  Main division loop          //          for (int j = m - n; j >= 0; j--) {            ulong rr' qq;            int i;              rr = Base * un[j + n] + un[j + n - 1];            qq = rr / vn[n - 1];            rr -= qq * vn[n - 1];              Debug.Assert((Base * un[j + n] + un[j + n - 1]) == qq * vn[n - 1] + rr);              for (; ; ) {              // Estimate too big ?              //              if ((qq >= Base) || (qq * vn[n - 2] > (rr * Base + un[j + n - 2]))) {                qq--;                rr += (ulong)vn[n - 1];                if (rr < Base) continue;              }              break;            }              Debug.Assert((Base * un[j + n] + un[j + n - 1]) == qq * vn[n - 1] + rr);              //  Multiply and subtract            //            long b = 0;            long t = 0;            for (i = 0; i < n; i++) {              ulong p = vn[i] * qq;              t = (long)un[i + j] - (long)(uint)p - b;              un[i + j] = (uint)t;              p >>= 32;              t >>= 32;              Debug.Assert(t == 0 || t == -1 || t == -2);              b = (long)p - t;            }            t = (long)un[j + n] - b;            un[j + n] = (uint)t;              //  Store the calculated value            //            q[j] = (uint)qq;              //  Add back vn[0..n] to un[j..j+n]            //            if (t < 0) {              q[j]--;              ulong c = 0;              for (i = 0; i < n; i++) {                c = (ulong)vn[i] + un[j + i] + c;                un[j + i] = (uint)c;                c >>= 32;              }              c += (ulong)un[j + n];              un[j + n] = (uint)c;            }              TestDivisionStep(un' vn' q' u' v);          }            Unnormalize(un' out r' shift);            //  Test normalized value ... Call TestNormalize          //  only pass the values in different order.          //          TestNormalize(r' un' shift);        } else {          q = new uint[] { 0 };          r = u;        }
Magic Number,Microsoft.Scripting.Math,BigInteger,C:\repos\Blecki_DCPUB\Irony\Microsoft\BigInteger.cs,DivModUnsigned,The following statement contains a magic number: if (n <= 1) {          if (n == 0) {            throw new DivideByZeroException();          }            //  Divide by single digit          //          ulong rem = 0;          uint v0 = v[0];          q = new uint[m];          r = new uint[1];            for (int j = m - 1; j >= 0; j--) {            rem *= Base;            rem += u[j];              ulong div = rem / v0;            rem -= div * v0;            q[j] = (uint)div;          }          r[0] = (uint)rem;        } else if (m >= n) {          int shift = GetNormalizeShift(v[n - 1]);            uint[] un = new uint[m + 1];          uint[] vn = new uint[n];            Normalize(u' m' un' shift);          Normalize(v' n' vn' shift);            q = new uint[m - n + 1];          r = null;            TestDivisionStep(un' vn' q' u' v);            //  Main division loop          //          for (int j = m - n; j >= 0; j--) {            ulong rr' qq;            int i;              rr = Base * un[j + n] + un[j + n - 1];            qq = rr / vn[n - 1];            rr -= qq * vn[n - 1];              Debug.Assert((Base * un[j + n] + un[j + n - 1]) == qq * vn[n - 1] + rr);              for (; ; ) {              // Estimate too big ?              //              if ((qq >= Base) || (qq * vn[n - 2] > (rr * Base + un[j + n - 2]))) {                qq--;                rr += (ulong)vn[n - 1];                if (rr < Base) continue;              }              break;            }              Debug.Assert((Base * un[j + n] + un[j + n - 1]) == qq * vn[n - 1] + rr);              //  Multiply and subtract            //            long b = 0;            long t = 0;            for (i = 0; i < n; i++) {              ulong p = vn[i] * qq;              t = (long)un[i + j] - (long)(uint)p - b;              un[i + j] = (uint)t;              p >>= 32;              t >>= 32;              Debug.Assert(t == 0 || t == -1 || t == -2);              b = (long)p - t;            }            t = (long)un[j + n] - b;            un[j + n] = (uint)t;              //  Store the calculated value            //            q[j] = (uint)qq;              //  Add back vn[0..n] to un[j..j+n]            //            if (t < 0) {              q[j]--;              ulong c = 0;              for (i = 0; i < n; i++) {                c = (ulong)vn[i] + un[j + i] + c;                un[j + i] = (uint)c;                c >>= 32;              }              c += (ulong)un[j + n];              un[j + n] = (uint)c;            }              TestDivisionStep(un' vn' q' u' v);          }            Unnormalize(un' out r' shift);            //  Test normalized value ... Call TestNormalize          //  only pass the values in different order.          //          TestNormalize(r' un' shift);        } else {          q = new uint[] { 0 };          r = u;        }
Magic Number,Microsoft.Scripting.Math,BigInteger,C:\repos\Blecki_DCPUB\Irony\Microsoft\BigInteger.cs,DivModUnsigned,The following statement contains a magic number: if (n <= 1) {          if (n == 0) {            throw new DivideByZeroException();          }            //  Divide by single digit          //          ulong rem = 0;          uint v0 = v[0];          q = new uint[m];          r = new uint[1];            for (int j = m - 1; j >= 0; j--) {            rem *= Base;            rem += u[j];              ulong div = rem / v0;            rem -= div * v0;            q[j] = (uint)div;          }          r[0] = (uint)rem;        } else if (m >= n) {          int shift = GetNormalizeShift(v[n - 1]);            uint[] un = new uint[m + 1];          uint[] vn = new uint[n];            Normalize(u' m' un' shift);          Normalize(v' n' vn' shift);            q = new uint[m - n + 1];          r = null;            TestDivisionStep(un' vn' q' u' v);            //  Main division loop          //          for (int j = m - n; j >= 0; j--) {            ulong rr' qq;            int i;              rr = Base * un[j + n] + un[j + n - 1];            qq = rr / vn[n - 1];            rr -= qq * vn[n - 1];              Debug.Assert((Base * un[j + n] + un[j + n - 1]) == qq * vn[n - 1] + rr);              for (; ; ) {              // Estimate too big ?              //              if ((qq >= Base) || (qq * vn[n - 2] > (rr * Base + un[j + n - 2]))) {                qq--;                rr += (ulong)vn[n - 1];                if (rr < Base) continue;              }              break;            }              Debug.Assert((Base * un[j + n] + un[j + n - 1]) == qq * vn[n - 1] + rr);              //  Multiply and subtract            //            long b = 0;            long t = 0;            for (i = 0; i < n; i++) {              ulong p = vn[i] * qq;              t = (long)un[i + j] - (long)(uint)p - b;              un[i + j] = (uint)t;              p >>= 32;              t >>= 32;              Debug.Assert(t == 0 || t == -1 || t == -2);              b = (long)p - t;            }            t = (long)un[j + n] - b;            un[j + n] = (uint)t;              //  Store the calculated value            //            q[j] = (uint)qq;              //  Add back vn[0..n] to un[j..j+n]            //            if (t < 0) {              q[j]--;              ulong c = 0;              for (i = 0; i < n; i++) {                c = (ulong)vn[i] + un[j + i] + c;                un[j + i] = (uint)c;                c >>= 32;              }              c += (ulong)un[j + n];              un[j + n] = (uint)c;            }              TestDivisionStep(un' vn' q' u' v);          }            Unnormalize(un' out r' shift);            //  Test normalized value ... Call TestNormalize          //  only pass the values in different order.          //          TestNormalize(r' un' shift);        } else {          q = new uint[] { 0 };          r = u;        }
Magic Number,Microsoft.Scripting.Math,BigInteger,C:\repos\Blecki_DCPUB\Irony\Microsoft\BigInteger.cs,DivModUnsigned,The following statement contains a magic number: if (n <= 1) {          if (n == 0) {            throw new DivideByZeroException();          }            //  Divide by single digit          //          ulong rem = 0;          uint v0 = v[0];          q = new uint[m];          r = new uint[1];            for (int j = m - 1; j >= 0; j--) {            rem *= Base;            rem += u[j];              ulong div = rem / v0;            rem -= div * v0;            q[j] = (uint)div;          }          r[0] = (uint)rem;        } else if (m >= n) {          int shift = GetNormalizeShift(v[n - 1]);            uint[] un = new uint[m + 1];          uint[] vn = new uint[n];            Normalize(u' m' un' shift);          Normalize(v' n' vn' shift);            q = new uint[m - n + 1];          r = null;            TestDivisionStep(un' vn' q' u' v);            //  Main division loop          //          for (int j = m - n; j >= 0; j--) {            ulong rr' qq;            int i;              rr = Base * un[j + n] + un[j + n - 1];            qq = rr / vn[n - 1];            rr -= qq * vn[n - 1];              Debug.Assert((Base * un[j + n] + un[j + n - 1]) == qq * vn[n - 1] + rr);              for (; ; ) {              // Estimate too big ?              //              if ((qq >= Base) || (qq * vn[n - 2] > (rr * Base + un[j + n - 2]))) {                qq--;                rr += (ulong)vn[n - 1];                if (rr < Base) continue;              }              break;            }              Debug.Assert((Base * un[j + n] + un[j + n - 1]) == qq * vn[n - 1] + rr);              //  Multiply and subtract            //            long b = 0;            long t = 0;            for (i = 0; i < n; i++) {              ulong p = vn[i] * qq;              t = (long)un[i + j] - (long)(uint)p - b;              un[i + j] = (uint)t;              p >>= 32;              t >>= 32;              Debug.Assert(t == 0 || t == -1 || t == -2);              b = (long)p - t;            }            t = (long)un[j + n] - b;            un[j + n] = (uint)t;              //  Store the calculated value            //            q[j] = (uint)qq;              //  Add back vn[0..n] to un[j..j+n]            //            if (t < 0) {              q[j]--;              ulong c = 0;              for (i = 0; i < n; i++) {                c = (ulong)vn[i] + un[j + i] + c;                un[j + i] = (uint)c;                c >>= 32;              }              c += (ulong)un[j + n];              un[j + n] = (uint)c;            }              TestDivisionStep(un' vn' q' u' v);          }            Unnormalize(un' out r' shift);            //  Test normalized value ... Call TestNormalize          //  only pass the values in different order.          //          TestNormalize(r' un' shift);        } else {          q = new uint[] { 0 };          r = u;        }
Magic Number,Microsoft.Scripting.Math,BigInteger,C:\repos\Blecki_DCPUB\Irony\Microsoft\BigInteger.cs,ToString,The following statement contains a magic number: return ToString(10);
Magic Number,Microsoft.Scripting.Math,BigInteger,C:\repos\Blecki_DCPUB\Irony\Microsoft\BigInteger.cs,ToString,The following statement contains a magic number: if (radix < 2) {          throw new ArgumentOutOfRangeException("radix");        }
Magic Number,Microsoft.Scripting.Math,BigInteger,C:\repos\Blecki_DCPUB\Irony\Microsoft\BigInteger.cs,ToString,The following statement contains a magic number: if (radix > 36) {          throw new ArgumentOutOfRangeException("radix");        }
Magic Number,Microsoft.Scripting.Math,BigInteger,C:\repos\Blecki_DCPUB\Irony\Microsoft\BigInteger.cs,ToByteArray,The following statement contains a magic number: byte[] bytes = new byte[4 * dwords.Length];
Magic Number,Microsoft.Scripting.Math,BigInteger,C:\repos\Blecki_DCPUB\Irony\Microsoft\BigInteger.cs,ToByteArray,The following statement contains a magic number: for (int i = 0; i < dwords.Length; i++) {          dword = dwords[i];          for (int j = 0; j < 4; j++) {            bytes[curByte++] = (byte)(dword & 0xff);            dword >>= 8;          }        }
Magic Number,Microsoft.Scripting.Math,BigInteger,C:\repos\Blecki_DCPUB\Irony\Microsoft\BigInteger.cs,ToByteArray,The following statement contains a magic number: for (int i = 0; i < dwords.Length; i++) {          dword = dwords[i];          for (int j = 0; j < 4; j++) {            bytes[curByte++] = (byte)(dword & 0xff);            dword >>= 8;          }        }
Magic Number,Microsoft.Scripting.Math,BigInteger,C:\repos\Blecki_DCPUB\Irony\Microsoft\BigInteger.cs,ToString,The following statement contains a magic number: switch (format[0]) {          case 'd':          case 'D':            if (format.Length > 1) {              int precision = Convert.ToInt32(format.Substring(1)' CultureInfo.InvariantCulture.NumberFormat);              string baseStr = ToString(10);              if (baseStr.Length < precision) {                string additional = new String('0'' precision - baseStr.Length);                if (baseStr[0] != '-') {                  return additional + baseStr;                } else {                  return "-" + additional + baseStr.Substring(1);                }              }              return baseStr;            }            return ToString(10);          case 'x':          case 'X':            StringBuilder res = new StringBuilder(ToString(16));            if (format[0] == 'x') {              for (int i = 0; i < res.Length; i++) {                if (res[i] >= 'A' && res[i] <= 'F') {                  res[i] = Char.ToLower(res[i]' CultureInfo.InvariantCulture);                }              }            }              if (format.Length > 1) {              int precision = Convert.ToInt32(format.Substring(1)' CultureInfo.InvariantCulture.NumberFormat);              if (res.Length < precision) {                string additional = new String('0'' precision - res.Length);                if (res[0] != '-') {                  res.Insert(0' additional);                } else {                  res.Insert(1' additional);                }              }            }              return res.ToString();          default:            throw new NotImplementedException(MathResources.FormatNotImplemented);        }
Magic Number,Microsoft.Scripting.Math,BigInteger,C:\repos\Blecki_DCPUB\Irony\Microsoft\BigInteger.cs,ToString,The following statement contains a magic number: switch (format[0]) {          case 'd':          case 'D':            if (format.Length > 1) {              int precision = Convert.ToInt32(format.Substring(1)' CultureInfo.InvariantCulture.NumberFormat);              string baseStr = ToString(10);              if (baseStr.Length < precision) {                string additional = new String('0'' precision - baseStr.Length);                if (baseStr[0] != '-') {                  return additional + baseStr;                } else {                  return "-" + additional + baseStr.Substring(1);                }              }              return baseStr;            }            return ToString(10);          case 'x':          case 'X':            StringBuilder res = new StringBuilder(ToString(16));            if (format[0] == 'x') {              for (int i = 0; i < res.Length; i++) {                if (res[i] >= 'A' && res[i] <= 'F') {                  res[i] = Char.ToLower(res[i]' CultureInfo.InvariantCulture);                }              }            }              if (format.Length > 1) {              int precision = Convert.ToInt32(format.Substring(1)' CultureInfo.InvariantCulture.NumberFormat);              if (res.Length < precision) {                string additional = new String('0'' precision - res.Length);                if (res[0] != '-') {                  res.Insert(0' additional);                } else {                  res.Insert(1' additional);                }              }            }              return res.ToString();          default:            throw new NotImplementedException(MathResources.FormatNotImplemented);        }
Magic Number,Microsoft.Scripting.Math,BigInteger,C:\repos\Blecki_DCPUB\Irony\Microsoft\BigInteger.cs,ToString,The following statement contains a magic number: switch (format[0]) {          case 'd':          case 'D':            if (format.Length > 1) {              int precision = Convert.ToInt32(format.Substring(1)' CultureInfo.InvariantCulture.NumberFormat);              string baseStr = ToString(10);              if (baseStr.Length < precision) {                string additional = new String('0'' precision - baseStr.Length);                if (baseStr[0] != '-') {                  return additional + baseStr;                } else {                  return "-" + additional + baseStr.Substring(1);                }              }              return baseStr;            }            return ToString(10);          case 'x':          case 'X':            StringBuilder res = new StringBuilder(ToString(16));            if (format[0] == 'x') {              for (int i = 0; i < res.Length; i++) {                if (res[i] >= 'A' && res[i] <= 'F') {                  res[i] = Char.ToLower(res[i]' CultureInfo.InvariantCulture);                }              }            }              if (format.Length > 1) {              int precision = Convert.ToInt32(format.Substring(1)' CultureInfo.InvariantCulture.NumberFormat);              if (res.Length < precision) {                string additional = new String('0'' precision - res.Length);                if (res[0] != '-') {                  res.Insert(0' additional);                } else {                  res.Insert(1' additional);                }              }            }              return res.ToString();          default:            throw new NotImplementedException(MathResources.FormatNotImplemented);        }
Missing Default,Irony.Parsing,CoreParser,C:\repos\Blecki_DCPUB\Irony\Parsing\Parser\CoreParser_ErrorHandling.cs,ExecuteAction,The following switch statement is missing a default case: switch (action.ActionType) {          case ParserActionType.Shift: ExecuteShift(action); break;          case ParserActionType.Operator: ExecuteOperatorAction(action); break;          case ParserActionType.Reduce: ExecuteReduce(action); break;          case ParserActionType.Code: ExecuteConflictAction (action); break;          case ParserActionType.Accept: ExecuteAccept(action); break;         }
Missing Default,Irony.Parsing,CoreParser,C:\repos\Blecki_DCPUB\Irony\Parsing\Parser\CoreParser_ErrorHandling.cs,ExecuteOperatorAction,The following switch statement is missing a default case: switch (realActionType) {          case ParserActionType.Shift: ExecuteShift(action); break;          case ParserActionType.Reduce: ExecuteReduce(action); break;         }
Missing Default,Irony.Parsing,ParserAction,C:\repos\Blecki_DCPUB\Irony\Parsing\Data\ParserData.cs,ToString,The following switch statement is missing a default case: switch (this.ActionType) {          case ParserActionType.Shift: return string.Format(Resources.LabelActionShift' NewState.Name);          case ParserActionType.Reduce: return string.Format(Resources.LabelActionReduce' ReduceProduction.ToStringQuoted());          case ParserActionType.Operator: return string.Format(Resources.LabelActionOp' NewState.Name' ReduceProduction.ToStringQuoted());          case ParserActionType.Accept: return Resources.LabelActionAccept;        }
Missing Default,Irony.Parsing,NumberLiteral,C:\repos\Blecki_DCPUB\Irony\Parsing\Terminals\NumberLiteral.cs,ConvertValue,The following switch statement is missing a default case: switch (details.TypeCodes[0]) {          case TypeCode.Int32:             if (QuickConvertToInt32(details)) return true;            break;          case TypeCode.Double:            if (QuickConvertToDouble(details)) return true;            break;        }
Missing Default,Irony.Parsing,NumberLiteral,C:\repos\Blecki_DCPUB\Irony\Parsing\Terminals\NumberLiteral.cs,ConvertValue,The following switch statement is missing a default case: switch (typeCode) {            case TypeCode.Single:   case TypeCode.Double:  case TypeCode.Decimal:  case TypeCodeImaginary:              return ConvertToFloat(typeCode' details);            case TypeCode.SByte:    case TypeCode.Byte:    case TypeCode.Int16:    case TypeCode.UInt16:            case TypeCode.Int32:    case TypeCode.UInt32:  case TypeCode.Int64:    case TypeCode.UInt64:              if (details.Value == null) //if it is not done yet                TryConvertToLong(details' typeCode == TypeCode.UInt64); //try to convert to Long/Ulong and place the result into details.Value field;              if(TryCastToIntegerType(typeCode' details)) //now try to cast the ULong value to the target type                 return true;              break;            case TypeCodeBigInt:              if (ConvertToBigInteger(details)) return true;              break;           }
Missing Default,Irony.Parsing,NumberLiteral,C:\repos\Blecki_DCPUB\Irony\Parsing\Terminals\NumberLiteral.cs,ConvertToFloat,The following switch statement is missing a default case: switch (typeCode) {          case TypeCode.Double:          case TypeCodeImaginary:            double dValue;            if (!Double.TryParse(body' NumberStyles.Float' CultureInfo.InvariantCulture' out dValue)) return false;            if (typeCode == TypeCodeImaginary)              details.Value = new Complex64(0' dValue);            else              details.Value = dValue;             return true;          case TypeCode.Single:            float fValue;            if (!Single.TryParse(body' NumberStyles.Float' CultureInfo.InvariantCulture' out fValue)) return false;            details.Value = fValue;            return true;           case TypeCode.Decimal:            decimal decValue;            if (!Decimal.TryParse(body' NumberStyles.Float' CultureInfo.InvariantCulture' out decValue)) return false;            details.Value = decValue;            return true;          }
Missing Default,Irony.Parsing,StringLiteral,C:\repos\Blecki_DCPUB\Irony\Parsing\Terminals\StringLiteral.cs,HandleSpecialEscape,The following switch statement is missing a default case: switch (first) {          case 'u':          case 'U':            if (details.IsSet((short)StringOptions.AllowsUEscapes)) {              len = (first == 'u' ? 4 : 8);              if (segment.Length < len + 1) {                details.Error = string.Format(Resources.ErrBadUnEscape' segment.Substring(len + 1)' len);// "Invalid unicode escape ({0})' expected {1} hex digits."                return segment;              }              digits = segment.Substring(1' len);              ch = (char) Convert.ToUInt32(digits' 16);              result = ch + segment.Substring(len + 1);              return result;             }//if            break;          case 'x':            if (details.IsSet((short)StringOptions.AllowsXEscapes)) {              //x-escape allows variable number of digits' from one to 4; let's count them              p = 1; //current position              while (p < 5 && p < segment.Length) {                if (Strings.HexDigits.IndexOf(segment[p]) < 0) break;                p++;              }              //p now point to char right after the last digit              if (p <= 1) {                details.Error = Resources.ErrBadXEscape; // @"Invalid \x escape' at least one digit expected.";                return segment;              }              digits = segment.Substring(1' p - 1);              ch = (char) Convert.ToUInt32(digits' 16);              result = ch + segment.Substring(p);              return result;            }//if            break;          case '0':  case '1':  case '2':  case '3':  case '4':  case '5':   case '6': case '7':            if (details.IsSet((short)StringOptions.AllowsOctalEscapes)) {              //octal escape allows variable number of digits' from one to 3; let's count them              p = 0; //current position              while (p < 3 && p < segment.Length) {                if (Strings.OctalDigits.IndexOf(segment[p]) < 0) break;                p++;              }              //p now point to char right after the last digit              digits = segment.Substring(0' p);              ch = (char)Convert.ToUInt32(digits' 8);              result = ch + segment.Substring(p);              return result;            }//if            break;        }
Missing Default,Irony.Parsing,IdentifierTerminal,C:\repos\Blecki_DCPUB\Irony\Parsing\Terminals\IdentifierTerminal.cs,Init,The following switch statement is missing a default case: switch(CaseRestriction) {          case CaseRestriction.AllLower:          case CaseRestriction.FirstLower:            AllFirstChars = AllFirstChars.ToLower();            break;          case CaseRestriction.AllUpper:          case CaseRestriction.FirstUpper:            AllFirstChars = AllFirstChars.ToUpper();            break;        }
Missing Default,Irony.Parsing,IdentifierTerminal,C:\repos\Blecki_DCPUB\Irony\Parsing\Terminals\IdentifierTerminal.cs,AdjustCasing,The following switch statement is missing a default case: switch(CaseRestriction) {          case CaseRestriction.None: break;           case CaseRestriction.FirstLower:            AllFirstChars = AllFirstChars.ToLower();            break;           case CaseRestriction.FirstUpper:            AllFirstChars = AllFirstChars.ToUpper();            break;           case CaseRestriction.AllLower:            AllFirstChars = AllFirstChars.ToLower();            AllChars = AllChars.ToLower();             break;           case CaseRestriction.AllUpper:            AllFirstChars = AllFirstChars.ToUpper();            AllChars = AllChars.ToUpper();             break;         }
Missing Default,Irony.Parsing,CodeOutlineFilter,C:\repos\Blecki_DCPUB\Irony\Parsing\TokenFilters\CodeOutlineFilter.cs,ProcessEofToken,The following switch statement is missing a default case: switch (_context.Mode) {          case ParseMode.File:            pushDedents = _produceIndents; //Do dedents if token filter tracks indents            break;          case ParseMode.CommandLine:            //only if user entered empty line' we dedent all            pushDedents = _produceIndents && _doubleEof;            pushEos = !_prevIsContinuation && !_doubleEof; //if previous symbol is continuation symbol then don't push Eos            break;          case ParseMode.VsLineScan:            pushDedents = false; //Do not dedent at all on every line end            break;        }
Missing Default,Irony.Interpreter.Ast,StringTemplateNode,C:\repos\Blecki_DCPUB\Irony\Interpreter\Ast\PrimitiveNodes\StringTemplateNode.cs,EvaluateNode,The following switch statement is missing a default case: switch (mode) {          case AstMode.Read:             var value = BuildString(context);             context.Data.Push(value);             break;          case AstMode.Write:             context.ThrowError(Resources.ErrAssignLiteralValue);              break;          }
Missing Default,Irony.Interpreter.Ast,StringTemplateNode,C:\repos\Blecki_DCPUB\Irony\Interpreter\Ast\PrimitiveNodes\StringTemplateNode.cs,BuildString,The following switch statement is missing a default case: switch(segment.Type) {            case SegmentType.Text:               values[i] = segment.Text;               break;             case SegmentType.Expression:               values[i] = EvaluateExpression(context' segment);              context.Data.PopUntil(initialStackCount);              break;           }
Missing Default,Irony.Interpreter.Ast,LiteralValueNode,C:\repos\Blecki_DCPUB\Irony\Interpreter\Ast\PrimitiveNodes\LiteralValueNode.cs,EvaluateNode,The following switch statement is missing a default case: switch (mode) {          case AstMode.Read:             context.Data.Push(Value);             break;          case AstMode.Write:             context.ThrowError(Resources.ErrAssignLiteralValue);              break;          }
Missing Default,Irony.Interpreter.Ast,IdentifierNode,C:\repos\Blecki_DCPUB\Irony\Interpreter\Ast\PrimitiveNodes\IdentifierNode.cs,EvaluateNode,The following switch statement is missing a default case: switch (mode) {          case AstMode.Read:            object value;            if (context.TryGetValue(Symbol' out value))              context.Data.Push(value);             else               context.ThrowError(Resources.ErrVarNotDefined' Symbol);            break;           case AstMode.Write:            context.SetValue(Symbol' context.Data.Pop());             break;         }
Missing Default,Irony.Interpreter,CommandLine,C:\repos\Blecki_DCPUB\Irony\Interpreter\CommandLine.cs,RunImpl,The following switch statement is missing a default case: switch (result) {            case ReadResult.AbortYes: return; //exit            case ReadResult.AbortNo: continue; //while loop            case ReadResult.Script: break; //do nothing' continue to evaluate script          }
Missing Default,Irony.Interpreter,LanguageRuntime,C:\repos\Blecki_DCPUB\Irony\Interpreter\LanguageRuntime_Init.cs,GetUpType,The following switch statement is missing a default case: switch (type.Name) {          case "Byte":          case "SByte":          case "Int16":          case "UInt16":          case "Int32":          case "UInt32":            return typeof(Int64);          case "Int64":          case "UInt64":            return typeof(BigInteger);          case "Single":            return typeof(double);        }
Missing Default,Microsoft.Scripting.Math,TypeConvertor,C:\repos\Blecki_DCPUB\Irony\Microsoft\BigInteger.cs,ConvertFrom,The following switch statement is missing a default case: switch (Type.GetTypeCode(vt)) {              case TypeCode.Byte:                return BigInteger.Create((byte)value);              case TypeCode.Char:                return BigInteger.Create((char)value);              case TypeCode.Int16:                return BigInteger.Create((short)value);              case TypeCode.Int32:                return BigInteger.Create((int)value);              case TypeCode.Int64:                return BigInteger.Create((long)value);              case TypeCode.SByte:                return BigInteger.Create((sbyte)value);              case TypeCode.UInt16:                return BigInteger.Create((ushort)value);              case TypeCode.UInt32:                return BigInteger.Create((uint)value);              case TypeCode.UInt64:                return BigInteger.Create((ulong)value);              case TypeCode.Decimal:                return BigInteger.Create((decimal)value);              case TypeCode.Single:                return BigInteger.Create((float)value);              case TypeCode.Double:                return BigInteger.Create((double)value);            }
Missing Default,Microsoft.Scripting.Math,TypeConvertor,C:\repos\Blecki_DCPUB\Irony\Microsoft\BigInteger.cs,ConvertTo,The following switch statement is missing a default case: switch (Type.GetTypeCode(vt)) {              case TypeCode.Byte:                return bi.ToByte(null);              case TypeCode.Char:                return bi.ToChar(null);              case TypeCode.Int16:                return bi.ToInt16(null);              case TypeCode.Int32:                return bi.ToInt32(null);              case TypeCode.Int64:                return bi.ToInt64(null);              case TypeCode.SByte:                return bi.ToSByte(null);              case TypeCode.UInt16:                return bi.ToUInt16(null);              case TypeCode.UInt32:                return bi.ToUInt32(null);              case TypeCode.UInt64:                return bi.ToUInt64(null);              case TypeCode.Decimal:                return bi.ToDecimal(null);              case TypeCode.Single:                return bi.ToSingle(null);              case TypeCode.Double:                return bi.ToDouble(null);            }
