Implementation smell,Namespace,Class,File,Method,Description
Long Method,NuoDb.Data.Client,NuoDbBulkLoader,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbBulkLoader.cs,WriteToServer,The method has 132 lines of code.
Long Method,NuoDb.Data.Client,NuoDbCommand,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbCommand.cs,Prepare,The method has 245 lines of code.
Long Method,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,doOpen,The method has 319 lines of code.
Long Method,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The method has 759 lines of code.
Long Method,NuoDb.Data.Client,NuoDbDataReader,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbDataReader.cs,GetSchemaTable,The method has 148 lines of code.
Long Method,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,decode,The method has 538 lines of code.
Long Method,NuoDb.Data.Client.Security,BigInteger,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,multiByteDivide,The method has 121 lines of code.
Complex Method,NuoDb.Data.Client,NuoDbBulkLoader,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbBulkLoader.cs,WriteToServer,Cyclomatic complexity of the method is 22
Complex Method,NuoDb.Data.Client,NuoDbCommand,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbCommand.cs,ExecuteBatch,Cyclomatic complexity of the method is 10
Complex Method,NuoDb.Data.Client,NuoDbCommand,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbCommand.cs,Prepare,Cyclomatic complexity of the method is 42
Complex Method,NuoDb.Data.Client,NuoDbMultipleCommands,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbMultipleCommands.cs,splitStatements,Cyclomatic complexity of the method is 11
Complex Method,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,BeginDbTransaction,Cyclomatic complexity of the method is 8
Complex Method,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,doOpen,Cyclomatic complexity of the method is 23
Complex Method,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,Cyclomatic complexity of the method is 78
Complex Method,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapDbTypeToNetType,Cyclomatic complexity of the method is 11
Complex Method,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapNuoDbToNetType,Cyclomatic complexity of the method is 11
Complex Method,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapJavaSqlToDbType,Cyclomatic complexity of the method is 16
Complex Method,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapDbTypeToJavaSql,Cyclomatic complexity of the method is 12
Complex Method,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,Cyclomatic complexity of the method is 8
Complex Method,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,Cyclomatic complexity of the method is 17
Complex Method,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,encodeDotNetObject,Cyclomatic complexity of the method is 19
Complex Method,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,decode,Cyclomatic complexity of the method is 50
Complex Method,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,getValue,Cyclomatic complexity of the method is 15
Complex Method,NuoDb.Data.Client.Security,BigInteger,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,BigInteger,Cyclomatic complexity of the method is 12
Complex Method,NuoDb.Data.Client.Security,BigInteger,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,BigInteger,Cyclomatic complexity of the method is 8
Complex Method,NuoDb.Data.Client.Security,BigInteger,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,BigInteger,Cyclomatic complexity of the method is 9
Complex Method,NuoDb.Data.Client.Security,BigInteger,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,multiByteDivide,Cyclomatic complexity of the method is 16
Complex Method,NuoDb.Data.Client.Security,BigInteger,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,singleByteDivide,Cyclomatic complexity of the method is 10
Complex Method,NuoDb.Data.Client.Security,BigInteger,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,modPow,Cyclomatic complexity of the method is 11
Complex Method,NuoDb.Data.Client.Security,BigInteger,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,BarrettReduction,Cyclomatic complexity of the method is 13
Complex Method,NuoDb.Data.Client.Xml,Doc,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Xml\Doc.cs,parseText,Cyclomatic complexity of the method is 12
Complex Method,NuoDb.Data.Client.Xml,Doc,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Xml\Doc.cs,processEscapes,Cyclomatic complexity of the method is 15
Complex Method,NuoDb.Data.Client.Xml,Doc,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Xml\Doc.cs,getString,Cyclomatic complexity of the method is 10
Complex Method,NuoDb.Data.Client.Xml,Tag,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Xml\Tag.cs,parseChildren,Cyclomatic complexity of the method is 10
Complex Method,NuoDb.Data.Client.Xml,Tag,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Xml\Tag.cs,gen,Cyclomatic complexity of the method is 8
Long Parameter List,NuoDb.Data.Client,TypedDbReader,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbMultipleCommands.cs,GetBytes,The method has 5 parameters. Parameters: ordinal' dataOffset' buffer' bufferOffset' length
Long Parameter List,NuoDb.Data.Client,TypedDbReader,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbMultipleCommands.cs,GetChars,The method has 5 parameters. Parameters: ordinal' dataOffset' buffer' bufferOffset' length
Long Parameter List,NuoDb.Data.Client,NuoDbDataReader,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbDataReader.cs,NuoDbDataReader,The method has 5 parameters. Parameters: connection' handle' dataStream' statement' readColumnNames
Long Parameter List,NuoDb.Data.Client,NuoDbDataReader,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbDataReader.cs,GetBytes,The method has 5 parameters. Parameters: i' fieldOffset' buffer' bufferoffset' length
Long Parameter List,NuoDb.Data.Client,NuoDbDataReader,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbDataReader.cs,GetChars,The method has 5 parameters. Parameters: i' fieldoffset' buffer' bufferoffset' length
Long Parameter List,NuoDb.Data.Client.Util,StringUtils,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\StringUtils.cs,overwrite,The method has 5 parameters. Parameters: origString' pos' newString' newPos' newLength
Long Identifier,NuoDb.Data.Client,Protocol,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Protocol.cs,,The length of the parameter DbmbDefaultTransactionIsolation is 31.
Long Statement,NuoDb.Data.Client,NuoDbBulkLoader,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbBulkLoader.cs,WriteToServer,The length of the statement  "                            throw new IndexOutOfRangeException(String.Format("The specified ordinal of the target column ({0}) is outside the range of the column count ({1}) of table {2}"'" is 160.
Long Statement,NuoDb.Data.Client,NuoDbBulkLoader,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbBulkLoader.cs,WriteToServer,The length of the statement  "                            throw new IndexOutOfRangeException(String.Format("The specified ordinal of the source column ({0}) is outside the range of the column count ({1})"'" is 147.
Long Statement,NuoDb.Data.Client,NuoDbBulkLoader,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbBulkLoader.cs,WriteToServer,The length of the statement  "            WriteToServer(table' DataRowState.Added | DataRowState.Deleted | DataRowState.Detached | DataRowState.Modified | DataRowState.Unchanged);" is 137.
Long Statement,NuoDb.Data.Client,IsolationLevelsListConverter,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionStringBuilder.cs,GetStandardValues,The length of the statement  "            return new StandardValuesCollection(new string[] { ""' "ReadCommitted"' "WriteCommitted"' "ConsistentRead"' "Serializable"});" is 125.
Long Statement,NuoDb.Data.Client,NuoDbCommand,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbCommand.cs,updateLastCommitInfo,The length of the statement  "            if (connection.InternalConnection.protocolVersion >= Protocol.PROTOCOL_VERSION2 && connection.InternalConnection.protocolVersion < Protocol.PROTOCOL_VERSION7 && generatingKeys)" is 176.
Long Statement,NuoDb.Data.Client,NuoDbCommand,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbCommand.cs,updateLastCommitInfo,The length of the statement  "            if ((connection.InternalConnection.protocolVersion >= Protocol.PROTOCOL_VERSION3 && !generatingKeys) || connection.InternalConnection.protocolVersion >= Protocol.PROTOCOL_VERSION7)" is 180.
Long Statement,NuoDb.Data.Client,NuoDbCommand,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbCommand.cs,ExecuteBatch,The length of the statement  "            ExecuteBatch(parameters' DataRowState.Added | DataRowState.Deleted | DataRowState.Detached | DataRowState.Modified | DataRowState.Unchanged);" is 141.
Long Statement,NuoDb.Data.Client,NuoDbCommand,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbCommand.cs,ExecuteDbDataReader,The length of the statement  "                NuoDbDataReader reader = generatedKeys != null ? generatedKeys : new NuoDbDataReader(connection' -1' null' this' false);" is 120.
Long Statement,NuoDb.Data.Client,NuoDbCommand,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbCommand.cs,ExecuteUpdate,The length of the statement  "            if (connection.InternalConnection.protocolVersion >= Protocol.PROTOCOL_VERSION2 && connection.InternalConnection.protocolVersion < Protocol.PROTOCOL_VERSION7)" is 158.
Long Statement,NuoDb.Data.Client,NuoDbCommand,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbCommand.cs,InvokeStoredProcedure,The length of the statement  "                throw new NuoDbSqlException(String.Format("server protocol {0} doesn't support prepareCall"' connection.InternalConnection.protocolVersion));" is 141.
Long Statement,NuoDb.Data.Client,NuoDbCommand,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbCommand.cs,Prepare,The length of the statement  "            // if we are given just the name of the stored procedure' retrieve the number of parameters and generate the full command" is 121.
Long Statement,NuoDb.Data.Client,NuoDbCommand,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbCommand.cs,Prepare,The length of the statement  "                    paramTable = NuoDbConnectionInternal.GetSchemaHelper(connection' "ProcedureParameters"' new string[] { null' parts[0].Trim(quotes)' parts[1].Trim(quotes)' null });" is 163.
Long Statement,NuoDb.Data.Client,NuoDbCommand,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbCommand.cs,Prepare,The length of the statement  "                    paramTable = NuoDbConnectionInternal.GetSchemaHelper(connection' "ProcedureParameters"' new string[] { null' schema' parts[0].Trim(quotes)' null });" is 148.
Long Statement,NuoDb.Data.Client,NuoDbCommand,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbCommand.cs,Prepare,The length of the statement  "                        throw new NuoDbSqlException(String.Format("Internal error: unexpected ordering of the parameters of the procedure {0}"' nuodbSqlString));" is 137.
Long Statement,NuoDb.Data.Client,NuoDbCommand,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbCommand.cs,Prepare,The length of the statement  "                        default: throw new NuoDbSqlException(String.Format("Internal error: unexpected parameter type for procedure {0}"' nuodbSqlString));" is 131.
Long Statement,NuoDb.Data.Client,NuoDbCommand,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbCommand.cs,Prepare,The length of the statement  "                    throw new NuoDbSqlException(String.Format("server protocol {0} doesn't support prepareCall"' connection.InternalConnection.protocolVersion));" is 141.
Long Statement,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,getProcessConnection,The length of the statement  "            for (processConnection = processConnections; processConnection != null && !processConnection.isThisDatabase(databaseName); processConnection = processConnection.Next)" is 166.
Long Statement,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The length of the statement  "                // The format of this is consistent for all versions of the provider to prevent version 10 from sorting between version 1 and version 2." is 136.
Long Statement,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The length of the statement  "                // Specifies the relationship between the columns in a GROUP BY clause and the non-aggregated columns in the select list." is 121.
Long Statement,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The length of the statement  "                // A regular expression that matches an identifier and has a match value of the identifier. For example "[A-Za-z0-9_#$]"." is 121.
Long Statement,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The length of the statement  "                row["IdentifierPattern"] = "(^\\[\\p{Lo}\\p{Lu}\\p{Ll}_@#][\\p{Lo}\\p{Lu}\\p{Ll}\\p{Nd}@$#_]*$)|(^\"[^\"\\0]|\"\"+\"$)";" is 120.
Long Statement,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The length of the statement  "                // A regular expression that matches a quoted identifier and has a match value of the identifier itself without the quotes. " is 123.
Long Statement,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The length of the statement  "                table.Columns.Add("ProviderDbType"' typeof(int)); // The provider-specific type value that should be used when specifying " is 121.
Long Statement,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The length of the statement  "                table.Columns.Add("NativeDataType"' typeof(string));    // NativeDataType is an OLE DB specific column for exposing the OLE DB type of the data type ." is 150.
Long Statement,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The length of the statement  "                table.ReadXml(XmlReader.Create(typeof(NuoDbConnectionInternal).Assembly.GetManifestResourceStream("NuoDb.Data.Client.DataTypes.xml")));" is 135.
Long Statement,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The length of the statement  "                List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));" is 151.
Long Statement,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The length of the statement  "                List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));" is 151.
Long Statement,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The length of the statement  "                                System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_SCHEM"] + "." + reader["TABLE_NAME"] + "=" + reader["COLUMN_NAME"]);" is 125.
Long Statement,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The length of the statement  "                                System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_SCHEM"] + "." + reader["TABLE_NAME"] + " (Primary) =" + reader["COLUMN_NAME"]);" is 136.
Long Statement,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The length of the statement  "                List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));" is 151.
Long Statement,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The length of the statement  "                List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));" is 151.
Long Statement,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The length of the statement  "                                System.Diagnostics.Trace.WriteLine("-> " + reader["FKTABLE_SCHEM"] + "." + reader["FKTABLE_NAME"] + "=" + reader["FKCOLUMN_NAME"]);" is 131.
Long Statement,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,RetrieveMatchingTables,The length of the statement  "                            tables.Add(new KeyValuePair<string' string>(reader.GetFieldValue<string>("TABLE_SCHEM")' reader.GetFieldValue<string>("TABLE_NAME")));" is 134.
Long Statement,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,isNumeric,The length of the statement  "            string[] numeric_types = new string[] { "integer"' "int"' "smallint"' "tinyint"' "float"' "double"' "bigint"' "numeric"' "decimal" };" is 133.
Long Statement,NuoDb.Data.Client,NuoDbDataReader,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbDataReader.cs,GetSchemaTable,The length of the statement  "            // Info on the schema of this table is at http://msdn.microsoft.com/en-us/library/system.data.odbc.odbcdatareader.getschematable.aspx" is 133.
Long Statement,NuoDb.Data.Client,NuoDbDataReader,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbDataReader.cs,GetSchemaTable,The length of the statement  "            // The maximum possible length of a value in the column. For columns that use a fixed-length data type' this is the size of the data type. " is 138.
Long Statement,NuoDb.Data.Client,NuoDbDataReader,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbDataReader.cs,GetSchemaTable,The length of the statement  "            // If the underlying ODBC driver returns a precision value for a non-numeric data type' this value is used in the schema table. " is 127.
Long Statement,NuoDb.Data.Client,NuoDbDataReader,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbDataReader.cs,GetSchemaTable,The length of the statement  "            // If the underlying ODBC driver returns a precision value for a non-numeric data type' this value is used in the schema table. " is 127.
Long Statement,NuoDb.Data.Client,NuoDbDataReader,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbDataReader.cs,GetSchemaTable,The length of the statement  "            // The name of the catalog in the data store that contains the column. NULL if the base catalog name cannot be determined." is 122.
Long Statement,NuoDb.Data.Client,NuoDbDataReader,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbDataReader.cs,GetSchemaTable,The length of the statement  "            // The name of the schema in the data source that contains the column. NULL if the base catalog name cannot be determined. " is 122.
Long Statement,NuoDb.Data.Client,NuoDbDataReader,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbDataReader.cs,GetSchemaTable,The length of the statement  "            // The name of the table or view in the data store that contains the column. A null value if the base table name cannot be determined." is 134.
Long Statement,NuoDb.Data.Client,NuoDbDataReader,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbDataReader.cs,GetSchemaTable,The length of the statement  "            // The name of the column in the data store. This might be different from the column name returned in the ColumnName column if an alias was used. " is 145.
Long Statement,NuoDb.Data.Client,NuoDbDataReader,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbDataReader.cs,GetSchemaTable,The length of the statement  "            // A null value if the base column name cannot be determined or if the rowset column is derived' but not identical to' a column in the data store. " is 146.
Long Statement,NuoDb.Data.Client,NuoDbDataReader,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbDataReader.cs,GetSchemaTable,The length of the statement  "            // true if the column contains a Binary Long Object (BLOB) that contains very long data. The definition of very long data is driver-specific. " is 141.
Long Statement,NuoDb.Data.Client,NuoDbDataReader,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbDataReader.cs,GetSchemaTable,The length of the statement  "            // true if the column assigns values to new rows in fixed increments; otherwise false. The default for this column is false. " is 124.
Long Statement,NuoDb.Data.Client,NuoDbDataReader,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbDataReader.cs,GetSchemaTable,The length of the statement  "            // IsUnique is guaranteed to be true if the column represents a key by itself or if there is a constraint of type UNIQUE that applies only to this column." is 154.
Long Statement,NuoDb.Data.Client,NuoDbDataReader,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbDataReader.cs,GetSchemaTable,The length of the statement  "            // The set of columns with IsKey set to true must uniquely identify a row in the rowset. There is no requirement that this set of columns is a minimal set of columns. This set of columns may be generated from a base table primary key' a unique constraint' or a unique index." is 274.
Long Statement,NuoDb.Data.Client,NuoDbDataReader,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbDataReader.cs,GetSchemaTable,The length of the statement  "            // Set if the column contains a persistent row identifier that cannot be written to' and has no meaningful value except to identity the row. " is 140.
Long Statement,NuoDb.Data.Client,NuoDbDataReader,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbDataReader.cs,GetSchemaTable,The length of the statement  "            // true if the consumer can set the column to a null value or if the driver cannot determine whether the consumer can set the column to a null value. " is 149.
Long Statement,NuoDb.Data.Client,NuoDbDataReader,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbDataReader.cs,GetSchemaTable,The length of the statement  "                if (((DbType)row["ProviderType"] == DbType.Int16 || (DbType)row["ProviderType"] == DbType.Int32 || (DbType)row["ProviderType"] == DbType.Int64) &&" is 146.
Long Statement,NuoDb.Data.Client,NuoDbDataReader,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbDataReader.cs,GetSchemaTable,The length of the statement  "                row["DataType"] = Type.GetType(NuoDbConnectionInternal.mapNuoDbToNetType((string)row["DataTypeName"]' (int)row["NumericPrecision"]' (int)row["NumericScale"]));" is 159.
Long Statement,NuoDb.Data.Client,NuoDbDataReader,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbDataReader.cs,GetSchemaTable,The length of the statement  "                    indexInfo = connection.GetSchema("IndexColumns"' new string[] { null' (string)row["BaseSchemaName"]' (string)row["BaseTableName"] });" is 133.
Long Statement,NuoDb.Data.Client,NuoDbDataReader,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbDataReader.cs,GetSchemaTable,The length of the statement  "                DataRow[] rows = indexInfo.Select(String.Format("INDEXCOLUMN_NAME = '{0}' AND INDEXCOLUMN_ISPRIMARY = true"' row["BaseColumnName"]));" is 133.
Long Statement,NuoDb.Data.Client,NuoDbDataReader,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbDataReader.cs,findColumn,The length of the statement  "                throw new IndexOutOfRangeException(String.Format("ResultSet column index of {0}' out of bounds.  Valid range 0-{1}"' columnIndex' numberColumns-1));" is 148.
Long Statement,NuoDb.Data.Client,NuoDbDataReader,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbDataReader.cs,getValue,The length of the statement  "                throw new IndexOutOfRangeException(String.Format("ResultSet column index of {0}' out of bounds.  Valid range 0-{1}"' columnIndex' numberColumns-1));" is 148.
Long Statement,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,encodeDotNetObject,The length of the statement  "                System.Diagnostics.Trace.WriteLine(String.Format("Unsupported type of parameter: {0}' sending as a plain string"' value.GetType().Name));" is 137.
Long Statement,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,decode,The length of the statement  "                    integer32 = ((sbyte)source[offset]) << 24 | (source[offset + 1] & 0xff) << 16 | (source[offset + 2] & 0xff) << 8 | (source[offset + 3] & 0xff);" is 143.
Long Statement,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,getString,The length of the statement  "                    throw new NuoDbSqlException("On message type " + currentMessageType + ":NuoDB jdbc expected string' got type: " + type);" is 120.
Long Statement,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,getBigDecimal,The length of the statement  "            throw new NuoDbSqlException("On message type " + currentMessageType + ":NuoDB jdbc expected BigDecimal got type: " + type);" is 123.
Long Statement,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,getBoolean,The length of the statement  "            throw new NuoDbSqlException("On message type " + currentMessageType + ":NuoDB jdbc expected boolean' got type: " + type);" is 121.
Long Statement,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,getValue,The length of the statement  "            throw new NuoDbSqlException("On message type " + currentMessageType + ":NuoDB jdbc decode value type " + type + " not yet implemented");" is 136.
Long Statement,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,encodeTime,The length of the statement  "                throw new NuoDbSqlException(String.Format("Unable to encode \"{0}\".  Need {1} bytes to encode but only have {2} bytes."' time' count' edsTimeLen4 - edsTimeLen0));" is 163.
Long Statement,NuoDb.Data.Client.Security,BigInteger,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,modPow,The length of the statement  "                        // NuoDB CHANGED!!! The original code was returning -resultNum' but the Java BigInteger adds the negative remainder to the modulus instead" is 138.
Long Statement,NuoDb.Data.Client.Security,BigInteger,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,modPow,The length of the statement  "            // NuoDB CHANGED!!! The original code was returning -resultNum' but the Java BigInteger adds the negative remainder to the modulus instead" is 138.
Long Statement,NuoDb.Data.Client.Security,RemoteGroup,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\RemoteGroup.cs,getGroup,The length of the statement  "				string prime = "EEAF0AB9ADB38DD69C33F80AFA8FC5E86072618775FF3C0B9EA2314C" + "9C256576D674DF7496EA81D3383B4813D692C6E0E0D5D8E250B98BE4" + "8E495C1D6089DAD15DC7D7B46154D6B6CE8EF4AD69B15D4982559B29" + "7BCF1885C529F566660E57EC68EDBC3C05726CC02FD4CBF4976EAA9A" + "FD5138FE8376435B9FC61D2FC0EB06E3";" is 294.
Long Statement,NuoDb.Data.Client.Util,StringUtils,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\StringUtils.cs,overwrite,The length of the statement  "				throw new System.IndexOutOfRangeException(String.Format("position {0} exceeds the length of the string {1}"' pos' origString.Length));" is 134.
Complex Conditional,NuoDb.Data.Client,NuoDbCommand,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbCommand.cs,Close,The conditional expression  "handle == -1 || connection == null || (connection as IDbConnection).State == ConnectionState.Closed ||                 !connection.InternalConnection.IsCommandRegistered(handle)"  is complex.
Complex Conditional,NuoDb.Data.Client,NuoDbCommand,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbCommand.cs,ExecuteDbDataReader,The conditional expression  "CommandType == CommandType.Text &&                 !trimmedSql.StartsWith("SELECT "' StringComparison.InvariantCultureIgnoreCase) &&                 !trimmedSql.StartsWith("CALL "' StringComparison.InvariantCultureIgnoreCase) &&                 !trimmedSql.StartsWith("EXECUTE "' StringComparison.InvariantCultureIgnoreCase)"  is complex.
Complex Conditional,NuoDb.Data.Client,NuoDbCommand,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbCommand.cs,Prepare,The conditional expression  "(c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || c == '_' ||                         (curParamName.Length > 0 && ((c >= '0' && c <= '9') || c == '-'))"  is complex.
Complex Conditional,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The conditional expression  "restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                     !restrictionValues[3].Equals(reader.GetFieldValue<string>("INDEX_NAME"))"  is complex.
Complex Conditional,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The conditional expression  "restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                     !restrictionValues[3].Equals(reader.GetFieldValue<string>(indexName))"  is complex.
Complex Conditional,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The conditional expression  "restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                     !restrictionValues[3].Equals(reader.GetFieldValue<string>("INDEX_NAME"))"  is complex.
Complex Conditional,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The conditional expression  "restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                     !restrictionValues[3].Equals(reader.GetFieldValue<string>(indexName))"  is complex.
Complex Conditional,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The conditional expression  "restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                     !restrictionValues[3].Equals(name)"  is complex.
Complex Conditional,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The conditional expression  "restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                     !restrictionValues[3].Equals(name)"  is complex.
Complex Conditional,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapNuoDbToNetType,The conditional expression  "p == "string" || p == "char" || p == "varchar" || p == "longvarchar""  is complex.
Complex Conditional,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapNuoDbToNetType,The conditional expression  "p == "tinyint" || p == "smallint" || p == "integer" || p == "numeric" || p == "decimal""  is complex.
Complex Conditional,NuoDb.Data.Client,NuoDbDataReader,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbDataReader.cs,closeCurrentResultSet,The conditional expression  "closed || handle == -1 || connection == null || (connection as IDbConnection).State == ConnectionState.Closed ||                 !connection.InternalConnection.IsResultSetRegistered(handle)"  is complex.
Complex Conditional,NuoDb.Data.Client,NuoDbDataReader,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbDataReader.cs,GetSchemaTable,The conditional expression  "((DbType)row["ProviderType"] == DbType.Int16 || (DbType)row["ProviderType"] == DbType.Int32 || (DbType)row["ProviderType"] == DbType.Int64) &&                     (int)row["NumericScale"] != 0"  is complex.
Complex Conditional,NuoDb.Data.Client.Util,StringUtils,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\StringUtils.cs,Equals,The conditional expression  "(one == null && two != null) || (one != null && two == null)"  is complex.
Complex Conditional,NuoDb.Data.Client.Xml,Doc,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Xml\Doc.cs,skipWhite,The conditional expression  "c != ' ' && c != '\t' && c != '\n' && c != '\r'"  is complex.
Virtual Method Call from Constructor,NuoDb.Data.Client,DataSegment,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\DataStream.cs,DataSegment,The constructor "DataSegment" calls a virtual method "allocate".
Virtual Method Call from Constructor,NuoDb.Data.Client.Xml,Attribute,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Xml\Attribute.cs,Attribute,The constructor "Attribute" calls a virtual method "parse".
Virtual Method Call from Constructor,NuoDb.Data.Client.Xml,Tag,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Xml\Tag.cs,Tag,The constructor "Tag" calls a virtual method "parseAttributes".
Virtual Method Call from Constructor,NuoDb.Data.Client.Xml,Tag,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Xml\Tag.cs,Tag,The constructor "Tag" calls a virtual method "parseChildren".
Virtual Method Call from Constructor,NuoDb.Data.Client.Xml,Tag,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Xml\Tag.cs,Tag,The constructor "Tag" calls a virtual method "parseText".
Empty Catch Block,NuoDb.Data.Client,NuoDbCommand,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbCommand.cs,Dispose,The method has an empty catch block.
Empty Catch Block,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,Dispose,The method has an empty catch block.
Empty Catch Block,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,doOpen,The method has an empty catch block.
Empty Catch Block,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,doOpen,The method has an empty catch block.
Empty Catch Block,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The method has an empty catch block.
Empty Catch Block,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The method has an empty catch block.
Empty Catch Block,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The method has an empty catch block.
Empty Catch Block,NuoDb.Data.Client,NuoDbDataReader,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbDataReader.cs,GetValue,The method has an empty catch block.
Empty Catch Block,NuoDb.Data.Client.Security,BigInteger,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,ToString,The method has an empty catch block.
Magic Number,NuoDb.Data.Client,OlsonDatabase,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\SQLContext.cs,FindOlsonTimeZone,The following statement contains a magic number: parts.Length >= 2
Magic Number,NuoDb.Data.Client,NuoDbCommand,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbCommand.cs,Prepare,The following statement contains a magic number: parts.Length == 2
Magic Number,NuoDb.Data.Client,NuoDbCommand,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbCommand.cs,Prepare,The following statement contains a magic number: switch (direction)                     {                         case 1: paramDirection = ParameterDirection.Input; break;                         case 2: paramDirection = ParameterDirection.InputOutput; break;                         case 4: paramDirection = ParameterDirection.Output; break;                         default: throw new NuoDbSqlException(String.Format("Internal error: unexpected parameter type for procedure {0}"' nuodbSqlString));                     }
Magic Number,NuoDb.Data.Client,NuoDbCommand,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbCommand.cs,Prepare,The following statement contains a magic number: switch (direction)                     {                         case 1: paramDirection = ParameterDirection.Input; break;                         case 2: paramDirection = ParameterDirection.InputOutput; break;                         case 4: paramDirection = ParameterDirection.Output; break;                         default: throw new NuoDbSqlException(String.Format("Internal error: unexpected parameter type for procedure {0}"' nuodbSqlString));                     }
Magic Number,NuoDb.Data.Client,NuoDbCommand,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbCommand.cs,Prepare,The following statement contains a magic number: switch (direction)                     {                         case 0: newParams[i].Direction = ParameterDirection.Input; break;                         case 1: newParams[i].Direction = ParameterDirection.InputOutput; break;                         case 2: newParams[i].Direction = ParameterDirection.Output; break;                     }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,BeginDbTransaction,The following statement contains a magic number: switch (isolationLevel)             {                 case IsolationLevel.Unspecified: level = 0; break;                 case IsolationLevel.ReadUncommitted: level = 1; break;                 case IsolationLevel.ReadCommitted: level = 2; break;                 case IsolationLevel.RepeatableRead: level = 4; break;                 case IsolationLevel.Serializable: level = 8; break;                 default:                     throw new NotSupportedException("The specified transaction isolation level is not supported");             }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,BeginDbTransaction,The following statement contains a magic number: switch (isolationLevel)             {                 case IsolationLevel.Unspecified: level = 0; break;                 case IsolationLevel.ReadUncommitted: level = 1; break;                 case IsolationLevel.ReadCommitted: level = 2; break;                 case IsolationLevel.RepeatableRead: level = 4; break;                 case IsolationLevel.Serializable: level = 8; break;                 default:                     throw new NotSupportedException("The specified transaction isolation level is not supported");             }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,BeginDbTransaction,The following statement contains a magic number: switch (isolationLevel)             {                 case IsolationLevel.Unspecified: level = 0; break;                 case IsolationLevel.ReadUncommitted: level = 1; break;                 case IsolationLevel.ReadCommitted: level = 2; break;                 case IsolationLevel.RepeatableRead: level = 4; break;                 case IsolationLevel.Serializable: level = 8; break;                 default:                     throw new NotSupportedException("The specified transaction isolation level is not supported");             }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,doOpen,The following statement contains a magic number: level = 2;
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapJavaSqlToDbType,The following statement contains a magic number: switch (jSQL)             {                 case -7: //BIT                     return DbType.Boolean;                 case -6: //TINYINT                 case 5: //SMALLINT                 case 4: //INTEGER                     return DbType.Int32;                 case -5: //BIGINT                     return DbType.Int64;                 case 6: //FLOAT                 case 7: //REAL                     return DbType.Single;                 case 8: //DOUBLE                     return DbType.Double;                 case 2: //NUMERIC                 case 3: //DECIMAL                     return DbType.Decimal;                 case 1: //CHAR                 case 12: //VARCHAR                 case -1: //LONGVARCHAR                     return DbType.String;                 case 91: //DATE                     return DbType.Date;                 case 92: //TIME                     return DbType.Time;                 case 93: //TIMESTAMP                     return DbType.DateTime;                 case -2: //BINARY                 case -3: //VARBINARY                 case -4: //LONGVARBINARY                     return DbType.Binary;                 case 0: //NULL                 case 1111: //OTHER                 case 2000: //JAVA_OBJECT                 case 2001: //DISTINCT                 case 2002: //STRUCT                 case 2003: //ARRAY                 case 2004: //BLOB                 case 2005: //CLOB                 case 2006: //REF                 case 70: //DATALINK                     return DbType.Object;                 case 16: //BOOLEAN                     return DbType.Boolean;                 //------------------------- JDBC 4.0 -----------------------------------                 case -15: //NCHAR                 case -9: //NVARCHAR                  case -16: //LONGNVARCHAR                 case 2011: //NCLOB                     return DbType.String;                 case 2009: //SQLXML                      return DbType.Xml;                 case -8: //ROWID                     return DbType.Object;             }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapJavaSqlToDbType,The following statement contains a magic number: switch (jSQL)             {                 case -7: //BIT                     return DbType.Boolean;                 case -6: //TINYINT                 case 5: //SMALLINT                 case 4: //INTEGER                     return DbType.Int32;                 case -5: //BIGINT                     return DbType.Int64;                 case 6: //FLOAT                 case 7: //REAL                     return DbType.Single;                 case 8: //DOUBLE                     return DbType.Double;                 case 2: //NUMERIC                 case 3: //DECIMAL                     return DbType.Decimal;                 case 1: //CHAR                 case 12: //VARCHAR                 case -1: //LONGVARCHAR                     return DbType.String;                 case 91: //DATE                     return DbType.Date;                 case 92: //TIME                     return DbType.Time;                 case 93: //TIMESTAMP                     return DbType.DateTime;                 case -2: //BINARY                 case -3: //VARBINARY                 case -4: //LONGVARBINARY                     return DbType.Binary;                 case 0: //NULL                 case 1111: //OTHER                 case 2000: //JAVA_OBJECT                 case 2001: //DISTINCT                 case 2002: //STRUCT                 case 2003: //ARRAY                 case 2004: //BLOB                 case 2005: //CLOB                 case 2006: //REF                 case 70: //DATALINK                     return DbType.Object;                 case 16: //BOOLEAN                     return DbType.Boolean;                 //------------------------- JDBC 4.0 -----------------------------------                 case -15: //NCHAR                 case -9: //NVARCHAR                  case -16: //LONGNVARCHAR                 case 2011: //NCLOB                     return DbType.String;                 case 2009: //SQLXML                      return DbType.Xml;                 case -8: //ROWID                     return DbType.Object;             }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapJavaSqlToDbType,The following statement contains a magic number: switch (jSQL)             {                 case -7: //BIT                     return DbType.Boolean;                 case -6: //TINYINT                 case 5: //SMALLINT                 case 4: //INTEGER                     return DbType.Int32;                 case -5: //BIGINT                     return DbType.Int64;                 case 6: //FLOAT                 case 7: //REAL                     return DbType.Single;                 case 8: //DOUBLE                     return DbType.Double;                 case 2: //NUMERIC                 case 3: //DECIMAL                     return DbType.Decimal;                 case 1: //CHAR                 case 12: //VARCHAR                 case -1: //LONGVARCHAR                     return DbType.String;                 case 91: //DATE                     return DbType.Date;                 case 92: //TIME                     return DbType.Time;                 case 93: //TIMESTAMP                     return DbType.DateTime;                 case -2: //BINARY                 case -3: //VARBINARY                 case -4: //LONGVARBINARY                     return DbType.Binary;                 case 0: //NULL                 case 1111: //OTHER                 case 2000: //JAVA_OBJECT                 case 2001: //DISTINCT                 case 2002: //STRUCT                 case 2003: //ARRAY                 case 2004: //BLOB                 case 2005: //CLOB                 case 2006: //REF                 case 70: //DATALINK                     return DbType.Object;                 case 16: //BOOLEAN                     return DbType.Boolean;                 //------------------------- JDBC 4.0 -----------------------------------                 case -15: //NCHAR                 case -9: //NVARCHAR                  case -16: //LONGNVARCHAR                 case 2011: //NCLOB                     return DbType.String;                 case 2009: //SQLXML                      return DbType.Xml;                 case -8: //ROWID                     return DbType.Object;             }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapJavaSqlToDbType,The following statement contains a magic number: switch (jSQL)             {                 case -7: //BIT                     return DbType.Boolean;                 case -6: //TINYINT                 case 5: //SMALLINT                 case 4: //INTEGER                     return DbType.Int32;                 case -5: //BIGINT                     return DbType.Int64;                 case 6: //FLOAT                 case 7: //REAL                     return DbType.Single;                 case 8: //DOUBLE                     return DbType.Double;                 case 2: //NUMERIC                 case 3: //DECIMAL                     return DbType.Decimal;                 case 1: //CHAR                 case 12: //VARCHAR                 case -1: //LONGVARCHAR                     return DbType.String;                 case 91: //DATE                     return DbType.Date;                 case 92: //TIME                     return DbType.Time;                 case 93: //TIMESTAMP                     return DbType.DateTime;                 case -2: //BINARY                 case -3: //VARBINARY                 case -4: //LONGVARBINARY                     return DbType.Binary;                 case 0: //NULL                 case 1111: //OTHER                 case 2000: //JAVA_OBJECT                 case 2001: //DISTINCT                 case 2002: //STRUCT                 case 2003: //ARRAY                 case 2004: //BLOB                 case 2005: //CLOB                 case 2006: //REF                 case 70: //DATALINK                     return DbType.Object;                 case 16: //BOOLEAN                     return DbType.Boolean;                 //------------------------- JDBC 4.0 -----------------------------------                 case -15: //NCHAR                 case -9: //NVARCHAR                  case -16: //LONGNVARCHAR                 case 2011: //NCLOB                     return DbType.String;                 case 2009: //SQLXML                      return DbType.Xml;                 case -8: //ROWID                     return DbType.Object;             }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapJavaSqlToDbType,The following statement contains a magic number: switch (jSQL)             {                 case -7: //BIT                     return DbType.Boolean;                 case -6: //TINYINT                 case 5: //SMALLINT                 case 4: //INTEGER                     return DbType.Int32;                 case -5: //BIGINT                     return DbType.Int64;                 case 6: //FLOAT                 case 7: //REAL                     return DbType.Single;                 case 8: //DOUBLE                     return DbType.Double;                 case 2: //NUMERIC                 case 3: //DECIMAL                     return DbType.Decimal;                 case 1: //CHAR                 case 12: //VARCHAR                 case -1: //LONGVARCHAR                     return DbType.String;                 case 91: //DATE                     return DbType.Date;                 case 92: //TIME                     return DbType.Time;                 case 93: //TIMESTAMP                     return DbType.DateTime;                 case -2: //BINARY                 case -3: //VARBINARY                 case -4: //LONGVARBINARY                     return DbType.Binary;                 case 0: //NULL                 case 1111: //OTHER                 case 2000: //JAVA_OBJECT                 case 2001: //DISTINCT                 case 2002: //STRUCT                 case 2003: //ARRAY                 case 2004: //BLOB                 case 2005: //CLOB                 case 2006: //REF                 case 70: //DATALINK                     return DbType.Object;                 case 16: //BOOLEAN                     return DbType.Boolean;                 //------------------------- JDBC 4.0 -----------------------------------                 case -15: //NCHAR                 case -9: //NVARCHAR                  case -16: //LONGNVARCHAR                 case 2011: //NCLOB                     return DbType.String;                 case 2009: //SQLXML                      return DbType.Xml;                 case -8: //ROWID                     return DbType.Object;             }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapJavaSqlToDbType,The following statement contains a magic number: switch (jSQL)             {                 case -7: //BIT                     return DbType.Boolean;                 case -6: //TINYINT                 case 5: //SMALLINT                 case 4: //INTEGER                     return DbType.Int32;                 case -5: //BIGINT                     return DbType.Int64;                 case 6: //FLOAT                 case 7: //REAL                     return DbType.Single;                 case 8: //DOUBLE                     return DbType.Double;                 case 2: //NUMERIC                 case 3: //DECIMAL                     return DbType.Decimal;                 case 1: //CHAR                 case 12: //VARCHAR                 case -1: //LONGVARCHAR                     return DbType.String;                 case 91: //DATE                     return DbType.Date;                 case 92: //TIME                     return DbType.Time;                 case 93: //TIMESTAMP                     return DbType.DateTime;                 case -2: //BINARY                 case -3: //VARBINARY                 case -4: //LONGVARBINARY                     return DbType.Binary;                 case 0: //NULL                 case 1111: //OTHER                 case 2000: //JAVA_OBJECT                 case 2001: //DISTINCT                 case 2002: //STRUCT                 case 2003: //ARRAY                 case 2004: //BLOB                 case 2005: //CLOB                 case 2006: //REF                 case 70: //DATALINK                     return DbType.Object;                 case 16: //BOOLEAN                     return DbType.Boolean;                 //------------------------- JDBC 4.0 -----------------------------------                 case -15: //NCHAR                 case -9: //NVARCHAR                  case -16: //LONGNVARCHAR                 case 2011: //NCLOB                     return DbType.String;                 case 2009: //SQLXML                      return DbType.Xml;                 case -8: //ROWID                     return DbType.Object;             }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapJavaSqlToDbType,The following statement contains a magic number: switch (jSQL)             {                 case -7: //BIT                     return DbType.Boolean;                 case -6: //TINYINT                 case 5: //SMALLINT                 case 4: //INTEGER                     return DbType.Int32;                 case -5: //BIGINT                     return DbType.Int64;                 case 6: //FLOAT                 case 7: //REAL                     return DbType.Single;                 case 8: //DOUBLE                     return DbType.Double;                 case 2: //NUMERIC                 case 3: //DECIMAL                     return DbType.Decimal;                 case 1: //CHAR                 case 12: //VARCHAR                 case -1: //LONGVARCHAR                     return DbType.String;                 case 91: //DATE                     return DbType.Date;                 case 92: //TIME                     return DbType.Time;                 case 93: //TIMESTAMP                     return DbType.DateTime;                 case -2: //BINARY                 case -3: //VARBINARY                 case -4: //LONGVARBINARY                     return DbType.Binary;                 case 0: //NULL                 case 1111: //OTHER                 case 2000: //JAVA_OBJECT                 case 2001: //DISTINCT                 case 2002: //STRUCT                 case 2003: //ARRAY                 case 2004: //BLOB                 case 2005: //CLOB                 case 2006: //REF                 case 70: //DATALINK                     return DbType.Object;                 case 16: //BOOLEAN                     return DbType.Boolean;                 //------------------------- JDBC 4.0 -----------------------------------                 case -15: //NCHAR                 case -9: //NVARCHAR                  case -16: //LONGNVARCHAR                 case 2011: //NCLOB                     return DbType.String;                 case 2009: //SQLXML                      return DbType.Xml;                 case -8: //ROWID                     return DbType.Object;             }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapJavaSqlToDbType,The following statement contains a magic number: switch (jSQL)             {                 case -7: //BIT                     return DbType.Boolean;                 case -6: //TINYINT                 case 5: //SMALLINT                 case 4: //INTEGER                     return DbType.Int32;                 case -5: //BIGINT                     return DbType.Int64;                 case 6: //FLOAT                 case 7: //REAL                     return DbType.Single;                 case 8: //DOUBLE                     return DbType.Double;                 case 2: //NUMERIC                 case 3: //DECIMAL                     return DbType.Decimal;                 case 1: //CHAR                 case 12: //VARCHAR                 case -1: //LONGVARCHAR                     return DbType.String;                 case 91: //DATE                     return DbType.Date;                 case 92: //TIME                     return DbType.Time;                 case 93: //TIMESTAMP                     return DbType.DateTime;                 case -2: //BINARY                 case -3: //VARBINARY                 case -4: //LONGVARBINARY                     return DbType.Binary;                 case 0: //NULL                 case 1111: //OTHER                 case 2000: //JAVA_OBJECT                 case 2001: //DISTINCT                 case 2002: //STRUCT                 case 2003: //ARRAY                 case 2004: //BLOB                 case 2005: //CLOB                 case 2006: //REF                 case 70: //DATALINK                     return DbType.Object;                 case 16: //BOOLEAN                     return DbType.Boolean;                 //------------------------- JDBC 4.0 -----------------------------------                 case -15: //NCHAR                 case -9: //NVARCHAR                  case -16: //LONGNVARCHAR                 case 2011: //NCLOB                     return DbType.String;                 case 2009: //SQLXML                      return DbType.Xml;                 case -8: //ROWID                     return DbType.Object;             }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapJavaSqlToDbType,The following statement contains a magic number: switch (jSQL)             {                 case -7: //BIT                     return DbType.Boolean;                 case -6: //TINYINT                 case 5: //SMALLINT                 case 4: //INTEGER                     return DbType.Int32;                 case -5: //BIGINT                     return DbType.Int64;                 case 6: //FLOAT                 case 7: //REAL                     return DbType.Single;                 case 8: //DOUBLE                     return DbType.Double;                 case 2: //NUMERIC                 case 3: //DECIMAL                     return DbType.Decimal;                 case 1: //CHAR                 case 12: //VARCHAR                 case -1: //LONGVARCHAR                     return DbType.String;                 case 91: //DATE                     return DbType.Date;                 case 92: //TIME                     return DbType.Time;                 case 93: //TIMESTAMP                     return DbType.DateTime;                 case -2: //BINARY                 case -3: //VARBINARY                 case -4: //LONGVARBINARY                     return DbType.Binary;                 case 0: //NULL                 case 1111: //OTHER                 case 2000: //JAVA_OBJECT                 case 2001: //DISTINCT                 case 2002: //STRUCT                 case 2003: //ARRAY                 case 2004: //BLOB                 case 2005: //CLOB                 case 2006: //REF                 case 70: //DATALINK                     return DbType.Object;                 case 16: //BOOLEAN                     return DbType.Boolean;                 //------------------------- JDBC 4.0 -----------------------------------                 case -15: //NCHAR                 case -9: //NVARCHAR                  case -16: //LONGNVARCHAR                 case 2011: //NCLOB                     return DbType.String;                 case 2009: //SQLXML                      return DbType.Xml;                 case -8: //ROWID                     return DbType.Object;             }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapJavaSqlToDbType,The following statement contains a magic number: switch (jSQL)             {                 case -7: //BIT                     return DbType.Boolean;                 case -6: //TINYINT                 case 5: //SMALLINT                 case 4: //INTEGER                     return DbType.Int32;                 case -5: //BIGINT                     return DbType.Int64;                 case 6: //FLOAT                 case 7: //REAL                     return DbType.Single;                 case 8: //DOUBLE                     return DbType.Double;                 case 2: //NUMERIC                 case 3: //DECIMAL                     return DbType.Decimal;                 case 1: //CHAR                 case 12: //VARCHAR                 case -1: //LONGVARCHAR                     return DbType.String;                 case 91: //DATE                     return DbType.Date;                 case 92: //TIME                     return DbType.Time;                 case 93: //TIMESTAMP                     return DbType.DateTime;                 case -2: //BINARY                 case -3: //VARBINARY                 case -4: //LONGVARBINARY                     return DbType.Binary;                 case 0: //NULL                 case 1111: //OTHER                 case 2000: //JAVA_OBJECT                 case 2001: //DISTINCT                 case 2002: //STRUCT                 case 2003: //ARRAY                 case 2004: //BLOB                 case 2005: //CLOB                 case 2006: //REF                 case 70: //DATALINK                     return DbType.Object;                 case 16: //BOOLEAN                     return DbType.Boolean;                 //------------------------- JDBC 4.0 -----------------------------------                 case -15: //NCHAR                 case -9: //NVARCHAR                  case -16: //LONGNVARCHAR                 case 2011: //NCLOB                     return DbType.String;                 case 2009: //SQLXML                      return DbType.Xml;                 case -8: //ROWID                     return DbType.Object;             }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapJavaSqlToDbType,The following statement contains a magic number: switch (jSQL)             {                 case -7: //BIT                     return DbType.Boolean;                 case -6: //TINYINT                 case 5: //SMALLINT                 case 4: //INTEGER                     return DbType.Int32;                 case -5: //BIGINT                     return DbType.Int64;                 case 6: //FLOAT                 case 7: //REAL                     return DbType.Single;                 case 8: //DOUBLE                     return DbType.Double;                 case 2: //NUMERIC                 case 3: //DECIMAL                     return DbType.Decimal;                 case 1: //CHAR                 case 12: //VARCHAR                 case -1: //LONGVARCHAR                     return DbType.String;                 case 91: //DATE                     return DbType.Date;                 case 92: //TIME                     return DbType.Time;                 case 93: //TIMESTAMP                     return DbType.DateTime;                 case -2: //BINARY                 case -3: //VARBINARY                 case -4: //LONGVARBINARY                     return DbType.Binary;                 case 0: //NULL                 case 1111: //OTHER                 case 2000: //JAVA_OBJECT                 case 2001: //DISTINCT                 case 2002: //STRUCT                 case 2003: //ARRAY                 case 2004: //BLOB                 case 2005: //CLOB                 case 2006: //REF                 case 70: //DATALINK                     return DbType.Object;                 case 16: //BOOLEAN                     return DbType.Boolean;                 //------------------------- JDBC 4.0 -----------------------------------                 case -15: //NCHAR                 case -9: //NVARCHAR                  case -16: //LONGNVARCHAR                 case 2011: //NCLOB                     return DbType.String;                 case 2009: //SQLXML                      return DbType.Xml;                 case -8: //ROWID                     return DbType.Object;             }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapJavaSqlToDbType,The following statement contains a magic number: switch (jSQL)             {                 case -7: //BIT                     return DbType.Boolean;                 case -6: //TINYINT                 case 5: //SMALLINT                 case 4: //INTEGER                     return DbType.Int32;                 case -5: //BIGINT                     return DbType.Int64;                 case 6: //FLOAT                 case 7: //REAL                     return DbType.Single;                 case 8: //DOUBLE                     return DbType.Double;                 case 2: //NUMERIC                 case 3: //DECIMAL                     return DbType.Decimal;                 case 1: //CHAR                 case 12: //VARCHAR                 case -1: //LONGVARCHAR                     return DbType.String;                 case 91: //DATE                     return DbType.Date;                 case 92: //TIME                     return DbType.Time;                 case 93: //TIMESTAMP                     return DbType.DateTime;                 case -2: //BINARY                 case -3: //VARBINARY                 case -4: //LONGVARBINARY                     return DbType.Binary;                 case 0: //NULL                 case 1111: //OTHER                 case 2000: //JAVA_OBJECT                 case 2001: //DISTINCT                 case 2002: //STRUCT                 case 2003: //ARRAY                 case 2004: //BLOB                 case 2005: //CLOB                 case 2006: //REF                 case 70: //DATALINK                     return DbType.Object;                 case 16: //BOOLEAN                     return DbType.Boolean;                 //------------------------- JDBC 4.0 -----------------------------------                 case -15: //NCHAR                 case -9: //NVARCHAR                  case -16: //LONGNVARCHAR                 case 2011: //NCLOB                     return DbType.String;                 case 2009: //SQLXML                      return DbType.Xml;                 case -8: //ROWID                     return DbType.Object;             }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapJavaSqlToDbType,The following statement contains a magic number: switch (jSQL)             {                 case -7: //BIT                     return DbType.Boolean;                 case -6: //TINYINT                 case 5: //SMALLINT                 case 4: //INTEGER                     return DbType.Int32;                 case -5: //BIGINT                     return DbType.Int64;                 case 6: //FLOAT                 case 7: //REAL                     return DbType.Single;                 case 8: //DOUBLE                     return DbType.Double;                 case 2: //NUMERIC                 case 3: //DECIMAL                     return DbType.Decimal;                 case 1: //CHAR                 case 12: //VARCHAR                 case -1: //LONGVARCHAR                     return DbType.String;                 case 91: //DATE                     return DbType.Date;                 case 92: //TIME                     return DbType.Time;                 case 93: //TIMESTAMP                     return DbType.DateTime;                 case -2: //BINARY                 case -3: //VARBINARY                 case -4: //LONGVARBINARY                     return DbType.Binary;                 case 0: //NULL                 case 1111: //OTHER                 case 2000: //JAVA_OBJECT                 case 2001: //DISTINCT                 case 2002: //STRUCT                 case 2003: //ARRAY                 case 2004: //BLOB                 case 2005: //CLOB                 case 2006: //REF                 case 70: //DATALINK                     return DbType.Object;                 case 16: //BOOLEAN                     return DbType.Boolean;                 //------------------------- JDBC 4.0 -----------------------------------                 case -15: //NCHAR                 case -9: //NVARCHAR                  case -16: //LONGNVARCHAR                 case 2011: //NCLOB                     return DbType.String;                 case 2009: //SQLXML                      return DbType.Xml;                 case -8: //ROWID                     return DbType.Object;             }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapJavaSqlToDbType,The following statement contains a magic number: switch (jSQL)             {                 case -7: //BIT                     return DbType.Boolean;                 case -6: //TINYINT                 case 5: //SMALLINT                 case 4: //INTEGER                     return DbType.Int32;                 case -5: //BIGINT                     return DbType.Int64;                 case 6: //FLOAT                 case 7: //REAL                     return DbType.Single;                 case 8: //DOUBLE                     return DbType.Double;                 case 2: //NUMERIC                 case 3: //DECIMAL                     return DbType.Decimal;                 case 1: //CHAR                 case 12: //VARCHAR                 case -1: //LONGVARCHAR                     return DbType.String;                 case 91: //DATE                     return DbType.Date;                 case 92: //TIME                     return DbType.Time;                 case 93: //TIMESTAMP                     return DbType.DateTime;                 case -2: //BINARY                 case -3: //VARBINARY                 case -4: //LONGVARBINARY                     return DbType.Binary;                 case 0: //NULL                 case 1111: //OTHER                 case 2000: //JAVA_OBJECT                 case 2001: //DISTINCT                 case 2002: //STRUCT                 case 2003: //ARRAY                 case 2004: //BLOB                 case 2005: //CLOB                 case 2006: //REF                 case 70: //DATALINK                     return DbType.Object;                 case 16: //BOOLEAN                     return DbType.Boolean;                 //------------------------- JDBC 4.0 -----------------------------------                 case -15: //NCHAR                 case -9: //NVARCHAR                  case -16: //LONGNVARCHAR                 case 2011: //NCLOB                     return DbType.String;                 case 2009: //SQLXML                      return DbType.Xml;                 case -8: //ROWID                     return DbType.Object;             }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapJavaSqlToDbType,The following statement contains a magic number: switch (jSQL)             {                 case -7: //BIT                     return DbType.Boolean;                 case -6: //TINYINT                 case 5: //SMALLINT                 case 4: //INTEGER                     return DbType.Int32;                 case -5: //BIGINT                     return DbType.Int64;                 case 6: //FLOAT                 case 7: //REAL                     return DbType.Single;                 case 8: //DOUBLE                     return DbType.Double;                 case 2: //NUMERIC                 case 3: //DECIMAL                     return DbType.Decimal;                 case 1: //CHAR                 case 12: //VARCHAR                 case -1: //LONGVARCHAR                     return DbType.String;                 case 91: //DATE                     return DbType.Date;                 case 92: //TIME                     return DbType.Time;                 case 93: //TIMESTAMP                     return DbType.DateTime;                 case -2: //BINARY                 case -3: //VARBINARY                 case -4: //LONGVARBINARY                     return DbType.Binary;                 case 0: //NULL                 case 1111: //OTHER                 case 2000: //JAVA_OBJECT                 case 2001: //DISTINCT                 case 2002: //STRUCT                 case 2003: //ARRAY                 case 2004: //BLOB                 case 2005: //CLOB                 case 2006: //REF                 case 70: //DATALINK                     return DbType.Object;                 case 16: //BOOLEAN                     return DbType.Boolean;                 //------------------------- JDBC 4.0 -----------------------------------                 case -15: //NCHAR                 case -9: //NVARCHAR                  case -16: //LONGNVARCHAR                 case 2011: //NCLOB                     return DbType.String;                 case 2009: //SQLXML                      return DbType.Xml;                 case -8: //ROWID                     return DbType.Object;             }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapJavaSqlToDbType,The following statement contains a magic number: switch (jSQL)             {                 case -7: //BIT                     return DbType.Boolean;                 case -6: //TINYINT                 case 5: //SMALLINT                 case 4: //INTEGER                     return DbType.Int32;                 case -5: //BIGINT                     return DbType.Int64;                 case 6: //FLOAT                 case 7: //REAL                     return DbType.Single;                 case 8: //DOUBLE                     return DbType.Double;                 case 2: //NUMERIC                 case 3: //DECIMAL                     return DbType.Decimal;                 case 1: //CHAR                 case 12: //VARCHAR                 case -1: //LONGVARCHAR                     return DbType.String;                 case 91: //DATE                     return DbType.Date;                 case 92: //TIME                     return DbType.Time;                 case 93: //TIMESTAMP                     return DbType.DateTime;                 case -2: //BINARY                 case -3: //VARBINARY                 case -4: //LONGVARBINARY                     return DbType.Binary;                 case 0: //NULL                 case 1111: //OTHER                 case 2000: //JAVA_OBJECT                 case 2001: //DISTINCT                 case 2002: //STRUCT                 case 2003: //ARRAY                 case 2004: //BLOB                 case 2005: //CLOB                 case 2006: //REF                 case 70: //DATALINK                     return DbType.Object;                 case 16: //BOOLEAN                     return DbType.Boolean;                 //------------------------- JDBC 4.0 -----------------------------------                 case -15: //NCHAR                 case -9: //NVARCHAR                  case -16: //LONGNVARCHAR                 case 2011: //NCLOB                     return DbType.String;                 case 2009: //SQLXML                      return DbType.Xml;                 case -8: //ROWID                     return DbType.Object;             }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapJavaSqlToDbType,The following statement contains a magic number: switch (jSQL)             {                 case -7: //BIT                     return DbType.Boolean;                 case -6: //TINYINT                 case 5: //SMALLINT                 case 4: //INTEGER                     return DbType.Int32;                 case -5: //BIGINT                     return DbType.Int64;                 case 6: //FLOAT                 case 7: //REAL                     return DbType.Single;                 case 8: //DOUBLE                     return DbType.Double;                 case 2: //NUMERIC                 case 3: //DECIMAL                     return DbType.Decimal;                 case 1: //CHAR                 case 12: //VARCHAR                 case -1: //LONGVARCHAR                     return DbType.String;                 case 91: //DATE                     return DbType.Date;                 case 92: //TIME                     return DbType.Time;                 case 93: //TIMESTAMP                     return DbType.DateTime;                 case -2: //BINARY                 case -3: //VARBINARY                 case -4: //LONGVARBINARY                     return DbType.Binary;                 case 0: //NULL                 case 1111: //OTHER                 case 2000: //JAVA_OBJECT                 case 2001: //DISTINCT                 case 2002: //STRUCT                 case 2003: //ARRAY                 case 2004: //BLOB                 case 2005: //CLOB                 case 2006: //REF                 case 70: //DATALINK                     return DbType.Object;                 case 16: //BOOLEAN                     return DbType.Boolean;                 //------------------------- JDBC 4.0 -----------------------------------                 case -15: //NCHAR                 case -9: //NVARCHAR                  case -16: //LONGNVARCHAR                 case 2011: //NCLOB                     return DbType.String;                 case 2009: //SQLXML                      return DbType.Xml;                 case -8: //ROWID                     return DbType.Object;             }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapJavaSqlToDbType,The following statement contains a magic number: switch (jSQL)             {                 case -7: //BIT                     return DbType.Boolean;                 case -6: //TINYINT                 case 5: //SMALLINT                 case 4: //INTEGER                     return DbType.Int32;                 case -5: //BIGINT                     return DbType.Int64;                 case 6: //FLOAT                 case 7: //REAL                     return DbType.Single;                 case 8: //DOUBLE                     return DbType.Double;                 case 2: //NUMERIC                 case 3: //DECIMAL                     return DbType.Decimal;                 case 1: //CHAR                 case 12: //VARCHAR                 case -1: //LONGVARCHAR                     return DbType.String;                 case 91: //DATE                     return DbType.Date;                 case 92: //TIME                     return DbType.Time;                 case 93: //TIMESTAMP                     return DbType.DateTime;                 case -2: //BINARY                 case -3: //VARBINARY                 case -4: //LONGVARBINARY                     return DbType.Binary;                 case 0: //NULL                 case 1111: //OTHER                 case 2000: //JAVA_OBJECT                 case 2001: //DISTINCT                 case 2002: //STRUCT                 case 2003: //ARRAY                 case 2004: //BLOB                 case 2005: //CLOB                 case 2006: //REF                 case 70: //DATALINK                     return DbType.Object;                 case 16: //BOOLEAN                     return DbType.Boolean;                 //------------------------- JDBC 4.0 -----------------------------------                 case -15: //NCHAR                 case -9: //NVARCHAR                  case -16: //LONGNVARCHAR                 case 2011: //NCLOB                     return DbType.String;                 case 2009: //SQLXML                      return DbType.Xml;                 case -8: //ROWID                     return DbType.Object;             }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapJavaSqlToDbType,The following statement contains a magic number: switch (jSQL)             {                 case -7: //BIT                     return DbType.Boolean;                 case -6: //TINYINT                 case 5: //SMALLINT                 case 4: //INTEGER                     return DbType.Int32;                 case -5: //BIGINT                     return DbType.Int64;                 case 6: //FLOAT                 case 7: //REAL                     return DbType.Single;                 case 8: //DOUBLE                     return DbType.Double;                 case 2: //NUMERIC                 case 3: //DECIMAL                     return DbType.Decimal;                 case 1: //CHAR                 case 12: //VARCHAR                 case -1: //LONGVARCHAR                     return DbType.String;                 case 91: //DATE                     return DbType.Date;                 case 92: //TIME                     return DbType.Time;                 case 93: //TIMESTAMP                     return DbType.DateTime;                 case -2: //BINARY                 case -3: //VARBINARY                 case -4: //LONGVARBINARY                     return DbType.Binary;                 case 0: //NULL                 case 1111: //OTHER                 case 2000: //JAVA_OBJECT                 case 2001: //DISTINCT                 case 2002: //STRUCT                 case 2003: //ARRAY                 case 2004: //BLOB                 case 2005: //CLOB                 case 2006: //REF                 case 70: //DATALINK                     return DbType.Object;                 case 16: //BOOLEAN                     return DbType.Boolean;                 //------------------------- JDBC 4.0 -----------------------------------                 case -15: //NCHAR                 case -9: //NVARCHAR                  case -16: //LONGNVARCHAR                 case 2011: //NCLOB                     return DbType.String;                 case 2009: //SQLXML                      return DbType.Xml;                 case -8: //ROWID                     return DbType.Object;             }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapJavaSqlToDbType,The following statement contains a magic number: switch (jSQL)             {                 case -7: //BIT                     return DbType.Boolean;                 case -6: //TINYINT                 case 5: //SMALLINT                 case 4: //INTEGER                     return DbType.Int32;                 case -5: //BIGINT                     return DbType.Int64;                 case 6: //FLOAT                 case 7: //REAL                     return DbType.Single;                 case 8: //DOUBLE                     return DbType.Double;                 case 2: //NUMERIC                 case 3: //DECIMAL                     return DbType.Decimal;                 case 1: //CHAR                 case 12: //VARCHAR                 case -1: //LONGVARCHAR                     return DbType.String;                 case 91: //DATE                     return DbType.Date;                 case 92: //TIME                     return DbType.Time;                 case 93: //TIMESTAMP                     return DbType.DateTime;                 case -2: //BINARY                 case -3: //VARBINARY                 case -4: //LONGVARBINARY                     return DbType.Binary;                 case 0: //NULL                 case 1111: //OTHER                 case 2000: //JAVA_OBJECT                 case 2001: //DISTINCT                 case 2002: //STRUCT                 case 2003: //ARRAY                 case 2004: //BLOB                 case 2005: //CLOB                 case 2006: //REF                 case 70: //DATALINK                     return DbType.Object;                 case 16: //BOOLEAN                     return DbType.Boolean;                 //------------------------- JDBC 4.0 -----------------------------------                 case -15: //NCHAR                 case -9: //NVARCHAR                  case -16: //LONGNVARCHAR                 case 2011: //NCLOB                     return DbType.String;                 case 2009: //SQLXML                      return DbType.Xml;                 case -8: //ROWID                     return DbType.Object;             }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapJavaSqlToDbType,The following statement contains a magic number: switch (jSQL)             {                 case -7: //BIT                     return DbType.Boolean;                 case -6: //TINYINT                 case 5: //SMALLINT                 case 4: //INTEGER                     return DbType.Int32;                 case -5: //BIGINT                     return DbType.Int64;                 case 6: //FLOAT                 case 7: //REAL                     return DbType.Single;                 case 8: //DOUBLE                     return DbType.Double;                 case 2: //NUMERIC                 case 3: //DECIMAL                     return DbType.Decimal;                 case 1: //CHAR                 case 12: //VARCHAR                 case -1: //LONGVARCHAR                     return DbType.String;                 case 91: //DATE                     return DbType.Date;                 case 92: //TIME                     return DbType.Time;                 case 93: //TIMESTAMP                     return DbType.DateTime;                 case -2: //BINARY                 case -3: //VARBINARY                 case -4: //LONGVARBINARY                     return DbType.Binary;                 case 0: //NULL                 case 1111: //OTHER                 case 2000: //JAVA_OBJECT                 case 2001: //DISTINCT                 case 2002: //STRUCT                 case 2003: //ARRAY                 case 2004: //BLOB                 case 2005: //CLOB                 case 2006: //REF                 case 70: //DATALINK                     return DbType.Object;                 case 16: //BOOLEAN                     return DbType.Boolean;                 //------------------------- JDBC 4.0 -----------------------------------                 case -15: //NCHAR                 case -9: //NVARCHAR                  case -16: //LONGNVARCHAR                 case 2011: //NCLOB                     return DbType.String;                 case 2009: //SQLXML                      return DbType.Xml;                 case -8: //ROWID                     return DbType.Object;             }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapJavaSqlToDbType,The following statement contains a magic number: switch (jSQL)             {                 case -7: //BIT                     return DbType.Boolean;                 case -6: //TINYINT                 case 5: //SMALLINT                 case 4: //INTEGER                     return DbType.Int32;                 case -5: //BIGINT                     return DbType.Int64;                 case 6: //FLOAT                 case 7: //REAL                     return DbType.Single;                 case 8: //DOUBLE                     return DbType.Double;                 case 2: //NUMERIC                 case 3: //DECIMAL                     return DbType.Decimal;                 case 1: //CHAR                 case 12: //VARCHAR                 case -1: //LONGVARCHAR                     return DbType.String;                 case 91: //DATE                     return DbType.Date;                 case 92: //TIME                     return DbType.Time;                 case 93: //TIMESTAMP                     return DbType.DateTime;                 case -2: //BINARY                 case -3: //VARBINARY                 case -4: //LONGVARBINARY                     return DbType.Binary;                 case 0: //NULL                 case 1111: //OTHER                 case 2000: //JAVA_OBJECT                 case 2001: //DISTINCT                 case 2002: //STRUCT                 case 2003: //ARRAY                 case 2004: //BLOB                 case 2005: //CLOB                 case 2006: //REF                 case 70: //DATALINK                     return DbType.Object;                 case 16: //BOOLEAN                     return DbType.Boolean;                 //------------------------- JDBC 4.0 -----------------------------------                 case -15: //NCHAR                 case -9: //NVARCHAR                  case -16: //LONGNVARCHAR                 case 2011: //NCLOB                     return DbType.String;                 case 2009: //SQLXML                      return DbType.Xml;                 case -8: //ROWID                     return DbType.Object;             }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapJavaSqlToDbType,The following statement contains a magic number: switch (jSQL)             {                 case -7: //BIT                     return DbType.Boolean;                 case -6: //TINYINT                 case 5: //SMALLINT                 case 4: //INTEGER                     return DbType.Int32;                 case -5: //BIGINT                     return DbType.Int64;                 case 6: //FLOAT                 case 7: //REAL                     return DbType.Single;                 case 8: //DOUBLE                     return DbType.Double;                 case 2: //NUMERIC                 case 3: //DECIMAL                     return DbType.Decimal;                 case 1: //CHAR                 case 12: //VARCHAR                 case -1: //LONGVARCHAR                     return DbType.String;                 case 91: //DATE                     return DbType.Date;                 case 92: //TIME                     return DbType.Time;                 case 93: //TIMESTAMP                     return DbType.DateTime;                 case -2: //BINARY                 case -3: //VARBINARY                 case -4: //LONGVARBINARY                     return DbType.Binary;                 case 0: //NULL                 case 1111: //OTHER                 case 2000: //JAVA_OBJECT                 case 2001: //DISTINCT                 case 2002: //STRUCT                 case 2003: //ARRAY                 case 2004: //BLOB                 case 2005: //CLOB                 case 2006: //REF                 case 70: //DATALINK                     return DbType.Object;                 case 16: //BOOLEAN                     return DbType.Boolean;                 //------------------------- JDBC 4.0 -----------------------------------                 case -15: //NCHAR                 case -9: //NVARCHAR                  case -16: //LONGNVARCHAR                 case 2011: //NCLOB                     return DbType.String;                 case 2009: //SQLXML                      return DbType.Xml;                 case -8: //ROWID                     return DbType.Object;             }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapJavaSqlToDbType,The following statement contains a magic number: switch (jSQL)             {                 case -7: //BIT                     return DbType.Boolean;                 case -6: //TINYINT                 case 5: //SMALLINT                 case 4: //INTEGER                     return DbType.Int32;                 case -5: //BIGINT                     return DbType.Int64;                 case 6: //FLOAT                 case 7: //REAL                     return DbType.Single;                 case 8: //DOUBLE                     return DbType.Double;                 case 2: //NUMERIC                 case 3: //DECIMAL                     return DbType.Decimal;                 case 1: //CHAR                 case 12: //VARCHAR                 case -1: //LONGVARCHAR                     return DbType.String;                 case 91: //DATE                     return DbType.Date;                 case 92: //TIME                     return DbType.Time;                 case 93: //TIMESTAMP                     return DbType.DateTime;                 case -2: //BINARY                 case -3: //VARBINARY                 case -4: //LONGVARBINARY                     return DbType.Binary;                 case 0: //NULL                 case 1111: //OTHER                 case 2000: //JAVA_OBJECT                 case 2001: //DISTINCT                 case 2002: //STRUCT                 case 2003: //ARRAY                 case 2004: //BLOB                 case 2005: //CLOB                 case 2006: //REF                 case 70: //DATALINK                     return DbType.Object;                 case 16: //BOOLEAN                     return DbType.Boolean;                 //------------------------- JDBC 4.0 -----------------------------------                 case -15: //NCHAR                 case -9: //NVARCHAR                  case -16: //LONGNVARCHAR                 case 2011: //NCLOB                     return DbType.String;                 case 2009: //SQLXML                      return DbType.Xml;                 case -8: //ROWID                     return DbType.Object;             }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapJavaSqlToDbType,The following statement contains a magic number: switch (jSQL)             {                 case -7: //BIT                     return DbType.Boolean;                 case -6: //TINYINT                 case 5: //SMALLINT                 case 4: //INTEGER                     return DbType.Int32;                 case -5: //BIGINT                     return DbType.Int64;                 case 6: //FLOAT                 case 7: //REAL                     return DbType.Single;                 case 8: //DOUBLE                     return DbType.Double;                 case 2: //NUMERIC                 case 3: //DECIMAL                     return DbType.Decimal;                 case 1: //CHAR                 case 12: //VARCHAR                 case -1: //LONGVARCHAR                     return DbType.String;                 case 91: //DATE                     return DbType.Date;                 case 92: //TIME                     return DbType.Time;                 case 93: //TIMESTAMP                     return DbType.DateTime;                 case -2: //BINARY                 case -3: //VARBINARY                 case -4: //LONGVARBINARY                     return DbType.Binary;                 case 0: //NULL                 case 1111: //OTHER                 case 2000: //JAVA_OBJECT                 case 2001: //DISTINCT                 case 2002: //STRUCT                 case 2003: //ARRAY                 case 2004: //BLOB                 case 2005: //CLOB                 case 2006: //REF                 case 70: //DATALINK                     return DbType.Object;                 case 16: //BOOLEAN                     return DbType.Boolean;                 //------------------------- JDBC 4.0 -----------------------------------                 case -15: //NCHAR                 case -9: //NVARCHAR                  case -16: //LONGNVARCHAR                 case 2011: //NCLOB                     return DbType.String;                 case 2009: //SQLXML                      return DbType.Xml;                 case -8: //ROWID                     return DbType.Object;             }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapJavaSqlToDbType,The following statement contains a magic number: switch (jSQL)             {                 case -7: //BIT                     return DbType.Boolean;                 case -6: //TINYINT                 case 5: //SMALLINT                 case 4: //INTEGER                     return DbType.Int32;                 case -5: //BIGINT                     return DbType.Int64;                 case 6: //FLOAT                 case 7: //REAL                     return DbType.Single;                 case 8: //DOUBLE                     return DbType.Double;                 case 2: //NUMERIC                 case 3: //DECIMAL                     return DbType.Decimal;                 case 1: //CHAR                 case 12: //VARCHAR                 case -1: //LONGVARCHAR                     return DbType.String;                 case 91: //DATE                     return DbType.Date;                 case 92: //TIME                     return DbType.Time;                 case 93: //TIMESTAMP                     return DbType.DateTime;                 case -2: //BINARY                 case -3: //VARBINARY                 case -4: //LONGVARBINARY                     return DbType.Binary;                 case 0: //NULL                 case 1111: //OTHER                 case 2000: //JAVA_OBJECT                 case 2001: //DISTINCT                 case 2002: //STRUCT                 case 2003: //ARRAY                 case 2004: //BLOB                 case 2005: //CLOB                 case 2006: //REF                 case 70: //DATALINK                     return DbType.Object;                 case 16: //BOOLEAN                     return DbType.Boolean;                 //------------------------- JDBC 4.0 -----------------------------------                 case -15: //NCHAR                 case -9: //NVARCHAR                  case -16: //LONGNVARCHAR                 case 2011: //NCLOB                     return DbType.String;                 case 2009: //SQLXML                      return DbType.Xml;                 case -8: //ROWID                     return DbType.Object;             }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapJavaSqlToDbType,The following statement contains a magic number: switch (jSQL)             {                 case -7: //BIT                     return DbType.Boolean;                 case -6: //TINYINT                 case 5: //SMALLINT                 case 4: //INTEGER                     return DbType.Int32;                 case -5: //BIGINT                     return DbType.Int64;                 case 6: //FLOAT                 case 7: //REAL                     return DbType.Single;                 case 8: //DOUBLE                     return DbType.Double;                 case 2: //NUMERIC                 case 3: //DECIMAL                     return DbType.Decimal;                 case 1: //CHAR                 case 12: //VARCHAR                 case -1: //LONGVARCHAR                     return DbType.String;                 case 91: //DATE                     return DbType.Date;                 case 92: //TIME                     return DbType.Time;                 case 93: //TIMESTAMP                     return DbType.DateTime;                 case -2: //BINARY                 case -3: //VARBINARY                 case -4: //LONGVARBINARY                     return DbType.Binary;                 case 0: //NULL                 case 1111: //OTHER                 case 2000: //JAVA_OBJECT                 case 2001: //DISTINCT                 case 2002: //STRUCT                 case 2003: //ARRAY                 case 2004: //BLOB                 case 2005: //CLOB                 case 2006: //REF                 case 70: //DATALINK                     return DbType.Object;                 case 16: //BOOLEAN                     return DbType.Boolean;                 //------------------------- JDBC 4.0 -----------------------------------                 case -15: //NCHAR                 case -9: //NVARCHAR                  case -16: //LONGNVARCHAR                 case 2011: //NCLOB                     return DbType.String;                 case 2009: //SQLXML                      return DbType.Xml;                 case -8: //ROWID                     return DbType.Object;             }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapJavaSqlToDbType,The following statement contains a magic number: switch (jSQL)             {                 case -7: //BIT                     return DbType.Boolean;                 case -6: //TINYINT                 case 5: //SMALLINT                 case 4: //INTEGER                     return DbType.Int32;                 case -5: //BIGINT                     return DbType.Int64;                 case 6: //FLOAT                 case 7: //REAL                     return DbType.Single;                 case 8: //DOUBLE                     return DbType.Double;                 case 2: //NUMERIC                 case 3: //DECIMAL                     return DbType.Decimal;                 case 1: //CHAR                 case 12: //VARCHAR                 case -1: //LONGVARCHAR                     return DbType.String;                 case 91: //DATE                     return DbType.Date;                 case 92: //TIME                     return DbType.Time;                 case 93: //TIMESTAMP                     return DbType.DateTime;                 case -2: //BINARY                 case -3: //VARBINARY                 case -4: //LONGVARBINARY                     return DbType.Binary;                 case 0: //NULL                 case 1111: //OTHER                 case 2000: //JAVA_OBJECT                 case 2001: //DISTINCT                 case 2002: //STRUCT                 case 2003: //ARRAY                 case 2004: //BLOB                 case 2005: //CLOB                 case 2006: //REF                 case 70: //DATALINK                     return DbType.Object;                 case 16: //BOOLEAN                     return DbType.Boolean;                 //------------------------- JDBC 4.0 -----------------------------------                 case -15: //NCHAR                 case -9: //NVARCHAR                  case -16: //LONGNVARCHAR                 case 2011: //NCLOB                     return DbType.String;                 case 2009: //SQLXML                      return DbType.Xml;                 case -8: //ROWID                     return DbType.Object;             }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapJavaSqlToDbType,The following statement contains a magic number: switch (jSQL)             {                 case -7: //BIT                     return DbType.Boolean;                 case -6: //TINYINT                 case 5: //SMALLINT                 case 4: //INTEGER                     return DbType.Int32;                 case -5: //BIGINT                     return DbType.Int64;                 case 6: //FLOAT                 case 7: //REAL                     return DbType.Single;                 case 8: //DOUBLE                     return DbType.Double;                 case 2: //NUMERIC                 case 3: //DECIMAL                     return DbType.Decimal;                 case 1: //CHAR                 case 12: //VARCHAR                 case -1: //LONGVARCHAR                     return DbType.String;                 case 91: //DATE                     return DbType.Date;                 case 92: //TIME                     return DbType.Time;                 case 93: //TIMESTAMP                     return DbType.DateTime;                 case -2: //BINARY                 case -3: //VARBINARY                 case -4: //LONGVARBINARY                     return DbType.Binary;                 case 0: //NULL                 case 1111: //OTHER                 case 2000: //JAVA_OBJECT                 case 2001: //DISTINCT                 case 2002: //STRUCT                 case 2003: //ARRAY                 case 2004: //BLOB                 case 2005: //CLOB                 case 2006: //REF                 case 70: //DATALINK                     return DbType.Object;                 case 16: //BOOLEAN                     return DbType.Boolean;                 //------------------------- JDBC 4.0 -----------------------------------                 case -15: //NCHAR                 case -9: //NVARCHAR                  case -16: //LONGNVARCHAR                 case 2011: //NCLOB                     return DbType.String;                 case 2009: //SQLXML                      return DbType.Xml;                 case -8: //ROWID                     return DbType.Object;             }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapJavaSqlToDbType,The following statement contains a magic number: switch (jSQL)             {                 case -7: //BIT                     return DbType.Boolean;                 case -6: //TINYINT                 case 5: //SMALLINT                 case 4: //INTEGER                     return DbType.Int32;                 case -5: //BIGINT                     return DbType.Int64;                 case 6: //FLOAT                 case 7: //REAL                     return DbType.Single;                 case 8: //DOUBLE                     return DbType.Double;                 case 2: //NUMERIC                 case 3: //DECIMAL                     return DbType.Decimal;                 case 1: //CHAR                 case 12: //VARCHAR                 case -1: //LONGVARCHAR                     return DbType.String;                 case 91: //DATE                     return DbType.Date;                 case 92: //TIME                     return DbType.Time;                 case 93: //TIMESTAMP                     return DbType.DateTime;                 case -2: //BINARY                 case -3: //VARBINARY                 case -4: //LONGVARBINARY                     return DbType.Binary;                 case 0: //NULL                 case 1111: //OTHER                 case 2000: //JAVA_OBJECT                 case 2001: //DISTINCT                 case 2002: //STRUCT                 case 2003: //ARRAY                 case 2004: //BLOB                 case 2005: //CLOB                 case 2006: //REF                 case 70: //DATALINK                     return DbType.Object;                 case 16: //BOOLEAN                     return DbType.Boolean;                 //------------------------- JDBC 4.0 -----------------------------------                 case -15: //NCHAR                 case -9: //NVARCHAR                  case -16: //LONGNVARCHAR                 case 2011: //NCLOB                     return DbType.String;                 case 2009: //SQLXML                      return DbType.Xml;                 case -8: //ROWID                     return DbType.Object;             }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapJavaSqlToDbType,The following statement contains a magic number: switch (jSQL)             {                 case -7: //BIT                     return DbType.Boolean;                 case -6: //TINYINT                 case 5: //SMALLINT                 case 4: //INTEGER                     return DbType.Int32;                 case -5: //BIGINT                     return DbType.Int64;                 case 6: //FLOAT                 case 7: //REAL                     return DbType.Single;                 case 8: //DOUBLE                     return DbType.Double;                 case 2: //NUMERIC                 case 3: //DECIMAL                     return DbType.Decimal;                 case 1: //CHAR                 case 12: //VARCHAR                 case -1: //LONGVARCHAR                     return DbType.String;                 case 91: //DATE                     return DbType.Date;                 case 92: //TIME                     return DbType.Time;                 case 93: //TIMESTAMP                     return DbType.DateTime;                 case -2: //BINARY                 case -3: //VARBINARY                 case -4: //LONGVARBINARY                     return DbType.Binary;                 case 0: //NULL                 case 1111: //OTHER                 case 2000: //JAVA_OBJECT                 case 2001: //DISTINCT                 case 2002: //STRUCT                 case 2003: //ARRAY                 case 2004: //BLOB                 case 2005: //CLOB                 case 2006: //REF                 case 70: //DATALINK                     return DbType.Object;                 case 16: //BOOLEAN                     return DbType.Boolean;                 //------------------------- JDBC 4.0 -----------------------------------                 case -15: //NCHAR                 case -9: //NVARCHAR                  case -16: //LONGNVARCHAR                 case 2011: //NCLOB                     return DbType.String;                 case 2009: //SQLXML                      return DbType.Xml;                 case -8: //ROWID                     return DbType.Object;             }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapJavaSqlToDbType,The following statement contains a magic number: switch (jSQL)             {                 case -7: //BIT                     return DbType.Boolean;                 case -6: //TINYINT                 case 5: //SMALLINT                 case 4: //INTEGER                     return DbType.Int32;                 case -5: //BIGINT                     return DbType.Int64;                 case 6: //FLOAT                 case 7: //REAL                     return DbType.Single;                 case 8: //DOUBLE                     return DbType.Double;                 case 2: //NUMERIC                 case 3: //DECIMAL                     return DbType.Decimal;                 case 1: //CHAR                 case 12: //VARCHAR                 case -1: //LONGVARCHAR                     return DbType.String;                 case 91: //DATE                     return DbType.Date;                 case 92: //TIME                     return DbType.Time;                 case 93: //TIMESTAMP                     return DbType.DateTime;                 case -2: //BINARY                 case -3: //VARBINARY                 case -4: //LONGVARBINARY                     return DbType.Binary;                 case 0: //NULL                 case 1111: //OTHER                 case 2000: //JAVA_OBJECT                 case 2001: //DISTINCT                 case 2002: //STRUCT                 case 2003: //ARRAY                 case 2004: //BLOB                 case 2005: //CLOB                 case 2006: //REF                 case 70: //DATALINK                     return DbType.Object;                 case 16: //BOOLEAN                     return DbType.Boolean;                 //------------------------- JDBC 4.0 -----------------------------------                 case -15: //NCHAR                 case -9: //NVARCHAR                  case -16: //LONGNVARCHAR                 case 2011: //NCLOB                     return DbType.String;                 case 2009: //SQLXML                      return DbType.Xml;                 case -8: //ROWID                     return DbType.Object;             }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapJavaSqlToDbType,The following statement contains a magic number: switch (jSQL)             {                 case -7: //BIT                     return DbType.Boolean;                 case -6: //TINYINT                 case 5: //SMALLINT                 case 4: //INTEGER                     return DbType.Int32;                 case -5: //BIGINT                     return DbType.Int64;                 case 6: //FLOAT                 case 7: //REAL                     return DbType.Single;                 case 8: //DOUBLE                     return DbType.Double;                 case 2: //NUMERIC                 case 3: //DECIMAL                     return DbType.Decimal;                 case 1: //CHAR                 case 12: //VARCHAR                 case -1: //LONGVARCHAR                     return DbType.String;                 case 91: //DATE                     return DbType.Date;                 case 92: //TIME                     return DbType.Time;                 case 93: //TIMESTAMP                     return DbType.DateTime;                 case -2: //BINARY                 case -3: //VARBINARY                 case -4: //LONGVARBINARY                     return DbType.Binary;                 case 0: //NULL                 case 1111: //OTHER                 case 2000: //JAVA_OBJECT                 case 2001: //DISTINCT                 case 2002: //STRUCT                 case 2003: //ARRAY                 case 2004: //BLOB                 case 2005: //CLOB                 case 2006: //REF                 case 70: //DATALINK                     return DbType.Object;                 case 16: //BOOLEAN                     return DbType.Boolean;                 //------------------------- JDBC 4.0 -----------------------------------                 case -15: //NCHAR                 case -9: //NVARCHAR                  case -16: //LONGNVARCHAR                 case 2011: //NCLOB                     return DbType.String;                 case 2009: //SQLXML                      return DbType.Xml;                 case -8: //ROWID                     return DbType.Object;             }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapDbTypeToJavaSql,The following statement contains a magic number: switch (dbType)             {                 case DbType.Boolean:                     return 16; //BOOLEAN                 case DbType.Int32:                     return 4; //INTEGER                 case DbType.Int64:                     return -5; //BIGINT                 case DbType.Single:                     return 7; //REAL                 case DbType.Double:                     return 8; //DOUBLE                 case DbType.Decimal:                     return 3; //DECIMAL                 case DbType.Xml:                 case DbType.String:                     return 12; //VARCHAR                 case DbType.Date:                     return 91; //DATE                 case DbType.Time:                     return 92; //TIME                 case DbType.DateTime:                     return 93; //TIMESTAMP                 case DbType.Binary:                     return -3; //VARBINARY                 case DbType.Object:                     return 2004; //BLOB             }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapDbTypeToJavaSql,The following statement contains a magic number: switch (dbType)             {                 case DbType.Boolean:                     return 16; //BOOLEAN                 case DbType.Int32:                     return 4; //INTEGER                 case DbType.Int64:                     return -5; //BIGINT                 case DbType.Single:                     return 7; //REAL                 case DbType.Double:                     return 8; //DOUBLE                 case DbType.Decimal:                     return 3; //DECIMAL                 case DbType.Xml:                 case DbType.String:                     return 12; //VARCHAR                 case DbType.Date:                     return 91; //DATE                 case DbType.Time:                     return 92; //TIME                 case DbType.DateTime:                     return 93; //TIMESTAMP                 case DbType.Binary:                     return -3; //VARBINARY                 case DbType.Object:                     return 2004; //BLOB             }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapDbTypeToJavaSql,The following statement contains a magic number: switch (dbType)             {                 case DbType.Boolean:                     return 16; //BOOLEAN                 case DbType.Int32:                     return 4; //INTEGER                 case DbType.Int64:                     return -5; //BIGINT                 case DbType.Single:                     return 7; //REAL                 case DbType.Double:                     return 8; //DOUBLE                 case DbType.Decimal:                     return 3; //DECIMAL                 case DbType.Xml:                 case DbType.String:                     return 12; //VARCHAR                 case DbType.Date:                     return 91; //DATE                 case DbType.Time:                     return 92; //TIME                 case DbType.DateTime:                     return 93; //TIMESTAMP                 case DbType.Binary:                     return -3; //VARBINARY                 case DbType.Object:                     return 2004; //BLOB             }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapDbTypeToJavaSql,The following statement contains a magic number: switch (dbType)             {                 case DbType.Boolean:                     return 16; //BOOLEAN                 case DbType.Int32:                     return 4; //INTEGER                 case DbType.Int64:                     return -5; //BIGINT                 case DbType.Single:                     return 7; //REAL                 case DbType.Double:                     return 8; //DOUBLE                 case DbType.Decimal:                     return 3; //DECIMAL                 case DbType.Xml:                 case DbType.String:                     return 12; //VARCHAR                 case DbType.Date:                     return 91; //DATE                 case DbType.Time:                     return 92; //TIME                 case DbType.DateTime:                     return 93; //TIMESTAMP                 case DbType.Binary:                     return -3; //VARBINARY                 case DbType.Object:                     return 2004; //BLOB             }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapDbTypeToJavaSql,The following statement contains a magic number: switch (dbType)             {                 case DbType.Boolean:                     return 16; //BOOLEAN                 case DbType.Int32:                     return 4; //INTEGER                 case DbType.Int64:                     return -5; //BIGINT                 case DbType.Single:                     return 7; //REAL                 case DbType.Double:                     return 8; //DOUBLE                 case DbType.Decimal:                     return 3; //DECIMAL                 case DbType.Xml:                 case DbType.String:                     return 12; //VARCHAR                 case DbType.Date:                     return 91; //DATE                 case DbType.Time:                     return 92; //TIME                 case DbType.DateTime:                     return 93; //TIMESTAMP                 case DbType.Binary:                     return -3; //VARBINARY                 case DbType.Object:                     return 2004; //BLOB             }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapDbTypeToJavaSql,The following statement contains a magic number: switch (dbType)             {                 case DbType.Boolean:                     return 16; //BOOLEAN                 case DbType.Int32:                     return 4; //INTEGER                 case DbType.Int64:                     return -5; //BIGINT                 case DbType.Single:                     return 7; //REAL                 case DbType.Double:                     return 8; //DOUBLE                 case DbType.Decimal:                     return 3; //DECIMAL                 case DbType.Xml:                 case DbType.String:                     return 12; //VARCHAR                 case DbType.Date:                     return 91; //DATE                 case DbType.Time:                     return 92; //TIME                 case DbType.DateTime:                     return 93; //TIMESTAMP                 case DbType.Binary:                     return -3; //VARBINARY                 case DbType.Object:                     return 2004; //BLOB             }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapDbTypeToJavaSql,The following statement contains a magic number: switch (dbType)             {                 case DbType.Boolean:                     return 16; //BOOLEAN                 case DbType.Int32:                     return 4; //INTEGER                 case DbType.Int64:                     return -5; //BIGINT                 case DbType.Single:                     return 7; //REAL                 case DbType.Double:                     return 8; //DOUBLE                 case DbType.Decimal:                     return 3; //DECIMAL                 case DbType.Xml:                 case DbType.String:                     return 12; //VARCHAR                 case DbType.Date:                     return 91; //DATE                 case DbType.Time:                     return 92; //TIME                 case DbType.DateTime:                     return 93; //TIMESTAMP                 case DbType.Binary:                     return -3; //VARBINARY                 case DbType.Object:                     return 2004; //BLOB             }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapDbTypeToJavaSql,The following statement contains a magic number: switch (dbType)             {                 case DbType.Boolean:                     return 16; //BOOLEAN                 case DbType.Int32:                     return 4; //INTEGER                 case DbType.Int64:                     return -5; //BIGINT                 case DbType.Single:                     return 7; //REAL                 case DbType.Double:                     return 8; //DOUBLE                 case DbType.Decimal:                     return 3; //DECIMAL                 case DbType.Xml:                 case DbType.String:                     return 12; //VARCHAR                 case DbType.Date:                     return 91; //DATE                 case DbType.Time:                     return 92; //TIME                 case DbType.DateTime:                     return 93; //TIMESTAMP                 case DbType.Binary:                     return -3; //VARBINARY                 case DbType.Object:                     return 2004; //BLOB             }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapDbTypeToJavaSql,The following statement contains a magic number: switch (dbType)             {                 case DbType.Boolean:                     return 16; //BOOLEAN                 case DbType.Int32:                     return 4; //INTEGER                 case DbType.Int64:                     return -5; //BIGINT                 case DbType.Single:                     return 7; //REAL                 case DbType.Double:                     return 8; //DOUBLE                 case DbType.Decimal:                     return 3; //DECIMAL                 case DbType.Xml:                 case DbType.String:                     return 12; //VARCHAR                 case DbType.Date:                     return 91; //DATE                 case DbType.Time:                     return 92; //TIME                 case DbType.DateTime:                     return 93; //TIMESTAMP                 case DbType.Binary:                     return -3; //VARBINARY                 case DbType.Object:                     return 2004; //BLOB             }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapDbTypeToJavaSql,The following statement contains a magic number: switch (dbType)             {                 case DbType.Boolean:                     return 16; //BOOLEAN                 case DbType.Int32:                     return 4; //INTEGER                 case DbType.Int64:                     return -5; //BIGINT                 case DbType.Single:                     return 7; //REAL                 case DbType.Double:                     return 8; //DOUBLE                 case DbType.Decimal:                     return 3; //DECIMAL                 case DbType.Xml:                 case DbType.String:                     return 12; //VARCHAR                 case DbType.Date:                     return 91; //DATE                 case DbType.Time:                     return 92; //TIME                 case DbType.DateTime:                     return 93; //TIMESTAMP                 case DbType.Binary:                     return -3; //VARBINARY                 case DbType.Object:                     return 2004; //BLOB             }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapDbTypeToJavaSql,The following statement contains a magic number: switch (dbType)             {                 case DbType.Boolean:                     return 16; //BOOLEAN                 case DbType.Int32:                     return 4; //INTEGER                 case DbType.Int64:                     return -5; //BIGINT                 case DbType.Single:                     return 7; //REAL                 case DbType.Double:                     return 8; //DOUBLE                 case DbType.Decimal:                     return 3; //DECIMAL                 case DbType.Xml:                 case DbType.String:                     return 12; //VARCHAR                 case DbType.Date:                     return 91; //DATE                 case DbType.Time:                     return 92; //TIME                 case DbType.DateTime:                     return 93; //TIMESTAMP                 case DbType.Binary:                     return -3; //VARBINARY                 case DbType.Object:                     return 2004; //BLOB             }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapDbTypeToJavaSql,The following statement contains a magic number: switch (dbType)             {                 case DbType.Boolean:                     return 16; //BOOLEAN                 case DbType.Int32:                     return 4; //INTEGER                 case DbType.Int64:                     return -5; //BIGINT                 case DbType.Single:                     return 7; //REAL                 case DbType.Double:                     return 8; //DOUBLE                 case DbType.Decimal:                     return 3; //DECIMAL                 case DbType.Xml:                 case DbType.String:                     return 12; //VARCHAR                 case DbType.Date:                     return 91; //DATE                 case DbType.Time:                     return 92; //TIME                 case DbType.DateTime:                     return 93; //TIMESTAMP                 case DbType.Binary:                     return -3; //VARBINARY                 case DbType.Object:                     return 2004; //BLOB             }
Magic Number,NuoDb.Data.Client,NuoDbDataReader,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbDataReader.cs,GetSchemaTable,The following statement contains a magic number: const int rsmdAutoIncrement = (1 << 2);
Magic Number,NuoDb.Data.Client,NuoDbDataReader,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbDataReader.cs,GetSchemaTable,The following statement contains a magic number: const int rsmdCaseSensitive = (1 << 3);
Magic Number,NuoDb.Data.Client,NuoDbDataReader,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbDataReader.cs,GetSchemaTable,The following statement contains a magic number: const int rsmdCurrency = (1 << 4);
Magic Number,NuoDb.Data.Client,NuoDbDataReader,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbDataReader.cs,GetSchemaTable,The following statement contains a magic number: const int rsmdDefinitelyWritable = (1 << 5);
Magic Number,NuoDb.Data.Client,NuoDbDataReader,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbDataReader.cs,GetSchemaTable,The following statement contains a magic number: const int rsmdWritable = (1 << 6);
Magic Number,NuoDb.Data.Client,NuoDbDataReader,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbDataReader.cs,GetSchemaTable,The following statement contains a magic number: const int rsmdReadOnly = (1 << 7);
Magic Number,NuoDb.Data.Client,NuoDbDataReader,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbDataReader.cs,GetSchemaTable,The following statement contains a magic number: const int rsmdSigned = (1 << 8);
Magic Number,NuoDb.Data.Client,NuoDbDataReader,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbDataReader.cs,GetSchemaTable,The following statement contains a magic number: const int rsmdNullable = (1 << 9);
Magic Number,NuoDb.Data.Client,DataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\DataStream.cs,DataStream,The following statement contains a magic number: base64Lookup = new byte[256];
Magic Number,NuoDb.Data.Client,DataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\DataStream.cs,DataStream,The following statement contains a magic number: base64Digits = new byte[64];
Magic Number,NuoDb.Data.Client,DataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\DataStream.cs,DataStream,The following statement contains a magic number: n < 64
Magic Number,NuoDb.Data.Client,DataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\DataStream.cs,setBase64,The following statement contains a magic number: allocate((length + 2) * 3 / 4);
Magic Number,NuoDb.Data.Client,DataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\DataStream.cs,setBase64,The following statement contains a magic number: allocate((length + 2) * 3 / 4);
Magic Number,NuoDb.Data.Client,DataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\DataStream.cs,setBase64,The following statement contains a magic number: allocate((length + 2) * 3 / 4);
Magic Number,NuoDb.Data.Client,DataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\DataStream.cs,setBase64,The following statement contains a magic number: buffer[@out++] = (byte)(bits << (6 - bitsRemaining));
Magic Number,NuoDb.Data.Client,DataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\DataStream.cs,setBase64,The following statement contains a magic number: bitsRemaining -= 8;
Magic Number,NuoDb.Data.Client,DataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\DataStream.cs,setBase64,The following statement contains a magic number: bitsRemaining >= 8
Magic Number,NuoDb.Data.Client,DataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\DataStream.cs,putBase64,The following statement contains a magic number: bits = (bits << 8) | (segment.buffer[n++] & 0xff);
Magic Number,NuoDb.Data.Client,DataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\DataStream.cs,putBase64,The following statement contains a magic number: bitsRemaining += 8;
Magic Number,NuoDb.Data.Client,DataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\DataStream.cs,putBase64,The following statement contains a magic number: bitsRemaining < 6
Magic Number,NuoDb.Data.Client,DataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\DataStream.cs,putBase64,The following statement contains a magic number: bitsRemaining -= 6;
Magic Number,NuoDb.Data.Client,DataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\DataStream.cs,putBase64,The following statement contains a magic number: bitsRemaining >= 6
Magic Number,NuoDb.Data.Client,DataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\DataStream.cs,putBase64,The following statement contains a magic number: int mod = length % 3;
Magic Number,NuoDb.Data.Client,DataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\DataStream.cs,putBase64,The following statement contains a magic number: outputStream.WriteByte(base64Digits[(bits << (6 - bitsRemaining)) & 0x3f]);
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,ScaleDecimal,The following statement contains a magic number: result /= 10.0M;
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,ConvertToScaledDecimal,The following statement contains a magic number: temp *= 10;
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,The following statement contains a magic number: n < (1 << 7)
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,The following statement contains a magic number: return 2;
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,The following statement contains a magic number: n < (1 << 15)
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,The following statement contains a magic number: return 3;
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,The following statement contains a magic number: n < (1 << 23)
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,The following statement contains a magic number: return 4;
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,The following statement contains a magic number: n >= -(1 << 7)
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,The following statement contains a magic number: return 2;
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,The following statement contains a magic number: n >= -(1 << 15)
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,The following statement contains a magic number: return 3;
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,The following statement contains a magic number: n >= -(1 << 23)
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,The following statement contains a magic number: return 4;
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,The following statement contains a magic number: n < (1L << 7)
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,The following statement contains a magic number: return 2;
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,The following statement contains a magic number: n < (1L << 15)
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,The following statement contains a magic number: return 3;
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,The following statement contains a magic number: n < (1L << 23)
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,The following statement contains a magic number: return 4;
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,The following statement contains a magic number: n < (1L << 31)
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,The following statement contains a magic number: return 5;
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,The following statement contains a magic number: n < (1L << 39)
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,The following statement contains a magic number: return 6;
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,The following statement contains a magic number: n < (1L << 47)
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,The following statement contains a magic number: return 7;
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,The following statement contains a magic number: n < (1L << 55)
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,The following statement contains a magic number: return 8;
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,The following statement contains a magic number: n >= -(1L << 7)
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,The following statement contains a magic number: return 2;
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,The following statement contains a magic number: n >= -(1L << 15)
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,The following statement contains a magic number: return 3;
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,The following statement contains a magic number: n >= -(1L << 23)
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,The following statement contains a magic number: return 4;
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,The following statement contains a magic number: n >= -(1L << 31)
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,The following statement contains a magic number: return 5;
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,The following statement contains a magic number: n >= -(1L << 39)
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,The following statement contains a magic number: return 6;
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,The following statement contains a magic number: n >= -(1L << 47)
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,The following statement contains a magic number: return 7;
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,The following statement contains a magic number: n >= -(1L << 55)
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,The following statement contains a magic number: return 8;
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,decode,The following statement contains a magic number: switch (code)             {                 case edsNull:                     type = edsTypeNull;                     break;                  case edsTrue:                     type = edsTypeBoolean;                     @bool = true;                     break;                  case edsFalse:                     type = edsTypeBoolean;                     @bool = false;                     break;                  case edsIntMinus10:                 case edsIntMinus9:                 case edsIntMinus8:                 case edsIntMinus7:                 case edsIntMinus6:                 case edsIntMinus5:                 case edsIntMinus4:                 case edsIntMinus3:                 case edsIntMinus2:                 case edsIntMinus1:                 case edsInt0:                 case edsInt1:                 case edsInt2:                 case edsInt3:                 case edsInt4:                 case edsInt5:                 case edsInt6:                 case edsInt7:                 case edsInt8:                 case edsInt9:                 case edsInt10:                 case edsInt11:                 case edsInt12:                 case edsInt13:                 case edsInt14:                 case edsInt15:                 case edsInt16:                 case edsInt17:                 case edsInt18:                 case edsInt19:                 case edsInt20:                 case edsInt21:                 case edsInt22:                 case edsInt23:                 case edsInt24:                 case edsInt25:                 case edsInt26:                 case edsInt27:                 case edsInt28:                 case edsInt29:                 case edsInt30:                 case edsInt31:                     integer32 = code - edsInt0;                     scale = 0;                     type = edsTypeInt32;                     break;                  case edsIntLen1:                     type = edsTypeInt32;                     scale = 0;                     integer32 = (sbyte)source[offset++];                     break;                  case edsIntLen2:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset] << 8) | (source[offset + 1] & 0xff);                     offset += 2;                     break;                  case edsIntLen3:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset]) << 16 | (source[offset + 1] & 0xff) << 8 | (source[offset + 2] & 0xff);                     offset += 3;                     break;                  case edsIntLen4:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset]) << 24 | (source[offset + 1] & 0xff) << 16 | (source[offset + 2] & 0xff) << 8 | (source[offset + 3] & 0xff);                     offset += 4;                     break;                  case edsIntLen5:                 case edsIntLen6:                 case edsIntLen7:                 case edsIntLen8:                     l = code - edsIntLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeInt64;                     break;                  case edsScaledLen0:                     scale = (sbyte)source[offset++];                     integer64 = 0;                     type = edsTypeScaled;                     break;                  case edsScaledLen1:                 case edsScaledLen2:                 case edsScaledLen3:                 case edsScaledLen4:                 case edsScaledLen5:                 case edsScaledLen6:                 case edsScaledLen7:                 case edsScaledLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaled;                     break;                  case edsUtf8Len0:                 case edsUtf8Len1:                 case edsUtf8Len2:                 case edsUtf8Len3:                 case edsUtf8Len4:                 case edsUtf8Len5:                 case edsUtf8Len6:                 case edsUtf8Len7:                 case edsUtf8Len8:                 case edsUtf8Len9:                 case edsUtf8Len10:                 case edsUtf8Len11:                 case edsUtf8Len12:                 case edsUtf8Len13:                 case edsUtf8Len14:                 case edsUtf8Len15:                 case edsUtf8Len16:                 case edsUtf8Len17:                 case edsUtf8Len18:                 case edsUtf8Len19:                 case edsUtf8Len20:                 case edsUtf8Len21:                 case edsUtf8Len22:                 case edsUtf8Len23:                 case edsUtf8Len24:                 case edsUtf8Len25:                 case edsUtf8Len26:                 case edsUtf8Len27:                 case edsUtf8Len28:                 case edsUtf8Len29:                 case edsUtf8Len30:                 case edsUtf8Len31:                 case edsUtf8Len32:                 case edsUtf8Len33:                 case edsUtf8Len34:                 case edsUtf8Len35:                 case edsUtf8Len36:                 case edsUtf8Len37:                 case edsUtf8Len38:                 case edsUtf8Len39:                     l = code - edsUtf8Len0;                     @string = getString(source' offset' l);                     offset += l;                     type = edsTypeUtf8;                     break;                  case edsUtf8Count1:                 case edsUtf8Count2:                 case edsUtf8Count3:                 case edsUtf8Count4:                     count = code - edsUtf8Count1;                     int length = source[offset++] & 0xff;                      for (int n = 0; n < count; ++n)                     {                         length = length << 8 | (source[offset++] & 0xff);                     }                      @string = getString(source' offset' length);                     offset += length;                     type = edsTypeUtf8;                     break;                  case edsOpaqueLen0:                 case edsOpaqueLen1:                 case edsOpaqueLen2:                 case edsOpaqueLen3:                 case edsOpaqueLen4:                 case edsOpaqueLen5:                 case edsOpaqueLen6:                 case edsOpaqueLen7:                 case edsOpaqueLen8:                 case edsOpaqueLen9:                 case edsOpaqueLen10:                 case edsOpaqueLen11:                 case edsOpaqueLen12:                 case edsOpaqueLen13:                 case edsOpaqueLen14:                 case edsOpaqueLen15:                 case edsOpaqueLen16:                 case edsOpaqueLen17:                 case edsOpaqueLen18:                 case edsOpaqueLen19:                 case edsOpaqueLen20:                 case edsOpaqueLen21:                 case edsOpaqueLen22:                 case edsOpaqueLen23:                 case edsOpaqueLen24:                 case edsOpaqueLen25:                 case edsOpaqueLen26:                 case edsOpaqueLen27:                 case edsOpaqueLen28:                 case edsOpaqueLen29:                 case edsOpaqueLen30:                 case edsOpaqueLen31:                 case edsOpaqueLen32:                 case edsOpaqueLen33:                 case edsOpaqueLen34:                 case edsOpaqueLen35:                 case edsOpaqueLen36:                 case edsOpaqueLen37:                 case edsOpaqueLen38:                 case edsOpaqueLen39:                     l = code - edsOpaqueLen0;                     bytes = new byte[l];                     Array.Copy(source' offset' bytes' 0' l);                     offset += l;                     type = edsTypeOpaque;                     break;                  case edsOpaqueCount1:                 case edsOpaqueCount2:                 case edsOpaqueCount3:                 case edsOpaqueCount4:                     count = code - edsOpaqueCount1 + 1;                     l = source[offset++] & 0xff;                      for (int n = 1; n < count; ++n)                     {                         l = l << 8 | (source[offset++] & 0xff);                     }                      bytes = new byte[l];                     Array.Copy(source' offset' bytes' 0' l);                     offset += l;                     type = edsTypeOpaque;                     break;                  case edsDoubleLen0:                 case edsDoubleLen1:                 case edsDoubleLen2:                 case edsDoubleLen3:                 case edsDoubleLen4:                 case edsDoubleLen5:                 case edsDoubleLen6:                 case edsDoubleLen7:                 case edsDoubleLen8:                     count = code - edsDoubleLen0;                     long lvalue = 0;                      for (int n = 0; n < count; ++n)                     {                         lvalue = (lvalue << 8) | (source[offset++] & 0xff);                     }                      lvalue <<= (8 - count) * 8;                     dbl = BitConverter.Int64BitsToDouble(lvalue);                     type = edsTypeDouble;                     break;                  case edsTimeLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeTime;                     break;                  case edsTimeLen1:                 case edsTimeLen2:                 case edsTimeLen3:                 case edsTimeLen4:                     l = code - edsTimeLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeTime;                     break;                  case edsMilliSecLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeMilliseconds;                     break;                  case edsMilliSecLen1:                 case edsMilliSecLen2:                 case edsMilliSecLen3:                 case edsMilliSecLen4:                 case edsMilliSecLen5:                 case edsMilliSecLen6:                 case edsMilliSecLen7:                 case edsMilliSecLen8:                     l = code - edsMilliSecLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeMilliseconds;                     break;                  case edsNanoSecLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeNanoseconds;                     break;                  case edsNanoSecLen1:                 case edsNanoSecLen2:                 case edsNanoSecLen3:                 case edsNanoSecLen4:                 case edsNanoSecLen5:                 case edsNanoSecLen6:                 case edsNanoSecLen7:                 case edsNanoSecLen8:                     l = code - edsNanoSecLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeNanoseconds;                     break;                  //                 // 09/2012 Added support for new scaled date/times encoding. These replace the old encoding                 // edsTimeLen' edsMilliSecLen and edsNanoSecLen.                 //                  case edsScaledTimeLen1:                 case edsScaledTimeLen2:                 case edsScaledTimeLen3:                 case edsScaledTimeLen4:                 case edsScaledTimeLen5:                 case edsScaledTimeLen6:                 case edsScaledTimeLen7:                 case edsScaledTimeLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledTimeLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledTime;                     break;                  case edsScaledDateLen1:                 case edsScaledDateLen2:                 case edsScaledDateLen3:                 case edsScaledDateLen4:                 case edsScaledDateLen5:                 case edsScaledDateLen6:                 case edsScaledDateLen7:                 case edsScaledDateLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledDateLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledDate;                     break;                  case edsScaledTimestampLen1:                 case edsScaledTimestampLen2:                 case edsScaledTimestampLen3:                 case edsScaledTimestampLen4:                 case edsScaledTimestampLen5:                 case edsScaledTimestampLen6:                 case edsScaledTimestampLen7:                 case edsScaledTimestampLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledTimestampLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledTimestamp;                     break;                  case edsClobLen0:                     blobId = 0;                     type = edsTypeClob;                     break;                  case edsClobLen1:                 case edsClobLen2:                 case edsClobLen3:                 case edsClobLen4:                     l = code - edsClobLen1;                     blobId = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         blobId = (blobId << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeClob;                     break;                  case edsBlobLen0:                     blobId = 0;                     type = edsTypeBlob;                     break;                  case edsBlobLen1:                 case edsBlobLen2:                 case edsBlobLen3:                 case edsBlobLen4:                     l = code - edsBlobLen1;                     blobId = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         blobId = (blobId << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeBlob;                     break;                  case edsScaledCount1:                     {                         // For some reason C++ EncodedStream expects the encoded                         // length to be length+1.                          length = (source[offset++] & 0xff) - 1;                         scale = (sbyte)source[offset++];                         type = edsTypeBigInt;                         bytes = new byte[length];                         Array.Copy(source' offset' bytes' 0' length);                         offset += length;                         int sign = ((bytes[0] & 0x80) > 0) ? -1 : 1;                          if (sign == -1)                         {                             bytes[0] &= 0x7f;                         }                          BigInteger bi = new BigInteger(bytes);                         bigDecimal = Decimal.Parse(bi.ToString());                     }                     break;                  case edsScaledCount2:                     {                         // For some reason C++ EncodedStream expects the encoded                         // length to be length+1.                          scale = (sbyte)source[offset++];                         sbyte sign = (sbyte)source[offset++];                         length = (source[offset++] & 0xff); // in bytes                         type = edsTypeBigInt;                         bytes = new byte[length];                         Array.Copy(source' offset' bytes' 0' length);                         offset += length;                          if (sign == -1)                             bytes[0] &= 0x7f;                         else                             sign = 1;                          BigInteger bi = new BigInteger(bytes);                         if (sign == -1)                             bi = -bi;                         bigDecimal = ScaleDecimal(Decimal.Parse(bi.ToString())' scale);                     }                     break;                  case edsUUID:                     {                         byte[] buff = new byte[16];                          for (int n = 0; n < 16; ++n)                         {                             buff[n] = (byte)(source[offset++] & 0xff);                         }                          uuid = new Guid(buff);                         type = edsTypeUUID;                     }                     break;                  default:                     type = edsTypeUnknown;                     break;             }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,decode,The following statement contains a magic number: switch (code)             {                 case edsNull:                     type = edsTypeNull;                     break;                  case edsTrue:                     type = edsTypeBoolean;                     @bool = true;                     break;                  case edsFalse:                     type = edsTypeBoolean;                     @bool = false;                     break;                  case edsIntMinus10:                 case edsIntMinus9:                 case edsIntMinus8:                 case edsIntMinus7:                 case edsIntMinus6:                 case edsIntMinus5:                 case edsIntMinus4:                 case edsIntMinus3:                 case edsIntMinus2:                 case edsIntMinus1:                 case edsInt0:                 case edsInt1:                 case edsInt2:                 case edsInt3:                 case edsInt4:                 case edsInt5:                 case edsInt6:                 case edsInt7:                 case edsInt8:                 case edsInt9:                 case edsInt10:                 case edsInt11:                 case edsInt12:                 case edsInt13:                 case edsInt14:                 case edsInt15:                 case edsInt16:                 case edsInt17:                 case edsInt18:                 case edsInt19:                 case edsInt20:                 case edsInt21:                 case edsInt22:                 case edsInt23:                 case edsInt24:                 case edsInt25:                 case edsInt26:                 case edsInt27:                 case edsInt28:                 case edsInt29:                 case edsInt30:                 case edsInt31:                     integer32 = code - edsInt0;                     scale = 0;                     type = edsTypeInt32;                     break;                  case edsIntLen1:                     type = edsTypeInt32;                     scale = 0;                     integer32 = (sbyte)source[offset++];                     break;                  case edsIntLen2:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset] << 8) | (source[offset + 1] & 0xff);                     offset += 2;                     break;                  case edsIntLen3:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset]) << 16 | (source[offset + 1] & 0xff) << 8 | (source[offset + 2] & 0xff);                     offset += 3;                     break;                  case edsIntLen4:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset]) << 24 | (source[offset + 1] & 0xff) << 16 | (source[offset + 2] & 0xff) << 8 | (source[offset + 3] & 0xff);                     offset += 4;                     break;                  case edsIntLen5:                 case edsIntLen6:                 case edsIntLen7:                 case edsIntLen8:                     l = code - edsIntLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeInt64;                     break;                  case edsScaledLen0:                     scale = (sbyte)source[offset++];                     integer64 = 0;                     type = edsTypeScaled;                     break;                  case edsScaledLen1:                 case edsScaledLen2:                 case edsScaledLen3:                 case edsScaledLen4:                 case edsScaledLen5:                 case edsScaledLen6:                 case edsScaledLen7:                 case edsScaledLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaled;                     break;                  case edsUtf8Len0:                 case edsUtf8Len1:                 case edsUtf8Len2:                 case edsUtf8Len3:                 case edsUtf8Len4:                 case edsUtf8Len5:                 case edsUtf8Len6:                 case edsUtf8Len7:                 case edsUtf8Len8:                 case edsUtf8Len9:                 case edsUtf8Len10:                 case edsUtf8Len11:                 case edsUtf8Len12:                 case edsUtf8Len13:                 case edsUtf8Len14:                 case edsUtf8Len15:                 case edsUtf8Len16:                 case edsUtf8Len17:                 case edsUtf8Len18:                 case edsUtf8Len19:                 case edsUtf8Len20:                 case edsUtf8Len21:                 case edsUtf8Len22:                 case edsUtf8Len23:                 case edsUtf8Len24:                 case edsUtf8Len25:                 case edsUtf8Len26:                 case edsUtf8Len27:                 case edsUtf8Len28:                 case edsUtf8Len29:                 case edsUtf8Len30:                 case edsUtf8Len31:                 case edsUtf8Len32:                 case edsUtf8Len33:                 case edsUtf8Len34:                 case edsUtf8Len35:                 case edsUtf8Len36:                 case edsUtf8Len37:                 case edsUtf8Len38:                 case edsUtf8Len39:                     l = code - edsUtf8Len0;                     @string = getString(source' offset' l);                     offset += l;                     type = edsTypeUtf8;                     break;                  case edsUtf8Count1:                 case edsUtf8Count2:                 case edsUtf8Count3:                 case edsUtf8Count4:                     count = code - edsUtf8Count1;                     int length = source[offset++] & 0xff;                      for (int n = 0; n < count; ++n)                     {                         length = length << 8 | (source[offset++] & 0xff);                     }                      @string = getString(source' offset' length);                     offset += length;                     type = edsTypeUtf8;                     break;                  case edsOpaqueLen0:                 case edsOpaqueLen1:                 case edsOpaqueLen2:                 case edsOpaqueLen3:                 case edsOpaqueLen4:                 case edsOpaqueLen5:                 case edsOpaqueLen6:                 case edsOpaqueLen7:                 case edsOpaqueLen8:                 case edsOpaqueLen9:                 case edsOpaqueLen10:                 case edsOpaqueLen11:                 case edsOpaqueLen12:                 case edsOpaqueLen13:                 case edsOpaqueLen14:                 case edsOpaqueLen15:                 case edsOpaqueLen16:                 case edsOpaqueLen17:                 case edsOpaqueLen18:                 case edsOpaqueLen19:                 case edsOpaqueLen20:                 case edsOpaqueLen21:                 case edsOpaqueLen22:                 case edsOpaqueLen23:                 case edsOpaqueLen24:                 case edsOpaqueLen25:                 case edsOpaqueLen26:                 case edsOpaqueLen27:                 case edsOpaqueLen28:                 case edsOpaqueLen29:                 case edsOpaqueLen30:                 case edsOpaqueLen31:                 case edsOpaqueLen32:                 case edsOpaqueLen33:                 case edsOpaqueLen34:                 case edsOpaqueLen35:                 case edsOpaqueLen36:                 case edsOpaqueLen37:                 case edsOpaqueLen38:                 case edsOpaqueLen39:                     l = code - edsOpaqueLen0;                     bytes = new byte[l];                     Array.Copy(source' offset' bytes' 0' l);                     offset += l;                     type = edsTypeOpaque;                     break;                  case edsOpaqueCount1:                 case edsOpaqueCount2:                 case edsOpaqueCount3:                 case edsOpaqueCount4:                     count = code - edsOpaqueCount1 + 1;                     l = source[offset++] & 0xff;                      for (int n = 1; n < count; ++n)                     {                         l = l << 8 | (source[offset++] & 0xff);                     }                      bytes = new byte[l];                     Array.Copy(source' offset' bytes' 0' l);                     offset += l;                     type = edsTypeOpaque;                     break;                  case edsDoubleLen0:                 case edsDoubleLen1:                 case edsDoubleLen2:                 case edsDoubleLen3:                 case edsDoubleLen4:                 case edsDoubleLen5:                 case edsDoubleLen6:                 case edsDoubleLen7:                 case edsDoubleLen8:                     count = code - edsDoubleLen0;                     long lvalue = 0;                      for (int n = 0; n < count; ++n)                     {                         lvalue = (lvalue << 8) | (source[offset++] & 0xff);                     }                      lvalue <<= (8 - count) * 8;                     dbl = BitConverter.Int64BitsToDouble(lvalue);                     type = edsTypeDouble;                     break;                  case edsTimeLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeTime;                     break;                  case edsTimeLen1:                 case edsTimeLen2:                 case edsTimeLen3:                 case edsTimeLen4:                     l = code - edsTimeLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeTime;                     break;                  case edsMilliSecLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeMilliseconds;                     break;                  case edsMilliSecLen1:                 case edsMilliSecLen2:                 case edsMilliSecLen3:                 case edsMilliSecLen4:                 case edsMilliSecLen5:                 case edsMilliSecLen6:                 case edsMilliSecLen7:                 case edsMilliSecLen8:                     l = code - edsMilliSecLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeMilliseconds;                     break;                  case edsNanoSecLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeNanoseconds;                     break;                  case edsNanoSecLen1:                 case edsNanoSecLen2:                 case edsNanoSecLen3:                 case edsNanoSecLen4:                 case edsNanoSecLen5:                 case edsNanoSecLen6:                 case edsNanoSecLen7:                 case edsNanoSecLen8:                     l = code - edsNanoSecLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeNanoseconds;                     break;                  //                 // 09/2012 Added support for new scaled date/times encoding. These replace the old encoding                 // edsTimeLen' edsMilliSecLen and edsNanoSecLen.                 //                  case edsScaledTimeLen1:                 case edsScaledTimeLen2:                 case edsScaledTimeLen3:                 case edsScaledTimeLen4:                 case edsScaledTimeLen5:                 case edsScaledTimeLen6:                 case edsScaledTimeLen7:                 case edsScaledTimeLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledTimeLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledTime;                     break;                  case edsScaledDateLen1:                 case edsScaledDateLen2:                 case edsScaledDateLen3:                 case edsScaledDateLen4:                 case edsScaledDateLen5:                 case edsScaledDateLen6:                 case edsScaledDateLen7:                 case edsScaledDateLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledDateLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledDate;                     break;                  case edsScaledTimestampLen1:                 case edsScaledTimestampLen2:                 case edsScaledTimestampLen3:                 case edsScaledTimestampLen4:                 case edsScaledTimestampLen5:                 case edsScaledTimestampLen6:                 case edsScaledTimestampLen7:                 case edsScaledTimestampLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledTimestampLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledTimestamp;                     break;                  case edsClobLen0:                     blobId = 0;                     type = edsTypeClob;                     break;                  case edsClobLen1:                 case edsClobLen2:                 case edsClobLen3:                 case edsClobLen4:                     l = code - edsClobLen1;                     blobId = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         blobId = (blobId << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeClob;                     break;                  case edsBlobLen0:                     blobId = 0;                     type = edsTypeBlob;                     break;                  case edsBlobLen1:                 case edsBlobLen2:                 case edsBlobLen3:                 case edsBlobLen4:                     l = code - edsBlobLen1;                     blobId = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         blobId = (blobId << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeBlob;                     break;                  case edsScaledCount1:                     {                         // For some reason C++ EncodedStream expects the encoded                         // length to be length+1.                          length = (source[offset++] & 0xff) - 1;                         scale = (sbyte)source[offset++];                         type = edsTypeBigInt;                         bytes = new byte[length];                         Array.Copy(source' offset' bytes' 0' length);                         offset += length;                         int sign = ((bytes[0] & 0x80) > 0) ? -1 : 1;                          if (sign == -1)                         {                             bytes[0] &= 0x7f;                         }                          BigInteger bi = new BigInteger(bytes);                         bigDecimal = Decimal.Parse(bi.ToString());                     }                     break;                  case edsScaledCount2:                     {                         // For some reason C++ EncodedStream expects the encoded                         // length to be length+1.                          scale = (sbyte)source[offset++];                         sbyte sign = (sbyte)source[offset++];                         length = (source[offset++] & 0xff); // in bytes                         type = edsTypeBigInt;                         bytes = new byte[length];                         Array.Copy(source' offset' bytes' 0' length);                         offset += length;                          if (sign == -1)                             bytes[0] &= 0x7f;                         else                             sign = 1;                          BigInteger bi = new BigInteger(bytes);                         if (sign == -1)                             bi = -bi;                         bigDecimal = ScaleDecimal(Decimal.Parse(bi.ToString())' scale);                     }                     break;                  case edsUUID:                     {                         byte[] buff = new byte[16];                          for (int n = 0; n < 16; ++n)                         {                             buff[n] = (byte)(source[offset++] & 0xff);                         }                          uuid = new Guid(buff);                         type = edsTypeUUID;                     }                     break;                  default:                     type = edsTypeUnknown;                     break;             }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,decode,The following statement contains a magic number: switch (code)             {                 case edsNull:                     type = edsTypeNull;                     break;                  case edsTrue:                     type = edsTypeBoolean;                     @bool = true;                     break;                  case edsFalse:                     type = edsTypeBoolean;                     @bool = false;                     break;                  case edsIntMinus10:                 case edsIntMinus9:                 case edsIntMinus8:                 case edsIntMinus7:                 case edsIntMinus6:                 case edsIntMinus5:                 case edsIntMinus4:                 case edsIntMinus3:                 case edsIntMinus2:                 case edsIntMinus1:                 case edsInt0:                 case edsInt1:                 case edsInt2:                 case edsInt3:                 case edsInt4:                 case edsInt5:                 case edsInt6:                 case edsInt7:                 case edsInt8:                 case edsInt9:                 case edsInt10:                 case edsInt11:                 case edsInt12:                 case edsInt13:                 case edsInt14:                 case edsInt15:                 case edsInt16:                 case edsInt17:                 case edsInt18:                 case edsInt19:                 case edsInt20:                 case edsInt21:                 case edsInt22:                 case edsInt23:                 case edsInt24:                 case edsInt25:                 case edsInt26:                 case edsInt27:                 case edsInt28:                 case edsInt29:                 case edsInt30:                 case edsInt31:                     integer32 = code - edsInt0;                     scale = 0;                     type = edsTypeInt32;                     break;                  case edsIntLen1:                     type = edsTypeInt32;                     scale = 0;                     integer32 = (sbyte)source[offset++];                     break;                  case edsIntLen2:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset] << 8) | (source[offset + 1] & 0xff);                     offset += 2;                     break;                  case edsIntLen3:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset]) << 16 | (source[offset + 1] & 0xff) << 8 | (source[offset + 2] & 0xff);                     offset += 3;                     break;                  case edsIntLen4:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset]) << 24 | (source[offset + 1] & 0xff) << 16 | (source[offset + 2] & 0xff) << 8 | (source[offset + 3] & 0xff);                     offset += 4;                     break;                  case edsIntLen5:                 case edsIntLen6:                 case edsIntLen7:                 case edsIntLen8:                     l = code - edsIntLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeInt64;                     break;                  case edsScaledLen0:                     scale = (sbyte)source[offset++];                     integer64 = 0;                     type = edsTypeScaled;                     break;                  case edsScaledLen1:                 case edsScaledLen2:                 case edsScaledLen3:                 case edsScaledLen4:                 case edsScaledLen5:                 case edsScaledLen6:                 case edsScaledLen7:                 case edsScaledLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaled;                     break;                  case edsUtf8Len0:                 case edsUtf8Len1:                 case edsUtf8Len2:                 case edsUtf8Len3:                 case edsUtf8Len4:                 case edsUtf8Len5:                 case edsUtf8Len6:                 case edsUtf8Len7:                 case edsUtf8Len8:                 case edsUtf8Len9:                 case edsUtf8Len10:                 case edsUtf8Len11:                 case edsUtf8Len12:                 case edsUtf8Len13:                 case edsUtf8Len14:                 case edsUtf8Len15:                 case edsUtf8Len16:                 case edsUtf8Len17:                 case edsUtf8Len18:                 case edsUtf8Len19:                 case edsUtf8Len20:                 case edsUtf8Len21:                 case edsUtf8Len22:                 case edsUtf8Len23:                 case edsUtf8Len24:                 case edsUtf8Len25:                 case edsUtf8Len26:                 case edsUtf8Len27:                 case edsUtf8Len28:                 case edsUtf8Len29:                 case edsUtf8Len30:                 case edsUtf8Len31:                 case edsUtf8Len32:                 case edsUtf8Len33:                 case edsUtf8Len34:                 case edsUtf8Len35:                 case edsUtf8Len36:                 case edsUtf8Len37:                 case edsUtf8Len38:                 case edsUtf8Len39:                     l = code - edsUtf8Len0;                     @string = getString(source' offset' l);                     offset += l;                     type = edsTypeUtf8;                     break;                  case edsUtf8Count1:                 case edsUtf8Count2:                 case edsUtf8Count3:                 case edsUtf8Count4:                     count = code - edsUtf8Count1;                     int length = source[offset++] & 0xff;                      for (int n = 0; n < count; ++n)                     {                         length = length << 8 | (source[offset++] & 0xff);                     }                      @string = getString(source' offset' length);                     offset += length;                     type = edsTypeUtf8;                     break;                  case edsOpaqueLen0:                 case edsOpaqueLen1:                 case edsOpaqueLen2:                 case edsOpaqueLen3:                 case edsOpaqueLen4:                 case edsOpaqueLen5:                 case edsOpaqueLen6:                 case edsOpaqueLen7:                 case edsOpaqueLen8:                 case edsOpaqueLen9:                 case edsOpaqueLen10:                 case edsOpaqueLen11:                 case edsOpaqueLen12:                 case edsOpaqueLen13:                 case edsOpaqueLen14:                 case edsOpaqueLen15:                 case edsOpaqueLen16:                 case edsOpaqueLen17:                 case edsOpaqueLen18:                 case edsOpaqueLen19:                 case edsOpaqueLen20:                 case edsOpaqueLen21:                 case edsOpaqueLen22:                 case edsOpaqueLen23:                 case edsOpaqueLen24:                 case edsOpaqueLen25:                 case edsOpaqueLen26:                 case edsOpaqueLen27:                 case edsOpaqueLen28:                 case edsOpaqueLen29:                 case edsOpaqueLen30:                 case edsOpaqueLen31:                 case edsOpaqueLen32:                 case edsOpaqueLen33:                 case edsOpaqueLen34:                 case edsOpaqueLen35:                 case edsOpaqueLen36:                 case edsOpaqueLen37:                 case edsOpaqueLen38:                 case edsOpaqueLen39:                     l = code - edsOpaqueLen0;                     bytes = new byte[l];                     Array.Copy(source' offset' bytes' 0' l);                     offset += l;                     type = edsTypeOpaque;                     break;                  case edsOpaqueCount1:                 case edsOpaqueCount2:                 case edsOpaqueCount3:                 case edsOpaqueCount4:                     count = code - edsOpaqueCount1 + 1;                     l = source[offset++] & 0xff;                      for (int n = 1; n < count; ++n)                     {                         l = l << 8 | (source[offset++] & 0xff);                     }                      bytes = new byte[l];                     Array.Copy(source' offset' bytes' 0' l);                     offset += l;                     type = edsTypeOpaque;                     break;                  case edsDoubleLen0:                 case edsDoubleLen1:                 case edsDoubleLen2:                 case edsDoubleLen3:                 case edsDoubleLen4:                 case edsDoubleLen5:                 case edsDoubleLen6:                 case edsDoubleLen7:                 case edsDoubleLen8:                     count = code - edsDoubleLen0;                     long lvalue = 0;                      for (int n = 0; n < count; ++n)                     {                         lvalue = (lvalue << 8) | (source[offset++] & 0xff);                     }                      lvalue <<= (8 - count) * 8;                     dbl = BitConverter.Int64BitsToDouble(lvalue);                     type = edsTypeDouble;                     break;                  case edsTimeLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeTime;                     break;                  case edsTimeLen1:                 case edsTimeLen2:                 case edsTimeLen3:                 case edsTimeLen4:                     l = code - edsTimeLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeTime;                     break;                  case edsMilliSecLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeMilliseconds;                     break;                  case edsMilliSecLen1:                 case edsMilliSecLen2:                 case edsMilliSecLen3:                 case edsMilliSecLen4:                 case edsMilliSecLen5:                 case edsMilliSecLen6:                 case edsMilliSecLen7:                 case edsMilliSecLen8:                     l = code - edsMilliSecLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeMilliseconds;                     break;                  case edsNanoSecLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeNanoseconds;                     break;                  case edsNanoSecLen1:                 case edsNanoSecLen2:                 case edsNanoSecLen3:                 case edsNanoSecLen4:                 case edsNanoSecLen5:                 case edsNanoSecLen6:                 case edsNanoSecLen7:                 case edsNanoSecLen8:                     l = code - edsNanoSecLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeNanoseconds;                     break;                  //                 // 09/2012 Added support for new scaled date/times encoding. These replace the old encoding                 // edsTimeLen' edsMilliSecLen and edsNanoSecLen.                 //                  case edsScaledTimeLen1:                 case edsScaledTimeLen2:                 case edsScaledTimeLen3:                 case edsScaledTimeLen4:                 case edsScaledTimeLen5:                 case edsScaledTimeLen6:                 case edsScaledTimeLen7:                 case edsScaledTimeLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledTimeLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledTime;                     break;                  case edsScaledDateLen1:                 case edsScaledDateLen2:                 case edsScaledDateLen3:                 case edsScaledDateLen4:                 case edsScaledDateLen5:                 case edsScaledDateLen6:                 case edsScaledDateLen7:                 case edsScaledDateLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledDateLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledDate;                     break;                  case edsScaledTimestampLen1:                 case edsScaledTimestampLen2:                 case edsScaledTimestampLen3:                 case edsScaledTimestampLen4:                 case edsScaledTimestampLen5:                 case edsScaledTimestampLen6:                 case edsScaledTimestampLen7:                 case edsScaledTimestampLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledTimestampLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledTimestamp;                     break;                  case edsClobLen0:                     blobId = 0;                     type = edsTypeClob;                     break;                  case edsClobLen1:                 case edsClobLen2:                 case edsClobLen3:                 case edsClobLen4:                     l = code - edsClobLen1;                     blobId = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         blobId = (blobId << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeClob;                     break;                  case edsBlobLen0:                     blobId = 0;                     type = edsTypeBlob;                     break;                  case edsBlobLen1:                 case edsBlobLen2:                 case edsBlobLen3:                 case edsBlobLen4:                     l = code - edsBlobLen1;                     blobId = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         blobId = (blobId << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeBlob;                     break;                  case edsScaledCount1:                     {                         // For some reason C++ EncodedStream expects the encoded                         // length to be length+1.                          length = (source[offset++] & 0xff) - 1;                         scale = (sbyte)source[offset++];                         type = edsTypeBigInt;                         bytes = new byte[length];                         Array.Copy(source' offset' bytes' 0' length);                         offset += length;                         int sign = ((bytes[0] & 0x80) > 0) ? -1 : 1;                          if (sign == -1)                         {                             bytes[0] &= 0x7f;                         }                          BigInteger bi = new BigInteger(bytes);                         bigDecimal = Decimal.Parse(bi.ToString());                     }                     break;                  case edsScaledCount2:                     {                         // For some reason C++ EncodedStream expects the encoded                         // length to be length+1.                          scale = (sbyte)source[offset++];                         sbyte sign = (sbyte)source[offset++];                         length = (source[offset++] & 0xff); // in bytes                         type = edsTypeBigInt;                         bytes = new byte[length];                         Array.Copy(source' offset' bytes' 0' length);                         offset += length;                          if (sign == -1)                             bytes[0] &= 0x7f;                         else                             sign = 1;                          BigInteger bi = new BigInteger(bytes);                         if (sign == -1)                             bi = -bi;                         bigDecimal = ScaleDecimal(Decimal.Parse(bi.ToString())' scale);                     }                     break;                  case edsUUID:                     {                         byte[] buff = new byte[16];                          for (int n = 0; n < 16; ++n)                         {                             buff[n] = (byte)(source[offset++] & 0xff);                         }                          uuid = new Guid(buff);                         type = edsTypeUUID;                     }                     break;                  default:                     type = edsTypeUnknown;                     break;             }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,decode,The following statement contains a magic number: switch (code)             {                 case edsNull:                     type = edsTypeNull;                     break;                  case edsTrue:                     type = edsTypeBoolean;                     @bool = true;                     break;                  case edsFalse:                     type = edsTypeBoolean;                     @bool = false;                     break;                  case edsIntMinus10:                 case edsIntMinus9:                 case edsIntMinus8:                 case edsIntMinus7:                 case edsIntMinus6:                 case edsIntMinus5:                 case edsIntMinus4:                 case edsIntMinus3:                 case edsIntMinus2:                 case edsIntMinus1:                 case edsInt0:                 case edsInt1:                 case edsInt2:                 case edsInt3:                 case edsInt4:                 case edsInt5:                 case edsInt6:                 case edsInt7:                 case edsInt8:                 case edsInt9:                 case edsInt10:                 case edsInt11:                 case edsInt12:                 case edsInt13:                 case edsInt14:                 case edsInt15:                 case edsInt16:                 case edsInt17:                 case edsInt18:                 case edsInt19:                 case edsInt20:                 case edsInt21:                 case edsInt22:                 case edsInt23:                 case edsInt24:                 case edsInt25:                 case edsInt26:                 case edsInt27:                 case edsInt28:                 case edsInt29:                 case edsInt30:                 case edsInt31:                     integer32 = code - edsInt0;                     scale = 0;                     type = edsTypeInt32;                     break;                  case edsIntLen1:                     type = edsTypeInt32;                     scale = 0;                     integer32 = (sbyte)source[offset++];                     break;                  case edsIntLen2:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset] << 8) | (source[offset + 1] & 0xff);                     offset += 2;                     break;                  case edsIntLen3:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset]) << 16 | (source[offset + 1] & 0xff) << 8 | (source[offset + 2] & 0xff);                     offset += 3;                     break;                  case edsIntLen4:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset]) << 24 | (source[offset + 1] & 0xff) << 16 | (source[offset + 2] & 0xff) << 8 | (source[offset + 3] & 0xff);                     offset += 4;                     break;                  case edsIntLen5:                 case edsIntLen6:                 case edsIntLen7:                 case edsIntLen8:                     l = code - edsIntLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeInt64;                     break;                  case edsScaledLen0:                     scale = (sbyte)source[offset++];                     integer64 = 0;                     type = edsTypeScaled;                     break;                  case edsScaledLen1:                 case edsScaledLen2:                 case edsScaledLen3:                 case edsScaledLen4:                 case edsScaledLen5:                 case edsScaledLen6:                 case edsScaledLen7:                 case edsScaledLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaled;                     break;                  case edsUtf8Len0:                 case edsUtf8Len1:                 case edsUtf8Len2:                 case edsUtf8Len3:                 case edsUtf8Len4:                 case edsUtf8Len5:                 case edsUtf8Len6:                 case edsUtf8Len7:                 case edsUtf8Len8:                 case edsUtf8Len9:                 case edsUtf8Len10:                 case edsUtf8Len11:                 case edsUtf8Len12:                 case edsUtf8Len13:                 case edsUtf8Len14:                 case edsUtf8Len15:                 case edsUtf8Len16:                 case edsUtf8Len17:                 case edsUtf8Len18:                 case edsUtf8Len19:                 case edsUtf8Len20:                 case edsUtf8Len21:                 case edsUtf8Len22:                 case edsUtf8Len23:                 case edsUtf8Len24:                 case edsUtf8Len25:                 case edsUtf8Len26:                 case edsUtf8Len27:                 case edsUtf8Len28:                 case edsUtf8Len29:                 case edsUtf8Len30:                 case edsUtf8Len31:                 case edsUtf8Len32:                 case edsUtf8Len33:                 case edsUtf8Len34:                 case edsUtf8Len35:                 case edsUtf8Len36:                 case edsUtf8Len37:                 case edsUtf8Len38:                 case edsUtf8Len39:                     l = code - edsUtf8Len0;                     @string = getString(source' offset' l);                     offset += l;                     type = edsTypeUtf8;                     break;                  case edsUtf8Count1:                 case edsUtf8Count2:                 case edsUtf8Count3:                 case edsUtf8Count4:                     count = code - edsUtf8Count1;                     int length = source[offset++] & 0xff;                      for (int n = 0; n < count; ++n)                     {                         length = length << 8 | (source[offset++] & 0xff);                     }                      @string = getString(source' offset' length);                     offset += length;                     type = edsTypeUtf8;                     break;                  case edsOpaqueLen0:                 case edsOpaqueLen1:                 case edsOpaqueLen2:                 case edsOpaqueLen3:                 case edsOpaqueLen4:                 case edsOpaqueLen5:                 case edsOpaqueLen6:                 case edsOpaqueLen7:                 case edsOpaqueLen8:                 case edsOpaqueLen9:                 case edsOpaqueLen10:                 case edsOpaqueLen11:                 case edsOpaqueLen12:                 case edsOpaqueLen13:                 case edsOpaqueLen14:                 case edsOpaqueLen15:                 case edsOpaqueLen16:                 case edsOpaqueLen17:                 case edsOpaqueLen18:                 case edsOpaqueLen19:                 case edsOpaqueLen20:                 case edsOpaqueLen21:                 case edsOpaqueLen22:                 case edsOpaqueLen23:                 case edsOpaqueLen24:                 case edsOpaqueLen25:                 case edsOpaqueLen26:                 case edsOpaqueLen27:                 case edsOpaqueLen28:                 case edsOpaqueLen29:                 case edsOpaqueLen30:                 case edsOpaqueLen31:                 case edsOpaqueLen32:                 case edsOpaqueLen33:                 case edsOpaqueLen34:                 case edsOpaqueLen35:                 case edsOpaqueLen36:                 case edsOpaqueLen37:                 case edsOpaqueLen38:                 case edsOpaqueLen39:                     l = code - edsOpaqueLen0;                     bytes = new byte[l];                     Array.Copy(source' offset' bytes' 0' l);                     offset += l;                     type = edsTypeOpaque;                     break;                  case edsOpaqueCount1:                 case edsOpaqueCount2:                 case edsOpaqueCount3:                 case edsOpaqueCount4:                     count = code - edsOpaqueCount1 + 1;                     l = source[offset++] & 0xff;                      for (int n = 1; n < count; ++n)                     {                         l = l << 8 | (source[offset++] & 0xff);                     }                      bytes = new byte[l];                     Array.Copy(source' offset' bytes' 0' l);                     offset += l;                     type = edsTypeOpaque;                     break;                  case edsDoubleLen0:                 case edsDoubleLen1:                 case edsDoubleLen2:                 case edsDoubleLen3:                 case edsDoubleLen4:                 case edsDoubleLen5:                 case edsDoubleLen6:                 case edsDoubleLen7:                 case edsDoubleLen8:                     count = code - edsDoubleLen0;                     long lvalue = 0;                      for (int n = 0; n < count; ++n)                     {                         lvalue = (lvalue << 8) | (source[offset++] & 0xff);                     }                      lvalue <<= (8 - count) * 8;                     dbl = BitConverter.Int64BitsToDouble(lvalue);                     type = edsTypeDouble;                     break;                  case edsTimeLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeTime;                     break;                  case edsTimeLen1:                 case edsTimeLen2:                 case edsTimeLen3:                 case edsTimeLen4:                     l = code - edsTimeLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeTime;                     break;                  case edsMilliSecLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeMilliseconds;                     break;                  case edsMilliSecLen1:                 case edsMilliSecLen2:                 case edsMilliSecLen3:                 case edsMilliSecLen4:                 case edsMilliSecLen5:                 case edsMilliSecLen6:                 case edsMilliSecLen7:                 case edsMilliSecLen8:                     l = code - edsMilliSecLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeMilliseconds;                     break;                  case edsNanoSecLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeNanoseconds;                     break;                  case edsNanoSecLen1:                 case edsNanoSecLen2:                 case edsNanoSecLen3:                 case edsNanoSecLen4:                 case edsNanoSecLen5:                 case edsNanoSecLen6:                 case edsNanoSecLen7:                 case edsNanoSecLen8:                     l = code - edsNanoSecLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeNanoseconds;                     break;                  //                 // 09/2012 Added support for new scaled date/times encoding. These replace the old encoding                 // edsTimeLen' edsMilliSecLen and edsNanoSecLen.                 //                  case edsScaledTimeLen1:                 case edsScaledTimeLen2:                 case edsScaledTimeLen3:                 case edsScaledTimeLen4:                 case edsScaledTimeLen5:                 case edsScaledTimeLen6:                 case edsScaledTimeLen7:                 case edsScaledTimeLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledTimeLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledTime;                     break;                  case edsScaledDateLen1:                 case edsScaledDateLen2:                 case edsScaledDateLen3:                 case edsScaledDateLen4:                 case edsScaledDateLen5:                 case edsScaledDateLen6:                 case edsScaledDateLen7:                 case edsScaledDateLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledDateLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledDate;                     break;                  case edsScaledTimestampLen1:                 case edsScaledTimestampLen2:                 case edsScaledTimestampLen3:                 case edsScaledTimestampLen4:                 case edsScaledTimestampLen5:                 case edsScaledTimestampLen6:                 case edsScaledTimestampLen7:                 case edsScaledTimestampLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledTimestampLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledTimestamp;                     break;                  case edsClobLen0:                     blobId = 0;                     type = edsTypeClob;                     break;                  case edsClobLen1:                 case edsClobLen2:                 case edsClobLen3:                 case edsClobLen4:                     l = code - edsClobLen1;                     blobId = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         blobId = (blobId << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeClob;                     break;                  case edsBlobLen0:                     blobId = 0;                     type = edsTypeBlob;                     break;                  case edsBlobLen1:                 case edsBlobLen2:                 case edsBlobLen3:                 case edsBlobLen4:                     l = code - edsBlobLen1;                     blobId = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         blobId = (blobId << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeBlob;                     break;                  case edsScaledCount1:                     {                         // For some reason C++ EncodedStream expects the encoded                         // length to be length+1.                          length = (source[offset++] & 0xff) - 1;                         scale = (sbyte)source[offset++];                         type = edsTypeBigInt;                         bytes = new byte[length];                         Array.Copy(source' offset' bytes' 0' length);                         offset += length;                         int sign = ((bytes[0] & 0x80) > 0) ? -1 : 1;                          if (sign == -1)                         {                             bytes[0] &= 0x7f;                         }                          BigInteger bi = new BigInteger(bytes);                         bigDecimal = Decimal.Parse(bi.ToString());                     }                     break;                  case edsScaledCount2:                     {                         // For some reason C++ EncodedStream expects the encoded                         // length to be length+1.                          scale = (sbyte)source[offset++];                         sbyte sign = (sbyte)source[offset++];                         length = (source[offset++] & 0xff); // in bytes                         type = edsTypeBigInt;                         bytes = new byte[length];                         Array.Copy(source' offset' bytes' 0' length);                         offset += length;                          if (sign == -1)                             bytes[0] &= 0x7f;                         else                             sign = 1;                          BigInteger bi = new BigInteger(bytes);                         if (sign == -1)                             bi = -bi;                         bigDecimal = ScaleDecimal(Decimal.Parse(bi.ToString())' scale);                     }                     break;                  case edsUUID:                     {                         byte[] buff = new byte[16];                          for (int n = 0; n < 16; ++n)                         {                             buff[n] = (byte)(source[offset++] & 0xff);                         }                          uuid = new Guid(buff);                         type = edsTypeUUID;                     }                     break;                  default:                     type = edsTypeUnknown;                     break;             }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,decode,The following statement contains a magic number: switch (code)             {                 case edsNull:                     type = edsTypeNull;                     break;                  case edsTrue:                     type = edsTypeBoolean;                     @bool = true;                     break;                  case edsFalse:                     type = edsTypeBoolean;                     @bool = false;                     break;                  case edsIntMinus10:                 case edsIntMinus9:                 case edsIntMinus8:                 case edsIntMinus7:                 case edsIntMinus6:                 case edsIntMinus5:                 case edsIntMinus4:                 case edsIntMinus3:                 case edsIntMinus2:                 case edsIntMinus1:                 case edsInt0:                 case edsInt1:                 case edsInt2:                 case edsInt3:                 case edsInt4:                 case edsInt5:                 case edsInt6:                 case edsInt7:                 case edsInt8:                 case edsInt9:                 case edsInt10:                 case edsInt11:                 case edsInt12:                 case edsInt13:                 case edsInt14:                 case edsInt15:                 case edsInt16:                 case edsInt17:                 case edsInt18:                 case edsInt19:                 case edsInt20:                 case edsInt21:                 case edsInt22:                 case edsInt23:                 case edsInt24:                 case edsInt25:                 case edsInt26:                 case edsInt27:                 case edsInt28:                 case edsInt29:                 case edsInt30:                 case edsInt31:                     integer32 = code - edsInt0;                     scale = 0;                     type = edsTypeInt32;                     break;                  case edsIntLen1:                     type = edsTypeInt32;                     scale = 0;                     integer32 = (sbyte)source[offset++];                     break;                  case edsIntLen2:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset] << 8) | (source[offset + 1] & 0xff);                     offset += 2;                     break;                  case edsIntLen3:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset]) << 16 | (source[offset + 1] & 0xff) << 8 | (source[offset + 2] & 0xff);                     offset += 3;                     break;                  case edsIntLen4:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset]) << 24 | (source[offset + 1] & 0xff) << 16 | (source[offset + 2] & 0xff) << 8 | (source[offset + 3] & 0xff);                     offset += 4;                     break;                  case edsIntLen5:                 case edsIntLen6:                 case edsIntLen7:                 case edsIntLen8:                     l = code - edsIntLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeInt64;                     break;                  case edsScaledLen0:                     scale = (sbyte)source[offset++];                     integer64 = 0;                     type = edsTypeScaled;                     break;                  case edsScaledLen1:                 case edsScaledLen2:                 case edsScaledLen3:                 case edsScaledLen4:                 case edsScaledLen5:                 case edsScaledLen6:                 case edsScaledLen7:                 case edsScaledLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaled;                     break;                  case edsUtf8Len0:                 case edsUtf8Len1:                 case edsUtf8Len2:                 case edsUtf8Len3:                 case edsUtf8Len4:                 case edsUtf8Len5:                 case edsUtf8Len6:                 case edsUtf8Len7:                 case edsUtf8Len8:                 case edsUtf8Len9:                 case edsUtf8Len10:                 case edsUtf8Len11:                 case edsUtf8Len12:                 case edsUtf8Len13:                 case edsUtf8Len14:                 case edsUtf8Len15:                 case edsUtf8Len16:                 case edsUtf8Len17:                 case edsUtf8Len18:                 case edsUtf8Len19:                 case edsUtf8Len20:                 case edsUtf8Len21:                 case edsUtf8Len22:                 case edsUtf8Len23:                 case edsUtf8Len24:                 case edsUtf8Len25:                 case edsUtf8Len26:                 case edsUtf8Len27:                 case edsUtf8Len28:                 case edsUtf8Len29:                 case edsUtf8Len30:                 case edsUtf8Len31:                 case edsUtf8Len32:                 case edsUtf8Len33:                 case edsUtf8Len34:                 case edsUtf8Len35:                 case edsUtf8Len36:                 case edsUtf8Len37:                 case edsUtf8Len38:                 case edsUtf8Len39:                     l = code - edsUtf8Len0;                     @string = getString(source' offset' l);                     offset += l;                     type = edsTypeUtf8;                     break;                  case edsUtf8Count1:                 case edsUtf8Count2:                 case edsUtf8Count3:                 case edsUtf8Count4:                     count = code - edsUtf8Count1;                     int length = source[offset++] & 0xff;                      for (int n = 0; n < count; ++n)                     {                         length = length << 8 | (source[offset++] & 0xff);                     }                      @string = getString(source' offset' length);                     offset += length;                     type = edsTypeUtf8;                     break;                  case edsOpaqueLen0:                 case edsOpaqueLen1:                 case edsOpaqueLen2:                 case edsOpaqueLen3:                 case edsOpaqueLen4:                 case edsOpaqueLen5:                 case edsOpaqueLen6:                 case edsOpaqueLen7:                 case edsOpaqueLen8:                 case edsOpaqueLen9:                 case edsOpaqueLen10:                 case edsOpaqueLen11:                 case edsOpaqueLen12:                 case edsOpaqueLen13:                 case edsOpaqueLen14:                 case edsOpaqueLen15:                 case edsOpaqueLen16:                 case edsOpaqueLen17:                 case edsOpaqueLen18:                 case edsOpaqueLen19:                 case edsOpaqueLen20:                 case edsOpaqueLen21:                 case edsOpaqueLen22:                 case edsOpaqueLen23:                 case edsOpaqueLen24:                 case edsOpaqueLen25:                 case edsOpaqueLen26:                 case edsOpaqueLen27:                 case edsOpaqueLen28:                 case edsOpaqueLen29:                 case edsOpaqueLen30:                 case edsOpaqueLen31:                 case edsOpaqueLen32:                 case edsOpaqueLen33:                 case edsOpaqueLen34:                 case edsOpaqueLen35:                 case edsOpaqueLen36:                 case edsOpaqueLen37:                 case edsOpaqueLen38:                 case edsOpaqueLen39:                     l = code - edsOpaqueLen0;                     bytes = new byte[l];                     Array.Copy(source' offset' bytes' 0' l);                     offset += l;                     type = edsTypeOpaque;                     break;                  case edsOpaqueCount1:                 case edsOpaqueCount2:                 case edsOpaqueCount3:                 case edsOpaqueCount4:                     count = code - edsOpaqueCount1 + 1;                     l = source[offset++] & 0xff;                      for (int n = 1; n < count; ++n)                     {                         l = l << 8 | (source[offset++] & 0xff);                     }                      bytes = new byte[l];                     Array.Copy(source' offset' bytes' 0' l);                     offset += l;                     type = edsTypeOpaque;                     break;                  case edsDoubleLen0:                 case edsDoubleLen1:                 case edsDoubleLen2:                 case edsDoubleLen3:                 case edsDoubleLen4:                 case edsDoubleLen5:                 case edsDoubleLen6:                 case edsDoubleLen7:                 case edsDoubleLen8:                     count = code - edsDoubleLen0;                     long lvalue = 0;                      for (int n = 0; n < count; ++n)                     {                         lvalue = (lvalue << 8) | (source[offset++] & 0xff);                     }                      lvalue <<= (8 - count) * 8;                     dbl = BitConverter.Int64BitsToDouble(lvalue);                     type = edsTypeDouble;                     break;                  case edsTimeLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeTime;                     break;                  case edsTimeLen1:                 case edsTimeLen2:                 case edsTimeLen3:                 case edsTimeLen4:                     l = code - edsTimeLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeTime;                     break;                  case edsMilliSecLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeMilliseconds;                     break;                  case edsMilliSecLen1:                 case edsMilliSecLen2:                 case edsMilliSecLen3:                 case edsMilliSecLen4:                 case edsMilliSecLen5:                 case edsMilliSecLen6:                 case edsMilliSecLen7:                 case edsMilliSecLen8:                     l = code - edsMilliSecLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeMilliseconds;                     break;                  case edsNanoSecLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeNanoseconds;                     break;                  case edsNanoSecLen1:                 case edsNanoSecLen2:                 case edsNanoSecLen3:                 case edsNanoSecLen4:                 case edsNanoSecLen5:                 case edsNanoSecLen6:                 case edsNanoSecLen7:                 case edsNanoSecLen8:                     l = code - edsNanoSecLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeNanoseconds;                     break;                  //                 // 09/2012 Added support for new scaled date/times encoding. These replace the old encoding                 // edsTimeLen' edsMilliSecLen and edsNanoSecLen.                 //                  case edsScaledTimeLen1:                 case edsScaledTimeLen2:                 case edsScaledTimeLen3:                 case edsScaledTimeLen4:                 case edsScaledTimeLen5:                 case edsScaledTimeLen6:                 case edsScaledTimeLen7:                 case edsScaledTimeLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledTimeLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledTime;                     break;                  case edsScaledDateLen1:                 case edsScaledDateLen2:                 case edsScaledDateLen3:                 case edsScaledDateLen4:                 case edsScaledDateLen5:                 case edsScaledDateLen6:                 case edsScaledDateLen7:                 case edsScaledDateLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledDateLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledDate;                     break;                  case edsScaledTimestampLen1:                 case edsScaledTimestampLen2:                 case edsScaledTimestampLen3:                 case edsScaledTimestampLen4:                 case edsScaledTimestampLen5:                 case edsScaledTimestampLen6:                 case edsScaledTimestampLen7:                 case edsScaledTimestampLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledTimestampLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledTimestamp;                     break;                  case edsClobLen0:                     blobId = 0;                     type = edsTypeClob;                     break;                  case edsClobLen1:                 case edsClobLen2:                 case edsClobLen3:                 case edsClobLen4:                     l = code - edsClobLen1;                     blobId = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         blobId = (blobId << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeClob;                     break;                  case edsBlobLen0:                     blobId = 0;                     type = edsTypeBlob;                     break;                  case edsBlobLen1:                 case edsBlobLen2:                 case edsBlobLen3:                 case edsBlobLen4:                     l = code - edsBlobLen1;                     blobId = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         blobId = (blobId << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeBlob;                     break;                  case edsScaledCount1:                     {                         // For some reason C++ EncodedStream expects the encoded                         // length to be length+1.                          length = (source[offset++] & 0xff) - 1;                         scale = (sbyte)source[offset++];                         type = edsTypeBigInt;                         bytes = new byte[length];                         Array.Copy(source' offset' bytes' 0' length);                         offset += length;                         int sign = ((bytes[0] & 0x80) > 0) ? -1 : 1;                          if (sign == -1)                         {                             bytes[0] &= 0x7f;                         }                          BigInteger bi = new BigInteger(bytes);                         bigDecimal = Decimal.Parse(bi.ToString());                     }                     break;                  case edsScaledCount2:                     {                         // For some reason C++ EncodedStream expects the encoded                         // length to be length+1.                          scale = (sbyte)source[offset++];                         sbyte sign = (sbyte)source[offset++];                         length = (source[offset++] & 0xff); // in bytes                         type = edsTypeBigInt;                         bytes = new byte[length];                         Array.Copy(source' offset' bytes' 0' length);                         offset += length;                          if (sign == -1)                             bytes[0] &= 0x7f;                         else                             sign = 1;                          BigInteger bi = new BigInteger(bytes);                         if (sign == -1)                             bi = -bi;                         bigDecimal = ScaleDecimal(Decimal.Parse(bi.ToString())' scale);                     }                     break;                  case edsUUID:                     {                         byte[] buff = new byte[16];                          for (int n = 0; n < 16; ++n)                         {                             buff[n] = (byte)(source[offset++] & 0xff);                         }                          uuid = new Guid(buff);                         type = edsTypeUUID;                     }                     break;                  default:                     type = edsTypeUnknown;                     break;             }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,decode,The following statement contains a magic number: switch (code)             {                 case edsNull:                     type = edsTypeNull;                     break;                  case edsTrue:                     type = edsTypeBoolean;                     @bool = true;                     break;                  case edsFalse:                     type = edsTypeBoolean;                     @bool = false;                     break;                  case edsIntMinus10:                 case edsIntMinus9:                 case edsIntMinus8:                 case edsIntMinus7:                 case edsIntMinus6:                 case edsIntMinus5:                 case edsIntMinus4:                 case edsIntMinus3:                 case edsIntMinus2:                 case edsIntMinus1:                 case edsInt0:                 case edsInt1:                 case edsInt2:                 case edsInt3:                 case edsInt4:                 case edsInt5:                 case edsInt6:                 case edsInt7:                 case edsInt8:                 case edsInt9:                 case edsInt10:                 case edsInt11:                 case edsInt12:                 case edsInt13:                 case edsInt14:                 case edsInt15:                 case edsInt16:                 case edsInt17:                 case edsInt18:                 case edsInt19:                 case edsInt20:                 case edsInt21:                 case edsInt22:                 case edsInt23:                 case edsInt24:                 case edsInt25:                 case edsInt26:                 case edsInt27:                 case edsInt28:                 case edsInt29:                 case edsInt30:                 case edsInt31:                     integer32 = code - edsInt0;                     scale = 0;                     type = edsTypeInt32;                     break;                  case edsIntLen1:                     type = edsTypeInt32;                     scale = 0;                     integer32 = (sbyte)source[offset++];                     break;                  case edsIntLen2:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset] << 8) | (source[offset + 1] & 0xff);                     offset += 2;                     break;                  case edsIntLen3:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset]) << 16 | (source[offset + 1] & 0xff) << 8 | (source[offset + 2] & 0xff);                     offset += 3;                     break;                  case edsIntLen4:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset]) << 24 | (source[offset + 1] & 0xff) << 16 | (source[offset + 2] & 0xff) << 8 | (source[offset + 3] & 0xff);                     offset += 4;                     break;                  case edsIntLen5:                 case edsIntLen6:                 case edsIntLen7:                 case edsIntLen8:                     l = code - edsIntLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeInt64;                     break;                  case edsScaledLen0:                     scale = (sbyte)source[offset++];                     integer64 = 0;                     type = edsTypeScaled;                     break;                  case edsScaledLen1:                 case edsScaledLen2:                 case edsScaledLen3:                 case edsScaledLen4:                 case edsScaledLen5:                 case edsScaledLen6:                 case edsScaledLen7:                 case edsScaledLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaled;                     break;                  case edsUtf8Len0:                 case edsUtf8Len1:                 case edsUtf8Len2:                 case edsUtf8Len3:                 case edsUtf8Len4:                 case edsUtf8Len5:                 case edsUtf8Len6:                 case edsUtf8Len7:                 case edsUtf8Len8:                 case edsUtf8Len9:                 case edsUtf8Len10:                 case edsUtf8Len11:                 case edsUtf8Len12:                 case edsUtf8Len13:                 case edsUtf8Len14:                 case edsUtf8Len15:                 case edsUtf8Len16:                 case edsUtf8Len17:                 case edsUtf8Len18:                 case edsUtf8Len19:                 case edsUtf8Len20:                 case edsUtf8Len21:                 case edsUtf8Len22:                 case edsUtf8Len23:                 case edsUtf8Len24:                 case edsUtf8Len25:                 case edsUtf8Len26:                 case edsUtf8Len27:                 case edsUtf8Len28:                 case edsUtf8Len29:                 case edsUtf8Len30:                 case edsUtf8Len31:                 case edsUtf8Len32:                 case edsUtf8Len33:                 case edsUtf8Len34:                 case edsUtf8Len35:                 case edsUtf8Len36:                 case edsUtf8Len37:                 case edsUtf8Len38:                 case edsUtf8Len39:                     l = code - edsUtf8Len0;                     @string = getString(source' offset' l);                     offset += l;                     type = edsTypeUtf8;                     break;                  case edsUtf8Count1:                 case edsUtf8Count2:                 case edsUtf8Count3:                 case edsUtf8Count4:                     count = code - edsUtf8Count1;                     int length = source[offset++] & 0xff;                      for (int n = 0; n < count; ++n)                     {                         length = length << 8 | (source[offset++] & 0xff);                     }                      @string = getString(source' offset' length);                     offset += length;                     type = edsTypeUtf8;                     break;                  case edsOpaqueLen0:                 case edsOpaqueLen1:                 case edsOpaqueLen2:                 case edsOpaqueLen3:                 case edsOpaqueLen4:                 case edsOpaqueLen5:                 case edsOpaqueLen6:                 case edsOpaqueLen7:                 case edsOpaqueLen8:                 case edsOpaqueLen9:                 case edsOpaqueLen10:                 case edsOpaqueLen11:                 case edsOpaqueLen12:                 case edsOpaqueLen13:                 case edsOpaqueLen14:                 case edsOpaqueLen15:                 case edsOpaqueLen16:                 case edsOpaqueLen17:                 case edsOpaqueLen18:                 case edsOpaqueLen19:                 case edsOpaqueLen20:                 case edsOpaqueLen21:                 case edsOpaqueLen22:                 case edsOpaqueLen23:                 case edsOpaqueLen24:                 case edsOpaqueLen25:                 case edsOpaqueLen26:                 case edsOpaqueLen27:                 case edsOpaqueLen28:                 case edsOpaqueLen29:                 case edsOpaqueLen30:                 case edsOpaqueLen31:                 case edsOpaqueLen32:                 case edsOpaqueLen33:                 case edsOpaqueLen34:                 case edsOpaqueLen35:                 case edsOpaqueLen36:                 case edsOpaqueLen37:                 case edsOpaqueLen38:                 case edsOpaqueLen39:                     l = code - edsOpaqueLen0;                     bytes = new byte[l];                     Array.Copy(source' offset' bytes' 0' l);                     offset += l;                     type = edsTypeOpaque;                     break;                  case edsOpaqueCount1:                 case edsOpaqueCount2:                 case edsOpaqueCount3:                 case edsOpaqueCount4:                     count = code - edsOpaqueCount1 + 1;                     l = source[offset++] & 0xff;                      for (int n = 1; n < count; ++n)                     {                         l = l << 8 | (source[offset++] & 0xff);                     }                      bytes = new byte[l];                     Array.Copy(source' offset' bytes' 0' l);                     offset += l;                     type = edsTypeOpaque;                     break;                  case edsDoubleLen0:                 case edsDoubleLen1:                 case edsDoubleLen2:                 case edsDoubleLen3:                 case edsDoubleLen4:                 case edsDoubleLen5:                 case edsDoubleLen6:                 case edsDoubleLen7:                 case edsDoubleLen8:                     count = code - edsDoubleLen0;                     long lvalue = 0;                      for (int n = 0; n < count; ++n)                     {                         lvalue = (lvalue << 8) | (source[offset++] & 0xff);                     }                      lvalue <<= (8 - count) * 8;                     dbl = BitConverter.Int64BitsToDouble(lvalue);                     type = edsTypeDouble;                     break;                  case edsTimeLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeTime;                     break;                  case edsTimeLen1:                 case edsTimeLen2:                 case edsTimeLen3:                 case edsTimeLen4:                     l = code - edsTimeLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeTime;                     break;                  case edsMilliSecLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeMilliseconds;                     break;                  case edsMilliSecLen1:                 case edsMilliSecLen2:                 case edsMilliSecLen3:                 case edsMilliSecLen4:                 case edsMilliSecLen5:                 case edsMilliSecLen6:                 case edsMilliSecLen7:                 case edsMilliSecLen8:                     l = code - edsMilliSecLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeMilliseconds;                     break;                  case edsNanoSecLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeNanoseconds;                     break;                  case edsNanoSecLen1:                 case edsNanoSecLen2:                 case edsNanoSecLen3:                 case edsNanoSecLen4:                 case edsNanoSecLen5:                 case edsNanoSecLen6:                 case edsNanoSecLen7:                 case edsNanoSecLen8:                     l = code - edsNanoSecLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeNanoseconds;                     break;                  //                 // 09/2012 Added support for new scaled date/times encoding. These replace the old encoding                 // edsTimeLen' edsMilliSecLen and edsNanoSecLen.                 //                  case edsScaledTimeLen1:                 case edsScaledTimeLen2:                 case edsScaledTimeLen3:                 case edsScaledTimeLen4:                 case edsScaledTimeLen5:                 case edsScaledTimeLen6:                 case edsScaledTimeLen7:                 case edsScaledTimeLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledTimeLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledTime;                     break;                  case edsScaledDateLen1:                 case edsScaledDateLen2:                 case edsScaledDateLen3:                 case edsScaledDateLen4:                 case edsScaledDateLen5:                 case edsScaledDateLen6:                 case edsScaledDateLen7:                 case edsScaledDateLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledDateLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledDate;                     break;                  case edsScaledTimestampLen1:                 case edsScaledTimestampLen2:                 case edsScaledTimestampLen3:                 case edsScaledTimestampLen4:                 case edsScaledTimestampLen5:                 case edsScaledTimestampLen6:                 case edsScaledTimestampLen7:                 case edsScaledTimestampLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledTimestampLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledTimestamp;                     break;                  case edsClobLen0:                     blobId = 0;                     type = edsTypeClob;                     break;                  case edsClobLen1:                 case edsClobLen2:                 case edsClobLen3:                 case edsClobLen4:                     l = code - edsClobLen1;                     blobId = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         blobId = (blobId << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeClob;                     break;                  case edsBlobLen0:                     blobId = 0;                     type = edsTypeBlob;                     break;                  case edsBlobLen1:                 case edsBlobLen2:                 case edsBlobLen3:                 case edsBlobLen4:                     l = code - edsBlobLen1;                     blobId = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         blobId = (blobId << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeBlob;                     break;                  case edsScaledCount1:                     {                         // For some reason C++ EncodedStream expects the encoded                         // length to be length+1.                          length = (source[offset++] & 0xff) - 1;                         scale = (sbyte)source[offset++];                         type = edsTypeBigInt;                         bytes = new byte[length];                         Array.Copy(source' offset' bytes' 0' length);                         offset += length;                         int sign = ((bytes[0] & 0x80) > 0) ? -1 : 1;                          if (sign == -1)                         {                             bytes[0] &= 0x7f;                         }                          BigInteger bi = new BigInteger(bytes);                         bigDecimal = Decimal.Parse(bi.ToString());                     }                     break;                  case edsScaledCount2:                     {                         // For some reason C++ EncodedStream expects the encoded                         // length to be length+1.                          scale = (sbyte)source[offset++];                         sbyte sign = (sbyte)source[offset++];                         length = (source[offset++] & 0xff); // in bytes                         type = edsTypeBigInt;                         bytes = new byte[length];                         Array.Copy(source' offset' bytes' 0' length);                         offset += length;                          if (sign == -1)                             bytes[0] &= 0x7f;                         else                             sign = 1;                          BigInteger bi = new BigInteger(bytes);                         if (sign == -1)                             bi = -bi;                         bigDecimal = ScaleDecimal(Decimal.Parse(bi.ToString())' scale);                     }                     break;                  case edsUUID:                     {                         byte[] buff = new byte[16];                          for (int n = 0; n < 16; ++n)                         {                             buff[n] = (byte)(source[offset++] & 0xff);                         }                          uuid = new Guid(buff);                         type = edsTypeUUID;                     }                     break;                  default:                     type = edsTypeUnknown;                     break;             }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,decode,The following statement contains a magic number: switch (code)             {                 case edsNull:                     type = edsTypeNull;                     break;                  case edsTrue:                     type = edsTypeBoolean;                     @bool = true;                     break;                  case edsFalse:                     type = edsTypeBoolean;                     @bool = false;                     break;                  case edsIntMinus10:                 case edsIntMinus9:                 case edsIntMinus8:                 case edsIntMinus7:                 case edsIntMinus6:                 case edsIntMinus5:                 case edsIntMinus4:                 case edsIntMinus3:                 case edsIntMinus2:                 case edsIntMinus1:                 case edsInt0:                 case edsInt1:                 case edsInt2:                 case edsInt3:                 case edsInt4:                 case edsInt5:                 case edsInt6:                 case edsInt7:                 case edsInt8:                 case edsInt9:                 case edsInt10:                 case edsInt11:                 case edsInt12:                 case edsInt13:                 case edsInt14:                 case edsInt15:                 case edsInt16:                 case edsInt17:                 case edsInt18:                 case edsInt19:                 case edsInt20:                 case edsInt21:                 case edsInt22:                 case edsInt23:                 case edsInt24:                 case edsInt25:                 case edsInt26:                 case edsInt27:                 case edsInt28:                 case edsInt29:                 case edsInt30:                 case edsInt31:                     integer32 = code - edsInt0;                     scale = 0;                     type = edsTypeInt32;                     break;                  case edsIntLen1:                     type = edsTypeInt32;                     scale = 0;                     integer32 = (sbyte)source[offset++];                     break;                  case edsIntLen2:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset] << 8) | (source[offset + 1] & 0xff);                     offset += 2;                     break;                  case edsIntLen3:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset]) << 16 | (source[offset + 1] & 0xff) << 8 | (source[offset + 2] & 0xff);                     offset += 3;                     break;                  case edsIntLen4:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset]) << 24 | (source[offset + 1] & 0xff) << 16 | (source[offset + 2] & 0xff) << 8 | (source[offset + 3] & 0xff);                     offset += 4;                     break;                  case edsIntLen5:                 case edsIntLen6:                 case edsIntLen7:                 case edsIntLen8:                     l = code - edsIntLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeInt64;                     break;                  case edsScaledLen0:                     scale = (sbyte)source[offset++];                     integer64 = 0;                     type = edsTypeScaled;                     break;                  case edsScaledLen1:                 case edsScaledLen2:                 case edsScaledLen3:                 case edsScaledLen4:                 case edsScaledLen5:                 case edsScaledLen6:                 case edsScaledLen7:                 case edsScaledLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaled;                     break;                  case edsUtf8Len0:                 case edsUtf8Len1:                 case edsUtf8Len2:                 case edsUtf8Len3:                 case edsUtf8Len4:                 case edsUtf8Len5:                 case edsUtf8Len6:                 case edsUtf8Len7:                 case edsUtf8Len8:                 case edsUtf8Len9:                 case edsUtf8Len10:                 case edsUtf8Len11:                 case edsUtf8Len12:                 case edsUtf8Len13:                 case edsUtf8Len14:                 case edsUtf8Len15:                 case edsUtf8Len16:                 case edsUtf8Len17:                 case edsUtf8Len18:                 case edsUtf8Len19:                 case edsUtf8Len20:                 case edsUtf8Len21:                 case edsUtf8Len22:                 case edsUtf8Len23:                 case edsUtf8Len24:                 case edsUtf8Len25:                 case edsUtf8Len26:                 case edsUtf8Len27:                 case edsUtf8Len28:                 case edsUtf8Len29:                 case edsUtf8Len30:                 case edsUtf8Len31:                 case edsUtf8Len32:                 case edsUtf8Len33:                 case edsUtf8Len34:                 case edsUtf8Len35:                 case edsUtf8Len36:                 case edsUtf8Len37:                 case edsUtf8Len38:                 case edsUtf8Len39:                     l = code - edsUtf8Len0;                     @string = getString(source' offset' l);                     offset += l;                     type = edsTypeUtf8;                     break;                  case edsUtf8Count1:                 case edsUtf8Count2:                 case edsUtf8Count3:                 case edsUtf8Count4:                     count = code - edsUtf8Count1;                     int length = source[offset++] & 0xff;                      for (int n = 0; n < count; ++n)                     {                         length = length << 8 | (source[offset++] & 0xff);                     }                      @string = getString(source' offset' length);                     offset += length;                     type = edsTypeUtf8;                     break;                  case edsOpaqueLen0:                 case edsOpaqueLen1:                 case edsOpaqueLen2:                 case edsOpaqueLen3:                 case edsOpaqueLen4:                 case edsOpaqueLen5:                 case edsOpaqueLen6:                 case edsOpaqueLen7:                 case edsOpaqueLen8:                 case edsOpaqueLen9:                 case edsOpaqueLen10:                 case edsOpaqueLen11:                 case edsOpaqueLen12:                 case edsOpaqueLen13:                 case edsOpaqueLen14:                 case edsOpaqueLen15:                 case edsOpaqueLen16:                 case edsOpaqueLen17:                 case edsOpaqueLen18:                 case edsOpaqueLen19:                 case edsOpaqueLen20:                 case edsOpaqueLen21:                 case edsOpaqueLen22:                 case edsOpaqueLen23:                 case edsOpaqueLen24:                 case edsOpaqueLen25:                 case edsOpaqueLen26:                 case edsOpaqueLen27:                 case edsOpaqueLen28:                 case edsOpaqueLen29:                 case edsOpaqueLen30:                 case edsOpaqueLen31:                 case edsOpaqueLen32:                 case edsOpaqueLen33:                 case edsOpaqueLen34:                 case edsOpaqueLen35:                 case edsOpaqueLen36:                 case edsOpaqueLen37:                 case edsOpaqueLen38:                 case edsOpaqueLen39:                     l = code - edsOpaqueLen0;                     bytes = new byte[l];                     Array.Copy(source' offset' bytes' 0' l);                     offset += l;                     type = edsTypeOpaque;                     break;                  case edsOpaqueCount1:                 case edsOpaqueCount2:                 case edsOpaqueCount3:                 case edsOpaqueCount4:                     count = code - edsOpaqueCount1 + 1;                     l = source[offset++] & 0xff;                      for (int n = 1; n < count; ++n)                     {                         l = l << 8 | (source[offset++] & 0xff);                     }                      bytes = new byte[l];                     Array.Copy(source' offset' bytes' 0' l);                     offset += l;                     type = edsTypeOpaque;                     break;                  case edsDoubleLen0:                 case edsDoubleLen1:                 case edsDoubleLen2:                 case edsDoubleLen3:                 case edsDoubleLen4:                 case edsDoubleLen5:                 case edsDoubleLen6:                 case edsDoubleLen7:                 case edsDoubleLen8:                     count = code - edsDoubleLen0;                     long lvalue = 0;                      for (int n = 0; n < count; ++n)                     {                         lvalue = (lvalue << 8) | (source[offset++] & 0xff);                     }                      lvalue <<= (8 - count) * 8;                     dbl = BitConverter.Int64BitsToDouble(lvalue);                     type = edsTypeDouble;                     break;                  case edsTimeLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeTime;                     break;                  case edsTimeLen1:                 case edsTimeLen2:                 case edsTimeLen3:                 case edsTimeLen4:                     l = code - edsTimeLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeTime;                     break;                  case edsMilliSecLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeMilliseconds;                     break;                  case edsMilliSecLen1:                 case edsMilliSecLen2:                 case edsMilliSecLen3:                 case edsMilliSecLen4:                 case edsMilliSecLen5:                 case edsMilliSecLen6:                 case edsMilliSecLen7:                 case edsMilliSecLen8:                     l = code - edsMilliSecLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeMilliseconds;                     break;                  case edsNanoSecLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeNanoseconds;                     break;                  case edsNanoSecLen1:                 case edsNanoSecLen2:                 case edsNanoSecLen3:                 case edsNanoSecLen4:                 case edsNanoSecLen5:                 case edsNanoSecLen6:                 case edsNanoSecLen7:                 case edsNanoSecLen8:                     l = code - edsNanoSecLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeNanoseconds;                     break;                  //                 // 09/2012 Added support for new scaled date/times encoding. These replace the old encoding                 // edsTimeLen' edsMilliSecLen and edsNanoSecLen.                 //                  case edsScaledTimeLen1:                 case edsScaledTimeLen2:                 case edsScaledTimeLen3:                 case edsScaledTimeLen4:                 case edsScaledTimeLen5:                 case edsScaledTimeLen6:                 case edsScaledTimeLen7:                 case edsScaledTimeLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledTimeLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledTime;                     break;                  case edsScaledDateLen1:                 case edsScaledDateLen2:                 case edsScaledDateLen3:                 case edsScaledDateLen4:                 case edsScaledDateLen5:                 case edsScaledDateLen6:                 case edsScaledDateLen7:                 case edsScaledDateLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledDateLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledDate;                     break;                  case edsScaledTimestampLen1:                 case edsScaledTimestampLen2:                 case edsScaledTimestampLen3:                 case edsScaledTimestampLen4:                 case edsScaledTimestampLen5:                 case edsScaledTimestampLen6:                 case edsScaledTimestampLen7:                 case edsScaledTimestampLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledTimestampLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledTimestamp;                     break;                  case edsClobLen0:                     blobId = 0;                     type = edsTypeClob;                     break;                  case edsClobLen1:                 case edsClobLen2:                 case edsClobLen3:                 case edsClobLen4:                     l = code - edsClobLen1;                     blobId = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         blobId = (blobId << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeClob;                     break;                  case edsBlobLen0:                     blobId = 0;                     type = edsTypeBlob;                     break;                  case edsBlobLen1:                 case edsBlobLen2:                 case edsBlobLen3:                 case edsBlobLen4:                     l = code - edsBlobLen1;                     blobId = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         blobId = (blobId << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeBlob;                     break;                  case edsScaledCount1:                     {                         // For some reason C++ EncodedStream expects the encoded                         // length to be length+1.                          length = (source[offset++] & 0xff) - 1;                         scale = (sbyte)source[offset++];                         type = edsTypeBigInt;                         bytes = new byte[length];                         Array.Copy(source' offset' bytes' 0' length);                         offset += length;                         int sign = ((bytes[0] & 0x80) > 0) ? -1 : 1;                          if (sign == -1)                         {                             bytes[0] &= 0x7f;                         }                          BigInteger bi = new BigInteger(bytes);                         bigDecimal = Decimal.Parse(bi.ToString());                     }                     break;                  case edsScaledCount2:                     {                         // For some reason C++ EncodedStream expects the encoded                         // length to be length+1.                          scale = (sbyte)source[offset++];                         sbyte sign = (sbyte)source[offset++];                         length = (source[offset++] & 0xff); // in bytes                         type = edsTypeBigInt;                         bytes = new byte[length];                         Array.Copy(source' offset' bytes' 0' length);                         offset += length;                          if (sign == -1)                             bytes[0] &= 0x7f;                         else                             sign = 1;                          BigInteger bi = new BigInteger(bytes);                         if (sign == -1)                             bi = -bi;                         bigDecimal = ScaleDecimal(Decimal.Parse(bi.ToString())' scale);                     }                     break;                  case edsUUID:                     {                         byte[] buff = new byte[16];                          for (int n = 0; n < 16; ++n)                         {                             buff[n] = (byte)(source[offset++] & 0xff);                         }                          uuid = new Guid(buff);                         type = edsTypeUUID;                     }                     break;                  default:                     type = edsTypeUnknown;                     break;             }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,decode,The following statement contains a magic number: switch (code)             {                 case edsNull:                     type = edsTypeNull;                     break;                  case edsTrue:                     type = edsTypeBoolean;                     @bool = true;                     break;                  case edsFalse:                     type = edsTypeBoolean;                     @bool = false;                     break;                  case edsIntMinus10:                 case edsIntMinus9:                 case edsIntMinus8:                 case edsIntMinus7:                 case edsIntMinus6:                 case edsIntMinus5:                 case edsIntMinus4:                 case edsIntMinus3:                 case edsIntMinus2:                 case edsIntMinus1:                 case edsInt0:                 case edsInt1:                 case edsInt2:                 case edsInt3:                 case edsInt4:                 case edsInt5:                 case edsInt6:                 case edsInt7:                 case edsInt8:                 case edsInt9:                 case edsInt10:                 case edsInt11:                 case edsInt12:                 case edsInt13:                 case edsInt14:                 case edsInt15:                 case edsInt16:                 case edsInt17:                 case edsInt18:                 case edsInt19:                 case edsInt20:                 case edsInt21:                 case edsInt22:                 case edsInt23:                 case edsInt24:                 case edsInt25:                 case edsInt26:                 case edsInt27:                 case edsInt28:                 case edsInt29:                 case edsInt30:                 case edsInt31:                     integer32 = code - edsInt0;                     scale = 0;                     type = edsTypeInt32;                     break;                  case edsIntLen1:                     type = edsTypeInt32;                     scale = 0;                     integer32 = (sbyte)source[offset++];                     break;                  case edsIntLen2:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset] << 8) | (source[offset + 1] & 0xff);                     offset += 2;                     break;                  case edsIntLen3:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset]) << 16 | (source[offset + 1] & 0xff) << 8 | (source[offset + 2] & 0xff);                     offset += 3;                     break;                  case edsIntLen4:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset]) << 24 | (source[offset + 1] & 0xff) << 16 | (source[offset + 2] & 0xff) << 8 | (source[offset + 3] & 0xff);                     offset += 4;                     break;                  case edsIntLen5:                 case edsIntLen6:                 case edsIntLen7:                 case edsIntLen8:                     l = code - edsIntLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeInt64;                     break;                  case edsScaledLen0:                     scale = (sbyte)source[offset++];                     integer64 = 0;                     type = edsTypeScaled;                     break;                  case edsScaledLen1:                 case edsScaledLen2:                 case edsScaledLen3:                 case edsScaledLen4:                 case edsScaledLen5:                 case edsScaledLen6:                 case edsScaledLen7:                 case edsScaledLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaled;                     break;                  case edsUtf8Len0:                 case edsUtf8Len1:                 case edsUtf8Len2:                 case edsUtf8Len3:                 case edsUtf8Len4:                 case edsUtf8Len5:                 case edsUtf8Len6:                 case edsUtf8Len7:                 case edsUtf8Len8:                 case edsUtf8Len9:                 case edsUtf8Len10:                 case edsUtf8Len11:                 case edsUtf8Len12:                 case edsUtf8Len13:                 case edsUtf8Len14:                 case edsUtf8Len15:                 case edsUtf8Len16:                 case edsUtf8Len17:                 case edsUtf8Len18:                 case edsUtf8Len19:                 case edsUtf8Len20:                 case edsUtf8Len21:                 case edsUtf8Len22:                 case edsUtf8Len23:                 case edsUtf8Len24:                 case edsUtf8Len25:                 case edsUtf8Len26:                 case edsUtf8Len27:                 case edsUtf8Len28:                 case edsUtf8Len29:                 case edsUtf8Len30:                 case edsUtf8Len31:                 case edsUtf8Len32:                 case edsUtf8Len33:                 case edsUtf8Len34:                 case edsUtf8Len35:                 case edsUtf8Len36:                 case edsUtf8Len37:                 case edsUtf8Len38:                 case edsUtf8Len39:                     l = code - edsUtf8Len0;                     @string = getString(source' offset' l);                     offset += l;                     type = edsTypeUtf8;                     break;                  case edsUtf8Count1:                 case edsUtf8Count2:                 case edsUtf8Count3:                 case edsUtf8Count4:                     count = code - edsUtf8Count1;                     int length = source[offset++] & 0xff;                      for (int n = 0; n < count; ++n)                     {                         length = length << 8 | (source[offset++] & 0xff);                     }                      @string = getString(source' offset' length);                     offset += length;                     type = edsTypeUtf8;                     break;                  case edsOpaqueLen0:                 case edsOpaqueLen1:                 case edsOpaqueLen2:                 case edsOpaqueLen3:                 case edsOpaqueLen4:                 case edsOpaqueLen5:                 case edsOpaqueLen6:                 case edsOpaqueLen7:                 case edsOpaqueLen8:                 case edsOpaqueLen9:                 case edsOpaqueLen10:                 case edsOpaqueLen11:                 case edsOpaqueLen12:                 case edsOpaqueLen13:                 case edsOpaqueLen14:                 case edsOpaqueLen15:                 case edsOpaqueLen16:                 case edsOpaqueLen17:                 case edsOpaqueLen18:                 case edsOpaqueLen19:                 case edsOpaqueLen20:                 case edsOpaqueLen21:                 case edsOpaqueLen22:                 case edsOpaqueLen23:                 case edsOpaqueLen24:                 case edsOpaqueLen25:                 case edsOpaqueLen26:                 case edsOpaqueLen27:                 case edsOpaqueLen28:                 case edsOpaqueLen29:                 case edsOpaqueLen30:                 case edsOpaqueLen31:                 case edsOpaqueLen32:                 case edsOpaqueLen33:                 case edsOpaqueLen34:                 case edsOpaqueLen35:                 case edsOpaqueLen36:                 case edsOpaqueLen37:                 case edsOpaqueLen38:                 case edsOpaqueLen39:                     l = code - edsOpaqueLen0;                     bytes = new byte[l];                     Array.Copy(source' offset' bytes' 0' l);                     offset += l;                     type = edsTypeOpaque;                     break;                  case edsOpaqueCount1:                 case edsOpaqueCount2:                 case edsOpaqueCount3:                 case edsOpaqueCount4:                     count = code - edsOpaqueCount1 + 1;                     l = source[offset++] & 0xff;                      for (int n = 1; n < count; ++n)                     {                         l = l << 8 | (source[offset++] & 0xff);                     }                      bytes = new byte[l];                     Array.Copy(source' offset' bytes' 0' l);                     offset += l;                     type = edsTypeOpaque;                     break;                  case edsDoubleLen0:                 case edsDoubleLen1:                 case edsDoubleLen2:                 case edsDoubleLen3:                 case edsDoubleLen4:                 case edsDoubleLen5:                 case edsDoubleLen6:                 case edsDoubleLen7:                 case edsDoubleLen8:                     count = code - edsDoubleLen0;                     long lvalue = 0;                      for (int n = 0; n < count; ++n)                     {                         lvalue = (lvalue << 8) | (source[offset++] & 0xff);                     }                      lvalue <<= (8 - count) * 8;                     dbl = BitConverter.Int64BitsToDouble(lvalue);                     type = edsTypeDouble;                     break;                  case edsTimeLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeTime;                     break;                  case edsTimeLen1:                 case edsTimeLen2:                 case edsTimeLen3:                 case edsTimeLen4:                     l = code - edsTimeLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeTime;                     break;                  case edsMilliSecLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeMilliseconds;                     break;                  case edsMilliSecLen1:                 case edsMilliSecLen2:                 case edsMilliSecLen3:                 case edsMilliSecLen4:                 case edsMilliSecLen5:                 case edsMilliSecLen6:                 case edsMilliSecLen7:                 case edsMilliSecLen8:                     l = code - edsMilliSecLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeMilliseconds;                     break;                  case edsNanoSecLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeNanoseconds;                     break;                  case edsNanoSecLen1:                 case edsNanoSecLen2:                 case edsNanoSecLen3:                 case edsNanoSecLen4:                 case edsNanoSecLen5:                 case edsNanoSecLen6:                 case edsNanoSecLen7:                 case edsNanoSecLen8:                     l = code - edsNanoSecLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeNanoseconds;                     break;                  //                 // 09/2012 Added support for new scaled date/times encoding. These replace the old encoding                 // edsTimeLen' edsMilliSecLen and edsNanoSecLen.                 //                  case edsScaledTimeLen1:                 case edsScaledTimeLen2:                 case edsScaledTimeLen3:                 case edsScaledTimeLen4:                 case edsScaledTimeLen5:                 case edsScaledTimeLen6:                 case edsScaledTimeLen7:                 case edsScaledTimeLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledTimeLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledTime;                     break;                  case edsScaledDateLen1:                 case edsScaledDateLen2:                 case edsScaledDateLen3:                 case edsScaledDateLen4:                 case edsScaledDateLen5:                 case edsScaledDateLen6:                 case edsScaledDateLen7:                 case edsScaledDateLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledDateLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledDate;                     break;                  case edsScaledTimestampLen1:                 case edsScaledTimestampLen2:                 case edsScaledTimestampLen3:                 case edsScaledTimestampLen4:                 case edsScaledTimestampLen5:                 case edsScaledTimestampLen6:                 case edsScaledTimestampLen7:                 case edsScaledTimestampLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledTimestampLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledTimestamp;                     break;                  case edsClobLen0:                     blobId = 0;                     type = edsTypeClob;                     break;                  case edsClobLen1:                 case edsClobLen2:                 case edsClobLen3:                 case edsClobLen4:                     l = code - edsClobLen1;                     blobId = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         blobId = (blobId << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeClob;                     break;                  case edsBlobLen0:                     blobId = 0;                     type = edsTypeBlob;                     break;                  case edsBlobLen1:                 case edsBlobLen2:                 case edsBlobLen3:                 case edsBlobLen4:                     l = code - edsBlobLen1;                     blobId = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         blobId = (blobId << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeBlob;                     break;                  case edsScaledCount1:                     {                         // For some reason C++ EncodedStream expects the encoded                         // length to be length+1.                          length = (source[offset++] & 0xff) - 1;                         scale = (sbyte)source[offset++];                         type = edsTypeBigInt;                         bytes = new byte[length];                         Array.Copy(source' offset' bytes' 0' length);                         offset += length;                         int sign = ((bytes[0] & 0x80) > 0) ? -1 : 1;                          if (sign == -1)                         {                             bytes[0] &= 0x7f;                         }                          BigInteger bi = new BigInteger(bytes);                         bigDecimal = Decimal.Parse(bi.ToString());                     }                     break;                  case edsScaledCount2:                     {                         // For some reason C++ EncodedStream expects the encoded                         // length to be length+1.                          scale = (sbyte)source[offset++];                         sbyte sign = (sbyte)source[offset++];                         length = (source[offset++] & 0xff); // in bytes                         type = edsTypeBigInt;                         bytes = new byte[length];                         Array.Copy(source' offset' bytes' 0' length);                         offset += length;                          if (sign == -1)                             bytes[0] &= 0x7f;                         else                             sign = 1;                          BigInteger bi = new BigInteger(bytes);                         if (sign == -1)                             bi = -bi;                         bigDecimal = ScaleDecimal(Decimal.Parse(bi.ToString())' scale);                     }                     break;                  case edsUUID:                     {                         byte[] buff = new byte[16];                          for (int n = 0; n < 16; ++n)                         {                             buff[n] = (byte)(source[offset++] & 0xff);                         }                          uuid = new Guid(buff);                         type = edsTypeUUID;                     }                     break;                  default:                     type = edsTypeUnknown;                     break;             }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,decode,The following statement contains a magic number: switch (code)             {                 case edsNull:                     type = edsTypeNull;                     break;                  case edsTrue:                     type = edsTypeBoolean;                     @bool = true;                     break;                  case edsFalse:                     type = edsTypeBoolean;                     @bool = false;                     break;                  case edsIntMinus10:                 case edsIntMinus9:                 case edsIntMinus8:                 case edsIntMinus7:                 case edsIntMinus6:                 case edsIntMinus5:                 case edsIntMinus4:                 case edsIntMinus3:                 case edsIntMinus2:                 case edsIntMinus1:                 case edsInt0:                 case edsInt1:                 case edsInt2:                 case edsInt3:                 case edsInt4:                 case edsInt5:                 case edsInt6:                 case edsInt7:                 case edsInt8:                 case edsInt9:                 case edsInt10:                 case edsInt11:                 case edsInt12:                 case edsInt13:                 case edsInt14:                 case edsInt15:                 case edsInt16:                 case edsInt17:                 case edsInt18:                 case edsInt19:                 case edsInt20:                 case edsInt21:                 case edsInt22:                 case edsInt23:                 case edsInt24:                 case edsInt25:                 case edsInt26:                 case edsInt27:                 case edsInt28:                 case edsInt29:                 case edsInt30:                 case edsInt31:                     integer32 = code - edsInt0;                     scale = 0;                     type = edsTypeInt32;                     break;                  case edsIntLen1:                     type = edsTypeInt32;                     scale = 0;                     integer32 = (sbyte)source[offset++];                     break;                  case edsIntLen2:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset] << 8) | (source[offset + 1] & 0xff);                     offset += 2;                     break;                  case edsIntLen3:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset]) << 16 | (source[offset + 1] & 0xff) << 8 | (source[offset + 2] & 0xff);                     offset += 3;                     break;                  case edsIntLen4:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset]) << 24 | (source[offset + 1] & 0xff) << 16 | (source[offset + 2] & 0xff) << 8 | (source[offset + 3] & 0xff);                     offset += 4;                     break;                  case edsIntLen5:                 case edsIntLen6:                 case edsIntLen7:                 case edsIntLen8:                     l = code - edsIntLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeInt64;                     break;                  case edsScaledLen0:                     scale = (sbyte)source[offset++];                     integer64 = 0;                     type = edsTypeScaled;                     break;                  case edsScaledLen1:                 case edsScaledLen2:                 case edsScaledLen3:                 case edsScaledLen4:                 case edsScaledLen5:                 case edsScaledLen6:                 case edsScaledLen7:                 case edsScaledLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaled;                     break;                  case edsUtf8Len0:                 case edsUtf8Len1:                 case edsUtf8Len2:                 case edsUtf8Len3:                 case edsUtf8Len4:                 case edsUtf8Len5:                 case edsUtf8Len6:                 case edsUtf8Len7:                 case edsUtf8Len8:                 case edsUtf8Len9:                 case edsUtf8Len10:                 case edsUtf8Len11:                 case edsUtf8Len12:                 case edsUtf8Len13:                 case edsUtf8Len14:                 case edsUtf8Len15:                 case edsUtf8Len16:                 case edsUtf8Len17:                 case edsUtf8Len18:                 case edsUtf8Len19:                 case edsUtf8Len20:                 case edsUtf8Len21:                 case edsUtf8Len22:                 case edsUtf8Len23:                 case edsUtf8Len24:                 case edsUtf8Len25:                 case edsUtf8Len26:                 case edsUtf8Len27:                 case edsUtf8Len28:                 case edsUtf8Len29:                 case edsUtf8Len30:                 case edsUtf8Len31:                 case edsUtf8Len32:                 case edsUtf8Len33:                 case edsUtf8Len34:                 case edsUtf8Len35:                 case edsUtf8Len36:                 case edsUtf8Len37:                 case edsUtf8Len38:                 case edsUtf8Len39:                     l = code - edsUtf8Len0;                     @string = getString(source' offset' l);                     offset += l;                     type = edsTypeUtf8;                     break;                  case edsUtf8Count1:                 case edsUtf8Count2:                 case edsUtf8Count3:                 case edsUtf8Count4:                     count = code - edsUtf8Count1;                     int length = source[offset++] & 0xff;                      for (int n = 0; n < count; ++n)                     {                         length = length << 8 | (source[offset++] & 0xff);                     }                      @string = getString(source' offset' length);                     offset += length;                     type = edsTypeUtf8;                     break;                  case edsOpaqueLen0:                 case edsOpaqueLen1:                 case edsOpaqueLen2:                 case edsOpaqueLen3:                 case edsOpaqueLen4:                 case edsOpaqueLen5:                 case edsOpaqueLen6:                 case edsOpaqueLen7:                 case edsOpaqueLen8:                 case edsOpaqueLen9:                 case edsOpaqueLen10:                 case edsOpaqueLen11:                 case edsOpaqueLen12:                 case edsOpaqueLen13:                 case edsOpaqueLen14:                 case edsOpaqueLen15:                 case edsOpaqueLen16:                 case edsOpaqueLen17:                 case edsOpaqueLen18:                 case edsOpaqueLen19:                 case edsOpaqueLen20:                 case edsOpaqueLen21:                 case edsOpaqueLen22:                 case edsOpaqueLen23:                 case edsOpaqueLen24:                 case edsOpaqueLen25:                 case edsOpaqueLen26:                 case edsOpaqueLen27:                 case edsOpaqueLen28:                 case edsOpaqueLen29:                 case edsOpaqueLen30:                 case edsOpaqueLen31:                 case edsOpaqueLen32:                 case edsOpaqueLen33:                 case edsOpaqueLen34:                 case edsOpaqueLen35:                 case edsOpaqueLen36:                 case edsOpaqueLen37:                 case edsOpaqueLen38:                 case edsOpaqueLen39:                     l = code - edsOpaqueLen0;                     bytes = new byte[l];                     Array.Copy(source' offset' bytes' 0' l);                     offset += l;                     type = edsTypeOpaque;                     break;                  case edsOpaqueCount1:                 case edsOpaqueCount2:                 case edsOpaqueCount3:                 case edsOpaqueCount4:                     count = code - edsOpaqueCount1 + 1;                     l = source[offset++] & 0xff;                      for (int n = 1; n < count; ++n)                     {                         l = l << 8 | (source[offset++] & 0xff);                     }                      bytes = new byte[l];                     Array.Copy(source' offset' bytes' 0' l);                     offset += l;                     type = edsTypeOpaque;                     break;                  case edsDoubleLen0:                 case edsDoubleLen1:                 case edsDoubleLen2:                 case edsDoubleLen3:                 case edsDoubleLen4:                 case edsDoubleLen5:                 case edsDoubleLen6:                 case edsDoubleLen7:                 case edsDoubleLen8:                     count = code - edsDoubleLen0;                     long lvalue = 0;                      for (int n = 0; n < count; ++n)                     {                         lvalue = (lvalue << 8) | (source[offset++] & 0xff);                     }                      lvalue <<= (8 - count) * 8;                     dbl = BitConverter.Int64BitsToDouble(lvalue);                     type = edsTypeDouble;                     break;                  case edsTimeLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeTime;                     break;                  case edsTimeLen1:                 case edsTimeLen2:                 case edsTimeLen3:                 case edsTimeLen4:                     l = code - edsTimeLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeTime;                     break;                  case edsMilliSecLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeMilliseconds;                     break;                  case edsMilliSecLen1:                 case edsMilliSecLen2:                 case edsMilliSecLen3:                 case edsMilliSecLen4:                 case edsMilliSecLen5:                 case edsMilliSecLen6:                 case edsMilliSecLen7:                 case edsMilliSecLen8:                     l = code - edsMilliSecLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeMilliseconds;                     break;                  case edsNanoSecLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeNanoseconds;                     break;                  case edsNanoSecLen1:                 case edsNanoSecLen2:                 case edsNanoSecLen3:                 case edsNanoSecLen4:                 case edsNanoSecLen5:                 case edsNanoSecLen6:                 case edsNanoSecLen7:                 case edsNanoSecLen8:                     l = code - edsNanoSecLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeNanoseconds;                     break;                  //                 // 09/2012 Added support for new scaled date/times encoding. These replace the old encoding                 // edsTimeLen' edsMilliSecLen and edsNanoSecLen.                 //                  case edsScaledTimeLen1:                 case edsScaledTimeLen2:                 case edsScaledTimeLen3:                 case edsScaledTimeLen4:                 case edsScaledTimeLen5:                 case edsScaledTimeLen6:                 case edsScaledTimeLen7:                 case edsScaledTimeLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledTimeLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledTime;                     break;                  case edsScaledDateLen1:                 case edsScaledDateLen2:                 case edsScaledDateLen3:                 case edsScaledDateLen4:                 case edsScaledDateLen5:                 case edsScaledDateLen6:                 case edsScaledDateLen7:                 case edsScaledDateLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledDateLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledDate;                     break;                  case edsScaledTimestampLen1:                 case edsScaledTimestampLen2:                 case edsScaledTimestampLen3:                 case edsScaledTimestampLen4:                 case edsScaledTimestampLen5:                 case edsScaledTimestampLen6:                 case edsScaledTimestampLen7:                 case edsScaledTimestampLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledTimestampLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledTimestamp;                     break;                  case edsClobLen0:                     blobId = 0;                     type = edsTypeClob;                     break;                  case edsClobLen1:                 case edsClobLen2:                 case edsClobLen3:                 case edsClobLen4:                     l = code - edsClobLen1;                     blobId = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         blobId = (blobId << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeClob;                     break;                  case edsBlobLen0:                     blobId = 0;                     type = edsTypeBlob;                     break;                  case edsBlobLen1:                 case edsBlobLen2:                 case edsBlobLen3:                 case edsBlobLen4:                     l = code - edsBlobLen1;                     blobId = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         blobId = (blobId << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeBlob;                     break;                  case edsScaledCount1:                     {                         // For some reason C++ EncodedStream expects the encoded                         // length to be length+1.                          length = (source[offset++] & 0xff) - 1;                         scale = (sbyte)source[offset++];                         type = edsTypeBigInt;                         bytes = new byte[length];                         Array.Copy(source' offset' bytes' 0' length);                         offset += length;                         int sign = ((bytes[0] & 0x80) > 0) ? -1 : 1;                          if (sign == -1)                         {                             bytes[0] &= 0x7f;                         }                          BigInteger bi = new BigInteger(bytes);                         bigDecimal = Decimal.Parse(bi.ToString());                     }                     break;                  case edsScaledCount2:                     {                         // For some reason C++ EncodedStream expects the encoded                         // length to be length+1.                          scale = (sbyte)source[offset++];                         sbyte sign = (sbyte)source[offset++];                         length = (source[offset++] & 0xff); // in bytes                         type = edsTypeBigInt;                         bytes = new byte[length];                         Array.Copy(source' offset' bytes' 0' length);                         offset += length;                          if (sign == -1)                             bytes[0] &= 0x7f;                         else                             sign = 1;                          BigInteger bi = new BigInteger(bytes);                         if (sign == -1)                             bi = -bi;                         bigDecimal = ScaleDecimal(Decimal.Parse(bi.ToString())' scale);                     }                     break;                  case edsUUID:                     {                         byte[] buff = new byte[16];                          for (int n = 0; n < 16; ++n)                         {                             buff[n] = (byte)(source[offset++] & 0xff);                         }                          uuid = new Guid(buff);                         type = edsTypeUUID;                     }                     break;                  default:                     type = edsTypeUnknown;                     break;             }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,decode,The following statement contains a magic number: switch (code)             {                 case edsNull:                     type = edsTypeNull;                     break;                  case edsTrue:                     type = edsTypeBoolean;                     @bool = true;                     break;                  case edsFalse:                     type = edsTypeBoolean;                     @bool = false;                     break;                  case edsIntMinus10:                 case edsIntMinus9:                 case edsIntMinus8:                 case edsIntMinus7:                 case edsIntMinus6:                 case edsIntMinus5:                 case edsIntMinus4:                 case edsIntMinus3:                 case edsIntMinus2:                 case edsIntMinus1:                 case edsInt0:                 case edsInt1:                 case edsInt2:                 case edsInt3:                 case edsInt4:                 case edsInt5:                 case edsInt6:                 case edsInt7:                 case edsInt8:                 case edsInt9:                 case edsInt10:                 case edsInt11:                 case edsInt12:                 case edsInt13:                 case edsInt14:                 case edsInt15:                 case edsInt16:                 case edsInt17:                 case edsInt18:                 case edsInt19:                 case edsInt20:                 case edsInt21:                 case edsInt22:                 case edsInt23:                 case edsInt24:                 case edsInt25:                 case edsInt26:                 case edsInt27:                 case edsInt28:                 case edsInt29:                 case edsInt30:                 case edsInt31:                     integer32 = code - edsInt0;                     scale = 0;                     type = edsTypeInt32;                     break;                  case edsIntLen1:                     type = edsTypeInt32;                     scale = 0;                     integer32 = (sbyte)source[offset++];                     break;                  case edsIntLen2:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset] << 8) | (source[offset + 1] & 0xff);                     offset += 2;                     break;                  case edsIntLen3:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset]) << 16 | (source[offset + 1] & 0xff) << 8 | (source[offset + 2] & 0xff);                     offset += 3;                     break;                  case edsIntLen4:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset]) << 24 | (source[offset + 1] & 0xff) << 16 | (source[offset + 2] & 0xff) << 8 | (source[offset + 3] & 0xff);                     offset += 4;                     break;                  case edsIntLen5:                 case edsIntLen6:                 case edsIntLen7:                 case edsIntLen8:                     l = code - edsIntLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeInt64;                     break;                  case edsScaledLen0:                     scale = (sbyte)source[offset++];                     integer64 = 0;                     type = edsTypeScaled;                     break;                  case edsScaledLen1:                 case edsScaledLen2:                 case edsScaledLen3:                 case edsScaledLen4:                 case edsScaledLen5:                 case edsScaledLen6:                 case edsScaledLen7:                 case edsScaledLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaled;                     break;                  case edsUtf8Len0:                 case edsUtf8Len1:                 case edsUtf8Len2:                 case edsUtf8Len3:                 case edsUtf8Len4:                 case edsUtf8Len5:                 case edsUtf8Len6:                 case edsUtf8Len7:                 case edsUtf8Len8:                 case edsUtf8Len9:                 case edsUtf8Len10:                 case edsUtf8Len11:                 case edsUtf8Len12:                 case edsUtf8Len13:                 case edsUtf8Len14:                 case edsUtf8Len15:                 case edsUtf8Len16:                 case edsUtf8Len17:                 case edsUtf8Len18:                 case edsUtf8Len19:                 case edsUtf8Len20:                 case edsUtf8Len21:                 case edsUtf8Len22:                 case edsUtf8Len23:                 case edsUtf8Len24:                 case edsUtf8Len25:                 case edsUtf8Len26:                 case edsUtf8Len27:                 case edsUtf8Len28:                 case edsUtf8Len29:                 case edsUtf8Len30:                 case edsUtf8Len31:                 case edsUtf8Len32:                 case edsUtf8Len33:                 case edsUtf8Len34:                 case edsUtf8Len35:                 case edsUtf8Len36:                 case edsUtf8Len37:                 case edsUtf8Len38:                 case edsUtf8Len39:                     l = code - edsUtf8Len0;                     @string = getString(source' offset' l);                     offset += l;                     type = edsTypeUtf8;                     break;                  case edsUtf8Count1:                 case edsUtf8Count2:                 case edsUtf8Count3:                 case edsUtf8Count4:                     count = code - edsUtf8Count1;                     int length = source[offset++] & 0xff;                      for (int n = 0; n < count; ++n)                     {                         length = length << 8 | (source[offset++] & 0xff);                     }                      @string = getString(source' offset' length);                     offset += length;                     type = edsTypeUtf8;                     break;                  case edsOpaqueLen0:                 case edsOpaqueLen1:                 case edsOpaqueLen2:                 case edsOpaqueLen3:                 case edsOpaqueLen4:                 case edsOpaqueLen5:                 case edsOpaqueLen6:                 case edsOpaqueLen7:                 case edsOpaqueLen8:                 case edsOpaqueLen9:                 case edsOpaqueLen10:                 case edsOpaqueLen11:                 case edsOpaqueLen12:                 case edsOpaqueLen13:                 case edsOpaqueLen14:                 case edsOpaqueLen15:                 case edsOpaqueLen16:                 case edsOpaqueLen17:                 case edsOpaqueLen18:                 case edsOpaqueLen19:                 case edsOpaqueLen20:                 case edsOpaqueLen21:                 case edsOpaqueLen22:                 case edsOpaqueLen23:                 case edsOpaqueLen24:                 case edsOpaqueLen25:                 case edsOpaqueLen26:                 case edsOpaqueLen27:                 case edsOpaqueLen28:                 case edsOpaqueLen29:                 case edsOpaqueLen30:                 case edsOpaqueLen31:                 case edsOpaqueLen32:                 case edsOpaqueLen33:                 case edsOpaqueLen34:                 case edsOpaqueLen35:                 case edsOpaqueLen36:                 case edsOpaqueLen37:                 case edsOpaqueLen38:                 case edsOpaqueLen39:                     l = code - edsOpaqueLen0;                     bytes = new byte[l];                     Array.Copy(source' offset' bytes' 0' l);                     offset += l;                     type = edsTypeOpaque;                     break;                  case edsOpaqueCount1:                 case edsOpaqueCount2:                 case edsOpaqueCount3:                 case edsOpaqueCount4:                     count = code - edsOpaqueCount1 + 1;                     l = source[offset++] & 0xff;                      for (int n = 1; n < count; ++n)                     {                         l = l << 8 | (source[offset++] & 0xff);                     }                      bytes = new byte[l];                     Array.Copy(source' offset' bytes' 0' l);                     offset += l;                     type = edsTypeOpaque;                     break;                  case edsDoubleLen0:                 case edsDoubleLen1:                 case edsDoubleLen2:                 case edsDoubleLen3:                 case edsDoubleLen4:                 case edsDoubleLen5:                 case edsDoubleLen6:                 case edsDoubleLen7:                 case edsDoubleLen8:                     count = code - edsDoubleLen0;                     long lvalue = 0;                      for (int n = 0; n < count; ++n)                     {                         lvalue = (lvalue << 8) | (source[offset++] & 0xff);                     }                      lvalue <<= (8 - count) * 8;                     dbl = BitConverter.Int64BitsToDouble(lvalue);                     type = edsTypeDouble;                     break;                  case edsTimeLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeTime;                     break;                  case edsTimeLen1:                 case edsTimeLen2:                 case edsTimeLen3:                 case edsTimeLen4:                     l = code - edsTimeLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeTime;                     break;                  case edsMilliSecLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeMilliseconds;                     break;                  case edsMilliSecLen1:                 case edsMilliSecLen2:                 case edsMilliSecLen3:                 case edsMilliSecLen4:                 case edsMilliSecLen5:                 case edsMilliSecLen6:                 case edsMilliSecLen7:                 case edsMilliSecLen8:                     l = code - edsMilliSecLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeMilliseconds;                     break;                  case edsNanoSecLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeNanoseconds;                     break;                  case edsNanoSecLen1:                 case edsNanoSecLen2:                 case edsNanoSecLen3:                 case edsNanoSecLen4:                 case edsNanoSecLen5:                 case edsNanoSecLen6:                 case edsNanoSecLen7:                 case edsNanoSecLen8:                     l = code - edsNanoSecLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeNanoseconds;                     break;                  //                 // 09/2012 Added support for new scaled date/times encoding. These replace the old encoding                 // edsTimeLen' edsMilliSecLen and edsNanoSecLen.                 //                  case edsScaledTimeLen1:                 case edsScaledTimeLen2:                 case edsScaledTimeLen3:                 case edsScaledTimeLen4:                 case edsScaledTimeLen5:                 case edsScaledTimeLen6:                 case edsScaledTimeLen7:                 case edsScaledTimeLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledTimeLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledTime;                     break;                  case edsScaledDateLen1:                 case edsScaledDateLen2:                 case edsScaledDateLen3:                 case edsScaledDateLen4:                 case edsScaledDateLen5:                 case edsScaledDateLen6:                 case edsScaledDateLen7:                 case edsScaledDateLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledDateLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledDate;                     break;                  case edsScaledTimestampLen1:                 case edsScaledTimestampLen2:                 case edsScaledTimestampLen3:                 case edsScaledTimestampLen4:                 case edsScaledTimestampLen5:                 case edsScaledTimestampLen6:                 case edsScaledTimestampLen7:                 case edsScaledTimestampLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledTimestampLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledTimestamp;                     break;                  case edsClobLen0:                     blobId = 0;                     type = edsTypeClob;                     break;                  case edsClobLen1:                 case edsClobLen2:                 case edsClobLen3:                 case edsClobLen4:                     l = code - edsClobLen1;                     blobId = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         blobId = (blobId << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeClob;                     break;                  case edsBlobLen0:                     blobId = 0;                     type = edsTypeBlob;                     break;                  case edsBlobLen1:                 case edsBlobLen2:                 case edsBlobLen3:                 case edsBlobLen4:                     l = code - edsBlobLen1;                     blobId = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         blobId = (blobId << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeBlob;                     break;                  case edsScaledCount1:                     {                         // For some reason C++ EncodedStream expects the encoded                         // length to be length+1.                          length = (source[offset++] & 0xff) - 1;                         scale = (sbyte)source[offset++];                         type = edsTypeBigInt;                         bytes = new byte[length];                         Array.Copy(source' offset' bytes' 0' length);                         offset += length;                         int sign = ((bytes[0] & 0x80) > 0) ? -1 : 1;                          if (sign == -1)                         {                             bytes[0] &= 0x7f;                         }                          BigInteger bi = new BigInteger(bytes);                         bigDecimal = Decimal.Parse(bi.ToString());                     }                     break;                  case edsScaledCount2:                     {                         // For some reason C++ EncodedStream expects the encoded                         // length to be length+1.                          scale = (sbyte)source[offset++];                         sbyte sign = (sbyte)source[offset++];                         length = (source[offset++] & 0xff); // in bytes                         type = edsTypeBigInt;                         bytes = new byte[length];                         Array.Copy(source' offset' bytes' 0' length);                         offset += length;                          if (sign == -1)                             bytes[0] &= 0x7f;                         else                             sign = 1;                          BigInteger bi = new BigInteger(bytes);                         if (sign == -1)                             bi = -bi;                         bigDecimal = ScaleDecimal(Decimal.Parse(bi.ToString())' scale);                     }                     break;                  case edsUUID:                     {                         byte[] buff = new byte[16];                          for (int n = 0; n < 16; ++n)                         {                             buff[n] = (byte)(source[offset++] & 0xff);                         }                          uuid = new Guid(buff);                         type = edsTypeUUID;                     }                     break;                  default:                     type = edsTypeUnknown;                     break;             }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,decode,The following statement contains a magic number: switch (code)             {                 case edsNull:                     type = edsTypeNull;                     break;                  case edsTrue:                     type = edsTypeBoolean;                     @bool = true;                     break;                  case edsFalse:                     type = edsTypeBoolean;                     @bool = false;                     break;                  case edsIntMinus10:                 case edsIntMinus9:                 case edsIntMinus8:                 case edsIntMinus7:                 case edsIntMinus6:                 case edsIntMinus5:                 case edsIntMinus4:                 case edsIntMinus3:                 case edsIntMinus2:                 case edsIntMinus1:                 case edsInt0:                 case edsInt1:                 case edsInt2:                 case edsInt3:                 case edsInt4:                 case edsInt5:                 case edsInt6:                 case edsInt7:                 case edsInt8:                 case edsInt9:                 case edsInt10:                 case edsInt11:                 case edsInt12:                 case edsInt13:                 case edsInt14:                 case edsInt15:                 case edsInt16:                 case edsInt17:                 case edsInt18:                 case edsInt19:                 case edsInt20:                 case edsInt21:                 case edsInt22:                 case edsInt23:                 case edsInt24:                 case edsInt25:                 case edsInt26:                 case edsInt27:                 case edsInt28:                 case edsInt29:                 case edsInt30:                 case edsInt31:                     integer32 = code - edsInt0;                     scale = 0;                     type = edsTypeInt32;                     break;                  case edsIntLen1:                     type = edsTypeInt32;                     scale = 0;                     integer32 = (sbyte)source[offset++];                     break;                  case edsIntLen2:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset] << 8) | (source[offset + 1] & 0xff);                     offset += 2;                     break;                  case edsIntLen3:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset]) << 16 | (source[offset + 1] & 0xff) << 8 | (source[offset + 2] & 0xff);                     offset += 3;                     break;                  case edsIntLen4:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset]) << 24 | (source[offset + 1] & 0xff) << 16 | (source[offset + 2] & 0xff) << 8 | (source[offset + 3] & 0xff);                     offset += 4;                     break;                  case edsIntLen5:                 case edsIntLen6:                 case edsIntLen7:                 case edsIntLen8:                     l = code - edsIntLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeInt64;                     break;                  case edsScaledLen0:                     scale = (sbyte)source[offset++];                     integer64 = 0;                     type = edsTypeScaled;                     break;                  case edsScaledLen1:                 case edsScaledLen2:                 case edsScaledLen3:                 case edsScaledLen4:                 case edsScaledLen5:                 case edsScaledLen6:                 case edsScaledLen7:                 case edsScaledLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaled;                     break;                  case edsUtf8Len0:                 case edsUtf8Len1:                 case edsUtf8Len2:                 case edsUtf8Len3:                 case edsUtf8Len4:                 case edsUtf8Len5:                 case edsUtf8Len6:                 case edsUtf8Len7:                 case edsUtf8Len8:                 case edsUtf8Len9:                 case edsUtf8Len10:                 case edsUtf8Len11:                 case edsUtf8Len12:                 case edsUtf8Len13:                 case edsUtf8Len14:                 case edsUtf8Len15:                 case edsUtf8Len16:                 case edsUtf8Len17:                 case edsUtf8Len18:                 case edsUtf8Len19:                 case edsUtf8Len20:                 case edsUtf8Len21:                 case edsUtf8Len22:                 case edsUtf8Len23:                 case edsUtf8Len24:                 case edsUtf8Len25:                 case edsUtf8Len26:                 case edsUtf8Len27:                 case edsUtf8Len28:                 case edsUtf8Len29:                 case edsUtf8Len30:                 case edsUtf8Len31:                 case edsUtf8Len32:                 case edsUtf8Len33:                 case edsUtf8Len34:                 case edsUtf8Len35:                 case edsUtf8Len36:                 case edsUtf8Len37:                 case edsUtf8Len38:                 case edsUtf8Len39:                     l = code - edsUtf8Len0;                     @string = getString(source' offset' l);                     offset += l;                     type = edsTypeUtf8;                     break;                  case edsUtf8Count1:                 case edsUtf8Count2:                 case edsUtf8Count3:                 case edsUtf8Count4:                     count = code - edsUtf8Count1;                     int length = source[offset++] & 0xff;                      for (int n = 0; n < count; ++n)                     {                         length = length << 8 | (source[offset++] & 0xff);                     }                      @string = getString(source' offset' length);                     offset += length;                     type = edsTypeUtf8;                     break;                  case edsOpaqueLen0:                 case edsOpaqueLen1:                 case edsOpaqueLen2:                 case edsOpaqueLen3:                 case edsOpaqueLen4:                 case edsOpaqueLen5:                 case edsOpaqueLen6:                 case edsOpaqueLen7:                 case edsOpaqueLen8:                 case edsOpaqueLen9:                 case edsOpaqueLen10:                 case edsOpaqueLen11:                 case edsOpaqueLen12:                 case edsOpaqueLen13:                 case edsOpaqueLen14:                 case edsOpaqueLen15:                 case edsOpaqueLen16:                 case edsOpaqueLen17:                 case edsOpaqueLen18:                 case edsOpaqueLen19:                 case edsOpaqueLen20:                 case edsOpaqueLen21:                 case edsOpaqueLen22:                 case edsOpaqueLen23:                 case edsOpaqueLen24:                 case edsOpaqueLen25:                 case edsOpaqueLen26:                 case edsOpaqueLen27:                 case edsOpaqueLen28:                 case edsOpaqueLen29:                 case edsOpaqueLen30:                 case edsOpaqueLen31:                 case edsOpaqueLen32:                 case edsOpaqueLen33:                 case edsOpaqueLen34:                 case edsOpaqueLen35:                 case edsOpaqueLen36:                 case edsOpaqueLen37:                 case edsOpaqueLen38:                 case edsOpaqueLen39:                     l = code - edsOpaqueLen0;                     bytes = new byte[l];                     Array.Copy(source' offset' bytes' 0' l);                     offset += l;                     type = edsTypeOpaque;                     break;                  case edsOpaqueCount1:                 case edsOpaqueCount2:                 case edsOpaqueCount3:                 case edsOpaqueCount4:                     count = code - edsOpaqueCount1 + 1;                     l = source[offset++] & 0xff;                      for (int n = 1; n < count; ++n)                     {                         l = l << 8 | (source[offset++] & 0xff);                     }                      bytes = new byte[l];                     Array.Copy(source' offset' bytes' 0' l);                     offset += l;                     type = edsTypeOpaque;                     break;                  case edsDoubleLen0:                 case edsDoubleLen1:                 case edsDoubleLen2:                 case edsDoubleLen3:                 case edsDoubleLen4:                 case edsDoubleLen5:                 case edsDoubleLen6:                 case edsDoubleLen7:                 case edsDoubleLen8:                     count = code - edsDoubleLen0;                     long lvalue = 0;                      for (int n = 0; n < count; ++n)                     {                         lvalue = (lvalue << 8) | (source[offset++] & 0xff);                     }                      lvalue <<= (8 - count) * 8;                     dbl = BitConverter.Int64BitsToDouble(lvalue);                     type = edsTypeDouble;                     break;                  case edsTimeLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeTime;                     break;                  case edsTimeLen1:                 case edsTimeLen2:                 case edsTimeLen3:                 case edsTimeLen4:                     l = code - edsTimeLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeTime;                     break;                  case edsMilliSecLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeMilliseconds;                     break;                  case edsMilliSecLen1:                 case edsMilliSecLen2:                 case edsMilliSecLen3:                 case edsMilliSecLen4:                 case edsMilliSecLen5:                 case edsMilliSecLen6:                 case edsMilliSecLen7:                 case edsMilliSecLen8:                     l = code - edsMilliSecLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeMilliseconds;                     break;                  case edsNanoSecLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeNanoseconds;                     break;                  case edsNanoSecLen1:                 case edsNanoSecLen2:                 case edsNanoSecLen3:                 case edsNanoSecLen4:                 case edsNanoSecLen5:                 case edsNanoSecLen6:                 case edsNanoSecLen7:                 case edsNanoSecLen8:                     l = code - edsNanoSecLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeNanoseconds;                     break;                  //                 // 09/2012 Added support for new scaled date/times encoding. These replace the old encoding                 // edsTimeLen' edsMilliSecLen and edsNanoSecLen.                 //                  case edsScaledTimeLen1:                 case edsScaledTimeLen2:                 case edsScaledTimeLen3:                 case edsScaledTimeLen4:                 case edsScaledTimeLen5:                 case edsScaledTimeLen6:                 case edsScaledTimeLen7:                 case edsScaledTimeLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledTimeLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledTime;                     break;                  case edsScaledDateLen1:                 case edsScaledDateLen2:                 case edsScaledDateLen3:                 case edsScaledDateLen4:                 case edsScaledDateLen5:                 case edsScaledDateLen6:                 case edsScaledDateLen7:                 case edsScaledDateLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledDateLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledDate;                     break;                  case edsScaledTimestampLen1:                 case edsScaledTimestampLen2:                 case edsScaledTimestampLen3:                 case edsScaledTimestampLen4:                 case edsScaledTimestampLen5:                 case edsScaledTimestampLen6:                 case edsScaledTimestampLen7:                 case edsScaledTimestampLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledTimestampLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledTimestamp;                     break;                  case edsClobLen0:                     blobId = 0;                     type = edsTypeClob;                     break;                  case edsClobLen1:                 case edsClobLen2:                 case edsClobLen3:                 case edsClobLen4:                     l = code - edsClobLen1;                     blobId = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         blobId = (blobId << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeClob;                     break;                  case edsBlobLen0:                     blobId = 0;                     type = edsTypeBlob;                     break;                  case edsBlobLen1:                 case edsBlobLen2:                 case edsBlobLen3:                 case edsBlobLen4:                     l = code - edsBlobLen1;                     blobId = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         blobId = (blobId << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeBlob;                     break;                  case edsScaledCount1:                     {                         // For some reason C++ EncodedStream expects the encoded                         // length to be length+1.                          length = (source[offset++] & 0xff) - 1;                         scale = (sbyte)source[offset++];                         type = edsTypeBigInt;                         bytes = new byte[length];                         Array.Copy(source' offset' bytes' 0' length);                         offset += length;                         int sign = ((bytes[0] & 0x80) > 0) ? -1 : 1;                          if (sign == -1)                         {                             bytes[0] &= 0x7f;                         }                          BigInteger bi = new BigInteger(bytes);                         bigDecimal = Decimal.Parse(bi.ToString());                     }                     break;                  case edsScaledCount2:                     {                         // For some reason C++ EncodedStream expects the encoded                         // length to be length+1.                          scale = (sbyte)source[offset++];                         sbyte sign = (sbyte)source[offset++];                         length = (source[offset++] & 0xff); // in bytes                         type = edsTypeBigInt;                         bytes = new byte[length];                         Array.Copy(source' offset' bytes' 0' length);                         offset += length;                          if (sign == -1)                             bytes[0] &= 0x7f;                         else                             sign = 1;                          BigInteger bi = new BigInteger(bytes);                         if (sign == -1)                             bi = -bi;                         bigDecimal = ScaleDecimal(Decimal.Parse(bi.ToString())' scale);                     }                     break;                  case edsUUID:                     {                         byte[] buff = new byte[16];                          for (int n = 0; n < 16; ++n)                         {                             buff[n] = (byte)(source[offset++] & 0xff);                         }                          uuid = new Guid(buff);                         type = edsTypeUUID;                     }                     break;                  default:                     type = edsTypeUnknown;                     break;             }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,decode,The following statement contains a magic number: switch (code)             {                 case edsNull:                     type = edsTypeNull;                     break;                  case edsTrue:                     type = edsTypeBoolean;                     @bool = true;                     break;                  case edsFalse:                     type = edsTypeBoolean;                     @bool = false;                     break;                  case edsIntMinus10:                 case edsIntMinus9:                 case edsIntMinus8:                 case edsIntMinus7:                 case edsIntMinus6:                 case edsIntMinus5:                 case edsIntMinus4:                 case edsIntMinus3:                 case edsIntMinus2:                 case edsIntMinus1:                 case edsInt0:                 case edsInt1:                 case edsInt2:                 case edsInt3:                 case edsInt4:                 case edsInt5:                 case edsInt6:                 case edsInt7:                 case edsInt8:                 case edsInt9:                 case edsInt10:                 case edsInt11:                 case edsInt12:                 case edsInt13:                 case edsInt14:                 case edsInt15:                 case edsInt16:                 case edsInt17:                 case edsInt18:                 case edsInt19:                 case edsInt20:                 case edsInt21:                 case edsInt22:                 case edsInt23:                 case edsInt24:                 case edsInt25:                 case edsInt26:                 case edsInt27:                 case edsInt28:                 case edsInt29:                 case edsInt30:                 case edsInt31:                     integer32 = code - edsInt0;                     scale = 0;                     type = edsTypeInt32;                     break;                  case edsIntLen1:                     type = edsTypeInt32;                     scale = 0;                     integer32 = (sbyte)source[offset++];                     break;                  case edsIntLen2:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset] << 8) | (source[offset + 1] & 0xff);                     offset += 2;                     break;                  case edsIntLen3:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset]) << 16 | (source[offset + 1] & 0xff) << 8 | (source[offset + 2] & 0xff);                     offset += 3;                     break;                  case edsIntLen4:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset]) << 24 | (source[offset + 1] & 0xff) << 16 | (source[offset + 2] & 0xff) << 8 | (source[offset + 3] & 0xff);                     offset += 4;                     break;                  case edsIntLen5:                 case edsIntLen6:                 case edsIntLen7:                 case edsIntLen8:                     l = code - edsIntLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeInt64;                     break;                  case edsScaledLen0:                     scale = (sbyte)source[offset++];                     integer64 = 0;                     type = edsTypeScaled;                     break;                  case edsScaledLen1:                 case edsScaledLen2:                 case edsScaledLen3:                 case edsScaledLen4:                 case edsScaledLen5:                 case edsScaledLen6:                 case edsScaledLen7:                 case edsScaledLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaled;                     break;                  case edsUtf8Len0:                 case edsUtf8Len1:                 case edsUtf8Len2:                 case edsUtf8Len3:                 case edsUtf8Len4:                 case edsUtf8Len5:                 case edsUtf8Len6:                 case edsUtf8Len7:                 case edsUtf8Len8:                 case edsUtf8Len9:                 case edsUtf8Len10:                 case edsUtf8Len11:                 case edsUtf8Len12:                 case edsUtf8Len13:                 case edsUtf8Len14:                 case edsUtf8Len15:                 case edsUtf8Len16:                 case edsUtf8Len17:                 case edsUtf8Len18:                 case edsUtf8Len19:                 case edsUtf8Len20:                 case edsUtf8Len21:                 case edsUtf8Len22:                 case edsUtf8Len23:                 case edsUtf8Len24:                 case edsUtf8Len25:                 case edsUtf8Len26:                 case edsUtf8Len27:                 case edsUtf8Len28:                 case edsUtf8Len29:                 case edsUtf8Len30:                 case edsUtf8Len31:                 case edsUtf8Len32:                 case edsUtf8Len33:                 case edsUtf8Len34:                 case edsUtf8Len35:                 case edsUtf8Len36:                 case edsUtf8Len37:                 case edsUtf8Len38:                 case edsUtf8Len39:                     l = code - edsUtf8Len0;                     @string = getString(source' offset' l);                     offset += l;                     type = edsTypeUtf8;                     break;                  case edsUtf8Count1:                 case edsUtf8Count2:                 case edsUtf8Count3:                 case edsUtf8Count4:                     count = code - edsUtf8Count1;                     int length = source[offset++] & 0xff;                      for (int n = 0; n < count; ++n)                     {                         length = length << 8 | (source[offset++] & 0xff);                     }                      @string = getString(source' offset' length);                     offset += length;                     type = edsTypeUtf8;                     break;                  case edsOpaqueLen0:                 case edsOpaqueLen1:                 case edsOpaqueLen2:                 case edsOpaqueLen3:                 case edsOpaqueLen4:                 case edsOpaqueLen5:                 case edsOpaqueLen6:                 case edsOpaqueLen7:                 case edsOpaqueLen8:                 case edsOpaqueLen9:                 case edsOpaqueLen10:                 case edsOpaqueLen11:                 case edsOpaqueLen12:                 case edsOpaqueLen13:                 case edsOpaqueLen14:                 case edsOpaqueLen15:                 case edsOpaqueLen16:                 case edsOpaqueLen17:                 case edsOpaqueLen18:                 case edsOpaqueLen19:                 case edsOpaqueLen20:                 case edsOpaqueLen21:                 case edsOpaqueLen22:                 case edsOpaqueLen23:                 case edsOpaqueLen24:                 case edsOpaqueLen25:                 case edsOpaqueLen26:                 case edsOpaqueLen27:                 case edsOpaqueLen28:                 case edsOpaqueLen29:                 case edsOpaqueLen30:                 case edsOpaqueLen31:                 case edsOpaqueLen32:                 case edsOpaqueLen33:                 case edsOpaqueLen34:                 case edsOpaqueLen35:                 case edsOpaqueLen36:                 case edsOpaqueLen37:                 case edsOpaqueLen38:                 case edsOpaqueLen39:                     l = code - edsOpaqueLen0;                     bytes = new byte[l];                     Array.Copy(source' offset' bytes' 0' l);                     offset += l;                     type = edsTypeOpaque;                     break;                  case edsOpaqueCount1:                 case edsOpaqueCount2:                 case edsOpaqueCount3:                 case edsOpaqueCount4:                     count = code - edsOpaqueCount1 + 1;                     l = source[offset++] & 0xff;                      for (int n = 1; n < count; ++n)                     {                         l = l << 8 | (source[offset++] & 0xff);                     }                      bytes = new byte[l];                     Array.Copy(source' offset' bytes' 0' l);                     offset += l;                     type = edsTypeOpaque;                     break;                  case edsDoubleLen0:                 case edsDoubleLen1:                 case edsDoubleLen2:                 case edsDoubleLen3:                 case edsDoubleLen4:                 case edsDoubleLen5:                 case edsDoubleLen6:                 case edsDoubleLen7:                 case edsDoubleLen8:                     count = code - edsDoubleLen0;                     long lvalue = 0;                      for (int n = 0; n < count; ++n)                     {                         lvalue = (lvalue << 8) | (source[offset++] & 0xff);                     }                      lvalue <<= (8 - count) * 8;                     dbl = BitConverter.Int64BitsToDouble(lvalue);                     type = edsTypeDouble;                     break;                  case edsTimeLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeTime;                     break;                  case edsTimeLen1:                 case edsTimeLen2:                 case edsTimeLen3:                 case edsTimeLen4:                     l = code - edsTimeLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeTime;                     break;                  case edsMilliSecLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeMilliseconds;                     break;                  case edsMilliSecLen1:                 case edsMilliSecLen2:                 case edsMilliSecLen3:                 case edsMilliSecLen4:                 case edsMilliSecLen5:                 case edsMilliSecLen6:                 case edsMilliSecLen7:                 case edsMilliSecLen8:                     l = code - edsMilliSecLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeMilliseconds;                     break;                  case edsNanoSecLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeNanoseconds;                     break;                  case edsNanoSecLen1:                 case edsNanoSecLen2:                 case edsNanoSecLen3:                 case edsNanoSecLen4:                 case edsNanoSecLen5:                 case edsNanoSecLen6:                 case edsNanoSecLen7:                 case edsNanoSecLen8:                     l = code - edsNanoSecLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeNanoseconds;                     break;                  //                 // 09/2012 Added support for new scaled date/times encoding. These replace the old encoding                 // edsTimeLen' edsMilliSecLen and edsNanoSecLen.                 //                  case edsScaledTimeLen1:                 case edsScaledTimeLen2:                 case edsScaledTimeLen3:                 case edsScaledTimeLen4:                 case edsScaledTimeLen5:                 case edsScaledTimeLen6:                 case edsScaledTimeLen7:                 case edsScaledTimeLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledTimeLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledTime;                     break;                  case edsScaledDateLen1:                 case edsScaledDateLen2:                 case edsScaledDateLen3:                 case edsScaledDateLen4:                 case edsScaledDateLen5:                 case edsScaledDateLen6:                 case edsScaledDateLen7:                 case edsScaledDateLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledDateLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledDate;                     break;                  case edsScaledTimestampLen1:                 case edsScaledTimestampLen2:                 case edsScaledTimestampLen3:                 case edsScaledTimestampLen4:                 case edsScaledTimestampLen5:                 case edsScaledTimestampLen6:                 case edsScaledTimestampLen7:                 case edsScaledTimestampLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledTimestampLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledTimestamp;                     break;                  case edsClobLen0:                     blobId = 0;                     type = edsTypeClob;                     break;                  case edsClobLen1:                 case edsClobLen2:                 case edsClobLen3:                 case edsClobLen4:                     l = code - edsClobLen1;                     blobId = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         blobId = (blobId << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeClob;                     break;                  case edsBlobLen0:                     blobId = 0;                     type = edsTypeBlob;                     break;                  case edsBlobLen1:                 case edsBlobLen2:                 case edsBlobLen3:                 case edsBlobLen4:                     l = code - edsBlobLen1;                     blobId = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         blobId = (blobId << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeBlob;                     break;                  case edsScaledCount1:                     {                         // For some reason C++ EncodedStream expects the encoded                         // length to be length+1.                          length = (source[offset++] & 0xff) - 1;                         scale = (sbyte)source[offset++];                         type = edsTypeBigInt;                         bytes = new byte[length];                         Array.Copy(source' offset' bytes' 0' length);                         offset += length;                         int sign = ((bytes[0] & 0x80) > 0) ? -1 : 1;                          if (sign == -1)                         {                             bytes[0] &= 0x7f;                         }                          BigInteger bi = new BigInteger(bytes);                         bigDecimal = Decimal.Parse(bi.ToString());                     }                     break;                  case edsScaledCount2:                     {                         // For some reason C++ EncodedStream expects the encoded                         // length to be length+1.                          scale = (sbyte)source[offset++];                         sbyte sign = (sbyte)source[offset++];                         length = (source[offset++] & 0xff); // in bytes                         type = edsTypeBigInt;                         bytes = new byte[length];                         Array.Copy(source' offset' bytes' 0' length);                         offset += length;                          if (sign == -1)                             bytes[0] &= 0x7f;                         else                             sign = 1;                          BigInteger bi = new BigInteger(bytes);                         if (sign == -1)                             bi = -bi;                         bigDecimal = ScaleDecimal(Decimal.Parse(bi.ToString())' scale);                     }                     break;                  case edsUUID:                     {                         byte[] buff = new byte[16];                          for (int n = 0; n < 16; ++n)                         {                             buff[n] = (byte)(source[offset++] & 0xff);                         }                          uuid = new Guid(buff);                         type = edsTypeUUID;                     }                     break;                  default:                     type = edsTypeUnknown;                     break;             }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,decode,The following statement contains a magic number: switch (code)             {                 case edsNull:                     type = edsTypeNull;                     break;                  case edsTrue:                     type = edsTypeBoolean;                     @bool = true;                     break;                  case edsFalse:                     type = edsTypeBoolean;                     @bool = false;                     break;                  case edsIntMinus10:                 case edsIntMinus9:                 case edsIntMinus8:                 case edsIntMinus7:                 case edsIntMinus6:                 case edsIntMinus5:                 case edsIntMinus4:                 case edsIntMinus3:                 case edsIntMinus2:                 case edsIntMinus1:                 case edsInt0:                 case edsInt1:                 case edsInt2:                 case edsInt3:                 case edsInt4:                 case edsInt5:                 case edsInt6:                 case edsInt7:                 case edsInt8:                 case edsInt9:                 case edsInt10:                 case edsInt11:                 case edsInt12:                 case edsInt13:                 case edsInt14:                 case edsInt15:                 case edsInt16:                 case edsInt17:                 case edsInt18:                 case edsInt19:                 case edsInt20:                 case edsInt21:                 case edsInt22:                 case edsInt23:                 case edsInt24:                 case edsInt25:                 case edsInt26:                 case edsInt27:                 case edsInt28:                 case edsInt29:                 case edsInt30:                 case edsInt31:                     integer32 = code - edsInt0;                     scale = 0;                     type = edsTypeInt32;                     break;                  case edsIntLen1:                     type = edsTypeInt32;                     scale = 0;                     integer32 = (sbyte)source[offset++];                     break;                  case edsIntLen2:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset] << 8) | (source[offset + 1] & 0xff);                     offset += 2;                     break;                  case edsIntLen3:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset]) << 16 | (source[offset + 1] & 0xff) << 8 | (source[offset + 2] & 0xff);                     offset += 3;                     break;                  case edsIntLen4:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset]) << 24 | (source[offset + 1] & 0xff) << 16 | (source[offset + 2] & 0xff) << 8 | (source[offset + 3] & 0xff);                     offset += 4;                     break;                  case edsIntLen5:                 case edsIntLen6:                 case edsIntLen7:                 case edsIntLen8:                     l = code - edsIntLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeInt64;                     break;                  case edsScaledLen0:                     scale = (sbyte)source[offset++];                     integer64 = 0;                     type = edsTypeScaled;                     break;                  case edsScaledLen1:                 case edsScaledLen2:                 case edsScaledLen3:                 case edsScaledLen4:                 case edsScaledLen5:                 case edsScaledLen6:                 case edsScaledLen7:                 case edsScaledLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaled;                     break;                  case edsUtf8Len0:                 case edsUtf8Len1:                 case edsUtf8Len2:                 case edsUtf8Len3:                 case edsUtf8Len4:                 case edsUtf8Len5:                 case edsUtf8Len6:                 case edsUtf8Len7:                 case edsUtf8Len8:                 case edsUtf8Len9:                 case edsUtf8Len10:                 case edsUtf8Len11:                 case edsUtf8Len12:                 case edsUtf8Len13:                 case edsUtf8Len14:                 case edsUtf8Len15:                 case edsUtf8Len16:                 case edsUtf8Len17:                 case edsUtf8Len18:                 case edsUtf8Len19:                 case edsUtf8Len20:                 case edsUtf8Len21:                 case edsUtf8Len22:                 case edsUtf8Len23:                 case edsUtf8Len24:                 case edsUtf8Len25:                 case edsUtf8Len26:                 case edsUtf8Len27:                 case edsUtf8Len28:                 case edsUtf8Len29:                 case edsUtf8Len30:                 case edsUtf8Len31:                 case edsUtf8Len32:                 case edsUtf8Len33:                 case edsUtf8Len34:                 case edsUtf8Len35:                 case edsUtf8Len36:                 case edsUtf8Len37:                 case edsUtf8Len38:                 case edsUtf8Len39:                     l = code - edsUtf8Len0;                     @string = getString(source' offset' l);                     offset += l;                     type = edsTypeUtf8;                     break;                  case edsUtf8Count1:                 case edsUtf8Count2:                 case edsUtf8Count3:                 case edsUtf8Count4:                     count = code - edsUtf8Count1;                     int length = source[offset++] & 0xff;                      for (int n = 0; n < count; ++n)                     {                         length = length << 8 | (source[offset++] & 0xff);                     }                      @string = getString(source' offset' length);                     offset += length;                     type = edsTypeUtf8;                     break;                  case edsOpaqueLen0:                 case edsOpaqueLen1:                 case edsOpaqueLen2:                 case edsOpaqueLen3:                 case edsOpaqueLen4:                 case edsOpaqueLen5:                 case edsOpaqueLen6:                 case edsOpaqueLen7:                 case edsOpaqueLen8:                 case edsOpaqueLen9:                 case edsOpaqueLen10:                 case edsOpaqueLen11:                 case edsOpaqueLen12:                 case edsOpaqueLen13:                 case edsOpaqueLen14:                 case edsOpaqueLen15:                 case edsOpaqueLen16:                 case edsOpaqueLen17:                 case edsOpaqueLen18:                 case edsOpaqueLen19:                 case edsOpaqueLen20:                 case edsOpaqueLen21:                 case edsOpaqueLen22:                 case edsOpaqueLen23:                 case edsOpaqueLen24:                 case edsOpaqueLen25:                 case edsOpaqueLen26:                 case edsOpaqueLen27:                 case edsOpaqueLen28:                 case edsOpaqueLen29:                 case edsOpaqueLen30:                 case edsOpaqueLen31:                 case edsOpaqueLen32:                 case edsOpaqueLen33:                 case edsOpaqueLen34:                 case edsOpaqueLen35:                 case edsOpaqueLen36:                 case edsOpaqueLen37:                 case edsOpaqueLen38:                 case edsOpaqueLen39:                     l = code - edsOpaqueLen0;                     bytes = new byte[l];                     Array.Copy(source' offset' bytes' 0' l);                     offset += l;                     type = edsTypeOpaque;                     break;                  case edsOpaqueCount1:                 case edsOpaqueCount2:                 case edsOpaqueCount3:                 case edsOpaqueCount4:                     count = code - edsOpaqueCount1 + 1;                     l = source[offset++] & 0xff;                      for (int n = 1; n < count; ++n)                     {                         l = l << 8 | (source[offset++] & 0xff);                     }                      bytes = new byte[l];                     Array.Copy(source' offset' bytes' 0' l);                     offset += l;                     type = edsTypeOpaque;                     break;                  case edsDoubleLen0:                 case edsDoubleLen1:                 case edsDoubleLen2:                 case edsDoubleLen3:                 case edsDoubleLen4:                 case edsDoubleLen5:                 case edsDoubleLen6:                 case edsDoubleLen7:                 case edsDoubleLen8:                     count = code - edsDoubleLen0;                     long lvalue = 0;                      for (int n = 0; n < count; ++n)                     {                         lvalue = (lvalue << 8) | (source[offset++] & 0xff);                     }                      lvalue <<= (8 - count) * 8;                     dbl = BitConverter.Int64BitsToDouble(lvalue);                     type = edsTypeDouble;                     break;                  case edsTimeLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeTime;                     break;                  case edsTimeLen1:                 case edsTimeLen2:                 case edsTimeLen3:                 case edsTimeLen4:                     l = code - edsTimeLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeTime;                     break;                  case edsMilliSecLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeMilliseconds;                     break;                  case edsMilliSecLen1:                 case edsMilliSecLen2:                 case edsMilliSecLen3:                 case edsMilliSecLen4:                 case edsMilliSecLen5:                 case edsMilliSecLen6:                 case edsMilliSecLen7:                 case edsMilliSecLen8:                     l = code - edsMilliSecLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeMilliseconds;                     break;                  case edsNanoSecLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeNanoseconds;                     break;                  case edsNanoSecLen1:                 case edsNanoSecLen2:                 case edsNanoSecLen3:                 case edsNanoSecLen4:                 case edsNanoSecLen5:                 case edsNanoSecLen6:                 case edsNanoSecLen7:                 case edsNanoSecLen8:                     l = code - edsNanoSecLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeNanoseconds;                     break;                  //                 // 09/2012 Added support for new scaled date/times encoding. These replace the old encoding                 // edsTimeLen' edsMilliSecLen and edsNanoSecLen.                 //                  case edsScaledTimeLen1:                 case edsScaledTimeLen2:                 case edsScaledTimeLen3:                 case edsScaledTimeLen4:                 case edsScaledTimeLen5:                 case edsScaledTimeLen6:                 case edsScaledTimeLen7:                 case edsScaledTimeLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledTimeLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledTime;                     break;                  case edsScaledDateLen1:                 case edsScaledDateLen2:                 case edsScaledDateLen3:                 case edsScaledDateLen4:                 case edsScaledDateLen5:                 case edsScaledDateLen6:                 case edsScaledDateLen7:                 case edsScaledDateLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledDateLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledDate;                     break;                  case edsScaledTimestampLen1:                 case edsScaledTimestampLen2:                 case edsScaledTimestampLen3:                 case edsScaledTimestampLen4:                 case edsScaledTimestampLen5:                 case edsScaledTimestampLen6:                 case edsScaledTimestampLen7:                 case edsScaledTimestampLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledTimestampLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledTimestamp;                     break;                  case edsClobLen0:                     blobId = 0;                     type = edsTypeClob;                     break;                  case edsClobLen1:                 case edsClobLen2:                 case edsClobLen3:                 case edsClobLen4:                     l = code - edsClobLen1;                     blobId = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         blobId = (blobId << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeClob;                     break;                  case edsBlobLen0:                     blobId = 0;                     type = edsTypeBlob;                     break;                  case edsBlobLen1:                 case edsBlobLen2:                 case edsBlobLen3:                 case edsBlobLen4:                     l = code - edsBlobLen1;                     blobId = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         blobId = (blobId << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeBlob;                     break;                  case edsScaledCount1:                     {                         // For some reason C++ EncodedStream expects the encoded                         // length to be length+1.                          length = (source[offset++] & 0xff) - 1;                         scale = (sbyte)source[offset++];                         type = edsTypeBigInt;                         bytes = new byte[length];                         Array.Copy(source' offset' bytes' 0' length);                         offset += length;                         int sign = ((bytes[0] & 0x80) > 0) ? -1 : 1;                          if (sign == -1)                         {                             bytes[0] &= 0x7f;                         }                          BigInteger bi = new BigInteger(bytes);                         bigDecimal = Decimal.Parse(bi.ToString());                     }                     break;                  case edsScaledCount2:                     {                         // For some reason C++ EncodedStream expects the encoded                         // length to be length+1.                          scale = (sbyte)source[offset++];                         sbyte sign = (sbyte)source[offset++];                         length = (source[offset++] & 0xff); // in bytes                         type = edsTypeBigInt;                         bytes = new byte[length];                         Array.Copy(source' offset' bytes' 0' length);                         offset += length;                          if (sign == -1)                             bytes[0] &= 0x7f;                         else                             sign = 1;                          BigInteger bi = new BigInteger(bytes);                         if (sign == -1)                             bi = -bi;                         bigDecimal = ScaleDecimal(Decimal.Parse(bi.ToString())' scale);                     }                     break;                  case edsUUID:                     {                         byte[] buff = new byte[16];                          for (int n = 0; n < 16; ++n)                         {                             buff[n] = (byte)(source[offset++] & 0xff);                         }                          uuid = new Guid(buff);                         type = edsTypeUUID;                     }                     break;                  default:                     type = edsTypeUnknown;                     break;             }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,decode,The following statement contains a magic number: switch (code)             {                 case edsNull:                     type = edsTypeNull;                     break;                  case edsTrue:                     type = edsTypeBoolean;                     @bool = true;                     break;                  case edsFalse:                     type = edsTypeBoolean;                     @bool = false;                     break;                  case edsIntMinus10:                 case edsIntMinus9:                 case edsIntMinus8:                 case edsIntMinus7:                 case edsIntMinus6:                 case edsIntMinus5:                 case edsIntMinus4:                 case edsIntMinus3:                 case edsIntMinus2:                 case edsIntMinus1:                 case edsInt0:                 case edsInt1:                 case edsInt2:                 case edsInt3:                 case edsInt4:                 case edsInt5:                 case edsInt6:                 case edsInt7:                 case edsInt8:                 case edsInt9:                 case edsInt10:                 case edsInt11:                 case edsInt12:                 case edsInt13:                 case edsInt14:                 case edsInt15:                 case edsInt16:                 case edsInt17:                 case edsInt18:                 case edsInt19:                 case edsInt20:                 case edsInt21:                 case edsInt22:                 case edsInt23:                 case edsInt24:                 case edsInt25:                 case edsInt26:                 case edsInt27:                 case edsInt28:                 case edsInt29:                 case edsInt30:                 case edsInt31:                     integer32 = code - edsInt0;                     scale = 0;                     type = edsTypeInt32;                     break;                  case edsIntLen1:                     type = edsTypeInt32;                     scale = 0;                     integer32 = (sbyte)source[offset++];                     break;                  case edsIntLen2:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset] << 8) | (source[offset + 1] & 0xff);                     offset += 2;                     break;                  case edsIntLen3:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset]) << 16 | (source[offset + 1] & 0xff) << 8 | (source[offset + 2] & 0xff);                     offset += 3;                     break;                  case edsIntLen4:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset]) << 24 | (source[offset + 1] & 0xff) << 16 | (source[offset + 2] & 0xff) << 8 | (source[offset + 3] & 0xff);                     offset += 4;                     break;                  case edsIntLen5:                 case edsIntLen6:                 case edsIntLen7:                 case edsIntLen8:                     l = code - edsIntLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeInt64;                     break;                  case edsScaledLen0:                     scale = (sbyte)source[offset++];                     integer64 = 0;                     type = edsTypeScaled;                     break;                  case edsScaledLen1:                 case edsScaledLen2:                 case edsScaledLen3:                 case edsScaledLen4:                 case edsScaledLen5:                 case edsScaledLen6:                 case edsScaledLen7:                 case edsScaledLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaled;                     break;                  case edsUtf8Len0:                 case edsUtf8Len1:                 case edsUtf8Len2:                 case edsUtf8Len3:                 case edsUtf8Len4:                 case edsUtf8Len5:                 case edsUtf8Len6:                 case edsUtf8Len7:                 case edsUtf8Len8:                 case edsUtf8Len9:                 case edsUtf8Len10:                 case edsUtf8Len11:                 case edsUtf8Len12:                 case edsUtf8Len13:                 case edsUtf8Len14:                 case edsUtf8Len15:                 case edsUtf8Len16:                 case edsUtf8Len17:                 case edsUtf8Len18:                 case edsUtf8Len19:                 case edsUtf8Len20:                 case edsUtf8Len21:                 case edsUtf8Len22:                 case edsUtf8Len23:                 case edsUtf8Len24:                 case edsUtf8Len25:                 case edsUtf8Len26:                 case edsUtf8Len27:                 case edsUtf8Len28:                 case edsUtf8Len29:                 case edsUtf8Len30:                 case edsUtf8Len31:                 case edsUtf8Len32:                 case edsUtf8Len33:                 case edsUtf8Len34:                 case edsUtf8Len35:                 case edsUtf8Len36:                 case edsUtf8Len37:                 case edsUtf8Len38:                 case edsUtf8Len39:                     l = code - edsUtf8Len0;                     @string = getString(source' offset' l);                     offset += l;                     type = edsTypeUtf8;                     break;                  case edsUtf8Count1:                 case edsUtf8Count2:                 case edsUtf8Count3:                 case edsUtf8Count4:                     count = code - edsUtf8Count1;                     int length = source[offset++] & 0xff;                      for (int n = 0; n < count; ++n)                     {                         length = length << 8 | (source[offset++] & 0xff);                     }                      @string = getString(source' offset' length);                     offset += length;                     type = edsTypeUtf8;                     break;                  case edsOpaqueLen0:                 case edsOpaqueLen1:                 case edsOpaqueLen2:                 case edsOpaqueLen3:                 case edsOpaqueLen4:                 case edsOpaqueLen5:                 case edsOpaqueLen6:                 case edsOpaqueLen7:                 case edsOpaqueLen8:                 case edsOpaqueLen9:                 case edsOpaqueLen10:                 case edsOpaqueLen11:                 case edsOpaqueLen12:                 case edsOpaqueLen13:                 case edsOpaqueLen14:                 case edsOpaqueLen15:                 case edsOpaqueLen16:                 case edsOpaqueLen17:                 case edsOpaqueLen18:                 case edsOpaqueLen19:                 case edsOpaqueLen20:                 case edsOpaqueLen21:                 case edsOpaqueLen22:                 case edsOpaqueLen23:                 case edsOpaqueLen24:                 case edsOpaqueLen25:                 case edsOpaqueLen26:                 case edsOpaqueLen27:                 case edsOpaqueLen28:                 case edsOpaqueLen29:                 case edsOpaqueLen30:                 case edsOpaqueLen31:                 case edsOpaqueLen32:                 case edsOpaqueLen33:                 case edsOpaqueLen34:                 case edsOpaqueLen35:                 case edsOpaqueLen36:                 case edsOpaqueLen37:                 case edsOpaqueLen38:                 case edsOpaqueLen39:                     l = code - edsOpaqueLen0;                     bytes = new byte[l];                     Array.Copy(source' offset' bytes' 0' l);                     offset += l;                     type = edsTypeOpaque;                     break;                  case edsOpaqueCount1:                 case edsOpaqueCount2:                 case edsOpaqueCount3:                 case edsOpaqueCount4:                     count = code - edsOpaqueCount1 + 1;                     l = source[offset++] & 0xff;                      for (int n = 1; n < count; ++n)                     {                         l = l << 8 | (source[offset++] & 0xff);                     }                      bytes = new byte[l];                     Array.Copy(source' offset' bytes' 0' l);                     offset += l;                     type = edsTypeOpaque;                     break;                  case edsDoubleLen0:                 case edsDoubleLen1:                 case edsDoubleLen2:                 case edsDoubleLen3:                 case edsDoubleLen4:                 case edsDoubleLen5:                 case edsDoubleLen6:                 case edsDoubleLen7:                 case edsDoubleLen8:                     count = code - edsDoubleLen0;                     long lvalue = 0;                      for (int n = 0; n < count; ++n)                     {                         lvalue = (lvalue << 8) | (source[offset++] & 0xff);                     }                      lvalue <<= (8 - count) * 8;                     dbl = BitConverter.Int64BitsToDouble(lvalue);                     type = edsTypeDouble;                     break;                  case edsTimeLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeTime;                     break;                  case edsTimeLen1:                 case edsTimeLen2:                 case edsTimeLen3:                 case edsTimeLen4:                     l = code - edsTimeLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeTime;                     break;                  case edsMilliSecLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeMilliseconds;                     break;                  case edsMilliSecLen1:                 case edsMilliSecLen2:                 case edsMilliSecLen3:                 case edsMilliSecLen4:                 case edsMilliSecLen5:                 case edsMilliSecLen6:                 case edsMilliSecLen7:                 case edsMilliSecLen8:                     l = code - edsMilliSecLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeMilliseconds;                     break;                  case edsNanoSecLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeNanoseconds;                     break;                  case edsNanoSecLen1:                 case edsNanoSecLen2:                 case edsNanoSecLen3:                 case edsNanoSecLen4:                 case edsNanoSecLen5:                 case edsNanoSecLen6:                 case edsNanoSecLen7:                 case edsNanoSecLen8:                     l = code - edsNanoSecLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeNanoseconds;                     break;                  //                 // 09/2012 Added support for new scaled date/times encoding. These replace the old encoding                 // edsTimeLen' edsMilliSecLen and edsNanoSecLen.                 //                  case edsScaledTimeLen1:                 case edsScaledTimeLen2:                 case edsScaledTimeLen3:                 case edsScaledTimeLen4:                 case edsScaledTimeLen5:                 case edsScaledTimeLen6:                 case edsScaledTimeLen7:                 case edsScaledTimeLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledTimeLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledTime;                     break;                  case edsScaledDateLen1:                 case edsScaledDateLen2:                 case edsScaledDateLen3:                 case edsScaledDateLen4:                 case edsScaledDateLen5:                 case edsScaledDateLen6:                 case edsScaledDateLen7:                 case edsScaledDateLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledDateLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledDate;                     break;                  case edsScaledTimestampLen1:                 case edsScaledTimestampLen2:                 case edsScaledTimestampLen3:                 case edsScaledTimestampLen4:                 case edsScaledTimestampLen5:                 case edsScaledTimestampLen6:                 case edsScaledTimestampLen7:                 case edsScaledTimestampLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledTimestampLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledTimestamp;                     break;                  case edsClobLen0:                     blobId = 0;                     type = edsTypeClob;                     break;                  case edsClobLen1:                 case edsClobLen2:                 case edsClobLen3:                 case edsClobLen4:                     l = code - edsClobLen1;                     blobId = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         blobId = (blobId << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeClob;                     break;                  case edsBlobLen0:                     blobId = 0;                     type = edsTypeBlob;                     break;                  case edsBlobLen1:                 case edsBlobLen2:                 case edsBlobLen3:                 case edsBlobLen4:                     l = code - edsBlobLen1;                     blobId = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         blobId = (blobId << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeBlob;                     break;                  case edsScaledCount1:                     {                         // For some reason C++ EncodedStream expects the encoded                         // length to be length+1.                          length = (source[offset++] & 0xff) - 1;                         scale = (sbyte)source[offset++];                         type = edsTypeBigInt;                         bytes = new byte[length];                         Array.Copy(source' offset' bytes' 0' length);                         offset += length;                         int sign = ((bytes[0] & 0x80) > 0) ? -1 : 1;                          if (sign == -1)                         {                             bytes[0] &= 0x7f;                         }                          BigInteger bi = new BigInteger(bytes);                         bigDecimal = Decimal.Parse(bi.ToString());                     }                     break;                  case edsScaledCount2:                     {                         // For some reason C++ EncodedStream expects the encoded                         // length to be length+1.                          scale = (sbyte)source[offset++];                         sbyte sign = (sbyte)source[offset++];                         length = (source[offset++] & 0xff); // in bytes                         type = edsTypeBigInt;                         bytes = new byte[length];                         Array.Copy(source' offset' bytes' 0' length);                         offset += length;                          if (sign == -1)                             bytes[0] &= 0x7f;                         else                             sign = 1;                          BigInteger bi = new BigInteger(bytes);                         if (sign == -1)                             bi = -bi;                         bigDecimal = ScaleDecimal(Decimal.Parse(bi.ToString())' scale);                     }                     break;                  case edsUUID:                     {                         byte[] buff = new byte[16];                          for (int n = 0; n < 16; ++n)                         {                             buff[n] = (byte)(source[offset++] & 0xff);                         }                          uuid = new Guid(buff);                         type = edsTypeUUID;                     }                     break;                  default:                     type = edsTypeUnknown;                     break;             }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,decode,The following statement contains a magic number: switch (code)             {                 case edsNull:                     type = edsTypeNull;                     break;                  case edsTrue:                     type = edsTypeBoolean;                     @bool = true;                     break;                  case edsFalse:                     type = edsTypeBoolean;                     @bool = false;                     break;                  case edsIntMinus10:                 case edsIntMinus9:                 case edsIntMinus8:                 case edsIntMinus7:                 case edsIntMinus6:                 case edsIntMinus5:                 case edsIntMinus4:                 case edsIntMinus3:                 case edsIntMinus2:                 case edsIntMinus1:                 case edsInt0:                 case edsInt1:                 case edsInt2:                 case edsInt3:                 case edsInt4:                 case edsInt5:                 case edsInt6:                 case edsInt7:                 case edsInt8:                 case edsInt9:                 case edsInt10:                 case edsInt11:                 case edsInt12:                 case edsInt13:                 case edsInt14:                 case edsInt15:                 case edsInt16:                 case edsInt17:                 case edsInt18:                 case edsInt19:                 case edsInt20:                 case edsInt21:                 case edsInt22:                 case edsInt23:                 case edsInt24:                 case edsInt25:                 case edsInt26:                 case edsInt27:                 case edsInt28:                 case edsInt29:                 case edsInt30:                 case edsInt31:                     integer32 = code - edsInt0;                     scale = 0;                     type = edsTypeInt32;                     break;                  case edsIntLen1:                     type = edsTypeInt32;                     scale = 0;                     integer32 = (sbyte)source[offset++];                     break;                  case edsIntLen2:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset] << 8) | (source[offset + 1] & 0xff);                     offset += 2;                     break;                  case edsIntLen3:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset]) << 16 | (source[offset + 1] & 0xff) << 8 | (source[offset + 2] & 0xff);                     offset += 3;                     break;                  case edsIntLen4:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset]) << 24 | (source[offset + 1] & 0xff) << 16 | (source[offset + 2] & 0xff) << 8 | (source[offset + 3] & 0xff);                     offset += 4;                     break;                  case edsIntLen5:                 case edsIntLen6:                 case edsIntLen7:                 case edsIntLen8:                     l = code - edsIntLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeInt64;                     break;                  case edsScaledLen0:                     scale = (sbyte)source[offset++];                     integer64 = 0;                     type = edsTypeScaled;                     break;                  case edsScaledLen1:                 case edsScaledLen2:                 case edsScaledLen3:                 case edsScaledLen4:                 case edsScaledLen5:                 case edsScaledLen6:                 case edsScaledLen7:                 case edsScaledLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaled;                     break;                  case edsUtf8Len0:                 case edsUtf8Len1:                 case edsUtf8Len2:                 case edsUtf8Len3:                 case edsUtf8Len4:                 case edsUtf8Len5:                 case edsUtf8Len6:                 case edsUtf8Len7:                 case edsUtf8Len8:                 case edsUtf8Len9:                 case edsUtf8Len10:                 case edsUtf8Len11:                 case edsUtf8Len12:                 case edsUtf8Len13:                 case edsUtf8Len14:                 case edsUtf8Len15:                 case edsUtf8Len16:                 case edsUtf8Len17:                 case edsUtf8Len18:                 case edsUtf8Len19:                 case edsUtf8Len20:                 case edsUtf8Len21:                 case edsUtf8Len22:                 case edsUtf8Len23:                 case edsUtf8Len24:                 case edsUtf8Len25:                 case edsUtf8Len26:                 case edsUtf8Len27:                 case edsUtf8Len28:                 case edsUtf8Len29:                 case edsUtf8Len30:                 case edsUtf8Len31:                 case edsUtf8Len32:                 case edsUtf8Len33:                 case edsUtf8Len34:                 case edsUtf8Len35:                 case edsUtf8Len36:                 case edsUtf8Len37:                 case edsUtf8Len38:                 case edsUtf8Len39:                     l = code - edsUtf8Len0;                     @string = getString(source' offset' l);                     offset += l;                     type = edsTypeUtf8;                     break;                  case edsUtf8Count1:                 case edsUtf8Count2:                 case edsUtf8Count3:                 case edsUtf8Count4:                     count = code - edsUtf8Count1;                     int length = source[offset++] & 0xff;                      for (int n = 0; n < count; ++n)                     {                         length = length << 8 | (source[offset++] & 0xff);                     }                      @string = getString(source' offset' length);                     offset += length;                     type = edsTypeUtf8;                     break;                  case edsOpaqueLen0:                 case edsOpaqueLen1:                 case edsOpaqueLen2:                 case edsOpaqueLen3:                 case edsOpaqueLen4:                 case edsOpaqueLen5:                 case edsOpaqueLen6:                 case edsOpaqueLen7:                 case edsOpaqueLen8:                 case edsOpaqueLen9:                 case edsOpaqueLen10:                 case edsOpaqueLen11:                 case edsOpaqueLen12:                 case edsOpaqueLen13:                 case edsOpaqueLen14:                 case edsOpaqueLen15:                 case edsOpaqueLen16:                 case edsOpaqueLen17:                 case edsOpaqueLen18:                 case edsOpaqueLen19:                 case edsOpaqueLen20:                 case edsOpaqueLen21:                 case edsOpaqueLen22:                 case edsOpaqueLen23:                 case edsOpaqueLen24:                 case edsOpaqueLen25:                 case edsOpaqueLen26:                 case edsOpaqueLen27:                 case edsOpaqueLen28:                 case edsOpaqueLen29:                 case edsOpaqueLen30:                 case edsOpaqueLen31:                 case edsOpaqueLen32:                 case edsOpaqueLen33:                 case edsOpaqueLen34:                 case edsOpaqueLen35:                 case edsOpaqueLen36:                 case edsOpaqueLen37:                 case edsOpaqueLen38:                 case edsOpaqueLen39:                     l = code - edsOpaqueLen0;                     bytes = new byte[l];                     Array.Copy(source' offset' bytes' 0' l);                     offset += l;                     type = edsTypeOpaque;                     break;                  case edsOpaqueCount1:                 case edsOpaqueCount2:                 case edsOpaqueCount3:                 case edsOpaqueCount4:                     count = code - edsOpaqueCount1 + 1;                     l = source[offset++] & 0xff;                      for (int n = 1; n < count; ++n)                     {                         l = l << 8 | (source[offset++] & 0xff);                     }                      bytes = new byte[l];                     Array.Copy(source' offset' bytes' 0' l);                     offset += l;                     type = edsTypeOpaque;                     break;                  case edsDoubleLen0:                 case edsDoubleLen1:                 case edsDoubleLen2:                 case edsDoubleLen3:                 case edsDoubleLen4:                 case edsDoubleLen5:                 case edsDoubleLen6:                 case edsDoubleLen7:                 case edsDoubleLen8:                     count = code - edsDoubleLen0;                     long lvalue = 0;                      for (int n = 0; n < count; ++n)                     {                         lvalue = (lvalue << 8) | (source[offset++] & 0xff);                     }                      lvalue <<= (8 - count) * 8;                     dbl = BitConverter.Int64BitsToDouble(lvalue);                     type = edsTypeDouble;                     break;                  case edsTimeLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeTime;                     break;                  case edsTimeLen1:                 case edsTimeLen2:                 case edsTimeLen3:                 case edsTimeLen4:                     l = code - edsTimeLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeTime;                     break;                  case edsMilliSecLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeMilliseconds;                     break;                  case edsMilliSecLen1:                 case edsMilliSecLen2:                 case edsMilliSecLen3:                 case edsMilliSecLen4:                 case edsMilliSecLen5:                 case edsMilliSecLen6:                 case edsMilliSecLen7:                 case edsMilliSecLen8:                     l = code - edsMilliSecLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeMilliseconds;                     break;                  case edsNanoSecLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeNanoseconds;                     break;                  case edsNanoSecLen1:                 case edsNanoSecLen2:                 case edsNanoSecLen3:                 case edsNanoSecLen4:                 case edsNanoSecLen5:                 case edsNanoSecLen6:                 case edsNanoSecLen7:                 case edsNanoSecLen8:                     l = code - edsNanoSecLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeNanoseconds;                     break;                  //                 // 09/2012 Added support for new scaled date/times encoding. These replace the old encoding                 // edsTimeLen' edsMilliSecLen and edsNanoSecLen.                 //                  case edsScaledTimeLen1:                 case edsScaledTimeLen2:                 case edsScaledTimeLen3:                 case edsScaledTimeLen4:                 case edsScaledTimeLen5:                 case edsScaledTimeLen6:                 case edsScaledTimeLen7:                 case edsScaledTimeLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledTimeLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledTime;                     break;                  case edsScaledDateLen1:                 case edsScaledDateLen2:                 case edsScaledDateLen3:                 case edsScaledDateLen4:                 case edsScaledDateLen5:                 case edsScaledDateLen6:                 case edsScaledDateLen7:                 case edsScaledDateLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledDateLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledDate;                     break;                  case edsScaledTimestampLen1:                 case edsScaledTimestampLen2:                 case edsScaledTimestampLen3:                 case edsScaledTimestampLen4:                 case edsScaledTimestampLen5:                 case edsScaledTimestampLen6:                 case edsScaledTimestampLen7:                 case edsScaledTimestampLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledTimestampLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledTimestamp;                     break;                  case edsClobLen0:                     blobId = 0;                     type = edsTypeClob;                     break;                  case edsClobLen1:                 case edsClobLen2:                 case edsClobLen3:                 case edsClobLen4:                     l = code - edsClobLen1;                     blobId = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         blobId = (blobId << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeClob;                     break;                  case edsBlobLen0:                     blobId = 0;                     type = edsTypeBlob;                     break;                  case edsBlobLen1:                 case edsBlobLen2:                 case edsBlobLen3:                 case edsBlobLen4:                     l = code - edsBlobLen1;                     blobId = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         blobId = (blobId << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeBlob;                     break;                  case edsScaledCount1:                     {                         // For some reason C++ EncodedStream expects the encoded                         // length to be length+1.                          length = (source[offset++] & 0xff) - 1;                         scale = (sbyte)source[offset++];                         type = edsTypeBigInt;                         bytes = new byte[length];                         Array.Copy(source' offset' bytes' 0' length);                         offset += length;                         int sign = ((bytes[0] & 0x80) > 0) ? -1 : 1;                          if (sign == -1)                         {                             bytes[0] &= 0x7f;                         }                          BigInteger bi = new BigInteger(bytes);                         bigDecimal = Decimal.Parse(bi.ToString());                     }                     break;                  case edsScaledCount2:                     {                         // For some reason C++ EncodedStream expects the encoded                         // length to be length+1.                          scale = (sbyte)source[offset++];                         sbyte sign = (sbyte)source[offset++];                         length = (source[offset++] & 0xff); // in bytes                         type = edsTypeBigInt;                         bytes = new byte[length];                         Array.Copy(source' offset' bytes' 0' length);                         offset += length;                          if (sign == -1)                             bytes[0] &= 0x7f;                         else                             sign = 1;                          BigInteger bi = new BigInteger(bytes);                         if (sign == -1)                             bi = -bi;                         bigDecimal = ScaleDecimal(Decimal.Parse(bi.ToString())' scale);                     }                     break;                  case edsUUID:                     {                         byte[] buff = new byte[16];                          for (int n = 0; n < 16; ++n)                         {                             buff[n] = (byte)(source[offset++] & 0xff);                         }                          uuid = new Guid(buff);                         type = edsTypeUUID;                     }                     break;                  default:                     type = edsTypeUnknown;                     break;             }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,decode,The following statement contains a magic number: switch (code)             {                 case edsNull:                     type = edsTypeNull;                     break;                  case edsTrue:                     type = edsTypeBoolean;                     @bool = true;                     break;                  case edsFalse:                     type = edsTypeBoolean;                     @bool = false;                     break;                  case edsIntMinus10:                 case edsIntMinus9:                 case edsIntMinus8:                 case edsIntMinus7:                 case edsIntMinus6:                 case edsIntMinus5:                 case edsIntMinus4:                 case edsIntMinus3:                 case edsIntMinus2:                 case edsIntMinus1:                 case edsInt0:                 case edsInt1:                 case edsInt2:                 case edsInt3:                 case edsInt4:                 case edsInt5:                 case edsInt6:                 case edsInt7:                 case edsInt8:                 case edsInt9:                 case edsInt10:                 case edsInt11:                 case edsInt12:                 case edsInt13:                 case edsInt14:                 case edsInt15:                 case edsInt16:                 case edsInt17:                 case edsInt18:                 case edsInt19:                 case edsInt20:                 case edsInt21:                 case edsInt22:                 case edsInt23:                 case edsInt24:                 case edsInt25:                 case edsInt26:                 case edsInt27:                 case edsInt28:                 case edsInt29:                 case edsInt30:                 case edsInt31:                     integer32 = code - edsInt0;                     scale = 0;                     type = edsTypeInt32;                     break;                  case edsIntLen1:                     type = edsTypeInt32;                     scale = 0;                     integer32 = (sbyte)source[offset++];                     break;                  case edsIntLen2:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset] << 8) | (source[offset + 1] & 0xff);                     offset += 2;                     break;                  case edsIntLen3:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset]) << 16 | (source[offset + 1] & 0xff) << 8 | (source[offset + 2] & 0xff);                     offset += 3;                     break;                  case edsIntLen4:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset]) << 24 | (source[offset + 1] & 0xff) << 16 | (source[offset + 2] & 0xff) << 8 | (source[offset + 3] & 0xff);                     offset += 4;                     break;                  case edsIntLen5:                 case edsIntLen6:                 case edsIntLen7:                 case edsIntLen8:                     l = code - edsIntLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeInt64;                     break;                  case edsScaledLen0:                     scale = (sbyte)source[offset++];                     integer64 = 0;                     type = edsTypeScaled;                     break;                  case edsScaledLen1:                 case edsScaledLen2:                 case edsScaledLen3:                 case edsScaledLen4:                 case edsScaledLen5:                 case edsScaledLen6:                 case edsScaledLen7:                 case edsScaledLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaled;                     break;                  case edsUtf8Len0:                 case edsUtf8Len1:                 case edsUtf8Len2:                 case edsUtf8Len3:                 case edsUtf8Len4:                 case edsUtf8Len5:                 case edsUtf8Len6:                 case edsUtf8Len7:                 case edsUtf8Len8:                 case edsUtf8Len9:                 case edsUtf8Len10:                 case edsUtf8Len11:                 case edsUtf8Len12:                 case edsUtf8Len13:                 case edsUtf8Len14:                 case edsUtf8Len15:                 case edsUtf8Len16:                 case edsUtf8Len17:                 case edsUtf8Len18:                 case edsUtf8Len19:                 case edsUtf8Len20:                 case edsUtf8Len21:                 case edsUtf8Len22:                 case edsUtf8Len23:                 case edsUtf8Len24:                 case edsUtf8Len25:                 case edsUtf8Len26:                 case edsUtf8Len27:                 case edsUtf8Len28:                 case edsUtf8Len29:                 case edsUtf8Len30:                 case edsUtf8Len31:                 case edsUtf8Len32:                 case edsUtf8Len33:                 case edsUtf8Len34:                 case edsUtf8Len35:                 case edsUtf8Len36:                 case edsUtf8Len37:                 case edsUtf8Len38:                 case edsUtf8Len39:                     l = code - edsUtf8Len0;                     @string = getString(source' offset' l);                     offset += l;                     type = edsTypeUtf8;                     break;                  case edsUtf8Count1:                 case edsUtf8Count2:                 case edsUtf8Count3:                 case edsUtf8Count4:                     count = code - edsUtf8Count1;                     int length = source[offset++] & 0xff;                      for (int n = 0; n < count; ++n)                     {                         length = length << 8 | (source[offset++] & 0xff);                     }                      @string = getString(source' offset' length);                     offset += length;                     type = edsTypeUtf8;                     break;                  case edsOpaqueLen0:                 case edsOpaqueLen1:                 case edsOpaqueLen2:                 case edsOpaqueLen3:                 case edsOpaqueLen4:                 case edsOpaqueLen5:                 case edsOpaqueLen6:                 case edsOpaqueLen7:                 case edsOpaqueLen8:                 case edsOpaqueLen9:                 case edsOpaqueLen10:                 case edsOpaqueLen11:                 case edsOpaqueLen12:                 case edsOpaqueLen13:                 case edsOpaqueLen14:                 case edsOpaqueLen15:                 case edsOpaqueLen16:                 case edsOpaqueLen17:                 case edsOpaqueLen18:                 case edsOpaqueLen19:                 case edsOpaqueLen20:                 case edsOpaqueLen21:                 case edsOpaqueLen22:                 case edsOpaqueLen23:                 case edsOpaqueLen24:                 case edsOpaqueLen25:                 case edsOpaqueLen26:                 case edsOpaqueLen27:                 case edsOpaqueLen28:                 case edsOpaqueLen29:                 case edsOpaqueLen30:                 case edsOpaqueLen31:                 case edsOpaqueLen32:                 case edsOpaqueLen33:                 case edsOpaqueLen34:                 case edsOpaqueLen35:                 case edsOpaqueLen36:                 case edsOpaqueLen37:                 case edsOpaqueLen38:                 case edsOpaqueLen39:                     l = code - edsOpaqueLen0;                     bytes = new byte[l];                     Array.Copy(source' offset' bytes' 0' l);                     offset += l;                     type = edsTypeOpaque;                     break;                  case edsOpaqueCount1:                 case edsOpaqueCount2:                 case edsOpaqueCount3:                 case edsOpaqueCount4:                     count = code - edsOpaqueCount1 + 1;                     l = source[offset++] & 0xff;                      for (int n = 1; n < count; ++n)                     {                         l = l << 8 | (source[offset++] & 0xff);                     }                      bytes = new byte[l];                     Array.Copy(source' offset' bytes' 0' l);                     offset += l;                     type = edsTypeOpaque;                     break;                  case edsDoubleLen0:                 case edsDoubleLen1:                 case edsDoubleLen2:                 case edsDoubleLen3:                 case edsDoubleLen4:                 case edsDoubleLen5:                 case edsDoubleLen6:                 case edsDoubleLen7:                 case edsDoubleLen8:                     count = code - edsDoubleLen0;                     long lvalue = 0;                      for (int n = 0; n < count; ++n)                     {                         lvalue = (lvalue << 8) | (source[offset++] & 0xff);                     }                      lvalue <<= (8 - count) * 8;                     dbl = BitConverter.Int64BitsToDouble(lvalue);                     type = edsTypeDouble;                     break;                  case edsTimeLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeTime;                     break;                  case edsTimeLen1:                 case edsTimeLen2:                 case edsTimeLen3:                 case edsTimeLen4:                     l = code - edsTimeLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeTime;                     break;                  case edsMilliSecLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeMilliseconds;                     break;                  case edsMilliSecLen1:                 case edsMilliSecLen2:                 case edsMilliSecLen3:                 case edsMilliSecLen4:                 case edsMilliSecLen5:                 case edsMilliSecLen6:                 case edsMilliSecLen7:                 case edsMilliSecLen8:                     l = code - edsMilliSecLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeMilliseconds;                     break;                  case edsNanoSecLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeNanoseconds;                     break;                  case edsNanoSecLen1:                 case edsNanoSecLen2:                 case edsNanoSecLen3:                 case edsNanoSecLen4:                 case edsNanoSecLen5:                 case edsNanoSecLen6:                 case edsNanoSecLen7:                 case edsNanoSecLen8:                     l = code - edsNanoSecLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeNanoseconds;                     break;                  //                 // 09/2012 Added support for new scaled date/times encoding. These replace the old encoding                 // edsTimeLen' edsMilliSecLen and edsNanoSecLen.                 //                  case edsScaledTimeLen1:                 case edsScaledTimeLen2:                 case edsScaledTimeLen3:                 case edsScaledTimeLen4:                 case edsScaledTimeLen5:                 case edsScaledTimeLen6:                 case edsScaledTimeLen7:                 case edsScaledTimeLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledTimeLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledTime;                     break;                  case edsScaledDateLen1:                 case edsScaledDateLen2:                 case edsScaledDateLen3:                 case edsScaledDateLen4:                 case edsScaledDateLen5:                 case edsScaledDateLen6:                 case edsScaledDateLen7:                 case edsScaledDateLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledDateLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledDate;                     break;                  case edsScaledTimestampLen1:                 case edsScaledTimestampLen2:                 case edsScaledTimestampLen3:                 case edsScaledTimestampLen4:                 case edsScaledTimestampLen5:                 case edsScaledTimestampLen6:                 case edsScaledTimestampLen7:                 case edsScaledTimestampLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledTimestampLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledTimestamp;                     break;                  case edsClobLen0:                     blobId = 0;                     type = edsTypeClob;                     break;                  case edsClobLen1:                 case edsClobLen2:                 case edsClobLen3:                 case edsClobLen4:                     l = code - edsClobLen1;                     blobId = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         blobId = (blobId << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeClob;                     break;                  case edsBlobLen0:                     blobId = 0;                     type = edsTypeBlob;                     break;                  case edsBlobLen1:                 case edsBlobLen2:                 case edsBlobLen3:                 case edsBlobLen4:                     l = code - edsBlobLen1;                     blobId = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         blobId = (blobId << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeBlob;                     break;                  case edsScaledCount1:                     {                         // For some reason C++ EncodedStream expects the encoded                         // length to be length+1.                          length = (source[offset++] & 0xff) - 1;                         scale = (sbyte)source[offset++];                         type = edsTypeBigInt;                         bytes = new byte[length];                         Array.Copy(source' offset' bytes' 0' length);                         offset += length;                         int sign = ((bytes[0] & 0x80) > 0) ? -1 : 1;                          if (sign == -1)                         {                             bytes[0] &= 0x7f;                         }                          BigInteger bi = new BigInteger(bytes);                         bigDecimal = Decimal.Parse(bi.ToString());                     }                     break;                  case edsScaledCount2:                     {                         // For some reason C++ EncodedStream expects the encoded                         // length to be length+1.                          scale = (sbyte)source[offset++];                         sbyte sign = (sbyte)source[offset++];                         length = (source[offset++] & 0xff); // in bytes                         type = edsTypeBigInt;                         bytes = new byte[length];                         Array.Copy(source' offset' bytes' 0' length);                         offset += length;                          if (sign == -1)                             bytes[0] &= 0x7f;                         else                             sign = 1;                          BigInteger bi = new BigInteger(bytes);                         if (sign == -1)                             bi = -bi;                         bigDecimal = ScaleDecimal(Decimal.Parse(bi.ToString())' scale);                     }                     break;                  case edsUUID:                     {                         byte[] buff = new byte[16];                          for (int n = 0; n < 16; ++n)                         {                             buff[n] = (byte)(source[offset++] & 0xff);                         }                          uuid = new Guid(buff);                         type = edsTypeUUID;                     }                     break;                  default:                     type = edsTypeUnknown;                     break;             }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,decode,The following statement contains a magic number: switch (code)             {                 case edsNull:                     type = edsTypeNull;                     break;                  case edsTrue:                     type = edsTypeBoolean;                     @bool = true;                     break;                  case edsFalse:                     type = edsTypeBoolean;                     @bool = false;                     break;                  case edsIntMinus10:                 case edsIntMinus9:                 case edsIntMinus8:                 case edsIntMinus7:                 case edsIntMinus6:                 case edsIntMinus5:                 case edsIntMinus4:                 case edsIntMinus3:                 case edsIntMinus2:                 case edsIntMinus1:                 case edsInt0:                 case edsInt1:                 case edsInt2:                 case edsInt3:                 case edsInt4:                 case edsInt5:                 case edsInt6:                 case edsInt7:                 case edsInt8:                 case edsInt9:                 case edsInt10:                 case edsInt11:                 case edsInt12:                 case edsInt13:                 case edsInt14:                 case edsInt15:                 case edsInt16:                 case edsInt17:                 case edsInt18:                 case edsInt19:                 case edsInt20:                 case edsInt21:                 case edsInt22:                 case edsInt23:                 case edsInt24:                 case edsInt25:                 case edsInt26:                 case edsInt27:                 case edsInt28:                 case edsInt29:                 case edsInt30:                 case edsInt31:                     integer32 = code - edsInt0;                     scale = 0;                     type = edsTypeInt32;                     break;                  case edsIntLen1:                     type = edsTypeInt32;                     scale = 0;                     integer32 = (sbyte)source[offset++];                     break;                  case edsIntLen2:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset] << 8) | (source[offset + 1] & 0xff);                     offset += 2;                     break;                  case edsIntLen3:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset]) << 16 | (source[offset + 1] & 0xff) << 8 | (source[offset + 2] & 0xff);                     offset += 3;                     break;                  case edsIntLen4:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset]) << 24 | (source[offset + 1] & 0xff) << 16 | (source[offset + 2] & 0xff) << 8 | (source[offset + 3] & 0xff);                     offset += 4;                     break;                  case edsIntLen5:                 case edsIntLen6:                 case edsIntLen7:                 case edsIntLen8:                     l = code - edsIntLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeInt64;                     break;                  case edsScaledLen0:                     scale = (sbyte)source[offset++];                     integer64 = 0;                     type = edsTypeScaled;                     break;                  case edsScaledLen1:                 case edsScaledLen2:                 case edsScaledLen3:                 case edsScaledLen4:                 case edsScaledLen5:                 case edsScaledLen6:                 case edsScaledLen7:                 case edsScaledLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaled;                     break;                  case edsUtf8Len0:                 case edsUtf8Len1:                 case edsUtf8Len2:                 case edsUtf8Len3:                 case edsUtf8Len4:                 case edsUtf8Len5:                 case edsUtf8Len6:                 case edsUtf8Len7:                 case edsUtf8Len8:                 case edsUtf8Len9:                 case edsUtf8Len10:                 case edsUtf8Len11:                 case edsUtf8Len12:                 case edsUtf8Len13:                 case edsUtf8Len14:                 case edsUtf8Len15:                 case edsUtf8Len16:                 case edsUtf8Len17:                 case edsUtf8Len18:                 case edsUtf8Len19:                 case edsUtf8Len20:                 case edsUtf8Len21:                 case edsUtf8Len22:                 case edsUtf8Len23:                 case edsUtf8Len24:                 case edsUtf8Len25:                 case edsUtf8Len26:                 case edsUtf8Len27:                 case edsUtf8Len28:                 case edsUtf8Len29:                 case edsUtf8Len30:                 case edsUtf8Len31:                 case edsUtf8Len32:                 case edsUtf8Len33:                 case edsUtf8Len34:                 case edsUtf8Len35:                 case edsUtf8Len36:                 case edsUtf8Len37:                 case edsUtf8Len38:                 case edsUtf8Len39:                     l = code - edsUtf8Len0;                     @string = getString(source' offset' l);                     offset += l;                     type = edsTypeUtf8;                     break;                  case edsUtf8Count1:                 case edsUtf8Count2:                 case edsUtf8Count3:                 case edsUtf8Count4:                     count = code - edsUtf8Count1;                     int length = source[offset++] & 0xff;                      for (int n = 0; n < count; ++n)                     {                         length = length << 8 | (source[offset++] & 0xff);                     }                      @string = getString(source' offset' length);                     offset += length;                     type = edsTypeUtf8;                     break;                  case edsOpaqueLen0:                 case edsOpaqueLen1:                 case edsOpaqueLen2:                 case edsOpaqueLen3:                 case edsOpaqueLen4:                 case edsOpaqueLen5:                 case edsOpaqueLen6:                 case edsOpaqueLen7:                 case edsOpaqueLen8:                 case edsOpaqueLen9:                 case edsOpaqueLen10:                 case edsOpaqueLen11:                 case edsOpaqueLen12:                 case edsOpaqueLen13:                 case edsOpaqueLen14:                 case edsOpaqueLen15:                 case edsOpaqueLen16:                 case edsOpaqueLen17:                 case edsOpaqueLen18:                 case edsOpaqueLen19:                 case edsOpaqueLen20:                 case edsOpaqueLen21:                 case edsOpaqueLen22:                 case edsOpaqueLen23:                 case edsOpaqueLen24:                 case edsOpaqueLen25:                 case edsOpaqueLen26:                 case edsOpaqueLen27:                 case edsOpaqueLen28:                 case edsOpaqueLen29:                 case edsOpaqueLen30:                 case edsOpaqueLen31:                 case edsOpaqueLen32:                 case edsOpaqueLen33:                 case edsOpaqueLen34:                 case edsOpaqueLen35:                 case edsOpaqueLen36:                 case edsOpaqueLen37:                 case edsOpaqueLen38:                 case edsOpaqueLen39:                     l = code - edsOpaqueLen0;                     bytes = new byte[l];                     Array.Copy(source' offset' bytes' 0' l);                     offset += l;                     type = edsTypeOpaque;                     break;                  case edsOpaqueCount1:                 case edsOpaqueCount2:                 case edsOpaqueCount3:                 case edsOpaqueCount4:                     count = code - edsOpaqueCount1 + 1;                     l = source[offset++] & 0xff;                      for (int n = 1; n < count; ++n)                     {                         l = l << 8 | (source[offset++] & 0xff);                     }                      bytes = new byte[l];                     Array.Copy(source' offset' bytes' 0' l);                     offset += l;                     type = edsTypeOpaque;                     break;                  case edsDoubleLen0:                 case edsDoubleLen1:                 case edsDoubleLen2:                 case edsDoubleLen3:                 case edsDoubleLen4:                 case edsDoubleLen5:                 case edsDoubleLen6:                 case edsDoubleLen7:                 case edsDoubleLen8:                     count = code - edsDoubleLen0;                     long lvalue = 0;                      for (int n = 0; n < count; ++n)                     {                         lvalue = (lvalue << 8) | (source[offset++] & 0xff);                     }                      lvalue <<= (8 - count) * 8;                     dbl = BitConverter.Int64BitsToDouble(lvalue);                     type = edsTypeDouble;                     break;                  case edsTimeLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeTime;                     break;                  case edsTimeLen1:                 case edsTimeLen2:                 case edsTimeLen3:                 case edsTimeLen4:                     l = code - edsTimeLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeTime;                     break;                  case edsMilliSecLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeMilliseconds;                     break;                  case edsMilliSecLen1:                 case edsMilliSecLen2:                 case edsMilliSecLen3:                 case edsMilliSecLen4:                 case edsMilliSecLen5:                 case edsMilliSecLen6:                 case edsMilliSecLen7:                 case edsMilliSecLen8:                     l = code - edsMilliSecLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeMilliseconds;                     break;                  case edsNanoSecLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeNanoseconds;                     break;                  case edsNanoSecLen1:                 case edsNanoSecLen2:                 case edsNanoSecLen3:                 case edsNanoSecLen4:                 case edsNanoSecLen5:                 case edsNanoSecLen6:                 case edsNanoSecLen7:                 case edsNanoSecLen8:                     l = code - edsNanoSecLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeNanoseconds;                     break;                  //                 // 09/2012 Added support for new scaled date/times encoding. These replace the old encoding                 // edsTimeLen' edsMilliSecLen and edsNanoSecLen.                 //                  case edsScaledTimeLen1:                 case edsScaledTimeLen2:                 case edsScaledTimeLen3:                 case edsScaledTimeLen4:                 case edsScaledTimeLen5:                 case edsScaledTimeLen6:                 case edsScaledTimeLen7:                 case edsScaledTimeLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledTimeLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledTime;                     break;                  case edsScaledDateLen1:                 case edsScaledDateLen2:                 case edsScaledDateLen3:                 case edsScaledDateLen4:                 case edsScaledDateLen5:                 case edsScaledDateLen6:                 case edsScaledDateLen7:                 case edsScaledDateLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledDateLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledDate;                     break;                  case edsScaledTimestampLen1:                 case edsScaledTimestampLen2:                 case edsScaledTimestampLen3:                 case edsScaledTimestampLen4:                 case edsScaledTimestampLen5:                 case edsScaledTimestampLen6:                 case edsScaledTimestampLen7:                 case edsScaledTimestampLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledTimestampLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledTimestamp;                     break;                  case edsClobLen0:                     blobId = 0;                     type = edsTypeClob;                     break;                  case edsClobLen1:                 case edsClobLen2:                 case edsClobLen3:                 case edsClobLen4:                     l = code - edsClobLen1;                     blobId = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         blobId = (blobId << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeClob;                     break;                  case edsBlobLen0:                     blobId = 0;                     type = edsTypeBlob;                     break;                  case edsBlobLen1:                 case edsBlobLen2:                 case edsBlobLen3:                 case edsBlobLen4:                     l = code - edsBlobLen1;                     blobId = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         blobId = (blobId << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeBlob;                     break;                  case edsScaledCount1:                     {                         // For some reason C++ EncodedStream expects the encoded                         // length to be length+1.                          length = (source[offset++] & 0xff) - 1;                         scale = (sbyte)source[offset++];                         type = edsTypeBigInt;                         bytes = new byte[length];                         Array.Copy(source' offset' bytes' 0' length);                         offset += length;                         int sign = ((bytes[0] & 0x80) > 0) ? -1 : 1;                          if (sign == -1)                         {                             bytes[0] &= 0x7f;                         }                          BigInteger bi = new BigInteger(bytes);                         bigDecimal = Decimal.Parse(bi.ToString());                     }                     break;                  case edsScaledCount2:                     {                         // For some reason C++ EncodedStream expects the encoded                         // length to be length+1.                          scale = (sbyte)source[offset++];                         sbyte sign = (sbyte)source[offset++];                         length = (source[offset++] & 0xff); // in bytes                         type = edsTypeBigInt;                         bytes = new byte[length];                         Array.Copy(source' offset' bytes' 0' length);                         offset += length;                          if (sign == -1)                             bytes[0] &= 0x7f;                         else                             sign = 1;                          BigInteger bi = new BigInteger(bytes);                         if (sign == -1)                             bi = -bi;                         bigDecimal = ScaleDecimal(Decimal.Parse(bi.ToString())' scale);                     }                     break;                  case edsUUID:                     {                         byte[] buff = new byte[16];                          for (int n = 0; n < 16; ++n)                         {                             buff[n] = (byte)(source[offset++] & 0xff);                         }                          uuid = new Guid(buff);                         type = edsTypeUUID;                     }                     break;                  default:                     type = edsTypeUnknown;                     break;             }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,decode,The following statement contains a magic number: switch (code)             {                 case edsNull:                     type = edsTypeNull;                     break;                  case edsTrue:                     type = edsTypeBoolean;                     @bool = true;                     break;                  case edsFalse:                     type = edsTypeBoolean;                     @bool = false;                     break;                  case edsIntMinus10:                 case edsIntMinus9:                 case edsIntMinus8:                 case edsIntMinus7:                 case edsIntMinus6:                 case edsIntMinus5:                 case edsIntMinus4:                 case edsIntMinus3:                 case edsIntMinus2:                 case edsIntMinus1:                 case edsInt0:                 case edsInt1:                 case edsInt2:                 case edsInt3:                 case edsInt4:                 case edsInt5:                 case edsInt6:                 case edsInt7:                 case edsInt8:                 case edsInt9:                 case edsInt10:                 case edsInt11:                 case edsInt12:                 case edsInt13:                 case edsInt14:                 case edsInt15:                 case edsInt16:                 case edsInt17:                 case edsInt18:                 case edsInt19:                 case edsInt20:                 case edsInt21:                 case edsInt22:                 case edsInt23:                 case edsInt24:                 case edsInt25:                 case edsInt26:                 case edsInt27:                 case edsInt28:                 case edsInt29:                 case edsInt30:                 case edsInt31:                     integer32 = code - edsInt0;                     scale = 0;                     type = edsTypeInt32;                     break;                  case edsIntLen1:                     type = edsTypeInt32;                     scale = 0;                     integer32 = (sbyte)source[offset++];                     break;                  case edsIntLen2:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset] << 8) | (source[offset + 1] & 0xff);                     offset += 2;                     break;                  case edsIntLen3:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset]) << 16 | (source[offset + 1] & 0xff) << 8 | (source[offset + 2] & 0xff);                     offset += 3;                     break;                  case edsIntLen4:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset]) << 24 | (source[offset + 1] & 0xff) << 16 | (source[offset + 2] & 0xff) << 8 | (source[offset + 3] & 0xff);                     offset += 4;                     break;                  case edsIntLen5:                 case edsIntLen6:                 case edsIntLen7:                 case edsIntLen8:                     l = code - edsIntLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeInt64;                     break;                  case edsScaledLen0:                     scale = (sbyte)source[offset++];                     integer64 = 0;                     type = edsTypeScaled;                     break;                  case edsScaledLen1:                 case edsScaledLen2:                 case edsScaledLen3:                 case edsScaledLen4:                 case edsScaledLen5:                 case edsScaledLen6:                 case edsScaledLen7:                 case edsScaledLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaled;                     break;                  case edsUtf8Len0:                 case edsUtf8Len1:                 case edsUtf8Len2:                 case edsUtf8Len3:                 case edsUtf8Len4:                 case edsUtf8Len5:                 case edsUtf8Len6:                 case edsUtf8Len7:                 case edsUtf8Len8:                 case edsUtf8Len9:                 case edsUtf8Len10:                 case edsUtf8Len11:                 case edsUtf8Len12:                 case edsUtf8Len13:                 case edsUtf8Len14:                 case edsUtf8Len15:                 case edsUtf8Len16:                 case edsUtf8Len17:                 case edsUtf8Len18:                 case edsUtf8Len19:                 case edsUtf8Len20:                 case edsUtf8Len21:                 case edsUtf8Len22:                 case edsUtf8Len23:                 case edsUtf8Len24:                 case edsUtf8Len25:                 case edsUtf8Len26:                 case edsUtf8Len27:                 case edsUtf8Len28:                 case edsUtf8Len29:                 case edsUtf8Len30:                 case edsUtf8Len31:                 case edsUtf8Len32:                 case edsUtf8Len33:                 case edsUtf8Len34:                 case edsUtf8Len35:                 case edsUtf8Len36:                 case edsUtf8Len37:                 case edsUtf8Len38:                 case edsUtf8Len39:                     l = code - edsUtf8Len0;                     @string = getString(source' offset' l);                     offset += l;                     type = edsTypeUtf8;                     break;                  case edsUtf8Count1:                 case edsUtf8Count2:                 case edsUtf8Count3:                 case edsUtf8Count4:                     count = code - edsUtf8Count1;                     int length = source[offset++] & 0xff;                      for (int n = 0; n < count; ++n)                     {                         length = length << 8 | (source[offset++] & 0xff);                     }                      @string = getString(source' offset' length);                     offset += length;                     type = edsTypeUtf8;                     break;                  case edsOpaqueLen0:                 case edsOpaqueLen1:                 case edsOpaqueLen2:                 case edsOpaqueLen3:                 case edsOpaqueLen4:                 case edsOpaqueLen5:                 case edsOpaqueLen6:                 case edsOpaqueLen7:                 case edsOpaqueLen8:                 case edsOpaqueLen9:                 case edsOpaqueLen10:                 case edsOpaqueLen11:                 case edsOpaqueLen12:                 case edsOpaqueLen13:                 case edsOpaqueLen14:                 case edsOpaqueLen15:                 case edsOpaqueLen16:                 case edsOpaqueLen17:                 case edsOpaqueLen18:                 case edsOpaqueLen19:                 case edsOpaqueLen20:                 case edsOpaqueLen21:                 case edsOpaqueLen22:                 case edsOpaqueLen23:                 case edsOpaqueLen24:                 case edsOpaqueLen25:                 case edsOpaqueLen26:                 case edsOpaqueLen27:                 case edsOpaqueLen28:                 case edsOpaqueLen29:                 case edsOpaqueLen30:                 case edsOpaqueLen31:                 case edsOpaqueLen32:                 case edsOpaqueLen33:                 case edsOpaqueLen34:                 case edsOpaqueLen35:                 case edsOpaqueLen36:                 case edsOpaqueLen37:                 case edsOpaqueLen38:                 case edsOpaqueLen39:                     l = code - edsOpaqueLen0;                     bytes = new byte[l];                     Array.Copy(source' offset' bytes' 0' l);                     offset += l;                     type = edsTypeOpaque;                     break;                  case edsOpaqueCount1:                 case edsOpaqueCount2:                 case edsOpaqueCount3:                 case edsOpaqueCount4:                     count = code - edsOpaqueCount1 + 1;                     l = source[offset++] & 0xff;                      for (int n = 1; n < count; ++n)                     {                         l = l << 8 | (source[offset++] & 0xff);                     }                      bytes = new byte[l];                     Array.Copy(source' offset' bytes' 0' l);                     offset += l;                     type = edsTypeOpaque;                     break;                  case edsDoubleLen0:                 case edsDoubleLen1:                 case edsDoubleLen2:                 case edsDoubleLen3:                 case edsDoubleLen4:                 case edsDoubleLen5:                 case edsDoubleLen6:                 case edsDoubleLen7:                 case edsDoubleLen8:                     count = code - edsDoubleLen0;                     long lvalue = 0;                      for (int n = 0; n < count; ++n)                     {                         lvalue = (lvalue << 8) | (source[offset++] & 0xff);                     }                      lvalue <<= (8 - count) * 8;                     dbl = BitConverter.Int64BitsToDouble(lvalue);                     type = edsTypeDouble;                     break;                  case edsTimeLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeTime;                     break;                  case edsTimeLen1:                 case edsTimeLen2:                 case edsTimeLen3:                 case edsTimeLen4:                     l = code - edsTimeLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeTime;                     break;                  case edsMilliSecLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeMilliseconds;                     break;                  case edsMilliSecLen1:                 case edsMilliSecLen2:                 case edsMilliSecLen3:                 case edsMilliSecLen4:                 case edsMilliSecLen5:                 case edsMilliSecLen6:                 case edsMilliSecLen7:                 case edsMilliSecLen8:                     l = code - edsMilliSecLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeMilliseconds;                     break;                  case edsNanoSecLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeNanoseconds;                     break;                  case edsNanoSecLen1:                 case edsNanoSecLen2:                 case edsNanoSecLen3:                 case edsNanoSecLen4:                 case edsNanoSecLen5:                 case edsNanoSecLen6:                 case edsNanoSecLen7:                 case edsNanoSecLen8:                     l = code - edsNanoSecLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeNanoseconds;                     break;                  //                 // 09/2012 Added support for new scaled date/times encoding. These replace the old encoding                 // edsTimeLen' edsMilliSecLen and edsNanoSecLen.                 //                  case edsScaledTimeLen1:                 case edsScaledTimeLen2:                 case edsScaledTimeLen3:                 case edsScaledTimeLen4:                 case edsScaledTimeLen5:                 case edsScaledTimeLen6:                 case edsScaledTimeLen7:                 case edsScaledTimeLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledTimeLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledTime;                     break;                  case edsScaledDateLen1:                 case edsScaledDateLen2:                 case edsScaledDateLen3:                 case edsScaledDateLen4:                 case edsScaledDateLen5:                 case edsScaledDateLen6:                 case edsScaledDateLen7:                 case edsScaledDateLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledDateLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledDate;                     break;                  case edsScaledTimestampLen1:                 case edsScaledTimestampLen2:                 case edsScaledTimestampLen3:                 case edsScaledTimestampLen4:                 case edsScaledTimestampLen5:                 case edsScaledTimestampLen6:                 case edsScaledTimestampLen7:                 case edsScaledTimestampLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledTimestampLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledTimestamp;                     break;                  case edsClobLen0:                     blobId = 0;                     type = edsTypeClob;                     break;                  case edsClobLen1:                 case edsClobLen2:                 case edsClobLen3:                 case edsClobLen4:                     l = code - edsClobLen1;                     blobId = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         blobId = (blobId << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeClob;                     break;                  case edsBlobLen0:                     blobId = 0;                     type = edsTypeBlob;                     break;                  case edsBlobLen1:                 case edsBlobLen2:                 case edsBlobLen3:                 case edsBlobLen4:                     l = code - edsBlobLen1;                     blobId = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         blobId = (blobId << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeBlob;                     break;                  case edsScaledCount1:                     {                         // For some reason C++ EncodedStream expects the encoded                         // length to be length+1.                          length = (source[offset++] & 0xff) - 1;                         scale = (sbyte)source[offset++];                         type = edsTypeBigInt;                         bytes = new byte[length];                         Array.Copy(source' offset' bytes' 0' length);                         offset += length;                         int sign = ((bytes[0] & 0x80) > 0) ? -1 : 1;                          if (sign == -1)                         {                             bytes[0] &= 0x7f;                         }                          BigInteger bi = new BigInteger(bytes);                         bigDecimal = Decimal.Parse(bi.ToString());                     }                     break;                  case edsScaledCount2:                     {                         // For some reason C++ EncodedStream expects the encoded                         // length to be length+1.                          scale = (sbyte)source[offset++];                         sbyte sign = (sbyte)source[offset++];                         length = (source[offset++] & 0xff); // in bytes                         type = edsTypeBigInt;                         bytes = new byte[length];                         Array.Copy(source' offset' bytes' 0' length);                         offset += length;                          if (sign == -1)                             bytes[0] &= 0x7f;                         else                             sign = 1;                          BigInteger bi = new BigInteger(bytes);                         if (sign == -1)                             bi = -bi;                         bigDecimal = ScaleDecimal(Decimal.Parse(bi.ToString())' scale);                     }                     break;                  case edsUUID:                     {                         byte[] buff = new byte[16];                          for (int n = 0; n < 16; ++n)                         {                             buff[n] = (byte)(source[offset++] & 0xff);                         }                          uuid = new Guid(buff);                         type = edsTypeUUID;                     }                     break;                  default:                     type = edsTypeUnknown;                     break;             }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,decode,The following statement contains a magic number: switch (code)             {                 case edsNull:                     type = edsTypeNull;                     break;                  case edsTrue:                     type = edsTypeBoolean;                     @bool = true;                     break;                  case edsFalse:                     type = edsTypeBoolean;                     @bool = false;                     break;                  case edsIntMinus10:                 case edsIntMinus9:                 case edsIntMinus8:                 case edsIntMinus7:                 case edsIntMinus6:                 case edsIntMinus5:                 case edsIntMinus4:                 case edsIntMinus3:                 case edsIntMinus2:                 case edsIntMinus1:                 case edsInt0:                 case edsInt1:                 case edsInt2:                 case edsInt3:                 case edsInt4:                 case edsInt5:                 case edsInt6:                 case edsInt7:                 case edsInt8:                 case edsInt9:                 case edsInt10:                 case edsInt11:                 case edsInt12:                 case edsInt13:                 case edsInt14:                 case edsInt15:                 case edsInt16:                 case edsInt17:                 case edsInt18:                 case edsInt19:                 case edsInt20:                 case edsInt21:                 case edsInt22:                 case edsInt23:                 case edsInt24:                 case edsInt25:                 case edsInt26:                 case edsInt27:                 case edsInt28:                 case edsInt29:                 case edsInt30:                 case edsInt31:                     integer32 = code - edsInt0;                     scale = 0;                     type = edsTypeInt32;                     break;                  case edsIntLen1:                     type = edsTypeInt32;                     scale = 0;                     integer32 = (sbyte)source[offset++];                     break;                  case edsIntLen2:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset] << 8) | (source[offset + 1] & 0xff);                     offset += 2;                     break;                  case edsIntLen3:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset]) << 16 | (source[offset + 1] & 0xff) << 8 | (source[offset + 2] & 0xff);                     offset += 3;                     break;                  case edsIntLen4:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset]) << 24 | (source[offset + 1] & 0xff) << 16 | (source[offset + 2] & 0xff) << 8 | (source[offset + 3] & 0xff);                     offset += 4;                     break;                  case edsIntLen5:                 case edsIntLen6:                 case edsIntLen7:                 case edsIntLen8:                     l = code - edsIntLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeInt64;                     break;                  case edsScaledLen0:                     scale = (sbyte)source[offset++];                     integer64 = 0;                     type = edsTypeScaled;                     break;                  case edsScaledLen1:                 case edsScaledLen2:                 case edsScaledLen3:                 case edsScaledLen4:                 case edsScaledLen5:                 case edsScaledLen6:                 case edsScaledLen7:                 case edsScaledLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaled;                     break;                  case edsUtf8Len0:                 case edsUtf8Len1:                 case edsUtf8Len2:                 case edsUtf8Len3:                 case edsUtf8Len4:                 case edsUtf8Len5:                 case edsUtf8Len6:                 case edsUtf8Len7:                 case edsUtf8Len8:                 case edsUtf8Len9:                 case edsUtf8Len10:                 case edsUtf8Len11:                 case edsUtf8Len12:                 case edsUtf8Len13:                 case edsUtf8Len14:                 case edsUtf8Len15:                 case edsUtf8Len16:                 case edsUtf8Len17:                 case edsUtf8Len18:                 case edsUtf8Len19:                 case edsUtf8Len20:                 case edsUtf8Len21:                 case edsUtf8Len22:                 case edsUtf8Len23:                 case edsUtf8Len24:                 case edsUtf8Len25:                 case edsUtf8Len26:                 case edsUtf8Len27:                 case edsUtf8Len28:                 case edsUtf8Len29:                 case edsUtf8Len30:                 case edsUtf8Len31:                 case edsUtf8Len32:                 case edsUtf8Len33:                 case edsUtf8Len34:                 case edsUtf8Len35:                 case edsUtf8Len36:                 case edsUtf8Len37:                 case edsUtf8Len38:                 case edsUtf8Len39:                     l = code - edsUtf8Len0;                     @string = getString(source' offset' l);                     offset += l;                     type = edsTypeUtf8;                     break;                  case edsUtf8Count1:                 case edsUtf8Count2:                 case edsUtf8Count3:                 case edsUtf8Count4:                     count = code - edsUtf8Count1;                     int length = source[offset++] & 0xff;                      for (int n = 0; n < count; ++n)                     {                         length = length << 8 | (source[offset++] & 0xff);                     }                      @string = getString(source' offset' length);                     offset += length;                     type = edsTypeUtf8;                     break;                  case edsOpaqueLen0:                 case edsOpaqueLen1:                 case edsOpaqueLen2:                 case edsOpaqueLen3:                 case edsOpaqueLen4:                 case edsOpaqueLen5:                 case edsOpaqueLen6:                 case edsOpaqueLen7:                 case edsOpaqueLen8:                 case edsOpaqueLen9:                 case edsOpaqueLen10:                 case edsOpaqueLen11:                 case edsOpaqueLen12:                 case edsOpaqueLen13:                 case edsOpaqueLen14:                 case edsOpaqueLen15:                 case edsOpaqueLen16:                 case edsOpaqueLen17:                 case edsOpaqueLen18:                 case edsOpaqueLen19:                 case edsOpaqueLen20:                 case edsOpaqueLen21:                 case edsOpaqueLen22:                 case edsOpaqueLen23:                 case edsOpaqueLen24:                 case edsOpaqueLen25:                 case edsOpaqueLen26:                 case edsOpaqueLen27:                 case edsOpaqueLen28:                 case edsOpaqueLen29:                 case edsOpaqueLen30:                 case edsOpaqueLen31:                 case edsOpaqueLen32:                 case edsOpaqueLen33:                 case edsOpaqueLen34:                 case edsOpaqueLen35:                 case edsOpaqueLen36:                 case edsOpaqueLen37:                 case edsOpaqueLen38:                 case edsOpaqueLen39:                     l = code - edsOpaqueLen0;                     bytes = new byte[l];                     Array.Copy(source' offset' bytes' 0' l);                     offset += l;                     type = edsTypeOpaque;                     break;                  case edsOpaqueCount1:                 case edsOpaqueCount2:                 case edsOpaqueCount3:                 case edsOpaqueCount4:                     count = code - edsOpaqueCount1 + 1;                     l = source[offset++] & 0xff;                      for (int n = 1; n < count; ++n)                     {                         l = l << 8 | (source[offset++] & 0xff);                     }                      bytes = new byte[l];                     Array.Copy(source' offset' bytes' 0' l);                     offset += l;                     type = edsTypeOpaque;                     break;                  case edsDoubleLen0:                 case edsDoubleLen1:                 case edsDoubleLen2:                 case edsDoubleLen3:                 case edsDoubleLen4:                 case edsDoubleLen5:                 case edsDoubleLen6:                 case edsDoubleLen7:                 case edsDoubleLen8:                     count = code - edsDoubleLen0;                     long lvalue = 0;                      for (int n = 0; n < count; ++n)                     {                         lvalue = (lvalue << 8) | (source[offset++] & 0xff);                     }                      lvalue <<= (8 - count) * 8;                     dbl = BitConverter.Int64BitsToDouble(lvalue);                     type = edsTypeDouble;                     break;                  case edsTimeLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeTime;                     break;                  case edsTimeLen1:                 case edsTimeLen2:                 case edsTimeLen3:                 case edsTimeLen4:                     l = code - edsTimeLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeTime;                     break;                  case edsMilliSecLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeMilliseconds;                     break;                  case edsMilliSecLen1:                 case edsMilliSecLen2:                 case edsMilliSecLen3:                 case edsMilliSecLen4:                 case edsMilliSecLen5:                 case edsMilliSecLen6:                 case edsMilliSecLen7:                 case edsMilliSecLen8:                     l = code - edsMilliSecLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeMilliseconds;                     break;                  case edsNanoSecLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeNanoseconds;                     break;                  case edsNanoSecLen1:                 case edsNanoSecLen2:                 case edsNanoSecLen3:                 case edsNanoSecLen4:                 case edsNanoSecLen5:                 case edsNanoSecLen6:                 case edsNanoSecLen7:                 case edsNanoSecLen8:                     l = code - edsNanoSecLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeNanoseconds;                     break;                  //                 // 09/2012 Added support for new scaled date/times encoding. These replace the old encoding                 // edsTimeLen' edsMilliSecLen and edsNanoSecLen.                 //                  case edsScaledTimeLen1:                 case edsScaledTimeLen2:                 case edsScaledTimeLen3:                 case edsScaledTimeLen4:                 case edsScaledTimeLen5:                 case edsScaledTimeLen6:                 case edsScaledTimeLen7:                 case edsScaledTimeLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledTimeLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledTime;                     break;                  case edsScaledDateLen1:                 case edsScaledDateLen2:                 case edsScaledDateLen3:                 case edsScaledDateLen4:                 case edsScaledDateLen5:                 case edsScaledDateLen6:                 case edsScaledDateLen7:                 case edsScaledDateLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledDateLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledDate;                     break;                  case edsScaledTimestampLen1:                 case edsScaledTimestampLen2:                 case edsScaledTimestampLen3:                 case edsScaledTimestampLen4:                 case edsScaledTimestampLen5:                 case edsScaledTimestampLen6:                 case edsScaledTimestampLen7:                 case edsScaledTimestampLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledTimestampLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledTimestamp;                     break;                  case edsClobLen0:                     blobId = 0;                     type = edsTypeClob;                     break;                  case edsClobLen1:                 case edsClobLen2:                 case edsClobLen3:                 case edsClobLen4:                     l = code - edsClobLen1;                     blobId = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         blobId = (blobId << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeClob;                     break;                  case edsBlobLen0:                     blobId = 0;                     type = edsTypeBlob;                     break;                  case edsBlobLen1:                 case edsBlobLen2:                 case edsBlobLen3:                 case edsBlobLen4:                     l = code - edsBlobLen1;                     blobId = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         blobId = (blobId << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeBlob;                     break;                  case edsScaledCount1:                     {                         // For some reason C++ EncodedStream expects the encoded                         // length to be length+1.                          length = (source[offset++] & 0xff) - 1;                         scale = (sbyte)source[offset++];                         type = edsTypeBigInt;                         bytes = new byte[length];                         Array.Copy(source' offset' bytes' 0' length);                         offset += length;                         int sign = ((bytes[0] & 0x80) > 0) ? -1 : 1;                          if (sign == -1)                         {                             bytes[0] &= 0x7f;                         }                          BigInteger bi = new BigInteger(bytes);                         bigDecimal = Decimal.Parse(bi.ToString());                     }                     break;                  case edsScaledCount2:                     {                         // For some reason C++ EncodedStream expects the encoded                         // length to be length+1.                          scale = (sbyte)source[offset++];                         sbyte sign = (sbyte)source[offset++];                         length = (source[offset++] & 0xff); // in bytes                         type = edsTypeBigInt;                         bytes = new byte[length];                         Array.Copy(source' offset' bytes' 0' length);                         offset += length;                          if (sign == -1)                             bytes[0] &= 0x7f;                         else                             sign = 1;                          BigInteger bi = new BigInteger(bytes);                         if (sign == -1)                             bi = -bi;                         bigDecimal = ScaleDecimal(Decimal.Parse(bi.ToString())' scale);                     }                     break;                  case edsUUID:                     {                         byte[] buff = new byte[16];                          for (int n = 0; n < 16; ++n)                         {                             buff[n] = (byte)(source[offset++] & 0xff);                         }                          uuid = new Guid(buff);                         type = edsTypeUUID;                     }                     break;                  default:                     type = edsTypeUnknown;                     break;             }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,decode,The following statement contains a magic number: switch (code)             {                 case edsNull:                     type = edsTypeNull;                     break;                  case edsTrue:                     type = edsTypeBoolean;                     @bool = true;                     break;                  case edsFalse:                     type = edsTypeBoolean;                     @bool = false;                     break;                  case edsIntMinus10:                 case edsIntMinus9:                 case edsIntMinus8:                 case edsIntMinus7:                 case edsIntMinus6:                 case edsIntMinus5:                 case edsIntMinus4:                 case edsIntMinus3:                 case edsIntMinus2:                 case edsIntMinus1:                 case edsInt0:                 case edsInt1:                 case edsInt2:                 case edsInt3:                 case edsInt4:                 case edsInt5:                 case edsInt6:                 case edsInt7:                 case edsInt8:                 case edsInt9:                 case edsInt10:                 case edsInt11:                 case edsInt12:                 case edsInt13:                 case edsInt14:                 case edsInt15:                 case edsInt16:                 case edsInt17:                 case edsInt18:                 case edsInt19:                 case edsInt20:                 case edsInt21:                 case edsInt22:                 case edsInt23:                 case edsInt24:                 case edsInt25:                 case edsInt26:                 case edsInt27:                 case edsInt28:                 case edsInt29:                 case edsInt30:                 case edsInt31:                     integer32 = code - edsInt0;                     scale = 0;                     type = edsTypeInt32;                     break;                  case edsIntLen1:                     type = edsTypeInt32;                     scale = 0;                     integer32 = (sbyte)source[offset++];                     break;                  case edsIntLen2:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset] << 8) | (source[offset + 1] & 0xff);                     offset += 2;                     break;                  case edsIntLen3:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset]) << 16 | (source[offset + 1] & 0xff) << 8 | (source[offset + 2] & 0xff);                     offset += 3;                     break;                  case edsIntLen4:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset]) << 24 | (source[offset + 1] & 0xff) << 16 | (source[offset + 2] & 0xff) << 8 | (source[offset + 3] & 0xff);                     offset += 4;                     break;                  case edsIntLen5:                 case edsIntLen6:                 case edsIntLen7:                 case edsIntLen8:                     l = code - edsIntLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeInt64;                     break;                  case edsScaledLen0:                     scale = (sbyte)source[offset++];                     integer64 = 0;                     type = edsTypeScaled;                     break;                  case edsScaledLen1:                 case edsScaledLen2:                 case edsScaledLen3:                 case edsScaledLen4:                 case edsScaledLen5:                 case edsScaledLen6:                 case edsScaledLen7:                 case edsScaledLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaled;                     break;                  case edsUtf8Len0:                 case edsUtf8Len1:                 case edsUtf8Len2:                 case edsUtf8Len3:                 case edsUtf8Len4:                 case edsUtf8Len5:                 case edsUtf8Len6:                 case edsUtf8Len7:                 case edsUtf8Len8:                 case edsUtf8Len9:                 case edsUtf8Len10:                 case edsUtf8Len11:                 case edsUtf8Len12:                 case edsUtf8Len13:                 case edsUtf8Len14:                 case edsUtf8Len15:                 case edsUtf8Len16:                 case edsUtf8Len17:                 case edsUtf8Len18:                 case edsUtf8Len19:                 case edsUtf8Len20:                 case edsUtf8Len21:                 case edsUtf8Len22:                 case edsUtf8Len23:                 case edsUtf8Len24:                 case edsUtf8Len25:                 case edsUtf8Len26:                 case edsUtf8Len27:                 case edsUtf8Len28:                 case edsUtf8Len29:                 case edsUtf8Len30:                 case edsUtf8Len31:                 case edsUtf8Len32:                 case edsUtf8Len33:                 case edsUtf8Len34:                 case edsUtf8Len35:                 case edsUtf8Len36:                 case edsUtf8Len37:                 case edsUtf8Len38:                 case edsUtf8Len39:                     l = code - edsUtf8Len0;                     @string = getString(source' offset' l);                     offset += l;                     type = edsTypeUtf8;                     break;                  case edsUtf8Count1:                 case edsUtf8Count2:                 case edsUtf8Count3:                 case edsUtf8Count4:                     count = code - edsUtf8Count1;                     int length = source[offset++] & 0xff;                      for (int n = 0; n < count; ++n)                     {                         length = length << 8 | (source[offset++] & 0xff);                     }                      @string = getString(source' offset' length);                     offset += length;                     type = edsTypeUtf8;                     break;                  case edsOpaqueLen0:                 case edsOpaqueLen1:                 case edsOpaqueLen2:                 case edsOpaqueLen3:                 case edsOpaqueLen4:                 case edsOpaqueLen5:                 case edsOpaqueLen6:                 case edsOpaqueLen7:                 case edsOpaqueLen8:                 case edsOpaqueLen9:                 case edsOpaqueLen10:                 case edsOpaqueLen11:                 case edsOpaqueLen12:                 case edsOpaqueLen13:                 case edsOpaqueLen14:                 case edsOpaqueLen15:                 case edsOpaqueLen16:                 case edsOpaqueLen17:                 case edsOpaqueLen18:                 case edsOpaqueLen19:                 case edsOpaqueLen20:                 case edsOpaqueLen21:                 case edsOpaqueLen22:                 case edsOpaqueLen23:                 case edsOpaqueLen24:                 case edsOpaqueLen25:                 case edsOpaqueLen26:                 case edsOpaqueLen27:                 case edsOpaqueLen28:                 case edsOpaqueLen29:                 case edsOpaqueLen30:                 case edsOpaqueLen31:                 case edsOpaqueLen32:                 case edsOpaqueLen33:                 case edsOpaqueLen34:                 case edsOpaqueLen35:                 case edsOpaqueLen36:                 case edsOpaqueLen37:                 case edsOpaqueLen38:                 case edsOpaqueLen39:                     l = code - edsOpaqueLen0;                     bytes = new byte[l];                     Array.Copy(source' offset' bytes' 0' l);                     offset += l;                     type = edsTypeOpaque;                     break;                  case edsOpaqueCount1:                 case edsOpaqueCount2:                 case edsOpaqueCount3:                 case edsOpaqueCount4:                     count = code - edsOpaqueCount1 + 1;                     l = source[offset++] & 0xff;                      for (int n = 1; n < count; ++n)                     {                         l = l << 8 | (source[offset++] & 0xff);                     }                      bytes = new byte[l];                     Array.Copy(source' offset' bytes' 0' l);                     offset += l;                     type = edsTypeOpaque;                     break;                  case edsDoubleLen0:                 case edsDoubleLen1:                 case edsDoubleLen2:                 case edsDoubleLen3:                 case edsDoubleLen4:                 case edsDoubleLen5:                 case edsDoubleLen6:                 case edsDoubleLen7:                 case edsDoubleLen8:                     count = code - edsDoubleLen0;                     long lvalue = 0;                      for (int n = 0; n < count; ++n)                     {                         lvalue = (lvalue << 8) | (source[offset++] & 0xff);                     }                      lvalue <<= (8 - count) * 8;                     dbl = BitConverter.Int64BitsToDouble(lvalue);                     type = edsTypeDouble;                     break;                  case edsTimeLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeTime;                     break;                  case edsTimeLen1:                 case edsTimeLen2:                 case edsTimeLen3:                 case edsTimeLen4:                     l = code - edsTimeLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeTime;                     break;                  case edsMilliSecLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeMilliseconds;                     break;                  case edsMilliSecLen1:                 case edsMilliSecLen2:                 case edsMilliSecLen3:                 case edsMilliSecLen4:                 case edsMilliSecLen5:                 case edsMilliSecLen6:                 case edsMilliSecLen7:                 case edsMilliSecLen8:                     l = code - edsMilliSecLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeMilliseconds;                     break;                  case edsNanoSecLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeNanoseconds;                     break;                  case edsNanoSecLen1:                 case edsNanoSecLen2:                 case edsNanoSecLen3:                 case edsNanoSecLen4:                 case edsNanoSecLen5:                 case edsNanoSecLen6:                 case edsNanoSecLen7:                 case edsNanoSecLen8:                     l = code - edsNanoSecLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeNanoseconds;                     break;                  //                 // 09/2012 Added support for new scaled date/times encoding. These replace the old encoding                 // edsTimeLen' edsMilliSecLen and edsNanoSecLen.                 //                  case edsScaledTimeLen1:                 case edsScaledTimeLen2:                 case edsScaledTimeLen3:                 case edsScaledTimeLen4:                 case edsScaledTimeLen5:                 case edsScaledTimeLen6:                 case edsScaledTimeLen7:                 case edsScaledTimeLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledTimeLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledTime;                     break;                  case edsScaledDateLen1:                 case edsScaledDateLen2:                 case edsScaledDateLen3:                 case edsScaledDateLen4:                 case edsScaledDateLen5:                 case edsScaledDateLen6:                 case edsScaledDateLen7:                 case edsScaledDateLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledDateLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledDate;                     break;                  case edsScaledTimestampLen1:                 case edsScaledTimestampLen2:                 case edsScaledTimestampLen3:                 case edsScaledTimestampLen4:                 case edsScaledTimestampLen5:                 case edsScaledTimestampLen6:                 case edsScaledTimestampLen7:                 case edsScaledTimestampLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledTimestampLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledTimestamp;                     break;                  case edsClobLen0:                     blobId = 0;                     type = edsTypeClob;                     break;                  case edsClobLen1:                 case edsClobLen2:                 case edsClobLen3:                 case edsClobLen4:                     l = code - edsClobLen1;                     blobId = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         blobId = (blobId << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeClob;                     break;                  case edsBlobLen0:                     blobId = 0;                     type = edsTypeBlob;                     break;                  case edsBlobLen1:                 case edsBlobLen2:                 case edsBlobLen3:                 case edsBlobLen4:                     l = code - edsBlobLen1;                     blobId = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         blobId = (blobId << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeBlob;                     break;                  case edsScaledCount1:                     {                         // For some reason C++ EncodedStream expects the encoded                         // length to be length+1.                          length = (source[offset++] & 0xff) - 1;                         scale = (sbyte)source[offset++];                         type = edsTypeBigInt;                         bytes = new byte[length];                         Array.Copy(source' offset' bytes' 0' length);                         offset += length;                         int sign = ((bytes[0] & 0x80) > 0) ? -1 : 1;                          if (sign == -1)                         {                             bytes[0] &= 0x7f;                         }                          BigInteger bi = new BigInteger(bytes);                         bigDecimal = Decimal.Parse(bi.ToString());                     }                     break;                  case edsScaledCount2:                     {                         // For some reason C++ EncodedStream expects the encoded                         // length to be length+1.                          scale = (sbyte)source[offset++];                         sbyte sign = (sbyte)source[offset++];                         length = (source[offset++] & 0xff); // in bytes                         type = edsTypeBigInt;                         bytes = new byte[length];                         Array.Copy(source' offset' bytes' 0' length);                         offset += length;                          if (sign == -1)                             bytes[0] &= 0x7f;                         else                             sign = 1;                          BigInteger bi = new BigInteger(bytes);                         if (sign == -1)                             bi = -bi;                         bigDecimal = ScaleDecimal(Decimal.Parse(bi.ToString())' scale);                     }                     break;                  case edsUUID:                     {                         byte[] buff = new byte[16];                          for (int n = 0; n < 16; ++n)                         {                             buff[n] = (byte)(source[offset++] & 0xff);                         }                          uuid = new Guid(buff);                         type = edsTypeUUID;                     }                     break;                  default:                     type = edsTypeUnknown;                     break;             }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,decode,The following statement contains a magic number: switch (code)             {                 case edsNull:                     type = edsTypeNull;                     break;                  case edsTrue:                     type = edsTypeBoolean;                     @bool = true;                     break;                  case edsFalse:                     type = edsTypeBoolean;                     @bool = false;                     break;                  case edsIntMinus10:                 case edsIntMinus9:                 case edsIntMinus8:                 case edsIntMinus7:                 case edsIntMinus6:                 case edsIntMinus5:                 case edsIntMinus4:                 case edsIntMinus3:                 case edsIntMinus2:                 case edsIntMinus1:                 case edsInt0:                 case edsInt1:                 case edsInt2:                 case edsInt3:                 case edsInt4:                 case edsInt5:                 case edsInt6:                 case edsInt7:                 case edsInt8:                 case edsInt9:                 case edsInt10:                 case edsInt11:                 case edsInt12:                 case edsInt13:                 case edsInt14:                 case edsInt15:                 case edsInt16:                 case edsInt17:                 case edsInt18:                 case edsInt19:                 case edsInt20:                 case edsInt21:                 case edsInt22:                 case edsInt23:                 case edsInt24:                 case edsInt25:                 case edsInt26:                 case edsInt27:                 case edsInt28:                 case edsInt29:                 case edsInt30:                 case edsInt31:                     integer32 = code - edsInt0;                     scale = 0;                     type = edsTypeInt32;                     break;                  case edsIntLen1:                     type = edsTypeInt32;                     scale = 0;                     integer32 = (sbyte)source[offset++];                     break;                  case edsIntLen2:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset] << 8) | (source[offset + 1] & 0xff);                     offset += 2;                     break;                  case edsIntLen3:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset]) << 16 | (source[offset + 1] & 0xff) << 8 | (source[offset + 2] & 0xff);                     offset += 3;                     break;                  case edsIntLen4:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset]) << 24 | (source[offset + 1] & 0xff) << 16 | (source[offset + 2] & 0xff) << 8 | (source[offset + 3] & 0xff);                     offset += 4;                     break;                  case edsIntLen5:                 case edsIntLen6:                 case edsIntLen7:                 case edsIntLen8:                     l = code - edsIntLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeInt64;                     break;                  case edsScaledLen0:                     scale = (sbyte)source[offset++];                     integer64 = 0;                     type = edsTypeScaled;                     break;                  case edsScaledLen1:                 case edsScaledLen2:                 case edsScaledLen3:                 case edsScaledLen4:                 case edsScaledLen5:                 case edsScaledLen6:                 case edsScaledLen7:                 case edsScaledLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaled;                     break;                  case edsUtf8Len0:                 case edsUtf8Len1:                 case edsUtf8Len2:                 case edsUtf8Len3:                 case edsUtf8Len4:                 case edsUtf8Len5:                 case edsUtf8Len6:                 case edsUtf8Len7:                 case edsUtf8Len8:                 case edsUtf8Len9:                 case edsUtf8Len10:                 case edsUtf8Len11:                 case edsUtf8Len12:                 case edsUtf8Len13:                 case edsUtf8Len14:                 case edsUtf8Len15:                 case edsUtf8Len16:                 case edsUtf8Len17:                 case edsUtf8Len18:                 case edsUtf8Len19:                 case edsUtf8Len20:                 case edsUtf8Len21:                 case edsUtf8Len22:                 case edsUtf8Len23:                 case edsUtf8Len24:                 case edsUtf8Len25:                 case edsUtf8Len26:                 case edsUtf8Len27:                 case edsUtf8Len28:                 case edsUtf8Len29:                 case edsUtf8Len30:                 case edsUtf8Len31:                 case edsUtf8Len32:                 case edsUtf8Len33:                 case edsUtf8Len34:                 case edsUtf8Len35:                 case edsUtf8Len36:                 case edsUtf8Len37:                 case edsUtf8Len38:                 case edsUtf8Len39:                     l = code - edsUtf8Len0;                     @string = getString(source' offset' l);                     offset += l;                     type = edsTypeUtf8;                     break;                  case edsUtf8Count1:                 case edsUtf8Count2:                 case edsUtf8Count3:                 case edsUtf8Count4:                     count = code - edsUtf8Count1;                     int length = source[offset++] & 0xff;                      for (int n = 0; n < count; ++n)                     {                         length = length << 8 | (source[offset++] & 0xff);                     }                      @string = getString(source' offset' length);                     offset += length;                     type = edsTypeUtf8;                     break;                  case edsOpaqueLen0:                 case edsOpaqueLen1:                 case edsOpaqueLen2:                 case edsOpaqueLen3:                 case edsOpaqueLen4:                 case edsOpaqueLen5:                 case edsOpaqueLen6:                 case edsOpaqueLen7:                 case edsOpaqueLen8:                 case edsOpaqueLen9:                 case edsOpaqueLen10:                 case edsOpaqueLen11:                 case edsOpaqueLen12:                 case edsOpaqueLen13:                 case edsOpaqueLen14:                 case edsOpaqueLen15:                 case edsOpaqueLen16:                 case edsOpaqueLen17:                 case edsOpaqueLen18:                 case edsOpaqueLen19:                 case edsOpaqueLen20:                 case edsOpaqueLen21:                 case edsOpaqueLen22:                 case edsOpaqueLen23:                 case edsOpaqueLen24:                 case edsOpaqueLen25:                 case edsOpaqueLen26:                 case edsOpaqueLen27:                 case edsOpaqueLen28:                 case edsOpaqueLen29:                 case edsOpaqueLen30:                 case edsOpaqueLen31:                 case edsOpaqueLen32:                 case edsOpaqueLen33:                 case edsOpaqueLen34:                 case edsOpaqueLen35:                 case edsOpaqueLen36:                 case edsOpaqueLen37:                 case edsOpaqueLen38:                 case edsOpaqueLen39:                     l = code - edsOpaqueLen0;                     bytes = new byte[l];                     Array.Copy(source' offset' bytes' 0' l);                     offset += l;                     type = edsTypeOpaque;                     break;                  case edsOpaqueCount1:                 case edsOpaqueCount2:                 case edsOpaqueCount3:                 case edsOpaqueCount4:                     count = code - edsOpaqueCount1 + 1;                     l = source[offset++] & 0xff;                      for (int n = 1; n < count; ++n)                     {                         l = l << 8 | (source[offset++] & 0xff);                     }                      bytes = new byte[l];                     Array.Copy(source' offset' bytes' 0' l);                     offset += l;                     type = edsTypeOpaque;                     break;                  case edsDoubleLen0:                 case edsDoubleLen1:                 case edsDoubleLen2:                 case edsDoubleLen3:                 case edsDoubleLen4:                 case edsDoubleLen5:                 case edsDoubleLen6:                 case edsDoubleLen7:                 case edsDoubleLen8:                     count = code - edsDoubleLen0;                     long lvalue = 0;                      for (int n = 0; n < count; ++n)                     {                         lvalue = (lvalue << 8) | (source[offset++] & 0xff);                     }                      lvalue <<= (8 - count) * 8;                     dbl = BitConverter.Int64BitsToDouble(lvalue);                     type = edsTypeDouble;                     break;                  case edsTimeLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeTime;                     break;                  case edsTimeLen1:                 case edsTimeLen2:                 case edsTimeLen3:                 case edsTimeLen4:                     l = code - edsTimeLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeTime;                     break;                  case edsMilliSecLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeMilliseconds;                     break;                  case edsMilliSecLen1:                 case edsMilliSecLen2:                 case edsMilliSecLen3:                 case edsMilliSecLen4:                 case edsMilliSecLen5:                 case edsMilliSecLen6:                 case edsMilliSecLen7:                 case edsMilliSecLen8:                     l = code - edsMilliSecLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeMilliseconds;                     break;                  case edsNanoSecLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeNanoseconds;                     break;                  case edsNanoSecLen1:                 case edsNanoSecLen2:                 case edsNanoSecLen3:                 case edsNanoSecLen4:                 case edsNanoSecLen5:                 case edsNanoSecLen6:                 case edsNanoSecLen7:                 case edsNanoSecLen8:                     l = code - edsNanoSecLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeNanoseconds;                     break;                  //                 // 09/2012 Added support for new scaled date/times encoding. These replace the old encoding                 // edsTimeLen' edsMilliSecLen and edsNanoSecLen.                 //                  case edsScaledTimeLen1:                 case edsScaledTimeLen2:                 case edsScaledTimeLen3:                 case edsScaledTimeLen4:                 case edsScaledTimeLen5:                 case edsScaledTimeLen6:                 case edsScaledTimeLen7:                 case edsScaledTimeLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledTimeLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledTime;                     break;                  case edsScaledDateLen1:                 case edsScaledDateLen2:                 case edsScaledDateLen3:                 case edsScaledDateLen4:                 case edsScaledDateLen5:                 case edsScaledDateLen6:                 case edsScaledDateLen7:                 case edsScaledDateLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledDateLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledDate;                     break;                  case edsScaledTimestampLen1:                 case edsScaledTimestampLen2:                 case edsScaledTimestampLen3:                 case edsScaledTimestampLen4:                 case edsScaledTimestampLen5:                 case edsScaledTimestampLen6:                 case edsScaledTimestampLen7:                 case edsScaledTimestampLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledTimestampLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledTimestamp;                     break;                  case edsClobLen0:                     blobId = 0;                     type = edsTypeClob;                     break;                  case edsClobLen1:                 case edsClobLen2:                 case edsClobLen3:                 case edsClobLen4:                     l = code - edsClobLen1;                     blobId = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         blobId = (blobId << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeClob;                     break;                  case edsBlobLen0:                     blobId = 0;                     type = edsTypeBlob;                     break;                  case edsBlobLen1:                 case edsBlobLen2:                 case edsBlobLen3:                 case edsBlobLen4:                     l = code - edsBlobLen1;                     blobId = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         blobId = (blobId << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeBlob;                     break;                  case edsScaledCount1:                     {                         // For some reason C++ EncodedStream expects the encoded                         // length to be length+1.                          length = (source[offset++] & 0xff) - 1;                         scale = (sbyte)source[offset++];                         type = edsTypeBigInt;                         bytes = new byte[length];                         Array.Copy(source' offset' bytes' 0' length);                         offset += length;                         int sign = ((bytes[0] & 0x80) > 0) ? -1 : 1;                          if (sign == -1)                         {                             bytes[0] &= 0x7f;                         }                          BigInteger bi = new BigInteger(bytes);                         bigDecimal = Decimal.Parse(bi.ToString());                     }                     break;                  case edsScaledCount2:                     {                         // For some reason C++ EncodedStream expects the encoded                         // length to be length+1.                          scale = (sbyte)source[offset++];                         sbyte sign = (sbyte)source[offset++];                         length = (source[offset++] & 0xff); // in bytes                         type = edsTypeBigInt;                         bytes = new byte[length];                         Array.Copy(source' offset' bytes' 0' length);                         offset += length;                          if (sign == -1)                             bytes[0] &= 0x7f;                         else                             sign = 1;                          BigInteger bi = new BigInteger(bytes);                         if (sign == -1)                             bi = -bi;                         bigDecimal = ScaleDecimal(Decimal.Parse(bi.ToString())' scale);                     }                     break;                  case edsUUID:                     {                         byte[] buff = new byte[16];                          for (int n = 0; n < 16; ++n)                         {                             buff[n] = (byte)(source[offset++] & 0xff);                         }                          uuid = new Guid(buff);                         type = edsTypeUUID;                     }                     break;                  default:                     type = edsTypeUnknown;                     break;             }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,decode,The following statement contains a magic number: switch (code)             {                 case edsNull:                     type = edsTypeNull;                     break;                  case edsTrue:                     type = edsTypeBoolean;                     @bool = true;                     break;                  case edsFalse:                     type = edsTypeBoolean;                     @bool = false;                     break;                  case edsIntMinus10:                 case edsIntMinus9:                 case edsIntMinus8:                 case edsIntMinus7:                 case edsIntMinus6:                 case edsIntMinus5:                 case edsIntMinus4:                 case edsIntMinus3:                 case edsIntMinus2:                 case edsIntMinus1:                 case edsInt0:                 case edsInt1:                 case edsInt2:                 case edsInt3:                 case edsInt4:                 case edsInt5:                 case edsInt6:                 case edsInt7:                 case edsInt8:                 case edsInt9:                 case edsInt10:                 case edsInt11:                 case edsInt12:                 case edsInt13:                 case edsInt14:                 case edsInt15:                 case edsInt16:                 case edsInt17:                 case edsInt18:                 case edsInt19:                 case edsInt20:                 case edsInt21:                 case edsInt22:                 case edsInt23:                 case edsInt24:                 case edsInt25:                 case edsInt26:                 case edsInt27:                 case edsInt28:                 case edsInt29:                 case edsInt30:                 case edsInt31:                     integer32 = code - edsInt0;                     scale = 0;                     type = edsTypeInt32;                     break;                  case edsIntLen1:                     type = edsTypeInt32;                     scale = 0;                     integer32 = (sbyte)source[offset++];                     break;                  case edsIntLen2:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset] << 8) | (source[offset + 1] & 0xff);                     offset += 2;                     break;                  case edsIntLen3:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset]) << 16 | (source[offset + 1] & 0xff) << 8 | (source[offset + 2] & 0xff);                     offset += 3;                     break;                  case edsIntLen4:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset]) << 24 | (source[offset + 1] & 0xff) << 16 | (source[offset + 2] & 0xff) << 8 | (source[offset + 3] & 0xff);                     offset += 4;                     break;                  case edsIntLen5:                 case edsIntLen6:                 case edsIntLen7:                 case edsIntLen8:                     l = code - edsIntLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeInt64;                     break;                  case edsScaledLen0:                     scale = (sbyte)source[offset++];                     integer64 = 0;                     type = edsTypeScaled;                     break;                  case edsScaledLen1:                 case edsScaledLen2:                 case edsScaledLen3:                 case edsScaledLen4:                 case edsScaledLen5:                 case edsScaledLen6:                 case edsScaledLen7:                 case edsScaledLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaled;                     break;                  case edsUtf8Len0:                 case edsUtf8Len1:                 case edsUtf8Len2:                 case edsUtf8Len3:                 case edsUtf8Len4:                 case edsUtf8Len5:                 case edsUtf8Len6:                 case edsUtf8Len7:                 case edsUtf8Len8:                 case edsUtf8Len9:                 case edsUtf8Len10:                 case edsUtf8Len11:                 case edsUtf8Len12:                 case edsUtf8Len13:                 case edsUtf8Len14:                 case edsUtf8Len15:                 case edsUtf8Len16:                 case edsUtf8Len17:                 case edsUtf8Len18:                 case edsUtf8Len19:                 case edsUtf8Len20:                 case edsUtf8Len21:                 case edsUtf8Len22:                 case edsUtf8Len23:                 case edsUtf8Len24:                 case edsUtf8Len25:                 case edsUtf8Len26:                 case edsUtf8Len27:                 case edsUtf8Len28:                 case edsUtf8Len29:                 case edsUtf8Len30:                 case edsUtf8Len31:                 case edsUtf8Len32:                 case edsUtf8Len33:                 case edsUtf8Len34:                 case edsUtf8Len35:                 case edsUtf8Len36:                 case edsUtf8Len37:                 case edsUtf8Len38:                 case edsUtf8Len39:                     l = code - edsUtf8Len0;                     @string = getString(source' offset' l);                     offset += l;                     type = edsTypeUtf8;                     break;                  case edsUtf8Count1:                 case edsUtf8Count2:                 case edsUtf8Count3:                 case edsUtf8Count4:                     count = code - edsUtf8Count1;                     int length = source[offset++] & 0xff;                      for (int n = 0; n < count; ++n)                     {                         length = length << 8 | (source[offset++] & 0xff);                     }                      @string = getString(source' offset' length);                     offset += length;                     type = edsTypeUtf8;                     break;                  case edsOpaqueLen0:                 case edsOpaqueLen1:                 case edsOpaqueLen2:                 case edsOpaqueLen3:                 case edsOpaqueLen4:                 case edsOpaqueLen5:                 case edsOpaqueLen6:                 case edsOpaqueLen7:                 case edsOpaqueLen8:                 case edsOpaqueLen9:                 case edsOpaqueLen10:                 case edsOpaqueLen11:                 case edsOpaqueLen12:                 case edsOpaqueLen13:                 case edsOpaqueLen14:                 case edsOpaqueLen15:                 case edsOpaqueLen16:                 case edsOpaqueLen17:                 case edsOpaqueLen18:                 case edsOpaqueLen19:                 case edsOpaqueLen20:                 case edsOpaqueLen21:                 case edsOpaqueLen22:                 case edsOpaqueLen23:                 case edsOpaqueLen24:                 case edsOpaqueLen25:                 case edsOpaqueLen26:                 case edsOpaqueLen27:                 case edsOpaqueLen28:                 case edsOpaqueLen29:                 case edsOpaqueLen30:                 case edsOpaqueLen31:                 case edsOpaqueLen32:                 case edsOpaqueLen33:                 case edsOpaqueLen34:                 case edsOpaqueLen35:                 case edsOpaqueLen36:                 case edsOpaqueLen37:                 case edsOpaqueLen38:                 case edsOpaqueLen39:                     l = code - edsOpaqueLen0;                     bytes = new byte[l];                     Array.Copy(source' offset' bytes' 0' l);                     offset += l;                     type = edsTypeOpaque;                     break;                  case edsOpaqueCount1:                 case edsOpaqueCount2:                 case edsOpaqueCount3:                 case edsOpaqueCount4:                     count = code - edsOpaqueCount1 + 1;                     l = source[offset++] & 0xff;                      for (int n = 1; n < count; ++n)                     {                         l = l << 8 | (source[offset++] & 0xff);                     }                      bytes = new byte[l];                     Array.Copy(source' offset' bytes' 0' l);                     offset += l;                     type = edsTypeOpaque;                     break;                  case edsDoubleLen0:                 case edsDoubleLen1:                 case edsDoubleLen2:                 case edsDoubleLen3:                 case edsDoubleLen4:                 case edsDoubleLen5:                 case edsDoubleLen6:                 case edsDoubleLen7:                 case edsDoubleLen8:                     count = code - edsDoubleLen0;                     long lvalue = 0;                      for (int n = 0; n < count; ++n)                     {                         lvalue = (lvalue << 8) | (source[offset++] & 0xff);                     }                      lvalue <<= (8 - count) * 8;                     dbl = BitConverter.Int64BitsToDouble(lvalue);                     type = edsTypeDouble;                     break;                  case edsTimeLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeTime;                     break;                  case edsTimeLen1:                 case edsTimeLen2:                 case edsTimeLen3:                 case edsTimeLen4:                     l = code - edsTimeLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeTime;                     break;                  case edsMilliSecLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeMilliseconds;                     break;                  case edsMilliSecLen1:                 case edsMilliSecLen2:                 case edsMilliSecLen3:                 case edsMilliSecLen4:                 case edsMilliSecLen5:                 case edsMilliSecLen6:                 case edsMilliSecLen7:                 case edsMilliSecLen8:                     l = code - edsMilliSecLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeMilliseconds;                     break;                  case edsNanoSecLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeNanoseconds;                     break;                  case edsNanoSecLen1:                 case edsNanoSecLen2:                 case edsNanoSecLen3:                 case edsNanoSecLen4:                 case edsNanoSecLen5:                 case edsNanoSecLen6:                 case edsNanoSecLen7:                 case edsNanoSecLen8:                     l = code - edsNanoSecLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeNanoseconds;                     break;                  //                 // 09/2012 Added support for new scaled date/times encoding. These replace the old encoding                 // edsTimeLen' edsMilliSecLen and edsNanoSecLen.                 //                  case edsScaledTimeLen1:                 case edsScaledTimeLen2:                 case edsScaledTimeLen3:                 case edsScaledTimeLen4:                 case edsScaledTimeLen5:                 case edsScaledTimeLen6:                 case edsScaledTimeLen7:                 case edsScaledTimeLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledTimeLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledTime;                     break;                  case edsScaledDateLen1:                 case edsScaledDateLen2:                 case edsScaledDateLen3:                 case edsScaledDateLen4:                 case edsScaledDateLen5:                 case edsScaledDateLen6:                 case edsScaledDateLen7:                 case edsScaledDateLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledDateLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledDate;                     break;                  case edsScaledTimestampLen1:                 case edsScaledTimestampLen2:                 case edsScaledTimestampLen3:                 case edsScaledTimestampLen4:                 case edsScaledTimestampLen5:                 case edsScaledTimestampLen6:                 case edsScaledTimestampLen7:                 case edsScaledTimestampLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledTimestampLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledTimestamp;                     break;                  case edsClobLen0:                     blobId = 0;                     type = edsTypeClob;                     break;                  case edsClobLen1:                 case edsClobLen2:                 case edsClobLen3:                 case edsClobLen4:                     l = code - edsClobLen1;                     blobId = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         blobId = (blobId << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeClob;                     break;                  case edsBlobLen0:                     blobId = 0;                     type = edsTypeBlob;                     break;                  case edsBlobLen1:                 case edsBlobLen2:                 case edsBlobLen3:                 case edsBlobLen4:                     l = code - edsBlobLen1;                     blobId = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         blobId = (blobId << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeBlob;                     break;                  case edsScaledCount1:                     {                         // For some reason C++ EncodedStream expects the encoded                         // length to be length+1.                          length = (source[offset++] & 0xff) - 1;                         scale = (sbyte)source[offset++];                         type = edsTypeBigInt;                         bytes = new byte[length];                         Array.Copy(source' offset' bytes' 0' length);                         offset += length;                         int sign = ((bytes[0] & 0x80) > 0) ? -1 : 1;                          if (sign == -1)                         {                             bytes[0] &= 0x7f;                         }                          BigInteger bi = new BigInteger(bytes);                         bigDecimal = Decimal.Parse(bi.ToString());                     }                     break;                  case edsScaledCount2:                     {                         // For some reason C++ EncodedStream expects the encoded                         // length to be length+1.                          scale = (sbyte)source[offset++];                         sbyte sign = (sbyte)source[offset++];                         length = (source[offset++] & 0xff); // in bytes                         type = edsTypeBigInt;                         bytes = new byte[length];                         Array.Copy(source' offset' bytes' 0' length);                         offset += length;                          if (sign == -1)                             bytes[0] &= 0x7f;                         else                             sign = 1;                          BigInteger bi = new BigInteger(bytes);                         if (sign == -1)                             bi = -bi;                         bigDecimal = ScaleDecimal(Decimal.Parse(bi.ToString())' scale);                     }                     break;                  case edsUUID:                     {                         byte[] buff = new byte[16];                          for (int n = 0; n < 16; ++n)                         {                             buff[n] = (byte)(source[offset++] & 0xff);                         }                          uuid = new Guid(buff);                         type = edsTypeUUID;                     }                     break;                  default:                     type = edsTypeUnknown;                     break;             }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,decode,The following statement contains a magic number: switch (code)             {                 case edsNull:                     type = edsTypeNull;                     break;                  case edsTrue:                     type = edsTypeBoolean;                     @bool = true;                     break;                  case edsFalse:                     type = edsTypeBoolean;                     @bool = false;                     break;                  case edsIntMinus10:                 case edsIntMinus9:                 case edsIntMinus8:                 case edsIntMinus7:                 case edsIntMinus6:                 case edsIntMinus5:                 case edsIntMinus4:                 case edsIntMinus3:                 case edsIntMinus2:                 case edsIntMinus1:                 case edsInt0:                 case edsInt1:                 case edsInt2:                 case edsInt3:                 case edsInt4:                 case edsInt5:                 case edsInt6:                 case edsInt7:                 case edsInt8:                 case edsInt9:                 case edsInt10:                 case edsInt11:                 case edsInt12:                 case edsInt13:                 case edsInt14:                 case edsInt15:                 case edsInt16:                 case edsInt17:                 case edsInt18:                 case edsInt19:                 case edsInt20:                 case edsInt21:                 case edsInt22:                 case edsInt23:                 case edsInt24:                 case edsInt25:                 case edsInt26:                 case edsInt27:                 case edsInt28:                 case edsInt29:                 case edsInt30:                 case edsInt31:                     integer32 = code - edsInt0;                     scale = 0;                     type = edsTypeInt32;                     break;                  case edsIntLen1:                     type = edsTypeInt32;                     scale = 0;                     integer32 = (sbyte)source[offset++];                     break;                  case edsIntLen2:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset] << 8) | (source[offset + 1] & 0xff);                     offset += 2;                     break;                  case edsIntLen3:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset]) << 16 | (source[offset + 1] & 0xff) << 8 | (source[offset + 2] & 0xff);                     offset += 3;                     break;                  case edsIntLen4:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset]) << 24 | (source[offset + 1] & 0xff) << 16 | (source[offset + 2] & 0xff) << 8 | (source[offset + 3] & 0xff);                     offset += 4;                     break;                  case edsIntLen5:                 case edsIntLen6:                 case edsIntLen7:                 case edsIntLen8:                     l = code - edsIntLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeInt64;                     break;                  case edsScaledLen0:                     scale = (sbyte)source[offset++];                     integer64 = 0;                     type = edsTypeScaled;                     break;                  case edsScaledLen1:                 case edsScaledLen2:                 case edsScaledLen3:                 case edsScaledLen4:                 case edsScaledLen5:                 case edsScaledLen6:                 case edsScaledLen7:                 case edsScaledLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaled;                     break;                  case edsUtf8Len0:                 case edsUtf8Len1:                 case edsUtf8Len2:                 case edsUtf8Len3:                 case edsUtf8Len4:                 case edsUtf8Len5:                 case edsUtf8Len6:                 case edsUtf8Len7:                 case edsUtf8Len8:                 case edsUtf8Len9:                 case edsUtf8Len10:                 case edsUtf8Len11:                 case edsUtf8Len12:                 case edsUtf8Len13:                 case edsUtf8Len14:                 case edsUtf8Len15:                 case edsUtf8Len16:                 case edsUtf8Len17:                 case edsUtf8Len18:                 case edsUtf8Len19:                 case edsUtf8Len20:                 case edsUtf8Len21:                 case edsUtf8Len22:                 case edsUtf8Len23:                 case edsUtf8Len24:                 case edsUtf8Len25:                 case edsUtf8Len26:                 case edsUtf8Len27:                 case edsUtf8Len28:                 case edsUtf8Len29:                 case edsUtf8Len30:                 case edsUtf8Len31:                 case edsUtf8Len32:                 case edsUtf8Len33:                 case edsUtf8Len34:                 case edsUtf8Len35:                 case edsUtf8Len36:                 case edsUtf8Len37:                 case edsUtf8Len38:                 case edsUtf8Len39:                     l = code - edsUtf8Len0;                     @string = getString(source' offset' l);                     offset += l;                     type = edsTypeUtf8;                     break;                  case edsUtf8Count1:                 case edsUtf8Count2:                 case edsUtf8Count3:                 case edsUtf8Count4:                     count = code - edsUtf8Count1;                     int length = source[offset++] & 0xff;                      for (int n = 0; n < count; ++n)                     {                         length = length << 8 | (source[offset++] & 0xff);                     }                      @string = getString(source' offset' length);                     offset += length;                     type = edsTypeUtf8;                     break;                  case edsOpaqueLen0:                 case edsOpaqueLen1:                 case edsOpaqueLen2:                 case edsOpaqueLen3:                 case edsOpaqueLen4:                 case edsOpaqueLen5:                 case edsOpaqueLen6:                 case edsOpaqueLen7:                 case edsOpaqueLen8:                 case edsOpaqueLen9:                 case edsOpaqueLen10:                 case edsOpaqueLen11:                 case edsOpaqueLen12:                 case edsOpaqueLen13:                 case edsOpaqueLen14:                 case edsOpaqueLen15:                 case edsOpaqueLen16:                 case edsOpaqueLen17:                 case edsOpaqueLen18:                 case edsOpaqueLen19:                 case edsOpaqueLen20:                 case edsOpaqueLen21:                 case edsOpaqueLen22:                 case edsOpaqueLen23:                 case edsOpaqueLen24:                 case edsOpaqueLen25:                 case edsOpaqueLen26:                 case edsOpaqueLen27:                 case edsOpaqueLen28:                 case edsOpaqueLen29:                 case edsOpaqueLen30:                 case edsOpaqueLen31:                 case edsOpaqueLen32:                 case edsOpaqueLen33:                 case edsOpaqueLen34:                 case edsOpaqueLen35:                 case edsOpaqueLen36:                 case edsOpaqueLen37:                 case edsOpaqueLen38:                 case edsOpaqueLen39:                     l = code - edsOpaqueLen0;                     bytes = new byte[l];                     Array.Copy(source' offset' bytes' 0' l);                     offset += l;                     type = edsTypeOpaque;                     break;                  case edsOpaqueCount1:                 case edsOpaqueCount2:                 case edsOpaqueCount3:                 case edsOpaqueCount4:                     count = code - edsOpaqueCount1 + 1;                     l = source[offset++] & 0xff;                      for (int n = 1; n < count; ++n)                     {                         l = l << 8 | (source[offset++] & 0xff);                     }                      bytes = new byte[l];                     Array.Copy(source' offset' bytes' 0' l);                     offset += l;                     type = edsTypeOpaque;                     break;                  case edsDoubleLen0:                 case edsDoubleLen1:                 case edsDoubleLen2:                 case edsDoubleLen3:                 case edsDoubleLen4:                 case edsDoubleLen5:                 case edsDoubleLen6:                 case edsDoubleLen7:                 case edsDoubleLen8:                     count = code - edsDoubleLen0;                     long lvalue = 0;                      for (int n = 0; n < count; ++n)                     {                         lvalue = (lvalue << 8) | (source[offset++] & 0xff);                     }                      lvalue <<= (8 - count) * 8;                     dbl = BitConverter.Int64BitsToDouble(lvalue);                     type = edsTypeDouble;                     break;                  case edsTimeLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeTime;                     break;                  case edsTimeLen1:                 case edsTimeLen2:                 case edsTimeLen3:                 case edsTimeLen4:                     l = code - edsTimeLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeTime;                     break;                  case edsMilliSecLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeMilliseconds;                     break;                  case edsMilliSecLen1:                 case edsMilliSecLen2:                 case edsMilliSecLen3:                 case edsMilliSecLen4:                 case edsMilliSecLen5:                 case edsMilliSecLen6:                 case edsMilliSecLen7:                 case edsMilliSecLen8:                     l = code - edsMilliSecLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeMilliseconds;                     break;                  case edsNanoSecLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeNanoseconds;                     break;                  case edsNanoSecLen1:                 case edsNanoSecLen2:                 case edsNanoSecLen3:                 case edsNanoSecLen4:                 case edsNanoSecLen5:                 case edsNanoSecLen6:                 case edsNanoSecLen7:                 case edsNanoSecLen8:                     l = code - edsNanoSecLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeNanoseconds;                     break;                  //                 // 09/2012 Added support for new scaled date/times encoding. These replace the old encoding                 // edsTimeLen' edsMilliSecLen and edsNanoSecLen.                 //                  case edsScaledTimeLen1:                 case edsScaledTimeLen2:                 case edsScaledTimeLen3:                 case edsScaledTimeLen4:                 case edsScaledTimeLen5:                 case edsScaledTimeLen6:                 case edsScaledTimeLen7:                 case edsScaledTimeLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledTimeLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledTime;                     break;                  case edsScaledDateLen1:                 case edsScaledDateLen2:                 case edsScaledDateLen3:                 case edsScaledDateLen4:                 case edsScaledDateLen5:                 case edsScaledDateLen6:                 case edsScaledDateLen7:                 case edsScaledDateLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledDateLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledDate;                     break;                  case edsScaledTimestampLen1:                 case edsScaledTimestampLen2:                 case edsScaledTimestampLen3:                 case edsScaledTimestampLen4:                 case edsScaledTimestampLen5:                 case edsScaledTimestampLen6:                 case edsScaledTimestampLen7:                 case edsScaledTimestampLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledTimestampLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledTimestamp;                     break;                  case edsClobLen0:                     blobId = 0;                     type = edsTypeClob;                     break;                  case edsClobLen1:                 case edsClobLen2:                 case edsClobLen3:                 case edsClobLen4:                     l = code - edsClobLen1;                     blobId = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         blobId = (blobId << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeClob;                     break;                  case edsBlobLen0:                     blobId = 0;                     type = edsTypeBlob;                     break;                  case edsBlobLen1:                 case edsBlobLen2:                 case edsBlobLen3:                 case edsBlobLen4:                     l = code - edsBlobLen1;                     blobId = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         blobId = (blobId << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeBlob;                     break;                  case edsScaledCount1:                     {                         // For some reason C++ EncodedStream expects the encoded                         // length to be length+1.                          length = (source[offset++] & 0xff) - 1;                         scale = (sbyte)source[offset++];                         type = edsTypeBigInt;                         bytes = new byte[length];                         Array.Copy(source' offset' bytes' 0' length);                         offset += length;                         int sign = ((bytes[0] & 0x80) > 0) ? -1 : 1;                          if (sign == -1)                         {                             bytes[0] &= 0x7f;                         }                          BigInteger bi = new BigInteger(bytes);                         bigDecimal = Decimal.Parse(bi.ToString());                     }                     break;                  case edsScaledCount2:                     {                         // For some reason C++ EncodedStream expects the encoded                         // length to be length+1.                          scale = (sbyte)source[offset++];                         sbyte sign = (sbyte)source[offset++];                         length = (source[offset++] & 0xff); // in bytes                         type = edsTypeBigInt;                         bytes = new byte[length];                         Array.Copy(source' offset' bytes' 0' length);                         offset += length;                          if (sign == -1)                             bytes[0] &= 0x7f;                         else                             sign = 1;                          BigInteger bi = new BigInteger(bytes);                         if (sign == -1)                             bi = -bi;                         bigDecimal = ScaleDecimal(Decimal.Parse(bi.ToString())' scale);                     }                     break;                  case edsUUID:                     {                         byte[] buff = new byte[16];                          for (int n = 0; n < 16; ++n)                         {                             buff[n] = (byte)(source[offset++] & 0xff);                         }                          uuid = new Guid(buff);                         type = edsTypeUUID;                     }                     break;                  default:                     type = edsTypeUnknown;                     break;             }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,decode,The following statement contains a magic number: switch (code)             {                 case edsNull:                     type = edsTypeNull;                     break;                  case edsTrue:                     type = edsTypeBoolean;                     @bool = true;                     break;                  case edsFalse:                     type = edsTypeBoolean;                     @bool = false;                     break;                  case edsIntMinus10:                 case edsIntMinus9:                 case edsIntMinus8:                 case edsIntMinus7:                 case edsIntMinus6:                 case edsIntMinus5:                 case edsIntMinus4:                 case edsIntMinus3:                 case edsIntMinus2:                 case edsIntMinus1:                 case edsInt0:                 case edsInt1:                 case edsInt2:                 case edsInt3:                 case edsInt4:                 case edsInt5:                 case edsInt6:                 case edsInt7:                 case edsInt8:                 case edsInt9:                 case edsInt10:                 case edsInt11:                 case edsInt12:                 case edsInt13:                 case edsInt14:                 case edsInt15:                 case edsInt16:                 case edsInt17:                 case edsInt18:                 case edsInt19:                 case edsInt20:                 case edsInt21:                 case edsInt22:                 case edsInt23:                 case edsInt24:                 case edsInt25:                 case edsInt26:                 case edsInt27:                 case edsInt28:                 case edsInt29:                 case edsInt30:                 case edsInt31:                     integer32 = code - edsInt0;                     scale = 0;                     type = edsTypeInt32;                     break;                  case edsIntLen1:                     type = edsTypeInt32;                     scale = 0;                     integer32 = (sbyte)source[offset++];                     break;                  case edsIntLen2:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset] << 8) | (source[offset + 1] & 0xff);                     offset += 2;                     break;                  case edsIntLen3:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset]) << 16 | (source[offset + 1] & 0xff) << 8 | (source[offset + 2] & 0xff);                     offset += 3;                     break;                  case edsIntLen4:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset]) << 24 | (source[offset + 1] & 0xff) << 16 | (source[offset + 2] & 0xff) << 8 | (source[offset + 3] & 0xff);                     offset += 4;                     break;                  case edsIntLen5:                 case edsIntLen6:                 case edsIntLen7:                 case edsIntLen8:                     l = code - edsIntLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeInt64;                     break;                  case edsScaledLen0:                     scale = (sbyte)source[offset++];                     integer64 = 0;                     type = edsTypeScaled;                     break;                  case edsScaledLen1:                 case edsScaledLen2:                 case edsScaledLen3:                 case edsScaledLen4:                 case edsScaledLen5:                 case edsScaledLen6:                 case edsScaledLen7:                 case edsScaledLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaled;                     break;                  case edsUtf8Len0:                 case edsUtf8Len1:                 case edsUtf8Len2:                 case edsUtf8Len3:                 case edsUtf8Len4:                 case edsUtf8Len5:                 case edsUtf8Len6:                 case edsUtf8Len7:                 case edsUtf8Len8:                 case edsUtf8Len9:                 case edsUtf8Len10:                 case edsUtf8Len11:                 case edsUtf8Len12:                 case edsUtf8Len13:                 case edsUtf8Len14:                 case edsUtf8Len15:                 case edsUtf8Len16:                 case edsUtf8Len17:                 case edsUtf8Len18:                 case edsUtf8Len19:                 case edsUtf8Len20:                 case edsUtf8Len21:                 case edsUtf8Len22:                 case edsUtf8Len23:                 case edsUtf8Len24:                 case edsUtf8Len25:                 case edsUtf8Len26:                 case edsUtf8Len27:                 case edsUtf8Len28:                 case edsUtf8Len29:                 case edsUtf8Len30:                 case edsUtf8Len31:                 case edsUtf8Len32:                 case edsUtf8Len33:                 case edsUtf8Len34:                 case edsUtf8Len35:                 case edsUtf8Len36:                 case edsUtf8Len37:                 case edsUtf8Len38:                 case edsUtf8Len39:                     l = code - edsUtf8Len0;                     @string = getString(source' offset' l);                     offset += l;                     type = edsTypeUtf8;                     break;                  case edsUtf8Count1:                 case edsUtf8Count2:                 case edsUtf8Count3:                 case edsUtf8Count4:                     count = code - edsUtf8Count1;                     int length = source[offset++] & 0xff;                      for (int n = 0; n < count; ++n)                     {                         length = length << 8 | (source[offset++] & 0xff);                     }                      @string = getString(source' offset' length);                     offset += length;                     type = edsTypeUtf8;                     break;                  case edsOpaqueLen0:                 case edsOpaqueLen1:                 case edsOpaqueLen2:                 case edsOpaqueLen3:                 case edsOpaqueLen4:                 case edsOpaqueLen5:                 case edsOpaqueLen6:                 case edsOpaqueLen7:                 case edsOpaqueLen8:                 case edsOpaqueLen9:                 case edsOpaqueLen10:                 case edsOpaqueLen11:                 case edsOpaqueLen12:                 case edsOpaqueLen13:                 case edsOpaqueLen14:                 case edsOpaqueLen15:                 case edsOpaqueLen16:                 case edsOpaqueLen17:                 case edsOpaqueLen18:                 case edsOpaqueLen19:                 case edsOpaqueLen20:                 case edsOpaqueLen21:                 case edsOpaqueLen22:                 case edsOpaqueLen23:                 case edsOpaqueLen24:                 case edsOpaqueLen25:                 case edsOpaqueLen26:                 case edsOpaqueLen27:                 case edsOpaqueLen28:                 case edsOpaqueLen29:                 case edsOpaqueLen30:                 case edsOpaqueLen31:                 case edsOpaqueLen32:                 case edsOpaqueLen33:                 case edsOpaqueLen34:                 case edsOpaqueLen35:                 case edsOpaqueLen36:                 case edsOpaqueLen37:                 case edsOpaqueLen38:                 case edsOpaqueLen39:                     l = code - edsOpaqueLen0;                     bytes = new byte[l];                     Array.Copy(source' offset' bytes' 0' l);                     offset += l;                     type = edsTypeOpaque;                     break;                  case edsOpaqueCount1:                 case edsOpaqueCount2:                 case edsOpaqueCount3:                 case edsOpaqueCount4:                     count = code - edsOpaqueCount1 + 1;                     l = source[offset++] & 0xff;                      for (int n = 1; n < count; ++n)                     {                         l = l << 8 | (source[offset++] & 0xff);                     }                      bytes = new byte[l];                     Array.Copy(source' offset' bytes' 0' l);                     offset += l;                     type = edsTypeOpaque;                     break;                  case edsDoubleLen0:                 case edsDoubleLen1:                 case edsDoubleLen2:                 case edsDoubleLen3:                 case edsDoubleLen4:                 case edsDoubleLen5:                 case edsDoubleLen6:                 case edsDoubleLen7:                 case edsDoubleLen8:                     count = code - edsDoubleLen0;                     long lvalue = 0;                      for (int n = 0; n < count; ++n)                     {                         lvalue = (lvalue << 8) | (source[offset++] & 0xff);                     }                      lvalue <<= (8 - count) * 8;                     dbl = BitConverter.Int64BitsToDouble(lvalue);                     type = edsTypeDouble;                     break;                  case edsTimeLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeTime;                     break;                  case edsTimeLen1:                 case edsTimeLen2:                 case edsTimeLen3:                 case edsTimeLen4:                     l = code - edsTimeLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeTime;                     break;                  case edsMilliSecLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeMilliseconds;                     break;                  case edsMilliSecLen1:                 case edsMilliSecLen2:                 case edsMilliSecLen3:                 case edsMilliSecLen4:                 case edsMilliSecLen5:                 case edsMilliSecLen6:                 case edsMilliSecLen7:                 case edsMilliSecLen8:                     l = code - edsMilliSecLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeMilliseconds;                     break;                  case edsNanoSecLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeNanoseconds;                     break;                  case edsNanoSecLen1:                 case edsNanoSecLen2:                 case edsNanoSecLen3:                 case edsNanoSecLen4:                 case edsNanoSecLen5:                 case edsNanoSecLen6:                 case edsNanoSecLen7:                 case edsNanoSecLen8:                     l = code - edsNanoSecLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeNanoseconds;                     break;                  //                 // 09/2012 Added support for new scaled date/times encoding. These replace the old encoding                 // edsTimeLen' edsMilliSecLen and edsNanoSecLen.                 //                  case edsScaledTimeLen1:                 case edsScaledTimeLen2:                 case edsScaledTimeLen3:                 case edsScaledTimeLen4:                 case edsScaledTimeLen5:                 case edsScaledTimeLen6:                 case edsScaledTimeLen7:                 case edsScaledTimeLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledTimeLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledTime;                     break;                  case edsScaledDateLen1:                 case edsScaledDateLen2:                 case edsScaledDateLen3:                 case edsScaledDateLen4:                 case edsScaledDateLen5:                 case edsScaledDateLen6:                 case edsScaledDateLen7:                 case edsScaledDateLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledDateLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledDate;                     break;                  case edsScaledTimestampLen1:                 case edsScaledTimestampLen2:                 case edsScaledTimestampLen3:                 case edsScaledTimestampLen4:                 case edsScaledTimestampLen5:                 case edsScaledTimestampLen6:                 case edsScaledTimestampLen7:                 case edsScaledTimestampLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledTimestampLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledTimestamp;                     break;                  case edsClobLen0:                     blobId = 0;                     type = edsTypeClob;                     break;                  case edsClobLen1:                 case edsClobLen2:                 case edsClobLen3:                 case edsClobLen4:                     l = code - edsClobLen1;                     blobId = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         blobId = (blobId << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeClob;                     break;                  case edsBlobLen0:                     blobId = 0;                     type = edsTypeBlob;                     break;                  case edsBlobLen1:                 case edsBlobLen2:                 case edsBlobLen3:                 case edsBlobLen4:                     l = code - edsBlobLen1;                     blobId = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         blobId = (blobId << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeBlob;                     break;                  case edsScaledCount1:                     {                         // For some reason C++ EncodedStream expects the encoded                         // length to be length+1.                          length = (source[offset++] & 0xff) - 1;                         scale = (sbyte)source[offset++];                         type = edsTypeBigInt;                         bytes = new byte[length];                         Array.Copy(source' offset' bytes' 0' length);                         offset += length;                         int sign = ((bytes[0] & 0x80) > 0) ? -1 : 1;                          if (sign == -1)                         {                             bytes[0] &= 0x7f;                         }                          BigInteger bi = new BigInteger(bytes);                         bigDecimal = Decimal.Parse(bi.ToString());                     }                     break;                  case edsScaledCount2:                     {                         // For some reason C++ EncodedStream expects the encoded                         // length to be length+1.                          scale = (sbyte)source[offset++];                         sbyte sign = (sbyte)source[offset++];                         length = (source[offset++] & 0xff); // in bytes                         type = edsTypeBigInt;                         bytes = new byte[length];                         Array.Copy(source' offset' bytes' 0' length);                         offset += length;                          if (sign == -1)                             bytes[0] &= 0x7f;                         else                             sign = 1;                          BigInteger bi = new BigInteger(bytes);                         if (sign == -1)                             bi = -bi;                         bigDecimal = ScaleDecimal(Decimal.Parse(bi.ToString())' scale);                     }                     break;                  case edsUUID:                     {                         byte[] buff = new byte[16];                          for (int n = 0; n < 16; ++n)                         {                             buff[n] = (byte)(source[offset++] & 0xff);                         }                          uuid = new Guid(buff);                         type = edsTypeUUID;                     }                     break;                  default:                     type = edsTypeUnknown;                     break;             }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,decode,The following statement contains a magic number: switch (code)             {                 case edsNull:                     type = edsTypeNull;                     break;                  case edsTrue:                     type = edsTypeBoolean;                     @bool = true;                     break;                  case edsFalse:                     type = edsTypeBoolean;                     @bool = false;                     break;                  case edsIntMinus10:                 case edsIntMinus9:                 case edsIntMinus8:                 case edsIntMinus7:                 case edsIntMinus6:                 case edsIntMinus5:                 case edsIntMinus4:                 case edsIntMinus3:                 case edsIntMinus2:                 case edsIntMinus1:                 case edsInt0:                 case edsInt1:                 case edsInt2:                 case edsInt3:                 case edsInt4:                 case edsInt5:                 case edsInt6:                 case edsInt7:                 case edsInt8:                 case edsInt9:                 case edsInt10:                 case edsInt11:                 case edsInt12:                 case edsInt13:                 case edsInt14:                 case edsInt15:                 case edsInt16:                 case edsInt17:                 case edsInt18:                 case edsInt19:                 case edsInt20:                 case edsInt21:                 case edsInt22:                 case edsInt23:                 case edsInt24:                 case edsInt25:                 case edsInt26:                 case edsInt27:                 case edsInt28:                 case edsInt29:                 case edsInt30:                 case edsInt31:                     integer32 = code - edsInt0;                     scale = 0;                     type = edsTypeInt32;                     break;                  case edsIntLen1:                     type = edsTypeInt32;                     scale = 0;                     integer32 = (sbyte)source[offset++];                     break;                  case edsIntLen2:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset] << 8) | (source[offset + 1] & 0xff);                     offset += 2;                     break;                  case edsIntLen3:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset]) << 16 | (source[offset + 1] & 0xff) << 8 | (source[offset + 2] & 0xff);                     offset += 3;                     break;                  case edsIntLen4:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset]) << 24 | (source[offset + 1] & 0xff) << 16 | (source[offset + 2] & 0xff) << 8 | (source[offset + 3] & 0xff);                     offset += 4;                     break;                  case edsIntLen5:                 case edsIntLen6:                 case edsIntLen7:                 case edsIntLen8:                     l = code - edsIntLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeInt64;                     break;                  case edsScaledLen0:                     scale = (sbyte)source[offset++];                     integer64 = 0;                     type = edsTypeScaled;                     break;                  case edsScaledLen1:                 case edsScaledLen2:                 case edsScaledLen3:                 case edsScaledLen4:                 case edsScaledLen5:                 case edsScaledLen6:                 case edsScaledLen7:                 case edsScaledLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaled;                     break;                  case edsUtf8Len0:                 case edsUtf8Len1:                 case edsUtf8Len2:                 case edsUtf8Len3:                 case edsUtf8Len4:                 case edsUtf8Len5:                 case edsUtf8Len6:                 case edsUtf8Len7:                 case edsUtf8Len8:                 case edsUtf8Len9:                 case edsUtf8Len10:                 case edsUtf8Len11:                 case edsUtf8Len12:                 case edsUtf8Len13:                 case edsUtf8Len14:                 case edsUtf8Len15:                 case edsUtf8Len16:                 case edsUtf8Len17:                 case edsUtf8Len18:                 case edsUtf8Len19:                 case edsUtf8Len20:                 case edsUtf8Len21:                 case edsUtf8Len22:                 case edsUtf8Len23:                 case edsUtf8Len24:                 case edsUtf8Len25:                 case edsUtf8Len26:                 case edsUtf8Len27:                 case edsUtf8Len28:                 case edsUtf8Len29:                 case edsUtf8Len30:                 case edsUtf8Len31:                 case edsUtf8Len32:                 case edsUtf8Len33:                 case edsUtf8Len34:                 case edsUtf8Len35:                 case edsUtf8Len36:                 case edsUtf8Len37:                 case edsUtf8Len38:                 case edsUtf8Len39:                     l = code - edsUtf8Len0;                     @string = getString(source' offset' l);                     offset += l;                     type = edsTypeUtf8;                     break;                  case edsUtf8Count1:                 case edsUtf8Count2:                 case edsUtf8Count3:                 case edsUtf8Count4:                     count = code - edsUtf8Count1;                     int length = source[offset++] & 0xff;                      for (int n = 0; n < count; ++n)                     {                         length = length << 8 | (source[offset++] & 0xff);                     }                      @string = getString(source' offset' length);                     offset += length;                     type = edsTypeUtf8;                     break;                  case edsOpaqueLen0:                 case edsOpaqueLen1:                 case edsOpaqueLen2:                 case edsOpaqueLen3:                 case edsOpaqueLen4:                 case edsOpaqueLen5:                 case edsOpaqueLen6:                 case edsOpaqueLen7:                 case edsOpaqueLen8:                 case edsOpaqueLen9:                 case edsOpaqueLen10:                 case edsOpaqueLen11:                 case edsOpaqueLen12:                 case edsOpaqueLen13:                 case edsOpaqueLen14:                 case edsOpaqueLen15:                 case edsOpaqueLen16:                 case edsOpaqueLen17:                 case edsOpaqueLen18:                 case edsOpaqueLen19:                 case edsOpaqueLen20:                 case edsOpaqueLen21:                 case edsOpaqueLen22:                 case edsOpaqueLen23:                 case edsOpaqueLen24:                 case edsOpaqueLen25:                 case edsOpaqueLen26:                 case edsOpaqueLen27:                 case edsOpaqueLen28:                 case edsOpaqueLen29:                 case edsOpaqueLen30:                 case edsOpaqueLen31:                 case edsOpaqueLen32:                 case edsOpaqueLen33:                 case edsOpaqueLen34:                 case edsOpaqueLen35:                 case edsOpaqueLen36:                 case edsOpaqueLen37:                 case edsOpaqueLen38:                 case edsOpaqueLen39:                     l = code - edsOpaqueLen0;                     bytes = new byte[l];                     Array.Copy(source' offset' bytes' 0' l);                     offset += l;                     type = edsTypeOpaque;                     break;                  case edsOpaqueCount1:                 case edsOpaqueCount2:                 case edsOpaqueCount3:                 case edsOpaqueCount4:                     count = code - edsOpaqueCount1 + 1;                     l = source[offset++] & 0xff;                      for (int n = 1; n < count; ++n)                     {                         l = l << 8 | (source[offset++] & 0xff);                     }                      bytes = new byte[l];                     Array.Copy(source' offset' bytes' 0' l);                     offset += l;                     type = edsTypeOpaque;                     break;                  case edsDoubleLen0:                 case edsDoubleLen1:                 case edsDoubleLen2:                 case edsDoubleLen3:                 case edsDoubleLen4:                 case edsDoubleLen5:                 case edsDoubleLen6:                 case edsDoubleLen7:                 case edsDoubleLen8:                     count = code - edsDoubleLen0;                     long lvalue = 0;                      for (int n = 0; n < count; ++n)                     {                         lvalue = (lvalue << 8) | (source[offset++] & 0xff);                     }                      lvalue <<= (8 - count) * 8;                     dbl = BitConverter.Int64BitsToDouble(lvalue);                     type = edsTypeDouble;                     break;                  case edsTimeLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeTime;                     break;                  case edsTimeLen1:                 case edsTimeLen2:                 case edsTimeLen3:                 case edsTimeLen4:                     l = code - edsTimeLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeTime;                     break;                  case edsMilliSecLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeMilliseconds;                     break;                  case edsMilliSecLen1:                 case edsMilliSecLen2:                 case edsMilliSecLen3:                 case edsMilliSecLen4:                 case edsMilliSecLen5:                 case edsMilliSecLen6:                 case edsMilliSecLen7:                 case edsMilliSecLen8:                     l = code - edsMilliSecLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeMilliseconds;                     break;                  case edsNanoSecLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeNanoseconds;                     break;                  case edsNanoSecLen1:                 case edsNanoSecLen2:                 case edsNanoSecLen3:                 case edsNanoSecLen4:                 case edsNanoSecLen5:                 case edsNanoSecLen6:                 case edsNanoSecLen7:                 case edsNanoSecLen8:                     l = code - edsNanoSecLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeNanoseconds;                     break;                  //                 // 09/2012 Added support for new scaled date/times encoding. These replace the old encoding                 // edsTimeLen' edsMilliSecLen and edsNanoSecLen.                 //                  case edsScaledTimeLen1:                 case edsScaledTimeLen2:                 case edsScaledTimeLen3:                 case edsScaledTimeLen4:                 case edsScaledTimeLen5:                 case edsScaledTimeLen6:                 case edsScaledTimeLen7:                 case edsScaledTimeLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledTimeLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledTime;                     break;                  case edsScaledDateLen1:                 case edsScaledDateLen2:                 case edsScaledDateLen3:                 case edsScaledDateLen4:                 case edsScaledDateLen5:                 case edsScaledDateLen6:                 case edsScaledDateLen7:                 case edsScaledDateLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledDateLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledDate;                     break;                  case edsScaledTimestampLen1:                 case edsScaledTimestampLen2:                 case edsScaledTimestampLen3:                 case edsScaledTimestampLen4:                 case edsScaledTimestampLen5:                 case edsScaledTimestampLen6:                 case edsScaledTimestampLen7:                 case edsScaledTimestampLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledTimestampLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledTimestamp;                     break;                  case edsClobLen0:                     blobId = 0;                     type = edsTypeClob;                     break;                  case edsClobLen1:                 case edsClobLen2:                 case edsClobLen3:                 case edsClobLen4:                     l = code - edsClobLen1;                     blobId = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         blobId = (blobId << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeClob;                     break;                  case edsBlobLen0:                     blobId = 0;                     type = edsTypeBlob;                     break;                  case edsBlobLen1:                 case edsBlobLen2:                 case edsBlobLen3:                 case edsBlobLen4:                     l = code - edsBlobLen1;                     blobId = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         blobId = (blobId << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeBlob;                     break;                  case edsScaledCount1:                     {                         // For some reason C++ EncodedStream expects the encoded                         // length to be length+1.                          length = (source[offset++] & 0xff) - 1;                         scale = (sbyte)source[offset++];                         type = edsTypeBigInt;                         bytes = new byte[length];                         Array.Copy(source' offset' bytes' 0' length);                         offset += length;                         int sign = ((bytes[0] & 0x80) > 0) ? -1 : 1;                          if (sign == -1)                         {                             bytes[0] &= 0x7f;                         }                          BigInteger bi = new BigInteger(bytes);                         bigDecimal = Decimal.Parse(bi.ToString());                     }                     break;                  case edsScaledCount2:                     {                         // For some reason C++ EncodedStream expects the encoded                         // length to be length+1.                          scale = (sbyte)source[offset++];                         sbyte sign = (sbyte)source[offset++];                         length = (source[offset++] & 0xff); // in bytes                         type = edsTypeBigInt;                         bytes = new byte[length];                         Array.Copy(source' offset' bytes' 0' length);                         offset += length;                          if (sign == -1)                             bytes[0] &= 0x7f;                         else                             sign = 1;                          BigInteger bi = new BigInteger(bytes);                         if (sign == -1)                             bi = -bi;                         bigDecimal = ScaleDecimal(Decimal.Parse(bi.ToString())' scale);                     }                     break;                  case edsUUID:                     {                         byte[] buff = new byte[16];                          for (int n = 0; n < 16; ++n)                         {                             buff[n] = (byte)(source[offset++] & 0xff);                         }                          uuid = new Guid(buff);                         type = edsTypeUUID;                     }                     break;                  default:                     type = edsTypeUnknown;                     break;             }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,decode,The following statement contains a magic number: switch (code)             {                 case edsNull:                     type = edsTypeNull;                     break;                  case edsTrue:                     type = edsTypeBoolean;                     @bool = true;                     break;                  case edsFalse:                     type = edsTypeBoolean;                     @bool = false;                     break;                  case edsIntMinus10:                 case edsIntMinus9:                 case edsIntMinus8:                 case edsIntMinus7:                 case edsIntMinus6:                 case edsIntMinus5:                 case edsIntMinus4:                 case edsIntMinus3:                 case edsIntMinus2:                 case edsIntMinus1:                 case edsInt0:                 case edsInt1:                 case edsInt2:                 case edsInt3:                 case edsInt4:                 case edsInt5:                 case edsInt6:                 case edsInt7:                 case edsInt8:                 case edsInt9:                 case edsInt10:                 case edsInt11:                 case edsInt12:                 case edsInt13:                 case edsInt14:                 case edsInt15:                 case edsInt16:                 case edsInt17:                 case edsInt18:                 case edsInt19:                 case edsInt20:                 case edsInt21:                 case edsInt22:                 case edsInt23:                 case edsInt24:                 case edsInt25:                 case edsInt26:                 case edsInt27:                 case edsInt28:                 case edsInt29:                 case edsInt30:                 case edsInt31:                     integer32 = code - edsInt0;                     scale = 0;                     type = edsTypeInt32;                     break;                  case edsIntLen1:                     type = edsTypeInt32;                     scale = 0;                     integer32 = (sbyte)source[offset++];                     break;                  case edsIntLen2:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset] << 8) | (source[offset + 1] & 0xff);                     offset += 2;                     break;                  case edsIntLen3:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset]) << 16 | (source[offset + 1] & 0xff) << 8 | (source[offset + 2] & 0xff);                     offset += 3;                     break;                  case edsIntLen4:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset]) << 24 | (source[offset + 1] & 0xff) << 16 | (source[offset + 2] & 0xff) << 8 | (source[offset + 3] & 0xff);                     offset += 4;                     break;                  case edsIntLen5:                 case edsIntLen6:                 case edsIntLen7:                 case edsIntLen8:                     l = code - edsIntLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeInt64;                     break;                  case edsScaledLen0:                     scale = (sbyte)source[offset++];                     integer64 = 0;                     type = edsTypeScaled;                     break;                  case edsScaledLen1:                 case edsScaledLen2:                 case edsScaledLen3:                 case edsScaledLen4:                 case edsScaledLen5:                 case edsScaledLen6:                 case edsScaledLen7:                 case edsScaledLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaled;                     break;                  case edsUtf8Len0:                 case edsUtf8Len1:                 case edsUtf8Len2:                 case edsUtf8Len3:                 case edsUtf8Len4:                 case edsUtf8Len5:                 case edsUtf8Len6:                 case edsUtf8Len7:                 case edsUtf8Len8:                 case edsUtf8Len9:                 case edsUtf8Len10:                 case edsUtf8Len11:                 case edsUtf8Len12:                 case edsUtf8Len13:                 case edsUtf8Len14:                 case edsUtf8Len15:                 case edsUtf8Len16:                 case edsUtf8Len17:                 case edsUtf8Len18:                 case edsUtf8Len19:                 case edsUtf8Len20:                 case edsUtf8Len21:                 case edsUtf8Len22:                 case edsUtf8Len23:                 case edsUtf8Len24:                 case edsUtf8Len25:                 case edsUtf8Len26:                 case edsUtf8Len27:                 case edsUtf8Len28:                 case edsUtf8Len29:                 case edsUtf8Len30:                 case edsUtf8Len31:                 case edsUtf8Len32:                 case edsUtf8Len33:                 case edsUtf8Len34:                 case edsUtf8Len35:                 case edsUtf8Len36:                 case edsUtf8Len37:                 case edsUtf8Len38:                 case edsUtf8Len39:                     l = code - edsUtf8Len0;                     @string = getString(source' offset' l);                     offset += l;                     type = edsTypeUtf8;                     break;                  case edsUtf8Count1:                 case edsUtf8Count2:                 case edsUtf8Count3:                 case edsUtf8Count4:                     count = code - edsUtf8Count1;                     int length = source[offset++] & 0xff;                      for (int n = 0; n < count; ++n)                     {                         length = length << 8 | (source[offset++] & 0xff);                     }                      @string = getString(source' offset' length);                     offset += length;                     type = edsTypeUtf8;                     break;                  case edsOpaqueLen0:                 case edsOpaqueLen1:                 case edsOpaqueLen2:                 case edsOpaqueLen3:                 case edsOpaqueLen4:                 case edsOpaqueLen5:                 case edsOpaqueLen6:                 case edsOpaqueLen7:                 case edsOpaqueLen8:                 case edsOpaqueLen9:                 case edsOpaqueLen10:                 case edsOpaqueLen11:                 case edsOpaqueLen12:                 case edsOpaqueLen13:                 case edsOpaqueLen14:                 case edsOpaqueLen15:                 case edsOpaqueLen16:                 case edsOpaqueLen17:                 case edsOpaqueLen18:                 case edsOpaqueLen19:                 case edsOpaqueLen20:                 case edsOpaqueLen21:                 case edsOpaqueLen22:                 case edsOpaqueLen23:                 case edsOpaqueLen24:                 case edsOpaqueLen25:                 case edsOpaqueLen26:                 case edsOpaqueLen27:                 case edsOpaqueLen28:                 case edsOpaqueLen29:                 case edsOpaqueLen30:                 case edsOpaqueLen31:                 case edsOpaqueLen32:                 case edsOpaqueLen33:                 case edsOpaqueLen34:                 case edsOpaqueLen35:                 case edsOpaqueLen36:                 case edsOpaqueLen37:                 case edsOpaqueLen38:                 case edsOpaqueLen39:                     l = code - edsOpaqueLen0;                     bytes = new byte[l];                     Array.Copy(source' offset' bytes' 0' l);                     offset += l;                     type = edsTypeOpaque;                     break;                  case edsOpaqueCount1:                 case edsOpaqueCount2:                 case edsOpaqueCount3:                 case edsOpaqueCount4:                     count = code - edsOpaqueCount1 + 1;                     l = source[offset++] & 0xff;                      for (int n = 1; n < count; ++n)                     {                         l = l << 8 | (source[offset++] & 0xff);                     }                      bytes = new byte[l];                     Array.Copy(source' offset' bytes' 0' l);                     offset += l;                     type = edsTypeOpaque;                     break;                  case edsDoubleLen0:                 case edsDoubleLen1:                 case edsDoubleLen2:                 case edsDoubleLen3:                 case edsDoubleLen4:                 case edsDoubleLen5:                 case edsDoubleLen6:                 case edsDoubleLen7:                 case edsDoubleLen8:                     count = code - edsDoubleLen0;                     long lvalue = 0;                      for (int n = 0; n < count; ++n)                     {                         lvalue = (lvalue << 8) | (source[offset++] & 0xff);                     }                      lvalue <<= (8 - count) * 8;                     dbl = BitConverter.Int64BitsToDouble(lvalue);                     type = edsTypeDouble;                     break;                  case edsTimeLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeTime;                     break;                  case edsTimeLen1:                 case edsTimeLen2:                 case edsTimeLen3:                 case edsTimeLen4:                     l = code - edsTimeLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeTime;                     break;                  case edsMilliSecLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeMilliseconds;                     break;                  case edsMilliSecLen1:                 case edsMilliSecLen2:                 case edsMilliSecLen3:                 case edsMilliSecLen4:                 case edsMilliSecLen5:                 case edsMilliSecLen6:                 case edsMilliSecLen7:                 case edsMilliSecLen8:                     l = code - edsMilliSecLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeMilliseconds;                     break;                  case edsNanoSecLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeNanoseconds;                     break;                  case edsNanoSecLen1:                 case edsNanoSecLen2:                 case edsNanoSecLen3:                 case edsNanoSecLen4:                 case edsNanoSecLen5:                 case edsNanoSecLen6:                 case edsNanoSecLen7:                 case edsNanoSecLen8:                     l = code - edsNanoSecLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeNanoseconds;                     break;                  //                 // 09/2012 Added support for new scaled date/times encoding. These replace the old encoding                 // edsTimeLen' edsMilliSecLen and edsNanoSecLen.                 //                  case edsScaledTimeLen1:                 case edsScaledTimeLen2:                 case edsScaledTimeLen3:                 case edsScaledTimeLen4:                 case edsScaledTimeLen5:                 case edsScaledTimeLen6:                 case edsScaledTimeLen7:                 case edsScaledTimeLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledTimeLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledTime;                     break;                  case edsScaledDateLen1:                 case edsScaledDateLen2:                 case edsScaledDateLen3:                 case edsScaledDateLen4:                 case edsScaledDateLen5:                 case edsScaledDateLen6:                 case edsScaledDateLen7:                 case edsScaledDateLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledDateLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledDate;                     break;                  case edsScaledTimestampLen1:                 case edsScaledTimestampLen2:                 case edsScaledTimestampLen3:                 case edsScaledTimestampLen4:                 case edsScaledTimestampLen5:                 case edsScaledTimestampLen6:                 case edsScaledTimestampLen7:                 case edsScaledTimestampLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledTimestampLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledTimestamp;                     break;                  case edsClobLen0:                     blobId = 0;                     type = edsTypeClob;                     break;                  case edsClobLen1:                 case edsClobLen2:                 case edsClobLen3:                 case edsClobLen4:                     l = code - edsClobLen1;                     blobId = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         blobId = (blobId << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeClob;                     break;                  case edsBlobLen0:                     blobId = 0;                     type = edsTypeBlob;                     break;                  case edsBlobLen1:                 case edsBlobLen2:                 case edsBlobLen3:                 case edsBlobLen4:                     l = code - edsBlobLen1;                     blobId = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         blobId = (blobId << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeBlob;                     break;                  case edsScaledCount1:                     {                         // For some reason C++ EncodedStream expects the encoded                         // length to be length+1.                          length = (source[offset++] & 0xff) - 1;                         scale = (sbyte)source[offset++];                         type = edsTypeBigInt;                         bytes = new byte[length];                         Array.Copy(source' offset' bytes' 0' length);                         offset += length;                         int sign = ((bytes[0] & 0x80) > 0) ? -1 : 1;                          if (sign == -1)                         {                             bytes[0] &= 0x7f;                         }                          BigInteger bi = new BigInteger(bytes);                         bigDecimal = Decimal.Parse(bi.ToString());                     }                     break;                  case edsScaledCount2:                     {                         // For some reason C++ EncodedStream expects the encoded                         // length to be length+1.                          scale = (sbyte)source[offset++];                         sbyte sign = (sbyte)source[offset++];                         length = (source[offset++] & 0xff); // in bytes                         type = edsTypeBigInt;                         bytes = new byte[length];                         Array.Copy(source' offset' bytes' 0' length);                         offset += length;                          if (sign == -1)                             bytes[0] &= 0x7f;                         else                             sign = 1;                          BigInteger bi = new BigInteger(bytes);                         if (sign == -1)                             bi = -bi;                         bigDecimal = ScaleDecimal(Decimal.Parse(bi.ToString())' scale);                     }                     break;                  case edsUUID:                     {                         byte[] buff = new byte[16];                          for (int n = 0; n < 16; ++n)                         {                             buff[n] = (byte)(source[offset++] & 0xff);                         }                          uuid = new Guid(buff);                         type = edsTypeUUID;                     }                     break;                  default:                     type = edsTypeUnknown;                     break;             }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,decode,The following statement contains a magic number: switch (code)             {                 case edsNull:                     type = edsTypeNull;                     break;                  case edsTrue:                     type = edsTypeBoolean;                     @bool = true;                     break;                  case edsFalse:                     type = edsTypeBoolean;                     @bool = false;                     break;                  case edsIntMinus10:                 case edsIntMinus9:                 case edsIntMinus8:                 case edsIntMinus7:                 case edsIntMinus6:                 case edsIntMinus5:                 case edsIntMinus4:                 case edsIntMinus3:                 case edsIntMinus2:                 case edsIntMinus1:                 case edsInt0:                 case edsInt1:                 case edsInt2:                 case edsInt3:                 case edsInt4:                 case edsInt5:                 case edsInt6:                 case edsInt7:                 case edsInt8:                 case edsInt9:                 case edsInt10:                 case edsInt11:                 case edsInt12:                 case edsInt13:                 case edsInt14:                 case edsInt15:                 case edsInt16:                 case edsInt17:                 case edsInt18:                 case edsInt19:                 case edsInt20:                 case edsInt21:                 case edsInt22:                 case edsInt23:                 case edsInt24:                 case edsInt25:                 case edsInt26:                 case edsInt27:                 case edsInt28:                 case edsInt29:                 case edsInt30:                 case edsInt31:                     integer32 = code - edsInt0;                     scale = 0;                     type = edsTypeInt32;                     break;                  case edsIntLen1:                     type = edsTypeInt32;                     scale = 0;                     integer32 = (sbyte)source[offset++];                     break;                  case edsIntLen2:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset] << 8) | (source[offset + 1] & 0xff);                     offset += 2;                     break;                  case edsIntLen3:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset]) << 16 | (source[offset + 1] & 0xff) << 8 | (source[offset + 2] & 0xff);                     offset += 3;                     break;                  case edsIntLen4:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset]) << 24 | (source[offset + 1] & 0xff) << 16 | (source[offset + 2] & 0xff) << 8 | (source[offset + 3] & 0xff);                     offset += 4;                     break;                  case edsIntLen5:                 case edsIntLen6:                 case edsIntLen7:                 case edsIntLen8:                     l = code - edsIntLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeInt64;                     break;                  case edsScaledLen0:                     scale = (sbyte)source[offset++];                     integer64 = 0;                     type = edsTypeScaled;                     break;                  case edsScaledLen1:                 case edsScaledLen2:                 case edsScaledLen3:                 case edsScaledLen4:                 case edsScaledLen5:                 case edsScaledLen6:                 case edsScaledLen7:                 case edsScaledLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaled;                     break;                  case edsUtf8Len0:                 case edsUtf8Len1:                 case edsUtf8Len2:                 case edsUtf8Len3:                 case edsUtf8Len4:                 case edsUtf8Len5:                 case edsUtf8Len6:                 case edsUtf8Len7:                 case edsUtf8Len8:                 case edsUtf8Len9:                 case edsUtf8Len10:                 case edsUtf8Len11:                 case edsUtf8Len12:                 case edsUtf8Len13:                 case edsUtf8Len14:                 case edsUtf8Len15:                 case edsUtf8Len16:                 case edsUtf8Len17:                 case edsUtf8Len18:                 case edsUtf8Len19:                 case edsUtf8Len20:                 case edsUtf8Len21:                 case edsUtf8Len22:                 case edsUtf8Len23:                 case edsUtf8Len24:                 case edsUtf8Len25:                 case edsUtf8Len26:                 case edsUtf8Len27:                 case edsUtf8Len28:                 case edsUtf8Len29:                 case edsUtf8Len30:                 case edsUtf8Len31:                 case edsUtf8Len32:                 case edsUtf8Len33:                 case edsUtf8Len34:                 case edsUtf8Len35:                 case edsUtf8Len36:                 case edsUtf8Len37:                 case edsUtf8Len38:                 case edsUtf8Len39:                     l = code - edsUtf8Len0;                     @string = getString(source' offset' l);                     offset += l;                     type = edsTypeUtf8;                     break;                  case edsUtf8Count1:                 case edsUtf8Count2:                 case edsUtf8Count3:                 case edsUtf8Count4:                     count = code - edsUtf8Count1;                     int length = source[offset++] & 0xff;                      for (int n = 0; n < count; ++n)                     {                         length = length << 8 | (source[offset++] & 0xff);                     }                      @string = getString(source' offset' length);                     offset += length;                     type = edsTypeUtf8;                     break;                  case edsOpaqueLen0:                 case edsOpaqueLen1:                 case edsOpaqueLen2:                 case edsOpaqueLen3:                 case edsOpaqueLen4:                 case edsOpaqueLen5:                 case edsOpaqueLen6:                 case edsOpaqueLen7:                 case edsOpaqueLen8:                 case edsOpaqueLen9:                 case edsOpaqueLen10:                 case edsOpaqueLen11:                 case edsOpaqueLen12:                 case edsOpaqueLen13:                 case edsOpaqueLen14:                 case edsOpaqueLen15:                 case edsOpaqueLen16:                 case edsOpaqueLen17:                 case edsOpaqueLen18:                 case edsOpaqueLen19:                 case edsOpaqueLen20:                 case edsOpaqueLen21:                 case edsOpaqueLen22:                 case edsOpaqueLen23:                 case edsOpaqueLen24:                 case edsOpaqueLen25:                 case edsOpaqueLen26:                 case edsOpaqueLen27:                 case edsOpaqueLen28:                 case edsOpaqueLen29:                 case edsOpaqueLen30:                 case edsOpaqueLen31:                 case edsOpaqueLen32:                 case edsOpaqueLen33:                 case edsOpaqueLen34:                 case edsOpaqueLen35:                 case edsOpaqueLen36:                 case edsOpaqueLen37:                 case edsOpaqueLen38:                 case edsOpaqueLen39:                     l = code - edsOpaqueLen0;                     bytes = new byte[l];                     Array.Copy(source' offset' bytes' 0' l);                     offset += l;                     type = edsTypeOpaque;                     break;                  case edsOpaqueCount1:                 case edsOpaqueCount2:                 case edsOpaqueCount3:                 case edsOpaqueCount4:                     count = code - edsOpaqueCount1 + 1;                     l = source[offset++] & 0xff;                      for (int n = 1; n < count; ++n)                     {                         l = l << 8 | (source[offset++] & 0xff);                     }                      bytes = new byte[l];                     Array.Copy(source' offset' bytes' 0' l);                     offset += l;                     type = edsTypeOpaque;                     break;                  case edsDoubleLen0:                 case edsDoubleLen1:                 case edsDoubleLen2:                 case edsDoubleLen3:                 case edsDoubleLen4:                 case edsDoubleLen5:                 case edsDoubleLen6:                 case edsDoubleLen7:                 case edsDoubleLen8:                     count = code - edsDoubleLen0;                     long lvalue = 0;                      for (int n = 0; n < count; ++n)                     {                         lvalue = (lvalue << 8) | (source[offset++] & 0xff);                     }                      lvalue <<= (8 - count) * 8;                     dbl = BitConverter.Int64BitsToDouble(lvalue);                     type = edsTypeDouble;                     break;                  case edsTimeLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeTime;                     break;                  case edsTimeLen1:                 case edsTimeLen2:                 case edsTimeLen3:                 case edsTimeLen4:                     l = code - edsTimeLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeTime;                     break;                  case edsMilliSecLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeMilliseconds;                     break;                  case edsMilliSecLen1:                 case edsMilliSecLen2:                 case edsMilliSecLen3:                 case edsMilliSecLen4:                 case edsMilliSecLen5:                 case edsMilliSecLen6:                 case edsMilliSecLen7:                 case edsMilliSecLen8:                     l = code - edsMilliSecLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeMilliseconds;                     break;                  case edsNanoSecLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeNanoseconds;                     break;                  case edsNanoSecLen1:                 case edsNanoSecLen2:                 case edsNanoSecLen3:                 case edsNanoSecLen4:                 case edsNanoSecLen5:                 case edsNanoSecLen6:                 case edsNanoSecLen7:                 case edsNanoSecLen8:                     l = code - edsNanoSecLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeNanoseconds;                     break;                  //                 // 09/2012 Added support for new scaled date/times encoding. These replace the old encoding                 // edsTimeLen' edsMilliSecLen and edsNanoSecLen.                 //                  case edsScaledTimeLen1:                 case edsScaledTimeLen2:                 case edsScaledTimeLen3:                 case edsScaledTimeLen4:                 case edsScaledTimeLen5:                 case edsScaledTimeLen6:                 case edsScaledTimeLen7:                 case edsScaledTimeLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledTimeLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledTime;                     break;                  case edsScaledDateLen1:                 case edsScaledDateLen2:                 case edsScaledDateLen3:                 case edsScaledDateLen4:                 case edsScaledDateLen5:                 case edsScaledDateLen6:                 case edsScaledDateLen7:                 case edsScaledDateLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledDateLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledDate;                     break;                  case edsScaledTimestampLen1:                 case edsScaledTimestampLen2:                 case edsScaledTimestampLen3:                 case edsScaledTimestampLen4:                 case edsScaledTimestampLen5:                 case edsScaledTimestampLen6:                 case edsScaledTimestampLen7:                 case edsScaledTimestampLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledTimestampLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledTimestamp;                     break;                  case edsClobLen0:                     blobId = 0;                     type = edsTypeClob;                     break;                  case edsClobLen1:                 case edsClobLen2:                 case edsClobLen3:                 case edsClobLen4:                     l = code - edsClobLen1;                     blobId = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         blobId = (blobId << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeClob;                     break;                  case edsBlobLen0:                     blobId = 0;                     type = edsTypeBlob;                     break;                  case edsBlobLen1:                 case edsBlobLen2:                 case edsBlobLen3:                 case edsBlobLen4:                     l = code - edsBlobLen1;                     blobId = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         blobId = (blobId << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeBlob;                     break;                  case edsScaledCount1:                     {                         // For some reason C++ EncodedStream expects the encoded                         // length to be length+1.                          length = (source[offset++] & 0xff) - 1;                         scale = (sbyte)source[offset++];                         type = edsTypeBigInt;                         bytes = new byte[length];                         Array.Copy(source' offset' bytes' 0' length);                         offset += length;                         int sign = ((bytes[0] & 0x80) > 0) ? -1 : 1;                          if (sign == -1)                         {                             bytes[0] &= 0x7f;                         }                          BigInteger bi = new BigInteger(bytes);                         bigDecimal = Decimal.Parse(bi.ToString());                     }                     break;                  case edsScaledCount2:                     {                         // For some reason C++ EncodedStream expects the encoded                         // length to be length+1.                          scale = (sbyte)source[offset++];                         sbyte sign = (sbyte)source[offset++];                         length = (source[offset++] & 0xff); // in bytes                         type = edsTypeBigInt;                         bytes = new byte[length];                         Array.Copy(source' offset' bytes' 0' length);                         offset += length;                          if (sign == -1)                             bytes[0] &= 0x7f;                         else                             sign = 1;                          BigInteger bi = new BigInteger(bytes);                         if (sign == -1)                             bi = -bi;                         bigDecimal = ScaleDecimal(Decimal.Parse(bi.ToString())' scale);                     }                     break;                  case edsUUID:                     {                         byte[] buff = new byte[16];                          for (int n = 0; n < 16; ++n)                         {                             buff[n] = (byte)(source[offset++] & 0xff);                         }                          uuid = new Guid(buff);                         type = edsTypeUUID;                     }                     break;                  default:                     type = edsTypeUnknown;                     break;             }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,decode,The following statement contains a magic number: switch (code)             {                 case edsNull:                     type = edsTypeNull;                     break;                  case edsTrue:                     type = edsTypeBoolean;                     @bool = true;                     break;                  case edsFalse:                     type = edsTypeBoolean;                     @bool = false;                     break;                  case edsIntMinus10:                 case edsIntMinus9:                 case edsIntMinus8:                 case edsIntMinus7:                 case edsIntMinus6:                 case edsIntMinus5:                 case edsIntMinus4:                 case edsIntMinus3:                 case edsIntMinus2:                 case edsIntMinus1:                 case edsInt0:                 case edsInt1:                 case edsInt2:                 case edsInt3:                 case edsInt4:                 case edsInt5:                 case edsInt6:                 case edsInt7:                 case edsInt8:                 case edsInt9:                 case edsInt10:                 case edsInt11:                 case edsInt12:                 case edsInt13:                 case edsInt14:                 case edsInt15:                 case edsInt16:                 case edsInt17:                 case edsInt18:                 case edsInt19:                 case edsInt20:                 case edsInt21:                 case edsInt22:                 case edsInt23:                 case edsInt24:                 case edsInt25:                 case edsInt26:                 case edsInt27:                 case edsInt28:                 case edsInt29:                 case edsInt30:                 case edsInt31:                     integer32 = code - edsInt0;                     scale = 0;                     type = edsTypeInt32;                     break;                  case edsIntLen1:                     type = edsTypeInt32;                     scale = 0;                     integer32 = (sbyte)source[offset++];                     break;                  case edsIntLen2:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset] << 8) | (source[offset + 1] & 0xff);                     offset += 2;                     break;                  case edsIntLen3:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset]) << 16 | (source[offset + 1] & 0xff) << 8 | (source[offset + 2] & 0xff);                     offset += 3;                     break;                  case edsIntLen4:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset]) << 24 | (source[offset + 1] & 0xff) << 16 | (source[offset + 2] & 0xff) << 8 | (source[offset + 3] & 0xff);                     offset += 4;                     break;                  case edsIntLen5:                 case edsIntLen6:                 case edsIntLen7:                 case edsIntLen8:                     l = code - edsIntLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeInt64;                     break;                  case edsScaledLen0:                     scale = (sbyte)source[offset++];                     integer64 = 0;                     type = edsTypeScaled;                     break;                  case edsScaledLen1:                 case edsScaledLen2:                 case edsScaledLen3:                 case edsScaledLen4:                 case edsScaledLen5:                 case edsScaledLen6:                 case edsScaledLen7:                 case edsScaledLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaled;                     break;                  case edsUtf8Len0:                 case edsUtf8Len1:                 case edsUtf8Len2:                 case edsUtf8Len3:                 case edsUtf8Len4:                 case edsUtf8Len5:                 case edsUtf8Len6:                 case edsUtf8Len7:                 case edsUtf8Len8:                 case edsUtf8Len9:                 case edsUtf8Len10:                 case edsUtf8Len11:                 case edsUtf8Len12:                 case edsUtf8Len13:                 case edsUtf8Len14:                 case edsUtf8Len15:                 case edsUtf8Len16:                 case edsUtf8Len17:                 case edsUtf8Len18:                 case edsUtf8Len19:                 case edsUtf8Len20:                 case edsUtf8Len21:                 case edsUtf8Len22:                 case edsUtf8Len23:                 case edsUtf8Len24:                 case edsUtf8Len25:                 case edsUtf8Len26:                 case edsUtf8Len27:                 case edsUtf8Len28:                 case edsUtf8Len29:                 case edsUtf8Len30:                 case edsUtf8Len31:                 case edsUtf8Len32:                 case edsUtf8Len33:                 case edsUtf8Len34:                 case edsUtf8Len35:                 case edsUtf8Len36:                 case edsUtf8Len37:                 case edsUtf8Len38:                 case edsUtf8Len39:                     l = code - edsUtf8Len0;                     @string = getString(source' offset' l);                     offset += l;                     type = edsTypeUtf8;                     break;                  case edsUtf8Count1:                 case edsUtf8Count2:                 case edsUtf8Count3:                 case edsUtf8Count4:                     count = code - edsUtf8Count1;                     int length = source[offset++] & 0xff;                      for (int n = 0; n < count; ++n)                     {                         length = length << 8 | (source[offset++] & 0xff);                     }                      @string = getString(source' offset' length);                     offset += length;                     type = edsTypeUtf8;                     break;                  case edsOpaqueLen0:                 case edsOpaqueLen1:                 case edsOpaqueLen2:                 case edsOpaqueLen3:                 case edsOpaqueLen4:                 case edsOpaqueLen5:                 case edsOpaqueLen6:                 case edsOpaqueLen7:                 case edsOpaqueLen8:                 case edsOpaqueLen9:                 case edsOpaqueLen10:                 case edsOpaqueLen11:                 case edsOpaqueLen12:                 case edsOpaqueLen13:                 case edsOpaqueLen14:                 case edsOpaqueLen15:                 case edsOpaqueLen16:                 case edsOpaqueLen17:                 case edsOpaqueLen18:                 case edsOpaqueLen19:                 case edsOpaqueLen20:                 case edsOpaqueLen21:                 case edsOpaqueLen22:                 case edsOpaqueLen23:                 case edsOpaqueLen24:                 case edsOpaqueLen25:                 case edsOpaqueLen26:                 case edsOpaqueLen27:                 case edsOpaqueLen28:                 case edsOpaqueLen29:                 case edsOpaqueLen30:                 case edsOpaqueLen31:                 case edsOpaqueLen32:                 case edsOpaqueLen33:                 case edsOpaqueLen34:                 case edsOpaqueLen35:                 case edsOpaqueLen36:                 case edsOpaqueLen37:                 case edsOpaqueLen38:                 case edsOpaqueLen39:                     l = code - edsOpaqueLen0;                     bytes = new byte[l];                     Array.Copy(source' offset' bytes' 0' l);                     offset += l;                     type = edsTypeOpaque;                     break;                  case edsOpaqueCount1:                 case edsOpaqueCount2:                 case edsOpaqueCount3:                 case edsOpaqueCount4:                     count = code - edsOpaqueCount1 + 1;                     l = source[offset++] & 0xff;                      for (int n = 1; n < count; ++n)                     {                         l = l << 8 | (source[offset++] & 0xff);                     }                      bytes = new byte[l];                     Array.Copy(source' offset' bytes' 0' l);                     offset += l;                     type = edsTypeOpaque;                     break;                  case edsDoubleLen0:                 case edsDoubleLen1:                 case edsDoubleLen2:                 case edsDoubleLen3:                 case edsDoubleLen4:                 case edsDoubleLen5:                 case edsDoubleLen6:                 case edsDoubleLen7:                 case edsDoubleLen8:                     count = code - edsDoubleLen0;                     long lvalue = 0;                      for (int n = 0; n < count; ++n)                     {                         lvalue = (lvalue << 8) | (source[offset++] & 0xff);                     }                      lvalue <<= (8 - count) * 8;                     dbl = BitConverter.Int64BitsToDouble(lvalue);                     type = edsTypeDouble;                     break;                  case edsTimeLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeTime;                     break;                  case edsTimeLen1:                 case edsTimeLen2:                 case edsTimeLen3:                 case edsTimeLen4:                     l = code - edsTimeLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeTime;                     break;                  case edsMilliSecLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeMilliseconds;                     break;                  case edsMilliSecLen1:                 case edsMilliSecLen2:                 case edsMilliSecLen3:                 case edsMilliSecLen4:                 case edsMilliSecLen5:                 case edsMilliSecLen6:                 case edsMilliSecLen7:                 case edsMilliSecLen8:                     l = code - edsMilliSecLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeMilliseconds;                     break;                  case edsNanoSecLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeNanoseconds;                     break;                  case edsNanoSecLen1:                 case edsNanoSecLen2:                 case edsNanoSecLen3:                 case edsNanoSecLen4:                 case edsNanoSecLen5:                 case edsNanoSecLen6:                 case edsNanoSecLen7:                 case edsNanoSecLen8:                     l = code - edsNanoSecLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeNanoseconds;                     break;                  //                 // 09/2012 Added support for new scaled date/times encoding. These replace the old encoding                 // edsTimeLen' edsMilliSecLen and edsNanoSecLen.                 //                  case edsScaledTimeLen1:                 case edsScaledTimeLen2:                 case edsScaledTimeLen3:                 case edsScaledTimeLen4:                 case edsScaledTimeLen5:                 case edsScaledTimeLen6:                 case edsScaledTimeLen7:                 case edsScaledTimeLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledTimeLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledTime;                     break;                  case edsScaledDateLen1:                 case edsScaledDateLen2:                 case edsScaledDateLen3:                 case edsScaledDateLen4:                 case edsScaledDateLen5:                 case edsScaledDateLen6:                 case edsScaledDateLen7:                 case edsScaledDateLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledDateLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledDate;                     break;                  case edsScaledTimestampLen1:                 case edsScaledTimestampLen2:                 case edsScaledTimestampLen3:                 case edsScaledTimestampLen4:                 case edsScaledTimestampLen5:                 case edsScaledTimestampLen6:                 case edsScaledTimestampLen7:                 case edsScaledTimestampLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledTimestampLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledTimestamp;                     break;                  case edsClobLen0:                     blobId = 0;                     type = edsTypeClob;                     break;                  case edsClobLen1:                 case edsClobLen2:                 case edsClobLen3:                 case edsClobLen4:                     l = code - edsClobLen1;                     blobId = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         blobId = (blobId << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeClob;                     break;                  case edsBlobLen0:                     blobId = 0;                     type = edsTypeBlob;                     break;                  case edsBlobLen1:                 case edsBlobLen2:                 case edsBlobLen3:                 case edsBlobLen4:                     l = code - edsBlobLen1;                     blobId = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         blobId = (blobId << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeBlob;                     break;                  case edsScaledCount1:                     {                         // For some reason C++ EncodedStream expects the encoded                         // length to be length+1.                          length = (source[offset++] & 0xff) - 1;                         scale = (sbyte)source[offset++];                         type = edsTypeBigInt;                         bytes = new byte[length];                         Array.Copy(source' offset' bytes' 0' length);                         offset += length;                         int sign = ((bytes[0] & 0x80) > 0) ? -1 : 1;                          if (sign == -1)                         {                             bytes[0] &= 0x7f;                         }                          BigInteger bi = new BigInteger(bytes);                         bigDecimal = Decimal.Parse(bi.ToString());                     }                     break;                  case edsScaledCount2:                     {                         // For some reason C++ EncodedStream expects the encoded                         // length to be length+1.                          scale = (sbyte)source[offset++];                         sbyte sign = (sbyte)source[offset++];                         length = (source[offset++] & 0xff); // in bytes                         type = edsTypeBigInt;                         bytes = new byte[length];                         Array.Copy(source' offset' bytes' 0' length);                         offset += length;                          if (sign == -1)                             bytes[0] &= 0x7f;                         else                             sign = 1;                          BigInteger bi = new BigInteger(bytes);                         if (sign == -1)                             bi = -bi;                         bigDecimal = ScaleDecimal(Decimal.Parse(bi.ToString())' scale);                     }                     break;                  case edsUUID:                     {                         byte[] buff = new byte[16];                          for (int n = 0; n < 16; ++n)                         {                             buff[n] = (byte)(source[offset++] & 0xff);                         }                          uuid = new Guid(buff);                         type = edsTypeUUID;                     }                     break;                  default:                     type = edsTypeUnknown;                     break;             }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,decode,The following statement contains a magic number: switch (code)             {                 case edsNull:                     type = edsTypeNull;                     break;                  case edsTrue:                     type = edsTypeBoolean;                     @bool = true;                     break;                  case edsFalse:                     type = edsTypeBoolean;                     @bool = false;                     break;                  case edsIntMinus10:                 case edsIntMinus9:                 case edsIntMinus8:                 case edsIntMinus7:                 case edsIntMinus6:                 case edsIntMinus5:                 case edsIntMinus4:                 case edsIntMinus3:                 case edsIntMinus2:                 case edsIntMinus1:                 case edsInt0:                 case edsInt1:                 case edsInt2:                 case edsInt3:                 case edsInt4:                 case edsInt5:                 case edsInt6:                 case edsInt7:                 case edsInt8:                 case edsInt9:                 case edsInt10:                 case edsInt11:                 case edsInt12:                 case edsInt13:                 case edsInt14:                 case edsInt15:                 case edsInt16:                 case edsInt17:                 case edsInt18:                 case edsInt19:                 case edsInt20:                 case edsInt21:                 case edsInt22:                 case edsInt23:                 case edsInt24:                 case edsInt25:                 case edsInt26:                 case edsInt27:                 case edsInt28:                 case edsInt29:                 case edsInt30:                 case edsInt31:                     integer32 = code - edsInt0;                     scale = 0;                     type = edsTypeInt32;                     break;                  case edsIntLen1:                     type = edsTypeInt32;                     scale = 0;                     integer32 = (sbyte)source[offset++];                     break;                  case edsIntLen2:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset] << 8) | (source[offset + 1] & 0xff);                     offset += 2;                     break;                  case edsIntLen3:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset]) << 16 | (source[offset + 1] & 0xff) << 8 | (source[offset + 2] & 0xff);                     offset += 3;                     break;                  case edsIntLen4:                     type = edsTypeInt32;                     scale = 0;                     integer32 = ((sbyte)source[offset]) << 24 | (source[offset + 1] & 0xff) << 16 | (source[offset + 2] & 0xff) << 8 | (source[offset + 3] & 0xff);                     offset += 4;                     break;                  case edsIntLen5:                 case edsIntLen6:                 case edsIntLen7:                 case edsIntLen8:                     l = code - edsIntLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeInt64;                     break;                  case edsScaledLen0:                     scale = (sbyte)source[offset++];                     integer64 = 0;                     type = edsTypeScaled;                     break;                  case edsScaledLen1:                 case edsScaledLen2:                 case edsScaledLen3:                 case edsScaledLen4:                 case edsScaledLen5:                 case edsScaledLen6:                 case edsScaledLen7:                 case edsScaledLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaled;                     break;                  case edsUtf8Len0:                 case edsUtf8Len1:                 case edsUtf8Len2:                 case edsUtf8Len3:                 case edsUtf8Len4:                 case edsUtf8Len5:                 case edsUtf8Len6:                 case edsUtf8Len7:                 case edsUtf8Len8:                 case edsUtf8Len9:                 case edsUtf8Len10:                 case edsUtf8Len11:                 case edsUtf8Len12:                 case edsUtf8Len13:                 case edsUtf8Len14:                 case edsUtf8Len15:                 case edsUtf8Len16:                 case edsUtf8Len17:                 case edsUtf8Len18:                 case edsUtf8Len19:                 case edsUtf8Len20:                 case edsUtf8Len21:                 case edsUtf8Len22:                 case edsUtf8Len23:                 case edsUtf8Len24:                 case edsUtf8Len25:                 case edsUtf8Len26:                 case edsUtf8Len27:                 case edsUtf8Len28:                 case edsUtf8Len29:                 case edsUtf8Len30:                 case edsUtf8Len31:                 case edsUtf8Len32:                 case edsUtf8Len33:                 case edsUtf8Len34:                 case edsUtf8Len35:                 case edsUtf8Len36:                 case edsUtf8Len37:                 case edsUtf8Len38:                 case edsUtf8Len39:                     l = code - edsUtf8Len0;                     @string = getString(source' offset' l);                     offset += l;                     type = edsTypeUtf8;                     break;                  case edsUtf8Count1:                 case edsUtf8Count2:                 case edsUtf8Count3:                 case edsUtf8Count4:                     count = code - edsUtf8Count1;                     int length = source[offset++] & 0xff;                      for (int n = 0; n < count; ++n)                     {                         length = length << 8 | (source[offset++] & 0xff);                     }                      @string = getString(source' offset' length);                     offset += length;                     type = edsTypeUtf8;                     break;                  case edsOpaqueLen0:                 case edsOpaqueLen1:                 case edsOpaqueLen2:                 case edsOpaqueLen3:                 case edsOpaqueLen4:                 case edsOpaqueLen5:                 case edsOpaqueLen6:                 case edsOpaqueLen7:                 case edsOpaqueLen8:                 case edsOpaqueLen9:                 case edsOpaqueLen10:                 case edsOpaqueLen11:                 case edsOpaqueLen12:                 case edsOpaqueLen13:                 case edsOpaqueLen14:                 case edsOpaqueLen15:                 case edsOpaqueLen16:                 case edsOpaqueLen17:                 case edsOpaqueLen18:                 case edsOpaqueLen19:                 case edsOpaqueLen20:                 case edsOpaqueLen21:                 case edsOpaqueLen22:                 case edsOpaqueLen23:                 case edsOpaqueLen24:                 case edsOpaqueLen25:                 case edsOpaqueLen26:                 case edsOpaqueLen27:                 case edsOpaqueLen28:                 case edsOpaqueLen29:                 case edsOpaqueLen30:                 case edsOpaqueLen31:                 case edsOpaqueLen32:                 case edsOpaqueLen33:                 case edsOpaqueLen34:                 case edsOpaqueLen35:                 case edsOpaqueLen36:                 case edsOpaqueLen37:                 case edsOpaqueLen38:                 case edsOpaqueLen39:                     l = code - edsOpaqueLen0;                     bytes = new byte[l];                     Array.Copy(source' offset' bytes' 0' l);                     offset += l;                     type = edsTypeOpaque;                     break;                  case edsOpaqueCount1:                 case edsOpaqueCount2:                 case edsOpaqueCount3:                 case edsOpaqueCount4:                     count = code - edsOpaqueCount1 + 1;                     l = source[offset++] & 0xff;                      for (int n = 1; n < count; ++n)                     {                         l = l << 8 | (source[offset++] & 0xff);                     }                      bytes = new byte[l];                     Array.Copy(source' offset' bytes' 0' l);                     offset += l;                     type = edsTypeOpaque;                     break;                  case edsDoubleLen0:                 case edsDoubleLen1:                 case edsDoubleLen2:                 case edsDoubleLen3:                 case edsDoubleLen4:                 case edsDoubleLen5:                 case edsDoubleLen6:                 case edsDoubleLen7:                 case edsDoubleLen8:                     count = code - edsDoubleLen0;                     long lvalue = 0;                      for (int n = 0; n < count; ++n)                     {                         lvalue = (lvalue << 8) | (source[offset++] & 0xff);                     }                      lvalue <<= (8 - count) * 8;                     dbl = BitConverter.Int64BitsToDouble(lvalue);                     type = edsTypeDouble;                     break;                  case edsTimeLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeTime;                     break;                  case edsTimeLen1:                 case edsTimeLen2:                 case edsTimeLen3:                 case edsTimeLen4:                     l = code - edsTimeLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeTime;                     break;                  case edsMilliSecLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeMilliseconds;                     break;                  case edsMilliSecLen1:                 case edsMilliSecLen2:                 case edsMilliSecLen3:                 case edsMilliSecLen4:                 case edsMilliSecLen5:                 case edsMilliSecLen6:                 case edsMilliSecLen7:                 case edsMilliSecLen8:                     l = code - edsMilliSecLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeMilliseconds;                     break;                  case edsNanoSecLen0:                     integer64 = 0;                     scale = 0;                     type = edsTypeNanoseconds;                     break;                  case edsNanoSecLen1:                 case edsNanoSecLen2:                 case edsNanoSecLen3:                 case edsNanoSecLen4:                 case edsNanoSecLen5:                 case edsNanoSecLen6:                 case edsNanoSecLen7:                 case edsNanoSecLen8:                     l = code - edsNanoSecLen1;                     integer64 = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      scale = 0;                     type = edsTypeNanoseconds;                     break;                  //                 // 09/2012 Added support for new scaled date/times encoding. These replace the old encoding                 // edsTimeLen' edsMilliSecLen and edsNanoSecLen.                 //                  case edsScaledTimeLen1:                 case edsScaledTimeLen2:                 case edsScaledTimeLen3:                 case edsScaledTimeLen4:                 case edsScaledTimeLen5:                 case edsScaledTimeLen6:                 case edsScaledTimeLen7:                 case edsScaledTimeLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledTimeLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledTime;                     break;                  case edsScaledDateLen1:                 case edsScaledDateLen2:                 case edsScaledDateLen3:                 case edsScaledDateLen4:                 case edsScaledDateLen5:                 case edsScaledDateLen6:                 case edsScaledDateLen7:                 case edsScaledDateLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledDateLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledDate;                     break;                  case edsScaledTimestampLen1:                 case edsScaledTimestampLen2:                 case edsScaledTimestampLen3:                 case edsScaledTimestampLen4:                 case edsScaledTimestampLen5:                 case edsScaledTimestampLen6:                 case edsScaledTimestampLen7:                 case edsScaledTimestampLen8:                     scale = (sbyte)source[offset++];                     l = code - edsScaledTimestampLen1 + 1;                     integer64 = (sbyte)source[offset++];                      for (int n = 1; n < l; ++n)                     {                         integer64 = (integer64 << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeScaledTimestamp;                     break;                  case edsClobLen0:                     blobId = 0;                     type = edsTypeClob;                     break;                  case edsClobLen1:                 case edsClobLen2:                 case edsClobLen3:                 case edsClobLen4:                     l = code - edsClobLen1;                     blobId = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         blobId = (blobId << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeClob;                     break;                  case edsBlobLen0:                     blobId = 0;                     type = edsTypeBlob;                     break;                  case edsBlobLen1:                 case edsBlobLen2:                 case edsBlobLen3:                 case edsBlobLen4:                     l = code - edsBlobLen1;                     blobId = (sbyte)source[offset++];                      for (int n = 0; n < l; ++n)                     {                         blobId = (blobId << 8) | (source[offset++] & 0xff);                     }                      type = edsTypeBlob;                     break;                  case edsScaledCount1:                     {                         // For some reason C++ EncodedStream expects the encoded                         // length to be length+1.                          length = (source[offset++] & 0xff) - 1;                         scale = (sbyte)source[offset++];                         type = edsTypeBigInt;                         bytes = new byte[length];                         Array.Copy(source' offset' bytes' 0' length);                         offset += length;                         int sign = ((bytes[0] & 0x80) > 0) ? -1 : 1;                          if (sign == -1)                         {                             bytes[0] &= 0x7f;                         }                          BigInteger bi = new BigInteger(bytes);                         bigDecimal = Decimal.Parse(bi.ToString());                     }                     break;                  case edsScaledCount2:                     {                         // For some reason C++ EncodedStream expects the encoded                         // length to be length+1.                          scale = (sbyte)source[offset++];                         sbyte sign = (sbyte)source[offset++];                         length = (source[offset++] & 0xff); // in bytes                         type = edsTypeBigInt;                         bytes = new byte[length];                         Array.Copy(source' offset' bytes' 0' length);                         offset += length;                          if (sign == -1)                             bytes[0] &= 0x7f;                         else                             sign = 1;                          BigInteger bi = new BigInteger(bytes);                         if (sign == -1)                             bi = -bi;                         bigDecimal = ScaleDecimal(Decimal.Parse(bi.ToString())' scale);                     }                     break;                  case edsUUID:                     {                         byte[] buff = new byte[16];                          for (int n = 0; n < 16; ++n)                         {                             buff[n] = (byte)(source[offset++] & 0xff);                         }                          uuid = new Guid(buff);                         type = edsTypeUUID;                     }                     break;                  default:                     type = edsTypeUnknown;                     break;             }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,encodeScaledDate,The following statement contains a magic number: long value = (long)span.TotalMilliseconds / 1000;
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,encodeDouble,The following statement contains a magic number: write(edsDoubleLen0 + 8);
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,encodeOldBigDecimal,The following statement contains a magic number: BigInteger bi = new BigInteger(Decimal.Truncate(Math.Abs(temp)).ToString()' 10);
Magic Number,NuoDb.Data.Client,Value,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Value.cs,getString,The following statement contains a magic number: char[] chars = new char[23];
Magic Number,NuoDb.Data.Client,Value,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Value.cs,getString,The following statement contains a magic number: chars[digits++] = (char)('0' + n % 10);
Magic Number,NuoDb.Data.Client,Value,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Value.cs,reScale,The following statement contains a magic number: number *= 10;
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,BigInteger,The following statement contains a magic number: value >>= 32;
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,BigInteger,The following statement contains a magic number: value >>= 32;
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,BigInteger,The following statement contains a magic number: dataLength = inData.Length >> 2;
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,BigInteger,The following statement contains a magic number: data[j] = (uint)((inData[i - 3] << 24) + (inData[i - 2] << 16) +                                  (inData[i - 1] << 8) + inData[i]);
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,BigInteger,The following statement contains a magic number: data[j] = (uint)((inData[i - 3] << 24) + (inData[i - 2] << 16) +                                  (inData[i - 1] << 8) + inData[i]);
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,BigInteger,The following statement contains a magic number: data[j] = (uint)((inData[i - 3] << 24) + (inData[i - 2] << 16) +                                  (inData[i - 1] << 8) + inData[i]);
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,BigInteger,The following statement contains a magic number: data[j] = (uint)((inData[i - 3] << 24) + (inData[i - 2] << 16) +                                  (inData[i - 1] << 8) + inData[i]);
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,BigInteger,The following statement contains a magic number: data[j] = (uint)((inData[i - 3] << 24) + (inData[i - 2] << 16) +                                  (inData[i - 1] << 8) + inData[i]);
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,BigInteger,The following statement contains a magic number: i >= 3
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,BigInteger,The following statement contains a magic number: dataLength = inLen >> 2;
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,BigInteger,The following statement contains a magic number: data[j] = (uint)((inData[i - 3] << 24) + (inData[i - 2] << 16) +                                  (inData[i - 1] << 8) + inData[i]);
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,BigInteger,The following statement contains a magic number: data[j] = (uint)((inData[i - 3] << 24) + (inData[i - 2] << 16) +                                  (inData[i - 1] << 8) + inData[i]);
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,BigInteger,The following statement contains a magic number: data[j] = (uint)((inData[i - 3] << 24) + (inData[i - 2] << 16) +                                  (inData[i - 1] << 8) + inData[i]);
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,BigInteger,The following statement contains a magic number: data[j] = (uint)((inData[i - 3] << 24) + (inData[i - 2] << 16) +                                  (inData[i - 1] << 8) + inData[i]);
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,BigInteger,The following statement contains a magic number: data[j] = (uint)((inData[i - 3] << 24) + (inData[i - 2] << 16) +                                  (inData[i - 1] << 8) + inData[i]);
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,BigInteger,The following statement contains a magic number: i >= 3
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,randomBits,The following statement contains a magic number: int numBytes = (int)(((long)numBits + 7) / 8);
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,randomBits,The following statement contains a magic number: int numBytes = (int)(((long)numBits + 7) / 8);
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,randomBits,The following statement contains a magic number: int excessBits = 8 * numBytes - numBits;
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,randomBits,The following statement contains a magic number: randomBits[0] &= (byte)((1 << (8 - excessBits)) - 1);
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,shiftLeft,The following statement contains a magic number: int shiftAmount = 32;
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,shiftLeft,The following statement contains a magic number: carry = val >> 32;
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,shiftRight,The following statement contains a magic number: int shiftAmount = 32;
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,shiftRight,The following statement contains a magic number: invShift = 32 - shiftAmount;
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,multiByteDivide,The following statement contains a magic number: ulong secondDivisorByte = bi2.data[bi2.dataLength - 2];
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,multiByteDivide,The following statement contains a magic number: ulong dividend = ((ulong)remainder[pos] << 32) + (ulong)remainder[pos - 1];
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,multiByteDivide,The following statement contains a magic number: q_hat == 0x100000000 ||                        (q_hat * secondDivisorByte) > ((r_hat << 32) + remainder[pos - 2])
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,multiByteDivide,The following statement contains a magic number: q_hat == 0x100000000 ||                        (q_hat * secondDivisorByte) > ((r_hat << 32) + remainder[pos - 2])
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,singleByteDivide,The following statement contains a magic number: dividend = ((ulong)outRemainder.data[pos + 1] << 32) + (ulong)outRemainder.data[pos];
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,ToString,The following statement contains a magic number: return ToString(10);
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,ToString,The following statement contains a magic number: radix < 2 || radix > 36
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,ToString,The following statement contains a magic number: radix < 2 || radix > 36
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,modPow,The following statement contains a magic number: index < 32
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,BarrettReduction,The following statement contains a magic number: mcarry = (val >> 32);
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,bitCount,The following statement contains a magic number: int bits = 32;
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,bitCount,The following statement contains a magic number: bits += ((dataLength - 1) << 5);
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,ToByteArray,The following statement contains a magic number: int numBytes = numBits >> 3;
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,ToByteArray,The following statement contains a magic number: (tempVal = (val >> 24)) != 0
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,ToByteArray,The following statement contains a magic number: (tempVal = (val >> 16)) != 0
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,ToByteArray,The following statement contains a magic number: (tempVal = (val >> 8)) != 0
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,ToByteArray,The following statement contains a magic number: result[pos + 3] = (byte)(val & 0xFF);
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,ToByteArray,The following statement contains a magic number: val >>= 8;
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,ToByteArray,The following statement contains a magic number: result[pos + 2] = (byte)(val & 0xFF);
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,ToByteArray,The following statement contains a magic number: val >>= 8;
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,ToByteArray,The following statement contains a magic number: val >>= 8;
Magic Number,NuoDb.Data.Client.Security,RemoteGroup,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\RemoteGroup.cs,RemoteGroup,The following statement contains a magic number: generator = new BigInteger(2);
Magic Number,NuoDb.Data.Client.Security,RemotePassword,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\RemotePassword.cs,RemotePassword,The following statement contains a magic number: hexDigits = new byte[256];
Magic Number,NuoDb.Data.Client.Security,RemotePassword,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\RemotePassword.cs,RemotePassword,The following statement contains a magic number: n < 10
Magic Number,NuoDb.Data.Client.Security,RemotePassword,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\RemotePassword.cs,RemotePassword,The following statement contains a magic number: hexDigits['a' + n] = (byte)(10 + n);
Magic Number,NuoDb.Data.Client.Security,RemotePassword,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\RemotePassword.cs,RemotePassword,The following statement contains a magic number: hexDigits['A' + n] = (byte)(10 + n);
Magic Number,NuoDb.Data.Client.Security,RemotePassword,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\RemotePassword.cs,RemotePassword,The following statement contains a magic number: n < 6
Magic Number,NuoDb.Data.Client.Security,RemotePassword,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\RemotePassword.cs,RemotePassword,The following statement contains a magic number: RemoteGroup group = RemoteGroup.getGroup(1024);
Magic Number,NuoDb.Data.Client.Security,RemotePassword,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\RemotePassword.cs,getBytes,The following statement contains a magic number: int length = hex.Length / 2;
Magic Number,NuoDb.Data.Client.Security,RemotePassword,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\RemotePassword.cs,getBytes,The following statement contains a magic number: bytes[n] = (byte)((hexDigits[hex[c]] << 4) | hexDigits[hex[c + 1]]);
Magic Number,NuoDb.Data.Client.Security,RemotePassword,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\RemotePassword.cs,getHex,The following statement contains a magic number: char[] hex = new char[length * 2];
Magic Number,NuoDb.Data.Client.Security,RemotePassword,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\RemotePassword.cs,getHex,The following statement contains a magic number: int high = b >> 4;
Magic Number,NuoDb.Data.Client.Security,RemotePassword,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\RemotePassword.cs,getHex,The following statement contains a magic number: hex[c++] = (char)((high < 10) ? '0' + high : 'A' + high - 10);
Magic Number,NuoDb.Data.Client.Security,RemotePassword,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\RemotePassword.cs,getHex,The following statement contains a magic number: hex[c++] = (char)((high < 10) ? '0' + high : 'A' + high - 10);
Magic Number,NuoDb.Data.Client.Security,RemotePassword,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\RemotePassword.cs,getHex,The following statement contains a magic number: hex[c++] = (char)((low < 10) ? '0' + low : 'A' + low - 10);
Magic Number,NuoDb.Data.Client.Security,RemotePassword,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\RemotePassword.cs,getHex,The following statement contains a magic number: hex[c++] = (char)((low < 10) ? '0' + low : 'A' + low - 10);
Magic Number,NuoDb.Data.Client.Security,RemotePassword,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\RemotePassword.cs,genClientKey,The following statement contains a magic number: clientPrivateKey = new BigInteger(256' random);
Magic Number,NuoDb.Data.Client.Security,RemotePassword,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\RemotePassword.cs,genServerKey,The following statement contains a magic number: return genServerKey(new BigInteger(256' random)' verifier);
Magic Number,NuoDb.Data.Client.Security,RemotePassword,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\RemotePassword.cs,genSalt,The following statement contains a magic number: BigInteger n = new BigInteger(256' random);
Magic Number,NuoDb.Data.Client.Security,CipherRC4,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\CypherRC4.cs,setKey,The following statement contains a magic number: state = new byte[256];
Magic Number,NuoDb.Data.Client.Security,CipherRC4,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\CypherRC4.cs,setKey,The following statement contains a magic number: k1 < 256
Magic Number,NuoDb.Data.Client.Security,CipherRC4,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\CypherRC4.cs,write,The following statement contains a magic number: buffer = new byte[length + 100];
Magic Number,NuoDb.Data.Client.Util,Op,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\Op.cs,getInt,The following statement contains a magic number: value = value * 10 + c - '0';
Magic Number,NuoDb.Data.Client.Util,Op,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\Op.cs,obfuscate,The following statement contains a magic number: StringBuilder builder = new StringBuilder(512);
Magic Number,NuoDb.Data.Client.Util,Op,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\Op.cs,obfuscate,The following statement contains a magic number: builder.Append((char)('0' + (c / 100) % 10));
Magic Number,NuoDb.Data.Client.Util,Op,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\Op.cs,obfuscate,The following statement contains a magic number: builder.Append((char)('0' + (c / 100) % 10));
Magic Number,NuoDb.Data.Client.Util,Op,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\Op.cs,obfuscate,The following statement contains a magic number: builder.Append((char)('0' + (c / 10) % 10));
Magic Number,NuoDb.Data.Client.Util,Op,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\Op.cs,obfuscate,The following statement contains a magic number: builder.Append((char)('0' + (c / 10) % 10));
Magic Number,NuoDb.Data.Client.Util,Op,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\Op.cs,obfuscate,The following statement contains a magic number: builder.Append((char)('0' + c % 10));
Magic Number,NuoDb.Data.Client.Util,Op,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\Op.cs,getLong,The following statement contains a magic number: value = value * 10 + c - '0';
Magic Number,NuoDb.Data.Client.Util,Op,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\Op.cs,getTimeNoTZN,The following statement contains a magic number: int[] values = new int[3];
Magic Number,NuoDb.Data.Client.Util,Op,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\Op.cs,getTimeNoTZN,The following statement contains a magic number: values[segment] = values[segment] * 10 + c - '0';
Magic Number,NuoDb.Data.Client.Util,Op,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\Op.cs,getTimeNoTZN,The following statement contains a magic number: return values[0] * 60 * 60 + values[1] * 60 + values[2];
Magic Number,NuoDb.Data.Client.Util,Op,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\Op.cs,getTimeNoTZN,The following statement contains a magic number: return values[0] * 60 * 60 + values[1] * 60 + values[2];
Magic Number,NuoDb.Data.Client.Util,Op,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\Op.cs,getTimeNoTZN,The following statement contains a magic number: return values[0] * 60 * 60 + values[1] * 60 + values[2];
Magic Number,NuoDb.Data.Client.Util,Op,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\Op.cs,getTimeNoTZN,The following statement contains a magic number: return values[0] * 60 * 60 + values[1] * 60 + values[2];
Magic Number,NuoDb.Data.Client.Util,Op,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\Op.cs,timeToStringNoTZN,The following statement contains a magic number: int hh = time / (60 * 60);
Magic Number,NuoDb.Data.Client.Util,Op,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\Op.cs,timeToStringNoTZN,The following statement contains a magic number: int hh = time / (60 * 60);
Magic Number,NuoDb.Data.Client.Util,Op,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\Op.cs,timeToStringNoTZN,The following statement contains a magic number: int mm = (time % (60 * 60)) / 60;
Magic Number,NuoDb.Data.Client.Util,Op,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\Op.cs,timeToStringNoTZN,The following statement contains a magic number: int mm = (time % (60 * 60)) / 60;
Magic Number,NuoDb.Data.Client.Util,Op,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\Op.cs,timeToStringNoTZN,The following statement contains a magic number: int mm = (time % (60 * 60)) / 60;
Magic Number,NuoDb.Data.Client.Util,Op,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\Op.cs,timeToStringNoTZN,The following statement contains a magic number: int ss = (time % (60 * 60)) % 60;
Magic Number,NuoDb.Data.Client.Util,Op,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\Op.cs,timeToStringNoTZN,The following statement contains a magic number: int ss = (time % (60 * 60)) % 60;
Magic Number,NuoDb.Data.Client.Util,Op,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\Op.cs,timeToStringNoTZN,The following statement contains a magic number: int ss = (time % (60 * 60)) % 60;
Magic Number,NuoDb.Data.Client.Util,Op,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\Op.cs,timeToStringNoTZN,The following statement contains a magic number: char[] packed = new char[8];
Magic Number,NuoDb.Data.Client.Util,Op,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\Op.cs,timeToStringNoTZN,The following statement contains a magic number: packed[0] = (char)('0' + (hh - (hh % 10)) / 10);
Magic Number,NuoDb.Data.Client.Util,Op,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\Op.cs,timeToStringNoTZN,The following statement contains a magic number: packed[0] = (char)('0' + (hh - (hh % 10)) / 10);
Magic Number,NuoDb.Data.Client.Util,Op,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\Op.cs,timeToStringNoTZN,The following statement contains a magic number: packed[1] = (char)('0' + (hh % 10));
Magic Number,NuoDb.Data.Client.Util,Op,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\Op.cs,timeToStringNoTZN,The following statement contains a magic number: packed[2] = ':';
Magic Number,NuoDb.Data.Client.Util,Op,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\Op.cs,timeToStringNoTZN,The following statement contains a magic number: packed[3] = (char)('0' + (mm - (mm % 10)) / 10);
Magic Number,NuoDb.Data.Client.Util,Op,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\Op.cs,timeToStringNoTZN,The following statement contains a magic number: packed[3] = (char)('0' + (mm - (mm % 10)) / 10);
Magic Number,NuoDb.Data.Client.Util,Op,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\Op.cs,timeToStringNoTZN,The following statement contains a magic number: packed[3] = (char)('0' + (mm - (mm % 10)) / 10);
Magic Number,NuoDb.Data.Client.Util,Op,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\Op.cs,timeToStringNoTZN,The following statement contains a magic number: packed[4] = (char)('0' + (mm % 10));
Magic Number,NuoDb.Data.Client.Util,Op,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\Op.cs,timeToStringNoTZN,The following statement contains a magic number: packed[4] = (char)('0' + (mm % 10));
Magic Number,NuoDb.Data.Client.Util,Op,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\Op.cs,timeToStringNoTZN,The following statement contains a magic number: packed[5] = ':';
Magic Number,NuoDb.Data.Client.Util,Op,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\Op.cs,timeToStringNoTZN,The following statement contains a magic number: packed[6] = (char)('0' + (ss - (ss % 10)) / 10);
Magic Number,NuoDb.Data.Client.Util,Op,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\Op.cs,timeToStringNoTZN,The following statement contains a magic number: packed[6] = (char)('0' + (ss - (ss % 10)) / 10);
Magic Number,NuoDb.Data.Client.Util,Op,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\Op.cs,timeToStringNoTZN,The following statement contains a magic number: packed[6] = (char)('0' + (ss - (ss % 10)) / 10);
Magic Number,NuoDb.Data.Client.Util,Op,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\Op.cs,timeToStringNoTZN,The following statement contains a magic number: packed[7] = (char)('0' + (ss % 10));
Magic Number,NuoDb.Data.Client.Util,Op,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\Op.cs,timeToStringNoTZN,The following statement contains a magic number: packed[7] = (char)('0' + (ss % 10));
Magic Number,NuoDb.Data.Client.Util,StringUtils,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\StringUtils.cs,randomString,The following statement contains a magic number: char c = (char)('a' + r.Next(26));
Magic Number,NuoDb.Data.Client.Xml,Doc,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Xml\Doc.cs,skipWhite,The following statement contains a magic number: offset += 2;
Magic Number,NuoDb.Data.Client.Xml,Doc,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Xml\Doc.cs,checkComment,The following statement contains a magic number: offset += 4;
Magic Number,NuoDb.Data.Client.Xml,Doc,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Xml\Doc.cs,skipComment,The following statement contains a magic number: offset += 2;
Magic Number,NuoDb.Data.Client.Xml,Tag,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Xml\Tag.cs,insert,The following statement contains a magic number: sequence < child.getIntAttribute(attribute' 1000000)
Magic Number,NuoDb.Data.Client.Xml,Tag,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Xml\Tag.cs,parseChildren,The following statement contains a magic number: doc.print("Tag.parseChildren: "' 30);
Magic Number,NuoDb.Data.Client.Xml,Tag,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Xml\Tag.cs,gen,The following statement contains a magic number: int attrIndent = level * 2 + 1 + buffer.Length - start;
Magic Number,NuoDb.Data.Client.Xml,Tag,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Xml\Tag.cs,gen,The following statement contains a magic number: int attrLimit = buffer.Length + 60;
Magic Number,NuoDb.Data.Client.Net,CryptoInputStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Net\CryptoInputStream.cs,CryptoInputStream,The following statement contains a magic number: stream = new BufferedStream(inputStream' 8192);
Magic Number,NuoDb.Data.Client.Net,CryptoInputStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Net\CryptoInputStream.cs,CryptoInputStream,The following statement contains a magic number: lengthBuffer = new byte[4];
Magic Number,NuoDb.Data.Client.Net,CryptoInputStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Net\CryptoInputStream.cs,CryptoInputStream,The following statement contains a magic number: stream = new BufferedStream(inputStream' 8192);
Magic Number,NuoDb.Data.Client.Net,CryptoInputStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Net\CryptoInputStream.cs,CryptoInputStream,The following statement contains a magic number: lengthBuffer = new byte[4];
Magic Number,NuoDb.Data.Client.Net,CryptoInputStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Net\CryptoInputStream.cs,readLength,The following statement contains a magic number: int remaining = 4;
Magic Number,NuoDb.Data.Client.Net,CryptoInputStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Net\CryptoInputStream.cs,readLength,The following statement contains a magic number: int lengthRead = stream.Read(lengthBuffer' 4 - remaining' remaining);
Magic Number,NuoDb.Data.Client.Net,CryptoInputStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Net\CryptoInputStream.cs,readLength,The following statement contains a magic number: length = (length << 8) | (lengthBuffer[n] & 0xff);
Magic Number,NuoDb.Data.Client.Net,CryptoInputStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Net\CryptoInputStream.cs,readLength,The following statement contains a magic number: n < 4
Magic Number,NuoDb.Data.Client.Net,CryptoOutputStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Net\CryptoOutputStream.cs,CryptoOutputStream,The following statement contains a magic number: stream = new BufferedStream(outputStream' 8192);
Magic Number,NuoDb.Data.Client.Net,CryptoOutputStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Net\CryptoOutputStream.cs,CryptoOutputStream,The following statement contains a magic number: stream = new BufferedStream(outputStream' 8192);
Magic Number,NuoDb.Data.Client.Net,CryptoOutputStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Net\CryptoOutputStream.cs,writeLength,The following statement contains a magic number: lengthBuffer = new byte[4];
Magic Number,NuoDb.Data.Client.Net,CryptoOutputStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Net\CryptoOutputStream.cs,writeLength,The following statement contains a magic number: stream.Write(lengthBuffer' 0' 4);
Duplicate Code,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The method contains a code clone-set at the following line numbers (starting from the method definition): ((409' 442)' (503' 536))
Duplicate Code,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The method contains a code clone-set at the following line numbers (starting from the method definition): ((563' 591)' (614' 642))
Missing Default,NuoDb.Data.Client,NuoDbCommand,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbCommand.cs,Prepare,The following switch statement is missing a default case: switch (direction)                     {                         case 0: newParams[i].Direction = ParameterDirection.Input; break;                         case 1: newParams[i].Direction = ParameterDirection.InputOutput; break;                         case 2: newParams[i].Direction = ParameterDirection.Output; break;                     }
Missing Default,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The following switch statement is missing a default case: switch (reader.GetFieldValue<int>("TYPE"))                                 {                                     case 0:                                         row["INDEX_TYPE"] = "Primary";                                         break;                                     case 1:                                         row["INDEX_TYPE"] = "Unique";                                         break;                                     case 2:                                         row["INDEX_TYPE"] = "Secondary";                                         break;                                     case 3:                                         row["INDEX_TYPE"] = "Foreign Key";                                         break;                                 }
Missing Default,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapDbTypeToNetType,The following switch statement is missing a default case: switch ((DbType)dbType)             {                 case DbType.Boolean: return "System.Boolean";                 case DbType.Int16: return "System.Int16";                 case DbType.Int32: return "System.Int32";                 case DbType.Int64: return "System.Int64";                 case DbType.Single: return "System.Single";                 case DbType.Double: return "System.Double";                 case DbType.Decimal: return "System.Decimal";                 case DbType.Byte: return "System.Byte";                 case DbType.String: return "System.String";                 case DbType.Date:                 case DbType.Time:                 case DbType.DateTime: return "System.DateTime";                 case DbType.Binary:                 case DbType.Object: return "System.Object";             }
Missing Default,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapJavaSqlToDbType,The following switch statement is missing a default case: switch (jSQL)             {                 case -7: //BIT                     return DbType.Boolean;                 case -6: //TINYINT                 case 5: //SMALLINT                 case 4: //INTEGER                     return DbType.Int32;                 case -5: //BIGINT                     return DbType.Int64;                 case 6: //FLOAT                 case 7: //REAL                     return DbType.Single;                 case 8: //DOUBLE                     return DbType.Double;                 case 2: //NUMERIC                 case 3: //DECIMAL                     return DbType.Decimal;                 case 1: //CHAR                 case 12: //VARCHAR                 case -1: //LONGVARCHAR                     return DbType.String;                 case 91: //DATE                     return DbType.Date;                 case 92: //TIME                     return DbType.Time;                 case 93: //TIMESTAMP                     return DbType.DateTime;                 case -2: //BINARY                 case -3: //VARBINARY                 case -4: //LONGVARBINARY                     return DbType.Binary;                 case 0: //NULL                 case 1111: //OTHER                 case 2000: //JAVA_OBJECT                 case 2001: //DISTINCT                 case 2002: //STRUCT                 case 2003: //ARRAY                 case 2004: //BLOB                 case 2005: //CLOB                 case 2006: //REF                 case 70: //DATALINK                     return DbType.Object;                 case 16: //BOOLEAN                     return DbType.Boolean;                 //------------------------- JDBC 4.0 -----------------------------------                 case -15: //NCHAR                 case -9: //NVARCHAR                  case -16: //LONGNVARCHAR                 case 2011: //NCLOB                     return DbType.String;                 case 2009: //SQLXML                      return DbType.Xml;                 case -8: //ROWID                     return DbType.Object;             }
Missing Default,NuoDb.Data.Client,NuoDbConnectionInternal,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapDbTypeToJavaSql,The following switch statement is missing a default case: switch (dbType)             {                 case DbType.Boolean:                     return 16; //BOOLEAN                 case DbType.Int32:                     return 4; //INTEGER                 case DbType.Int64:                     return -5; //BIGINT                 case DbType.Single:                     return 7; //REAL                 case DbType.Double:                     return 8; //DOUBLE                 case DbType.Decimal:                     return 3; //DECIMAL                 case DbType.Xml:                 case DbType.String:                     return 12; //VARCHAR                 case DbType.Date:                     return 91; //DATE                 case DbType.Time:                     return 92; //TIME                 case DbType.DateTime:                     return 93; //TIMESTAMP                 case DbType.Binary:                     return -3; //VARBINARY                 case DbType.Object:                     return 2004; //BLOB             }
Missing Default,NuoDb.Data.Client,EncodedDataStream,C:\research\architectureSmells\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,getValue,The following switch statement is missing a default case: switch (type)             {                 case edsTypeNull:                     return new ValueNull();                  case edsTypeUtf8:                     return new ValueString(@string);                  case edsTypeOpaque:                     return new ValueBytes(bytes);                  case edsTypeScaled:                     return new ValueNumber(ScaleDecimal(integer64' scale));                  case edsTypeInt32:                     return new ValueInt(integer32' 0);                  case edsTypeInt64:                     return new ValueLong(integer64' 0);                  case edsTypeBoolean:                     return new ValueBoolean(@bool);                  case edsTypeDouble:                     return new ValueDouble(dbl);                  case edsTypeScaledTime:                     {                         long inNanos = Value.reScale(integer64' scale' NANOSECONDS_SCALE);                         DateTime utcTime = new DateTime(baseDate.Ticks + inNanos / NANOSECONDS_PER_TICK' DateTimeKind.Utc);                         DateTime localTime = TimeZoneInfo.ConvertTimeFromUtc(utcTime' sqlContext.TimeZone);                         return new ValueTime(localTime);                     }                  case edsTypeTime:                     {                         DateTime utcTime = new DateTime(baseDate.Ticks + integer64 * TimeSpan.TicksPerMillisecond' DateTimeKind.Utc);                         DateTime localTime = TimeZoneInfo.ConvertTimeFromUtc(utcTime' sqlContext.TimeZone);                         return new ValueTime(localTime);                     }                  case edsTypeScaledDate:                     {                         long inSeconds = Value.reScale(integer64' scale' SECONDS_SCALE);                         DateTime utcTime = new DateTime(baseDate.Ticks + inSeconds * TimeSpan.TicksPerSecond' DateTimeKind.Utc);                         DateTime localTime = TimeZoneInfo.ConvertTimeFromUtc(utcTime' sqlContext.TimeZone);                         return new ValueDate(localTime);                     }                  case edsTypeMilliseconds:                     {                         DateTime utcTime = new DateTime(baseDate.Ticks + integer64 * TimeSpan.TicksPerMillisecond' DateTimeKind.Utc);                         DateTime localTime = TimeZoneInfo.ConvertTimeFromUtc(utcTime' sqlContext.TimeZone);                         return new ValueDate(localTime);                     }                  case edsTypeScaledTimestamp:                     {                         long inNanos = Value.reScale(integer64' scale' NANOSECONDS_SCALE);                         DateTime utcTime = new DateTime(baseDate.Ticks + inNanos / NANOSECONDS_PER_TICK' DateTimeKind.Utc);                         DateTime localTime = TimeZoneInfo.ConvertTimeFromUtc(utcTime' sqlContext.TimeZone);                         return new ValueTimestamp(localTime);                     }                  case edsTypeNanoseconds:                     {                         DateTime utcTime = new DateTime(baseDate.Ticks + integer64 / NANOSECONDS_PER_TICK' DateTimeKind.Utc);                         DateTime localTime = TimeZoneInfo.ConvertTimeFromUtc(utcTime' sqlContext.TimeZone);                         return new ValueTimestamp(localTime);                     }                  case edsTypeBigInt:                     return new ValueNumber(bigDecimal);              }
