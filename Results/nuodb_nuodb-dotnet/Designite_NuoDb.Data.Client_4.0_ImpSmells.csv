Implementation smell,Namespace,Class,File,Method,Description
Long Method,NuoDb.Data.Client,NuoDbBulkLoader,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbBulkLoader.cs,WriteToServer,The method has 125 lines of code.
Long Method,NuoDb.Data.Client,NuoDbCommand,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbCommand.cs,Prepare,The method has 240 lines of code.
Long Method,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,doOpen,The method has 273 lines of code.
Long Method,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The method has 718 lines of code.
Long Method,NuoDb.Data.Client,NuoDbDataReader,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbDataReader.cs,GetSchemaTable,The method has 142 lines of code.
Long Method,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,decode,The method has 468 lines of code.
Long Method,NuoDb.Data.Client.EntityFramework.SqlGen,SqlGenerator,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EntityFramework\SqlGen\SqlGenerator.cs,Visit,The method has 117 lines of code.
Long Method,NuoDb.Data.Client.EntityFramework.SqlGen,SqlGenerator,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EntityFramework\SqlGen\SqlGenerator.cs,VisitJoinExpression,The method has 145 lines of code.
Long Method,NuoDb.Data.Client.EntityFramework.SqlGen,SqlGenerator,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EntityFramework\SqlGen\SqlGenerator.cs,AddColumns,The method has 102 lines of code.
Long Method,NuoDb.Data.Client.EntityFramework.SqlGen,SqlSelectStatement,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EntityFramework\SqlGen\SqlSelectStatement.cs,WriteSql,The method has 118 lines of code.
Complex Method,NuoDb.Data.Client,NuoDbBulkLoader,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbBulkLoader.cs,WriteToServer,Cyclomatic complexity of the method is 9
Complex Method,NuoDb.Data.Client,NuoDbMultipleCommands,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbMultipleCommands.cs,splitStatements,Cyclomatic complexity of the method is 9
Complex Method,NuoDb.Data.Client,NuoDbCommand,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbCommand.cs,ExecuteBatch,Cyclomatic complexity of the method is 10
Complex Method,NuoDb.Data.Client,NuoDbCommand,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbCommand.cs,Prepare,Cyclomatic complexity of the method is 20
Complex Method,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,doOpen,Cyclomatic complexity of the method is 21
Complex Method,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapNuoDbToNetType,Cyclomatic complexity of the method is 11
Complex Method,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,Cyclomatic complexity of the method is 8
Complex Method,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,Cyclomatic complexity of the method is 17
Complex Method,NuoDb.Data.Client.EntityFramework,NuoDbProviderServices,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EntityFramework\NuoDbProviderServices.cs,CreateDbCommandDefinition,Cyclomatic complexity of the method is 10
Complex Method,NuoDb.Data.Client.EntityFramework,NuoDbProviderServices,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EntityFramework\NuoDbProviderServices.cs,PrepareTypeCoercions,Cyclomatic complexity of the method is 9
Complex Method,NuoDb.Data.Client.EntityFramework.SqlGen,SqlGenerator,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EntityFramework\SqlGen\SqlGenerator.cs,GetTargetSql,Cyclomatic complexity of the method is 9
Complex Method,NuoDb.Data.Client.EntityFramework.SqlGen,SqlGenerator,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EntityFramework\SqlGen\SqlGenerator.cs,VisitJoinExpression,Cyclomatic complexity of the method is 19
Complex Method,NuoDb.Data.Client.EntityFramework.SqlGen,SqlSelectStatement,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EntityFramework\SqlGen\SqlSelectStatement.cs,WriteSql,Cyclomatic complexity of the method is 17
Complex Method,NuoDb.Data.Client.Security,BigInteger,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,BigInteger,Cyclomatic complexity of the method is 8
Complex Method,NuoDb.Data.Client.Security,BigInteger,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,multiByteDivide,Cyclomatic complexity of the method is 16
Complex Method,NuoDb.Data.Client.Security,BigInteger,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,singleByteDivide,Cyclomatic complexity of the method is 10
Complex Method,NuoDb.Data.Client.Security,BigInteger,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,modPow,Cyclomatic complexity of the method is 11
Complex Method,NuoDb.Data.Client.Security,BigInteger,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,BarrettReduction,Cyclomatic complexity of the method is 13
Complex Method,NuoDb.Data.Client.Xml,Tag,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Xml\Tag.cs,parseChildren,Cyclomatic complexity of the method is 10
Long Parameter List,NuoDb.Data.Client,TypedDbReader,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbMultipleCommands.cs,GetBytes,The method has 5 parameters. Parameters: ordinal' dataOffset' buffer' bufferOffset' length
Long Parameter List,NuoDb.Data.Client,TypedDbReader,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbMultipleCommands.cs,GetChars,The method has 5 parameters. Parameters: ordinal' dataOffset' buffer' bufferOffset' length
Long Parameter List,NuoDb.Data.Client,NuoDbDataReader,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbDataReader.cs,NuoDbDataReader,The method has 5 parameters. Parameters: connection' handle' dataStream' statement' readColumnNames
Long Parameter List,NuoDb.Data.Client,NuoDbDataReader,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbDataReader.cs,GetBytes,The method has 5 parameters. Parameters: i' fieldOffset' buffer' bufferoffset' length
Long Parameter List,NuoDb.Data.Client,NuoDbDataReader,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbDataReader.cs,GetChars,The method has 5 parameters. Parameters: i' fieldoffset' buffer' bufferoffset' length
Long Parameter List,NuoDb.Data.Client.EntityFramework.SqlGen,SqlGenerator,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EntityFramework\SqlGen\SqlGenerator.cs,ProcessJoinInputResult,The method has 6 parameters. Parameters: fromExtentFragment' result' inputExpression' inputVariableName' inputVariableType' fromSymbolStart
Long Parameter List,NuoDb.Data.Client.EntityFramework.SqlGen,SqlGenerator,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EntityFramework\SqlGen\SqlGenerator.cs,AddColumns,The method has 5 parameters. Parameters: selectStatement' symbol' columnList' columnDictionary' separator
Long Parameter List,NuoDb.Data.Client.EntityFramework.SqlGen,SqlGenerator,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EntityFramework\SqlGen\SqlGenerator.cs,CreateNewSelectStatement,The method has 5 parameters. Parameters: oldStatement' inputVarName' inputVarType' finalizeOldStatement' fromSymbol
Long Parameter List,NuoDb.Data.Client.Util,StringUtils,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\StringUtils.cs,overwrite,The method has 5 parameters. Parameters: origString' pos' newString' newPos' newLength
Long Identifier,NuoDb.Data.Client,Protocol,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Protocol.cs,,The length of the parameter DbmbDefaultTransactionIsolation is 31.
Long Identifier,NuoDb.Data.Client.EntityFramework,NuoDbProviderManifest,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EntityFramework\NuoDbProviderManifest.cs,,The length of the parameter StoreSchemaDefinitionResourceName is 33.
Long Identifier,NuoDb.Data.Client.EntityFramework,NuoDbProviderManifest,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EntityFramework\NuoDbProviderManifest.cs,,The length of the parameter StoreSchemaMappingResourceName is 30.
Long Identifier,NuoDb.Data.Client.EntityFramework.SqlGen,DmlSqlGenerator,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EntityFramework\SqlGen\DmlSqlGenerator.cs,,The length of the parameter CommandTextBuilderInitialCapacity is 33.
Long Identifier,NuoDb.Data.Client.EntityFramework.SqlGen,MetadataHelpers,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EntityFramework\SqlGen\MetadataHelpers.cs,,The length of the parameter StoreGeneratedPatternFacetName is 30.
Long Identifier,NuoDb.Data.Client.EntityFramework.SqlGen,SqlGenerator,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EntityFramework\SqlGen\SqlGenerator.cs,InitializeFunctionNameToOperatorDictionary,The length of the parameter functionNameToOperatorDictionary is 32.
Long Identifier,NuoDb.Data.Client.EntityFramework.SqlGen,SqlGenerator,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EntityFramework\SqlGen\SqlGenerator.cs,,The length of the parameter _functionNameToOperatorDictionary is 33.
Long Statement,NuoDb.Data.Client,NuoDbBulkLoader,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbBulkLoader.cs,WriteToServer,The length of the statement  "                            throw new IndexOutOfRangeException(String.Format("The specified ordinal of the target column ({0}) is outside the range of the column count ({1}) of table {2}"' " is 160.
Long Statement,NuoDb.Data.Client,NuoDbBulkLoader,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbBulkLoader.cs,WriteToServer,The length of the statement  "                            throw new IndexOutOfRangeException(String.Format("The specified ordinal of the source column ({0}) is outside the range of the column count ({1})"' " is 147.
Long Statement,NuoDb.Data.Client,NuoDbBulkLoader,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbBulkLoader.cs,WriteToServer,The length of the statement  "            WriteToServer(table' DataRowState.Added | DataRowState.Deleted | DataRowState.Detached | DataRowState.Modified | DataRowState.Unchanged); " is 137.
Long Statement,NuoDb.Data.Client,IsolationLevelsListConverter,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionStringBuilder.cs,GetStandardValues,The length of the statement  "            return new StandardValuesCollection(new string[] { ""' "ReadCommitted"' "WriteCommitted"' "ConsistentRead"' "Serializable"}); " is 125.
Long Statement,NuoDb.Data.Client,NuoDbCommand,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbCommand.cs,updateLastCommitInfo,The length of the statement  "            if (connection.InternalConnection.protocolVersion >= Protocol.PROTOCOL_VERSION2 && connection.InternalConnection.protocolVersion < Protocol.PROTOCOL_VERSION7 && generatingKeys) " is 176.
Long Statement,NuoDb.Data.Client,NuoDbCommand,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbCommand.cs,updateLastCommitInfo,The length of the statement  "            if ((connection.InternalConnection.protocolVersion >= Protocol.PROTOCOL_VERSION3 && !generatingKeys) || connection.InternalConnection.protocolVersion >= Protocol.PROTOCOL_VERSION7) " is 180.
Long Statement,NuoDb.Data.Client,NuoDbCommand,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbCommand.cs,ExecuteBatch,The length of the statement  "            ExecuteBatch(parameters' DataRowState.Added | DataRowState.Deleted | DataRowState.Detached | DataRowState.Modified | DataRowState.Unchanged); " is 141.
Long Statement,NuoDb.Data.Client,NuoDbCommand,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbCommand.cs,ExecuteDbDataReader,The length of the statement  "                NuoDbDataReader reader = generatedKeys != null ? generatedKeys : new NuoDbDataReader(connection' -1' null' this' false); " is 120.
Long Statement,NuoDb.Data.Client,NuoDbCommand,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbCommand.cs,ExecuteUpdate,The length of the statement  "            if (connection.InternalConnection.protocolVersion >= Protocol.PROTOCOL_VERSION2 && connection.InternalConnection.protocolVersion < Protocol.PROTOCOL_VERSION7) " is 158.
Long Statement,NuoDb.Data.Client,NuoDbCommand,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbCommand.cs,InvokeStoredProcedure,The length of the statement  "                throw new NuoDbSqlException(String.Format("server protocol {0} doesn't support prepareCall"' connection.InternalConnection.protocolVersion)); " is 141.
Long Statement,NuoDb.Data.Client,NuoDbCommand,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbCommand.cs,Prepare,The length of the statement  "            // if we are given just the name of the stored procedure' retrieve the number of parameters and generate the full command " is 121.
Long Statement,NuoDb.Data.Client,NuoDbCommand,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbCommand.cs,Prepare,The length of the statement  "                    paramTable = NuoDbConnectionInternal.GetSchemaHelper(connection' "ProcedureParameters"' new string[] { null' parts[0].Trim(quotes)' parts[1].Trim(quotes)' null }); " is 163.
Long Statement,NuoDb.Data.Client,NuoDbCommand,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbCommand.cs,Prepare,The length of the statement  "                    paramTable = NuoDbConnectionInternal.GetSchemaHelper(connection' "ProcedureParameters"' new string[] { null' schema' parts[0].Trim(quotes)' null }); " is 148.
Long Statement,NuoDb.Data.Client,NuoDbCommand,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbCommand.cs,Prepare,The length of the statement  "                        throw new NuoDbSqlException(String.Format("Internal error: unexpected ordering of the parameters of the procedure {0}"' nuodbSqlString)); " is 137.
Long Statement,NuoDb.Data.Client,NuoDbCommand,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbCommand.cs,Prepare,The length of the statement  "                        default: throw new NuoDbSqlException(String.Format("Internal error: unexpected parameter type for procedure {0}"' nuodbSqlString)); " is 131.
Long Statement,NuoDb.Data.Client,NuoDbCommand,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbCommand.cs,Prepare,The length of the statement  "                    newParams[newParams.Count - 1].DbType = NuoDbConnectionInternal.mapJavaSqlToDbType(row.Field<int>("PARAMETER_DATA_TYPE")); " is 122.
Long Statement,NuoDb.Data.Client,NuoDbCommand,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbCommand.cs,Prepare,The length of the statement  "                    throw new NuoDbSqlException(String.Format("server protocol {0} doesn't support prepareCall"' connection.InternalConnection.protocolVersion)); " is 141.
Long Statement,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,getProcessConnection,The length of the statement  "            for (processConnection = processConnections; processConnection != null && !processConnection.isThisDatabase(databaseName); processConnection = processConnection.Next) " is 166.
Long Statement,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The length of the statement  "                // The format of this is consistent for all versions of the provider to prevent version 10 from sorting between version 1 and version 2. " is 136.
Long Statement,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The length of the statement  "                // Specifies the relationship between the columns in a GROUP BY clause and the non-aggregated columns in the select list. " is 121.
Long Statement,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The length of the statement  "                // A regular expression that matches an identifier and has a match value of the identifier. For example "[A-Za-z0-9_#$]". " is 121.
Long Statement,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The length of the statement  "                row["IdentifierPattern"] = "(^\\[\\p{Lo}\\p{Lu}\\p{Ll}_@#][\\p{Lo}\\p{Lu}\\p{Ll}\\p{Nd}@$#_]*$)|(^\"[^\"\\0]|\"\"+\"$)"; " is 120.
Long Statement,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The length of the statement  "                // A regular expression that matches a quoted identifier and has a match value of the identifier itself without the quotes.  " is 123.
Long Statement,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The length of the statement  "                table.Columns.Add("ProviderDbType"' typeof(int)); // The provider-specific type value that should be used when specifying  " is 121.
Long Statement,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The length of the statement  "                table.Columns.Add("NativeDataType"' typeof(string));    // NativeDataType is an OLE DB specific column for exposing the OLE DB type of the data type . " is 150.
Long Statement,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The length of the statement  "                table.ReadXml(XmlReader.Create(typeof(NuoDbConnectionInternal).Assembly.GetManifestResourceStream("NuoDb.Data.Client.DataTypes.xml"))); " is 135.
Long Statement,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The length of the statement  "                List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2)); " is 151.
Long Statement,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The length of the statement  "                List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2)); " is 151.
Long Statement,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The length of the statement  "                                System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_SCHEM"] + "." + reader["TABLE_NAME"] + "=" + reader["COLUMN_NAME"]); " is 125.
Long Statement,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The length of the statement  "                                System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_SCHEM"] + "." + reader["TABLE_NAME"] + " (Primary) =" + reader["COLUMN_NAME"]); " is 136.
Long Statement,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The length of the statement  "                List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2)); " is 151.
Long Statement,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The length of the statement  "                List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2)); " is 151.
Long Statement,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The length of the statement  "                                System.Diagnostics.Trace.WriteLine("-> " + reader["FKTABLE_SCHEM"] + "." + reader["FKTABLE_NAME"] + "=" + reader["FKCOLUMN_NAME"]); " is 131.
Long Statement,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,RetrieveMatchingTables,The length of the statement  "                            tables.Add(new KeyValuePair<string' string>(reader.GetFieldValue<string>("TABLE_SCHEM")' reader.GetFieldValue<string>("TABLE_NAME"))); " is 134.
Long Statement,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,isNumeric,The length of the statement  "            string[] numeric_types = new string[] { "integer"' "int"' "smallint"' "tinyint"' "float"' "double"' "bigint"' "numeric"' "decimal" }; " is 133.
Long Statement,NuoDb.Data.Client,NuoDbDataReader,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbDataReader.cs,GetSchemaTable,The length of the statement  "            // Info on the schema of this table is at http://msdn.microsoft.com/en-us/library/system.data.odbc.odbcdatareader.getschematable.aspx " is 133.
Long Statement,NuoDb.Data.Client,NuoDbDataReader,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbDataReader.cs,GetSchemaTable,The length of the statement  "            // The maximum possible length of a value in the column. For columns that use a fixed-length data type' this is the size of the data type.  " is 138.
Long Statement,NuoDb.Data.Client,NuoDbDataReader,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbDataReader.cs,GetSchemaTable,The length of the statement  "            // If the underlying ODBC driver returns a precision value for a non-numeric data type' this value is used in the schema table.  " is 127.
Long Statement,NuoDb.Data.Client,NuoDbDataReader,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbDataReader.cs,GetSchemaTable,The length of the statement  "            // If the underlying ODBC driver returns a precision value for a non-numeric data type' this value is used in the schema table.  " is 127.
Long Statement,NuoDb.Data.Client,NuoDbDataReader,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbDataReader.cs,GetSchemaTable,The length of the statement  "            // The name of the catalog in the data store that contains the column. NULL if the base catalog name cannot be determined. " is 122.
Long Statement,NuoDb.Data.Client,NuoDbDataReader,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbDataReader.cs,GetSchemaTable,The length of the statement  "            // The name of the schema in the data source that contains the column. NULL if the base catalog name cannot be determined.  " is 122.
Long Statement,NuoDb.Data.Client,NuoDbDataReader,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbDataReader.cs,GetSchemaTable,The length of the statement  "            // The name of the table or view in the data store that contains the column. A null value if the base table name cannot be determined. " is 134.
Long Statement,NuoDb.Data.Client,NuoDbDataReader,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbDataReader.cs,GetSchemaTable,The length of the statement  "            // The name of the column in the data store. This might be different from the column name returned in the ColumnName column if an alias was used.  " is 145.
Long Statement,NuoDb.Data.Client,NuoDbDataReader,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbDataReader.cs,GetSchemaTable,The length of the statement  "            // A null value if the base column name cannot be determined or if the rowset column is derived' but not identical to' a column in the data store.  " is 146.
Long Statement,NuoDb.Data.Client,NuoDbDataReader,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbDataReader.cs,GetSchemaTable,The length of the statement  "            // true if the column contains a Binary Long Object (BLOB) that contains very long data. The definition of very long data is driver-specific.  " is 141.
Long Statement,NuoDb.Data.Client,NuoDbDataReader,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbDataReader.cs,GetSchemaTable,The length of the statement  "            // true if the column assigns values to new rows in fixed increments; otherwise false. The default for this column is false.  " is 124.
Long Statement,NuoDb.Data.Client,NuoDbDataReader,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbDataReader.cs,GetSchemaTable,The length of the statement  "            // IsUnique is guaranteed to be true if the column represents a key by itself or if there is a constraint of type UNIQUE that applies only to this column. " is 154.
Long Statement,NuoDb.Data.Client,NuoDbDataReader,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbDataReader.cs,GetSchemaTable,The length of the statement  "            // The set of columns with IsKey set to true must uniquely identify a row in the rowset. There is no requirement that this set of columns is a minimal set of columns. This set of columns may be generated from a base table primary key' a unique constraint' or a unique index. " is 274.
Long Statement,NuoDb.Data.Client,NuoDbDataReader,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbDataReader.cs,GetSchemaTable,The length of the statement  "            // Set if the column contains a persistent row identifier that cannot be written to' and has no meaningful value except to identity the row.  " is 140.
Long Statement,NuoDb.Data.Client,NuoDbDataReader,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbDataReader.cs,GetSchemaTable,The length of the statement  "            // true if the consumer can set the column to a null value or if the driver cannot determine whether the consumer can set the column to a null value.  " is 149.
Long Statement,NuoDb.Data.Client,NuoDbDataReader,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbDataReader.cs,GetSchemaTable,The length of the statement  "                if (((DbType)row["ProviderType"] == DbType.Int16 || (DbType)row["ProviderType"] == DbType.Int32 || (DbType)row["ProviderType"] == DbType.Int64) && " is 146.
Long Statement,NuoDb.Data.Client,NuoDbDataReader,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbDataReader.cs,GetSchemaTable,The length of the statement  "                row["DataType"] = Type.GetType(NuoDbConnectionInternal.mapNuoDbToNetType((string)row["DataTypeName"]' (int)row["NumericPrecision"]' (int)row["NumericScale"])); " is 159.
Long Statement,NuoDb.Data.Client,NuoDbDataReader,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbDataReader.cs,GetSchemaTable,The length of the statement  "                    indexInfo = connection.GetSchema("IndexColumns"' new string[] { null' (string)row["BaseSchemaName"]' (string)row["BaseTableName"] }); " is 133.
Long Statement,NuoDb.Data.Client,NuoDbDataReader,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbDataReader.cs,GetSchemaTable,The length of the statement  "                DataRow[] rows = indexInfo.Select(String.Format("INDEXCOLUMN_NAME = '{0}' AND INDEXCOLUMN_ISPRIMARY = true"' row["BaseColumnName"])); " is 133.
Long Statement,NuoDb.Data.Client,NuoDbDataReader,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbDataReader.cs,findColumn,The length of the statement  "                throw new IndexOutOfRangeException(String.Format("ResultSet column index of {0}' out of bounds.  Valid range 0-{1}"' columnIndex' numberColumns-1)); " is 148.
Long Statement,NuoDb.Data.Client,NuoDbDataReader,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbDataReader.cs,getValue,The length of the statement  "                throw new IndexOutOfRangeException(String.Format("ResultSet column index of {0}' out of bounds.  Valid range 0-{1}"' columnIndex' numberColumns-1)); " is 148.
Long Statement,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,encodeDotNetObject,The length of the statement  "                System.Diagnostics.Trace.WriteLine(String.Format("Unsupported type of parameter: {0}' sending as a plain string"' value.GetType().Name)); " is 137.
Long Statement,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,decode,The length of the statement  "                    integer32 = ((sbyte)source[offset]) << 24 | (source[offset + 1] & 0xff) << 16 | (source[offset + 2] & 0xff) << 8 | (source[offset + 3] & 0xff); " is 143.
Long Statement,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,getString,The length of the statement  "                    throw new NuoDbSqlException("On message type " + currentMessageType + ":NuoDB jdbc expected string' got type: " + type); " is 120.
Long Statement,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,getBigDecimal,The length of the statement  "            throw new NuoDbSqlException("On message type " + currentMessageType + ":NuoDB jdbc expected BigDecimal got type: " + type); " is 123.
Long Statement,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,getBoolean,The length of the statement  "            throw new NuoDbSqlException("On message type " + currentMessageType + ":NuoDB jdbc expected boolean' got type: " + type); " is 121.
Long Statement,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,getValue,The length of the statement  "            throw new NuoDbSqlException("On message type " + currentMessageType + ":NuoDB jdbc decode value type " + type + " not yet implemented"); " is 136.
Long Statement,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,encodeTime,The length of the statement  "                throw new NuoDbSqlException(String.Format("Unable to encode \"{0}\".  Need {1} bytes to encode but only have {2} bytes."' time' count' edsTimeLen4 - edsTimeLen0)); " is 163.
Long Statement,NuoDb.Data.Client.EntityFramework,NuoDbProviderManifest,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EntityFramework\NuoDbProviderManifest.cs,GetStoreType,The length of the statement  "                        return TypeUsage.CreateDefaultTypeUsage(useTimestamp ? StoreTypeNameToStorePrimitiveType["datetime"] : StoreTypeNameToStorePrimitiveType["date"]); " is 146.
Long Statement,NuoDb.Data.Client.EntityFramework,NuoDbProviderManifest,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EntityFramework\NuoDbProviderManifest.cs,GetStoreType,The length of the statement  "                    throw new NotSupportedException(string.Format("There is no store type corresponding to the EDM type '{0}' of primitive type '{1}'."' edmType' primitiveType.PrimitiveTypeKind)); " is 176.
Long Statement,NuoDb.Data.Client.EntityFramework,NuoDbProviderServices,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EntityFramework\NuoDbProviderServices.cs,CreateDbCommandDefinition,The length of the statement  "                    parameter = CreateSqlParameter(functionParameter.Name' functionParameter.TypeUsage' functionParameter.Mode' DBNull.Value); " is 122.
Long Statement,NuoDb.Data.Client.EntityFramework.SqlGen,DmlSqlGenerator,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EntityFramework\SqlGen\DmlSqlGenerator.cs,GenerateUpdateSql,The length of the statement  "            ExpressionTranslator translator = new ExpressionTranslator(commandText' tree' null != tree.Returning' generateParameters); " is 122.
Long Statement,NuoDb.Data.Client.EntityFramework.SqlGen,DmlSqlGenerator,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EntityFramework\SqlGen\DmlSqlGenerator.cs,GenerateInsertSql,The length of the statement  "            ExpressionTranslator translator = new ExpressionTranslator(commandText' tree' null != tree.Returning' generateParameters); " is 122.
Long Statement,NuoDb.Data.Client.EntityFramework.SqlGen,MetadataHelpers,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EntityFramework\SqlGen\MetadataHelpers.cs,IsStoreGeneratedPattern,The length of the statement  "            return (member.TypeUsage.Facets.TryGetValue(StoreGeneratedPatternFacetName' false' out item) && ((StoreGeneratedPattern)item.Value) == pattern); " is 144.
Long Statement,NuoDb.Data.Client.EntityFramework.SqlGen,ScriptBuilder,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EntityFramework\SqlGen\ScriptBuilder.cs,GenerateTables,The length of the statement  "                result.AppendFormat("CREATE TABLE {0}.{1} ("' SqlGenerator.QuoteIdentifier(schemaName)' SqlGenerator.QuoteIdentifier(tableName)); " is 129.
Long Statement,NuoDb.Data.Client.EntityFramework.SqlGen,ScriptBuilder,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EntityFramework\SqlGen\ScriptBuilder.cs,GenerateTables,The length of the statement  "                result.Append(string.Join("'" + Environment.NewLine + "\t"' MetadataHelpers.GetProperties(entitySet.ElementType).Select(p => GenerateColumn(p)))); " is 146.
Long Statement,NuoDb.Data.Client.EntityFramework.SqlGen,SqlGenerator,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EntityFramework\SqlGen\SqlGenerator.cs,InitializeBuiltInFunctionHandlers,The length of the statement  "            Dictionary<string' FunctionHandler> functionHandlers = new Dictionary<string' FunctionHandler>(0' StringComparer.Ordinal); " is 122.
Long Statement,NuoDb.Data.Client.EntityFramework.SqlGen,SqlGenerator,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EntityFramework\SqlGen\SqlGenerator.cs,Visit,The length of the statement  "                        if (MetadataHelpers.TryGetTypeFacetDescriptionByName(e.ResultType.EdmType' MetadataHelpers.PrecisionFacetName' out precisionFacetDescription)) " is 142.
Long Statement,NuoDb.Data.Client.EntityFramework.SqlGen,SqlGenerator,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EntityFramework\SqlGen\SqlGenerator.cs,Visit,The length of the statement  "            RowType groupByType = MetadataHelpers.GetEdmType<RowType>(MetadataHelpers.GetEdmType<CollectionType>(e.ResultType).TypeUsage); " is 126.
Long Statement,NuoDb.Data.Client.EntityFramework.SqlGen,SqlGenerator,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EntityFramework\SqlGen\SqlGenerator.cs,Visit,The length of the statement  "            Debug.Assert(e.Limit is DbConstantExpression || e.Limit is DbParameterReferenceExpression' "DbLimitExpression.Limit is of invalid expression type"); " is 148.
Long Statement,NuoDb.Data.Client.EntityFramework.SqlGen,SqlGenerator,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EntityFramework\SqlGen\SqlGenerator.cs,Visit,The length of the statement  "            SqlSelectStatement result = VisitInputExpression(e.Input.Expression' e.Input.VariableName' e.Input.VariableType' out fromSymbol); " is 129.
Long Statement,NuoDb.Data.Client.EntityFramework.SqlGen,SqlGenerator,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EntityFramework\SqlGen\SqlGenerator.cs,Visit,The length of the statement  "            Debug.Assert(e.Count is DbConstantExpression || e.Count is DbParameterReferenceExpression' "DbSkipExpression.Count is of invalid expression type"); " is 147.
Long Statement,NuoDb.Data.Client.EntityFramework.SqlGen,SqlGenerator,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EntityFramework\SqlGen\SqlGenerator.cs,Visit,The length of the statement  "            SqlSelectStatement result = VisitInputExpression(e.Input.Expression' e.Input.VariableName' e.Input.VariableType' out fromSymbol); " is 129.
Long Statement,NuoDb.Data.Client.EntityFramework.SqlGen,SqlGenerator,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EntityFramework\SqlGen\SqlGenerator.cs,Visit,The length of the statement  "            SqlSelectStatement result = VisitInputExpression(e.Input.Expression' e.Input.VariableName' e.Input.VariableType' out fromSymbol); " is 129.
Long Statement,NuoDb.Data.Client.EntityFramework.SqlGen,SqlGenerator,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EntityFramework\SqlGen\SqlGenerator.cs,VisitJoinExpression,The length of the statement  "                    DbExpression[] children = new DbExpression[] { (processing as DbUnionAllExpression).Left' (processing as DbUnionAllExpression).Right }; " is 135.
Long Statement,NuoDb.Data.Client.EntityFramework.SqlGen,SqlGenerator,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EntityFramework\SqlGen\SqlGenerator.cs,VisitJoinExpression,The length of the statement  "                ProcessJoinInputResult(fromExtentFragment' result' processing' input.VariableName' input.VariableType' fromSymbolStart); " is 120.
Long Statement,NuoDb.Data.Client.EntityFramework.SqlGen,SqlGenerator,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EntityFramework\SqlGen\SqlGenerator.cs,ExtractConstraints,The length of the statement  "                        result.Add(((joinCondition as DbComparisonExpression).Right as DbPropertyExpression).Property.Name' (joinCondition as DbComparisonExpression).Left as DbConstantExpression); " is 172.
Long Statement,NuoDb.Data.Client.EntityFramework.SqlGen,SqlGenerator,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EntityFramework\SqlGen\SqlGenerator.cs,ExtractConstraints,The length of the statement  "                        result.Add(((joinCondition as DbComparisonExpression).Left as DbPropertyExpression).Property.Name' (joinCondition as DbComparisonExpression).Right as DbConstantExpression); " is 172.
Long Statement,NuoDb.Data.Client.EntityFramework.SqlGen,SqlGenerator,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EntityFramework\SqlGen\SqlGenerator.cs,HandleSpecialFunction,The length of the statement  "                throw new InvalidOperationException("Special handling should be called only for functions in the list of special functions"); " is 125.
Long Statement,NuoDb.Data.Client.EntityFramework.SqlGen,SqlGenerator,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EntityFramework\SqlGen\SqlGenerator.cs,HandleSpecialFunctionToOperator,The length of the statement  "            Debug.Assert(_functionNameToOperatorDictionary.ContainsKey(e.Function.Name)' "The function can not be mapped to an operator"); " is 126.
Long Statement,NuoDb.Data.Client.EntityFramework.SqlGen,SqlGenerator,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EntityFramework\SqlGen\SqlGenerator.cs,WriteFunctionName,The length of the statement  "            string storeFunctionName = MetadataHelpers.TryGetValueForMetadataProperty<string>(function' "StoreFunctionNameAttribute"); " is 122.
Long Statement,NuoDb.Data.Client.Security,BigInteger,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,modPow,The length of the statement  "                        // NuoDB CHANGED!!! The original code was returning -resultNum' but the Java BigInteger adds the negative remainder to the modulus instead " is 138.
Long Statement,NuoDb.Data.Client.Security,BigInteger,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,modPow,The length of the statement  "            // NuoDB CHANGED!!! The original code was returning -resultNum' but the Java BigInteger adds the negative remainder to the modulus instead " is 138.
Long Statement,NuoDb.Data.Client.Security,RemoteGroup,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\RemoteGroup.cs,getGroup,The length of the statement  "				string prime = "EEAF0AB9ADB38DD69C33F80AFA8FC5E86072618775FF3C0B9EA2314C" + "9C256576D674DF7496EA81D3383B4813D692C6E0E0D5D8E250B98BE4" + "8E495C1D6089DAD15DC7D7B46154D6B6CE8EF4AD69B15D4982559B29" + "7BCF1885C529F566660E57EC68EDBC3C05726CC02FD4CBF4976EAA9A" + "FD5138FE8376435B9FC61D2FC0EB06E3"; " is 294.
Long Statement,NuoDb.Data.Client.Util,StringUtils,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\StringUtils.cs,overwrite,The length of the statement  "				throw new System.IndexOutOfRangeException(String.Format("position {0} exceeds the length of the string {1}"' pos' origString.Length)); " is 134.
Complex Conditional,NuoDb.Data.Client,NuoDbCommand,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbCommand.cs,Close,The conditional expression  "handle == -1 || connection == null || (connection as IDbConnection).State == ConnectionState.Closed ||                  !connection.InternalConnection.IsCommandRegistered(handle)"  is complex.
Complex Conditional,NuoDb.Data.Client,NuoDbCommand,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbCommand.cs,ExecuteDbDataReader,The conditional expression  "CommandType == CommandType.Text &&                  !trimmedSql.StartsWith("SELECT "' StringComparison.InvariantCultureIgnoreCase) &&                  !trimmedSql.StartsWith("CALL "' StringComparison.InvariantCultureIgnoreCase) &&                  !trimmedSql.StartsWith("EXECUTE "' StringComparison.InvariantCultureIgnoreCase)"  is complex.
Complex Conditional,NuoDb.Data.Client,NuoDbCommand,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbCommand.cs,Prepare,The conditional expression  "(c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || c == '_' ||                          (curParamName.Length > 0 && ((c >= '0' && c <= '9') || c == '-'))"  is complex.
Complex Conditional,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The conditional expression  "restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>("INDEX_NAME"))"  is complex.
Complex Conditional,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The conditional expression  "restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>(indexName))"  is complex.
Complex Conditional,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The conditional expression  "restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>("INDEX_NAME"))"  is complex.
Complex Conditional,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The conditional expression  "restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>(indexName))"  is complex.
Complex Conditional,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The conditional expression  "restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(name)"  is complex.
Complex Conditional,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The conditional expression  "restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(name)"  is complex.
Complex Conditional,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapNuoDbToNetType,The conditional expression  "p == "string" || p == "char" || p == "varchar" || p == "longvarchar""  is complex.
Complex Conditional,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapNuoDbToNetType,The conditional expression  "p == "tinyint" || p == "smallint" || p == "integer" || p == "numeric" || p == "decimal""  is complex.
Complex Conditional,NuoDb.Data.Client,NuoDbDataReader,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbDataReader.cs,closeCurrentResultSet,The conditional expression  "closed || handle == -1 || connection == null || (connection as IDbConnection).State == ConnectionState.Closed ||                  !connection.InternalConnection.IsResultSetRegistered(handle)"  is complex.
Complex Conditional,NuoDb.Data.Client,NuoDbDataReader,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbDataReader.cs,GetSchemaTable,The conditional expression  "((DbType)row["ProviderType"] == DbType.Int16 || (DbType)row["ProviderType"] == DbType.Int32 || (DbType)row["ProviderType"] == DbType.Int64) &&                      (int)row["NumericScale"] != 0"  is complex.
Complex Conditional,NuoDb.Data.Client.EntityFramework,NuoDbProviderManifest,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EntityFramework\NuoDbProviderManifest.cs,GetEdmType,The conditional expression  "fPrecision != null && !fPrecision.IsUnbounded && fPrecision.Value != null &&                       fScale != null && !fScale.IsUnbounded && fScale.Value != null"  is complex.
Complex Conditional,NuoDb.Data.Client.EntityFramework.SqlGen,SqlGenerator,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EntityFramework\SqlGen\SqlGenerator.cs,VisitAggregate,The conditional expression  "MetadataHelpers.IsCanonicalFunction(functionAggregate.Function) && (                  string.Equals(functionAggregate.Function.Name' "StDev"' StringComparison.Ordinal) ||                  string.Equals(functionAggregate.Function.Name' "StDevP"' StringComparison.Ordinal) ||                  string.Equals(functionAggregate.Function.Name' "Var"' StringComparison.Ordinal) ||                  string.Equals(functionAggregate.Function.Name' "VarP"' StringComparison.Ordinal))"  is complex.
Complex Conditional,NuoDb.Data.Client.EntityFramework.SqlGen,SqlSelectStatement,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EntityFramework\SqlGen\SqlSelectStatement.cs,WriteSql,The conditional expression  "(this.orderBy != null) && !this.OrderBy.IsEmpty && (this.IsTopMost || this.First != null || this.Skip != null)"  is complex.
Complex Conditional,NuoDb.Data.Client.Util,StringUtils,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\StringUtils.cs,Equals,The conditional expression  "(one == null && two != null) || (one != null && two == null)"  is complex.
Complex Conditional,NuoDb.Data.Client.Xml,Doc,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Xml\Doc.cs,skipWhite,The conditional expression  "c != ' ' && c != '\t' && c != '\n' && c != '\r'"  is complex.
Virtual Method Call from Constructor,NuoDb.Data.Client,DataSegment,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\DataStream.cs,DataSegment,The constructor "DataSegment" calls a virtual method "allocate".
Virtual Method Call from Constructor,NuoDb.Data.Client.Xml,Attribute,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Xml\Attribute.cs,Attribute,The constructor "Attribute" calls a virtual method "parse".
Virtual Method Call from Constructor,NuoDb.Data.Client.Xml,Tag,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Xml\Tag.cs,Tag,The constructor "Tag" calls a virtual method "parseAttributes".
Virtual Method Call from Constructor,NuoDb.Data.Client.Xml,Tag,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Xml\Tag.cs,Tag,The constructor "Tag" calls a virtual method "parseChildren".
Virtual Method Call from Constructor,NuoDb.Data.Client.Xml,Tag,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Xml\Tag.cs,Tag,The constructor "Tag" calls a virtual method "parseText".
Empty Catch Block,NuoDb.Data.Client,NuoDbCommand,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbCommand.cs,Dispose,The method has an empty catch block.
Empty Catch Block,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,Dispose,The method has an empty catch block.
Empty Catch Block,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,doOpen,The method has an empty catch block.
Empty Catch Block,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,doOpen,The method has an empty catch block.
Empty Catch Block,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The method has an empty catch block.
Empty Catch Block,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The method has an empty catch block.
Empty Catch Block,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The method has an empty catch block.
Empty Catch Block,NuoDb.Data.Client,NuoDbDataReader,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbDataReader.cs,GetValue,The method has an empty catch block.
Empty Catch Block,NuoDb.Data.Client.Security,BigInteger,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,ToString,The method has an empty catch block.
Magic Number,NuoDb.Data.Client,NuoDbBulkLoader,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbBulkLoader.cs,WriteToServer,The following statement contains a magic number: if (mappings.Count == 0)              {                  // the target table has the same number and names of the columns as in the specified input rows                  builder.Append("VALUES (");                  for (int i = 0; i < feeder.FieldCount; i++)                  {                      if (i != 0)                          builder.Append("' ");                      builder.Append("?");                  }                  builder.Append(")");              }              else              {                  DataRowCollection targetColumns = null;                  builder.Append(" (");                  for (int i = 0; i < mappings.Count; i++)                  {                      NuoDbBulkLoaderColumnMapping mapping = mappings[i];                      if (i != 0)                          builder.Append("' ");                      builder.Append("`");                      if (mapping.DestinationColumn == null)                      {                          // we are requested to map to a target column that is identified with its ordinal number' so                           // fetch the schema of the target table to find out what is its name                          if (targetColumns == null)                          {                              // split the destination table into its different parts                              string[] parts = this.tableName.Split(new char[] { '.' });                                DataTable targetSchema = this.connection.GetSchema("Columns"' new string[] { null' // catalog                                                                                      parts.Length == 2 ? parts[0] : null' // schema                                                                                      parts.Length == 2 ? parts[1] : parts[0] // table                                                                                  });                              targetColumns = targetSchema.Rows;                          }                            if (mapping.DestinationOrdinal < 0 || mapping.DestinationOrdinal > targetColumns.Count)                              throw new IndexOutOfRangeException(String.Format("The specified ordinal of the target column ({0}) is outside the range of the column count ({1}) of table {2}"'                                  new object[] { mapping.DestinationOrdinal' targetColumns.Count' this.tableName }));                            string columnName = (string)(targetColumns[mapping.DestinationOrdinal]["COLUMN_NAME"]);                          builder.Append(columnName.Replace("`"' "``"));                      }                      else                          builder.Append(mapping.DestinationColumn.Replace("`"' "``"));                      builder.Append("`");                  }                  builder.Append(") VALUES (");                  for (int i = 0; i < mappings.Count; i++)                  {                      if (i != 0)                          builder.Append("' ");                      builder.Append("?");                  }                  builder.Append(")");              }
Magic Number,NuoDb.Data.Client,NuoDbBulkLoader,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbBulkLoader.cs,WriteToServer,The following statement contains a magic number: if (mappings.Count == 0)              {                  // the target table has the same number and names of the columns as in the specified input rows                  builder.Append("VALUES (");                  for (int i = 0; i < feeder.FieldCount; i++)                  {                      if (i != 0)                          builder.Append("' ");                      builder.Append("?");                  }                  builder.Append(")");              }              else              {                  DataRowCollection targetColumns = null;                  builder.Append(" (");                  for (int i = 0; i < mappings.Count; i++)                  {                      NuoDbBulkLoaderColumnMapping mapping = mappings[i];                      if (i != 0)                          builder.Append("' ");                      builder.Append("`");                      if (mapping.DestinationColumn == null)                      {                          // we are requested to map to a target column that is identified with its ordinal number' so                           // fetch the schema of the target table to find out what is its name                          if (targetColumns == null)                          {                              // split the destination table into its different parts                              string[] parts = this.tableName.Split(new char[] { '.' });                                DataTable targetSchema = this.connection.GetSchema("Columns"' new string[] { null' // catalog                                                                                      parts.Length == 2 ? parts[0] : null' // schema                                                                                      parts.Length == 2 ? parts[1] : parts[0] // table                                                                                  });                              targetColumns = targetSchema.Rows;                          }                            if (mapping.DestinationOrdinal < 0 || mapping.DestinationOrdinal > targetColumns.Count)                              throw new IndexOutOfRangeException(String.Format("The specified ordinal of the target column ({0}) is outside the range of the column count ({1}) of table {2}"'                                  new object[] { mapping.DestinationOrdinal' targetColumns.Count' this.tableName }));                            string columnName = (string)(targetColumns[mapping.DestinationOrdinal]["COLUMN_NAME"]);                          builder.Append(columnName.Replace("`"' "``"));                      }                      else                          builder.Append(mapping.DestinationColumn.Replace("`"' "``"));                      builder.Append("`");                  }                  builder.Append(") VALUES (");                  for (int i = 0; i < mappings.Count; i++)                  {                      if (i != 0)                          builder.Append("' ");                      builder.Append("?");                  }                  builder.Append(")");              }
Magic Number,NuoDb.Data.Client,OlsonDatabase,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\SQLContext.cs,FindOlsonTimeZone,The following statement contains a magic number: if (parts.Length >= 2)              {                  TimezoneKey = WindowsTimeZone + "|" + parts[1];                  if (db.TryGetValue(TimezoneKey' out OlsonZone))                      return OlsonZone;              }
Magic Number,NuoDb.Data.Client,NuoDbCommand,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbCommand.cs,Prepare,The following statement contains a magic number: foreach (char c in CommandText)              {                  if (c == '\'' && !(inDoubleQuotes || inSmartQuotes))                  {                      inSingleQuotes = !inSingleQuotes;                      state = 0;                      sqlString.Append(c);                      continue;                  }                  else if (c == '\"' && !(inSingleQuotes || inSmartQuotes))                  {                      inDoubleQuotes = !inDoubleQuotes;                      state = 0;                      sqlString.Append(c);                      continue;                  }                  else if (c == '`' && !(inSingleQuotes || inDoubleQuotes))                  {                      inSmartQuotes = !inSmartQuotes;                      state = 0;                      sqlString.Append(c);                      continue;                  }                  if (inSingleQuotes || inDoubleQuotes || inSmartQuotes)                  {                      sqlString.Append(c);                      continue;                  }                    if (c == '?')                      state = 1;                  else if (c == '@')                      state = 2;                  else if (state == 1)                  {                      if (c == '.')                          state = 2;                      else                      {                          // either add a new parameter' or carry over the user-provided one                          if (parameters.Count > newParams.Count)                              newParams.Add(parameters[newParams.Count]);                          else                              newParams.Add(new NuoDbParameter());                          state = 0;                          sqlString.Append("?");                          sqlString.Append(c);                      }                  }                  else if (state == 2)                  {                      if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || c == '_' ||                          (curParamName.Length > 0 && ((c >= '0' && c <= '9') || c == '-')))                      {                          curParamName += c;                      }                      else                      {                          // if the user-provided parameters have a value for this name' preserve it                          if (parameters.Contains(curParamName))                              newParams.Add(parameters[curParamName]);                          else if (parameters.Contains("@" + curParamName))                              newParams.Add(parameters["@" + curParamName]);                          else                          {                              NuoDbParameter p = new NuoDbParameter();                              p.ParameterName = curParamName;                              newParams.Add(p);                          }                          sqlString.Append("?.");                          sqlString.Append(curParamName);                          sqlString.Append(c);                            curParamName = "";                          state = 0;                      }                  }                  else                  {                      state = 0;                      sqlString.Append(c);                  }              }
Magic Number,NuoDb.Data.Client,NuoDbCommand,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbCommand.cs,Prepare,The following statement contains a magic number: foreach (char c in CommandText)              {                  if (c == '\'' && !(inDoubleQuotes || inSmartQuotes))                  {                      inSingleQuotes = !inSingleQuotes;                      state = 0;                      sqlString.Append(c);                      continue;                  }                  else if (c == '\"' && !(inSingleQuotes || inSmartQuotes))                  {                      inDoubleQuotes = !inDoubleQuotes;                      state = 0;                      sqlString.Append(c);                      continue;                  }                  else if (c == '`' && !(inSingleQuotes || inDoubleQuotes))                  {                      inSmartQuotes = !inSmartQuotes;                      state = 0;                      sqlString.Append(c);                      continue;                  }                  if (inSingleQuotes || inDoubleQuotes || inSmartQuotes)                  {                      sqlString.Append(c);                      continue;                  }                    if (c == '?')                      state = 1;                  else if (c == '@')                      state = 2;                  else if (state == 1)                  {                      if (c == '.')                          state = 2;                      else                      {                          // either add a new parameter' or carry over the user-provided one                          if (parameters.Count > newParams.Count)                              newParams.Add(parameters[newParams.Count]);                          else                              newParams.Add(new NuoDbParameter());                          state = 0;                          sqlString.Append("?");                          sqlString.Append(c);                      }                  }                  else if (state == 2)                  {                      if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || c == '_' ||                          (curParamName.Length > 0 && ((c >= '0' && c <= '9') || c == '-')))                      {                          curParamName += c;                      }                      else                      {                          // if the user-provided parameters have a value for this name' preserve it                          if (parameters.Contains(curParamName))                              newParams.Add(parameters[curParamName]);                          else if (parameters.Contains("@" + curParamName))                              newParams.Add(parameters["@" + curParamName]);                          else                          {                              NuoDbParameter p = new NuoDbParameter();                              p.ParameterName = curParamName;                              newParams.Add(p);                          }                          sqlString.Append("?.");                          sqlString.Append(curParamName);                          sqlString.Append(c);                            curParamName = "";                          state = 0;                      }                  }                  else                  {                      state = 0;                      sqlString.Append(c);                  }              }
Magic Number,NuoDb.Data.Client,NuoDbCommand,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbCommand.cs,Prepare,The following statement contains a magic number: foreach (char c in CommandText)              {                  if (c == '\'' && !(inDoubleQuotes || inSmartQuotes))                  {                      inSingleQuotes = !inSingleQuotes;                      state = 0;                      sqlString.Append(c);                      continue;                  }                  else if (c == '\"' && !(inSingleQuotes || inSmartQuotes))                  {                      inDoubleQuotes = !inDoubleQuotes;                      state = 0;                      sqlString.Append(c);                      continue;                  }                  else if (c == '`' && !(inSingleQuotes || inDoubleQuotes))                  {                      inSmartQuotes = !inSmartQuotes;                      state = 0;                      sqlString.Append(c);                      continue;                  }                  if (inSingleQuotes || inDoubleQuotes || inSmartQuotes)                  {                      sqlString.Append(c);                      continue;                  }                    if (c == '?')                      state = 1;                  else if (c == '@')                      state = 2;                  else if (state == 1)                  {                      if (c == '.')                          state = 2;                      else                      {                          // either add a new parameter' or carry over the user-provided one                          if (parameters.Count > newParams.Count)                              newParams.Add(parameters[newParams.Count]);                          else                              newParams.Add(new NuoDbParameter());                          state = 0;                          sqlString.Append("?");                          sqlString.Append(c);                      }                  }                  else if (state == 2)                  {                      if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || c == '_' ||                          (curParamName.Length > 0 && ((c >= '0' && c <= '9') || c == '-')))                      {                          curParamName += c;                      }                      else                      {                          // if the user-provided parameters have a value for this name' preserve it                          if (parameters.Contains(curParamName))                              newParams.Add(parameters[curParamName]);                          else if (parameters.Contains("@" + curParamName))                              newParams.Add(parameters["@" + curParamName]);                          else                          {                              NuoDbParameter p = new NuoDbParameter();                              p.ParameterName = curParamName;                              newParams.Add(p);                          }                          sqlString.Append("?.");                          sqlString.Append(curParamName);                          sqlString.Append(c);                            curParamName = "";                          state = 0;                      }                  }                  else                  {                      state = 0;                      sqlString.Append(c);                  }              }
Magic Number,NuoDb.Data.Client,NuoDbCommand,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbCommand.cs,Prepare,The following statement contains a magic number: if (state == 1)              {                  // either add a new parameter' or carry over the user-provided one                  if (parameters.Count > newParams.Count)                      newParams.Add(parameters[newParams.Count]);                  else                      newParams.Add(new NuoDbParameter());                  sqlString.Append("?");              }              else if (state == 2)              {                  // if the user-provided parameters have a value for this name' preserve it                  if (parameters.Contains(curParamName))                      newParams.Add(parameters[curParamName]);                  else if (parameters.Contains("@" + curParamName))                      newParams.Add(parameters["@" + curParamName]);                  else                  {                      NuoDbParameter p = new NuoDbParameter();                      p.ParameterName = curParamName;                      newParams.Add(p);                  }                  sqlString.Append("?.");                  sqlString.Append(curParamName);              }
Magic Number,NuoDb.Data.Client,NuoDbCommand,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbCommand.cs,Prepare,The following statement contains a magic number: if (CommandType == CommandType.StoredProcedure &&                  !nuodbSqlString.StartsWith("EXECUTE "' StringComparison.InvariantCultureIgnoreCase) &&                  !nuodbSqlString.StartsWith("CALL "' StringComparison.InvariantCultureIgnoreCase))              {                  char[] quotes = new char[] { '"' };                  string[] parts = nuodbSqlString.Split(new char[] { '.' });                  DataTable paramTable = null;                  if (parts.Length == 2)                      paramTable = NuoDbConnectionInternal.GetSchemaHelper(connection' "ProcedureParameters"' new string[] { null' parts[0].Trim(quotes)' parts[1].Trim(quotes)' null });                  else                  {                      NuoDbConnectionStringBuilder builder = new NuoDbConnectionStringBuilder(connection.ConnectionString);                      string schema = builder.Schema;                      if (schema.Length == 0)                          schema = "USER";                      paramTable = NuoDbConnectionInternal.GetSchemaHelper(connection' "ProcedureParameters"' new string[] { null' schema' parts[0].Trim(quotes)' null });                  }                  int numParams = 0;                  foreach (DataRow row in paramTable.Select("PARAMETER_DIRECTION <> 3"' "ORDINAL_POSITION ASC"))                  {                      int ordinal = row.Field<int>("ORDINAL_POSITION");                      if (ordinal != ++numParams)                          throw new NuoDbSqlException(String.Format("Internal error: unexpected ordering of the parameters of the procedure {0}"' nuodbSqlString));                      int direction = row.Field<int>("PARAMETER_DIRECTION");                      ParameterDirection paramDirection;                      switch (direction)                      {                          case 1: paramDirection = ParameterDirection.Input; break;                          case 2: paramDirection = ParameterDirection.InputOutput; break;                          case 4: paramDirection = ParameterDirection.Output; break;                          default: throw new NuoDbSqlException(String.Format("Internal error: unexpected parameter type for procedure {0}"' nuodbSqlString));                      }                      // either add a new parameter' or carry over the user-provided one                      string paramName = row.Field<string>("PARAMETER_NAME");                      if (parameters.Contains(paramName))                          newParams.Add(parameters[paramName]);                      else if (parameters.Contains("@" + paramName))                          newParams.Add(parameters["@" + paramName]);                      else if (parameters.Count > newParams.Count)                      {                          if (parameters[newParams.Count].ParameterName.Length == 0)                              parameters[newParams.Count].ParameterName = paramName;                          newParams.Add(parameters[newParams.Count]);                      }                      else                      {                          NuoDbParameter p = new NuoDbParameter();                          p.ParameterName = paramName;                          newParams.Add(p);                      }                      newParams[newParams.Count - 1].DbType = NuoDbConnectionInternal.mapJavaSqlToDbType(row.Field<int>("PARAMETER_DATA_TYPE"));                      newParams[newParams.Count - 1].Direction = paramDirection;                  }                  StringBuilder strBuilder = new StringBuilder("EXECUTE ");                  strBuilder.Append(nuodbSqlString);                  strBuilder.Append("(");                  for (int i = 0; i < numParams; i++)                  {                      if (i != 0)                          strBuilder.Append("'");                      strBuilder.Append("?");                  }                  strBuilder.Append(")");                  nuodbSqlString = strBuilder.ToString();              }
Magic Number,NuoDb.Data.Client,NuoDbCommand,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbCommand.cs,Prepare,The following statement contains a magic number: if (CommandType == CommandType.StoredProcedure &&                  !nuodbSqlString.StartsWith("EXECUTE "' StringComparison.InvariantCultureIgnoreCase) &&                  !nuodbSqlString.StartsWith("CALL "' StringComparison.InvariantCultureIgnoreCase))              {                  char[] quotes = new char[] { '"' };                  string[] parts = nuodbSqlString.Split(new char[] { '.' });                  DataTable paramTable = null;                  if (parts.Length == 2)                      paramTable = NuoDbConnectionInternal.GetSchemaHelper(connection' "ProcedureParameters"' new string[] { null' parts[0].Trim(quotes)' parts[1].Trim(quotes)' null });                  else                  {                      NuoDbConnectionStringBuilder builder = new NuoDbConnectionStringBuilder(connection.ConnectionString);                      string schema = builder.Schema;                      if (schema.Length == 0)                          schema = "USER";                      paramTable = NuoDbConnectionInternal.GetSchemaHelper(connection' "ProcedureParameters"' new string[] { null' schema' parts[0].Trim(quotes)' null });                  }                  int numParams = 0;                  foreach (DataRow row in paramTable.Select("PARAMETER_DIRECTION <> 3"' "ORDINAL_POSITION ASC"))                  {                      int ordinal = row.Field<int>("ORDINAL_POSITION");                      if (ordinal != ++numParams)                          throw new NuoDbSqlException(String.Format("Internal error: unexpected ordering of the parameters of the procedure {0}"' nuodbSqlString));                      int direction = row.Field<int>("PARAMETER_DIRECTION");                      ParameterDirection paramDirection;                      switch (direction)                      {                          case 1: paramDirection = ParameterDirection.Input; break;                          case 2: paramDirection = ParameterDirection.InputOutput; break;                          case 4: paramDirection = ParameterDirection.Output; break;                          default: throw new NuoDbSqlException(String.Format("Internal error: unexpected parameter type for procedure {0}"' nuodbSqlString));                      }                      // either add a new parameter' or carry over the user-provided one                      string paramName = row.Field<string>("PARAMETER_NAME");                      if (parameters.Contains(paramName))                          newParams.Add(parameters[paramName]);                      else if (parameters.Contains("@" + paramName))                          newParams.Add(parameters["@" + paramName]);                      else if (parameters.Count > newParams.Count)                      {                          if (parameters[newParams.Count].ParameterName.Length == 0)                              parameters[newParams.Count].ParameterName = paramName;                          newParams.Add(parameters[newParams.Count]);                      }                      else                      {                          NuoDbParameter p = new NuoDbParameter();                          p.ParameterName = paramName;                          newParams.Add(p);                      }                      newParams[newParams.Count - 1].DbType = NuoDbConnectionInternal.mapJavaSqlToDbType(row.Field<int>("PARAMETER_DATA_TYPE"));                      newParams[newParams.Count - 1].Direction = paramDirection;                  }                  StringBuilder strBuilder = new StringBuilder("EXECUTE ");                  strBuilder.Append(nuodbSqlString);                  strBuilder.Append("(");                  for (int i = 0; i < numParams; i++)                  {                      if (i != 0)                          strBuilder.Append("'");                      strBuilder.Append("?");                  }                  strBuilder.Append(")");                  nuodbSqlString = strBuilder.ToString();              }
Magic Number,NuoDb.Data.Client,NuoDbCommand,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbCommand.cs,Prepare,The following statement contains a magic number: if (CommandType == CommandType.StoredProcedure &&                  !nuodbSqlString.StartsWith("EXECUTE "' StringComparison.InvariantCultureIgnoreCase) &&                  !nuodbSqlString.StartsWith("CALL "' StringComparison.InvariantCultureIgnoreCase))              {                  char[] quotes = new char[] { '"' };                  string[] parts = nuodbSqlString.Split(new char[] { '.' });                  DataTable paramTable = null;                  if (parts.Length == 2)                      paramTable = NuoDbConnectionInternal.GetSchemaHelper(connection' "ProcedureParameters"' new string[] { null' parts[0].Trim(quotes)' parts[1].Trim(quotes)' null });                  else                  {                      NuoDbConnectionStringBuilder builder = new NuoDbConnectionStringBuilder(connection.ConnectionString);                      string schema = builder.Schema;                      if (schema.Length == 0)                          schema = "USER";                      paramTable = NuoDbConnectionInternal.GetSchemaHelper(connection' "ProcedureParameters"' new string[] { null' schema' parts[0].Trim(quotes)' null });                  }                  int numParams = 0;                  foreach (DataRow row in paramTable.Select("PARAMETER_DIRECTION <> 3"' "ORDINAL_POSITION ASC"))                  {                      int ordinal = row.Field<int>("ORDINAL_POSITION");                      if (ordinal != ++numParams)                          throw new NuoDbSqlException(String.Format("Internal error: unexpected ordering of the parameters of the procedure {0}"' nuodbSqlString));                      int direction = row.Field<int>("PARAMETER_DIRECTION");                      ParameterDirection paramDirection;                      switch (direction)                      {                          case 1: paramDirection = ParameterDirection.Input; break;                          case 2: paramDirection = ParameterDirection.InputOutput; break;                          case 4: paramDirection = ParameterDirection.Output; break;                          default: throw new NuoDbSqlException(String.Format("Internal error: unexpected parameter type for procedure {0}"' nuodbSqlString));                      }                      // either add a new parameter' or carry over the user-provided one                      string paramName = row.Field<string>("PARAMETER_NAME");                      if (parameters.Contains(paramName))                          newParams.Add(parameters[paramName]);                      else if (parameters.Contains("@" + paramName))                          newParams.Add(parameters["@" + paramName]);                      else if (parameters.Count > newParams.Count)                      {                          if (parameters[newParams.Count].ParameterName.Length == 0)                              parameters[newParams.Count].ParameterName = paramName;                          newParams.Add(parameters[newParams.Count]);                      }                      else                      {                          NuoDbParameter p = new NuoDbParameter();                          p.ParameterName = paramName;                          newParams.Add(p);                      }                      newParams[newParams.Count - 1].DbType = NuoDbConnectionInternal.mapJavaSqlToDbType(row.Field<int>("PARAMETER_DATA_TYPE"));                      newParams[newParams.Count - 1].Direction = paramDirection;                  }                  StringBuilder strBuilder = new StringBuilder("EXECUTE ");                  strBuilder.Append(nuodbSqlString);                  strBuilder.Append("(");                  for (int i = 0; i < numParams; i++)                  {                      if (i != 0)                          strBuilder.Append("'");                      strBuilder.Append("?");                  }                  strBuilder.Append(")");                  nuodbSqlString = strBuilder.ToString();              }
Magic Number,NuoDb.Data.Client,NuoDbCommand,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbCommand.cs,Prepare,The following statement contains a magic number: if (nuodbSqlString.StartsWith("EXECUTE "' StringComparison.InvariantCultureIgnoreCase) ||                  nuodbSqlString.StartsWith("CALL "' StringComparison.InvariantCultureIgnoreCase))              {                  if (connection.InternalConnection.protocolVersion < Protocol.PROTOCOL_VERSION12)                      throw new NuoDbSqlException(String.Format("server protocol {0} doesn't support prepareCall"' connection.InternalConnection.protocolVersion));                  EncodedDataStream dataStream = new RemEncodedStream(connection.InternalConnection.protocolVersion);                  dataStream.startMessage(Protocol.PrepareCall);                  dataStream.encodeString(nuodbSqlString);                  connection.InternalConnection.sendAndReceive(dataStream);                  handle = dataStream.getInt();                  connection.InternalConnection.RegisterCommand(handle);                  int numberParameters = dataStream.getInt();                  for (int i = 0; i < numberParameters; i++)                  {                      int direction = dataStream.getInt();                      String name = dataStream.getString();                      switch (direction)                      {                          case 0: newParams[i].Direction = ParameterDirection.Input; break;                          case 1: newParams[i].Direction = ParameterDirection.InputOutput; break;                          case 2: newParams[i].Direction = ParameterDirection.Output; break;                      }                      if (newParams[i].ParameterName.Length == 0)                          newParams[i].ParameterName = name;                  }                  parameters = newParams;                  isPrepared = true;                  isPreparedWithKeys = generatingKeys;              }              else              {                  EncodedDataStream dataStream = new RemEncodedStream(connection.InternalConnection.protocolVersion);                  if (generatingKeys)                  {                      dataStream.startMessage(Protocol.PrepareStatementKeys);                      dataStream.encodeInt(generatingKeys ? 1 : 0);                  }                  else                      dataStream.startMessage(Protocol.PrepareStatement);                  dataStream.encodeString(nuodbSqlString);                  connection.InternalConnection.sendAndReceive(dataStream);                  handle = dataStream.getInt();                  connection.InternalConnection.RegisterCommand(handle);                  int numberParameters = dataStream.getInt();                  // a prepared DDL command fails to execute                  if (numberParameters != 0 || nuodbSqlString.StartsWith("SELECT "' StringComparison.InvariantCultureIgnoreCase))                  {                      parameters = newParams;                      isPrepared = true;                      isPreparedWithKeys = generatingKeys;                  }                  else                  {                      Close();                      isPrepared = false;                  }              }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,BeginDbTransaction,The following statement contains a magic number: switch (isolationLevel)              {                  case IsolationLevel.Unspecified: level = 0; break;                  case IsolationLevel.ReadUncommitted: level = 1; break;                  case IsolationLevel.ReadCommitted: level = 2; break;                  case IsolationLevel.RepeatableRead: level = 4; break;                  case IsolationLevel.Serializable: level = 8; break;                  default:                      throw new NotSupportedException("The specified transaction isolation level is not supported");              }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,BeginDbTransaction,The following statement contains a magic number: switch (isolationLevel)              {                  case IsolationLevel.Unspecified: level = 0; break;                  case IsolationLevel.ReadUncommitted: level = 1; break;                  case IsolationLevel.ReadCommitted: level = 2; break;                  case IsolationLevel.RepeatableRead: level = 4; break;                  case IsolationLevel.Serializable: level = 8; break;                  default:                      throw new NotSupportedException("The specified transaction isolation level is not supported");              }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,BeginDbTransaction,The following statement contains a magic number: switch (isolationLevel)              {                  case IsolationLevel.Unspecified: level = 0; break;                  case IsolationLevel.ReadUncommitted: level = 1; break;                  case IsolationLevel.ReadCommitted: level = 2; break;                  case IsolationLevel.RepeatableRead: level = 4; break;                  case IsolationLevel.Serializable: level = 8; break;                  default:                      throw new NotSupportedException("The specified transaction isolation level is not supported");              }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,doOpen,The following statement contains a magic number: if (parsedConnectionString.ContainsKey(NuoDbConnectionStringBuilder.IsolationLevelKey))              {                  string isolationLevel = parsedConnectionString.IsolationLevel;                  int level = 0;                  if (isolationLevel.Equals("ReadCommitted"' StringComparison.InvariantCultureIgnoreCase))                  {                      // static const int TRANSACTION_READ_COMMITTED    = 2;                      level = 2;                  }                  else if (isolationLevel.Equals("Serializable"' StringComparison.InvariantCultureIgnoreCase))                  {                      // static const int TRANSACTION_SERIALIZABLE      = 8;                      level = 8;                  }                  else if (isolationLevel.Equals("WriteCommitted"' StringComparison.InvariantCultureIgnoreCase))                  {                      // static const int TRANSACTION_WRITE_COMMITTED   = 5;                      level = 5;                  }                  else if (isolationLevel.Equals("ConsistentRead"' StringComparison.InvariantCultureIgnoreCase))                  {                      // static const int TRANSACTION_CONSISTENT_READ   = 7;                      level = 7;                  }                  else                  {                      throw new NuoDbSqlException("\"" + isolationLevel + "\" is not a valid isolation level");                  }                  dataStream.startMessage(Protocol.SetTransactionIsolation);                  dataStream.encodeInt(level);                  sendAndReceive(dataStream);              }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,doOpen,The following statement contains a magic number: if (parsedConnectionString.ContainsKey(NuoDbConnectionStringBuilder.IsolationLevelKey))              {                  string isolationLevel = parsedConnectionString.IsolationLevel;                  int level = 0;                  if (isolationLevel.Equals("ReadCommitted"' StringComparison.InvariantCultureIgnoreCase))                  {                      // static const int TRANSACTION_READ_COMMITTED    = 2;                      level = 2;                  }                  else if (isolationLevel.Equals("Serializable"' StringComparison.InvariantCultureIgnoreCase))                  {                      // static const int TRANSACTION_SERIALIZABLE      = 8;                      level = 8;                  }                  else if (isolationLevel.Equals("WriteCommitted"' StringComparison.InvariantCultureIgnoreCase))                  {                      // static const int TRANSACTION_WRITE_COMMITTED   = 5;                      level = 5;                  }                  else if (isolationLevel.Equals("ConsistentRead"' StringComparison.InvariantCultureIgnoreCase))                  {                      // static const int TRANSACTION_CONSISTENT_READ   = 7;                      level = 7;                  }                  else                  {                      throw new NuoDbSqlException("\"" + isolationLevel + "\" is not a valid isolation level");                  }                  dataStream.startMessage(Protocol.SetTransactionIsolation);                  dataStream.encodeInt(level);                  sendAndReceive(dataStream);              }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,doOpen,The following statement contains a magic number: if (parsedConnectionString.ContainsKey(NuoDbConnectionStringBuilder.IsolationLevelKey))              {                  string isolationLevel = parsedConnectionString.IsolationLevel;                  int level = 0;                  if (isolationLevel.Equals("ReadCommitted"' StringComparison.InvariantCultureIgnoreCase))                  {                      // static const int TRANSACTION_READ_COMMITTED    = 2;                      level = 2;                  }                  else if (isolationLevel.Equals("Serializable"' StringComparison.InvariantCultureIgnoreCase))                  {                      // static const int TRANSACTION_SERIALIZABLE      = 8;                      level = 8;                  }                  else if (isolationLevel.Equals("WriteCommitted"' StringComparison.InvariantCultureIgnoreCase))                  {                      // static const int TRANSACTION_WRITE_COMMITTED   = 5;                      level = 5;                  }                  else if (isolationLevel.Equals("ConsistentRead"' StringComparison.InvariantCultureIgnoreCase))                  {                      // static const int TRANSACTION_CONSISTENT_READ   = 7;                      level = 7;                  }                  else                  {                      throw new NuoDbSqlException("\"" + isolationLevel + "\" is not a valid isolation level");                  }                  dataStream.startMessage(Protocol.SetTransactionIsolation);                  dataStream.encodeInt(level);                  sendAndReceive(dataStream);              }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,doOpen,The following statement contains a magic number: if (parsedConnectionString.ContainsKey(NuoDbConnectionStringBuilder.IsolationLevelKey))              {                  string isolationLevel = parsedConnectionString.IsolationLevel;                  int level = 0;                  if (isolationLevel.Equals("ReadCommitted"' StringComparison.InvariantCultureIgnoreCase))                  {                      // static const int TRANSACTION_READ_COMMITTED    = 2;                      level = 2;                  }                  else if (isolationLevel.Equals("Serializable"' StringComparison.InvariantCultureIgnoreCase))                  {                      // static const int TRANSACTION_SERIALIZABLE      = 8;                      level = 8;                  }                  else if (isolationLevel.Equals("WriteCommitted"' StringComparison.InvariantCultureIgnoreCase))                  {                      // static const int TRANSACTION_WRITE_COMMITTED   = 5;                      level = 5;                  }                  else if (isolationLevel.Equals("ConsistentRead"' StringComparison.InvariantCultureIgnoreCase))                  {                      // static const int TRANSACTION_CONSISTENT_READ   = 7;                      level = 7;                  }                  else                  {                      throw new NuoDbSqlException("\"" + isolationLevel + "\" is not a valid isolation level");                  }                  dataStream.startMessage(Protocol.SetTransactionIsolation);                  dataStream.encodeInt(level);                  sendAndReceive(dataStream);              }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The following statement contains a magic number: if (collectionName == DbMetaDataCollectionNames.DataSourceInformation)              {                  // see http://msdn.microsoft.com/en-us/library/ms254501.aspx                  table.Columns.Add("CompositeIdentifierSeparatorPattern"' typeof(string));                  table.Columns.Add("DataSourceProductName"' typeof(string));                  table.Columns.Add("DataSourceProductVersion"' typeof(string));                  table.Columns.Add("DataSourceProductVersionNormalized"' typeof(string));                  table.Columns.Add("DataSourceInternalProductVersion"' typeof(string));                  table.Columns.Add("GroupByBehavior"' typeof(GroupByBehavior));                  table.Columns.Add("IdentifierPattern"' typeof(string));                  table.Columns.Add("IdentifierCase"' typeof(IdentifierCase));                  table.Columns.Add("OrderByColumnsInSelect"' typeof(bool));                  table.Columns.Add("ParameterMarkerFormat"' typeof(string));                  table.Columns.Add("ParameterMarkerPattern"' typeof(string));                  table.Columns.Add("ParameterNameMaxLength"' typeof(int));                  table.Columns.Add("ParameterNamePattern"' typeof(string));                  table.Columns.Add("QuotedIdentifierPattern"' typeof(string));  // Regex                  table.Columns.Add("QuotedIdentifierCase"' typeof(int));                  table.Columns.Add("StatementSeparatorPattern"' typeof(string));                  table.Columns.Add("StringLiteralPattern"' typeof(string));  // Regex                  table.Columns.Add("SupportedJoinOperators"' typeof(SupportedJoinOperators));                    table.BeginLoadData();                  DataRow row = table.NewRow();                  int databaseMajorVersion = 0' databaseMinorVersion = 0;                  try                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetDatabaseMetaData);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      for (int item; (item = tmConn.InternalConnection.dataStream.getInt()) != Protocol.DbmbFini; )                      {                          switch (item)                          {                              case Protocol.DbmbProductName:                                  row["DataSourceProductName"] = tmConn.InternalConnection.dataStream.getString();                                  break;                                case Protocol.DbmbProductVersion:                                  row["DataSourceProductVersion"] = tmConn.InternalConnection.dataStream.getString();                                  break;                                case Protocol.DbmbDatabaseMinorVersion:                                  databaseMinorVersion = tmConn.InternalConnection.dataStream.getInt();                                  break;                                case Protocol.DbmbDatabaseMajorVersion:                                  databaseMajorVersion = tmConn.InternalConnection.dataStream.getInt();                                  break;                                case Protocol.DbmbDefaultTransactionIsolation:                                  int defaultTransactionIsolation = tmConn.InternalConnection.dataStream.getInt();                                  break;                                default:                                  tmConn.InternalConnection.dataStream.decode();                                  break;                          }                      }                  }                  catch (Exception)                  {                  }                    row["DataSourceInternalProductVersion"] = String.Format("{0:D3}.{1:D3}"' databaseMajorVersion' databaseMinorVersion);                  // The regular expression to match the composite separators in a composite identifier.                   // For example' "\." (for SQL Server) or "@|\." (for Oracle).                  // A composite identifier is typically what is used for a database object name'                   // for example: pubs.dbo.authors or pubs@dbo.authors.                  row["CompositeIdentifierSeparatorPattern"] = "\\.";                  // A normalized version for the data source' such that it can be compared with String.Compare().                   // The format of this is consistent for all versions of the provider to prevent version 10 from sorting between version 1 and version 2.                  //row["DataSourceProductVersionNormalized"] = ??                  // Specifies the relationship between the columns in a GROUP BY clause and the non-aggregated columns in the select list.                  row["GroupByBehavior"] = GroupByBehavior.Unknown;                  // A regular expression that matches an identifier and has a match value of the identifier. For example "[A-Za-z0-9_#$]".                  row["IdentifierPattern"] = "(^\\[\\p{Lo}\\p{Lu}\\p{Ll}_@#][\\p{Lo}\\p{Lu}\\p{Ll}\\p{Nd}@$#_]*$)|(^\"[^\"\\0]|\"\"+\"$)";                  // Indicates whether non-quoted identifiers are treated as case sensitive or not.                  row["IdentifierCase"] = IdentifierCase.Insensitive;                  // Specifies whether columns in an ORDER BY clause must be in the select list.                   // A value of true indicates that they are required to be in the select list'                   // a value of false indicates that they are not required to be in the select list.                  row["OrderByColumnsInSelect"] = false;                  // For data sources that do not expect named parameters and expect the use of the ‘?’ character' the format string                  // can be specified as simply '?'' which would ignore the parameter name.                  row["ParameterMarkerFormat"] = "?";                  // if the data source doesn't support named parameters' this would simply be "?".                  row["ParameterMarkerPattern"] = "?";                  // If the data source does not support named parameters' this property returns zero.                  row["ParameterNameMaxLength"] = 0;                  // A regular expression that matches the valid parameter names                  row["ParameterNamePattern"] = "";                  // A regular expression that matches a quoted identifier and has a match value of the identifier itself without the quotes.                   // For example' if the data source used double-quotes to identify quoted identifiers' this would be: "(([^\"]|\"\")*)".                  row["QuotedIdentifierPattern"] = "\"([^\"]*)\"";                  // Indicates whether quoted identifiers are treated as case sensitive or not.                  row["QuotedIdentifierCase"] = IdentifierCase.Sensitive;                  // A regular expression that matches the statement separator.                  row["StatementSeparatorPattern"] = ";";                  // A regular expression that matches a string literal and has a match value of the literal itself.                   // For example' if the data source used single-quotes to identify strings' this would be: "('([^']|'')*')"'                  row["StringLiteralPattern"] = "'([^']*)'";                  // Specifies what types of SQL join statements are supported by the data source.                  row["SupportedJoinOperators"] = SupportedJoinOperators.None;                  table.Rows.Add(row);                  table.EndLoadData();              }              else if (collectionName == DbMetaDataCollectionNames.ReservedWords)              {                  table.Columns.Add("ReservedWord"' typeof(string));                  table.Columns.Add("MaximumVersion"' typeof(string));                  table.Columns.Add("MinimumVersion"' typeof(string));                    string[] words = { "select"' "Add field"' "Drop field"' "Alter table"' "Alter field"'                                      "Alter user"' "And"' "Or"' "Not"' "Create Index"' "Upgrade"' "Unique"'                                      "Table key"' "Table unique key"' "Primary Key"' "Create Table"'                                      "Upgrade Table"' "Rename Table"' "Create View"' "Upgrade View"'                                      "Drop View"' "Create Schema"' "Drop Schema"' "Integer"' "Smallint"'                                      "Bigint"' "Tinyint"' "float"' "double"' "Blob"' "bytes"' "boolean"'                                      "binary"' "varbinary"' "string"' "char"' "text"' "date"' "timestamp"'                                      "time"' "varchar"' "numeric"' "Decimal Number"' "Enum"' "Delete"' "Repair"'                                      "Field"' "Not Null"' "Default Value"' "searchable"' "not searchable"'                                      "collation"' "character_set"' "Foreign Key"' "Identifier"' "record number"'                                      "Insert"' "Replace"' "Name"' "Number"' "Order"' "Descending"' "limit"'                                      "Quoted String"' "Select Clause"' "Distinct"' "Gtr"' "Geq"' "Eql"'                                      "Leq"' "Lss"' "Neq"' "in list"' "in select"' "exists"' "Between"' "Like"'                                      "starts with"' "Containing"' "Matching"' "Regular expression"' "Null"'                                      "True"' "False"' "Execute"' "Parameter"' "Count"' "sum"' "min"' "max"'                                      "avg"' "Drop Index"' "Drop primary key"' "Drop foreign key"' "Drop Table"'                                      "If Exists"' "Describe"' "Statement"' "for_select"' "for_insert"' "while"'                                      "if then else"' "variable"' "declaration"' "throw"' "assignment"'                                      "Start transaction"' "read only"' "read write"' "read committed"' "write committed"'                                      "read uncommitted"' "repeatableread"' "serializable"' "Commit"' "Rollback"'                                      "Savepoint"' "Rollack Savepoint"' "Release Savepoint"' "Table"' "Derived Table"'                                      "Assign"' "Update"' "list"' "Constant"' "Function"' "Grant"' "Grant role"' "Alter"'                                      "Read"' "Identity"' "Check"' "Constraint"' "value constraint"' "auto increment"'                                      "generated"' "always"' "Domain"' "is null"' "is active_role"' "start with"' "reindex"'                                      "cursor"' "alias"' "push_namespace"' "pop_namespace"' "set_namespace"' "coalesce"'                                      "nod_nullif"' "case"' "case_search"' "add"' "subtract"' "multiply"' "divide"' "modulus"'                                      "negate"' "plus"' "cast"' "concatenation"' "create user"' "drop user"' "create role"'                                      "upgrade role"' "drop role"' "revoke"' "revoke role"' "assume"' "revert"' "negate"'                                      "priv insert"' "priv delete"' "priv execute"' "priv select"' "priv update"' "priv grant"'                                      "priv all"' "characters"' "octets"' "role"' "view"' "procedure"' "user"' "zone"' "admin"'                                      "default role"' "create sequence"' "upgrade sequence"' "drop sequence"' "next value"'                                      "create trigger"' "upgrade trigger"' "alter trigger"' "drop trigger"' "create procedure"'                                      "upgrade procedure"' "alter procedure"' "drop procedure"' "pre-insert"' "post-insert"'                                      "pre-update"' "post-update"' "pre-delete"' "post-delete"' "pre-commit"' "post-commit"'                                      "active"' "inactive"' "position"' "select-expr"' "create filterset"' "upgrade filterset"'                                      "drop filterset"' "enable filterset"' "disable filterset"' "table filter"' "left outer"'                                      "right outer"' "full outer"' "inner"' "join"' "join_term"' "trigger class"' "enable trigger class"'                                      "disable trigger class"' "create zone"' "upgrade zone"' "drop zone"' "range"' "ip address"'                                      "node_name"' "wildcard"' "create domain"' "upgrade domain"' "alter domain"' "upgrade schema"'                                      "delete cascade"' "index segment"' "for update"' "write committed"' "read committed"'                                       "consistent read"' "set dialect"' "set names"' "restrict"' "cascade"' "characters"' "octets"'                                      "create event"' "collate"' "truncate"' "restart"' "nameless constraint"' "drop constraint"'                                      "drop unique constraint"' "drop domain"' "with check option"' "not real"' "lower"' "upper"'                                      "substr"' "substring index"' "charlength"' "default keyword"' "sqrt"' "power"' "Scientific Notation Number"'                                      "Explain"' "msleep"' "KillStatement"' "now" };                  table.BeginLoadData();                  foreach (string keyword in words)                  {                      DataRow row = table.NewRow();                      row["ReservedWord"] = keyword;                      table.Rows.Add(row);                  }                  table.EndLoadData();                }              else if (collectionName == DbMetaDataCollectionNames.DataTypes)              {                  table.Columns.Add("TypeName"' typeof(string));  // The provider-specific data type name.                  table.Columns.Add("ProviderDbType"' typeof(int)); // The provider-specific type value that should be used when specifying                   //a parameter's type. For example' SqlDbType.Money or OracleType.Blob.                  table.Columns.Add("ColumnSize"' typeof(long));                  table.Columns.Add("CreateFormat"' typeof(string));                  table.Columns.Add("CreateParameters"' typeof(string));                  table.Columns.Add("DataType"' typeof(string));  // The name of the .NET Framework type of the data type.                  table.Columns.Add("IsAutoincrementable"' typeof(bool));                  table.Columns.Add("IsBestMatch"' typeof(bool));                  table.Columns.Add("IsCaseSensitive"' typeof(bool));                  table.Columns.Add("IsFixedLength"' typeof(bool));                  table.Columns.Add("IsFixedPrecisionScale"' typeof(bool));                  table.Columns.Add("IsLong"' typeof(bool));                  table.Columns.Add("IsNullable"' typeof(bool));                  table.Columns.Add("IsSearchable"' typeof(bool));                  table.Columns.Add("IsSearchableWithLike"' typeof(bool));                  table.Columns.Add("IsUnsigned"' typeof(bool));                  table.Columns.Add("MaximumScale"' typeof(short));                  table.Columns.Add("MinimumScale"' typeof(short));                  table.Columns.Add("IsConcurrencyType"' typeof(bool));                  table.Columns.Add("IsLiteralsSupported"' typeof(bool));                  table.Columns.Add("LiteralPrefix"' typeof(string));                  table.Columns.Add("LiteralSuffix"' typeof(string));                  table.Columns.Add("NativeDataType"' typeof(string));    // NativeDataType is an OLE DB specific column for exposing the OLE DB type of the data type .                    table.ReadXml(XmlReader.Create(typeof(NuoDbConnectionInternal).Assembly.GetManifestResourceStream("NuoDb.Data.Client.DataTypes.xml")));              }              else if (collectionName == "Tables")              {                  table.Columns.Add("TABLE_CATALOG"' typeof(string));                  table.Columns.Add("TABLE_SCHEMA"' typeof(string));                  table.Columns.Add("TABLE_NAME"' typeof(string));                  table.Columns.Add("TABLE_TYPE"' typeof(string));                  table.Columns.Add("REMARKS"' typeof(string));                  table.Columns.Add("VIEW_DEF"' typeof(string));                    tmConn.InternalConnection.dataStream.startMessage(Protocol.GetTables);                  tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                  for (int i = 1; i < 3; i++)                      if (restrictionValues != null && restrictionValues.Length > i)                          tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                      else                          tmConn.InternalConnection.dataStream.encodeNull();                  if (restrictionValues == null || restrictionValues.Length < 4 || restrictionValues[3] == null)                      tmConn.InternalConnection.dataStream.encodeInt(0);                  else                  {                      tmConn.InternalConnection.dataStream.encodeInt(1);                      tmConn.InternalConnection.dataStream.encodeString(restrictionValues[3]);                  }                    tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                  int handle = tmConn.InternalConnection.dataStream.getInt();                    if (handle != -1)                  {                      using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                      {                          table.BeginLoadData();                          string view_def_label="";                          try                           {                               reader.GetOrdinal("VIEW_DEF");                              view_def_label = "VIEW_DEF";                          }                          catch(Exception) {}                          try                           {                               reader.GetOrdinal("VIEWDEFINITION");                              view_def_label = "VIEWDEFINITION";                          }                          catch (Exception) { }                          while (reader.Read())                          {  #if DEBUG                          System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_NAME"] + "' " + reader["TABLE_TYPE"]);  #endif                              DataRow row = table.NewRow();                              row["TABLE_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                              row["TABLE_NAME"] = reader.GetFieldValue<string>("TABLE_NAME");                              row["TABLE_TYPE"] = reader.GetFieldValue<string>("TABLE_TYPE");                              row["REMARKS"] = reader.GetFieldValue<string>("REMARKS");                              if (view_def_label.Length != 0)                              {                                  row["VIEW_DEF"] = reader.GetFieldValue<string>(view_def_label);                              }                              table.Rows.Add(row);                          }                          table.EndLoadData();                      }                  }              }              else if (collectionName == "Columns")              {                  table.Columns.Add("COLUMN_CATALOG"' typeof(string));                  table.Columns.Add("COLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("COLUMN_TABLE"' typeof(string));                  table.Columns.Add("COLUMN_NAME"' typeof(string));                  table.Columns.Add("COLUMN_POSITION"' typeof(int));                  table.Columns.Add("COLUMN_TYPE"' typeof(string));                  table.Columns.Add("COLUMN_LENGTH"' typeof(int));                  table.Columns.Add("COLUMN_PRECISION"' typeof(int));                  table.Columns.Add("COLUMN_NULLABLE"' typeof(bool));                  table.Columns.Add("COLUMN_IDENTITY"' typeof(bool));                  table.Columns.Add("COLUMN_DEFAULT"' typeof(string));                  table.Columns.Add("COLUMN_SCALE"' typeof(int));                    tmConn.InternalConnection.dataStream.startMessage(Protocol.GetColumns);                  tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                  for (int i = 1; i < 4; i++)                      if (restrictionValues != null && restrictionValues.Length > i)                          tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                      else                          tmConn.InternalConnection.dataStream.encodeNull();                    tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                  int handle = tmConn.InternalConnection.dataStream.getInt();                    if (handle != -1)                  {                      using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                      {                          table.BeginLoadData();                          while (reader.Read())                          {                              DataRow row = table.NewRow();                              row["COLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                              row["COLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                              row["COLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                              row["COLUMN_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                              row["COLUMN_LENGTH"] = reader.GetFieldValue<int>("COLUMN_SIZE");                              row["COLUMN_PRECISION"] = reader.GetFieldValue<int>("BUFFER_LENGTH");                              row["COLUMN_SCALE"] = reader.GetFieldValue<int>("DECIMAL_DIGITS");                              if (isNumeric(reader.GetFieldValue<string>("TYPE_NAME")))                              {                                  if (reader.GetFieldValue<int>("DECIMAL_DIGITS") != 0)                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME") +                                           "(" + reader.GetFieldValue<int>("BUFFER_LENGTH") + "'" + reader.GetFieldValue<int>("DECIMAL_DIGITS") + ")";                                  else                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME");                              }                              else                              {                                  if (isVarLenType(reader.GetFieldValue<string>("TYPE_NAME")) && reader.GetFieldValue<int>("COLUMN_SIZE") != 0)                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME") +                                           "(" + reader.GetFieldValue<int>("COLUMN_SIZE") + ")";                                  else                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME");                              }                              if (!reader.IsDBNull(reader.GetOrdinal("IS_NULLABLE")))                                  row["COLUMN_NULLABLE"] = reader.GetFieldValue<string>("IS_NULLABLE").Equals("YES");                              if (!reader.IsDBNull(reader.GetOrdinal("IS_AUTOINCREMENT")))                                  row["COLUMN_IDENTITY"] = reader.GetFieldValue<string>("IS_AUTOINCREMENT").Equals("YES");                              row["COLUMN_DEFAULT"] = reader.GetFieldValue<string>("COLUMN_DEF");    #if DEBUG                              System.Diagnostics.Trace.WriteLine("-> " + row["COLUMN_NAME"] + " " + row["COLUMN_TYPE"]);  #endif                              table.Rows.Add(row);                          }                          table.EndLoadData();                      }                  }              }              else if (collectionName == "Indexes")              {                  table.Columns.Add("INDEX_CATALOG"' typeof(string));                  table.Columns.Add("INDEX_SCHEMA"' typeof(string));                  table.Columns.Add("INDEX_TABLE"' typeof(string));                  table.Columns.Add("INDEX_NAME"' typeof(string));                  table.Columns.Add("INDEX_TYPE"' typeof(string));                  table.Columns.Add("INDEX_UNIQUE"' typeof(bool));                  table.Columns.Add("INDEX_PRIMARY"' typeof(bool));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetIndexInfo);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // unique                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // approximate                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        // to avoid to insert the same index more than once                      HashSet<string> unique = new HashSet<string>();                      if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;                                  if (!unique.Add(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;                                  DataRow row = table.NewRow();                                  row["INDEX_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEX_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEX_NAME"] = reader.GetFieldValue<string>("INDEX_NAME");                                  switch (reader.GetFieldValue<int>("TYPE"))                                  {                                      case 0:                                          row["INDEX_TYPE"] = "Primary";                                          break;                                      case 1:                                          row["INDEX_TYPE"] = "Unique";                                          break;                                      case 2:                                          row["INDEX_TYPE"] = "Secondary";                                          break;                                      case 3:                                          row["INDEX_TYPE"] = "Foreign Key";                                          break;                                  }                                  row["INDEX_UNIQUE"] = (reader.GetFieldValue<int>("NON_UNIQUE") == 0) ? true : false;                                  row["INDEX_PRIMARY"] = (reader.GetFieldValue<int>("TYPE") == 0) ? true : false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                        tmConn.InternalConnection.dataStream.startMessage(Protocol.GetPrimaryKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              // use INDEX_NAME' if present; if missing' the name of the index is in PK_NAME                              string indexName = "PK_NAME";                              foreach (string column in reader.columnNames)                              {                                  if (column == "INDEX_NAME")                                  {                                      indexName = "INDEX_NAME";                                      break;                                  }                              }                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>(indexName)))                                      continue;                                  if (!unique.Add(reader.GetFieldValue<string>(indexName)))                                      continue;                                  DataRow row = table.NewRow();                                  row["INDEX_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEX_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEX_NAME"] = reader.GetFieldValue<string>(indexName);                                  row["INDEX_TYPE"] = "Primary";                                  row["INDEX_UNIQUE"] = true;                                  row["INDEX_PRIMARY"] = true;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "IndexColumns")              {                  table.Columns.Add("INDEXCOLUMN_CATALOG"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_TABLE"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_INDEX"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_NAME"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_POSITION"' typeof(int));                  table.Columns.Add("INDEXCOLUMN_ISPRIMARY"' typeof(bool));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetIndexInfo);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // unique                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // approximate                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_SCHEM"] + "." + reader["TABLE_NAME"] + "=" + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["INDEXCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEXCOLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEXCOLUMN_INDEX"] = reader.GetFieldValue<string>("INDEX_NAME");                                  row["INDEXCOLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["INDEXCOLUMN_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                                  row["INDEXCOLUMN_ISPRIMARY"] = false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                        tmConn.InternalConnection.dataStream.startMessage(Protocol.GetPrimaryKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              // use INDEX_NAME' if present; if missing' the name of the index is in PK_NAME                              string indexName = "PK_NAME";                              foreach (string column in reader.columnNames)                              {                                  if (column == "INDEX_NAME")                                  {                                      indexName = "INDEX_NAME";                                      break;                                  }                              }                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>(indexName)))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_SCHEM"] + "." + reader["TABLE_NAME"] + " (Primary) =" + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["INDEXCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEXCOLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEXCOLUMN_INDEX"] = reader.GetFieldValue<string>(indexName);                                  row["INDEXCOLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["INDEXCOLUMN_POSITION"] = reader.GetFieldValue<int>("KEY_SEQ");                                  row["INDEXCOLUMN_ISPRIMARY"] = true;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ForeignKeys")              {                  table.Columns.Add("FOREIGNKEY_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEY_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEY_TABLE"' typeof(string));                  table.Columns.Add("FOREIGNKEY_NAME"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_TABLE"' typeof(string));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetImportedKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  string name = "[" + reader.GetFieldValue<string>("FKTABLE_SCHEM") + "]" +                                                   reader.GetFieldValue<string>("FKTABLE_NAME") + "." +                                                   reader.GetFieldValue<string>("FKCOLUMN_NAME") + "->" +                                                  "[" + reader.GetFieldValue<string>("PKTABLE_SCHEM") + "]" +                                                   reader.GetFieldValue<string>("PKTABLE_NAME") + "." +                                                   reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(name))                                      continue;                                  DataRow row = table.NewRow();                                  row["FOREIGNKEY_SCHEMA"] = reader.GetFieldValue<string>("FKTABLE_SCHEM");                                  row["FOREIGNKEY_TABLE"] = reader.GetFieldValue<string>("FKTABLE_NAME");                                  row["FOREIGNKEY_NAME"] = name;                                  row["FOREIGNKEY_OTHER_SCHEMA"] = reader.GetFieldValue<string>("PKTABLE_SCHEM");                                  row["FOREIGNKEY_OTHER_TABLE"] = reader.GetFieldValue<string>("PKTABLE_NAME");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ForeignKeyColumns")              {                  table.Columns.Add("FOREIGNKEYCOLUMN_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_TABLE"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_KEY"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_NAME"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_ORDINAL"' typeof(int));                  table.Columns.Add("FOREIGNKEYCOLUMN_OTHER_COLUMN_NAME"' typeof(string));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetImportedKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  string name = "[" + reader.GetFieldValue<string>("FKTABLE_SCHEM") + "]" +                                                  reader.GetFieldValue<string>("FKTABLE_NAME") + "." +                                                  reader.GetFieldValue<string>("FKCOLUMN_NAME") + "->" +                                                  "[" + reader.GetFieldValue<string>("PKTABLE_SCHEM") + "]" +                                                  reader.GetFieldValue<string>("PKTABLE_NAME") + "." +                                                  reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(name))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["FKTABLE_SCHEM"] + "." + reader["FKTABLE_NAME"] + "=" + reader["FKCOLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["FOREIGNKEYCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("FKTABLE_SCHEM");                                  row["FOREIGNKEYCOLUMN_TABLE"] = reader.GetFieldValue<string>("FKTABLE_NAME");                                  row["FOREIGNKEYCOLUMN_KEY"] = name;                                  row["FOREIGNKEYCOLUMN_NAME"] = reader.GetFieldValue<string>("FKCOLUMN_NAME");                                  row["FOREIGNKEYCOLUMN_ORDINAL"] = reader.GetFieldValue<int>("KEY_SEQ");                                  row["FOREIGNKEYCOLUMN_OTHER_COLUMN_NAME"] = reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "Procedures")               {                  table.Columns.Add("PROCEDURE_CATALOG"' typeof(string));                  table.Columns.Add("PROCEDURE_SCHEMA"' typeof(string));                  table.Columns.Add("PROCEDURE_NAME"' typeof(string));                  table.Columns.Add("IS_SYSTEM_PROCEDURE"' typeof(bool));                    if (tmConn.InternalConnection.protocolVersion >= Protocol.PROTOCOL_VERSION12)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetProcedures);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      for (int i = 1; i < 3; i++)                          if (restrictionValues != null && restrictionValues.Length > i)                              tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                          else                              tmConn.InternalConnection.dataStream.encodeNull();                        tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["PROCEDURE_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["PROCEDURE_SCHEMA"] = reader.GetFieldValue<string>("PROCEDURE_SCHEM");                                  row["PROCEDURE_NAME"] = reader.GetFieldValue<string>("PROCEDURE_NAME");                                  row["IS_SYSTEM_PROCEDURE"] = false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ProcedureParameters")              {                  table.Columns.Add("PROCEDURE_CATALOG"' typeof(string));                  table.Columns.Add("PROCEDURE_SCHEMA"' typeof(string));                  table.Columns.Add("PROCEDURE_NAME"' typeof(string));                  table.Columns.Add("PARAMETER_NAME"' typeof(string));                  table.Columns.Add("ORDINAL_POSITION"' typeof(int));                  table.Columns.Add("PARAMETER_DATA_TYPE"' typeof(int));                  table.Columns.Add("PARAMETER_TYPE_NAME"' typeof(string));                  table.Columns.Add("PARAMETER_SIZE"' typeof(int));                  table.Columns.Add("NUMERIC_PRECISION"' typeof(int));                  table.Columns.Add("NUMERIC_SCALE"' typeof(int));                  table.Columns.Add("PARAMETER_DIRECTION"' typeof(int));                  table.Columns.Add("IS_NULLABLE"' typeof(bool));                    if (tmConn.InternalConnection.protocolVersion >= Protocol.PROTOCOL_VERSION12)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetProcedureColumns);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      for (int i = 1; i < 4; i++)                          if (restrictionValues != null && restrictionValues.Length > i)                              tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                          else                              tmConn.InternalConnection.dataStream.encodeNull();                        tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["PROCEDURE_NAME"] + "' " + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["PROCEDURE_SCHEMA"] = reader.GetFieldValue<string>("PROCEDURE_SCHEM");                                  row["PROCEDURE_NAME"] = reader.GetFieldValue<string>("PROCEDURE_NAME");                                  row["PARAMETER_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["ORDINAL_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                                  row["PARAMETER_TYPE_NAME"] = reader.GetFieldValue<string>("TYPE_NAME");                                  row["PARAMETER_DATA_TYPE"] = reader.GetFieldValue<int>("DATA_TYPE");                                  row["PARAMETER_SIZE"] = reader.GetFieldValue<int>("LENGTH");                                  row["NUMERIC_PRECISION"] = reader.GetFieldValue<int>("PRECISION");                                  row["NUMERIC_SCALE"] = reader.GetFieldValue<int>("SCALE");                                  row["PARAMETER_DIRECTION"] = reader.GetFieldValue<int>("COLUMN_TYPE");                                  row["IS_NULLABLE"] = !reader.GetFieldValue<string>("IS_NULLABLE").Equals("NO");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The following statement contains a magic number: if (collectionName == DbMetaDataCollectionNames.DataSourceInformation)              {                  // see http://msdn.microsoft.com/en-us/library/ms254501.aspx                  table.Columns.Add("CompositeIdentifierSeparatorPattern"' typeof(string));                  table.Columns.Add("DataSourceProductName"' typeof(string));                  table.Columns.Add("DataSourceProductVersion"' typeof(string));                  table.Columns.Add("DataSourceProductVersionNormalized"' typeof(string));                  table.Columns.Add("DataSourceInternalProductVersion"' typeof(string));                  table.Columns.Add("GroupByBehavior"' typeof(GroupByBehavior));                  table.Columns.Add("IdentifierPattern"' typeof(string));                  table.Columns.Add("IdentifierCase"' typeof(IdentifierCase));                  table.Columns.Add("OrderByColumnsInSelect"' typeof(bool));                  table.Columns.Add("ParameterMarkerFormat"' typeof(string));                  table.Columns.Add("ParameterMarkerPattern"' typeof(string));                  table.Columns.Add("ParameterNameMaxLength"' typeof(int));                  table.Columns.Add("ParameterNamePattern"' typeof(string));                  table.Columns.Add("QuotedIdentifierPattern"' typeof(string));  // Regex                  table.Columns.Add("QuotedIdentifierCase"' typeof(int));                  table.Columns.Add("StatementSeparatorPattern"' typeof(string));                  table.Columns.Add("StringLiteralPattern"' typeof(string));  // Regex                  table.Columns.Add("SupportedJoinOperators"' typeof(SupportedJoinOperators));                    table.BeginLoadData();                  DataRow row = table.NewRow();                  int databaseMajorVersion = 0' databaseMinorVersion = 0;                  try                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetDatabaseMetaData);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      for (int item; (item = tmConn.InternalConnection.dataStream.getInt()) != Protocol.DbmbFini; )                      {                          switch (item)                          {                              case Protocol.DbmbProductName:                                  row["DataSourceProductName"] = tmConn.InternalConnection.dataStream.getString();                                  break;                                case Protocol.DbmbProductVersion:                                  row["DataSourceProductVersion"] = tmConn.InternalConnection.dataStream.getString();                                  break;                                case Protocol.DbmbDatabaseMinorVersion:                                  databaseMinorVersion = tmConn.InternalConnection.dataStream.getInt();                                  break;                                case Protocol.DbmbDatabaseMajorVersion:                                  databaseMajorVersion = tmConn.InternalConnection.dataStream.getInt();                                  break;                                case Protocol.DbmbDefaultTransactionIsolation:                                  int defaultTransactionIsolation = tmConn.InternalConnection.dataStream.getInt();                                  break;                                default:                                  tmConn.InternalConnection.dataStream.decode();                                  break;                          }                      }                  }                  catch (Exception)                  {                  }                    row["DataSourceInternalProductVersion"] = String.Format("{0:D3}.{1:D3}"' databaseMajorVersion' databaseMinorVersion);                  // The regular expression to match the composite separators in a composite identifier.                   // For example' "\." (for SQL Server) or "@|\." (for Oracle).                  // A composite identifier is typically what is used for a database object name'                   // for example: pubs.dbo.authors or pubs@dbo.authors.                  row["CompositeIdentifierSeparatorPattern"] = "\\.";                  // A normalized version for the data source' such that it can be compared with String.Compare().                   // The format of this is consistent for all versions of the provider to prevent version 10 from sorting between version 1 and version 2.                  //row["DataSourceProductVersionNormalized"] = ??                  // Specifies the relationship between the columns in a GROUP BY clause and the non-aggregated columns in the select list.                  row["GroupByBehavior"] = GroupByBehavior.Unknown;                  // A regular expression that matches an identifier and has a match value of the identifier. For example "[A-Za-z0-9_#$]".                  row["IdentifierPattern"] = "(^\\[\\p{Lo}\\p{Lu}\\p{Ll}_@#][\\p{Lo}\\p{Lu}\\p{Ll}\\p{Nd}@$#_]*$)|(^\"[^\"\\0]|\"\"+\"$)";                  // Indicates whether non-quoted identifiers are treated as case sensitive or not.                  row["IdentifierCase"] = IdentifierCase.Insensitive;                  // Specifies whether columns in an ORDER BY clause must be in the select list.                   // A value of true indicates that they are required to be in the select list'                   // a value of false indicates that they are not required to be in the select list.                  row["OrderByColumnsInSelect"] = false;                  // For data sources that do not expect named parameters and expect the use of the ‘?’ character' the format string                  // can be specified as simply '?'' which would ignore the parameter name.                  row["ParameterMarkerFormat"] = "?";                  // if the data source doesn't support named parameters' this would simply be "?".                  row["ParameterMarkerPattern"] = "?";                  // If the data source does not support named parameters' this property returns zero.                  row["ParameterNameMaxLength"] = 0;                  // A regular expression that matches the valid parameter names                  row["ParameterNamePattern"] = "";                  // A regular expression that matches a quoted identifier and has a match value of the identifier itself without the quotes.                   // For example' if the data source used double-quotes to identify quoted identifiers' this would be: "(([^\"]|\"\")*)".                  row["QuotedIdentifierPattern"] = "\"([^\"]*)\"";                  // Indicates whether quoted identifiers are treated as case sensitive or not.                  row["QuotedIdentifierCase"] = IdentifierCase.Sensitive;                  // A regular expression that matches the statement separator.                  row["StatementSeparatorPattern"] = ";";                  // A regular expression that matches a string literal and has a match value of the literal itself.                   // For example' if the data source used single-quotes to identify strings' this would be: "('([^']|'')*')"'                  row["StringLiteralPattern"] = "'([^']*)'";                  // Specifies what types of SQL join statements are supported by the data source.                  row["SupportedJoinOperators"] = SupportedJoinOperators.None;                  table.Rows.Add(row);                  table.EndLoadData();              }              else if (collectionName == DbMetaDataCollectionNames.ReservedWords)              {                  table.Columns.Add("ReservedWord"' typeof(string));                  table.Columns.Add("MaximumVersion"' typeof(string));                  table.Columns.Add("MinimumVersion"' typeof(string));                    string[] words = { "select"' "Add field"' "Drop field"' "Alter table"' "Alter field"'                                      "Alter user"' "And"' "Or"' "Not"' "Create Index"' "Upgrade"' "Unique"'                                      "Table key"' "Table unique key"' "Primary Key"' "Create Table"'                                      "Upgrade Table"' "Rename Table"' "Create View"' "Upgrade View"'                                      "Drop View"' "Create Schema"' "Drop Schema"' "Integer"' "Smallint"'                                      "Bigint"' "Tinyint"' "float"' "double"' "Blob"' "bytes"' "boolean"'                                      "binary"' "varbinary"' "string"' "char"' "text"' "date"' "timestamp"'                                      "time"' "varchar"' "numeric"' "Decimal Number"' "Enum"' "Delete"' "Repair"'                                      "Field"' "Not Null"' "Default Value"' "searchable"' "not searchable"'                                      "collation"' "character_set"' "Foreign Key"' "Identifier"' "record number"'                                      "Insert"' "Replace"' "Name"' "Number"' "Order"' "Descending"' "limit"'                                      "Quoted String"' "Select Clause"' "Distinct"' "Gtr"' "Geq"' "Eql"'                                      "Leq"' "Lss"' "Neq"' "in list"' "in select"' "exists"' "Between"' "Like"'                                      "starts with"' "Containing"' "Matching"' "Regular expression"' "Null"'                                      "True"' "False"' "Execute"' "Parameter"' "Count"' "sum"' "min"' "max"'                                      "avg"' "Drop Index"' "Drop primary key"' "Drop foreign key"' "Drop Table"'                                      "If Exists"' "Describe"' "Statement"' "for_select"' "for_insert"' "while"'                                      "if then else"' "variable"' "declaration"' "throw"' "assignment"'                                      "Start transaction"' "read only"' "read write"' "read committed"' "write committed"'                                      "read uncommitted"' "repeatableread"' "serializable"' "Commit"' "Rollback"'                                      "Savepoint"' "Rollack Savepoint"' "Release Savepoint"' "Table"' "Derived Table"'                                      "Assign"' "Update"' "list"' "Constant"' "Function"' "Grant"' "Grant role"' "Alter"'                                      "Read"' "Identity"' "Check"' "Constraint"' "value constraint"' "auto increment"'                                      "generated"' "always"' "Domain"' "is null"' "is active_role"' "start with"' "reindex"'                                      "cursor"' "alias"' "push_namespace"' "pop_namespace"' "set_namespace"' "coalesce"'                                      "nod_nullif"' "case"' "case_search"' "add"' "subtract"' "multiply"' "divide"' "modulus"'                                      "negate"' "plus"' "cast"' "concatenation"' "create user"' "drop user"' "create role"'                                      "upgrade role"' "drop role"' "revoke"' "revoke role"' "assume"' "revert"' "negate"'                                      "priv insert"' "priv delete"' "priv execute"' "priv select"' "priv update"' "priv grant"'                                      "priv all"' "characters"' "octets"' "role"' "view"' "procedure"' "user"' "zone"' "admin"'                                      "default role"' "create sequence"' "upgrade sequence"' "drop sequence"' "next value"'                                      "create trigger"' "upgrade trigger"' "alter trigger"' "drop trigger"' "create procedure"'                                      "upgrade procedure"' "alter procedure"' "drop procedure"' "pre-insert"' "post-insert"'                                      "pre-update"' "post-update"' "pre-delete"' "post-delete"' "pre-commit"' "post-commit"'                                      "active"' "inactive"' "position"' "select-expr"' "create filterset"' "upgrade filterset"'                                      "drop filterset"' "enable filterset"' "disable filterset"' "table filter"' "left outer"'                                      "right outer"' "full outer"' "inner"' "join"' "join_term"' "trigger class"' "enable trigger class"'                                      "disable trigger class"' "create zone"' "upgrade zone"' "drop zone"' "range"' "ip address"'                                      "node_name"' "wildcard"' "create domain"' "upgrade domain"' "alter domain"' "upgrade schema"'                                      "delete cascade"' "index segment"' "for update"' "write committed"' "read committed"'                                       "consistent read"' "set dialect"' "set names"' "restrict"' "cascade"' "characters"' "octets"'                                      "create event"' "collate"' "truncate"' "restart"' "nameless constraint"' "drop constraint"'                                      "drop unique constraint"' "drop domain"' "with check option"' "not real"' "lower"' "upper"'                                      "substr"' "substring index"' "charlength"' "default keyword"' "sqrt"' "power"' "Scientific Notation Number"'                                      "Explain"' "msleep"' "KillStatement"' "now" };                  table.BeginLoadData();                  foreach (string keyword in words)                  {                      DataRow row = table.NewRow();                      row["ReservedWord"] = keyword;                      table.Rows.Add(row);                  }                  table.EndLoadData();                }              else if (collectionName == DbMetaDataCollectionNames.DataTypes)              {                  table.Columns.Add("TypeName"' typeof(string));  // The provider-specific data type name.                  table.Columns.Add("ProviderDbType"' typeof(int)); // The provider-specific type value that should be used when specifying                   //a parameter's type. For example' SqlDbType.Money or OracleType.Blob.                  table.Columns.Add("ColumnSize"' typeof(long));                  table.Columns.Add("CreateFormat"' typeof(string));                  table.Columns.Add("CreateParameters"' typeof(string));                  table.Columns.Add("DataType"' typeof(string));  // The name of the .NET Framework type of the data type.                  table.Columns.Add("IsAutoincrementable"' typeof(bool));                  table.Columns.Add("IsBestMatch"' typeof(bool));                  table.Columns.Add("IsCaseSensitive"' typeof(bool));                  table.Columns.Add("IsFixedLength"' typeof(bool));                  table.Columns.Add("IsFixedPrecisionScale"' typeof(bool));                  table.Columns.Add("IsLong"' typeof(bool));                  table.Columns.Add("IsNullable"' typeof(bool));                  table.Columns.Add("IsSearchable"' typeof(bool));                  table.Columns.Add("IsSearchableWithLike"' typeof(bool));                  table.Columns.Add("IsUnsigned"' typeof(bool));                  table.Columns.Add("MaximumScale"' typeof(short));                  table.Columns.Add("MinimumScale"' typeof(short));                  table.Columns.Add("IsConcurrencyType"' typeof(bool));                  table.Columns.Add("IsLiteralsSupported"' typeof(bool));                  table.Columns.Add("LiteralPrefix"' typeof(string));                  table.Columns.Add("LiteralSuffix"' typeof(string));                  table.Columns.Add("NativeDataType"' typeof(string));    // NativeDataType is an OLE DB specific column for exposing the OLE DB type of the data type .                    table.ReadXml(XmlReader.Create(typeof(NuoDbConnectionInternal).Assembly.GetManifestResourceStream("NuoDb.Data.Client.DataTypes.xml")));              }              else if (collectionName == "Tables")              {                  table.Columns.Add("TABLE_CATALOG"' typeof(string));                  table.Columns.Add("TABLE_SCHEMA"' typeof(string));                  table.Columns.Add("TABLE_NAME"' typeof(string));                  table.Columns.Add("TABLE_TYPE"' typeof(string));                  table.Columns.Add("REMARKS"' typeof(string));                  table.Columns.Add("VIEW_DEF"' typeof(string));                    tmConn.InternalConnection.dataStream.startMessage(Protocol.GetTables);                  tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                  for (int i = 1; i < 3; i++)                      if (restrictionValues != null && restrictionValues.Length > i)                          tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                      else                          tmConn.InternalConnection.dataStream.encodeNull();                  if (restrictionValues == null || restrictionValues.Length < 4 || restrictionValues[3] == null)                      tmConn.InternalConnection.dataStream.encodeInt(0);                  else                  {                      tmConn.InternalConnection.dataStream.encodeInt(1);                      tmConn.InternalConnection.dataStream.encodeString(restrictionValues[3]);                  }                    tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                  int handle = tmConn.InternalConnection.dataStream.getInt();                    if (handle != -1)                  {                      using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                      {                          table.BeginLoadData();                          string view_def_label="";                          try                           {                               reader.GetOrdinal("VIEW_DEF");                              view_def_label = "VIEW_DEF";                          }                          catch(Exception) {}                          try                           {                               reader.GetOrdinal("VIEWDEFINITION");                              view_def_label = "VIEWDEFINITION";                          }                          catch (Exception) { }                          while (reader.Read())                          {  #if DEBUG                          System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_NAME"] + "' " + reader["TABLE_TYPE"]);  #endif                              DataRow row = table.NewRow();                              row["TABLE_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                              row["TABLE_NAME"] = reader.GetFieldValue<string>("TABLE_NAME");                              row["TABLE_TYPE"] = reader.GetFieldValue<string>("TABLE_TYPE");                              row["REMARKS"] = reader.GetFieldValue<string>("REMARKS");                              if (view_def_label.Length != 0)                              {                                  row["VIEW_DEF"] = reader.GetFieldValue<string>(view_def_label);                              }                              table.Rows.Add(row);                          }                          table.EndLoadData();                      }                  }              }              else if (collectionName == "Columns")              {                  table.Columns.Add("COLUMN_CATALOG"' typeof(string));                  table.Columns.Add("COLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("COLUMN_TABLE"' typeof(string));                  table.Columns.Add("COLUMN_NAME"' typeof(string));                  table.Columns.Add("COLUMN_POSITION"' typeof(int));                  table.Columns.Add("COLUMN_TYPE"' typeof(string));                  table.Columns.Add("COLUMN_LENGTH"' typeof(int));                  table.Columns.Add("COLUMN_PRECISION"' typeof(int));                  table.Columns.Add("COLUMN_NULLABLE"' typeof(bool));                  table.Columns.Add("COLUMN_IDENTITY"' typeof(bool));                  table.Columns.Add("COLUMN_DEFAULT"' typeof(string));                  table.Columns.Add("COLUMN_SCALE"' typeof(int));                    tmConn.InternalConnection.dataStream.startMessage(Protocol.GetColumns);                  tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                  for (int i = 1; i < 4; i++)                      if (restrictionValues != null && restrictionValues.Length > i)                          tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                      else                          tmConn.InternalConnection.dataStream.encodeNull();                    tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                  int handle = tmConn.InternalConnection.dataStream.getInt();                    if (handle != -1)                  {                      using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                      {                          table.BeginLoadData();                          while (reader.Read())                          {                              DataRow row = table.NewRow();                              row["COLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                              row["COLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                              row["COLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                              row["COLUMN_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                              row["COLUMN_LENGTH"] = reader.GetFieldValue<int>("COLUMN_SIZE");                              row["COLUMN_PRECISION"] = reader.GetFieldValue<int>("BUFFER_LENGTH");                              row["COLUMN_SCALE"] = reader.GetFieldValue<int>("DECIMAL_DIGITS");                              if (isNumeric(reader.GetFieldValue<string>("TYPE_NAME")))                              {                                  if (reader.GetFieldValue<int>("DECIMAL_DIGITS") != 0)                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME") +                                           "(" + reader.GetFieldValue<int>("BUFFER_LENGTH") + "'" + reader.GetFieldValue<int>("DECIMAL_DIGITS") + ")";                                  else                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME");                              }                              else                              {                                  if (isVarLenType(reader.GetFieldValue<string>("TYPE_NAME")) && reader.GetFieldValue<int>("COLUMN_SIZE") != 0)                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME") +                                           "(" + reader.GetFieldValue<int>("COLUMN_SIZE") + ")";                                  else                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME");                              }                              if (!reader.IsDBNull(reader.GetOrdinal("IS_NULLABLE")))                                  row["COLUMN_NULLABLE"] = reader.GetFieldValue<string>("IS_NULLABLE").Equals("YES");                              if (!reader.IsDBNull(reader.GetOrdinal("IS_AUTOINCREMENT")))                                  row["COLUMN_IDENTITY"] = reader.GetFieldValue<string>("IS_AUTOINCREMENT").Equals("YES");                              row["COLUMN_DEFAULT"] = reader.GetFieldValue<string>("COLUMN_DEF");    #if DEBUG                              System.Diagnostics.Trace.WriteLine("-> " + row["COLUMN_NAME"] + " " + row["COLUMN_TYPE"]);  #endif                              table.Rows.Add(row);                          }                          table.EndLoadData();                      }                  }              }              else if (collectionName == "Indexes")              {                  table.Columns.Add("INDEX_CATALOG"' typeof(string));                  table.Columns.Add("INDEX_SCHEMA"' typeof(string));                  table.Columns.Add("INDEX_TABLE"' typeof(string));                  table.Columns.Add("INDEX_NAME"' typeof(string));                  table.Columns.Add("INDEX_TYPE"' typeof(string));                  table.Columns.Add("INDEX_UNIQUE"' typeof(bool));                  table.Columns.Add("INDEX_PRIMARY"' typeof(bool));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetIndexInfo);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // unique                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // approximate                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        // to avoid to insert the same index more than once                      HashSet<string> unique = new HashSet<string>();                      if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;                                  if (!unique.Add(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;                                  DataRow row = table.NewRow();                                  row["INDEX_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEX_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEX_NAME"] = reader.GetFieldValue<string>("INDEX_NAME");                                  switch (reader.GetFieldValue<int>("TYPE"))                                  {                                      case 0:                                          row["INDEX_TYPE"] = "Primary";                                          break;                                      case 1:                                          row["INDEX_TYPE"] = "Unique";                                          break;                                      case 2:                                          row["INDEX_TYPE"] = "Secondary";                                          break;                                      case 3:                                          row["INDEX_TYPE"] = "Foreign Key";                                          break;                                  }                                  row["INDEX_UNIQUE"] = (reader.GetFieldValue<int>("NON_UNIQUE") == 0) ? true : false;                                  row["INDEX_PRIMARY"] = (reader.GetFieldValue<int>("TYPE") == 0) ? true : false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                        tmConn.InternalConnection.dataStream.startMessage(Protocol.GetPrimaryKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              // use INDEX_NAME' if present; if missing' the name of the index is in PK_NAME                              string indexName = "PK_NAME";                              foreach (string column in reader.columnNames)                              {                                  if (column == "INDEX_NAME")                                  {                                      indexName = "INDEX_NAME";                                      break;                                  }                              }                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>(indexName)))                                      continue;                                  if (!unique.Add(reader.GetFieldValue<string>(indexName)))                                      continue;                                  DataRow row = table.NewRow();                                  row["INDEX_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEX_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEX_NAME"] = reader.GetFieldValue<string>(indexName);                                  row["INDEX_TYPE"] = "Primary";                                  row["INDEX_UNIQUE"] = true;                                  row["INDEX_PRIMARY"] = true;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "IndexColumns")              {                  table.Columns.Add("INDEXCOLUMN_CATALOG"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_TABLE"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_INDEX"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_NAME"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_POSITION"' typeof(int));                  table.Columns.Add("INDEXCOLUMN_ISPRIMARY"' typeof(bool));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetIndexInfo);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // unique                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // approximate                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_SCHEM"] + "." + reader["TABLE_NAME"] + "=" + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["INDEXCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEXCOLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEXCOLUMN_INDEX"] = reader.GetFieldValue<string>("INDEX_NAME");                                  row["INDEXCOLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["INDEXCOLUMN_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                                  row["INDEXCOLUMN_ISPRIMARY"] = false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                        tmConn.InternalConnection.dataStream.startMessage(Protocol.GetPrimaryKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              // use INDEX_NAME' if present; if missing' the name of the index is in PK_NAME                              string indexName = "PK_NAME";                              foreach (string column in reader.columnNames)                              {                                  if (column == "INDEX_NAME")                                  {                                      indexName = "INDEX_NAME";                                      break;                                  }                              }                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>(indexName)))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_SCHEM"] + "." + reader["TABLE_NAME"] + " (Primary) =" + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["INDEXCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEXCOLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEXCOLUMN_INDEX"] = reader.GetFieldValue<string>(indexName);                                  row["INDEXCOLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["INDEXCOLUMN_POSITION"] = reader.GetFieldValue<int>("KEY_SEQ");                                  row["INDEXCOLUMN_ISPRIMARY"] = true;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ForeignKeys")              {                  table.Columns.Add("FOREIGNKEY_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEY_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEY_TABLE"' typeof(string));                  table.Columns.Add("FOREIGNKEY_NAME"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_TABLE"' typeof(string));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetImportedKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  string name = "[" + reader.GetFieldValue<string>("FKTABLE_SCHEM") + "]" +                                                   reader.GetFieldValue<string>("FKTABLE_NAME") + "." +                                                   reader.GetFieldValue<string>("FKCOLUMN_NAME") + "->" +                                                  "[" + reader.GetFieldValue<string>("PKTABLE_SCHEM") + "]" +                                                   reader.GetFieldValue<string>("PKTABLE_NAME") + "." +                                                   reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(name))                                      continue;                                  DataRow row = table.NewRow();                                  row["FOREIGNKEY_SCHEMA"] = reader.GetFieldValue<string>("FKTABLE_SCHEM");                                  row["FOREIGNKEY_TABLE"] = reader.GetFieldValue<string>("FKTABLE_NAME");                                  row["FOREIGNKEY_NAME"] = name;                                  row["FOREIGNKEY_OTHER_SCHEMA"] = reader.GetFieldValue<string>("PKTABLE_SCHEM");                                  row["FOREIGNKEY_OTHER_TABLE"] = reader.GetFieldValue<string>("PKTABLE_NAME");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ForeignKeyColumns")              {                  table.Columns.Add("FOREIGNKEYCOLUMN_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_TABLE"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_KEY"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_NAME"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_ORDINAL"' typeof(int));                  table.Columns.Add("FOREIGNKEYCOLUMN_OTHER_COLUMN_NAME"' typeof(string));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetImportedKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  string name = "[" + reader.GetFieldValue<string>("FKTABLE_SCHEM") + "]" +                                                  reader.GetFieldValue<string>("FKTABLE_NAME") + "." +                                                  reader.GetFieldValue<string>("FKCOLUMN_NAME") + "->" +                                                  "[" + reader.GetFieldValue<string>("PKTABLE_SCHEM") + "]" +                                                  reader.GetFieldValue<string>("PKTABLE_NAME") + "." +                                                  reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(name))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["FKTABLE_SCHEM"] + "." + reader["FKTABLE_NAME"] + "=" + reader["FKCOLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["FOREIGNKEYCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("FKTABLE_SCHEM");                                  row["FOREIGNKEYCOLUMN_TABLE"] = reader.GetFieldValue<string>("FKTABLE_NAME");                                  row["FOREIGNKEYCOLUMN_KEY"] = name;                                  row["FOREIGNKEYCOLUMN_NAME"] = reader.GetFieldValue<string>("FKCOLUMN_NAME");                                  row["FOREIGNKEYCOLUMN_ORDINAL"] = reader.GetFieldValue<int>("KEY_SEQ");                                  row["FOREIGNKEYCOLUMN_OTHER_COLUMN_NAME"] = reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "Procedures")               {                  table.Columns.Add("PROCEDURE_CATALOG"' typeof(string));                  table.Columns.Add("PROCEDURE_SCHEMA"' typeof(string));                  table.Columns.Add("PROCEDURE_NAME"' typeof(string));                  table.Columns.Add("IS_SYSTEM_PROCEDURE"' typeof(bool));                    if (tmConn.InternalConnection.protocolVersion >= Protocol.PROTOCOL_VERSION12)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetProcedures);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      for (int i = 1; i < 3; i++)                          if (restrictionValues != null && restrictionValues.Length > i)                              tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                          else                              tmConn.InternalConnection.dataStream.encodeNull();                        tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["PROCEDURE_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["PROCEDURE_SCHEMA"] = reader.GetFieldValue<string>("PROCEDURE_SCHEM");                                  row["PROCEDURE_NAME"] = reader.GetFieldValue<string>("PROCEDURE_NAME");                                  row["IS_SYSTEM_PROCEDURE"] = false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ProcedureParameters")              {                  table.Columns.Add("PROCEDURE_CATALOG"' typeof(string));                  table.Columns.Add("PROCEDURE_SCHEMA"' typeof(string));                  table.Columns.Add("PROCEDURE_NAME"' typeof(string));                  table.Columns.Add("PARAMETER_NAME"' typeof(string));                  table.Columns.Add("ORDINAL_POSITION"' typeof(int));                  table.Columns.Add("PARAMETER_DATA_TYPE"' typeof(int));                  table.Columns.Add("PARAMETER_TYPE_NAME"' typeof(string));                  table.Columns.Add("PARAMETER_SIZE"' typeof(int));                  table.Columns.Add("NUMERIC_PRECISION"' typeof(int));                  table.Columns.Add("NUMERIC_SCALE"' typeof(int));                  table.Columns.Add("PARAMETER_DIRECTION"' typeof(int));                  table.Columns.Add("IS_NULLABLE"' typeof(bool));                    if (tmConn.InternalConnection.protocolVersion >= Protocol.PROTOCOL_VERSION12)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetProcedureColumns);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      for (int i = 1; i < 4; i++)                          if (restrictionValues != null && restrictionValues.Length > i)                              tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                          else                              tmConn.InternalConnection.dataStream.encodeNull();                        tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["PROCEDURE_NAME"] + "' " + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["PROCEDURE_SCHEMA"] = reader.GetFieldValue<string>("PROCEDURE_SCHEM");                                  row["PROCEDURE_NAME"] = reader.GetFieldValue<string>("PROCEDURE_NAME");                                  row["PARAMETER_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["ORDINAL_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                                  row["PARAMETER_TYPE_NAME"] = reader.GetFieldValue<string>("TYPE_NAME");                                  row["PARAMETER_DATA_TYPE"] = reader.GetFieldValue<int>("DATA_TYPE");                                  row["PARAMETER_SIZE"] = reader.GetFieldValue<int>("LENGTH");                                  row["NUMERIC_PRECISION"] = reader.GetFieldValue<int>("PRECISION");                                  row["NUMERIC_SCALE"] = reader.GetFieldValue<int>("SCALE");                                  row["PARAMETER_DIRECTION"] = reader.GetFieldValue<int>("COLUMN_TYPE");                                  row["IS_NULLABLE"] = !reader.GetFieldValue<string>("IS_NULLABLE").Equals("NO");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The following statement contains a magic number: if (collectionName == DbMetaDataCollectionNames.DataSourceInformation)              {                  // see http://msdn.microsoft.com/en-us/library/ms254501.aspx                  table.Columns.Add("CompositeIdentifierSeparatorPattern"' typeof(string));                  table.Columns.Add("DataSourceProductName"' typeof(string));                  table.Columns.Add("DataSourceProductVersion"' typeof(string));                  table.Columns.Add("DataSourceProductVersionNormalized"' typeof(string));                  table.Columns.Add("DataSourceInternalProductVersion"' typeof(string));                  table.Columns.Add("GroupByBehavior"' typeof(GroupByBehavior));                  table.Columns.Add("IdentifierPattern"' typeof(string));                  table.Columns.Add("IdentifierCase"' typeof(IdentifierCase));                  table.Columns.Add("OrderByColumnsInSelect"' typeof(bool));                  table.Columns.Add("ParameterMarkerFormat"' typeof(string));                  table.Columns.Add("ParameterMarkerPattern"' typeof(string));                  table.Columns.Add("ParameterNameMaxLength"' typeof(int));                  table.Columns.Add("ParameterNamePattern"' typeof(string));                  table.Columns.Add("QuotedIdentifierPattern"' typeof(string));  // Regex                  table.Columns.Add("QuotedIdentifierCase"' typeof(int));                  table.Columns.Add("StatementSeparatorPattern"' typeof(string));                  table.Columns.Add("StringLiteralPattern"' typeof(string));  // Regex                  table.Columns.Add("SupportedJoinOperators"' typeof(SupportedJoinOperators));                    table.BeginLoadData();                  DataRow row = table.NewRow();                  int databaseMajorVersion = 0' databaseMinorVersion = 0;                  try                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetDatabaseMetaData);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      for (int item; (item = tmConn.InternalConnection.dataStream.getInt()) != Protocol.DbmbFini; )                      {                          switch (item)                          {                              case Protocol.DbmbProductName:                                  row["DataSourceProductName"] = tmConn.InternalConnection.dataStream.getString();                                  break;                                case Protocol.DbmbProductVersion:                                  row["DataSourceProductVersion"] = tmConn.InternalConnection.dataStream.getString();                                  break;                                case Protocol.DbmbDatabaseMinorVersion:                                  databaseMinorVersion = tmConn.InternalConnection.dataStream.getInt();                                  break;                                case Protocol.DbmbDatabaseMajorVersion:                                  databaseMajorVersion = tmConn.InternalConnection.dataStream.getInt();                                  break;                                case Protocol.DbmbDefaultTransactionIsolation:                                  int defaultTransactionIsolation = tmConn.InternalConnection.dataStream.getInt();                                  break;                                default:                                  tmConn.InternalConnection.dataStream.decode();                                  break;                          }                      }                  }                  catch (Exception)                  {                  }                    row["DataSourceInternalProductVersion"] = String.Format("{0:D3}.{1:D3}"' databaseMajorVersion' databaseMinorVersion);                  // The regular expression to match the composite separators in a composite identifier.                   // For example' "\." (for SQL Server) or "@|\." (for Oracle).                  // A composite identifier is typically what is used for a database object name'                   // for example: pubs.dbo.authors or pubs@dbo.authors.                  row["CompositeIdentifierSeparatorPattern"] = "\\.";                  // A normalized version for the data source' such that it can be compared with String.Compare().                   // The format of this is consistent for all versions of the provider to prevent version 10 from sorting between version 1 and version 2.                  //row["DataSourceProductVersionNormalized"] = ??                  // Specifies the relationship between the columns in a GROUP BY clause and the non-aggregated columns in the select list.                  row["GroupByBehavior"] = GroupByBehavior.Unknown;                  // A regular expression that matches an identifier and has a match value of the identifier. For example "[A-Za-z0-9_#$]".                  row["IdentifierPattern"] = "(^\\[\\p{Lo}\\p{Lu}\\p{Ll}_@#][\\p{Lo}\\p{Lu}\\p{Ll}\\p{Nd}@$#_]*$)|(^\"[^\"\\0]|\"\"+\"$)";                  // Indicates whether non-quoted identifiers are treated as case sensitive or not.                  row["IdentifierCase"] = IdentifierCase.Insensitive;                  // Specifies whether columns in an ORDER BY clause must be in the select list.                   // A value of true indicates that they are required to be in the select list'                   // a value of false indicates that they are not required to be in the select list.                  row["OrderByColumnsInSelect"] = false;                  // For data sources that do not expect named parameters and expect the use of the ‘?’ character' the format string                  // can be specified as simply '?'' which would ignore the parameter name.                  row["ParameterMarkerFormat"] = "?";                  // if the data source doesn't support named parameters' this would simply be "?".                  row["ParameterMarkerPattern"] = "?";                  // If the data source does not support named parameters' this property returns zero.                  row["ParameterNameMaxLength"] = 0;                  // A regular expression that matches the valid parameter names                  row["ParameterNamePattern"] = "";                  // A regular expression that matches a quoted identifier and has a match value of the identifier itself without the quotes.                   // For example' if the data source used double-quotes to identify quoted identifiers' this would be: "(([^\"]|\"\")*)".                  row["QuotedIdentifierPattern"] = "\"([^\"]*)\"";                  // Indicates whether quoted identifiers are treated as case sensitive or not.                  row["QuotedIdentifierCase"] = IdentifierCase.Sensitive;                  // A regular expression that matches the statement separator.                  row["StatementSeparatorPattern"] = ";";                  // A regular expression that matches a string literal and has a match value of the literal itself.                   // For example' if the data source used single-quotes to identify strings' this would be: "('([^']|'')*')"'                  row["StringLiteralPattern"] = "'([^']*)'";                  // Specifies what types of SQL join statements are supported by the data source.                  row["SupportedJoinOperators"] = SupportedJoinOperators.None;                  table.Rows.Add(row);                  table.EndLoadData();              }              else if (collectionName == DbMetaDataCollectionNames.ReservedWords)              {                  table.Columns.Add("ReservedWord"' typeof(string));                  table.Columns.Add("MaximumVersion"' typeof(string));                  table.Columns.Add("MinimumVersion"' typeof(string));                    string[] words = { "select"' "Add field"' "Drop field"' "Alter table"' "Alter field"'                                      "Alter user"' "And"' "Or"' "Not"' "Create Index"' "Upgrade"' "Unique"'                                      "Table key"' "Table unique key"' "Primary Key"' "Create Table"'                                      "Upgrade Table"' "Rename Table"' "Create View"' "Upgrade View"'                                      "Drop View"' "Create Schema"' "Drop Schema"' "Integer"' "Smallint"'                                      "Bigint"' "Tinyint"' "float"' "double"' "Blob"' "bytes"' "boolean"'                                      "binary"' "varbinary"' "string"' "char"' "text"' "date"' "timestamp"'                                      "time"' "varchar"' "numeric"' "Decimal Number"' "Enum"' "Delete"' "Repair"'                                      "Field"' "Not Null"' "Default Value"' "searchable"' "not searchable"'                                      "collation"' "character_set"' "Foreign Key"' "Identifier"' "record number"'                                      "Insert"' "Replace"' "Name"' "Number"' "Order"' "Descending"' "limit"'                                      "Quoted String"' "Select Clause"' "Distinct"' "Gtr"' "Geq"' "Eql"'                                      "Leq"' "Lss"' "Neq"' "in list"' "in select"' "exists"' "Between"' "Like"'                                      "starts with"' "Containing"' "Matching"' "Regular expression"' "Null"'                                      "True"' "False"' "Execute"' "Parameter"' "Count"' "sum"' "min"' "max"'                                      "avg"' "Drop Index"' "Drop primary key"' "Drop foreign key"' "Drop Table"'                                      "If Exists"' "Describe"' "Statement"' "for_select"' "for_insert"' "while"'                                      "if then else"' "variable"' "declaration"' "throw"' "assignment"'                                      "Start transaction"' "read only"' "read write"' "read committed"' "write committed"'                                      "read uncommitted"' "repeatableread"' "serializable"' "Commit"' "Rollback"'                                      "Savepoint"' "Rollack Savepoint"' "Release Savepoint"' "Table"' "Derived Table"'                                      "Assign"' "Update"' "list"' "Constant"' "Function"' "Grant"' "Grant role"' "Alter"'                                      "Read"' "Identity"' "Check"' "Constraint"' "value constraint"' "auto increment"'                                      "generated"' "always"' "Domain"' "is null"' "is active_role"' "start with"' "reindex"'                                      "cursor"' "alias"' "push_namespace"' "pop_namespace"' "set_namespace"' "coalesce"'                                      "nod_nullif"' "case"' "case_search"' "add"' "subtract"' "multiply"' "divide"' "modulus"'                                      "negate"' "plus"' "cast"' "concatenation"' "create user"' "drop user"' "create role"'                                      "upgrade role"' "drop role"' "revoke"' "revoke role"' "assume"' "revert"' "negate"'                                      "priv insert"' "priv delete"' "priv execute"' "priv select"' "priv update"' "priv grant"'                                      "priv all"' "characters"' "octets"' "role"' "view"' "procedure"' "user"' "zone"' "admin"'                                      "default role"' "create sequence"' "upgrade sequence"' "drop sequence"' "next value"'                                      "create trigger"' "upgrade trigger"' "alter trigger"' "drop trigger"' "create procedure"'                                      "upgrade procedure"' "alter procedure"' "drop procedure"' "pre-insert"' "post-insert"'                                      "pre-update"' "post-update"' "pre-delete"' "post-delete"' "pre-commit"' "post-commit"'                                      "active"' "inactive"' "position"' "select-expr"' "create filterset"' "upgrade filterset"'                                      "drop filterset"' "enable filterset"' "disable filterset"' "table filter"' "left outer"'                                      "right outer"' "full outer"' "inner"' "join"' "join_term"' "trigger class"' "enable trigger class"'                                      "disable trigger class"' "create zone"' "upgrade zone"' "drop zone"' "range"' "ip address"'                                      "node_name"' "wildcard"' "create domain"' "upgrade domain"' "alter domain"' "upgrade schema"'                                      "delete cascade"' "index segment"' "for update"' "write committed"' "read committed"'                                       "consistent read"' "set dialect"' "set names"' "restrict"' "cascade"' "characters"' "octets"'                                      "create event"' "collate"' "truncate"' "restart"' "nameless constraint"' "drop constraint"'                                      "drop unique constraint"' "drop domain"' "with check option"' "not real"' "lower"' "upper"'                                      "substr"' "substring index"' "charlength"' "default keyword"' "sqrt"' "power"' "Scientific Notation Number"'                                      "Explain"' "msleep"' "KillStatement"' "now" };                  table.BeginLoadData();                  foreach (string keyword in words)                  {                      DataRow row = table.NewRow();                      row["ReservedWord"] = keyword;                      table.Rows.Add(row);                  }                  table.EndLoadData();                }              else if (collectionName == DbMetaDataCollectionNames.DataTypes)              {                  table.Columns.Add("TypeName"' typeof(string));  // The provider-specific data type name.                  table.Columns.Add("ProviderDbType"' typeof(int)); // The provider-specific type value that should be used when specifying                   //a parameter's type. For example' SqlDbType.Money or OracleType.Blob.                  table.Columns.Add("ColumnSize"' typeof(long));                  table.Columns.Add("CreateFormat"' typeof(string));                  table.Columns.Add("CreateParameters"' typeof(string));                  table.Columns.Add("DataType"' typeof(string));  // The name of the .NET Framework type of the data type.                  table.Columns.Add("IsAutoincrementable"' typeof(bool));                  table.Columns.Add("IsBestMatch"' typeof(bool));                  table.Columns.Add("IsCaseSensitive"' typeof(bool));                  table.Columns.Add("IsFixedLength"' typeof(bool));                  table.Columns.Add("IsFixedPrecisionScale"' typeof(bool));                  table.Columns.Add("IsLong"' typeof(bool));                  table.Columns.Add("IsNullable"' typeof(bool));                  table.Columns.Add("IsSearchable"' typeof(bool));                  table.Columns.Add("IsSearchableWithLike"' typeof(bool));                  table.Columns.Add("IsUnsigned"' typeof(bool));                  table.Columns.Add("MaximumScale"' typeof(short));                  table.Columns.Add("MinimumScale"' typeof(short));                  table.Columns.Add("IsConcurrencyType"' typeof(bool));                  table.Columns.Add("IsLiteralsSupported"' typeof(bool));                  table.Columns.Add("LiteralPrefix"' typeof(string));                  table.Columns.Add("LiteralSuffix"' typeof(string));                  table.Columns.Add("NativeDataType"' typeof(string));    // NativeDataType is an OLE DB specific column for exposing the OLE DB type of the data type .                    table.ReadXml(XmlReader.Create(typeof(NuoDbConnectionInternal).Assembly.GetManifestResourceStream("NuoDb.Data.Client.DataTypes.xml")));              }              else if (collectionName == "Tables")              {                  table.Columns.Add("TABLE_CATALOG"' typeof(string));                  table.Columns.Add("TABLE_SCHEMA"' typeof(string));                  table.Columns.Add("TABLE_NAME"' typeof(string));                  table.Columns.Add("TABLE_TYPE"' typeof(string));                  table.Columns.Add("REMARKS"' typeof(string));                  table.Columns.Add("VIEW_DEF"' typeof(string));                    tmConn.InternalConnection.dataStream.startMessage(Protocol.GetTables);                  tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                  for (int i = 1; i < 3; i++)                      if (restrictionValues != null && restrictionValues.Length > i)                          tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                      else                          tmConn.InternalConnection.dataStream.encodeNull();                  if (restrictionValues == null || restrictionValues.Length < 4 || restrictionValues[3] == null)                      tmConn.InternalConnection.dataStream.encodeInt(0);                  else                  {                      tmConn.InternalConnection.dataStream.encodeInt(1);                      tmConn.InternalConnection.dataStream.encodeString(restrictionValues[3]);                  }                    tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                  int handle = tmConn.InternalConnection.dataStream.getInt();                    if (handle != -1)                  {                      using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                      {                          table.BeginLoadData();                          string view_def_label="";                          try                           {                               reader.GetOrdinal("VIEW_DEF");                              view_def_label = "VIEW_DEF";                          }                          catch(Exception) {}                          try                           {                               reader.GetOrdinal("VIEWDEFINITION");                              view_def_label = "VIEWDEFINITION";                          }                          catch (Exception) { }                          while (reader.Read())                          {  #if DEBUG                          System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_NAME"] + "' " + reader["TABLE_TYPE"]);  #endif                              DataRow row = table.NewRow();                              row["TABLE_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                              row["TABLE_NAME"] = reader.GetFieldValue<string>("TABLE_NAME");                              row["TABLE_TYPE"] = reader.GetFieldValue<string>("TABLE_TYPE");                              row["REMARKS"] = reader.GetFieldValue<string>("REMARKS");                              if (view_def_label.Length != 0)                              {                                  row["VIEW_DEF"] = reader.GetFieldValue<string>(view_def_label);                              }                              table.Rows.Add(row);                          }                          table.EndLoadData();                      }                  }              }              else if (collectionName == "Columns")              {                  table.Columns.Add("COLUMN_CATALOG"' typeof(string));                  table.Columns.Add("COLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("COLUMN_TABLE"' typeof(string));                  table.Columns.Add("COLUMN_NAME"' typeof(string));                  table.Columns.Add("COLUMN_POSITION"' typeof(int));                  table.Columns.Add("COLUMN_TYPE"' typeof(string));                  table.Columns.Add("COLUMN_LENGTH"' typeof(int));                  table.Columns.Add("COLUMN_PRECISION"' typeof(int));                  table.Columns.Add("COLUMN_NULLABLE"' typeof(bool));                  table.Columns.Add("COLUMN_IDENTITY"' typeof(bool));                  table.Columns.Add("COLUMN_DEFAULT"' typeof(string));                  table.Columns.Add("COLUMN_SCALE"' typeof(int));                    tmConn.InternalConnection.dataStream.startMessage(Protocol.GetColumns);                  tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                  for (int i = 1; i < 4; i++)                      if (restrictionValues != null && restrictionValues.Length > i)                          tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                      else                          tmConn.InternalConnection.dataStream.encodeNull();                    tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                  int handle = tmConn.InternalConnection.dataStream.getInt();                    if (handle != -1)                  {                      using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                      {                          table.BeginLoadData();                          while (reader.Read())                          {                              DataRow row = table.NewRow();                              row["COLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                              row["COLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                              row["COLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                              row["COLUMN_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                              row["COLUMN_LENGTH"] = reader.GetFieldValue<int>("COLUMN_SIZE");                              row["COLUMN_PRECISION"] = reader.GetFieldValue<int>("BUFFER_LENGTH");                              row["COLUMN_SCALE"] = reader.GetFieldValue<int>("DECIMAL_DIGITS");                              if (isNumeric(reader.GetFieldValue<string>("TYPE_NAME")))                              {                                  if (reader.GetFieldValue<int>("DECIMAL_DIGITS") != 0)                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME") +                                           "(" + reader.GetFieldValue<int>("BUFFER_LENGTH") + "'" + reader.GetFieldValue<int>("DECIMAL_DIGITS") + ")";                                  else                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME");                              }                              else                              {                                  if (isVarLenType(reader.GetFieldValue<string>("TYPE_NAME")) && reader.GetFieldValue<int>("COLUMN_SIZE") != 0)                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME") +                                           "(" + reader.GetFieldValue<int>("COLUMN_SIZE") + ")";                                  else                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME");                              }                              if (!reader.IsDBNull(reader.GetOrdinal("IS_NULLABLE")))                                  row["COLUMN_NULLABLE"] = reader.GetFieldValue<string>("IS_NULLABLE").Equals("YES");                              if (!reader.IsDBNull(reader.GetOrdinal("IS_AUTOINCREMENT")))                                  row["COLUMN_IDENTITY"] = reader.GetFieldValue<string>("IS_AUTOINCREMENT").Equals("YES");                              row["COLUMN_DEFAULT"] = reader.GetFieldValue<string>("COLUMN_DEF");    #if DEBUG                              System.Diagnostics.Trace.WriteLine("-> " + row["COLUMN_NAME"] + " " + row["COLUMN_TYPE"]);  #endif                              table.Rows.Add(row);                          }                          table.EndLoadData();                      }                  }              }              else if (collectionName == "Indexes")              {                  table.Columns.Add("INDEX_CATALOG"' typeof(string));                  table.Columns.Add("INDEX_SCHEMA"' typeof(string));                  table.Columns.Add("INDEX_TABLE"' typeof(string));                  table.Columns.Add("INDEX_NAME"' typeof(string));                  table.Columns.Add("INDEX_TYPE"' typeof(string));                  table.Columns.Add("INDEX_UNIQUE"' typeof(bool));                  table.Columns.Add("INDEX_PRIMARY"' typeof(bool));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetIndexInfo);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // unique                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // approximate                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        // to avoid to insert the same index more than once                      HashSet<string> unique = new HashSet<string>();                      if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;                                  if (!unique.Add(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;                                  DataRow row = table.NewRow();                                  row["INDEX_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEX_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEX_NAME"] = reader.GetFieldValue<string>("INDEX_NAME");                                  switch (reader.GetFieldValue<int>("TYPE"))                                  {                                      case 0:                                          row["INDEX_TYPE"] = "Primary";                                          break;                                      case 1:                                          row["INDEX_TYPE"] = "Unique";                                          break;                                      case 2:                                          row["INDEX_TYPE"] = "Secondary";                                          break;                                      case 3:                                          row["INDEX_TYPE"] = "Foreign Key";                                          break;                                  }                                  row["INDEX_UNIQUE"] = (reader.GetFieldValue<int>("NON_UNIQUE") == 0) ? true : false;                                  row["INDEX_PRIMARY"] = (reader.GetFieldValue<int>("TYPE") == 0) ? true : false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                        tmConn.InternalConnection.dataStream.startMessage(Protocol.GetPrimaryKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              // use INDEX_NAME' if present; if missing' the name of the index is in PK_NAME                              string indexName = "PK_NAME";                              foreach (string column in reader.columnNames)                              {                                  if (column == "INDEX_NAME")                                  {                                      indexName = "INDEX_NAME";                                      break;                                  }                              }                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>(indexName)))                                      continue;                                  if (!unique.Add(reader.GetFieldValue<string>(indexName)))                                      continue;                                  DataRow row = table.NewRow();                                  row["INDEX_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEX_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEX_NAME"] = reader.GetFieldValue<string>(indexName);                                  row["INDEX_TYPE"] = "Primary";                                  row["INDEX_UNIQUE"] = true;                                  row["INDEX_PRIMARY"] = true;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "IndexColumns")              {                  table.Columns.Add("INDEXCOLUMN_CATALOG"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_TABLE"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_INDEX"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_NAME"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_POSITION"' typeof(int));                  table.Columns.Add("INDEXCOLUMN_ISPRIMARY"' typeof(bool));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetIndexInfo);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // unique                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // approximate                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_SCHEM"] + "." + reader["TABLE_NAME"] + "=" + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["INDEXCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEXCOLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEXCOLUMN_INDEX"] = reader.GetFieldValue<string>("INDEX_NAME");                                  row["INDEXCOLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["INDEXCOLUMN_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                                  row["INDEXCOLUMN_ISPRIMARY"] = false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                        tmConn.InternalConnection.dataStream.startMessage(Protocol.GetPrimaryKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              // use INDEX_NAME' if present; if missing' the name of the index is in PK_NAME                              string indexName = "PK_NAME";                              foreach (string column in reader.columnNames)                              {                                  if (column == "INDEX_NAME")                                  {                                      indexName = "INDEX_NAME";                                      break;                                  }                              }                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>(indexName)))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_SCHEM"] + "." + reader["TABLE_NAME"] + " (Primary) =" + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["INDEXCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEXCOLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEXCOLUMN_INDEX"] = reader.GetFieldValue<string>(indexName);                                  row["INDEXCOLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["INDEXCOLUMN_POSITION"] = reader.GetFieldValue<int>("KEY_SEQ");                                  row["INDEXCOLUMN_ISPRIMARY"] = true;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ForeignKeys")              {                  table.Columns.Add("FOREIGNKEY_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEY_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEY_TABLE"' typeof(string));                  table.Columns.Add("FOREIGNKEY_NAME"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_TABLE"' typeof(string));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetImportedKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  string name = "[" + reader.GetFieldValue<string>("FKTABLE_SCHEM") + "]" +                                                   reader.GetFieldValue<string>("FKTABLE_NAME") + "." +                                                   reader.GetFieldValue<string>("FKCOLUMN_NAME") + "->" +                                                  "[" + reader.GetFieldValue<string>("PKTABLE_SCHEM") + "]" +                                                   reader.GetFieldValue<string>("PKTABLE_NAME") + "." +                                                   reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(name))                                      continue;                                  DataRow row = table.NewRow();                                  row["FOREIGNKEY_SCHEMA"] = reader.GetFieldValue<string>("FKTABLE_SCHEM");                                  row["FOREIGNKEY_TABLE"] = reader.GetFieldValue<string>("FKTABLE_NAME");                                  row["FOREIGNKEY_NAME"] = name;                                  row["FOREIGNKEY_OTHER_SCHEMA"] = reader.GetFieldValue<string>("PKTABLE_SCHEM");                                  row["FOREIGNKEY_OTHER_TABLE"] = reader.GetFieldValue<string>("PKTABLE_NAME");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ForeignKeyColumns")              {                  table.Columns.Add("FOREIGNKEYCOLUMN_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_TABLE"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_KEY"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_NAME"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_ORDINAL"' typeof(int));                  table.Columns.Add("FOREIGNKEYCOLUMN_OTHER_COLUMN_NAME"' typeof(string));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetImportedKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  string name = "[" + reader.GetFieldValue<string>("FKTABLE_SCHEM") + "]" +                                                  reader.GetFieldValue<string>("FKTABLE_NAME") + "." +                                                  reader.GetFieldValue<string>("FKCOLUMN_NAME") + "->" +                                                  "[" + reader.GetFieldValue<string>("PKTABLE_SCHEM") + "]" +                                                  reader.GetFieldValue<string>("PKTABLE_NAME") + "." +                                                  reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(name))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["FKTABLE_SCHEM"] + "." + reader["FKTABLE_NAME"] + "=" + reader["FKCOLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["FOREIGNKEYCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("FKTABLE_SCHEM");                                  row["FOREIGNKEYCOLUMN_TABLE"] = reader.GetFieldValue<string>("FKTABLE_NAME");                                  row["FOREIGNKEYCOLUMN_KEY"] = name;                                  row["FOREIGNKEYCOLUMN_NAME"] = reader.GetFieldValue<string>("FKCOLUMN_NAME");                                  row["FOREIGNKEYCOLUMN_ORDINAL"] = reader.GetFieldValue<int>("KEY_SEQ");                                  row["FOREIGNKEYCOLUMN_OTHER_COLUMN_NAME"] = reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "Procedures")               {                  table.Columns.Add("PROCEDURE_CATALOG"' typeof(string));                  table.Columns.Add("PROCEDURE_SCHEMA"' typeof(string));                  table.Columns.Add("PROCEDURE_NAME"' typeof(string));                  table.Columns.Add("IS_SYSTEM_PROCEDURE"' typeof(bool));                    if (tmConn.InternalConnection.protocolVersion >= Protocol.PROTOCOL_VERSION12)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetProcedures);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      for (int i = 1; i < 3; i++)                          if (restrictionValues != null && restrictionValues.Length > i)                              tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                          else                              tmConn.InternalConnection.dataStream.encodeNull();                        tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["PROCEDURE_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["PROCEDURE_SCHEMA"] = reader.GetFieldValue<string>("PROCEDURE_SCHEM");                                  row["PROCEDURE_NAME"] = reader.GetFieldValue<string>("PROCEDURE_NAME");                                  row["IS_SYSTEM_PROCEDURE"] = false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ProcedureParameters")              {                  table.Columns.Add("PROCEDURE_CATALOG"' typeof(string));                  table.Columns.Add("PROCEDURE_SCHEMA"' typeof(string));                  table.Columns.Add("PROCEDURE_NAME"' typeof(string));                  table.Columns.Add("PARAMETER_NAME"' typeof(string));                  table.Columns.Add("ORDINAL_POSITION"' typeof(int));                  table.Columns.Add("PARAMETER_DATA_TYPE"' typeof(int));                  table.Columns.Add("PARAMETER_TYPE_NAME"' typeof(string));                  table.Columns.Add("PARAMETER_SIZE"' typeof(int));                  table.Columns.Add("NUMERIC_PRECISION"' typeof(int));                  table.Columns.Add("NUMERIC_SCALE"' typeof(int));                  table.Columns.Add("PARAMETER_DIRECTION"' typeof(int));                  table.Columns.Add("IS_NULLABLE"' typeof(bool));                    if (tmConn.InternalConnection.protocolVersion >= Protocol.PROTOCOL_VERSION12)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetProcedureColumns);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      for (int i = 1; i < 4; i++)                          if (restrictionValues != null && restrictionValues.Length > i)                              tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                          else                              tmConn.InternalConnection.dataStream.encodeNull();                        tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["PROCEDURE_NAME"] + "' " + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["PROCEDURE_SCHEMA"] = reader.GetFieldValue<string>("PROCEDURE_SCHEM");                                  row["PROCEDURE_NAME"] = reader.GetFieldValue<string>("PROCEDURE_NAME");                                  row["PARAMETER_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["ORDINAL_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                                  row["PARAMETER_TYPE_NAME"] = reader.GetFieldValue<string>("TYPE_NAME");                                  row["PARAMETER_DATA_TYPE"] = reader.GetFieldValue<int>("DATA_TYPE");                                  row["PARAMETER_SIZE"] = reader.GetFieldValue<int>("LENGTH");                                  row["NUMERIC_PRECISION"] = reader.GetFieldValue<int>("PRECISION");                                  row["NUMERIC_SCALE"] = reader.GetFieldValue<int>("SCALE");                                  row["PARAMETER_DIRECTION"] = reader.GetFieldValue<int>("COLUMN_TYPE");                                  row["IS_NULLABLE"] = !reader.GetFieldValue<string>("IS_NULLABLE").Equals("NO");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The following statement contains a magic number: if (collectionName == DbMetaDataCollectionNames.DataSourceInformation)              {                  // see http://msdn.microsoft.com/en-us/library/ms254501.aspx                  table.Columns.Add("CompositeIdentifierSeparatorPattern"' typeof(string));                  table.Columns.Add("DataSourceProductName"' typeof(string));                  table.Columns.Add("DataSourceProductVersion"' typeof(string));                  table.Columns.Add("DataSourceProductVersionNormalized"' typeof(string));                  table.Columns.Add("DataSourceInternalProductVersion"' typeof(string));                  table.Columns.Add("GroupByBehavior"' typeof(GroupByBehavior));                  table.Columns.Add("IdentifierPattern"' typeof(string));                  table.Columns.Add("IdentifierCase"' typeof(IdentifierCase));                  table.Columns.Add("OrderByColumnsInSelect"' typeof(bool));                  table.Columns.Add("ParameterMarkerFormat"' typeof(string));                  table.Columns.Add("ParameterMarkerPattern"' typeof(string));                  table.Columns.Add("ParameterNameMaxLength"' typeof(int));                  table.Columns.Add("ParameterNamePattern"' typeof(string));                  table.Columns.Add("QuotedIdentifierPattern"' typeof(string));  // Regex                  table.Columns.Add("QuotedIdentifierCase"' typeof(int));                  table.Columns.Add("StatementSeparatorPattern"' typeof(string));                  table.Columns.Add("StringLiteralPattern"' typeof(string));  // Regex                  table.Columns.Add("SupportedJoinOperators"' typeof(SupportedJoinOperators));                    table.BeginLoadData();                  DataRow row = table.NewRow();                  int databaseMajorVersion = 0' databaseMinorVersion = 0;                  try                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetDatabaseMetaData);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      for (int item; (item = tmConn.InternalConnection.dataStream.getInt()) != Protocol.DbmbFini; )                      {                          switch (item)                          {                              case Protocol.DbmbProductName:                                  row["DataSourceProductName"] = tmConn.InternalConnection.dataStream.getString();                                  break;                                case Protocol.DbmbProductVersion:                                  row["DataSourceProductVersion"] = tmConn.InternalConnection.dataStream.getString();                                  break;                                case Protocol.DbmbDatabaseMinorVersion:                                  databaseMinorVersion = tmConn.InternalConnection.dataStream.getInt();                                  break;                                case Protocol.DbmbDatabaseMajorVersion:                                  databaseMajorVersion = tmConn.InternalConnection.dataStream.getInt();                                  break;                                case Protocol.DbmbDefaultTransactionIsolation:                                  int defaultTransactionIsolation = tmConn.InternalConnection.dataStream.getInt();                                  break;                                default:                                  tmConn.InternalConnection.dataStream.decode();                                  break;                          }                      }                  }                  catch (Exception)                  {                  }                    row["DataSourceInternalProductVersion"] = String.Format("{0:D3}.{1:D3}"' databaseMajorVersion' databaseMinorVersion);                  // The regular expression to match the composite separators in a composite identifier.                   // For example' "\." (for SQL Server) or "@|\." (for Oracle).                  // A composite identifier is typically what is used for a database object name'                   // for example: pubs.dbo.authors or pubs@dbo.authors.                  row["CompositeIdentifierSeparatorPattern"] = "\\.";                  // A normalized version for the data source' such that it can be compared with String.Compare().                   // The format of this is consistent for all versions of the provider to prevent version 10 from sorting between version 1 and version 2.                  //row["DataSourceProductVersionNormalized"] = ??                  // Specifies the relationship between the columns in a GROUP BY clause and the non-aggregated columns in the select list.                  row["GroupByBehavior"] = GroupByBehavior.Unknown;                  // A regular expression that matches an identifier and has a match value of the identifier. For example "[A-Za-z0-9_#$]".                  row["IdentifierPattern"] = "(^\\[\\p{Lo}\\p{Lu}\\p{Ll}_@#][\\p{Lo}\\p{Lu}\\p{Ll}\\p{Nd}@$#_]*$)|(^\"[^\"\\0]|\"\"+\"$)";                  // Indicates whether non-quoted identifiers are treated as case sensitive or not.                  row["IdentifierCase"] = IdentifierCase.Insensitive;                  // Specifies whether columns in an ORDER BY clause must be in the select list.                   // A value of true indicates that they are required to be in the select list'                   // a value of false indicates that they are not required to be in the select list.                  row["OrderByColumnsInSelect"] = false;                  // For data sources that do not expect named parameters and expect the use of the ‘?’ character' the format string                  // can be specified as simply '?'' which would ignore the parameter name.                  row["ParameterMarkerFormat"] = "?";                  // if the data source doesn't support named parameters' this would simply be "?".                  row["ParameterMarkerPattern"] = "?";                  // If the data source does not support named parameters' this property returns zero.                  row["ParameterNameMaxLength"] = 0;                  // A regular expression that matches the valid parameter names                  row["ParameterNamePattern"] = "";                  // A regular expression that matches a quoted identifier and has a match value of the identifier itself without the quotes.                   // For example' if the data source used double-quotes to identify quoted identifiers' this would be: "(([^\"]|\"\")*)".                  row["QuotedIdentifierPattern"] = "\"([^\"]*)\"";                  // Indicates whether quoted identifiers are treated as case sensitive or not.                  row["QuotedIdentifierCase"] = IdentifierCase.Sensitive;                  // A regular expression that matches the statement separator.                  row["StatementSeparatorPattern"] = ";";                  // A regular expression that matches a string literal and has a match value of the literal itself.                   // For example' if the data source used single-quotes to identify strings' this would be: "('([^']|'')*')"'                  row["StringLiteralPattern"] = "'([^']*)'";                  // Specifies what types of SQL join statements are supported by the data source.                  row["SupportedJoinOperators"] = SupportedJoinOperators.None;                  table.Rows.Add(row);                  table.EndLoadData();              }              else if (collectionName == DbMetaDataCollectionNames.ReservedWords)              {                  table.Columns.Add("ReservedWord"' typeof(string));                  table.Columns.Add("MaximumVersion"' typeof(string));                  table.Columns.Add("MinimumVersion"' typeof(string));                    string[] words = { "select"' "Add field"' "Drop field"' "Alter table"' "Alter field"'                                      "Alter user"' "And"' "Or"' "Not"' "Create Index"' "Upgrade"' "Unique"'                                      "Table key"' "Table unique key"' "Primary Key"' "Create Table"'                                      "Upgrade Table"' "Rename Table"' "Create View"' "Upgrade View"'                                      "Drop View"' "Create Schema"' "Drop Schema"' "Integer"' "Smallint"'                                      "Bigint"' "Tinyint"' "float"' "double"' "Blob"' "bytes"' "boolean"'                                      "binary"' "varbinary"' "string"' "char"' "text"' "date"' "timestamp"'                                      "time"' "varchar"' "numeric"' "Decimal Number"' "Enum"' "Delete"' "Repair"'                                      "Field"' "Not Null"' "Default Value"' "searchable"' "not searchable"'                                      "collation"' "character_set"' "Foreign Key"' "Identifier"' "record number"'                                      "Insert"' "Replace"' "Name"' "Number"' "Order"' "Descending"' "limit"'                                      "Quoted String"' "Select Clause"' "Distinct"' "Gtr"' "Geq"' "Eql"'                                      "Leq"' "Lss"' "Neq"' "in list"' "in select"' "exists"' "Between"' "Like"'                                      "starts with"' "Containing"' "Matching"' "Regular expression"' "Null"'                                      "True"' "False"' "Execute"' "Parameter"' "Count"' "sum"' "min"' "max"'                                      "avg"' "Drop Index"' "Drop primary key"' "Drop foreign key"' "Drop Table"'                                      "If Exists"' "Describe"' "Statement"' "for_select"' "for_insert"' "while"'                                      "if then else"' "variable"' "declaration"' "throw"' "assignment"'                                      "Start transaction"' "read only"' "read write"' "read committed"' "write committed"'                                      "read uncommitted"' "repeatableread"' "serializable"' "Commit"' "Rollback"'                                      "Savepoint"' "Rollack Savepoint"' "Release Savepoint"' "Table"' "Derived Table"'                                      "Assign"' "Update"' "list"' "Constant"' "Function"' "Grant"' "Grant role"' "Alter"'                                      "Read"' "Identity"' "Check"' "Constraint"' "value constraint"' "auto increment"'                                      "generated"' "always"' "Domain"' "is null"' "is active_role"' "start with"' "reindex"'                                      "cursor"' "alias"' "push_namespace"' "pop_namespace"' "set_namespace"' "coalesce"'                                      "nod_nullif"' "case"' "case_search"' "add"' "subtract"' "multiply"' "divide"' "modulus"'                                      "negate"' "plus"' "cast"' "concatenation"' "create user"' "drop user"' "create role"'                                      "upgrade role"' "drop role"' "revoke"' "revoke role"' "assume"' "revert"' "negate"'                                      "priv insert"' "priv delete"' "priv execute"' "priv select"' "priv update"' "priv grant"'                                      "priv all"' "characters"' "octets"' "role"' "view"' "procedure"' "user"' "zone"' "admin"'                                      "default role"' "create sequence"' "upgrade sequence"' "drop sequence"' "next value"'                                      "create trigger"' "upgrade trigger"' "alter trigger"' "drop trigger"' "create procedure"'                                      "upgrade procedure"' "alter procedure"' "drop procedure"' "pre-insert"' "post-insert"'                                      "pre-update"' "post-update"' "pre-delete"' "post-delete"' "pre-commit"' "post-commit"'                                      "active"' "inactive"' "position"' "select-expr"' "create filterset"' "upgrade filterset"'                                      "drop filterset"' "enable filterset"' "disable filterset"' "table filter"' "left outer"'                                      "right outer"' "full outer"' "inner"' "join"' "join_term"' "trigger class"' "enable trigger class"'                                      "disable trigger class"' "create zone"' "upgrade zone"' "drop zone"' "range"' "ip address"'                                      "node_name"' "wildcard"' "create domain"' "upgrade domain"' "alter domain"' "upgrade schema"'                                      "delete cascade"' "index segment"' "for update"' "write committed"' "read committed"'                                       "consistent read"' "set dialect"' "set names"' "restrict"' "cascade"' "characters"' "octets"'                                      "create event"' "collate"' "truncate"' "restart"' "nameless constraint"' "drop constraint"'                                      "drop unique constraint"' "drop domain"' "with check option"' "not real"' "lower"' "upper"'                                      "substr"' "substring index"' "charlength"' "default keyword"' "sqrt"' "power"' "Scientific Notation Number"'                                      "Explain"' "msleep"' "KillStatement"' "now" };                  table.BeginLoadData();                  foreach (string keyword in words)                  {                      DataRow row = table.NewRow();                      row["ReservedWord"] = keyword;                      table.Rows.Add(row);                  }                  table.EndLoadData();                }              else if (collectionName == DbMetaDataCollectionNames.DataTypes)              {                  table.Columns.Add("TypeName"' typeof(string));  // The provider-specific data type name.                  table.Columns.Add("ProviderDbType"' typeof(int)); // The provider-specific type value that should be used when specifying                   //a parameter's type. For example' SqlDbType.Money or OracleType.Blob.                  table.Columns.Add("ColumnSize"' typeof(long));                  table.Columns.Add("CreateFormat"' typeof(string));                  table.Columns.Add("CreateParameters"' typeof(string));                  table.Columns.Add("DataType"' typeof(string));  // The name of the .NET Framework type of the data type.                  table.Columns.Add("IsAutoincrementable"' typeof(bool));                  table.Columns.Add("IsBestMatch"' typeof(bool));                  table.Columns.Add("IsCaseSensitive"' typeof(bool));                  table.Columns.Add("IsFixedLength"' typeof(bool));                  table.Columns.Add("IsFixedPrecisionScale"' typeof(bool));                  table.Columns.Add("IsLong"' typeof(bool));                  table.Columns.Add("IsNullable"' typeof(bool));                  table.Columns.Add("IsSearchable"' typeof(bool));                  table.Columns.Add("IsSearchableWithLike"' typeof(bool));                  table.Columns.Add("IsUnsigned"' typeof(bool));                  table.Columns.Add("MaximumScale"' typeof(short));                  table.Columns.Add("MinimumScale"' typeof(short));                  table.Columns.Add("IsConcurrencyType"' typeof(bool));                  table.Columns.Add("IsLiteralsSupported"' typeof(bool));                  table.Columns.Add("LiteralPrefix"' typeof(string));                  table.Columns.Add("LiteralSuffix"' typeof(string));                  table.Columns.Add("NativeDataType"' typeof(string));    // NativeDataType is an OLE DB specific column for exposing the OLE DB type of the data type .                    table.ReadXml(XmlReader.Create(typeof(NuoDbConnectionInternal).Assembly.GetManifestResourceStream("NuoDb.Data.Client.DataTypes.xml")));              }              else if (collectionName == "Tables")              {                  table.Columns.Add("TABLE_CATALOG"' typeof(string));                  table.Columns.Add("TABLE_SCHEMA"' typeof(string));                  table.Columns.Add("TABLE_NAME"' typeof(string));                  table.Columns.Add("TABLE_TYPE"' typeof(string));                  table.Columns.Add("REMARKS"' typeof(string));                  table.Columns.Add("VIEW_DEF"' typeof(string));                    tmConn.InternalConnection.dataStream.startMessage(Protocol.GetTables);                  tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                  for (int i = 1; i < 3; i++)                      if (restrictionValues != null && restrictionValues.Length > i)                          tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                      else                          tmConn.InternalConnection.dataStream.encodeNull();                  if (restrictionValues == null || restrictionValues.Length < 4 || restrictionValues[3] == null)                      tmConn.InternalConnection.dataStream.encodeInt(0);                  else                  {                      tmConn.InternalConnection.dataStream.encodeInt(1);                      tmConn.InternalConnection.dataStream.encodeString(restrictionValues[3]);                  }                    tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                  int handle = tmConn.InternalConnection.dataStream.getInt();                    if (handle != -1)                  {                      using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                      {                          table.BeginLoadData();                          string view_def_label="";                          try                           {                               reader.GetOrdinal("VIEW_DEF");                              view_def_label = "VIEW_DEF";                          }                          catch(Exception) {}                          try                           {                               reader.GetOrdinal("VIEWDEFINITION");                              view_def_label = "VIEWDEFINITION";                          }                          catch (Exception) { }                          while (reader.Read())                          {  #if DEBUG                          System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_NAME"] + "' " + reader["TABLE_TYPE"]);  #endif                              DataRow row = table.NewRow();                              row["TABLE_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                              row["TABLE_NAME"] = reader.GetFieldValue<string>("TABLE_NAME");                              row["TABLE_TYPE"] = reader.GetFieldValue<string>("TABLE_TYPE");                              row["REMARKS"] = reader.GetFieldValue<string>("REMARKS");                              if (view_def_label.Length != 0)                              {                                  row["VIEW_DEF"] = reader.GetFieldValue<string>(view_def_label);                              }                              table.Rows.Add(row);                          }                          table.EndLoadData();                      }                  }              }              else if (collectionName == "Columns")              {                  table.Columns.Add("COLUMN_CATALOG"' typeof(string));                  table.Columns.Add("COLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("COLUMN_TABLE"' typeof(string));                  table.Columns.Add("COLUMN_NAME"' typeof(string));                  table.Columns.Add("COLUMN_POSITION"' typeof(int));                  table.Columns.Add("COLUMN_TYPE"' typeof(string));                  table.Columns.Add("COLUMN_LENGTH"' typeof(int));                  table.Columns.Add("COLUMN_PRECISION"' typeof(int));                  table.Columns.Add("COLUMN_NULLABLE"' typeof(bool));                  table.Columns.Add("COLUMN_IDENTITY"' typeof(bool));                  table.Columns.Add("COLUMN_DEFAULT"' typeof(string));                  table.Columns.Add("COLUMN_SCALE"' typeof(int));                    tmConn.InternalConnection.dataStream.startMessage(Protocol.GetColumns);                  tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                  for (int i = 1; i < 4; i++)                      if (restrictionValues != null && restrictionValues.Length > i)                          tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                      else                          tmConn.InternalConnection.dataStream.encodeNull();                    tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                  int handle = tmConn.InternalConnection.dataStream.getInt();                    if (handle != -1)                  {                      using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                      {                          table.BeginLoadData();                          while (reader.Read())                          {                              DataRow row = table.NewRow();                              row["COLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                              row["COLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                              row["COLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                              row["COLUMN_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                              row["COLUMN_LENGTH"] = reader.GetFieldValue<int>("COLUMN_SIZE");                              row["COLUMN_PRECISION"] = reader.GetFieldValue<int>("BUFFER_LENGTH");                              row["COLUMN_SCALE"] = reader.GetFieldValue<int>("DECIMAL_DIGITS");                              if (isNumeric(reader.GetFieldValue<string>("TYPE_NAME")))                              {                                  if (reader.GetFieldValue<int>("DECIMAL_DIGITS") != 0)                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME") +                                           "(" + reader.GetFieldValue<int>("BUFFER_LENGTH") + "'" + reader.GetFieldValue<int>("DECIMAL_DIGITS") + ")";                                  else                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME");                              }                              else                              {                                  if (isVarLenType(reader.GetFieldValue<string>("TYPE_NAME")) && reader.GetFieldValue<int>("COLUMN_SIZE") != 0)                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME") +                                           "(" + reader.GetFieldValue<int>("COLUMN_SIZE") + ")";                                  else                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME");                              }                              if (!reader.IsDBNull(reader.GetOrdinal("IS_NULLABLE")))                                  row["COLUMN_NULLABLE"] = reader.GetFieldValue<string>("IS_NULLABLE").Equals("YES");                              if (!reader.IsDBNull(reader.GetOrdinal("IS_AUTOINCREMENT")))                                  row["COLUMN_IDENTITY"] = reader.GetFieldValue<string>("IS_AUTOINCREMENT").Equals("YES");                              row["COLUMN_DEFAULT"] = reader.GetFieldValue<string>("COLUMN_DEF");    #if DEBUG                              System.Diagnostics.Trace.WriteLine("-> " + row["COLUMN_NAME"] + " " + row["COLUMN_TYPE"]);  #endif                              table.Rows.Add(row);                          }                          table.EndLoadData();                      }                  }              }              else if (collectionName == "Indexes")              {                  table.Columns.Add("INDEX_CATALOG"' typeof(string));                  table.Columns.Add("INDEX_SCHEMA"' typeof(string));                  table.Columns.Add("INDEX_TABLE"' typeof(string));                  table.Columns.Add("INDEX_NAME"' typeof(string));                  table.Columns.Add("INDEX_TYPE"' typeof(string));                  table.Columns.Add("INDEX_UNIQUE"' typeof(bool));                  table.Columns.Add("INDEX_PRIMARY"' typeof(bool));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetIndexInfo);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // unique                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // approximate                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        // to avoid to insert the same index more than once                      HashSet<string> unique = new HashSet<string>();                      if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;                                  if (!unique.Add(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;                                  DataRow row = table.NewRow();                                  row["INDEX_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEX_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEX_NAME"] = reader.GetFieldValue<string>("INDEX_NAME");                                  switch (reader.GetFieldValue<int>("TYPE"))                                  {                                      case 0:                                          row["INDEX_TYPE"] = "Primary";                                          break;                                      case 1:                                          row["INDEX_TYPE"] = "Unique";                                          break;                                      case 2:                                          row["INDEX_TYPE"] = "Secondary";                                          break;                                      case 3:                                          row["INDEX_TYPE"] = "Foreign Key";                                          break;                                  }                                  row["INDEX_UNIQUE"] = (reader.GetFieldValue<int>("NON_UNIQUE") == 0) ? true : false;                                  row["INDEX_PRIMARY"] = (reader.GetFieldValue<int>("TYPE") == 0) ? true : false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                        tmConn.InternalConnection.dataStream.startMessage(Protocol.GetPrimaryKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              // use INDEX_NAME' if present; if missing' the name of the index is in PK_NAME                              string indexName = "PK_NAME";                              foreach (string column in reader.columnNames)                              {                                  if (column == "INDEX_NAME")                                  {                                      indexName = "INDEX_NAME";                                      break;                                  }                              }                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>(indexName)))                                      continue;                                  if (!unique.Add(reader.GetFieldValue<string>(indexName)))                                      continue;                                  DataRow row = table.NewRow();                                  row["INDEX_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEX_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEX_NAME"] = reader.GetFieldValue<string>(indexName);                                  row["INDEX_TYPE"] = "Primary";                                  row["INDEX_UNIQUE"] = true;                                  row["INDEX_PRIMARY"] = true;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "IndexColumns")              {                  table.Columns.Add("INDEXCOLUMN_CATALOG"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_TABLE"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_INDEX"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_NAME"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_POSITION"' typeof(int));                  table.Columns.Add("INDEXCOLUMN_ISPRIMARY"' typeof(bool));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetIndexInfo);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // unique                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // approximate                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_SCHEM"] + "." + reader["TABLE_NAME"] + "=" + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["INDEXCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEXCOLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEXCOLUMN_INDEX"] = reader.GetFieldValue<string>("INDEX_NAME");                                  row["INDEXCOLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["INDEXCOLUMN_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                                  row["INDEXCOLUMN_ISPRIMARY"] = false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                        tmConn.InternalConnection.dataStream.startMessage(Protocol.GetPrimaryKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              // use INDEX_NAME' if present; if missing' the name of the index is in PK_NAME                              string indexName = "PK_NAME";                              foreach (string column in reader.columnNames)                              {                                  if (column == "INDEX_NAME")                                  {                                      indexName = "INDEX_NAME";                                      break;                                  }                              }                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>(indexName)))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_SCHEM"] + "." + reader["TABLE_NAME"] + " (Primary) =" + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["INDEXCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEXCOLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEXCOLUMN_INDEX"] = reader.GetFieldValue<string>(indexName);                                  row["INDEXCOLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["INDEXCOLUMN_POSITION"] = reader.GetFieldValue<int>("KEY_SEQ");                                  row["INDEXCOLUMN_ISPRIMARY"] = true;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ForeignKeys")              {                  table.Columns.Add("FOREIGNKEY_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEY_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEY_TABLE"' typeof(string));                  table.Columns.Add("FOREIGNKEY_NAME"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_TABLE"' typeof(string));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetImportedKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  string name = "[" + reader.GetFieldValue<string>("FKTABLE_SCHEM") + "]" +                                                   reader.GetFieldValue<string>("FKTABLE_NAME") + "." +                                                   reader.GetFieldValue<string>("FKCOLUMN_NAME") + "->" +                                                  "[" + reader.GetFieldValue<string>("PKTABLE_SCHEM") + "]" +                                                   reader.GetFieldValue<string>("PKTABLE_NAME") + "." +                                                   reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(name))                                      continue;                                  DataRow row = table.NewRow();                                  row["FOREIGNKEY_SCHEMA"] = reader.GetFieldValue<string>("FKTABLE_SCHEM");                                  row["FOREIGNKEY_TABLE"] = reader.GetFieldValue<string>("FKTABLE_NAME");                                  row["FOREIGNKEY_NAME"] = name;                                  row["FOREIGNKEY_OTHER_SCHEMA"] = reader.GetFieldValue<string>("PKTABLE_SCHEM");                                  row["FOREIGNKEY_OTHER_TABLE"] = reader.GetFieldValue<string>("PKTABLE_NAME");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ForeignKeyColumns")              {                  table.Columns.Add("FOREIGNKEYCOLUMN_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_TABLE"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_KEY"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_NAME"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_ORDINAL"' typeof(int));                  table.Columns.Add("FOREIGNKEYCOLUMN_OTHER_COLUMN_NAME"' typeof(string));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetImportedKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  string name = "[" + reader.GetFieldValue<string>("FKTABLE_SCHEM") + "]" +                                                  reader.GetFieldValue<string>("FKTABLE_NAME") + "." +                                                  reader.GetFieldValue<string>("FKCOLUMN_NAME") + "->" +                                                  "[" + reader.GetFieldValue<string>("PKTABLE_SCHEM") + "]" +                                                  reader.GetFieldValue<string>("PKTABLE_NAME") + "." +                                                  reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(name))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["FKTABLE_SCHEM"] + "." + reader["FKTABLE_NAME"] + "=" + reader["FKCOLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["FOREIGNKEYCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("FKTABLE_SCHEM");                                  row["FOREIGNKEYCOLUMN_TABLE"] = reader.GetFieldValue<string>("FKTABLE_NAME");                                  row["FOREIGNKEYCOLUMN_KEY"] = name;                                  row["FOREIGNKEYCOLUMN_NAME"] = reader.GetFieldValue<string>("FKCOLUMN_NAME");                                  row["FOREIGNKEYCOLUMN_ORDINAL"] = reader.GetFieldValue<int>("KEY_SEQ");                                  row["FOREIGNKEYCOLUMN_OTHER_COLUMN_NAME"] = reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "Procedures")               {                  table.Columns.Add("PROCEDURE_CATALOG"' typeof(string));                  table.Columns.Add("PROCEDURE_SCHEMA"' typeof(string));                  table.Columns.Add("PROCEDURE_NAME"' typeof(string));                  table.Columns.Add("IS_SYSTEM_PROCEDURE"' typeof(bool));                    if (tmConn.InternalConnection.protocolVersion >= Protocol.PROTOCOL_VERSION12)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetProcedures);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      for (int i = 1; i < 3; i++)                          if (restrictionValues != null && restrictionValues.Length > i)                              tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                          else                              tmConn.InternalConnection.dataStream.encodeNull();                        tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["PROCEDURE_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["PROCEDURE_SCHEMA"] = reader.GetFieldValue<string>("PROCEDURE_SCHEM");                                  row["PROCEDURE_NAME"] = reader.GetFieldValue<string>("PROCEDURE_NAME");                                  row["IS_SYSTEM_PROCEDURE"] = false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ProcedureParameters")              {                  table.Columns.Add("PROCEDURE_CATALOG"' typeof(string));                  table.Columns.Add("PROCEDURE_SCHEMA"' typeof(string));                  table.Columns.Add("PROCEDURE_NAME"' typeof(string));                  table.Columns.Add("PARAMETER_NAME"' typeof(string));                  table.Columns.Add("ORDINAL_POSITION"' typeof(int));                  table.Columns.Add("PARAMETER_DATA_TYPE"' typeof(int));                  table.Columns.Add("PARAMETER_TYPE_NAME"' typeof(string));                  table.Columns.Add("PARAMETER_SIZE"' typeof(int));                  table.Columns.Add("NUMERIC_PRECISION"' typeof(int));                  table.Columns.Add("NUMERIC_SCALE"' typeof(int));                  table.Columns.Add("PARAMETER_DIRECTION"' typeof(int));                  table.Columns.Add("IS_NULLABLE"' typeof(bool));                    if (tmConn.InternalConnection.protocolVersion >= Protocol.PROTOCOL_VERSION12)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetProcedureColumns);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      for (int i = 1; i < 4; i++)                          if (restrictionValues != null && restrictionValues.Length > i)                              tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                          else                              tmConn.InternalConnection.dataStream.encodeNull();                        tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["PROCEDURE_NAME"] + "' " + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["PROCEDURE_SCHEMA"] = reader.GetFieldValue<string>("PROCEDURE_SCHEM");                                  row["PROCEDURE_NAME"] = reader.GetFieldValue<string>("PROCEDURE_NAME");                                  row["PARAMETER_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["ORDINAL_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                                  row["PARAMETER_TYPE_NAME"] = reader.GetFieldValue<string>("TYPE_NAME");                                  row["PARAMETER_DATA_TYPE"] = reader.GetFieldValue<int>("DATA_TYPE");                                  row["PARAMETER_SIZE"] = reader.GetFieldValue<int>("LENGTH");                                  row["NUMERIC_PRECISION"] = reader.GetFieldValue<int>("PRECISION");                                  row["NUMERIC_SCALE"] = reader.GetFieldValue<int>("SCALE");                                  row["PARAMETER_DIRECTION"] = reader.GetFieldValue<int>("COLUMN_TYPE");                                  row["IS_NULLABLE"] = !reader.GetFieldValue<string>("IS_NULLABLE").Equals("NO");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The following statement contains a magic number: if (collectionName == DbMetaDataCollectionNames.DataSourceInformation)              {                  // see http://msdn.microsoft.com/en-us/library/ms254501.aspx                  table.Columns.Add("CompositeIdentifierSeparatorPattern"' typeof(string));                  table.Columns.Add("DataSourceProductName"' typeof(string));                  table.Columns.Add("DataSourceProductVersion"' typeof(string));                  table.Columns.Add("DataSourceProductVersionNormalized"' typeof(string));                  table.Columns.Add("DataSourceInternalProductVersion"' typeof(string));                  table.Columns.Add("GroupByBehavior"' typeof(GroupByBehavior));                  table.Columns.Add("IdentifierPattern"' typeof(string));                  table.Columns.Add("IdentifierCase"' typeof(IdentifierCase));                  table.Columns.Add("OrderByColumnsInSelect"' typeof(bool));                  table.Columns.Add("ParameterMarkerFormat"' typeof(string));                  table.Columns.Add("ParameterMarkerPattern"' typeof(string));                  table.Columns.Add("ParameterNameMaxLength"' typeof(int));                  table.Columns.Add("ParameterNamePattern"' typeof(string));                  table.Columns.Add("QuotedIdentifierPattern"' typeof(string));  // Regex                  table.Columns.Add("QuotedIdentifierCase"' typeof(int));                  table.Columns.Add("StatementSeparatorPattern"' typeof(string));                  table.Columns.Add("StringLiteralPattern"' typeof(string));  // Regex                  table.Columns.Add("SupportedJoinOperators"' typeof(SupportedJoinOperators));                    table.BeginLoadData();                  DataRow row = table.NewRow();                  int databaseMajorVersion = 0' databaseMinorVersion = 0;                  try                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetDatabaseMetaData);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      for (int item; (item = tmConn.InternalConnection.dataStream.getInt()) != Protocol.DbmbFini; )                      {                          switch (item)                          {                              case Protocol.DbmbProductName:                                  row["DataSourceProductName"] = tmConn.InternalConnection.dataStream.getString();                                  break;                                case Protocol.DbmbProductVersion:                                  row["DataSourceProductVersion"] = tmConn.InternalConnection.dataStream.getString();                                  break;                                case Protocol.DbmbDatabaseMinorVersion:                                  databaseMinorVersion = tmConn.InternalConnection.dataStream.getInt();                                  break;                                case Protocol.DbmbDatabaseMajorVersion:                                  databaseMajorVersion = tmConn.InternalConnection.dataStream.getInt();                                  break;                                case Protocol.DbmbDefaultTransactionIsolation:                                  int defaultTransactionIsolation = tmConn.InternalConnection.dataStream.getInt();                                  break;                                default:                                  tmConn.InternalConnection.dataStream.decode();                                  break;                          }                      }                  }                  catch (Exception)                  {                  }                    row["DataSourceInternalProductVersion"] = String.Format("{0:D3}.{1:D3}"' databaseMajorVersion' databaseMinorVersion);                  // The regular expression to match the composite separators in a composite identifier.                   // For example' "\." (for SQL Server) or "@|\." (for Oracle).                  // A composite identifier is typically what is used for a database object name'                   // for example: pubs.dbo.authors or pubs@dbo.authors.                  row["CompositeIdentifierSeparatorPattern"] = "\\.";                  // A normalized version for the data source' such that it can be compared with String.Compare().                   // The format of this is consistent for all versions of the provider to prevent version 10 from sorting between version 1 and version 2.                  //row["DataSourceProductVersionNormalized"] = ??                  // Specifies the relationship between the columns in a GROUP BY clause and the non-aggregated columns in the select list.                  row["GroupByBehavior"] = GroupByBehavior.Unknown;                  // A regular expression that matches an identifier and has a match value of the identifier. For example "[A-Za-z0-9_#$]".                  row["IdentifierPattern"] = "(^\\[\\p{Lo}\\p{Lu}\\p{Ll}_@#][\\p{Lo}\\p{Lu}\\p{Ll}\\p{Nd}@$#_]*$)|(^\"[^\"\\0]|\"\"+\"$)";                  // Indicates whether non-quoted identifiers are treated as case sensitive or not.                  row["IdentifierCase"] = IdentifierCase.Insensitive;                  // Specifies whether columns in an ORDER BY clause must be in the select list.                   // A value of true indicates that they are required to be in the select list'                   // a value of false indicates that they are not required to be in the select list.                  row["OrderByColumnsInSelect"] = false;                  // For data sources that do not expect named parameters and expect the use of the ‘?’ character' the format string                  // can be specified as simply '?'' which would ignore the parameter name.                  row["ParameterMarkerFormat"] = "?";                  // if the data source doesn't support named parameters' this would simply be "?".                  row["ParameterMarkerPattern"] = "?";                  // If the data source does not support named parameters' this property returns zero.                  row["ParameterNameMaxLength"] = 0;                  // A regular expression that matches the valid parameter names                  row["ParameterNamePattern"] = "";                  // A regular expression that matches a quoted identifier and has a match value of the identifier itself without the quotes.                   // For example' if the data source used double-quotes to identify quoted identifiers' this would be: "(([^\"]|\"\")*)".                  row["QuotedIdentifierPattern"] = "\"([^\"]*)\"";                  // Indicates whether quoted identifiers are treated as case sensitive or not.                  row["QuotedIdentifierCase"] = IdentifierCase.Sensitive;                  // A regular expression that matches the statement separator.                  row["StatementSeparatorPattern"] = ";";                  // A regular expression that matches a string literal and has a match value of the literal itself.                   // For example' if the data source used single-quotes to identify strings' this would be: "('([^']|'')*')"'                  row["StringLiteralPattern"] = "'([^']*)'";                  // Specifies what types of SQL join statements are supported by the data source.                  row["SupportedJoinOperators"] = SupportedJoinOperators.None;                  table.Rows.Add(row);                  table.EndLoadData();              }              else if (collectionName == DbMetaDataCollectionNames.ReservedWords)              {                  table.Columns.Add("ReservedWord"' typeof(string));                  table.Columns.Add("MaximumVersion"' typeof(string));                  table.Columns.Add("MinimumVersion"' typeof(string));                    string[] words = { "select"' "Add field"' "Drop field"' "Alter table"' "Alter field"'                                      "Alter user"' "And"' "Or"' "Not"' "Create Index"' "Upgrade"' "Unique"'                                      "Table key"' "Table unique key"' "Primary Key"' "Create Table"'                                      "Upgrade Table"' "Rename Table"' "Create View"' "Upgrade View"'                                      "Drop View"' "Create Schema"' "Drop Schema"' "Integer"' "Smallint"'                                      "Bigint"' "Tinyint"' "float"' "double"' "Blob"' "bytes"' "boolean"'                                      "binary"' "varbinary"' "string"' "char"' "text"' "date"' "timestamp"'                                      "time"' "varchar"' "numeric"' "Decimal Number"' "Enum"' "Delete"' "Repair"'                                      "Field"' "Not Null"' "Default Value"' "searchable"' "not searchable"'                                      "collation"' "character_set"' "Foreign Key"' "Identifier"' "record number"'                                      "Insert"' "Replace"' "Name"' "Number"' "Order"' "Descending"' "limit"'                                      "Quoted String"' "Select Clause"' "Distinct"' "Gtr"' "Geq"' "Eql"'                                      "Leq"' "Lss"' "Neq"' "in list"' "in select"' "exists"' "Between"' "Like"'                                      "starts with"' "Containing"' "Matching"' "Regular expression"' "Null"'                                      "True"' "False"' "Execute"' "Parameter"' "Count"' "sum"' "min"' "max"'                                      "avg"' "Drop Index"' "Drop primary key"' "Drop foreign key"' "Drop Table"'                                      "If Exists"' "Describe"' "Statement"' "for_select"' "for_insert"' "while"'                                      "if then else"' "variable"' "declaration"' "throw"' "assignment"'                                      "Start transaction"' "read only"' "read write"' "read committed"' "write committed"'                                      "read uncommitted"' "repeatableread"' "serializable"' "Commit"' "Rollback"'                                      "Savepoint"' "Rollack Savepoint"' "Release Savepoint"' "Table"' "Derived Table"'                                      "Assign"' "Update"' "list"' "Constant"' "Function"' "Grant"' "Grant role"' "Alter"'                                      "Read"' "Identity"' "Check"' "Constraint"' "value constraint"' "auto increment"'                                      "generated"' "always"' "Domain"' "is null"' "is active_role"' "start with"' "reindex"'                                      "cursor"' "alias"' "push_namespace"' "pop_namespace"' "set_namespace"' "coalesce"'                                      "nod_nullif"' "case"' "case_search"' "add"' "subtract"' "multiply"' "divide"' "modulus"'                                      "negate"' "plus"' "cast"' "concatenation"' "create user"' "drop user"' "create role"'                                      "upgrade role"' "drop role"' "revoke"' "revoke role"' "assume"' "revert"' "negate"'                                      "priv insert"' "priv delete"' "priv execute"' "priv select"' "priv update"' "priv grant"'                                      "priv all"' "characters"' "octets"' "role"' "view"' "procedure"' "user"' "zone"' "admin"'                                      "default role"' "create sequence"' "upgrade sequence"' "drop sequence"' "next value"'                                      "create trigger"' "upgrade trigger"' "alter trigger"' "drop trigger"' "create procedure"'                                      "upgrade procedure"' "alter procedure"' "drop procedure"' "pre-insert"' "post-insert"'                                      "pre-update"' "post-update"' "pre-delete"' "post-delete"' "pre-commit"' "post-commit"'                                      "active"' "inactive"' "position"' "select-expr"' "create filterset"' "upgrade filterset"'                                      "drop filterset"' "enable filterset"' "disable filterset"' "table filter"' "left outer"'                                      "right outer"' "full outer"' "inner"' "join"' "join_term"' "trigger class"' "enable trigger class"'                                      "disable trigger class"' "create zone"' "upgrade zone"' "drop zone"' "range"' "ip address"'                                      "node_name"' "wildcard"' "create domain"' "upgrade domain"' "alter domain"' "upgrade schema"'                                      "delete cascade"' "index segment"' "for update"' "write committed"' "read committed"'                                       "consistent read"' "set dialect"' "set names"' "restrict"' "cascade"' "characters"' "octets"'                                      "create event"' "collate"' "truncate"' "restart"' "nameless constraint"' "drop constraint"'                                      "drop unique constraint"' "drop domain"' "with check option"' "not real"' "lower"' "upper"'                                      "substr"' "substring index"' "charlength"' "default keyword"' "sqrt"' "power"' "Scientific Notation Number"'                                      "Explain"' "msleep"' "KillStatement"' "now" };                  table.BeginLoadData();                  foreach (string keyword in words)                  {                      DataRow row = table.NewRow();                      row["ReservedWord"] = keyword;                      table.Rows.Add(row);                  }                  table.EndLoadData();                }              else if (collectionName == DbMetaDataCollectionNames.DataTypes)              {                  table.Columns.Add("TypeName"' typeof(string));  // The provider-specific data type name.                  table.Columns.Add("ProviderDbType"' typeof(int)); // The provider-specific type value that should be used when specifying                   //a parameter's type. For example' SqlDbType.Money or OracleType.Blob.                  table.Columns.Add("ColumnSize"' typeof(long));                  table.Columns.Add("CreateFormat"' typeof(string));                  table.Columns.Add("CreateParameters"' typeof(string));                  table.Columns.Add("DataType"' typeof(string));  // The name of the .NET Framework type of the data type.                  table.Columns.Add("IsAutoincrementable"' typeof(bool));                  table.Columns.Add("IsBestMatch"' typeof(bool));                  table.Columns.Add("IsCaseSensitive"' typeof(bool));                  table.Columns.Add("IsFixedLength"' typeof(bool));                  table.Columns.Add("IsFixedPrecisionScale"' typeof(bool));                  table.Columns.Add("IsLong"' typeof(bool));                  table.Columns.Add("IsNullable"' typeof(bool));                  table.Columns.Add("IsSearchable"' typeof(bool));                  table.Columns.Add("IsSearchableWithLike"' typeof(bool));                  table.Columns.Add("IsUnsigned"' typeof(bool));                  table.Columns.Add("MaximumScale"' typeof(short));                  table.Columns.Add("MinimumScale"' typeof(short));                  table.Columns.Add("IsConcurrencyType"' typeof(bool));                  table.Columns.Add("IsLiteralsSupported"' typeof(bool));                  table.Columns.Add("LiteralPrefix"' typeof(string));                  table.Columns.Add("LiteralSuffix"' typeof(string));                  table.Columns.Add("NativeDataType"' typeof(string));    // NativeDataType is an OLE DB specific column for exposing the OLE DB type of the data type .                    table.ReadXml(XmlReader.Create(typeof(NuoDbConnectionInternal).Assembly.GetManifestResourceStream("NuoDb.Data.Client.DataTypes.xml")));              }              else if (collectionName == "Tables")              {                  table.Columns.Add("TABLE_CATALOG"' typeof(string));                  table.Columns.Add("TABLE_SCHEMA"' typeof(string));                  table.Columns.Add("TABLE_NAME"' typeof(string));                  table.Columns.Add("TABLE_TYPE"' typeof(string));                  table.Columns.Add("REMARKS"' typeof(string));                  table.Columns.Add("VIEW_DEF"' typeof(string));                    tmConn.InternalConnection.dataStream.startMessage(Protocol.GetTables);                  tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                  for (int i = 1; i < 3; i++)                      if (restrictionValues != null && restrictionValues.Length > i)                          tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                      else                          tmConn.InternalConnection.dataStream.encodeNull();                  if (restrictionValues == null || restrictionValues.Length < 4 || restrictionValues[3] == null)                      tmConn.InternalConnection.dataStream.encodeInt(0);                  else                  {                      tmConn.InternalConnection.dataStream.encodeInt(1);                      tmConn.InternalConnection.dataStream.encodeString(restrictionValues[3]);                  }                    tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                  int handle = tmConn.InternalConnection.dataStream.getInt();                    if (handle != -1)                  {                      using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                      {                          table.BeginLoadData();                          string view_def_label="";                          try                           {                               reader.GetOrdinal("VIEW_DEF");                              view_def_label = "VIEW_DEF";                          }                          catch(Exception) {}                          try                           {                               reader.GetOrdinal("VIEWDEFINITION");                              view_def_label = "VIEWDEFINITION";                          }                          catch (Exception) { }                          while (reader.Read())                          {  #if DEBUG                          System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_NAME"] + "' " + reader["TABLE_TYPE"]);  #endif                              DataRow row = table.NewRow();                              row["TABLE_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                              row["TABLE_NAME"] = reader.GetFieldValue<string>("TABLE_NAME");                              row["TABLE_TYPE"] = reader.GetFieldValue<string>("TABLE_TYPE");                              row["REMARKS"] = reader.GetFieldValue<string>("REMARKS");                              if (view_def_label.Length != 0)                              {                                  row["VIEW_DEF"] = reader.GetFieldValue<string>(view_def_label);                              }                              table.Rows.Add(row);                          }                          table.EndLoadData();                      }                  }              }              else if (collectionName == "Columns")              {                  table.Columns.Add("COLUMN_CATALOG"' typeof(string));                  table.Columns.Add("COLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("COLUMN_TABLE"' typeof(string));                  table.Columns.Add("COLUMN_NAME"' typeof(string));                  table.Columns.Add("COLUMN_POSITION"' typeof(int));                  table.Columns.Add("COLUMN_TYPE"' typeof(string));                  table.Columns.Add("COLUMN_LENGTH"' typeof(int));                  table.Columns.Add("COLUMN_PRECISION"' typeof(int));                  table.Columns.Add("COLUMN_NULLABLE"' typeof(bool));                  table.Columns.Add("COLUMN_IDENTITY"' typeof(bool));                  table.Columns.Add("COLUMN_DEFAULT"' typeof(string));                  table.Columns.Add("COLUMN_SCALE"' typeof(int));                    tmConn.InternalConnection.dataStream.startMessage(Protocol.GetColumns);                  tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                  for (int i = 1; i < 4; i++)                      if (restrictionValues != null && restrictionValues.Length > i)                          tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                      else                          tmConn.InternalConnection.dataStream.encodeNull();                    tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                  int handle = tmConn.InternalConnection.dataStream.getInt();                    if (handle != -1)                  {                      using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                      {                          table.BeginLoadData();                          while (reader.Read())                          {                              DataRow row = table.NewRow();                              row["COLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                              row["COLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                              row["COLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                              row["COLUMN_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                              row["COLUMN_LENGTH"] = reader.GetFieldValue<int>("COLUMN_SIZE");                              row["COLUMN_PRECISION"] = reader.GetFieldValue<int>("BUFFER_LENGTH");                              row["COLUMN_SCALE"] = reader.GetFieldValue<int>("DECIMAL_DIGITS");                              if (isNumeric(reader.GetFieldValue<string>("TYPE_NAME")))                              {                                  if (reader.GetFieldValue<int>("DECIMAL_DIGITS") != 0)                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME") +                                           "(" + reader.GetFieldValue<int>("BUFFER_LENGTH") + "'" + reader.GetFieldValue<int>("DECIMAL_DIGITS") + ")";                                  else                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME");                              }                              else                              {                                  if (isVarLenType(reader.GetFieldValue<string>("TYPE_NAME")) && reader.GetFieldValue<int>("COLUMN_SIZE") != 0)                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME") +                                           "(" + reader.GetFieldValue<int>("COLUMN_SIZE") + ")";                                  else                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME");                              }                              if (!reader.IsDBNull(reader.GetOrdinal("IS_NULLABLE")))                                  row["COLUMN_NULLABLE"] = reader.GetFieldValue<string>("IS_NULLABLE").Equals("YES");                              if (!reader.IsDBNull(reader.GetOrdinal("IS_AUTOINCREMENT")))                                  row["COLUMN_IDENTITY"] = reader.GetFieldValue<string>("IS_AUTOINCREMENT").Equals("YES");                              row["COLUMN_DEFAULT"] = reader.GetFieldValue<string>("COLUMN_DEF");    #if DEBUG                              System.Diagnostics.Trace.WriteLine("-> " + row["COLUMN_NAME"] + " " + row["COLUMN_TYPE"]);  #endif                              table.Rows.Add(row);                          }                          table.EndLoadData();                      }                  }              }              else if (collectionName == "Indexes")              {                  table.Columns.Add("INDEX_CATALOG"' typeof(string));                  table.Columns.Add("INDEX_SCHEMA"' typeof(string));                  table.Columns.Add("INDEX_TABLE"' typeof(string));                  table.Columns.Add("INDEX_NAME"' typeof(string));                  table.Columns.Add("INDEX_TYPE"' typeof(string));                  table.Columns.Add("INDEX_UNIQUE"' typeof(bool));                  table.Columns.Add("INDEX_PRIMARY"' typeof(bool));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetIndexInfo);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // unique                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // approximate                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        // to avoid to insert the same index more than once                      HashSet<string> unique = new HashSet<string>();                      if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;                                  if (!unique.Add(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;                                  DataRow row = table.NewRow();                                  row["INDEX_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEX_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEX_NAME"] = reader.GetFieldValue<string>("INDEX_NAME");                                  switch (reader.GetFieldValue<int>("TYPE"))                                  {                                      case 0:                                          row["INDEX_TYPE"] = "Primary";                                          break;                                      case 1:                                          row["INDEX_TYPE"] = "Unique";                                          break;                                      case 2:                                          row["INDEX_TYPE"] = "Secondary";                                          break;                                      case 3:                                          row["INDEX_TYPE"] = "Foreign Key";                                          break;                                  }                                  row["INDEX_UNIQUE"] = (reader.GetFieldValue<int>("NON_UNIQUE") == 0) ? true : false;                                  row["INDEX_PRIMARY"] = (reader.GetFieldValue<int>("TYPE") == 0) ? true : false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                        tmConn.InternalConnection.dataStream.startMessage(Protocol.GetPrimaryKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              // use INDEX_NAME' if present; if missing' the name of the index is in PK_NAME                              string indexName = "PK_NAME";                              foreach (string column in reader.columnNames)                              {                                  if (column == "INDEX_NAME")                                  {                                      indexName = "INDEX_NAME";                                      break;                                  }                              }                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>(indexName)))                                      continue;                                  if (!unique.Add(reader.GetFieldValue<string>(indexName)))                                      continue;                                  DataRow row = table.NewRow();                                  row["INDEX_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEX_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEX_NAME"] = reader.GetFieldValue<string>(indexName);                                  row["INDEX_TYPE"] = "Primary";                                  row["INDEX_UNIQUE"] = true;                                  row["INDEX_PRIMARY"] = true;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "IndexColumns")              {                  table.Columns.Add("INDEXCOLUMN_CATALOG"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_TABLE"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_INDEX"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_NAME"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_POSITION"' typeof(int));                  table.Columns.Add("INDEXCOLUMN_ISPRIMARY"' typeof(bool));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetIndexInfo);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // unique                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // approximate                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_SCHEM"] + "." + reader["TABLE_NAME"] + "=" + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["INDEXCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEXCOLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEXCOLUMN_INDEX"] = reader.GetFieldValue<string>("INDEX_NAME");                                  row["INDEXCOLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["INDEXCOLUMN_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                                  row["INDEXCOLUMN_ISPRIMARY"] = false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                        tmConn.InternalConnection.dataStream.startMessage(Protocol.GetPrimaryKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              // use INDEX_NAME' if present; if missing' the name of the index is in PK_NAME                              string indexName = "PK_NAME";                              foreach (string column in reader.columnNames)                              {                                  if (column == "INDEX_NAME")                                  {                                      indexName = "INDEX_NAME";                                      break;                                  }                              }                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>(indexName)))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_SCHEM"] + "." + reader["TABLE_NAME"] + " (Primary) =" + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["INDEXCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEXCOLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEXCOLUMN_INDEX"] = reader.GetFieldValue<string>(indexName);                                  row["INDEXCOLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["INDEXCOLUMN_POSITION"] = reader.GetFieldValue<int>("KEY_SEQ");                                  row["INDEXCOLUMN_ISPRIMARY"] = true;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ForeignKeys")              {                  table.Columns.Add("FOREIGNKEY_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEY_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEY_TABLE"' typeof(string));                  table.Columns.Add("FOREIGNKEY_NAME"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_TABLE"' typeof(string));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetImportedKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  string name = "[" + reader.GetFieldValue<string>("FKTABLE_SCHEM") + "]" +                                                   reader.GetFieldValue<string>("FKTABLE_NAME") + "." +                                                   reader.GetFieldValue<string>("FKCOLUMN_NAME") + "->" +                                                  "[" + reader.GetFieldValue<string>("PKTABLE_SCHEM") + "]" +                                                   reader.GetFieldValue<string>("PKTABLE_NAME") + "." +                                                   reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(name))                                      continue;                                  DataRow row = table.NewRow();                                  row["FOREIGNKEY_SCHEMA"] = reader.GetFieldValue<string>("FKTABLE_SCHEM");                                  row["FOREIGNKEY_TABLE"] = reader.GetFieldValue<string>("FKTABLE_NAME");                                  row["FOREIGNKEY_NAME"] = name;                                  row["FOREIGNKEY_OTHER_SCHEMA"] = reader.GetFieldValue<string>("PKTABLE_SCHEM");                                  row["FOREIGNKEY_OTHER_TABLE"] = reader.GetFieldValue<string>("PKTABLE_NAME");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ForeignKeyColumns")              {                  table.Columns.Add("FOREIGNKEYCOLUMN_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_TABLE"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_KEY"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_NAME"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_ORDINAL"' typeof(int));                  table.Columns.Add("FOREIGNKEYCOLUMN_OTHER_COLUMN_NAME"' typeof(string));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetImportedKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  string name = "[" + reader.GetFieldValue<string>("FKTABLE_SCHEM") + "]" +                                                  reader.GetFieldValue<string>("FKTABLE_NAME") + "." +                                                  reader.GetFieldValue<string>("FKCOLUMN_NAME") + "->" +                                                  "[" + reader.GetFieldValue<string>("PKTABLE_SCHEM") + "]" +                                                  reader.GetFieldValue<string>("PKTABLE_NAME") + "." +                                                  reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(name))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["FKTABLE_SCHEM"] + "." + reader["FKTABLE_NAME"] + "=" + reader["FKCOLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["FOREIGNKEYCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("FKTABLE_SCHEM");                                  row["FOREIGNKEYCOLUMN_TABLE"] = reader.GetFieldValue<string>("FKTABLE_NAME");                                  row["FOREIGNKEYCOLUMN_KEY"] = name;                                  row["FOREIGNKEYCOLUMN_NAME"] = reader.GetFieldValue<string>("FKCOLUMN_NAME");                                  row["FOREIGNKEYCOLUMN_ORDINAL"] = reader.GetFieldValue<int>("KEY_SEQ");                                  row["FOREIGNKEYCOLUMN_OTHER_COLUMN_NAME"] = reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "Procedures")               {                  table.Columns.Add("PROCEDURE_CATALOG"' typeof(string));                  table.Columns.Add("PROCEDURE_SCHEMA"' typeof(string));                  table.Columns.Add("PROCEDURE_NAME"' typeof(string));                  table.Columns.Add("IS_SYSTEM_PROCEDURE"' typeof(bool));                    if (tmConn.InternalConnection.protocolVersion >= Protocol.PROTOCOL_VERSION12)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetProcedures);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      for (int i = 1; i < 3; i++)                          if (restrictionValues != null && restrictionValues.Length > i)                              tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                          else                              tmConn.InternalConnection.dataStream.encodeNull();                        tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["PROCEDURE_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["PROCEDURE_SCHEMA"] = reader.GetFieldValue<string>("PROCEDURE_SCHEM");                                  row["PROCEDURE_NAME"] = reader.GetFieldValue<string>("PROCEDURE_NAME");                                  row["IS_SYSTEM_PROCEDURE"] = false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ProcedureParameters")              {                  table.Columns.Add("PROCEDURE_CATALOG"' typeof(string));                  table.Columns.Add("PROCEDURE_SCHEMA"' typeof(string));                  table.Columns.Add("PROCEDURE_NAME"' typeof(string));                  table.Columns.Add("PARAMETER_NAME"' typeof(string));                  table.Columns.Add("ORDINAL_POSITION"' typeof(int));                  table.Columns.Add("PARAMETER_DATA_TYPE"' typeof(int));                  table.Columns.Add("PARAMETER_TYPE_NAME"' typeof(string));                  table.Columns.Add("PARAMETER_SIZE"' typeof(int));                  table.Columns.Add("NUMERIC_PRECISION"' typeof(int));                  table.Columns.Add("NUMERIC_SCALE"' typeof(int));                  table.Columns.Add("PARAMETER_DIRECTION"' typeof(int));                  table.Columns.Add("IS_NULLABLE"' typeof(bool));                    if (tmConn.InternalConnection.protocolVersion >= Protocol.PROTOCOL_VERSION12)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetProcedureColumns);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      for (int i = 1; i < 4; i++)                          if (restrictionValues != null && restrictionValues.Length > i)                              tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                          else                              tmConn.InternalConnection.dataStream.encodeNull();                        tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["PROCEDURE_NAME"] + "' " + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["PROCEDURE_SCHEMA"] = reader.GetFieldValue<string>("PROCEDURE_SCHEM");                                  row["PROCEDURE_NAME"] = reader.GetFieldValue<string>("PROCEDURE_NAME");                                  row["PARAMETER_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["ORDINAL_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                                  row["PARAMETER_TYPE_NAME"] = reader.GetFieldValue<string>("TYPE_NAME");                                  row["PARAMETER_DATA_TYPE"] = reader.GetFieldValue<int>("DATA_TYPE");                                  row["PARAMETER_SIZE"] = reader.GetFieldValue<int>("LENGTH");                                  row["NUMERIC_PRECISION"] = reader.GetFieldValue<int>("PRECISION");                                  row["NUMERIC_SCALE"] = reader.GetFieldValue<int>("SCALE");                                  row["PARAMETER_DIRECTION"] = reader.GetFieldValue<int>("COLUMN_TYPE");                                  row["IS_NULLABLE"] = !reader.GetFieldValue<string>("IS_NULLABLE").Equals("NO");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The following statement contains a magic number: if (collectionName == DbMetaDataCollectionNames.DataSourceInformation)              {                  // see http://msdn.microsoft.com/en-us/library/ms254501.aspx                  table.Columns.Add("CompositeIdentifierSeparatorPattern"' typeof(string));                  table.Columns.Add("DataSourceProductName"' typeof(string));                  table.Columns.Add("DataSourceProductVersion"' typeof(string));                  table.Columns.Add("DataSourceProductVersionNormalized"' typeof(string));                  table.Columns.Add("DataSourceInternalProductVersion"' typeof(string));                  table.Columns.Add("GroupByBehavior"' typeof(GroupByBehavior));                  table.Columns.Add("IdentifierPattern"' typeof(string));                  table.Columns.Add("IdentifierCase"' typeof(IdentifierCase));                  table.Columns.Add("OrderByColumnsInSelect"' typeof(bool));                  table.Columns.Add("ParameterMarkerFormat"' typeof(string));                  table.Columns.Add("ParameterMarkerPattern"' typeof(string));                  table.Columns.Add("ParameterNameMaxLength"' typeof(int));                  table.Columns.Add("ParameterNamePattern"' typeof(string));                  table.Columns.Add("QuotedIdentifierPattern"' typeof(string));  // Regex                  table.Columns.Add("QuotedIdentifierCase"' typeof(int));                  table.Columns.Add("StatementSeparatorPattern"' typeof(string));                  table.Columns.Add("StringLiteralPattern"' typeof(string));  // Regex                  table.Columns.Add("SupportedJoinOperators"' typeof(SupportedJoinOperators));                    table.BeginLoadData();                  DataRow row = table.NewRow();                  int databaseMajorVersion = 0' databaseMinorVersion = 0;                  try                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetDatabaseMetaData);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      for (int item; (item = tmConn.InternalConnection.dataStream.getInt()) != Protocol.DbmbFini; )                      {                          switch (item)                          {                              case Protocol.DbmbProductName:                                  row["DataSourceProductName"] = tmConn.InternalConnection.dataStream.getString();                                  break;                                case Protocol.DbmbProductVersion:                                  row["DataSourceProductVersion"] = tmConn.InternalConnection.dataStream.getString();                                  break;                                case Protocol.DbmbDatabaseMinorVersion:                                  databaseMinorVersion = tmConn.InternalConnection.dataStream.getInt();                                  break;                                case Protocol.DbmbDatabaseMajorVersion:                                  databaseMajorVersion = tmConn.InternalConnection.dataStream.getInt();                                  break;                                case Protocol.DbmbDefaultTransactionIsolation:                                  int defaultTransactionIsolation = tmConn.InternalConnection.dataStream.getInt();                                  break;                                default:                                  tmConn.InternalConnection.dataStream.decode();                                  break;                          }                      }                  }                  catch (Exception)                  {                  }                    row["DataSourceInternalProductVersion"] = String.Format("{0:D3}.{1:D3}"' databaseMajorVersion' databaseMinorVersion);                  // The regular expression to match the composite separators in a composite identifier.                   // For example' "\." (for SQL Server) or "@|\." (for Oracle).                  // A composite identifier is typically what is used for a database object name'                   // for example: pubs.dbo.authors or pubs@dbo.authors.                  row["CompositeIdentifierSeparatorPattern"] = "\\.";                  // A normalized version for the data source' such that it can be compared with String.Compare().                   // The format of this is consistent for all versions of the provider to prevent version 10 from sorting between version 1 and version 2.                  //row["DataSourceProductVersionNormalized"] = ??                  // Specifies the relationship between the columns in a GROUP BY clause and the non-aggregated columns in the select list.                  row["GroupByBehavior"] = GroupByBehavior.Unknown;                  // A regular expression that matches an identifier and has a match value of the identifier. For example "[A-Za-z0-9_#$]".                  row["IdentifierPattern"] = "(^\\[\\p{Lo}\\p{Lu}\\p{Ll}_@#][\\p{Lo}\\p{Lu}\\p{Ll}\\p{Nd}@$#_]*$)|(^\"[^\"\\0]|\"\"+\"$)";                  // Indicates whether non-quoted identifiers are treated as case sensitive or not.                  row["IdentifierCase"] = IdentifierCase.Insensitive;                  // Specifies whether columns in an ORDER BY clause must be in the select list.                   // A value of true indicates that they are required to be in the select list'                   // a value of false indicates that they are not required to be in the select list.                  row["OrderByColumnsInSelect"] = false;                  // For data sources that do not expect named parameters and expect the use of the ‘?’ character' the format string                  // can be specified as simply '?'' which would ignore the parameter name.                  row["ParameterMarkerFormat"] = "?";                  // if the data source doesn't support named parameters' this would simply be "?".                  row["ParameterMarkerPattern"] = "?";                  // If the data source does not support named parameters' this property returns zero.                  row["ParameterNameMaxLength"] = 0;                  // A regular expression that matches the valid parameter names                  row["ParameterNamePattern"] = "";                  // A regular expression that matches a quoted identifier and has a match value of the identifier itself without the quotes.                   // For example' if the data source used double-quotes to identify quoted identifiers' this would be: "(([^\"]|\"\")*)".                  row["QuotedIdentifierPattern"] = "\"([^\"]*)\"";                  // Indicates whether quoted identifiers are treated as case sensitive or not.                  row["QuotedIdentifierCase"] = IdentifierCase.Sensitive;                  // A regular expression that matches the statement separator.                  row["StatementSeparatorPattern"] = ";";                  // A regular expression that matches a string literal and has a match value of the literal itself.                   // For example' if the data source used single-quotes to identify strings' this would be: "('([^']|'')*')"'                  row["StringLiteralPattern"] = "'([^']*)'";                  // Specifies what types of SQL join statements are supported by the data source.                  row["SupportedJoinOperators"] = SupportedJoinOperators.None;                  table.Rows.Add(row);                  table.EndLoadData();              }              else if (collectionName == DbMetaDataCollectionNames.ReservedWords)              {                  table.Columns.Add("ReservedWord"' typeof(string));                  table.Columns.Add("MaximumVersion"' typeof(string));                  table.Columns.Add("MinimumVersion"' typeof(string));                    string[] words = { "select"' "Add field"' "Drop field"' "Alter table"' "Alter field"'                                      "Alter user"' "And"' "Or"' "Not"' "Create Index"' "Upgrade"' "Unique"'                                      "Table key"' "Table unique key"' "Primary Key"' "Create Table"'                                      "Upgrade Table"' "Rename Table"' "Create View"' "Upgrade View"'                                      "Drop View"' "Create Schema"' "Drop Schema"' "Integer"' "Smallint"'                                      "Bigint"' "Tinyint"' "float"' "double"' "Blob"' "bytes"' "boolean"'                                      "binary"' "varbinary"' "string"' "char"' "text"' "date"' "timestamp"'                                      "time"' "varchar"' "numeric"' "Decimal Number"' "Enum"' "Delete"' "Repair"'                                      "Field"' "Not Null"' "Default Value"' "searchable"' "not searchable"'                                      "collation"' "character_set"' "Foreign Key"' "Identifier"' "record number"'                                      "Insert"' "Replace"' "Name"' "Number"' "Order"' "Descending"' "limit"'                                      "Quoted String"' "Select Clause"' "Distinct"' "Gtr"' "Geq"' "Eql"'                                      "Leq"' "Lss"' "Neq"' "in list"' "in select"' "exists"' "Between"' "Like"'                                      "starts with"' "Containing"' "Matching"' "Regular expression"' "Null"'                                      "True"' "False"' "Execute"' "Parameter"' "Count"' "sum"' "min"' "max"'                                      "avg"' "Drop Index"' "Drop primary key"' "Drop foreign key"' "Drop Table"'                                      "If Exists"' "Describe"' "Statement"' "for_select"' "for_insert"' "while"'                                      "if then else"' "variable"' "declaration"' "throw"' "assignment"'                                      "Start transaction"' "read only"' "read write"' "read committed"' "write committed"'                                      "read uncommitted"' "repeatableread"' "serializable"' "Commit"' "Rollback"'                                      "Savepoint"' "Rollack Savepoint"' "Release Savepoint"' "Table"' "Derived Table"'                                      "Assign"' "Update"' "list"' "Constant"' "Function"' "Grant"' "Grant role"' "Alter"'                                      "Read"' "Identity"' "Check"' "Constraint"' "value constraint"' "auto increment"'                                      "generated"' "always"' "Domain"' "is null"' "is active_role"' "start with"' "reindex"'                                      "cursor"' "alias"' "push_namespace"' "pop_namespace"' "set_namespace"' "coalesce"'                                      "nod_nullif"' "case"' "case_search"' "add"' "subtract"' "multiply"' "divide"' "modulus"'                                      "negate"' "plus"' "cast"' "concatenation"' "create user"' "drop user"' "create role"'                                      "upgrade role"' "drop role"' "revoke"' "revoke role"' "assume"' "revert"' "negate"'                                      "priv insert"' "priv delete"' "priv execute"' "priv select"' "priv update"' "priv grant"'                                      "priv all"' "characters"' "octets"' "role"' "view"' "procedure"' "user"' "zone"' "admin"'                                      "default role"' "create sequence"' "upgrade sequence"' "drop sequence"' "next value"'                                      "create trigger"' "upgrade trigger"' "alter trigger"' "drop trigger"' "create procedure"'                                      "upgrade procedure"' "alter procedure"' "drop procedure"' "pre-insert"' "post-insert"'                                      "pre-update"' "post-update"' "pre-delete"' "post-delete"' "pre-commit"' "post-commit"'                                      "active"' "inactive"' "position"' "select-expr"' "create filterset"' "upgrade filterset"'                                      "drop filterset"' "enable filterset"' "disable filterset"' "table filter"' "left outer"'                                      "right outer"' "full outer"' "inner"' "join"' "join_term"' "trigger class"' "enable trigger class"'                                      "disable trigger class"' "create zone"' "upgrade zone"' "drop zone"' "range"' "ip address"'                                      "node_name"' "wildcard"' "create domain"' "upgrade domain"' "alter domain"' "upgrade schema"'                                      "delete cascade"' "index segment"' "for update"' "write committed"' "read committed"'                                       "consistent read"' "set dialect"' "set names"' "restrict"' "cascade"' "characters"' "octets"'                                      "create event"' "collate"' "truncate"' "restart"' "nameless constraint"' "drop constraint"'                                      "drop unique constraint"' "drop domain"' "with check option"' "not real"' "lower"' "upper"'                                      "substr"' "substring index"' "charlength"' "default keyword"' "sqrt"' "power"' "Scientific Notation Number"'                                      "Explain"' "msleep"' "KillStatement"' "now" };                  table.BeginLoadData();                  foreach (string keyword in words)                  {                      DataRow row = table.NewRow();                      row["ReservedWord"] = keyword;                      table.Rows.Add(row);                  }                  table.EndLoadData();                }              else if (collectionName == DbMetaDataCollectionNames.DataTypes)              {                  table.Columns.Add("TypeName"' typeof(string));  // The provider-specific data type name.                  table.Columns.Add("ProviderDbType"' typeof(int)); // The provider-specific type value that should be used when specifying                   //a parameter's type. For example' SqlDbType.Money or OracleType.Blob.                  table.Columns.Add("ColumnSize"' typeof(long));                  table.Columns.Add("CreateFormat"' typeof(string));                  table.Columns.Add("CreateParameters"' typeof(string));                  table.Columns.Add("DataType"' typeof(string));  // The name of the .NET Framework type of the data type.                  table.Columns.Add("IsAutoincrementable"' typeof(bool));                  table.Columns.Add("IsBestMatch"' typeof(bool));                  table.Columns.Add("IsCaseSensitive"' typeof(bool));                  table.Columns.Add("IsFixedLength"' typeof(bool));                  table.Columns.Add("IsFixedPrecisionScale"' typeof(bool));                  table.Columns.Add("IsLong"' typeof(bool));                  table.Columns.Add("IsNullable"' typeof(bool));                  table.Columns.Add("IsSearchable"' typeof(bool));                  table.Columns.Add("IsSearchableWithLike"' typeof(bool));                  table.Columns.Add("IsUnsigned"' typeof(bool));                  table.Columns.Add("MaximumScale"' typeof(short));                  table.Columns.Add("MinimumScale"' typeof(short));                  table.Columns.Add("IsConcurrencyType"' typeof(bool));                  table.Columns.Add("IsLiteralsSupported"' typeof(bool));                  table.Columns.Add("LiteralPrefix"' typeof(string));                  table.Columns.Add("LiteralSuffix"' typeof(string));                  table.Columns.Add("NativeDataType"' typeof(string));    // NativeDataType is an OLE DB specific column for exposing the OLE DB type of the data type .                    table.ReadXml(XmlReader.Create(typeof(NuoDbConnectionInternal).Assembly.GetManifestResourceStream("NuoDb.Data.Client.DataTypes.xml")));              }              else if (collectionName == "Tables")              {                  table.Columns.Add("TABLE_CATALOG"' typeof(string));                  table.Columns.Add("TABLE_SCHEMA"' typeof(string));                  table.Columns.Add("TABLE_NAME"' typeof(string));                  table.Columns.Add("TABLE_TYPE"' typeof(string));                  table.Columns.Add("REMARKS"' typeof(string));                  table.Columns.Add("VIEW_DEF"' typeof(string));                    tmConn.InternalConnection.dataStream.startMessage(Protocol.GetTables);                  tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                  for (int i = 1; i < 3; i++)                      if (restrictionValues != null && restrictionValues.Length > i)                          tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                      else                          tmConn.InternalConnection.dataStream.encodeNull();                  if (restrictionValues == null || restrictionValues.Length < 4 || restrictionValues[3] == null)                      tmConn.InternalConnection.dataStream.encodeInt(0);                  else                  {                      tmConn.InternalConnection.dataStream.encodeInt(1);                      tmConn.InternalConnection.dataStream.encodeString(restrictionValues[3]);                  }                    tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                  int handle = tmConn.InternalConnection.dataStream.getInt();                    if (handle != -1)                  {                      using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                      {                          table.BeginLoadData();                          string view_def_label="";                          try                           {                               reader.GetOrdinal("VIEW_DEF");                              view_def_label = "VIEW_DEF";                          }                          catch(Exception) {}                          try                           {                               reader.GetOrdinal("VIEWDEFINITION");                              view_def_label = "VIEWDEFINITION";                          }                          catch (Exception) { }                          while (reader.Read())                          {  #if DEBUG                          System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_NAME"] + "' " + reader["TABLE_TYPE"]);  #endif                              DataRow row = table.NewRow();                              row["TABLE_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                              row["TABLE_NAME"] = reader.GetFieldValue<string>("TABLE_NAME");                              row["TABLE_TYPE"] = reader.GetFieldValue<string>("TABLE_TYPE");                              row["REMARKS"] = reader.GetFieldValue<string>("REMARKS");                              if (view_def_label.Length != 0)                              {                                  row["VIEW_DEF"] = reader.GetFieldValue<string>(view_def_label);                              }                              table.Rows.Add(row);                          }                          table.EndLoadData();                      }                  }              }              else if (collectionName == "Columns")              {                  table.Columns.Add("COLUMN_CATALOG"' typeof(string));                  table.Columns.Add("COLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("COLUMN_TABLE"' typeof(string));                  table.Columns.Add("COLUMN_NAME"' typeof(string));                  table.Columns.Add("COLUMN_POSITION"' typeof(int));                  table.Columns.Add("COLUMN_TYPE"' typeof(string));                  table.Columns.Add("COLUMN_LENGTH"' typeof(int));                  table.Columns.Add("COLUMN_PRECISION"' typeof(int));                  table.Columns.Add("COLUMN_NULLABLE"' typeof(bool));                  table.Columns.Add("COLUMN_IDENTITY"' typeof(bool));                  table.Columns.Add("COLUMN_DEFAULT"' typeof(string));                  table.Columns.Add("COLUMN_SCALE"' typeof(int));                    tmConn.InternalConnection.dataStream.startMessage(Protocol.GetColumns);                  tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                  for (int i = 1; i < 4; i++)                      if (restrictionValues != null && restrictionValues.Length > i)                          tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                      else                          tmConn.InternalConnection.dataStream.encodeNull();                    tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                  int handle = tmConn.InternalConnection.dataStream.getInt();                    if (handle != -1)                  {                      using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                      {                          table.BeginLoadData();                          while (reader.Read())                          {                              DataRow row = table.NewRow();                              row["COLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                              row["COLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                              row["COLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                              row["COLUMN_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                              row["COLUMN_LENGTH"] = reader.GetFieldValue<int>("COLUMN_SIZE");                              row["COLUMN_PRECISION"] = reader.GetFieldValue<int>("BUFFER_LENGTH");                              row["COLUMN_SCALE"] = reader.GetFieldValue<int>("DECIMAL_DIGITS");                              if (isNumeric(reader.GetFieldValue<string>("TYPE_NAME")))                              {                                  if (reader.GetFieldValue<int>("DECIMAL_DIGITS") != 0)                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME") +                                           "(" + reader.GetFieldValue<int>("BUFFER_LENGTH") + "'" + reader.GetFieldValue<int>("DECIMAL_DIGITS") + ")";                                  else                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME");                              }                              else                              {                                  if (isVarLenType(reader.GetFieldValue<string>("TYPE_NAME")) && reader.GetFieldValue<int>("COLUMN_SIZE") != 0)                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME") +                                           "(" + reader.GetFieldValue<int>("COLUMN_SIZE") + ")";                                  else                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME");                              }                              if (!reader.IsDBNull(reader.GetOrdinal("IS_NULLABLE")))                                  row["COLUMN_NULLABLE"] = reader.GetFieldValue<string>("IS_NULLABLE").Equals("YES");                              if (!reader.IsDBNull(reader.GetOrdinal("IS_AUTOINCREMENT")))                                  row["COLUMN_IDENTITY"] = reader.GetFieldValue<string>("IS_AUTOINCREMENT").Equals("YES");                              row["COLUMN_DEFAULT"] = reader.GetFieldValue<string>("COLUMN_DEF");    #if DEBUG                              System.Diagnostics.Trace.WriteLine("-> " + row["COLUMN_NAME"] + " " + row["COLUMN_TYPE"]);  #endif                              table.Rows.Add(row);                          }                          table.EndLoadData();                      }                  }              }              else if (collectionName == "Indexes")              {                  table.Columns.Add("INDEX_CATALOG"' typeof(string));                  table.Columns.Add("INDEX_SCHEMA"' typeof(string));                  table.Columns.Add("INDEX_TABLE"' typeof(string));                  table.Columns.Add("INDEX_NAME"' typeof(string));                  table.Columns.Add("INDEX_TYPE"' typeof(string));                  table.Columns.Add("INDEX_UNIQUE"' typeof(bool));                  table.Columns.Add("INDEX_PRIMARY"' typeof(bool));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetIndexInfo);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // unique                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // approximate                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        // to avoid to insert the same index more than once                      HashSet<string> unique = new HashSet<string>();                      if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;                                  if (!unique.Add(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;                                  DataRow row = table.NewRow();                                  row["INDEX_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEX_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEX_NAME"] = reader.GetFieldValue<string>("INDEX_NAME");                                  switch (reader.GetFieldValue<int>("TYPE"))                                  {                                      case 0:                                          row["INDEX_TYPE"] = "Primary";                                          break;                                      case 1:                                          row["INDEX_TYPE"] = "Unique";                                          break;                                      case 2:                                          row["INDEX_TYPE"] = "Secondary";                                          break;                                      case 3:                                          row["INDEX_TYPE"] = "Foreign Key";                                          break;                                  }                                  row["INDEX_UNIQUE"] = (reader.GetFieldValue<int>("NON_UNIQUE") == 0) ? true : false;                                  row["INDEX_PRIMARY"] = (reader.GetFieldValue<int>("TYPE") == 0) ? true : false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                        tmConn.InternalConnection.dataStream.startMessage(Protocol.GetPrimaryKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              // use INDEX_NAME' if present; if missing' the name of the index is in PK_NAME                              string indexName = "PK_NAME";                              foreach (string column in reader.columnNames)                              {                                  if (column == "INDEX_NAME")                                  {                                      indexName = "INDEX_NAME";                                      break;                                  }                              }                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>(indexName)))                                      continue;                                  if (!unique.Add(reader.GetFieldValue<string>(indexName)))                                      continue;                                  DataRow row = table.NewRow();                                  row["INDEX_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEX_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEX_NAME"] = reader.GetFieldValue<string>(indexName);                                  row["INDEX_TYPE"] = "Primary";                                  row["INDEX_UNIQUE"] = true;                                  row["INDEX_PRIMARY"] = true;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "IndexColumns")              {                  table.Columns.Add("INDEXCOLUMN_CATALOG"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_TABLE"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_INDEX"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_NAME"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_POSITION"' typeof(int));                  table.Columns.Add("INDEXCOLUMN_ISPRIMARY"' typeof(bool));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetIndexInfo);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // unique                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // approximate                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_SCHEM"] + "." + reader["TABLE_NAME"] + "=" + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["INDEXCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEXCOLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEXCOLUMN_INDEX"] = reader.GetFieldValue<string>("INDEX_NAME");                                  row["INDEXCOLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["INDEXCOLUMN_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                                  row["INDEXCOLUMN_ISPRIMARY"] = false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                        tmConn.InternalConnection.dataStream.startMessage(Protocol.GetPrimaryKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              // use INDEX_NAME' if present; if missing' the name of the index is in PK_NAME                              string indexName = "PK_NAME";                              foreach (string column in reader.columnNames)                              {                                  if (column == "INDEX_NAME")                                  {                                      indexName = "INDEX_NAME";                                      break;                                  }                              }                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>(indexName)))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_SCHEM"] + "." + reader["TABLE_NAME"] + " (Primary) =" + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["INDEXCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEXCOLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEXCOLUMN_INDEX"] = reader.GetFieldValue<string>(indexName);                                  row["INDEXCOLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["INDEXCOLUMN_POSITION"] = reader.GetFieldValue<int>("KEY_SEQ");                                  row["INDEXCOLUMN_ISPRIMARY"] = true;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ForeignKeys")              {                  table.Columns.Add("FOREIGNKEY_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEY_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEY_TABLE"' typeof(string));                  table.Columns.Add("FOREIGNKEY_NAME"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_TABLE"' typeof(string));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetImportedKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  string name = "[" + reader.GetFieldValue<string>("FKTABLE_SCHEM") + "]" +                                                   reader.GetFieldValue<string>("FKTABLE_NAME") + "." +                                                   reader.GetFieldValue<string>("FKCOLUMN_NAME") + "->" +                                                  "[" + reader.GetFieldValue<string>("PKTABLE_SCHEM") + "]" +                                                   reader.GetFieldValue<string>("PKTABLE_NAME") + "." +                                                   reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(name))                                      continue;                                  DataRow row = table.NewRow();                                  row["FOREIGNKEY_SCHEMA"] = reader.GetFieldValue<string>("FKTABLE_SCHEM");                                  row["FOREIGNKEY_TABLE"] = reader.GetFieldValue<string>("FKTABLE_NAME");                                  row["FOREIGNKEY_NAME"] = name;                                  row["FOREIGNKEY_OTHER_SCHEMA"] = reader.GetFieldValue<string>("PKTABLE_SCHEM");                                  row["FOREIGNKEY_OTHER_TABLE"] = reader.GetFieldValue<string>("PKTABLE_NAME");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ForeignKeyColumns")              {                  table.Columns.Add("FOREIGNKEYCOLUMN_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_TABLE"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_KEY"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_NAME"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_ORDINAL"' typeof(int));                  table.Columns.Add("FOREIGNKEYCOLUMN_OTHER_COLUMN_NAME"' typeof(string));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetImportedKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  string name = "[" + reader.GetFieldValue<string>("FKTABLE_SCHEM") + "]" +                                                  reader.GetFieldValue<string>("FKTABLE_NAME") + "." +                                                  reader.GetFieldValue<string>("FKCOLUMN_NAME") + "->" +                                                  "[" + reader.GetFieldValue<string>("PKTABLE_SCHEM") + "]" +                                                  reader.GetFieldValue<string>("PKTABLE_NAME") + "." +                                                  reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(name))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["FKTABLE_SCHEM"] + "." + reader["FKTABLE_NAME"] + "=" + reader["FKCOLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["FOREIGNKEYCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("FKTABLE_SCHEM");                                  row["FOREIGNKEYCOLUMN_TABLE"] = reader.GetFieldValue<string>("FKTABLE_NAME");                                  row["FOREIGNKEYCOLUMN_KEY"] = name;                                  row["FOREIGNKEYCOLUMN_NAME"] = reader.GetFieldValue<string>("FKCOLUMN_NAME");                                  row["FOREIGNKEYCOLUMN_ORDINAL"] = reader.GetFieldValue<int>("KEY_SEQ");                                  row["FOREIGNKEYCOLUMN_OTHER_COLUMN_NAME"] = reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "Procedures")               {                  table.Columns.Add("PROCEDURE_CATALOG"' typeof(string));                  table.Columns.Add("PROCEDURE_SCHEMA"' typeof(string));                  table.Columns.Add("PROCEDURE_NAME"' typeof(string));                  table.Columns.Add("IS_SYSTEM_PROCEDURE"' typeof(bool));                    if (tmConn.InternalConnection.protocolVersion >= Protocol.PROTOCOL_VERSION12)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetProcedures);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      for (int i = 1; i < 3; i++)                          if (restrictionValues != null && restrictionValues.Length > i)                              tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                          else                              tmConn.InternalConnection.dataStream.encodeNull();                        tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["PROCEDURE_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["PROCEDURE_SCHEMA"] = reader.GetFieldValue<string>("PROCEDURE_SCHEM");                                  row["PROCEDURE_NAME"] = reader.GetFieldValue<string>("PROCEDURE_NAME");                                  row["IS_SYSTEM_PROCEDURE"] = false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ProcedureParameters")              {                  table.Columns.Add("PROCEDURE_CATALOG"' typeof(string));                  table.Columns.Add("PROCEDURE_SCHEMA"' typeof(string));                  table.Columns.Add("PROCEDURE_NAME"' typeof(string));                  table.Columns.Add("PARAMETER_NAME"' typeof(string));                  table.Columns.Add("ORDINAL_POSITION"' typeof(int));                  table.Columns.Add("PARAMETER_DATA_TYPE"' typeof(int));                  table.Columns.Add("PARAMETER_TYPE_NAME"' typeof(string));                  table.Columns.Add("PARAMETER_SIZE"' typeof(int));                  table.Columns.Add("NUMERIC_PRECISION"' typeof(int));                  table.Columns.Add("NUMERIC_SCALE"' typeof(int));                  table.Columns.Add("PARAMETER_DIRECTION"' typeof(int));                  table.Columns.Add("IS_NULLABLE"' typeof(bool));                    if (tmConn.InternalConnection.protocolVersion >= Protocol.PROTOCOL_VERSION12)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetProcedureColumns);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      for (int i = 1; i < 4; i++)                          if (restrictionValues != null && restrictionValues.Length > i)                              tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                          else                              tmConn.InternalConnection.dataStream.encodeNull();                        tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["PROCEDURE_NAME"] + "' " + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["PROCEDURE_SCHEMA"] = reader.GetFieldValue<string>("PROCEDURE_SCHEM");                                  row["PROCEDURE_NAME"] = reader.GetFieldValue<string>("PROCEDURE_NAME");                                  row["PARAMETER_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["ORDINAL_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                                  row["PARAMETER_TYPE_NAME"] = reader.GetFieldValue<string>("TYPE_NAME");                                  row["PARAMETER_DATA_TYPE"] = reader.GetFieldValue<int>("DATA_TYPE");                                  row["PARAMETER_SIZE"] = reader.GetFieldValue<int>("LENGTH");                                  row["NUMERIC_PRECISION"] = reader.GetFieldValue<int>("PRECISION");                                  row["NUMERIC_SCALE"] = reader.GetFieldValue<int>("SCALE");                                  row["PARAMETER_DIRECTION"] = reader.GetFieldValue<int>("COLUMN_TYPE");                                  row["IS_NULLABLE"] = !reader.GetFieldValue<string>("IS_NULLABLE").Equals("NO");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The following statement contains a magic number: if (collectionName == DbMetaDataCollectionNames.DataSourceInformation)              {                  // see http://msdn.microsoft.com/en-us/library/ms254501.aspx                  table.Columns.Add("CompositeIdentifierSeparatorPattern"' typeof(string));                  table.Columns.Add("DataSourceProductName"' typeof(string));                  table.Columns.Add("DataSourceProductVersion"' typeof(string));                  table.Columns.Add("DataSourceProductVersionNormalized"' typeof(string));                  table.Columns.Add("DataSourceInternalProductVersion"' typeof(string));                  table.Columns.Add("GroupByBehavior"' typeof(GroupByBehavior));                  table.Columns.Add("IdentifierPattern"' typeof(string));                  table.Columns.Add("IdentifierCase"' typeof(IdentifierCase));                  table.Columns.Add("OrderByColumnsInSelect"' typeof(bool));                  table.Columns.Add("ParameterMarkerFormat"' typeof(string));                  table.Columns.Add("ParameterMarkerPattern"' typeof(string));                  table.Columns.Add("ParameterNameMaxLength"' typeof(int));                  table.Columns.Add("ParameterNamePattern"' typeof(string));                  table.Columns.Add("QuotedIdentifierPattern"' typeof(string));  // Regex                  table.Columns.Add("QuotedIdentifierCase"' typeof(int));                  table.Columns.Add("StatementSeparatorPattern"' typeof(string));                  table.Columns.Add("StringLiteralPattern"' typeof(string));  // Regex                  table.Columns.Add("SupportedJoinOperators"' typeof(SupportedJoinOperators));                    table.BeginLoadData();                  DataRow row = table.NewRow();                  int databaseMajorVersion = 0' databaseMinorVersion = 0;                  try                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetDatabaseMetaData);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      for (int item; (item = tmConn.InternalConnection.dataStream.getInt()) != Protocol.DbmbFini; )                      {                          switch (item)                          {                              case Protocol.DbmbProductName:                                  row["DataSourceProductName"] = tmConn.InternalConnection.dataStream.getString();                                  break;                                case Protocol.DbmbProductVersion:                                  row["DataSourceProductVersion"] = tmConn.InternalConnection.dataStream.getString();                                  break;                                case Protocol.DbmbDatabaseMinorVersion:                                  databaseMinorVersion = tmConn.InternalConnection.dataStream.getInt();                                  break;                                case Protocol.DbmbDatabaseMajorVersion:                                  databaseMajorVersion = tmConn.InternalConnection.dataStream.getInt();                                  break;                                case Protocol.DbmbDefaultTransactionIsolation:                                  int defaultTransactionIsolation = tmConn.InternalConnection.dataStream.getInt();                                  break;                                default:                                  tmConn.InternalConnection.dataStream.decode();                                  break;                          }                      }                  }                  catch (Exception)                  {                  }                    row["DataSourceInternalProductVersion"] = String.Format("{0:D3}.{1:D3}"' databaseMajorVersion' databaseMinorVersion);                  // The regular expression to match the composite separators in a composite identifier.                   // For example' "\." (for SQL Server) or "@|\." (for Oracle).                  // A composite identifier is typically what is used for a database object name'                   // for example: pubs.dbo.authors or pubs@dbo.authors.                  row["CompositeIdentifierSeparatorPattern"] = "\\.";                  // A normalized version for the data source' such that it can be compared with String.Compare().                   // The format of this is consistent for all versions of the provider to prevent version 10 from sorting between version 1 and version 2.                  //row["DataSourceProductVersionNormalized"] = ??                  // Specifies the relationship between the columns in a GROUP BY clause and the non-aggregated columns in the select list.                  row["GroupByBehavior"] = GroupByBehavior.Unknown;                  // A regular expression that matches an identifier and has a match value of the identifier. For example "[A-Za-z0-9_#$]".                  row["IdentifierPattern"] = "(^\\[\\p{Lo}\\p{Lu}\\p{Ll}_@#][\\p{Lo}\\p{Lu}\\p{Ll}\\p{Nd}@$#_]*$)|(^\"[^\"\\0]|\"\"+\"$)";                  // Indicates whether non-quoted identifiers are treated as case sensitive or not.                  row["IdentifierCase"] = IdentifierCase.Insensitive;                  // Specifies whether columns in an ORDER BY clause must be in the select list.                   // A value of true indicates that they are required to be in the select list'                   // a value of false indicates that they are not required to be in the select list.                  row["OrderByColumnsInSelect"] = false;                  // For data sources that do not expect named parameters and expect the use of the ‘?’ character' the format string                  // can be specified as simply '?'' which would ignore the parameter name.                  row["ParameterMarkerFormat"] = "?";                  // if the data source doesn't support named parameters' this would simply be "?".                  row["ParameterMarkerPattern"] = "?";                  // If the data source does not support named parameters' this property returns zero.                  row["ParameterNameMaxLength"] = 0;                  // A regular expression that matches the valid parameter names                  row["ParameterNamePattern"] = "";                  // A regular expression that matches a quoted identifier and has a match value of the identifier itself without the quotes.                   // For example' if the data source used double-quotes to identify quoted identifiers' this would be: "(([^\"]|\"\")*)".                  row["QuotedIdentifierPattern"] = "\"([^\"]*)\"";                  // Indicates whether quoted identifiers are treated as case sensitive or not.                  row["QuotedIdentifierCase"] = IdentifierCase.Sensitive;                  // A regular expression that matches the statement separator.                  row["StatementSeparatorPattern"] = ";";                  // A regular expression that matches a string literal and has a match value of the literal itself.                   // For example' if the data source used single-quotes to identify strings' this would be: "('([^']|'')*')"'                  row["StringLiteralPattern"] = "'([^']*)'";                  // Specifies what types of SQL join statements are supported by the data source.                  row["SupportedJoinOperators"] = SupportedJoinOperators.None;                  table.Rows.Add(row);                  table.EndLoadData();              }              else if (collectionName == DbMetaDataCollectionNames.ReservedWords)              {                  table.Columns.Add("ReservedWord"' typeof(string));                  table.Columns.Add("MaximumVersion"' typeof(string));                  table.Columns.Add("MinimumVersion"' typeof(string));                    string[] words = { "select"' "Add field"' "Drop field"' "Alter table"' "Alter field"'                                      "Alter user"' "And"' "Or"' "Not"' "Create Index"' "Upgrade"' "Unique"'                                      "Table key"' "Table unique key"' "Primary Key"' "Create Table"'                                      "Upgrade Table"' "Rename Table"' "Create View"' "Upgrade View"'                                      "Drop View"' "Create Schema"' "Drop Schema"' "Integer"' "Smallint"'                                      "Bigint"' "Tinyint"' "float"' "double"' "Blob"' "bytes"' "boolean"'                                      "binary"' "varbinary"' "string"' "char"' "text"' "date"' "timestamp"'                                      "time"' "varchar"' "numeric"' "Decimal Number"' "Enum"' "Delete"' "Repair"'                                      "Field"' "Not Null"' "Default Value"' "searchable"' "not searchable"'                                      "collation"' "character_set"' "Foreign Key"' "Identifier"' "record number"'                                      "Insert"' "Replace"' "Name"' "Number"' "Order"' "Descending"' "limit"'                                      "Quoted String"' "Select Clause"' "Distinct"' "Gtr"' "Geq"' "Eql"'                                      "Leq"' "Lss"' "Neq"' "in list"' "in select"' "exists"' "Between"' "Like"'                                      "starts with"' "Containing"' "Matching"' "Regular expression"' "Null"'                                      "True"' "False"' "Execute"' "Parameter"' "Count"' "sum"' "min"' "max"'                                      "avg"' "Drop Index"' "Drop primary key"' "Drop foreign key"' "Drop Table"'                                      "If Exists"' "Describe"' "Statement"' "for_select"' "for_insert"' "while"'                                      "if then else"' "variable"' "declaration"' "throw"' "assignment"'                                      "Start transaction"' "read only"' "read write"' "read committed"' "write committed"'                                      "read uncommitted"' "repeatableread"' "serializable"' "Commit"' "Rollback"'                                      "Savepoint"' "Rollack Savepoint"' "Release Savepoint"' "Table"' "Derived Table"'                                      "Assign"' "Update"' "list"' "Constant"' "Function"' "Grant"' "Grant role"' "Alter"'                                      "Read"' "Identity"' "Check"' "Constraint"' "value constraint"' "auto increment"'                                      "generated"' "always"' "Domain"' "is null"' "is active_role"' "start with"' "reindex"'                                      "cursor"' "alias"' "push_namespace"' "pop_namespace"' "set_namespace"' "coalesce"'                                      "nod_nullif"' "case"' "case_search"' "add"' "subtract"' "multiply"' "divide"' "modulus"'                                      "negate"' "plus"' "cast"' "concatenation"' "create user"' "drop user"' "create role"'                                      "upgrade role"' "drop role"' "revoke"' "revoke role"' "assume"' "revert"' "negate"'                                      "priv insert"' "priv delete"' "priv execute"' "priv select"' "priv update"' "priv grant"'                                      "priv all"' "characters"' "octets"' "role"' "view"' "procedure"' "user"' "zone"' "admin"'                                      "default role"' "create sequence"' "upgrade sequence"' "drop sequence"' "next value"'                                      "create trigger"' "upgrade trigger"' "alter trigger"' "drop trigger"' "create procedure"'                                      "upgrade procedure"' "alter procedure"' "drop procedure"' "pre-insert"' "post-insert"'                                      "pre-update"' "post-update"' "pre-delete"' "post-delete"' "pre-commit"' "post-commit"'                                      "active"' "inactive"' "position"' "select-expr"' "create filterset"' "upgrade filterset"'                                      "drop filterset"' "enable filterset"' "disable filterset"' "table filter"' "left outer"'                                      "right outer"' "full outer"' "inner"' "join"' "join_term"' "trigger class"' "enable trigger class"'                                      "disable trigger class"' "create zone"' "upgrade zone"' "drop zone"' "range"' "ip address"'                                      "node_name"' "wildcard"' "create domain"' "upgrade domain"' "alter domain"' "upgrade schema"'                                      "delete cascade"' "index segment"' "for update"' "write committed"' "read committed"'                                       "consistent read"' "set dialect"' "set names"' "restrict"' "cascade"' "characters"' "octets"'                                      "create event"' "collate"' "truncate"' "restart"' "nameless constraint"' "drop constraint"'                                      "drop unique constraint"' "drop domain"' "with check option"' "not real"' "lower"' "upper"'                                      "substr"' "substring index"' "charlength"' "default keyword"' "sqrt"' "power"' "Scientific Notation Number"'                                      "Explain"' "msleep"' "KillStatement"' "now" };                  table.BeginLoadData();                  foreach (string keyword in words)                  {                      DataRow row = table.NewRow();                      row["ReservedWord"] = keyword;                      table.Rows.Add(row);                  }                  table.EndLoadData();                }              else if (collectionName == DbMetaDataCollectionNames.DataTypes)              {                  table.Columns.Add("TypeName"' typeof(string));  // The provider-specific data type name.                  table.Columns.Add("ProviderDbType"' typeof(int)); // The provider-specific type value that should be used when specifying                   //a parameter's type. For example' SqlDbType.Money or OracleType.Blob.                  table.Columns.Add("ColumnSize"' typeof(long));                  table.Columns.Add("CreateFormat"' typeof(string));                  table.Columns.Add("CreateParameters"' typeof(string));                  table.Columns.Add("DataType"' typeof(string));  // The name of the .NET Framework type of the data type.                  table.Columns.Add("IsAutoincrementable"' typeof(bool));                  table.Columns.Add("IsBestMatch"' typeof(bool));                  table.Columns.Add("IsCaseSensitive"' typeof(bool));                  table.Columns.Add("IsFixedLength"' typeof(bool));                  table.Columns.Add("IsFixedPrecisionScale"' typeof(bool));                  table.Columns.Add("IsLong"' typeof(bool));                  table.Columns.Add("IsNullable"' typeof(bool));                  table.Columns.Add("IsSearchable"' typeof(bool));                  table.Columns.Add("IsSearchableWithLike"' typeof(bool));                  table.Columns.Add("IsUnsigned"' typeof(bool));                  table.Columns.Add("MaximumScale"' typeof(short));                  table.Columns.Add("MinimumScale"' typeof(short));                  table.Columns.Add("IsConcurrencyType"' typeof(bool));                  table.Columns.Add("IsLiteralsSupported"' typeof(bool));                  table.Columns.Add("LiteralPrefix"' typeof(string));                  table.Columns.Add("LiteralSuffix"' typeof(string));                  table.Columns.Add("NativeDataType"' typeof(string));    // NativeDataType is an OLE DB specific column for exposing the OLE DB type of the data type .                    table.ReadXml(XmlReader.Create(typeof(NuoDbConnectionInternal).Assembly.GetManifestResourceStream("NuoDb.Data.Client.DataTypes.xml")));              }              else if (collectionName == "Tables")              {                  table.Columns.Add("TABLE_CATALOG"' typeof(string));                  table.Columns.Add("TABLE_SCHEMA"' typeof(string));                  table.Columns.Add("TABLE_NAME"' typeof(string));                  table.Columns.Add("TABLE_TYPE"' typeof(string));                  table.Columns.Add("REMARKS"' typeof(string));                  table.Columns.Add("VIEW_DEF"' typeof(string));                    tmConn.InternalConnection.dataStream.startMessage(Protocol.GetTables);                  tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                  for (int i = 1; i < 3; i++)                      if (restrictionValues != null && restrictionValues.Length > i)                          tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                      else                          tmConn.InternalConnection.dataStream.encodeNull();                  if (restrictionValues == null || restrictionValues.Length < 4 || restrictionValues[3] == null)                      tmConn.InternalConnection.dataStream.encodeInt(0);                  else                  {                      tmConn.InternalConnection.dataStream.encodeInt(1);                      tmConn.InternalConnection.dataStream.encodeString(restrictionValues[3]);                  }                    tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                  int handle = tmConn.InternalConnection.dataStream.getInt();                    if (handle != -1)                  {                      using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                      {                          table.BeginLoadData();                          string view_def_label="";                          try                           {                               reader.GetOrdinal("VIEW_DEF");                              view_def_label = "VIEW_DEF";                          }                          catch(Exception) {}                          try                           {                               reader.GetOrdinal("VIEWDEFINITION");                              view_def_label = "VIEWDEFINITION";                          }                          catch (Exception) { }                          while (reader.Read())                          {  #if DEBUG                          System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_NAME"] + "' " + reader["TABLE_TYPE"]);  #endif                              DataRow row = table.NewRow();                              row["TABLE_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                              row["TABLE_NAME"] = reader.GetFieldValue<string>("TABLE_NAME");                              row["TABLE_TYPE"] = reader.GetFieldValue<string>("TABLE_TYPE");                              row["REMARKS"] = reader.GetFieldValue<string>("REMARKS");                              if (view_def_label.Length != 0)                              {                                  row["VIEW_DEF"] = reader.GetFieldValue<string>(view_def_label);                              }                              table.Rows.Add(row);                          }                          table.EndLoadData();                      }                  }              }              else if (collectionName == "Columns")              {                  table.Columns.Add("COLUMN_CATALOG"' typeof(string));                  table.Columns.Add("COLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("COLUMN_TABLE"' typeof(string));                  table.Columns.Add("COLUMN_NAME"' typeof(string));                  table.Columns.Add("COLUMN_POSITION"' typeof(int));                  table.Columns.Add("COLUMN_TYPE"' typeof(string));                  table.Columns.Add("COLUMN_LENGTH"' typeof(int));                  table.Columns.Add("COLUMN_PRECISION"' typeof(int));                  table.Columns.Add("COLUMN_NULLABLE"' typeof(bool));                  table.Columns.Add("COLUMN_IDENTITY"' typeof(bool));                  table.Columns.Add("COLUMN_DEFAULT"' typeof(string));                  table.Columns.Add("COLUMN_SCALE"' typeof(int));                    tmConn.InternalConnection.dataStream.startMessage(Protocol.GetColumns);                  tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                  for (int i = 1; i < 4; i++)                      if (restrictionValues != null && restrictionValues.Length > i)                          tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                      else                          tmConn.InternalConnection.dataStream.encodeNull();                    tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                  int handle = tmConn.InternalConnection.dataStream.getInt();                    if (handle != -1)                  {                      using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                      {                          table.BeginLoadData();                          while (reader.Read())                          {                              DataRow row = table.NewRow();                              row["COLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                              row["COLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                              row["COLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                              row["COLUMN_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                              row["COLUMN_LENGTH"] = reader.GetFieldValue<int>("COLUMN_SIZE");                              row["COLUMN_PRECISION"] = reader.GetFieldValue<int>("BUFFER_LENGTH");                              row["COLUMN_SCALE"] = reader.GetFieldValue<int>("DECIMAL_DIGITS");                              if (isNumeric(reader.GetFieldValue<string>("TYPE_NAME")))                              {                                  if (reader.GetFieldValue<int>("DECIMAL_DIGITS") != 0)                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME") +                                           "(" + reader.GetFieldValue<int>("BUFFER_LENGTH") + "'" + reader.GetFieldValue<int>("DECIMAL_DIGITS") + ")";                                  else                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME");                              }                              else                              {                                  if (isVarLenType(reader.GetFieldValue<string>("TYPE_NAME")) && reader.GetFieldValue<int>("COLUMN_SIZE") != 0)                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME") +                                           "(" + reader.GetFieldValue<int>("COLUMN_SIZE") + ")";                                  else                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME");                              }                              if (!reader.IsDBNull(reader.GetOrdinal("IS_NULLABLE")))                                  row["COLUMN_NULLABLE"] = reader.GetFieldValue<string>("IS_NULLABLE").Equals("YES");                              if (!reader.IsDBNull(reader.GetOrdinal("IS_AUTOINCREMENT")))                                  row["COLUMN_IDENTITY"] = reader.GetFieldValue<string>("IS_AUTOINCREMENT").Equals("YES");                              row["COLUMN_DEFAULT"] = reader.GetFieldValue<string>("COLUMN_DEF");    #if DEBUG                              System.Diagnostics.Trace.WriteLine("-> " + row["COLUMN_NAME"] + " " + row["COLUMN_TYPE"]);  #endif                              table.Rows.Add(row);                          }                          table.EndLoadData();                      }                  }              }              else if (collectionName == "Indexes")              {                  table.Columns.Add("INDEX_CATALOG"' typeof(string));                  table.Columns.Add("INDEX_SCHEMA"' typeof(string));                  table.Columns.Add("INDEX_TABLE"' typeof(string));                  table.Columns.Add("INDEX_NAME"' typeof(string));                  table.Columns.Add("INDEX_TYPE"' typeof(string));                  table.Columns.Add("INDEX_UNIQUE"' typeof(bool));                  table.Columns.Add("INDEX_PRIMARY"' typeof(bool));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetIndexInfo);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // unique                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // approximate                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        // to avoid to insert the same index more than once                      HashSet<string> unique = new HashSet<string>();                      if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;                                  if (!unique.Add(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;                                  DataRow row = table.NewRow();                                  row["INDEX_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEX_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEX_NAME"] = reader.GetFieldValue<string>("INDEX_NAME");                                  switch (reader.GetFieldValue<int>("TYPE"))                                  {                                      case 0:                                          row["INDEX_TYPE"] = "Primary";                                          break;                                      case 1:                                          row["INDEX_TYPE"] = "Unique";                                          break;                                      case 2:                                          row["INDEX_TYPE"] = "Secondary";                                          break;                                      case 3:                                          row["INDEX_TYPE"] = "Foreign Key";                                          break;                                  }                                  row["INDEX_UNIQUE"] = (reader.GetFieldValue<int>("NON_UNIQUE") == 0) ? true : false;                                  row["INDEX_PRIMARY"] = (reader.GetFieldValue<int>("TYPE") == 0) ? true : false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                        tmConn.InternalConnection.dataStream.startMessage(Protocol.GetPrimaryKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              // use INDEX_NAME' if present; if missing' the name of the index is in PK_NAME                              string indexName = "PK_NAME";                              foreach (string column in reader.columnNames)                              {                                  if (column == "INDEX_NAME")                                  {                                      indexName = "INDEX_NAME";                                      break;                                  }                              }                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>(indexName)))                                      continue;                                  if (!unique.Add(reader.GetFieldValue<string>(indexName)))                                      continue;                                  DataRow row = table.NewRow();                                  row["INDEX_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEX_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEX_NAME"] = reader.GetFieldValue<string>(indexName);                                  row["INDEX_TYPE"] = "Primary";                                  row["INDEX_UNIQUE"] = true;                                  row["INDEX_PRIMARY"] = true;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "IndexColumns")              {                  table.Columns.Add("INDEXCOLUMN_CATALOG"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_TABLE"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_INDEX"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_NAME"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_POSITION"' typeof(int));                  table.Columns.Add("INDEXCOLUMN_ISPRIMARY"' typeof(bool));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetIndexInfo);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // unique                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // approximate                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_SCHEM"] + "." + reader["TABLE_NAME"] + "=" + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["INDEXCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEXCOLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEXCOLUMN_INDEX"] = reader.GetFieldValue<string>("INDEX_NAME");                                  row["INDEXCOLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["INDEXCOLUMN_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                                  row["INDEXCOLUMN_ISPRIMARY"] = false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                        tmConn.InternalConnection.dataStream.startMessage(Protocol.GetPrimaryKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              // use INDEX_NAME' if present; if missing' the name of the index is in PK_NAME                              string indexName = "PK_NAME";                              foreach (string column in reader.columnNames)                              {                                  if (column == "INDEX_NAME")                                  {                                      indexName = "INDEX_NAME";                                      break;                                  }                              }                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>(indexName)))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_SCHEM"] + "." + reader["TABLE_NAME"] + " (Primary) =" + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["INDEXCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEXCOLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEXCOLUMN_INDEX"] = reader.GetFieldValue<string>(indexName);                                  row["INDEXCOLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["INDEXCOLUMN_POSITION"] = reader.GetFieldValue<int>("KEY_SEQ");                                  row["INDEXCOLUMN_ISPRIMARY"] = true;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ForeignKeys")              {                  table.Columns.Add("FOREIGNKEY_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEY_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEY_TABLE"' typeof(string));                  table.Columns.Add("FOREIGNKEY_NAME"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_TABLE"' typeof(string));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetImportedKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  string name = "[" + reader.GetFieldValue<string>("FKTABLE_SCHEM") + "]" +                                                   reader.GetFieldValue<string>("FKTABLE_NAME") + "." +                                                   reader.GetFieldValue<string>("FKCOLUMN_NAME") + "->" +                                                  "[" + reader.GetFieldValue<string>("PKTABLE_SCHEM") + "]" +                                                   reader.GetFieldValue<string>("PKTABLE_NAME") + "." +                                                   reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(name))                                      continue;                                  DataRow row = table.NewRow();                                  row["FOREIGNKEY_SCHEMA"] = reader.GetFieldValue<string>("FKTABLE_SCHEM");                                  row["FOREIGNKEY_TABLE"] = reader.GetFieldValue<string>("FKTABLE_NAME");                                  row["FOREIGNKEY_NAME"] = name;                                  row["FOREIGNKEY_OTHER_SCHEMA"] = reader.GetFieldValue<string>("PKTABLE_SCHEM");                                  row["FOREIGNKEY_OTHER_TABLE"] = reader.GetFieldValue<string>("PKTABLE_NAME");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ForeignKeyColumns")              {                  table.Columns.Add("FOREIGNKEYCOLUMN_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_TABLE"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_KEY"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_NAME"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_ORDINAL"' typeof(int));                  table.Columns.Add("FOREIGNKEYCOLUMN_OTHER_COLUMN_NAME"' typeof(string));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetImportedKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  string name = "[" + reader.GetFieldValue<string>("FKTABLE_SCHEM") + "]" +                                                  reader.GetFieldValue<string>("FKTABLE_NAME") + "." +                                                  reader.GetFieldValue<string>("FKCOLUMN_NAME") + "->" +                                                  "[" + reader.GetFieldValue<string>("PKTABLE_SCHEM") + "]" +                                                  reader.GetFieldValue<string>("PKTABLE_NAME") + "." +                                                  reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(name))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["FKTABLE_SCHEM"] + "." + reader["FKTABLE_NAME"] + "=" + reader["FKCOLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["FOREIGNKEYCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("FKTABLE_SCHEM");                                  row["FOREIGNKEYCOLUMN_TABLE"] = reader.GetFieldValue<string>("FKTABLE_NAME");                                  row["FOREIGNKEYCOLUMN_KEY"] = name;                                  row["FOREIGNKEYCOLUMN_NAME"] = reader.GetFieldValue<string>("FKCOLUMN_NAME");                                  row["FOREIGNKEYCOLUMN_ORDINAL"] = reader.GetFieldValue<int>("KEY_SEQ");                                  row["FOREIGNKEYCOLUMN_OTHER_COLUMN_NAME"] = reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "Procedures")               {                  table.Columns.Add("PROCEDURE_CATALOG"' typeof(string));                  table.Columns.Add("PROCEDURE_SCHEMA"' typeof(string));                  table.Columns.Add("PROCEDURE_NAME"' typeof(string));                  table.Columns.Add("IS_SYSTEM_PROCEDURE"' typeof(bool));                    if (tmConn.InternalConnection.protocolVersion >= Protocol.PROTOCOL_VERSION12)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetProcedures);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      for (int i = 1; i < 3; i++)                          if (restrictionValues != null && restrictionValues.Length > i)                              tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                          else                              tmConn.InternalConnection.dataStream.encodeNull();                        tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["PROCEDURE_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["PROCEDURE_SCHEMA"] = reader.GetFieldValue<string>("PROCEDURE_SCHEM");                                  row["PROCEDURE_NAME"] = reader.GetFieldValue<string>("PROCEDURE_NAME");                                  row["IS_SYSTEM_PROCEDURE"] = false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ProcedureParameters")              {                  table.Columns.Add("PROCEDURE_CATALOG"' typeof(string));                  table.Columns.Add("PROCEDURE_SCHEMA"' typeof(string));                  table.Columns.Add("PROCEDURE_NAME"' typeof(string));                  table.Columns.Add("PARAMETER_NAME"' typeof(string));                  table.Columns.Add("ORDINAL_POSITION"' typeof(int));                  table.Columns.Add("PARAMETER_DATA_TYPE"' typeof(int));                  table.Columns.Add("PARAMETER_TYPE_NAME"' typeof(string));                  table.Columns.Add("PARAMETER_SIZE"' typeof(int));                  table.Columns.Add("NUMERIC_PRECISION"' typeof(int));                  table.Columns.Add("NUMERIC_SCALE"' typeof(int));                  table.Columns.Add("PARAMETER_DIRECTION"' typeof(int));                  table.Columns.Add("IS_NULLABLE"' typeof(bool));                    if (tmConn.InternalConnection.protocolVersion >= Protocol.PROTOCOL_VERSION12)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetProcedureColumns);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      for (int i = 1; i < 4; i++)                          if (restrictionValues != null && restrictionValues.Length > i)                              tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                          else                              tmConn.InternalConnection.dataStream.encodeNull();                        tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["PROCEDURE_NAME"] + "' " + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["PROCEDURE_SCHEMA"] = reader.GetFieldValue<string>("PROCEDURE_SCHEM");                                  row["PROCEDURE_NAME"] = reader.GetFieldValue<string>("PROCEDURE_NAME");                                  row["PARAMETER_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["ORDINAL_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                                  row["PARAMETER_TYPE_NAME"] = reader.GetFieldValue<string>("TYPE_NAME");                                  row["PARAMETER_DATA_TYPE"] = reader.GetFieldValue<int>("DATA_TYPE");                                  row["PARAMETER_SIZE"] = reader.GetFieldValue<int>("LENGTH");                                  row["NUMERIC_PRECISION"] = reader.GetFieldValue<int>("PRECISION");                                  row["NUMERIC_SCALE"] = reader.GetFieldValue<int>("SCALE");                                  row["PARAMETER_DIRECTION"] = reader.GetFieldValue<int>("COLUMN_TYPE");                                  row["IS_NULLABLE"] = !reader.GetFieldValue<string>("IS_NULLABLE").Equals("NO");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The following statement contains a magic number: if (collectionName == DbMetaDataCollectionNames.DataSourceInformation)              {                  // see http://msdn.microsoft.com/en-us/library/ms254501.aspx                  table.Columns.Add("CompositeIdentifierSeparatorPattern"' typeof(string));                  table.Columns.Add("DataSourceProductName"' typeof(string));                  table.Columns.Add("DataSourceProductVersion"' typeof(string));                  table.Columns.Add("DataSourceProductVersionNormalized"' typeof(string));                  table.Columns.Add("DataSourceInternalProductVersion"' typeof(string));                  table.Columns.Add("GroupByBehavior"' typeof(GroupByBehavior));                  table.Columns.Add("IdentifierPattern"' typeof(string));                  table.Columns.Add("IdentifierCase"' typeof(IdentifierCase));                  table.Columns.Add("OrderByColumnsInSelect"' typeof(bool));                  table.Columns.Add("ParameterMarkerFormat"' typeof(string));                  table.Columns.Add("ParameterMarkerPattern"' typeof(string));                  table.Columns.Add("ParameterNameMaxLength"' typeof(int));                  table.Columns.Add("ParameterNamePattern"' typeof(string));                  table.Columns.Add("QuotedIdentifierPattern"' typeof(string));  // Regex                  table.Columns.Add("QuotedIdentifierCase"' typeof(int));                  table.Columns.Add("StatementSeparatorPattern"' typeof(string));                  table.Columns.Add("StringLiteralPattern"' typeof(string));  // Regex                  table.Columns.Add("SupportedJoinOperators"' typeof(SupportedJoinOperators));                    table.BeginLoadData();                  DataRow row = table.NewRow();                  int databaseMajorVersion = 0' databaseMinorVersion = 0;                  try                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetDatabaseMetaData);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      for (int item; (item = tmConn.InternalConnection.dataStream.getInt()) != Protocol.DbmbFini; )                      {                          switch (item)                          {                              case Protocol.DbmbProductName:                                  row["DataSourceProductName"] = tmConn.InternalConnection.dataStream.getString();                                  break;                                case Protocol.DbmbProductVersion:                                  row["DataSourceProductVersion"] = tmConn.InternalConnection.dataStream.getString();                                  break;                                case Protocol.DbmbDatabaseMinorVersion:                                  databaseMinorVersion = tmConn.InternalConnection.dataStream.getInt();                                  break;                                case Protocol.DbmbDatabaseMajorVersion:                                  databaseMajorVersion = tmConn.InternalConnection.dataStream.getInt();                                  break;                                case Protocol.DbmbDefaultTransactionIsolation:                                  int defaultTransactionIsolation = tmConn.InternalConnection.dataStream.getInt();                                  break;                                default:                                  tmConn.InternalConnection.dataStream.decode();                                  break;                          }                      }                  }                  catch (Exception)                  {                  }                    row["DataSourceInternalProductVersion"] = String.Format("{0:D3}.{1:D3}"' databaseMajorVersion' databaseMinorVersion);                  // The regular expression to match the composite separators in a composite identifier.                   // For example' "\." (for SQL Server) or "@|\." (for Oracle).                  // A composite identifier is typically what is used for a database object name'                   // for example: pubs.dbo.authors or pubs@dbo.authors.                  row["CompositeIdentifierSeparatorPattern"] = "\\.";                  // A normalized version for the data source' such that it can be compared with String.Compare().                   // The format of this is consistent for all versions of the provider to prevent version 10 from sorting between version 1 and version 2.                  //row["DataSourceProductVersionNormalized"] = ??                  // Specifies the relationship between the columns in a GROUP BY clause and the non-aggregated columns in the select list.                  row["GroupByBehavior"] = GroupByBehavior.Unknown;                  // A regular expression that matches an identifier and has a match value of the identifier. For example "[A-Za-z0-9_#$]".                  row["IdentifierPattern"] = "(^\\[\\p{Lo}\\p{Lu}\\p{Ll}_@#][\\p{Lo}\\p{Lu}\\p{Ll}\\p{Nd}@$#_]*$)|(^\"[^\"\\0]|\"\"+\"$)";                  // Indicates whether non-quoted identifiers are treated as case sensitive or not.                  row["IdentifierCase"] = IdentifierCase.Insensitive;                  // Specifies whether columns in an ORDER BY clause must be in the select list.                   // A value of true indicates that they are required to be in the select list'                   // a value of false indicates that they are not required to be in the select list.                  row["OrderByColumnsInSelect"] = false;                  // For data sources that do not expect named parameters and expect the use of the ‘?’ character' the format string                  // can be specified as simply '?'' which would ignore the parameter name.                  row["ParameterMarkerFormat"] = "?";                  // if the data source doesn't support named parameters' this would simply be "?".                  row["ParameterMarkerPattern"] = "?";                  // If the data source does not support named parameters' this property returns zero.                  row["ParameterNameMaxLength"] = 0;                  // A regular expression that matches the valid parameter names                  row["ParameterNamePattern"] = "";                  // A regular expression that matches a quoted identifier and has a match value of the identifier itself without the quotes.                   // For example' if the data source used double-quotes to identify quoted identifiers' this would be: "(([^\"]|\"\")*)".                  row["QuotedIdentifierPattern"] = "\"([^\"]*)\"";                  // Indicates whether quoted identifiers are treated as case sensitive or not.                  row["QuotedIdentifierCase"] = IdentifierCase.Sensitive;                  // A regular expression that matches the statement separator.                  row["StatementSeparatorPattern"] = ";";                  // A regular expression that matches a string literal and has a match value of the literal itself.                   // For example' if the data source used single-quotes to identify strings' this would be: "('([^']|'')*')"'                  row["StringLiteralPattern"] = "'([^']*)'";                  // Specifies what types of SQL join statements are supported by the data source.                  row["SupportedJoinOperators"] = SupportedJoinOperators.None;                  table.Rows.Add(row);                  table.EndLoadData();              }              else if (collectionName == DbMetaDataCollectionNames.ReservedWords)              {                  table.Columns.Add("ReservedWord"' typeof(string));                  table.Columns.Add("MaximumVersion"' typeof(string));                  table.Columns.Add("MinimumVersion"' typeof(string));                    string[] words = { "select"' "Add field"' "Drop field"' "Alter table"' "Alter field"'                                      "Alter user"' "And"' "Or"' "Not"' "Create Index"' "Upgrade"' "Unique"'                                      "Table key"' "Table unique key"' "Primary Key"' "Create Table"'                                      "Upgrade Table"' "Rename Table"' "Create View"' "Upgrade View"'                                      "Drop View"' "Create Schema"' "Drop Schema"' "Integer"' "Smallint"'                                      "Bigint"' "Tinyint"' "float"' "double"' "Blob"' "bytes"' "boolean"'                                      "binary"' "varbinary"' "string"' "char"' "text"' "date"' "timestamp"'                                      "time"' "varchar"' "numeric"' "Decimal Number"' "Enum"' "Delete"' "Repair"'                                      "Field"' "Not Null"' "Default Value"' "searchable"' "not searchable"'                                      "collation"' "character_set"' "Foreign Key"' "Identifier"' "record number"'                                      "Insert"' "Replace"' "Name"' "Number"' "Order"' "Descending"' "limit"'                                      "Quoted String"' "Select Clause"' "Distinct"' "Gtr"' "Geq"' "Eql"'                                      "Leq"' "Lss"' "Neq"' "in list"' "in select"' "exists"' "Between"' "Like"'                                      "starts with"' "Containing"' "Matching"' "Regular expression"' "Null"'                                      "True"' "False"' "Execute"' "Parameter"' "Count"' "sum"' "min"' "max"'                                      "avg"' "Drop Index"' "Drop primary key"' "Drop foreign key"' "Drop Table"'                                      "If Exists"' "Describe"' "Statement"' "for_select"' "for_insert"' "while"'                                      "if then else"' "variable"' "declaration"' "throw"' "assignment"'                                      "Start transaction"' "read only"' "read write"' "read committed"' "write committed"'                                      "read uncommitted"' "repeatableread"' "serializable"' "Commit"' "Rollback"'                                      "Savepoint"' "Rollack Savepoint"' "Release Savepoint"' "Table"' "Derived Table"'                                      "Assign"' "Update"' "list"' "Constant"' "Function"' "Grant"' "Grant role"' "Alter"'                                      "Read"' "Identity"' "Check"' "Constraint"' "value constraint"' "auto increment"'                                      "generated"' "always"' "Domain"' "is null"' "is active_role"' "start with"' "reindex"'                                      "cursor"' "alias"' "push_namespace"' "pop_namespace"' "set_namespace"' "coalesce"'                                      "nod_nullif"' "case"' "case_search"' "add"' "subtract"' "multiply"' "divide"' "modulus"'                                      "negate"' "plus"' "cast"' "concatenation"' "create user"' "drop user"' "create role"'                                      "upgrade role"' "drop role"' "revoke"' "revoke role"' "assume"' "revert"' "negate"'                                      "priv insert"' "priv delete"' "priv execute"' "priv select"' "priv update"' "priv grant"'                                      "priv all"' "characters"' "octets"' "role"' "view"' "procedure"' "user"' "zone"' "admin"'                                      "default role"' "create sequence"' "upgrade sequence"' "drop sequence"' "next value"'                                      "create trigger"' "upgrade trigger"' "alter trigger"' "drop trigger"' "create procedure"'                                      "upgrade procedure"' "alter procedure"' "drop procedure"' "pre-insert"' "post-insert"'                                      "pre-update"' "post-update"' "pre-delete"' "post-delete"' "pre-commit"' "post-commit"'                                      "active"' "inactive"' "position"' "select-expr"' "create filterset"' "upgrade filterset"'                                      "drop filterset"' "enable filterset"' "disable filterset"' "table filter"' "left outer"'                                      "right outer"' "full outer"' "inner"' "join"' "join_term"' "trigger class"' "enable trigger class"'                                      "disable trigger class"' "create zone"' "upgrade zone"' "drop zone"' "range"' "ip address"'                                      "node_name"' "wildcard"' "create domain"' "upgrade domain"' "alter domain"' "upgrade schema"'                                      "delete cascade"' "index segment"' "for update"' "write committed"' "read committed"'                                       "consistent read"' "set dialect"' "set names"' "restrict"' "cascade"' "characters"' "octets"'                                      "create event"' "collate"' "truncate"' "restart"' "nameless constraint"' "drop constraint"'                                      "drop unique constraint"' "drop domain"' "with check option"' "not real"' "lower"' "upper"'                                      "substr"' "substring index"' "charlength"' "default keyword"' "sqrt"' "power"' "Scientific Notation Number"'                                      "Explain"' "msleep"' "KillStatement"' "now" };                  table.BeginLoadData();                  foreach (string keyword in words)                  {                      DataRow row = table.NewRow();                      row["ReservedWord"] = keyword;                      table.Rows.Add(row);                  }                  table.EndLoadData();                }              else if (collectionName == DbMetaDataCollectionNames.DataTypes)              {                  table.Columns.Add("TypeName"' typeof(string));  // The provider-specific data type name.                  table.Columns.Add("ProviderDbType"' typeof(int)); // The provider-specific type value that should be used when specifying                   //a parameter's type. For example' SqlDbType.Money or OracleType.Blob.                  table.Columns.Add("ColumnSize"' typeof(long));                  table.Columns.Add("CreateFormat"' typeof(string));                  table.Columns.Add("CreateParameters"' typeof(string));                  table.Columns.Add("DataType"' typeof(string));  // The name of the .NET Framework type of the data type.                  table.Columns.Add("IsAutoincrementable"' typeof(bool));                  table.Columns.Add("IsBestMatch"' typeof(bool));                  table.Columns.Add("IsCaseSensitive"' typeof(bool));                  table.Columns.Add("IsFixedLength"' typeof(bool));                  table.Columns.Add("IsFixedPrecisionScale"' typeof(bool));                  table.Columns.Add("IsLong"' typeof(bool));                  table.Columns.Add("IsNullable"' typeof(bool));                  table.Columns.Add("IsSearchable"' typeof(bool));                  table.Columns.Add("IsSearchableWithLike"' typeof(bool));                  table.Columns.Add("IsUnsigned"' typeof(bool));                  table.Columns.Add("MaximumScale"' typeof(short));                  table.Columns.Add("MinimumScale"' typeof(short));                  table.Columns.Add("IsConcurrencyType"' typeof(bool));                  table.Columns.Add("IsLiteralsSupported"' typeof(bool));                  table.Columns.Add("LiteralPrefix"' typeof(string));                  table.Columns.Add("LiteralSuffix"' typeof(string));                  table.Columns.Add("NativeDataType"' typeof(string));    // NativeDataType is an OLE DB specific column for exposing the OLE DB type of the data type .                    table.ReadXml(XmlReader.Create(typeof(NuoDbConnectionInternal).Assembly.GetManifestResourceStream("NuoDb.Data.Client.DataTypes.xml")));              }              else if (collectionName == "Tables")              {                  table.Columns.Add("TABLE_CATALOG"' typeof(string));                  table.Columns.Add("TABLE_SCHEMA"' typeof(string));                  table.Columns.Add("TABLE_NAME"' typeof(string));                  table.Columns.Add("TABLE_TYPE"' typeof(string));                  table.Columns.Add("REMARKS"' typeof(string));                  table.Columns.Add("VIEW_DEF"' typeof(string));                    tmConn.InternalConnection.dataStream.startMessage(Protocol.GetTables);                  tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                  for (int i = 1; i < 3; i++)                      if (restrictionValues != null && restrictionValues.Length > i)                          tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                      else                          tmConn.InternalConnection.dataStream.encodeNull();                  if (restrictionValues == null || restrictionValues.Length < 4 || restrictionValues[3] == null)                      tmConn.InternalConnection.dataStream.encodeInt(0);                  else                  {                      tmConn.InternalConnection.dataStream.encodeInt(1);                      tmConn.InternalConnection.dataStream.encodeString(restrictionValues[3]);                  }                    tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                  int handle = tmConn.InternalConnection.dataStream.getInt();                    if (handle != -1)                  {                      using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                      {                          table.BeginLoadData();                          string view_def_label="";                          try                           {                               reader.GetOrdinal("VIEW_DEF");                              view_def_label = "VIEW_DEF";                          }                          catch(Exception) {}                          try                           {                               reader.GetOrdinal("VIEWDEFINITION");                              view_def_label = "VIEWDEFINITION";                          }                          catch (Exception) { }                          while (reader.Read())                          {  #if DEBUG                          System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_NAME"] + "' " + reader["TABLE_TYPE"]);  #endif                              DataRow row = table.NewRow();                              row["TABLE_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                              row["TABLE_NAME"] = reader.GetFieldValue<string>("TABLE_NAME");                              row["TABLE_TYPE"] = reader.GetFieldValue<string>("TABLE_TYPE");                              row["REMARKS"] = reader.GetFieldValue<string>("REMARKS");                              if (view_def_label.Length != 0)                              {                                  row["VIEW_DEF"] = reader.GetFieldValue<string>(view_def_label);                              }                              table.Rows.Add(row);                          }                          table.EndLoadData();                      }                  }              }              else if (collectionName == "Columns")              {                  table.Columns.Add("COLUMN_CATALOG"' typeof(string));                  table.Columns.Add("COLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("COLUMN_TABLE"' typeof(string));                  table.Columns.Add("COLUMN_NAME"' typeof(string));                  table.Columns.Add("COLUMN_POSITION"' typeof(int));                  table.Columns.Add("COLUMN_TYPE"' typeof(string));                  table.Columns.Add("COLUMN_LENGTH"' typeof(int));                  table.Columns.Add("COLUMN_PRECISION"' typeof(int));                  table.Columns.Add("COLUMN_NULLABLE"' typeof(bool));                  table.Columns.Add("COLUMN_IDENTITY"' typeof(bool));                  table.Columns.Add("COLUMN_DEFAULT"' typeof(string));                  table.Columns.Add("COLUMN_SCALE"' typeof(int));                    tmConn.InternalConnection.dataStream.startMessage(Protocol.GetColumns);                  tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                  for (int i = 1; i < 4; i++)                      if (restrictionValues != null && restrictionValues.Length > i)                          tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                      else                          tmConn.InternalConnection.dataStream.encodeNull();                    tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                  int handle = tmConn.InternalConnection.dataStream.getInt();                    if (handle != -1)                  {                      using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                      {                          table.BeginLoadData();                          while (reader.Read())                          {                              DataRow row = table.NewRow();                              row["COLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                              row["COLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                              row["COLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                              row["COLUMN_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                              row["COLUMN_LENGTH"] = reader.GetFieldValue<int>("COLUMN_SIZE");                              row["COLUMN_PRECISION"] = reader.GetFieldValue<int>("BUFFER_LENGTH");                              row["COLUMN_SCALE"] = reader.GetFieldValue<int>("DECIMAL_DIGITS");                              if (isNumeric(reader.GetFieldValue<string>("TYPE_NAME")))                              {                                  if (reader.GetFieldValue<int>("DECIMAL_DIGITS") != 0)                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME") +                                           "(" + reader.GetFieldValue<int>("BUFFER_LENGTH") + "'" + reader.GetFieldValue<int>("DECIMAL_DIGITS") + ")";                                  else                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME");                              }                              else                              {                                  if (isVarLenType(reader.GetFieldValue<string>("TYPE_NAME")) && reader.GetFieldValue<int>("COLUMN_SIZE") != 0)                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME") +                                           "(" + reader.GetFieldValue<int>("COLUMN_SIZE") + ")";                                  else                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME");                              }                              if (!reader.IsDBNull(reader.GetOrdinal("IS_NULLABLE")))                                  row["COLUMN_NULLABLE"] = reader.GetFieldValue<string>("IS_NULLABLE").Equals("YES");                              if (!reader.IsDBNull(reader.GetOrdinal("IS_AUTOINCREMENT")))                                  row["COLUMN_IDENTITY"] = reader.GetFieldValue<string>("IS_AUTOINCREMENT").Equals("YES");                              row["COLUMN_DEFAULT"] = reader.GetFieldValue<string>("COLUMN_DEF");    #if DEBUG                              System.Diagnostics.Trace.WriteLine("-> " + row["COLUMN_NAME"] + " " + row["COLUMN_TYPE"]);  #endif                              table.Rows.Add(row);                          }                          table.EndLoadData();                      }                  }              }              else if (collectionName == "Indexes")              {                  table.Columns.Add("INDEX_CATALOG"' typeof(string));                  table.Columns.Add("INDEX_SCHEMA"' typeof(string));                  table.Columns.Add("INDEX_TABLE"' typeof(string));                  table.Columns.Add("INDEX_NAME"' typeof(string));                  table.Columns.Add("INDEX_TYPE"' typeof(string));                  table.Columns.Add("INDEX_UNIQUE"' typeof(bool));                  table.Columns.Add("INDEX_PRIMARY"' typeof(bool));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetIndexInfo);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // unique                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // approximate                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        // to avoid to insert the same index more than once                      HashSet<string> unique = new HashSet<string>();                      if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;                                  if (!unique.Add(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;                                  DataRow row = table.NewRow();                                  row["INDEX_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEX_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEX_NAME"] = reader.GetFieldValue<string>("INDEX_NAME");                                  switch (reader.GetFieldValue<int>("TYPE"))                                  {                                      case 0:                                          row["INDEX_TYPE"] = "Primary";                                          break;                                      case 1:                                          row["INDEX_TYPE"] = "Unique";                                          break;                                      case 2:                                          row["INDEX_TYPE"] = "Secondary";                                          break;                                      case 3:                                          row["INDEX_TYPE"] = "Foreign Key";                                          break;                                  }                                  row["INDEX_UNIQUE"] = (reader.GetFieldValue<int>("NON_UNIQUE") == 0) ? true : false;                                  row["INDEX_PRIMARY"] = (reader.GetFieldValue<int>("TYPE") == 0) ? true : false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                        tmConn.InternalConnection.dataStream.startMessage(Protocol.GetPrimaryKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              // use INDEX_NAME' if present; if missing' the name of the index is in PK_NAME                              string indexName = "PK_NAME";                              foreach (string column in reader.columnNames)                              {                                  if (column == "INDEX_NAME")                                  {                                      indexName = "INDEX_NAME";                                      break;                                  }                              }                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>(indexName)))                                      continue;                                  if (!unique.Add(reader.GetFieldValue<string>(indexName)))                                      continue;                                  DataRow row = table.NewRow();                                  row["INDEX_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEX_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEX_NAME"] = reader.GetFieldValue<string>(indexName);                                  row["INDEX_TYPE"] = "Primary";                                  row["INDEX_UNIQUE"] = true;                                  row["INDEX_PRIMARY"] = true;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "IndexColumns")              {                  table.Columns.Add("INDEXCOLUMN_CATALOG"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_TABLE"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_INDEX"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_NAME"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_POSITION"' typeof(int));                  table.Columns.Add("INDEXCOLUMN_ISPRIMARY"' typeof(bool));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetIndexInfo);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // unique                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // approximate                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_SCHEM"] + "." + reader["TABLE_NAME"] + "=" + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["INDEXCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEXCOLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEXCOLUMN_INDEX"] = reader.GetFieldValue<string>("INDEX_NAME");                                  row["INDEXCOLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["INDEXCOLUMN_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                                  row["INDEXCOLUMN_ISPRIMARY"] = false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                        tmConn.InternalConnection.dataStream.startMessage(Protocol.GetPrimaryKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              // use INDEX_NAME' if present; if missing' the name of the index is in PK_NAME                              string indexName = "PK_NAME";                              foreach (string column in reader.columnNames)                              {                                  if (column == "INDEX_NAME")                                  {                                      indexName = "INDEX_NAME";                                      break;                                  }                              }                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>(indexName)))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_SCHEM"] + "." + reader["TABLE_NAME"] + " (Primary) =" + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["INDEXCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEXCOLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEXCOLUMN_INDEX"] = reader.GetFieldValue<string>(indexName);                                  row["INDEXCOLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["INDEXCOLUMN_POSITION"] = reader.GetFieldValue<int>("KEY_SEQ");                                  row["INDEXCOLUMN_ISPRIMARY"] = true;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ForeignKeys")              {                  table.Columns.Add("FOREIGNKEY_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEY_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEY_TABLE"' typeof(string));                  table.Columns.Add("FOREIGNKEY_NAME"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_TABLE"' typeof(string));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetImportedKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  string name = "[" + reader.GetFieldValue<string>("FKTABLE_SCHEM") + "]" +                                                   reader.GetFieldValue<string>("FKTABLE_NAME") + "." +                                                   reader.GetFieldValue<string>("FKCOLUMN_NAME") + "->" +                                                  "[" + reader.GetFieldValue<string>("PKTABLE_SCHEM") + "]" +                                                   reader.GetFieldValue<string>("PKTABLE_NAME") + "." +                                                   reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(name))                                      continue;                                  DataRow row = table.NewRow();                                  row["FOREIGNKEY_SCHEMA"] = reader.GetFieldValue<string>("FKTABLE_SCHEM");                                  row["FOREIGNKEY_TABLE"] = reader.GetFieldValue<string>("FKTABLE_NAME");                                  row["FOREIGNKEY_NAME"] = name;                                  row["FOREIGNKEY_OTHER_SCHEMA"] = reader.GetFieldValue<string>("PKTABLE_SCHEM");                                  row["FOREIGNKEY_OTHER_TABLE"] = reader.GetFieldValue<string>("PKTABLE_NAME");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ForeignKeyColumns")              {                  table.Columns.Add("FOREIGNKEYCOLUMN_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_TABLE"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_KEY"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_NAME"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_ORDINAL"' typeof(int));                  table.Columns.Add("FOREIGNKEYCOLUMN_OTHER_COLUMN_NAME"' typeof(string));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetImportedKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  string name = "[" + reader.GetFieldValue<string>("FKTABLE_SCHEM") + "]" +                                                  reader.GetFieldValue<string>("FKTABLE_NAME") + "." +                                                  reader.GetFieldValue<string>("FKCOLUMN_NAME") + "->" +                                                  "[" + reader.GetFieldValue<string>("PKTABLE_SCHEM") + "]" +                                                  reader.GetFieldValue<string>("PKTABLE_NAME") + "." +                                                  reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(name))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["FKTABLE_SCHEM"] + "." + reader["FKTABLE_NAME"] + "=" + reader["FKCOLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["FOREIGNKEYCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("FKTABLE_SCHEM");                                  row["FOREIGNKEYCOLUMN_TABLE"] = reader.GetFieldValue<string>("FKTABLE_NAME");                                  row["FOREIGNKEYCOLUMN_KEY"] = name;                                  row["FOREIGNKEYCOLUMN_NAME"] = reader.GetFieldValue<string>("FKCOLUMN_NAME");                                  row["FOREIGNKEYCOLUMN_ORDINAL"] = reader.GetFieldValue<int>("KEY_SEQ");                                  row["FOREIGNKEYCOLUMN_OTHER_COLUMN_NAME"] = reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "Procedures")               {                  table.Columns.Add("PROCEDURE_CATALOG"' typeof(string));                  table.Columns.Add("PROCEDURE_SCHEMA"' typeof(string));                  table.Columns.Add("PROCEDURE_NAME"' typeof(string));                  table.Columns.Add("IS_SYSTEM_PROCEDURE"' typeof(bool));                    if (tmConn.InternalConnection.protocolVersion >= Protocol.PROTOCOL_VERSION12)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetProcedures);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      for (int i = 1; i < 3; i++)                          if (restrictionValues != null && restrictionValues.Length > i)                              tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                          else                              tmConn.InternalConnection.dataStream.encodeNull();                        tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["PROCEDURE_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["PROCEDURE_SCHEMA"] = reader.GetFieldValue<string>("PROCEDURE_SCHEM");                                  row["PROCEDURE_NAME"] = reader.GetFieldValue<string>("PROCEDURE_NAME");                                  row["IS_SYSTEM_PROCEDURE"] = false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ProcedureParameters")              {                  table.Columns.Add("PROCEDURE_CATALOG"' typeof(string));                  table.Columns.Add("PROCEDURE_SCHEMA"' typeof(string));                  table.Columns.Add("PROCEDURE_NAME"' typeof(string));                  table.Columns.Add("PARAMETER_NAME"' typeof(string));                  table.Columns.Add("ORDINAL_POSITION"' typeof(int));                  table.Columns.Add("PARAMETER_DATA_TYPE"' typeof(int));                  table.Columns.Add("PARAMETER_TYPE_NAME"' typeof(string));                  table.Columns.Add("PARAMETER_SIZE"' typeof(int));                  table.Columns.Add("NUMERIC_PRECISION"' typeof(int));                  table.Columns.Add("NUMERIC_SCALE"' typeof(int));                  table.Columns.Add("PARAMETER_DIRECTION"' typeof(int));                  table.Columns.Add("IS_NULLABLE"' typeof(bool));                    if (tmConn.InternalConnection.protocolVersion >= Protocol.PROTOCOL_VERSION12)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetProcedureColumns);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      for (int i = 1; i < 4; i++)                          if (restrictionValues != null && restrictionValues.Length > i)                              tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                          else                              tmConn.InternalConnection.dataStream.encodeNull();                        tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["PROCEDURE_NAME"] + "' " + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["PROCEDURE_SCHEMA"] = reader.GetFieldValue<string>("PROCEDURE_SCHEM");                                  row["PROCEDURE_NAME"] = reader.GetFieldValue<string>("PROCEDURE_NAME");                                  row["PARAMETER_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["ORDINAL_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                                  row["PARAMETER_TYPE_NAME"] = reader.GetFieldValue<string>("TYPE_NAME");                                  row["PARAMETER_DATA_TYPE"] = reader.GetFieldValue<int>("DATA_TYPE");                                  row["PARAMETER_SIZE"] = reader.GetFieldValue<int>("LENGTH");                                  row["NUMERIC_PRECISION"] = reader.GetFieldValue<int>("PRECISION");                                  row["NUMERIC_SCALE"] = reader.GetFieldValue<int>("SCALE");                                  row["PARAMETER_DIRECTION"] = reader.GetFieldValue<int>("COLUMN_TYPE");                                  row["IS_NULLABLE"] = !reader.GetFieldValue<string>("IS_NULLABLE").Equals("NO");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The following statement contains a magic number: if (collectionName == DbMetaDataCollectionNames.DataSourceInformation)              {                  // see http://msdn.microsoft.com/en-us/library/ms254501.aspx                  table.Columns.Add("CompositeIdentifierSeparatorPattern"' typeof(string));                  table.Columns.Add("DataSourceProductName"' typeof(string));                  table.Columns.Add("DataSourceProductVersion"' typeof(string));                  table.Columns.Add("DataSourceProductVersionNormalized"' typeof(string));                  table.Columns.Add("DataSourceInternalProductVersion"' typeof(string));                  table.Columns.Add("GroupByBehavior"' typeof(GroupByBehavior));                  table.Columns.Add("IdentifierPattern"' typeof(string));                  table.Columns.Add("IdentifierCase"' typeof(IdentifierCase));                  table.Columns.Add("OrderByColumnsInSelect"' typeof(bool));                  table.Columns.Add("ParameterMarkerFormat"' typeof(string));                  table.Columns.Add("ParameterMarkerPattern"' typeof(string));                  table.Columns.Add("ParameterNameMaxLength"' typeof(int));                  table.Columns.Add("ParameterNamePattern"' typeof(string));                  table.Columns.Add("QuotedIdentifierPattern"' typeof(string));  // Regex                  table.Columns.Add("QuotedIdentifierCase"' typeof(int));                  table.Columns.Add("StatementSeparatorPattern"' typeof(string));                  table.Columns.Add("StringLiteralPattern"' typeof(string));  // Regex                  table.Columns.Add("SupportedJoinOperators"' typeof(SupportedJoinOperators));                    table.BeginLoadData();                  DataRow row = table.NewRow();                  int databaseMajorVersion = 0' databaseMinorVersion = 0;                  try                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetDatabaseMetaData);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      for (int item; (item = tmConn.InternalConnection.dataStream.getInt()) != Protocol.DbmbFini; )                      {                          switch (item)                          {                              case Protocol.DbmbProductName:                                  row["DataSourceProductName"] = tmConn.InternalConnection.dataStream.getString();                                  break;                                case Protocol.DbmbProductVersion:                                  row["DataSourceProductVersion"] = tmConn.InternalConnection.dataStream.getString();                                  break;                                case Protocol.DbmbDatabaseMinorVersion:                                  databaseMinorVersion = tmConn.InternalConnection.dataStream.getInt();                                  break;                                case Protocol.DbmbDatabaseMajorVersion:                                  databaseMajorVersion = tmConn.InternalConnection.dataStream.getInt();                                  break;                                case Protocol.DbmbDefaultTransactionIsolation:                                  int defaultTransactionIsolation = tmConn.InternalConnection.dataStream.getInt();                                  break;                                default:                                  tmConn.InternalConnection.dataStream.decode();                                  break;                          }                      }                  }                  catch (Exception)                  {                  }                    row["DataSourceInternalProductVersion"] = String.Format("{0:D3}.{1:D3}"' databaseMajorVersion' databaseMinorVersion);                  // The regular expression to match the composite separators in a composite identifier.                   // For example' "\." (for SQL Server) or "@|\." (for Oracle).                  // A composite identifier is typically what is used for a database object name'                   // for example: pubs.dbo.authors or pubs@dbo.authors.                  row["CompositeIdentifierSeparatorPattern"] = "\\.";                  // A normalized version for the data source' such that it can be compared with String.Compare().                   // The format of this is consistent for all versions of the provider to prevent version 10 from sorting between version 1 and version 2.                  //row["DataSourceProductVersionNormalized"] = ??                  // Specifies the relationship between the columns in a GROUP BY clause and the non-aggregated columns in the select list.                  row["GroupByBehavior"] = GroupByBehavior.Unknown;                  // A regular expression that matches an identifier and has a match value of the identifier. For example "[A-Za-z0-9_#$]".                  row["IdentifierPattern"] = "(^\\[\\p{Lo}\\p{Lu}\\p{Ll}_@#][\\p{Lo}\\p{Lu}\\p{Ll}\\p{Nd}@$#_]*$)|(^\"[^\"\\0]|\"\"+\"$)";                  // Indicates whether non-quoted identifiers are treated as case sensitive or not.                  row["IdentifierCase"] = IdentifierCase.Insensitive;                  // Specifies whether columns in an ORDER BY clause must be in the select list.                   // A value of true indicates that they are required to be in the select list'                   // a value of false indicates that they are not required to be in the select list.                  row["OrderByColumnsInSelect"] = false;                  // For data sources that do not expect named parameters and expect the use of the ‘?’ character' the format string                  // can be specified as simply '?'' which would ignore the parameter name.                  row["ParameterMarkerFormat"] = "?";                  // if the data source doesn't support named parameters' this would simply be "?".                  row["ParameterMarkerPattern"] = "?";                  // If the data source does not support named parameters' this property returns zero.                  row["ParameterNameMaxLength"] = 0;                  // A regular expression that matches the valid parameter names                  row["ParameterNamePattern"] = "";                  // A regular expression that matches a quoted identifier and has a match value of the identifier itself without the quotes.                   // For example' if the data source used double-quotes to identify quoted identifiers' this would be: "(([^\"]|\"\")*)".                  row["QuotedIdentifierPattern"] = "\"([^\"]*)\"";                  // Indicates whether quoted identifiers are treated as case sensitive or not.                  row["QuotedIdentifierCase"] = IdentifierCase.Sensitive;                  // A regular expression that matches the statement separator.                  row["StatementSeparatorPattern"] = ";";                  // A regular expression that matches a string literal and has a match value of the literal itself.                   // For example' if the data source used single-quotes to identify strings' this would be: "('([^']|'')*')"'                  row["StringLiteralPattern"] = "'([^']*)'";                  // Specifies what types of SQL join statements are supported by the data source.                  row["SupportedJoinOperators"] = SupportedJoinOperators.None;                  table.Rows.Add(row);                  table.EndLoadData();              }              else if (collectionName == DbMetaDataCollectionNames.ReservedWords)              {                  table.Columns.Add("ReservedWord"' typeof(string));                  table.Columns.Add("MaximumVersion"' typeof(string));                  table.Columns.Add("MinimumVersion"' typeof(string));                    string[] words = { "select"' "Add field"' "Drop field"' "Alter table"' "Alter field"'                                      "Alter user"' "And"' "Or"' "Not"' "Create Index"' "Upgrade"' "Unique"'                                      "Table key"' "Table unique key"' "Primary Key"' "Create Table"'                                      "Upgrade Table"' "Rename Table"' "Create View"' "Upgrade View"'                                      "Drop View"' "Create Schema"' "Drop Schema"' "Integer"' "Smallint"'                                      "Bigint"' "Tinyint"' "float"' "double"' "Blob"' "bytes"' "boolean"'                                      "binary"' "varbinary"' "string"' "char"' "text"' "date"' "timestamp"'                                      "time"' "varchar"' "numeric"' "Decimal Number"' "Enum"' "Delete"' "Repair"'                                      "Field"' "Not Null"' "Default Value"' "searchable"' "not searchable"'                                      "collation"' "character_set"' "Foreign Key"' "Identifier"' "record number"'                                      "Insert"' "Replace"' "Name"' "Number"' "Order"' "Descending"' "limit"'                                      "Quoted String"' "Select Clause"' "Distinct"' "Gtr"' "Geq"' "Eql"'                                      "Leq"' "Lss"' "Neq"' "in list"' "in select"' "exists"' "Between"' "Like"'                                      "starts with"' "Containing"' "Matching"' "Regular expression"' "Null"'                                      "True"' "False"' "Execute"' "Parameter"' "Count"' "sum"' "min"' "max"'                                      "avg"' "Drop Index"' "Drop primary key"' "Drop foreign key"' "Drop Table"'                                      "If Exists"' "Describe"' "Statement"' "for_select"' "for_insert"' "while"'                                      "if then else"' "variable"' "declaration"' "throw"' "assignment"'                                      "Start transaction"' "read only"' "read write"' "read committed"' "write committed"'                                      "read uncommitted"' "repeatableread"' "serializable"' "Commit"' "Rollback"'                                      "Savepoint"' "Rollack Savepoint"' "Release Savepoint"' "Table"' "Derived Table"'                                      "Assign"' "Update"' "list"' "Constant"' "Function"' "Grant"' "Grant role"' "Alter"'                                      "Read"' "Identity"' "Check"' "Constraint"' "value constraint"' "auto increment"'                                      "generated"' "always"' "Domain"' "is null"' "is active_role"' "start with"' "reindex"'                                      "cursor"' "alias"' "push_namespace"' "pop_namespace"' "set_namespace"' "coalesce"'                                      "nod_nullif"' "case"' "case_search"' "add"' "subtract"' "multiply"' "divide"' "modulus"'                                      "negate"' "plus"' "cast"' "concatenation"' "create user"' "drop user"' "create role"'                                      "upgrade role"' "drop role"' "revoke"' "revoke role"' "assume"' "revert"' "negate"'                                      "priv insert"' "priv delete"' "priv execute"' "priv select"' "priv update"' "priv grant"'                                      "priv all"' "characters"' "octets"' "role"' "view"' "procedure"' "user"' "zone"' "admin"'                                      "default role"' "create sequence"' "upgrade sequence"' "drop sequence"' "next value"'                                      "create trigger"' "upgrade trigger"' "alter trigger"' "drop trigger"' "create procedure"'                                      "upgrade procedure"' "alter procedure"' "drop procedure"' "pre-insert"' "post-insert"'                                      "pre-update"' "post-update"' "pre-delete"' "post-delete"' "pre-commit"' "post-commit"'                                      "active"' "inactive"' "position"' "select-expr"' "create filterset"' "upgrade filterset"'                                      "drop filterset"' "enable filterset"' "disable filterset"' "table filter"' "left outer"'                                      "right outer"' "full outer"' "inner"' "join"' "join_term"' "trigger class"' "enable trigger class"'                                      "disable trigger class"' "create zone"' "upgrade zone"' "drop zone"' "range"' "ip address"'                                      "node_name"' "wildcard"' "create domain"' "upgrade domain"' "alter domain"' "upgrade schema"'                                      "delete cascade"' "index segment"' "for update"' "write committed"' "read committed"'                                       "consistent read"' "set dialect"' "set names"' "restrict"' "cascade"' "characters"' "octets"'                                      "create event"' "collate"' "truncate"' "restart"' "nameless constraint"' "drop constraint"'                                      "drop unique constraint"' "drop domain"' "with check option"' "not real"' "lower"' "upper"'                                      "substr"' "substring index"' "charlength"' "default keyword"' "sqrt"' "power"' "Scientific Notation Number"'                                      "Explain"' "msleep"' "KillStatement"' "now" };                  table.BeginLoadData();                  foreach (string keyword in words)                  {                      DataRow row = table.NewRow();                      row["ReservedWord"] = keyword;                      table.Rows.Add(row);                  }                  table.EndLoadData();                }              else if (collectionName == DbMetaDataCollectionNames.DataTypes)              {                  table.Columns.Add("TypeName"' typeof(string));  // The provider-specific data type name.                  table.Columns.Add("ProviderDbType"' typeof(int)); // The provider-specific type value that should be used when specifying                   //a parameter's type. For example' SqlDbType.Money or OracleType.Blob.                  table.Columns.Add("ColumnSize"' typeof(long));                  table.Columns.Add("CreateFormat"' typeof(string));                  table.Columns.Add("CreateParameters"' typeof(string));                  table.Columns.Add("DataType"' typeof(string));  // The name of the .NET Framework type of the data type.                  table.Columns.Add("IsAutoincrementable"' typeof(bool));                  table.Columns.Add("IsBestMatch"' typeof(bool));                  table.Columns.Add("IsCaseSensitive"' typeof(bool));                  table.Columns.Add("IsFixedLength"' typeof(bool));                  table.Columns.Add("IsFixedPrecisionScale"' typeof(bool));                  table.Columns.Add("IsLong"' typeof(bool));                  table.Columns.Add("IsNullable"' typeof(bool));                  table.Columns.Add("IsSearchable"' typeof(bool));                  table.Columns.Add("IsSearchableWithLike"' typeof(bool));                  table.Columns.Add("IsUnsigned"' typeof(bool));                  table.Columns.Add("MaximumScale"' typeof(short));                  table.Columns.Add("MinimumScale"' typeof(short));                  table.Columns.Add("IsConcurrencyType"' typeof(bool));                  table.Columns.Add("IsLiteralsSupported"' typeof(bool));                  table.Columns.Add("LiteralPrefix"' typeof(string));                  table.Columns.Add("LiteralSuffix"' typeof(string));                  table.Columns.Add("NativeDataType"' typeof(string));    // NativeDataType is an OLE DB specific column for exposing the OLE DB type of the data type .                    table.ReadXml(XmlReader.Create(typeof(NuoDbConnectionInternal).Assembly.GetManifestResourceStream("NuoDb.Data.Client.DataTypes.xml")));              }              else if (collectionName == "Tables")              {                  table.Columns.Add("TABLE_CATALOG"' typeof(string));                  table.Columns.Add("TABLE_SCHEMA"' typeof(string));                  table.Columns.Add("TABLE_NAME"' typeof(string));                  table.Columns.Add("TABLE_TYPE"' typeof(string));                  table.Columns.Add("REMARKS"' typeof(string));                  table.Columns.Add("VIEW_DEF"' typeof(string));                    tmConn.InternalConnection.dataStream.startMessage(Protocol.GetTables);                  tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                  for (int i = 1; i < 3; i++)                      if (restrictionValues != null && restrictionValues.Length > i)                          tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                      else                          tmConn.InternalConnection.dataStream.encodeNull();                  if (restrictionValues == null || restrictionValues.Length < 4 || restrictionValues[3] == null)                      tmConn.InternalConnection.dataStream.encodeInt(0);                  else                  {                      tmConn.InternalConnection.dataStream.encodeInt(1);                      tmConn.InternalConnection.dataStream.encodeString(restrictionValues[3]);                  }                    tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                  int handle = tmConn.InternalConnection.dataStream.getInt();                    if (handle != -1)                  {                      using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                      {                          table.BeginLoadData();                          string view_def_label="";                          try                           {                               reader.GetOrdinal("VIEW_DEF");                              view_def_label = "VIEW_DEF";                          }                          catch(Exception) {}                          try                           {                               reader.GetOrdinal("VIEWDEFINITION");                              view_def_label = "VIEWDEFINITION";                          }                          catch (Exception) { }                          while (reader.Read())                          {  #if DEBUG                          System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_NAME"] + "' " + reader["TABLE_TYPE"]);  #endif                              DataRow row = table.NewRow();                              row["TABLE_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                              row["TABLE_NAME"] = reader.GetFieldValue<string>("TABLE_NAME");                              row["TABLE_TYPE"] = reader.GetFieldValue<string>("TABLE_TYPE");                              row["REMARKS"] = reader.GetFieldValue<string>("REMARKS");                              if (view_def_label.Length != 0)                              {                                  row["VIEW_DEF"] = reader.GetFieldValue<string>(view_def_label);                              }                              table.Rows.Add(row);                          }                          table.EndLoadData();                      }                  }              }              else if (collectionName == "Columns")              {                  table.Columns.Add("COLUMN_CATALOG"' typeof(string));                  table.Columns.Add("COLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("COLUMN_TABLE"' typeof(string));                  table.Columns.Add("COLUMN_NAME"' typeof(string));                  table.Columns.Add("COLUMN_POSITION"' typeof(int));                  table.Columns.Add("COLUMN_TYPE"' typeof(string));                  table.Columns.Add("COLUMN_LENGTH"' typeof(int));                  table.Columns.Add("COLUMN_PRECISION"' typeof(int));                  table.Columns.Add("COLUMN_NULLABLE"' typeof(bool));                  table.Columns.Add("COLUMN_IDENTITY"' typeof(bool));                  table.Columns.Add("COLUMN_DEFAULT"' typeof(string));                  table.Columns.Add("COLUMN_SCALE"' typeof(int));                    tmConn.InternalConnection.dataStream.startMessage(Protocol.GetColumns);                  tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                  for (int i = 1; i < 4; i++)                      if (restrictionValues != null && restrictionValues.Length > i)                          tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                      else                          tmConn.InternalConnection.dataStream.encodeNull();                    tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                  int handle = tmConn.InternalConnection.dataStream.getInt();                    if (handle != -1)                  {                      using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                      {                          table.BeginLoadData();                          while (reader.Read())                          {                              DataRow row = table.NewRow();                              row["COLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                              row["COLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                              row["COLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                              row["COLUMN_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                              row["COLUMN_LENGTH"] = reader.GetFieldValue<int>("COLUMN_SIZE");                              row["COLUMN_PRECISION"] = reader.GetFieldValue<int>("BUFFER_LENGTH");                              row["COLUMN_SCALE"] = reader.GetFieldValue<int>("DECIMAL_DIGITS");                              if (isNumeric(reader.GetFieldValue<string>("TYPE_NAME")))                              {                                  if (reader.GetFieldValue<int>("DECIMAL_DIGITS") != 0)                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME") +                                           "(" + reader.GetFieldValue<int>("BUFFER_LENGTH") + "'" + reader.GetFieldValue<int>("DECIMAL_DIGITS") + ")";                                  else                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME");                              }                              else                              {                                  if (isVarLenType(reader.GetFieldValue<string>("TYPE_NAME")) && reader.GetFieldValue<int>("COLUMN_SIZE") != 0)                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME") +                                           "(" + reader.GetFieldValue<int>("COLUMN_SIZE") + ")";                                  else                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME");                              }                              if (!reader.IsDBNull(reader.GetOrdinal("IS_NULLABLE")))                                  row["COLUMN_NULLABLE"] = reader.GetFieldValue<string>("IS_NULLABLE").Equals("YES");                              if (!reader.IsDBNull(reader.GetOrdinal("IS_AUTOINCREMENT")))                                  row["COLUMN_IDENTITY"] = reader.GetFieldValue<string>("IS_AUTOINCREMENT").Equals("YES");                              row["COLUMN_DEFAULT"] = reader.GetFieldValue<string>("COLUMN_DEF");    #if DEBUG                              System.Diagnostics.Trace.WriteLine("-> " + row["COLUMN_NAME"] + " " + row["COLUMN_TYPE"]);  #endif                              table.Rows.Add(row);                          }                          table.EndLoadData();                      }                  }              }              else if (collectionName == "Indexes")              {                  table.Columns.Add("INDEX_CATALOG"' typeof(string));                  table.Columns.Add("INDEX_SCHEMA"' typeof(string));                  table.Columns.Add("INDEX_TABLE"' typeof(string));                  table.Columns.Add("INDEX_NAME"' typeof(string));                  table.Columns.Add("INDEX_TYPE"' typeof(string));                  table.Columns.Add("INDEX_UNIQUE"' typeof(bool));                  table.Columns.Add("INDEX_PRIMARY"' typeof(bool));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetIndexInfo);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // unique                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // approximate                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        // to avoid to insert the same index more than once                      HashSet<string> unique = new HashSet<string>();                      if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;                                  if (!unique.Add(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;                                  DataRow row = table.NewRow();                                  row["INDEX_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEX_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEX_NAME"] = reader.GetFieldValue<string>("INDEX_NAME");                                  switch (reader.GetFieldValue<int>("TYPE"))                                  {                                      case 0:                                          row["INDEX_TYPE"] = "Primary";                                          break;                                      case 1:                                          row["INDEX_TYPE"] = "Unique";                                          break;                                      case 2:                                          row["INDEX_TYPE"] = "Secondary";                                          break;                                      case 3:                                          row["INDEX_TYPE"] = "Foreign Key";                                          break;                                  }                                  row["INDEX_UNIQUE"] = (reader.GetFieldValue<int>("NON_UNIQUE") == 0) ? true : false;                                  row["INDEX_PRIMARY"] = (reader.GetFieldValue<int>("TYPE") == 0) ? true : false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                        tmConn.InternalConnection.dataStream.startMessage(Protocol.GetPrimaryKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              // use INDEX_NAME' if present; if missing' the name of the index is in PK_NAME                              string indexName = "PK_NAME";                              foreach (string column in reader.columnNames)                              {                                  if (column == "INDEX_NAME")                                  {                                      indexName = "INDEX_NAME";                                      break;                                  }                              }                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>(indexName)))                                      continue;                                  if (!unique.Add(reader.GetFieldValue<string>(indexName)))                                      continue;                                  DataRow row = table.NewRow();                                  row["INDEX_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEX_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEX_NAME"] = reader.GetFieldValue<string>(indexName);                                  row["INDEX_TYPE"] = "Primary";                                  row["INDEX_UNIQUE"] = true;                                  row["INDEX_PRIMARY"] = true;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "IndexColumns")              {                  table.Columns.Add("INDEXCOLUMN_CATALOG"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_TABLE"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_INDEX"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_NAME"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_POSITION"' typeof(int));                  table.Columns.Add("INDEXCOLUMN_ISPRIMARY"' typeof(bool));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetIndexInfo);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // unique                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // approximate                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_SCHEM"] + "." + reader["TABLE_NAME"] + "=" + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["INDEXCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEXCOLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEXCOLUMN_INDEX"] = reader.GetFieldValue<string>("INDEX_NAME");                                  row["INDEXCOLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["INDEXCOLUMN_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                                  row["INDEXCOLUMN_ISPRIMARY"] = false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                        tmConn.InternalConnection.dataStream.startMessage(Protocol.GetPrimaryKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              // use INDEX_NAME' if present; if missing' the name of the index is in PK_NAME                              string indexName = "PK_NAME";                              foreach (string column in reader.columnNames)                              {                                  if (column == "INDEX_NAME")                                  {                                      indexName = "INDEX_NAME";                                      break;                                  }                              }                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>(indexName)))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_SCHEM"] + "." + reader["TABLE_NAME"] + " (Primary) =" + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["INDEXCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEXCOLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEXCOLUMN_INDEX"] = reader.GetFieldValue<string>(indexName);                                  row["INDEXCOLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["INDEXCOLUMN_POSITION"] = reader.GetFieldValue<int>("KEY_SEQ");                                  row["INDEXCOLUMN_ISPRIMARY"] = true;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ForeignKeys")              {                  table.Columns.Add("FOREIGNKEY_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEY_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEY_TABLE"' typeof(string));                  table.Columns.Add("FOREIGNKEY_NAME"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_TABLE"' typeof(string));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetImportedKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  string name = "[" + reader.GetFieldValue<string>("FKTABLE_SCHEM") + "]" +                                                   reader.GetFieldValue<string>("FKTABLE_NAME") + "." +                                                   reader.GetFieldValue<string>("FKCOLUMN_NAME") + "->" +                                                  "[" + reader.GetFieldValue<string>("PKTABLE_SCHEM") + "]" +                                                   reader.GetFieldValue<string>("PKTABLE_NAME") + "." +                                                   reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(name))                                      continue;                                  DataRow row = table.NewRow();                                  row["FOREIGNKEY_SCHEMA"] = reader.GetFieldValue<string>("FKTABLE_SCHEM");                                  row["FOREIGNKEY_TABLE"] = reader.GetFieldValue<string>("FKTABLE_NAME");                                  row["FOREIGNKEY_NAME"] = name;                                  row["FOREIGNKEY_OTHER_SCHEMA"] = reader.GetFieldValue<string>("PKTABLE_SCHEM");                                  row["FOREIGNKEY_OTHER_TABLE"] = reader.GetFieldValue<string>("PKTABLE_NAME");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ForeignKeyColumns")              {                  table.Columns.Add("FOREIGNKEYCOLUMN_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_TABLE"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_KEY"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_NAME"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_ORDINAL"' typeof(int));                  table.Columns.Add("FOREIGNKEYCOLUMN_OTHER_COLUMN_NAME"' typeof(string));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetImportedKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  string name = "[" + reader.GetFieldValue<string>("FKTABLE_SCHEM") + "]" +                                                  reader.GetFieldValue<string>("FKTABLE_NAME") + "." +                                                  reader.GetFieldValue<string>("FKCOLUMN_NAME") + "->" +                                                  "[" + reader.GetFieldValue<string>("PKTABLE_SCHEM") + "]" +                                                  reader.GetFieldValue<string>("PKTABLE_NAME") + "." +                                                  reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(name))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["FKTABLE_SCHEM"] + "." + reader["FKTABLE_NAME"] + "=" + reader["FKCOLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["FOREIGNKEYCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("FKTABLE_SCHEM");                                  row["FOREIGNKEYCOLUMN_TABLE"] = reader.GetFieldValue<string>("FKTABLE_NAME");                                  row["FOREIGNKEYCOLUMN_KEY"] = name;                                  row["FOREIGNKEYCOLUMN_NAME"] = reader.GetFieldValue<string>("FKCOLUMN_NAME");                                  row["FOREIGNKEYCOLUMN_ORDINAL"] = reader.GetFieldValue<int>("KEY_SEQ");                                  row["FOREIGNKEYCOLUMN_OTHER_COLUMN_NAME"] = reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "Procedures")               {                  table.Columns.Add("PROCEDURE_CATALOG"' typeof(string));                  table.Columns.Add("PROCEDURE_SCHEMA"' typeof(string));                  table.Columns.Add("PROCEDURE_NAME"' typeof(string));                  table.Columns.Add("IS_SYSTEM_PROCEDURE"' typeof(bool));                    if (tmConn.InternalConnection.protocolVersion >= Protocol.PROTOCOL_VERSION12)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetProcedures);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      for (int i = 1; i < 3; i++)                          if (restrictionValues != null && restrictionValues.Length > i)                              tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                          else                              tmConn.InternalConnection.dataStream.encodeNull();                        tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["PROCEDURE_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["PROCEDURE_SCHEMA"] = reader.GetFieldValue<string>("PROCEDURE_SCHEM");                                  row["PROCEDURE_NAME"] = reader.GetFieldValue<string>("PROCEDURE_NAME");                                  row["IS_SYSTEM_PROCEDURE"] = false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ProcedureParameters")              {                  table.Columns.Add("PROCEDURE_CATALOG"' typeof(string));                  table.Columns.Add("PROCEDURE_SCHEMA"' typeof(string));                  table.Columns.Add("PROCEDURE_NAME"' typeof(string));                  table.Columns.Add("PARAMETER_NAME"' typeof(string));                  table.Columns.Add("ORDINAL_POSITION"' typeof(int));                  table.Columns.Add("PARAMETER_DATA_TYPE"' typeof(int));                  table.Columns.Add("PARAMETER_TYPE_NAME"' typeof(string));                  table.Columns.Add("PARAMETER_SIZE"' typeof(int));                  table.Columns.Add("NUMERIC_PRECISION"' typeof(int));                  table.Columns.Add("NUMERIC_SCALE"' typeof(int));                  table.Columns.Add("PARAMETER_DIRECTION"' typeof(int));                  table.Columns.Add("IS_NULLABLE"' typeof(bool));                    if (tmConn.InternalConnection.protocolVersion >= Protocol.PROTOCOL_VERSION12)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetProcedureColumns);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      for (int i = 1; i < 4; i++)                          if (restrictionValues != null && restrictionValues.Length > i)                              tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                          else                              tmConn.InternalConnection.dataStream.encodeNull();                        tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["PROCEDURE_NAME"] + "' " + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["PROCEDURE_SCHEMA"] = reader.GetFieldValue<string>("PROCEDURE_SCHEM");                                  row["PROCEDURE_NAME"] = reader.GetFieldValue<string>("PROCEDURE_NAME");                                  row["PARAMETER_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["ORDINAL_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                                  row["PARAMETER_TYPE_NAME"] = reader.GetFieldValue<string>("TYPE_NAME");                                  row["PARAMETER_DATA_TYPE"] = reader.GetFieldValue<int>("DATA_TYPE");                                  row["PARAMETER_SIZE"] = reader.GetFieldValue<int>("LENGTH");                                  row["NUMERIC_PRECISION"] = reader.GetFieldValue<int>("PRECISION");                                  row["NUMERIC_SCALE"] = reader.GetFieldValue<int>("SCALE");                                  row["PARAMETER_DIRECTION"] = reader.GetFieldValue<int>("COLUMN_TYPE");                                  row["IS_NULLABLE"] = !reader.GetFieldValue<string>("IS_NULLABLE").Equals("NO");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The following statement contains a magic number: if (collectionName == DbMetaDataCollectionNames.DataSourceInformation)              {                  // see http://msdn.microsoft.com/en-us/library/ms254501.aspx                  table.Columns.Add("CompositeIdentifierSeparatorPattern"' typeof(string));                  table.Columns.Add("DataSourceProductName"' typeof(string));                  table.Columns.Add("DataSourceProductVersion"' typeof(string));                  table.Columns.Add("DataSourceProductVersionNormalized"' typeof(string));                  table.Columns.Add("DataSourceInternalProductVersion"' typeof(string));                  table.Columns.Add("GroupByBehavior"' typeof(GroupByBehavior));                  table.Columns.Add("IdentifierPattern"' typeof(string));                  table.Columns.Add("IdentifierCase"' typeof(IdentifierCase));                  table.Columns.Add("OrderByColumnsInSelect"' typeof(bool));                  table.Columns.Add("ParameterMarkerFormat"' typeof(string));                  table.Columns.Add("ParameterMarkerPattern"' typeof(string));                  table.Columns.Add("ParameterNameMaxLength"' typeof(int));                  table.Columns.Add("ParameterNamePattern"' typeof(string));                  table.Columns.Add("QuotedIdentifierPattern"' typeof(string));  // Regex                  table.Columns.Add("QuotedIdentifierCase"' typeof(int));                  table.Columns.Add("StatementSeparatorPattern"' typeof(string));                  table.Columns.Add("StringLiteralPattern"' typeof(string));  // Regex                  table.Columns.Add("SupportedJoinOperators"' typeof(SupportedJoinOperators));                    table.BeginLoadData();                  DataRow row = table.NewRow();                  int databaseMajorVersion = 0' databaseMinorVersion = 0;                  try                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetDatabaseMetaData);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      for (int item; (item = tmConn.InternalConnection.dataStream.getInt()) != Protocol.DbmbFini; )                      {                          switch (item)                          {                              case Protocol.DbmbProductName:                                  row["DataSourceProductName"] = tmConn.InternalConnection.dataStream.getString();                                  break;                                case Protocol.DbmbProductVersion:                                  row["DataSourceProductVersion"] = tmConn.InternalConnection.dataStream.getString();                                  break;                                case Protocol.DbmbDatabaseMinorVersion:                                  databaseMinorVersion = tmConn.InternalConnection.dataStream.getInt();                                  break;                                case Protocol.DbmbDatabaseMajorVersion:                                  databaseMajorVersion = tmConn.InternalConnection.dataStream.getInt();                                  break;                                case Protocol.DbmbDefaultTransactionIsolation:                                  int defaultTransactionIsolation = tmConn.InternalConnection.dataStream.getInt();                                  break;                                default:                                  tmConn.InternalConnection.dataStream.decode();                                  break;                          }                      }                  }                  catch (Exception)                  {                  }                    row["DataSourceInternalProductVersion"] = String.Format("{0:D3}.{1:D3}"' databaseMajorVersion' databaseMinorVersion);                  // The regular expression to match the composite separators in a composite identifier.                   // For example' "\." (for SQL Server) or "@|\." (for Oracle).                  // A composite identifier is typically what is used for a database object name'                   // for example: pubs.dbo.authors or pubs@dbo.authors.                  row["CompositeIdentifierSeparatorPattern"] = "\\.";                  // A normalized version for the data source' such that it can be compared with String.Compare().                   // The format of this is consistent for all versions of the provider to prevent version 10 from sorting between version 1 and version 2.                  //row["DataSourceProductVersionNormalized"] = ??                  // Specifies the relationship between the columns in a GROUP BY clause and the non-aggregated columns in the select list.                  row["GroupByBehavior"] = GroupByBehavior.Unknown;                  // A regular expression that matches an identifier and has a match value of the identifier. For example "[A-Za-z0-9_#$]".                  row["IdentifierPattern"] = "(^\\[\\p{Lo}\\p{Lu}\\p{Ll}_@#][\\p{Lo}\\p{Lu}\\p{Ll}\\p{Nd}@$#_]*$)|(^\"[^\"\\0]|\"\"+\"$)";                  // Indicates whether non-quoted identifiers are treated as case sensitive or not.                  row["IdentifierCase"] = IdentifierCase.Insensitive;                  // Specifies whether columns in an ORDER BY clause must be in the select list.                   // A value of true indicates that they are required to be in the select list'                   // a value of false indicates that they are not required to be in the select list.                  row["OrderByColumnsInSelect"] = false;                  // For data sources that do not expect named parameters and expect the use of the ‘?’ character' the format string                  // can be specified as simply '?'' which would ignore the parameter name.                  row["ParameterMarkerFormat"] = "?";                  // if the data source doesn't support named parameters' this would simply be "?".                  row["ParameterMarkerPattern"] = "?";                  // If the data source does not support named parameters' this property returns zero.                  row["ParameterNameMaxLength"] = 0;                  // A regular expression that matches the valid parameter names                  row["ParameterNamePattern"] = "";                  // A regular expression that matches a quoted identifier and has a match value of the identifier itself without the quotes.                   // For example' if the data source used double-quotes to identify quoted identifiers' this would be: "(([^\"]|\"\")*)".                  row["QuotedIdentifierPattern"] = "\"([^\"]*)\"";                  // Indicates whether quoted identifiers are treated as case sensitive or not.                  row["QuotedIdentifierCase"] = IdentifierCase.Sensitive;                  // A regular expression that matches the statement separator.                  row["StatementSeparatorPattern"] = ";";                  // A regular expression that matches a string literal and has a match value of the literal itself.                   // For example' if the data source used single-quotes to identify strings' this would be: "('([^']|'')*')"'                  row["StringLiteralPattern"] = "'([^']*)'";                  // Specifies what types of SQL join statements are supported by the data source.                  row["SupportedJoinOperators"] = SupportedJoinOperators.None;                  table.Rows.Add(row);                  table.EndLoadData();              }              else if (collectionName == DbMetaDataCollectionNames.ReservedWords)              {                  table.Columns.Add("ReservedWord"' typeof(string));                  table.Columns.Add("MaximumVersion"' typeof(string));                  table.Columns.Add("MinimumVersion"' typeof(string));                    string[] words = { "select"' "Add field"' "Drop field"' "Alter table"' "Alter field"'                                      "Alter user"' "And"' "Or"' "Not"' "Create Index"' "Upgrade"' "Unique"'                                      "Table key"' "Table unique key"' "Primary Key"' "Create Table"'                                      "Upgrade Table"' "Rename Table"' "Create View"' "Upgrade View"'                                      "Drop View"' "Create Schema"' "Drop Schema"' "Integer"' "Smallint"'                                      "Bigint"' "Tinyint"' "float"' "double"' "Blob"' "bytes"' "boolean"'                                      "binary"' "varbinary"' "string"' "char"' "text"' "date"' "timestamp"'                                      "time"' "varchar"' "numeric"' "Decimal Number"' "Enum"' "Delete"' "Repair"'                                      "Field"' "Not Null"' "Default Value"' "searchable"' "not searchable"'                                      "collation"' "character_set"' "Foreign Key"' "Identifier"' "record number"'                                      "Insert"' "Replace"' "Name"' "Number"' "Order"' "Descending"' "limit"'                                      "Quoted String"' "Select Clause"' "Distinct"' "Gtr"' "Geq"' "Eql"'                                      "Leq"' "Lss"' "Neq"' "in list"' "in select"' "exists"' "Between"' "Like"'                                      "starts with"' "Containing"' "Matching"' "Regular expression"' "Null"'                                      "True"' "False"' "Execute"' "Parameter"' "Count"' "sum"' "min"' "max"'                                      "avg"' "Drop Index"' "Drop primary key"' "Drop foreign key"' "Drop Table"'                                      "If Exists"' "Describe"' "Statement"' "for_select"' "for_insert"' "while"'                                      "if then else"' "variable"' "declaration"' "throw"' "assignment"'                                      "Start transaction"' "read only"' "read write"' "read committed"' "write committed"'                                      "read uncommitted"' "repeatableread"' "serializable"' "Commit"' "Rollback"'                                      "Savepoint"' "Rollack Savepoint"' "Release Savepoint"' "Table"' "Derived Table"'                                      "Assign"' "Update"' "list"' "Constant"' "Function"' "Grant"' "Grant role"' "Alter"'                                      "Read"' "Identity"' "Check"' "Constraint"' "value constraint"' "auto increment"'                                      "generated"' "always"' "Domain"' "is null"' "is active_role"' "start with"' "reindex"'                                      "cursor"' "alias"' "push_namespace"' "pop_namespace"' "set_namespace"' "coalesce"'                                      "nod_nullif"' "case"' "case_search"' "add"' "subtract"' "multiply"' "divide"' "modulus"'                                      "negate"' "plus"' "cast"' "concatenation"' "create user"' "drop user"' "create role"'                                      "upgrade role"' "drop role"' "revoke"' "revoke role"' "assume"' "revert"' "negate"'                                      "priv insert"' "priv delete"' "priv execute"' "priv select"' "priv update"' "priv grant"'                                      "priv all"' "characters"' "octets"' "role"' "view"' "procedure"' "user"' "zone"' "admin"'                                      "default role"' "create sequence"' "upgrade sequence"' "drop sequence"' "next value"'                                      "create trigger"' "upgrade trigger"' "alter trigger"' "drop trigger"' "create procedure"'                                      "upgrade procedure"' "alter procedure"' "drop procedure"' "pre-insert"' "post-insert"'                                      "pre-update"' "post-update"' "pre-delete"' "post-delete"' "pre-commit"' "post-commit"'                                      "active"' "inactive"' "position"' "select-expr"' "create filterset"' "upgrade filterset"'                                      "drop filterset"' "enable filterset"' "disable filterset"' "table filter"' "left outer"'                                      "right outer"' "full outer"' "inner"' "join"' "join_term"' "trigger class"' "enable trigger class"'                                      "disable trigger class"' "create zone"' "upgrade zone"' "drop zone"' "range"' "ip address"'                                      "node_name"' "wildcard"' "create domain"' "upgrade domain"' "alter domain"' "upgrade schema"'                                      "delete cascade"' "index segment"' "for update"' "write committed"' "read committed"'                                       "consistent read"' "set dialect"' "set names"' "restrict"' "cascade"' "characters"' "octets"'                                      "create event"' "collate"' "truncate"' "restart"' "nameless constraint"' "drop constraint"'                                      "drop unique constraint"' "drop domain"' "with check option"' "not real"' "lower"' "upper"'                                      "substr"' "substring index"' "charlength"' "default keyword"' "sqrt"' "power"' "Scientific Notation Number"'                                      "Explain"' "msleep"' "KillStatement"' "now" };                  table.BeginLoadData();                  foreach (string keyword in words)                  {                      DataRow row = table.NewRow();                      row["ReservedWord"] = keyword;                      table.Rows.Add(row);                  }                  table.EndLoadData();                }              else if (collectionName == DbMetaDataCollectionNames.DataTypes)              {                  table.Columns.Add("TypeName"' typeof(string));  // The provider-specific data type name.                  table.Columns.Add("ProviderDbType"' typeof(int)); // The provider-specific type value that should be used when specifying                   //a parameter's type. For example' SqlDbType.Money or OracleType.Blob.                  table.Columns.Add("ColumnSize"' typeof(long));                  table.Columns.Add("CreateFormat"' typeof(string));                  table.Columns.Add("CreateParameters"' typeof(string));                  table.Columns.Add("DataType"' typeof(string));  // The name of the .NET Framework type of the data type.                  table.Columns.Add("IsAutoincrementable"' typeof(bool));                  table.Columns.Add("IsBestMatch"' typeof(bool));                  table.Columns.Add("IsCaseSensitive"' typeof(bool));                  table.Columns.Add("IsFixedLength"' typeof(bool));                  table.Columns.Add("IsFixedPrecisionScale"' typeof(bool));                  table.Columns.Add("IsLong"' typeof(bool));                  table.Columns.Add("IsNullable"' typeof(bool));                  table.Columns.Add("IsSearchable"' typeof(bool));                  table.Columns.Add("IsSearchableWithLike"' typeof(bool));                  table.Columns.Add("IsUnsigned"' typeof(bool));                  table.Columns.Add("MaximumScale"' typeof(short));                  table.Columns.Add("MinimumScale"' typeof(short));                  table.Columns.Add("IsConcurrencyType"' typeof(bool));                  table.Columns.Add("IsLiteralsSupported"' typeof(bool));                  table.Columns.Add("LiteralPrefix"' typeof(string));                  table.Columns.Add("LiteralSuffix"' typeof(string));                  table.Columns.Add("NativeDataType"' typeof(string));    // NativeDataType is an OLE DB specific column for exposing the OLE DB type of the data type .                    table.ReadXml(XmlReader.Create(typeof(NuoDbConnectionInternal).Assembly.GetManifestResourceStream("NuoDb.Data.Client.DataTypes.xml")));              }              else if (collectionName == "Tables")              {                  table.Columns.Add("TABLE_CATALOG"' typeof(string));                  table.Columns.Add("TABLE_SCHEMA"' typeof(string));                  table.Columns.Add("TABLE_NAME"' typeof(string));                  table.Columns.Add("TABLE_TYPE"' typeof(string));                  table.Columns.Add("REMARKS"' typeof(string));                  table.Columns.Add("VIEW_DEF"' typeof(string));                    tmConn.InternalConnection.dataStream.startMessage(Protocol.GetTables);                  tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                  for (int i = 1; i < 3; i++)                      if (restrictionValues != null && restrictionValues.Length > i)                          tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                      else                          tmConn.InternalConnection.dataStream.encodeNull();                  if (restrictionValues == null || restrictionValues.Length < 4 || restrictionValues[3] == null)                      tmConn.InternalConnection.dataStream.encodeInt(0);                  else                  {                      tmConn.InternalConnection.dataStream.encodeInt(1);                      tmConn.InternalConnection.dataStream.encodeString(restrictionValues[3]);                  }                    tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                  int handle = tmConn.InternalConnection.dataStream.getInt();                    if (handle != -1)                  {                      using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                      {                          table.BeginLoadData();                          string view_def_label="";                          try                           {                               reader.GetOrdinal("VIEW_DEF");                              view_def_label = "VIEW_DEF";                          }                          catch(Exception) {}                          try                           {                               reader.GetOrdinal("VIEWDEFINITION");                              view_def_label = "VIEWDEFINITION";                          }                          catch (Exception) { }                          while (reader.Read())                          {  #if DEBUG                          System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_NAME"] + "' " + reader["TABLE_TYPE"]);  #endif                              DataRow row = table.NewRow();                              row["TABLE_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                              row["TABLE_NAME"] = reader.GetFieldValue<string>("TABLE_NAME");                              row["TABLE_TYPE"] = reader.GetFieldValue<string>("TABLE_TYPE");                              row["REMARKS"] = reader.GetFieldValue<string>("REMARKS");                              if (view_def_label.Length != 0)                              {                                  row["VIEW_DEF"] = reader.GetFieldValue<string>(view_def_label);                              }                              table.Rows.Add(row);                          }                          table.EndLoadData();                      }                  }              }              else if (collectionName == "Columns")              {                  table.Columns.Add("COLUMN_CATALOG"' typeof(string));                  table.Columns.Add("COLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("COLUMN_TABLE"' typeof(string));                  table.Columns.Add("COLUMN_NAME"' typeof(string));                  table.Columns.Add("COLUMN_POSITION"' typeof(int));                  table.Columns.Add("COLUMN_TYPE"' typeof(string));                  table.Columns.Add("COLUMN_LENGTH"' typeof(int));                  table.Columns.Add("COLUMN_PRECISION"' typeof(int));                  table.Columns.Add("COLUMN_NULLABLE"' typeof(bool));                  table.Columns.Add("COLUMN_IDENTITY"' typeof(bool));                  table.Columns.Add("COLUMN_DEFAULT"' typeof(string));                  table.Columns.Add("COLUMN_SCALE"' typeof(int));                    tmConn.InternalConnection.dataStream.startMessage(Protocol.GetColumns);                  tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                  for (int i = 1; i < 4; i++)                      if (restrictionValues != null && restrictionValues.Length > i)                          tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                      else                          tmConn.InternalConnection.dataStream.encodeNull();                    tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                  int handle = tmConn.InternalConnection.dataStream.getInt();                    if (handle != -1)                  {                      using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                      {                          table.BeginLoadData();                          while (reader.Read())                          {                              DataRow row = table.NewRow();                              row["COLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                              row["COLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                              row["COLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                              row["COLUMN_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                              row["COLUMN_LENGTH"] = reader.GetFieldValue<int>("COLUMN_SIZE");                              row["COLUMN_PRECISION"] = reader.GetFieldValue<int>("BUFFER_LENGTH");                              row["COLUMN_SCALE"] = reader.GetFieldValue<int>("DECIMAL_DIGITS");                              if (isNumeric(reader.GetFieldValue<string>("TYPE_NAME")))                              {                                  if (reader.GetFieldValue<int>("DECIMAL_DIGITS") != 0)                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME") +                                           "(" + reader.GetFieldValue<int>("BUFFER_LENGTH") + "'" + reader.GetFieldValue<int>("DECIMAL_DIGITS") + ")";                                  else                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME");                              }                              else                              {                                  if (isVarLenType(reader.GetFieldValue<string>("TYPE_NAME")) && reader.GetFieldValue<int>("COLUMN_SIZE") != 0)                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME") +                                           "(" + reader.GetFieldValue<int>("COLUMN_SIZE") + ")";                                  else                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME");                              }                              if (!reader.IsDBNull(reader.GetOrdinal("IS_NULLABLE")))                                  row["COLUMN_NULLABLE"] = reader.GetFieldValue<string>("IS_NULLABLE").Equals("YES");                              if (!reader.IsDBNull(reader.GetOrdinal("IS_AUTOINCREMENT")))                                  row["COLUMN_IDENTITY"] = reader.GetFieldValue<string>("IS_AUTOINCREMENT").Equals("YES");                              row["COLUMN_DEFAULT"] = reader.GetFieldValue<string>("COLUMN_DEF");    #if DEBUG                              System.Diagnostics.Trace.WriteLine("-> " + row["COLUMN_NAME"] + " " + row["COLUMN_TYPE"]);  #endif                              table.Rows.Add(row);                          }                          table.EndLoadData();                      }                  }              }              else if (collectionName == "Indexes")              {                  table.Columns.Add("INDEX_CATALOG"' typeof(string));                  table.Columns.Add("INDEX_SCHEMA"' typeof(string));                  table.Columns.Add("INDEX_TABLE"' typeof(string));                  table.Columns.Add("INDEX_NAME"' typeof(string));                  table.Columns.Add("INDEX_TYPE"' typeof(string));                  table.Columns.Add("INDEX_UNIQUE"' typeof(bool));                  table.Columns.Add("INDEX_PRIMARY"' typeof(bool));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetIndexInfo);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // unique                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // approximate                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        // to avoid to insert the same index more than once                      HashSet<string> unique = new HashSet<string>();                      if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;                                  if (!unique.Add(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;                                  DataRow row = table.NewRow();                                  row["INDEX_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEX_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEX_NAME"] = reader.GetFieldValue<string>("INDEX_NAME");                                  switch (reader.GetFieldValue<int>("TYPE"))                                  {                                      case 0:                                          row["INDEX_TYPE"] = "Primary";                                          break;                                      case 1:                                          row["INDEX_TYPE"] = "Unique";                                          break;                                      case 2:                                          row["INDEX_TYPE"] = "Secondary";                                          break;                                      case 3:                                          row["INDEX_TYPE"] = "Foreign Key";                                          break;                                  }                                  row["INDEX_UNIQUE"] = (reader.GetFieldValue<int>("NON_UNIQUE") == 0) ? true : false;                                  row["INDEX_PRIMARY"] = (reader.GetFieldValue<int>("TYPE") == 0) ? true : false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                        tmConn.InternalConnection.dataStream.startMessage(Protocol.GetPrimaryKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              // use INDEX_NAME' if present; if missing' the name of the index is in PK_NAME                              string indexName = "PK_NAME";                              foreach (string column in reader.columnNames)                              {                                  if (column == "INDEX_NAME")                                  {                                      indexName = "INDEX_NAME";                                      break;                                  }                              }                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>(indexName)))                                      continue;                                  if (!unique.Add(reader.GetFieldValue<string>(indexName)))                                      continue;                                  DataRow row = table.NewRow();                                  row["INDEX_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEX_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEX_NAME"] = reader.GetFieldValue<string>(indexName);                                  row["INDEX_TYPE"] = "Primary";                                  row["INDEX_UNIQUE"] = true;                                  row["INDEX_PRIMARY"] = true;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "IndexColumns")              {                  table.Columns.Add("INDEXCOLUMN_CATALOG"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_TABLE"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_INDEX"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_NAME"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_POSITION"' typeof(int));                  table.Columns.Add("INDEXCOLUMN_ISPRIMARY"' typeof(bool));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetIndexInfo);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // unique                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // approximate                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_SCHEM"] + "." + reader["TABLE_NAME"] + "=" + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["INDEXCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEXCOLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEXCOLUMN_INDEX"] = reader.GetFieldValue<string>("INDEX_NAME");                                  row["INDEXCOLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["INDEXCOLUMN_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                                  row["INDEXCOLUMN_ISPRIMARY"] = false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                        tmConn.InternalConnection.dataStream.startMessage(Protocol.GetPrimaryKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              // use INDEX_NAME' if present; if missing' the name of the index is in PK_NAME                              string indexName = "PK_NAME";                              foreach (string column in reader.columnNames)                              {                                  if (column == "INDEX_NAME")                                  {                                      indexName = "INDEX_NAME";                                      break;                                  }                              }                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>(indexName)))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_SCHEM"] + "." + reader["TABLE_NAME"] + " (Primary) =" + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["INDEXCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEXCOLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEXCOLUMN_INDEX"] = reader.GetFieldValue<string>(indexName);                                  row["INDEXCOLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["INDEXCOLUMN_POSITION"] = reader.GetFieldValue<int>("KEY_SEQ");                                  row["INDEXCOLUMN_ISPRIMARY"] = true;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ForeignKeys")              {                  table.Columns.Add("FOREIGNKEY_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEY_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEY_TABLE"' typeof(string));                  table.Columns.Add("FOREIGNKEY_NAME"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_TABLE"' typeof(string));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetImportedKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  string name = "[" + reader.GetFieldValue<string>("FKTABLE_SCHEM") + "]" +                                                   reader.GetFieldValue<string>("FKTABLE_NAME") + "." +                                                   reader.GetFieldValue<string>("FKCOLUMN_NAME") + "->" +                                                  "[" + reader.GetFieldValue<string>("PKTABLE_SCHEM") + "]" +                                                   reader.GetFieldValue<string>("PKTABLE_NAME") + "." +                                                   reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(name))                                      continue;                                  DataRow row = table.NewRow();                                  row["FOREIGNKEY_SCHEMA"] = reader.GetFieldValue<string>("FKTABLE_SCHEM");                                  row["FOREIGNKEY_TABLE"] = reader.GetFieldValue<string>("FKTABLE_NAME");                                  row["FOREIGNKEY_NAME"] = name;                                  row["FOREIGNKEY_OTHER_SCHEMA"] = reader.GetFieldValue<string>("PKTABLE_SCHEM");                                  row["FOREIGNKEY_OTHER_TABLE"] = reader.GetFieldValue<string>("PKTABLE_NAME");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ForeignKeyColumns")              {                  table.Columns.Add("FOREIGNKEYCOLUMN_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_TABLE"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_KEY"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_NAME"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_ORDINAL"' typeof(int));                  table.Columns.Add("FOREIGNKEYCOLUMN_OTHER_COLUMN_NAME"' typeof(string));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetImportedKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  string name = "[" + reader.GetFieldValue<string>("FKTABLE_SCHEM") + "]" +                                                  reader.GetFieldValue<string>("FKTABLE_NAME") + "." +                                                  reader.GetFieldValue<string>("FKCOLUMN_NAME") + "->" +                                                  "[" + reader.GetFieldValue<string>("PKTABLE_SCHEM") + "]" +                                                  reader.GetFieldValue<string>("PKTABLE_NAME") + "." +                                                  reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(name))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["FKTABLE_SCHEM"] + "." + reader["FKTABLE_NAME"] + "=" + reader["FKCOLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["FOREIGNKEYCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("FKTABLE_SCHEM");                                  row["FOREIGNKEYCOLUMN_TABLE"] = reader.GetFieldValue<string>("FKTABLE_NAME");                                  row["FOREIGNKEYCOLUMN_KEY"] = name;                                  row["FOREIGNKEYCOLUMN_NAME"] = reader.GetFieldValue<string>("FKCOLUMN_NAME");                                  row["FOREIGNKEYCOLUMN_ORDINAL"] = reader.GetFieldValue<int>("KEY_SEQ");                                  row["FOREIGNKEYCOLUMN_OTHER_COLUMN_NAME"] = reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "Procedures")               {                  table.Columns.Add("PROCEDURE_CATALOG"' typeof(string));                  table.Columns.Add("PROCEDURE_SCHEMA"' typeof(string));                  table.Columns.Add("PROCEDURE_NAME"' typeof(string));                  table.Columns.Add("IS_SYSTEM_PROCEDURE"' typeof(bool));                    if (tmConn.InternalConnection.protocolVersion >= Protocol.PROTOCOL_VERSION12)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetProcedures);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      for (int i = 1; i < 3; i++)                          if (restrictionValues != null && restrictionValues.Length > i)                              tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                          else                              tmConn.InternalConnection.dataStream.encodeNull();                        tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["PROCEDURE_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["PROCEDURE_SCHEMA"] = reader.GetFieldValue<string>("PROCEDURE_SCHEM");                                  row["PROCEDURE_NAME"] = reader.GetFieldValue<string>("PROCEDURE_NAME");                                  row["IS_SYSTEM_PROCEDURE"] = false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ProcedureParameters")              {                  table.Columns.Add("PROCEDURE_CATALOG"' typeof(string));                  table.Columns.Add("PROCEDURE_SCHEMA"' typeof(string));                  table.Columns.Add("PROCEDURE_NAME"' typeof(string));                  table.Columns.Add("PARAMETER_NAME"' typeof(string));                  table.Columns.Add("ORDINAL_POSITION"' typeof(int));                  table.Columns.Add("PARAMETER_DATA_TYPE"' typeof(int));                  table.Columns.Add("PARAMETER_TYPE_NAME"' typeof(string));                  table.Columns.Add("PARAMETER_SIZE"' typeof(int));                  table.Columns.Add("NUMERIC_PRECISION"' typeof(int));                  table.Columns.Add("NUMERIC_SCALE"' typeof(int));                  table.Columns.Add("PARAMETER_DIRECTION"' typeof(int));                  table.Columns.Add("IS_NULLABLE"' typeof(bool));                    if (tmConn.InternalConnection.protocolVersion >= Protocol.PROTOCOL_VERSION12)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetProcedureColumns);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      for (int i = 1; i < 4; i++)                          if (restrictionValues != null && restrictionValues.Length > i)                              tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                          else                              tmConn.InternalConnection.dataStream.encodeNull();                        tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["PROCEDURE_NAME"] + "' " + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["PROCEDURE_SCHEMA"] = reader.GetFieldValue<string>("PROCEDURE_SCHEM");                                  row["PROCEDURE_NAME"] = reader.GetFieldValue<string>("PROCEDURE_NAME");                                  row["PARAMETER_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["ORDINAL_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                                  row["PARAMETER_TYPE_NAME"] = reader.GetFieldValue<string>("TYPE_NAME");                                  row["PARAMETER_DATA_TYPE"] = reader.GetFieldValue<int>("DATA_TYPE");                                  row["PARAMETER_SIZE"] = reader.GetFieldValue<int>("LENGTH");                                  row["NUMERIC_PRECISION"] = reader.GetFieldValue<int>("PRECISION");                                  row["NUMERIC_SCALE"] = reader.GetFieldValue<int>("SCALE");                                  row["PARAMETER_DIRECTION"] = reader.GetFieldValue<int>("COLUMN_TYPE");                                  row["IS_NULLABLE"] = !reader.GetFieldValue<string>("IS_NULLABLE").Equals("NO");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The following statement contains a magic number: if (collectionName == DbMetaDataCollectionNames.DataSourceInformation)              {                  // see http://msdn.microsoft.com/en-us/library/ms254501.aspx                  table.Columns.Add("CompositeIdentifierSeparatorPattern"' typeof(string));                  table.Columns.Add("DataSourceProductName"' typeof(string));                  table.Columns.Add("DataSourceProductVersion"' typeof(string));                  table.Columns.Add("DataSourceProductVersionNormalized"' typeof(string));                  table.Columns.Add("DataSourceInternalProductVersion"' typeof(string));                  table.Columns.Add("GroupByBehavior"' typeof(GroupByBehavior));                  table.Columns.Add("IdentifierPattern"' typeof(string));                  table.Columns.Add("IdentifierCase"' typeof(IdentifierCase));                  table.Columns.Add("OrderByColumnsInSelect"' typeof(bool));                  table.Columns.Add("ParameterMarkerFormat"' typeof(string));                  table.Columns.Add("ParameterMarkerPattern"' typeof(string));                  table.Columns.Add("ParameterNameMaxLength"' typeof(int));                  table.Columns.Add("ParameterNamePattern"' typeof(string));                  table.Columns.Add("QuotedIdentifierPattern"' typeof(string));  // Regex                  table.Columns.Add("QuotedIdentifierCase"' typeof(int));                  table.Columns.Add("StatementSeparatorPattern"' typeof(string));                  table.Columns.Add("StringLiteralPattern"' typeof(string));  // Regex                  table.Columns.Add("SupportedJoinOperators"' typeof(SupportedJoinOperators));                    table.BeginLoadData();                  DataRow row = table.NewRow();                  int databaseMajorVersion = 0' databaseMinorVersion = 0;                  try                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetDatabaseMetaData);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      for (int item; (item = tmConn.InternalConnection.dataStream.getInt()) != Protocol.DbmbFini; )                      {                          switch (item)                          {                              case Protocol.DbmbProductName:                                  row["DataSourceProductName"] = tmConn.InternalConnection.dataStream.getString();                                  break;                                case Protocol.DbmbProductVersion:                                  row["DataSourceProductVersion"] = tmConn.InternalConnection.dataStream.getString();                                  break;                                case Protocol.DbmbDatabaseMinorVersion:                                  databaseMinorVersion = tmConn.InternalConnection.dataStream.getInt();                                  break;                                case Protocol.DbmbDatabaseMajorVersion:                                  databaseMajorVersion = tmConn.InternalConnection.dataStream.getInt();                                  break;                                case Protocol.DbmbDefaultTransactionIsolation:                                  int defaultTransactionIsolation = tmConn.InternalConnection.dataStream.getInt();                                  break;                                default:                                  tmConn.InternalConnection.dataStream.decode();                                  break;                          }                      }                  }                  catch (Exception)                  {                  }                    row["DataSourceInternalProductVersion"] = String.Format("{0:D3}.{1:D3}"' databaseMajorVersion' databaseMinorVersion);                  // The regular expression to match the composite separators in a composite identifier.                   // For example' "\." (for SQL Server) or "@|\." (for Oracle).                  // A composite identifier is typically what is used for a database object name'                   // for example: pubs.dbo.authors or pubs@dbo.authors.                  row["CompositeIdentifierSeparatorPattern"] = "\\.";                  // A normalized version for the data source' such that it can be compared with String.Compare().                   // The format of this is consistent for all versions of the provider to prevent version 10 from sorting between version 1 and version 2.                  //row["DataSourceProductVersionNormalized"] = ??                  // Specifies the relationship between the columns in a GROUP BY clause and the non-aggregated columns in the select list.                  row["GroupByBehavior"] = GroupByBehavior.Unknown;                  // A regular expression that matches an identifier and has a match value of the identifier. For example "[A-Za-z0-9_#$]".                  row["IdentifierPattern"] = "(^\\[\\p{Lo}\\p{Lu}\\p{Ll}_@#][\\p{Lo}\\p{Lu}\\p{Ll}\\p{Nd}@$#_]*$)|(^\"[^\"\\0]|\"\"+\"$)";                  // Indicates whether non-quoted identifiers are treated as case sensitive or not.                  row["IdentifierCase"] = IdentifierCase.Insensitive;                  // Specifies whether columns in an ORDER BY clause must be in the select list.                   // A value of true indicates that they are required to be in the select list'                   // a value of false indicates that they are not required to be in the select list.                  row["OrderByColumnsInSelect"] = false;                  // For data sources that do not expect named parameters and expect the use of the ‘?’ character' the format string                  // can be specified as simply '?'' which would ignore the parameter name.                  row["ParameterMarkerFormat"] = "?";                  // if the data source doesn't support named parameters' this would simply be "?".                  row["ParameterMarkerPattern"] = "?";                  // If the data source does not support named parameters' this property returns zero.                  row["ParameterNameMaxLength"] = 0;                  // A regular expression that matches the valid parameter names                  row["ParameterNamePattern"] = "";                  // A regular expression that matches a quoted identifier and has a match value of the identifier itself without the quotes.                   // For example' if the data source used double-quotes to identify quoted identifiers' this would be: "(([^\"]|\"\")*)".                  row["QuotedIdentifierPattern"] = "\"([^\"]*)\"";                  // Indicates whether quoted identifiers are treated as case sensitive or not.                  row["QuotedIdentifierCase"] = IdentifierCase.Sensitive;                  // A regular expression that matches the statement separator.                  row["StatementSeparatorPattern"] = ";";                  // A regular expression that matches a string literal and has a match value of the literal itself.                   // For example' if the data source used single-quotes to identify strings' this would be: "('([^']|'')*')"'                  row["StringLiteralPattern"] = "'([^']*)'";                  // Specifies what types of SQL join statements are supported by the data source.                  row["SupportedJoinOperators"] = SupportedJoinOperators.None;                  table.Rows.Add(row);                  table.EndLoadData();              }              else if (collectionName == DbMetaDataCollectionNames.ReservedWords)              {                  table.Columns.Add("ReservedWord"' typeof(string));                  table.Columns.Add("MaximumVersion"' typeof(string));                  table.Columns.Add("MinimumVersion"' typeof(string));                    string[] words = { "select"' "Add field"' "Drop field"' "Alter table"' "Alter field"'                                      "Alter user"' "And"' "Or"' "Not"' "Create Index"' "Upgrade"' "Unique"'                                      "Table key"' "Table unique key"' "Primary Key"' "Create Table"'                                      "Upgrade Table"' "Rename Table"' "Create View"' "Upgrade View"'                                      "Drop View"' "Create Schema"' "Drop Schema"' "Integer"' "Smallint"'                                      "Bigint"' "Tinyint"' "float"' "double"' "Blob"' "bytes"' "boolean"'                                      "binary"' "varbinary"' "string"' "char"' "text"' "date"' "timestamp"'                                      "time"' "varchar"' "numeric"' "Decimal Number"' "Enum"' "Delete"' "Repair"'                                      "Field"' "Not Null"' "Default Value"' "searchable"' "not searchable"'                                      "collation"' "character_set"' "Foreign Key"' "Identifier"' "record number"'                                      "Insert"' "Replace"' "Name"' "Number"' "Order"' "Descending"' "limit"'                                      "Quoted String"' "Select Clause"' "Distinct"' "Gtr"' "Geq"' "Eql"'                                      "Leq"' "Lss"' "Neq"' "in list"' "in select"' "exists"' "Between"' "Like"'                                      "starts with"' "Containing"' "Matching"' "Regular expression"' "Null"'                                      "True"' "False"' "Execute"' "Parameter"' "Count"' "sum"' "min"' "max"'                                      "avg"' "Drop Index"' "Drop primary key"' "Drop foreign key"' "Drop Table"'                                      "If Exists"' "Describe"' "Statement"' "for_select"' "for_insert"' "while"'                                      "if then else"' "variable"' "declaration"' "throw"' "assignment"'                                      "Start transaction"' "read only"' "read write"' "read committed"' "write committed"'                                      "read uncommitted"' "repeatableread"' "serializable"' "Commit"' "Rollback"'                                      "Savepoint"' "Rollack Savepoint"' "Release Savepoint"' "Table"' "Derived Table"'                                      "Assign"' "Update"' "list"' "Constant"' "Function"' "Grant"' "Grant role"' "Alter"'                                      "Read"' "Identity"' "Check"' "Constraint"' "value constraint"' "auto increment"'                                      "generated"' "always"' "Domain"' "is null"' "is active_role"' "start with"' "reindex"'                                      "cursor"' "alias"' "push_namespace"' "pop_namespace"' "set_namespace"' "coalesce"'                                      "nod_nullif"' "case"' "case_search"' "add"' "subtract"' "multiply"' "divide"' "modulus"'                                      "negate"' "plus"' "cast"' "concatenation"' "create user"' "drop user"' "create role"'                                      "upgrade role"' "drop role"' "revoke"' "revoke role"' "assume"' "revert"' "negate"'                                      "priv insert"' "priv delete"' "priv execute"' "priv select"' "priv update"' "priv grant"'                                      "priv all"' "characters"' "octets"' "role"' "view"' "procedure"' "user"' "zone"' "admin"'                                      "default role"' "create sequence"' "upgrade sequence"' "drop sequence"' "next value"'                                      "create trigger"' "upgrade trigger"' "alter trigger"' "drop trigger"' "create procedure"'                                      "upgrade procedure"' "alter procedure"' "drop procedure"' "pre-insert"' "post-insert"'                                      "pre-update"' "post-update"' "pre-delete"' "post-delete"' "pre-commit"' "post-commit"'                                      "active"' "inactive"' "position"' "select-expr"' "create filterset"' "upgrade filterset"'                                      "drop filterset"' "enable filterset"' "disable filterset"' "table filter"' "left outer"'                                      "right outer"' "full outer"' "inner"' "join"' "join_term"' "trigger class"' "enable trigger class"'                                      "disable trigger class"' "create zone"' "upgrade zone"' "drop zone"' "range"' "ip address"'                                      "node_name"' "wildcard"' "create domain"' "upgrade domain"' "alter domain"' "upgrade schema"'                                      "delete cascade"' "index segment"' "for update"' "write committed"' "read committed"'                                       "consistent read"' "set dialect"' "set names"' "restrict"' "cascade"' "characters"' "octets"'                                      "create event"' "collate"' "truncate"' "restart"' "nameless constraint"' "drop constraint"'                                      "drop unique constraint"' "drop domain"' "with check option"' "not real"' "lower"' "upper"'                                      "substr"' "substring index"' "charlength"' "default keyword"' "sqrt"' "power"' "Scientific Notation Number"'                                      "Explain"' "msleep"' "KillStatement"' "now" };                  table.BeginLoadData();                  foreach (string keyword in words)                  {                      DataRow row = table.NewRow();                      row["ReservedWord"] = keyword;                      table.Rows.Add(row);                  }                  table.EndLoadData();                }              else if (collectionName == DbMetaDataCollectionNames.DataTypes)              {                  table.Columns.Add("TypeName"' typeof(string));  // The provider-specific data type name.                  table.Columns.Add("ProviderDbType"' typeof(int)); // The provider-specific type value that should be used when specifying                   //a parameter's type. For example' SqlDbType.Money or OracleType.Blob.                  table.Columns.Add("ColumnSize"' typeof(long));                  table.Columns.Add("CreateFormat"' typeof(string));                  table.Columns.Add("CreateParameters"' typeof(string));                  table.Columns.Add("DataType"' typeof(string));  // The name of the .NET Framework type of the data type.                  table.Columns.Add("IsAutoincrementable"' typeof(bool));                  table.Columns.Add("IsBestMatch"' typeof(bool));                  table.Columns.Add("IsCaseSensitive"' typeof(bool));                  table.Columns.Add("IsFixedLength"' typeof(bool));                  table.Columns.Add("IsFixedPrecisionScale"' typeof(bool));                  table.Columns.Add("IsLong"' typeof(bool));                  table.Columns.Add("IsNullable"' typeof(bool));                  table.Columns.Add("IsSearchable"' typeof(bool));                  table.Columns.Add("IsSearchableWithLike"' typeof(bool));                  table.Columns.Add("IsUnsigned"' typeof(bool));                  table.Columns.Add("MaximumScale"' typeof(short));                  table.Columns.Add("MinimumScale"' typeof(short));                  table.Columns.Add("IsConcurrencyType"' typeof(bool));                  table.Columns.Add("IsLiteralsSupported"' typeof(bool));                  table.Columns.Add("LiteralPrefix"' typeof(string));                  table.Columns.Add("LiteralSuffix"' typeof(string));                  table.Columns.Add("NativeDataType"' typeof(string));    // NativeDataType is an OLE DB specific column for exposing the OLE DB type of the data type .                    table.ReadXml(XmlReader.Create(typeof(NuoDbConnectionInternal).Assembly.GetManifestResourceStream("NuoDb.Data.Client.DataTypes.xml")));              }              else if (collectionName == "Tables")              {                  table.Columns.Add("TABLE_CATALOG"' typeof(string));                  table.Columns.Add("TABLE_SCHEMA"' typeof(string));                  table.Columns.Add("TABLE_NAME"' typeof(string));                  table.Columns.Add("TABLE_TYPE"' typeof(string));                  table.Columns.Add("REMARKS"' typeof(string));                  table.Columns.Add("VIEW_DEF"' typeof(string));                    tmConn.InternalConnection.dataStream.startMessage(Protocol.GetTables);                  tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                  for (int i = 1; i < 3; i++)                      if (restrictionValues != null && restrictionValues.Length > i)                          tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                      else                          tmConn.InternalConnection.dataStream.encodeNull();                  if (restrictionValues == null || restrictionValues.Length < 4 || restrictionValues[3] == null)                      tmConn.InternalConnection.dataStream.encodeInt(0);                  else                  {                      tmConn.InternalConnection.dataStream.encodeInt(1);                      tmConn.InternalConnection.dataStream.encodeString(restrictionValues[3]);                  }                    tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                  int handle = tmConn.InternalConnection.dataStream.getInt();                    if (handle != -1)                  {                      using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                      {                          table.BeginLoadData();                          string view_def_label="";                          try                           {                               reader.GetOrdinal("VIEW_DEF");                              view_def_label = "VIEW_DEF";                          }                          catch(Exception) {}                          try                           {                               reader.GetOrdinal("VIEWDEFINITION");                              view_def_label = "VIEWDEFINITION";                          }                          catch (Exception) { }                          while (reader.Read())                          {  #if DEBUG                          System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_NAME"] + "' " + reader["TABLE_TYPE"]);  #endif                              DataRow row = table.NewRow();                              row["TABLE_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                              row["TABLE_NAME"] = reader.GetFieldValue<string>("TABLE_NAME");                              row["TABLE_TYPE"] = reader.GetFieldValue<string>("TABLE_TYPE");                              row["REMARKS"] = reader.GetFieldValue<string>("REMARKS");                              if (view_def_label.Length != 0)                              {                                  row["VIEW_DEF"] = reader.GetFieldValue<string>(view_def_label);                              }                              table.Rows.Add(row);                          }                          table.EndLoadData();                      }                  }              }              else if (collectionName == "Columns")              {                  table.Columns.Add("COLUMN_CATALOG"' typeof(string));                  table.Columns.Add("COLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("COLUMN_TABLE"' typeof(string));                  table.Columns.Add("COLUMN_NAME"' typeof(string));                  table.Columns.Add("COLUMN_POSITION"' typeof(int));                  table.Columns.Add("COLUMN_TYPE"' typeof(string));                  table.Columns.Add("COLUMN_LENGTH"' typeof(int));                  table.Columns.Add("COLUMN_PRECISION"' typeof(int));                  table.Columns.Add("COLUMN_NULLABLE"' typeof(bool));                  table.Columns.Add("COLUMN_IDENTITY"' typeof(bool));                  table.Columns.Add("COLUMN_DEFAULT"' typeof(string));                  table.Columns.Add("COLUMN_SCALE"' typeof(int));                    tmConn.InternalConnection.dataStream.startMessage(Protocol.GetColumns);                  tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                  for (int i = 1; i < 4; i++)                      if (restrictionValues != null && restrictionValues.Length > i)                          tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                      else                          tmConn.InternalConnection.dataStream.encodeNull();                    tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                  int handle = tmConn.InternalConnection.dataStream.getInt();                    if (handle != -1)                  {                      using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                      {                          table.BeginLoadData();                          while (reader.Read())                          {                              DataRow row = table.NewRow();                              row["COLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                              row["COLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                              row["COLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                              row["COLUMN_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                              row["COLUMN_LENGTH"] = reader.GetFieldValue<int>("COLUMN_SIZE");                              row["COLUMN_PRECISION"] = reader.GetFieldValue<int>("BUFFER_LENGTH");                              row["COLUMN_SCALE"] = reader.GetFieldValue<int>("DECIMAL_DIGITS");                              if (isNumeric(reader.GetFieldValue<string>("TYPE_NAME")))                              {                                  if (reader.GetFieldValue<int>("DECIMAL_DIGITS") != 0)                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME") +                                           "(" + reader.GetFieldValue<int>("BUFFER_LENGTH") + "'" + reader.GetFieldValue<int>("DECIMAL_DIGITS") + ")";                                  else                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME");                              }                              else                              {                                  if (isVarLenType(reader.GetFieldValue<string>("TYPE_NAME")) && reader.GetFieldValue<int>("COLUMN_SIZE") != 0)                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME") +                                           "(" + reader.GetFieldValue<int>("COLUMN_SIZE") + ")";                                  else                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME");                              }                              if (!reader.IsDBNull(reader.GetOrdinal("IS_NULLABLE")))                                  row["COLUMN_NULLABLE"] = reader.GetFieldValue<string>("IS_NULLABLE").Equals("YES");                              if (!reader.IsDBNull(reader.GetOrdinal("IS_AUTOINCREMENT")))                                  row["COLUMN_IDENTITY"] = reader.GetFieldValue<string>("IS_AUTOINCREMENT").Equals("YES");                              row["COLUMN_DEFAULT"] = reader.GetFieldValue<string>("COLUMN_DEF");    #if DEBUG                              System.Diagnostics.Trace.WriteLine("-> " + row["COLUMN_NAME"] + " " + row["COLUMN_TYPE"]);  #endif                              table.Rows.Add(row);                          }                          table.EndLoadData();                      }                  }              }              else if (collectionName == "Indexes")              {                  table.Columns.Add("INDEX_CATALOG"' typeof(string));                  table.Columns.Add("INDEX_SCHEMA"' typeof(string));                  table.Columns.Add("INDEX_TABLE"' typeof(string));                  table.Columns.Add("INDEX_NAME"' typeof(string));                  table.Columns.Add("INDEX_TYPE"' typeof(string));                  table.Columns.Add("INDEX_UNIQUE"' typeof(bool));                  table.Columns.Add("INDEX_PRIMARY"' typeof(bool));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetIndexInfo);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // unique                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // approximate                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        // to avoid to insert the same index more than once                      HashSet<string> unique = new HashSet<string>();                      if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;                                  if (!unique.Add(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;                                  DataRow row = table.NewRow();                                  row["INDEX_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEX_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEX_NAME"] = reader.GetFieldValue<string>("INDEX_NAME");                                  switch (reader.GetFieldValue<int>("TYPE"))                                  {                                      case 0:                                          row["INDEX_TYPE"] = "Primary";                                          break;                                      case 1:                                          row["INDEX_TYPE"] = "Unique";                                          break;                                      case 2:                                          row["INDEX_TYPE"] = "Secondary";                                          break;                                      case 3:                                          row["INDEX_TYPE"] = "Foreign Key";                                          break;                                  }                                  row["INDEX_UNIQUE"] = (reader.GetFieldValue<int>("NON_UNIQUE") == 0) ? true : false;                                  row["INDEX_PRIMARY"] = (reader.GetFieldValue<int>("TYPE") == 0) ? true : false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                        tmConn.InternalConnection.dataStream.startMessage(Protocol.GetPrimaryKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              // use INDEX_NAME' if present; if missing' the name of the index is in PK_NAME                              string indexName = "PK_NAME";                              foreach (string column in reader.columnNames)                              {                                  if (column == "INDEX_NAME")                                  {                                      indexName = "INDEX_NAME";                                      break;                                  }                              }                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>(indexName)))                                      continue;                                  if (!unique.Add(reader.GetFieldValue<string>(indexName)))                                      continue;                                  DataRow row = table.NewRow();                                  row["INDEX_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEX_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEX_NAME"] = reader.GetFieldValue<string>(indexName);                                  row["INDEX_TYPE"] = "Primary";                                  row["INDEX_UNIQUE"] = true;                                  row["INDEX_PRIMARY"] = true;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "IndexColumns")              {                  table.Columns.Add("INDEXCOLUMN_CATALOG"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_TABLE"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_INDEX"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_NAME"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_POSITION"' typeof(int));                  table.Columns.Add("INDEXCOLUMN_ISPRIMARY"' typeof(bool));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetIndexInfo);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // unique                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // approximate                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_SCHEM"] + "." + reader["TABLE_NAME"] + "=" + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["INDEXCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEXCOLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEXCOLUMN_INDEX"] = reader.GetFieldValue<string>("INDEX_NAME");                                  row["INDEXCOLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["INDEXCOLUMN_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                                  row["INDEXCOLUMN_ISPRIMARY"] = false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                        tmConn.InternalConnection.dataStream.startMessage(Protocol.GetPrimaryKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              // use INDEX_NAME' if present; if missing' the name of the index is in PK_NAME                              string indexName = "PK_NAME";                              foreach (string column in reader.columnNames)                              {                                  if (column == "INDEX_NAME")                                  {                                      indexName = "INDEX_NAME";                                      break;                                  }                              }                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>(indexName)))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_SCHEM"] + "." + reader["TABLE_NAME"] + " (Primary) =" + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["INDEXCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEXCOLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEXCOLUMN_INDEX"] = reader.GetFieldValue<string>(indexName);                                  row["INDEXCOLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["INDEXCOLUMN_POSITION"] = reader.GetFieldValue<int>("KEY_SEQ");                                  row["INDEXCOLUMN_ISPRIMARY"] = true;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ForeignKeys")              {                  table.Columns.Add("FOREIGNKEY_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEY_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEY_TABLE"' typeof(string));                  table.Columns.Add("FOREIGNKEY_NAME"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_TABLE"' typeof(string));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetImportedKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  string name = "[" + reader.GetFieldValue<string>("FKTABLE_SCHEM") + "]" +                                                   reader.GetFieldValue<string>("FKTABLE_NAME") + "." +                                                   reader.GetFieldValue<string>("FKCOLUMN_NAME") + "->" +                                                  "[" + reader.GetFieldValue<string>("PKTABLE_SCHEM") + "]" +                                                   reader.GetFieldValue<string>("PKTABLE_NAME") + "." +                                                   reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(name))                                      continue;                                  DataRow row = table.NewRow();                                  row["FOREIGNKEY_SCHEMA"] = reader.GetFieldValue<string>("FKTABLE_SCHEM");                                  row["FOREIGNKEY_TABLE"] = reader.GetFieldValue<string>("FKTABLE_NAME");                                  row["FOREIGNKEY_NAME"] = name;                                  row["FOREIGNKEY_OTHER_SCHEMA"] = reader.GetFieldValue<string>("PKTABLE_SCHEM");                                  row["FOREIGNKEY_OTHER_TABLE"] = reader.GetFieldValue<string>("PKTABLE_NAME");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ForeignKeyColumns")              {                  table.Columns.Add("FOREIGNKEYCOLUMN_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_TABLE"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_KEY"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_NAME"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_ORDINAL"' typeof(int));                  table.Columns.Add("FOREIGNKEYCOLUMN_OTHER_COLUMN_NAME"' typeof(string));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetImportedKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  string name = "[" + reader.GetFieldValue<string>("FKTABLE_SCHEM") + "]" +                                                  reader.GetFieldValue<string>("FKTABLE_NAME") + "." +                                                  reader.GetFieldValue<string>("FKCOLUMN_NAME") + "->" +                                                  "[" + reader.GetFieldValue<string>("PKTABLE_SCHEM") + "]" +                                                  reader.GetFieldValue<string>("PKTABLE_NAME") + "." +                                                  reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(name))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["FKTABLE_SCHEM"] + "." + reader["FKTABLE_NAME"] + "=" + reader["FKCOLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["FOREIGNKEYCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("FKTABLE_SCHEM");                                  row["FOREIGNKEYCOLUMN_TABLE"] = reader.GetFieldValue<string>("FKTABLE_NAME");                                  row["FOREIGNKEYCOLUMN_KEY"] = name;                                  row["FOREIGNKEYCOLUMN_NAME"] = reader.GetFieldValue<string>("FKCOLUMN_NAME");                                  row["FOREIGNKEYCOLUMN_ORDINAL"] = reader.GetFieldValue<int>("KEY_SEQ");                                  row["FOREIGNKEYCOLUMN_OTHER_COLUMN_NAME"] = reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "Procedures")               {                  table.Columns.Add("PROCEDURE_CATALOG"' typeof(string));                  table.Columns.Add("PROCEDURE_SCHEMA"' typeof(string));                  table.Columns.Add("PROCEDURE_NAME"' typeof(string));                  table.Columns.Add("IS_SYSTEM_PROCEDURE"' typeof(bool));                    if (tmConn.InternalConnection.protocolVersion >= Protocol.PROTOCOL_VERSION12)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetProcedures);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      for (int i = 1; i < 3; i++)                          if (restrictionValues != null && restrictionValues.Length > i)                              tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                          else                              tmConn.InternalConnection.dataStream.encodeNull();                        tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["PROCEDURE_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["PROCEDURE_SCHEMA"] = reader.GetFieldValue<string>("PROCEDURE_SCHEM");                                  row["PROCEDURE_NAME"] = reader.GetFieldValue<string>("PROCEDURE_NAME");                                  row["IS_SYSTEM_PROCEDURE"] = false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ProcedureParameters")              {                  table.Columns.Add("PROCEDURE_CATALOG"' typeof(string));                  table.Columns.Add("PROCEDURE_SCHEMA"' typeof(string));                  table.Columns.Add("PROCEDURE_NAME"' typeof(string));                  table.Columns.Add("PARAMETER_NAME"' typeof(string));                  table.Columns.Add("ORDINAL_POSITION"' typeof(int));                  table.Columns.Add("PARAMETER_DATA_TYPE"' typeof(int));                  table.Columns.Add("PARAMETER_TYPE_NAME"' typeof(string));                  table.Columns.Add("PARAMETER_SIZE"' typeof(int));                  table.Columns.Add("NUMERIC_PRECISION"' typeof(int));                  table.Columns.Add("NUMERIC_SCALE"' typeof(int));                  table.Columns.Add("PARAMETER_DIRECTION"' typeof(int));                  table.Columns.Add("IS_NULLABLE"' typeof(bool));                    if (tmConn.InternalConnection.protocolVersion >= Protocol.PROTOCOL_VERSION12)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetProcedureColumns);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      for (int i = 1; i < 4; i++)                          if (restrictionValues != null && restrictionValues.Length > i)                              tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                          else                              tmConn.InternalConnection.dataStream.encodeNull();                        tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["PROCEDURE_NAME"] + "' " + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["PROCEDURE_SCHEMA"] = reader.GetFieldValue<string>("PROCEDURE_SCHEM");                                  row["PROCEDURE_NAME"] = reader.GetFieldValue<string>("PROCEDURE_NAME");                                  row["PARAMETER_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["ORDINAL_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                                  row["PARAMETER_TYPE_NAME"] = reader.GetFieldValue<string>("TYPE_NAME");                                  row["PARAMETER_DATA_TYPE"] = reader.GetFieldValue<int>("DATA_TYPE");                                  row["PARAMETER_SIZE"] = reader.GetFieldValue<int>("LENGTH");                                  row["NUMERIC_PRECISION"] = reader.GetFieldValue<int>("PRECISION");                                  row["NUMERIC_SCALE"] = reader.GetFieldValue<int>("SCALE");                                  row["PARAMETER_DIRECTION"] = reader.GetFieldValue<int>("COLUMN_TYPE");                                  row["IS_NULLABLE"] = !reader.GetFieldValue<string>("IS_NULLABLE").Equals("NO");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The following statement contains a magic number: if (collectionName == DbMetaDataCollectionNames.DataSourceInformation)              {                  // see http://msdn.microsoft.com/en-us/library/ms254501.aspx                  table.Columns.Add("CompositeIdentifierSeparatorPattern"' typeof(string));                  table.Columns.Add("DataSourceProductName"' typeof(string));                  table.Columns.Add("DataSourceProductVersion"' typeof(string));                  table.Columns.Add("DataSourceProductVersionNormalized"' typeof(string));                  table.Columns.Add("DataSourceInternalProductVersion"' typeof(string));                  table.Columns.Add("GroupByBehavior"' typeof(GroupByBehavior));                  table.Columns.Add("IdentifierPattern"' typeof(string));                  table.Columns.Add("IdentifierCase"' typeof(IdentifierCase));                  table.Columns.Add("OrderByColumnsInSelect"' typeof(bool));                  table.Columns.Add("ParameterMarkerFormat"' typeof(string));                  table.Columns.Add("ParameterMarkerPattern"' typeof(string));                  table.Columns.Add("ParameterNameMaxLength"' typeof(int));                  table.Columns.Add("ParameterNamePattern"' typeof(string));                  table.Columns.Add("QuotedIdentifierPattern"' typeof(string));  // Regex                  table.Columns.Add("QuotedIdentifierCase"' typeof(int));                  table.Columns.Add("StatementSeparatorPattern"' typeof(string));                  table.Columns.Add("StringLiteralPattern"' typeof(string));  // Regex                  table.Columns.Add("SupportedJoinOperators"' typeof(SupportedJoinOperators));                    table.BeginLoadData();                  DataRow row = table.NewRow();                  int databaseMajorVersion = 0' databaseMinorVersion = 0;                  try                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetDatabaseMetaData);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      for (int item; (item = tmConn.InternalConnection.dataStream.getInt()) != Protocol.DbmbFini; )                      {                          switch (item)                          {                              case Protocol.DbmbProductName:                                  row["DataSourceProductName"] = tmConn.InternalConnection.dataStream.getString();                                  break;                                case Protocol.DbmbProductVersion:                                  row["DataSourceProductVersion"] = tmConn.InternalConnection.dataStream.getString();                                  break;                                case Protocol.DbmbDatabaseMinorVersion:                                  databaseMinorVersion = tmConn.InternalConnection.dataStream.getInt();                                  break;                                case Protocol.DbmbDatabaseMajorVersion:                                  databaseMajorVersion = tmConn.InternalConnection.dataStream.getInt();                                  break;                                case Protocol.DbmbDefaultTransactionIsolation:                                  int defaultTransactionIsolation = tmConn.InternalConnection.dataStream.getInt();                                  break;                                default:                                  tmConn.InternalConnection.dataStream.decode();                                  break;                          }                      }                  }                  catch (Exception)                  {                  }                    row["DataSourceInternalProductVersion"] = String.Format("{0:D3}.{1:D3}"' databaseMajorVersion' databaseMinorVersion);                  // The regular expression to match the composite separators in a composite identifier.                   // For example' "\." (for SQL Server) or "@|\." (for Oracle).                  // A composite identifier is typically what is used for a database object name'                   // for example: pubs.dbo.authors or pubs@dbo.authors.                  row["CompositeIdentifierSeparatorPattern"] = "\\.";                  // A normalized version for the data source' such that it can be compared with String.Compare().                   // The format of this is consistent for all versions of the provider to prevent version 10 from sorting between version 1 and version 2.                  //row["DataSourceProductVersionNormalized"] = ??                  // Specifies the relationship between the columns in a GROUP BY clause and the non-aggregated columns in the select list.                  row["GroupByBehavior"] = GroupByBehavior.Unknown;                  // A regular expression that matches an identifier and has a match value of the identifier. For example "[A-Za-z0-9_#$]".                  row["IdentifierPattern"] = "(^\\[\\p{Lo}\\p{Lu}\\p{Ll}_@#][\\p{Lo}\\p{Lu}\\p{Ll}\\p{Nd}@$#_]*$)|(^\"[^\"\\0]|\"\"+\"$)";                  // Indicates whether non-quoted identifiers are treated as case sensitive or not.                  row["IdentifierCase"] = IdentifierCase.Insensitive;                  // Specifies whether columns in an ORDER BY clause must be in the select list.                   // A value of true indicates that they are required to be in the select list'                   // a value of false indicates that they are not required to be in the select list.                  row["OrderByColumnsInSelect"] = false;                  // For data sources that do not expect named parameters and expect the use of the ‘?’ character' the format string                  // can be specified as simply '?'' which would ignore the parameter name.                  row["ParameterMarkerFormat"] = "?";                  // if the data source doesn't support named parameters' this would simply be "?".                  row["ParameterMarkerPattern"] = "?";                  // If the data source does not support named parameters' this property returns zero.                  row["ParameterNameMaxLength"] = 0;                  // A regular expression that matches the valid parameter names                  row["ParameterNamePattern"] = "";                  // A regular expression that matches a quoted identifier and has a match value of the identifier itself without the quotes.                   // For example' if the data source used double-quotes to identify quoted identifiers' this would be: "(([^\"]|\"\")*)".                  row["QuotedIdentifierPattern"] = "\"([^\"]*)\"";                  // Indicates whether quoted identifiers are treated as case sensitive or not.                  row["QuotedIdentifierCase"] = IdentifierCase.Sensitive;                  // A regular expression that matches the statement separator.                  row["StatementSeparatorPattern"] = ";";                  // A regular expression that matches a string literal and has a match value of the literal itself.                   // For example' if the data source used single-quotes to identify strings' this would be: "('([^']|'')*')"'                  row["StringLiteralPattern"] = "'([^']*)'";                  // Specifies what types of SQL join statements are supported by the data source.                  row["SupportedJoinOperators"] = SupportedJoinOperators.None;                  table.Rows.Add(row);                  table.EndLoadData();              }              else if (collectionName == DbMetaDataCollectionNames.ReservedWords)              {                  table.Columns.Add("ReservedWord"' typeof(string));                  table.Columns.Add("MaximumVersion"' typeof(string));                  table.Columns.Add("MinimumVersion"' typeof(string));                    string[] words = { "select"' "Add field"' "Drop field"' "Alter table"' "Alter field"'                                      "Alter user"' "And"' "Or"' "Not"' "Create Index"' "Upgrade"' "Unique"'                                      "Table key"' "Table unique key"' "Primary Key"' "Create Table"'                                      "Upgrade Table"' "Rename Table"' "Create View"' "Upgrade View"'                                      "Drop View"' "Create Schema"' "Drop Schema"' "Integer"' "Smallint"'                                      "Bigint"' "Tinyint"' "float"' "double"' "Blob"' "bytes"' "boolean"'                                      "binary"' "varbinary"' "string"' "char"' "text"' "date"' "timestamp"'                                      "time"' "varchar"' "numeric"' "Decimal Number"' "Enum"' "Delete"' "Repair"'                                      "Field"' "Not Null"' "Default Value"' "searchable"' "not searchable"'                                      "collation"' "character_set"' "Foreign Key"' "Identifier"' "record number"'                                      "Insert"' "Replace"' "Name"' "Number"' "Order"' "Descending"' "limit"'                                      "Quoted String"' "Select Clause"' "Distinct"' "Gtr"' "Geq"' "Eql"'                                      "Leq"' "Lss"' "Neq"' "in list"' "in select"' "exists"' "Between"' "Like"'                                      "starts with"' "Containing"' "Matching"' "Regular expression"' "Null"'                                      "True"' "False"' "Execute"' "Parameter"' "Count"' "sum"' "min"' "max"'                                      "avg"' "Drop Index"' "Drop primary key"' "Drop foreign key"' "Drop Table"'                                      "If Exists"' "Describe"' "Statement"' "for_select"' "for_insert"' "while"'                                      "if then else"' "variable"' "declaration"' "throw"' "assignment"'                                      "Start transaction"' "read only"' "read write"' "read committed"' "write committed"'                                      "read uncommitted"' "repeatableread"' "serializable"' "Commit"' "Rollback"'                                      "Savepoint"' "Rollack Savepoint"' "Release Savepoint"' "Table"' "Derived Table"'                                      "Assign"' "Update"' "list"' "Constant"' "Function"' "Grant"' "Grant role"' "Alter"'                                      "Read"' "Identity"' "Check"' "Constraint"' "value constraint"' "auto increment"'                                      "generated"' "always"' "Domain"' "is null"' "is active_role"' "start with"' "reindex"'                                      "cursor"' "alias"' "push_namespace"' "pop_namespace"' "set_namespace"' "coalesce"'                                      "nod_nullif"' "case"' "case_search"' "add"' "subtract"' "multiply"' "divide"' "modulus"'                                      "negate"' "plus"' "cast"' "concatenation"' "create user"' "drop user"' "create role"'                                      "upgrade role"' "drop role"' "revoke"' "revoke role"' "assume"' "revert"' "negate"'                                      "priv insert"' "priv delete"' "priv execute"' "priv select"' "priv update"' "priv grant"'                                      "priv all"' "characters"' "octets"' "role"' "view"' "procedure"' "user"' "zone"' "admin"'                                      "default role"' "create sequence"' "upgrade sequence"' "drop sequence"' "next value"'                                      "create trigger"' "upgrade trigger"' "alter trigger"' "drop trigger"' "create procedure"'                                      "upgrade procedure"' "alter procedure"' "drop procedure"' "pre-insert"' "post-insert"'                                      "pre-update"' "post-update"' "pre-delete"' "post-delete"' "pre-commit"' "post-commit"'                                      "active"' "inactive"' "position"' "select-expr"' "create filterset"' "upgrade filterset"'                                      "drop filterset"' "enable filterset"' "disable filterset"' "table filter"' "left outer"'                                      "right outer"' "full outer"' "inner"' "join"' "join_term"' "trigger class"' "enable trigger class"'                                      "disable trigger class"' "create zone"' "upgrade zone"' "drop zone"' "range"' "ip address"'                                      "node_name"' "wildcard"' "create domain"' "upgrade domain"' "alter domain"' "upgrade schema"'                                      "delete cascade"' "index segment"' "for update"' "write committed"' "read committed"'                                       "consistent read"' "set dialect"' "set names"' "restrict"' "cascade"' "characters"' "octets"'                                      "create event"' "collate"' "truncate"' "restart"' "nameless constraint"' "drop constraint"'                                      "drop unique constraint"' "drop domain"' "with check option"' "not real"' "lower"' "upper"'                                      "substr"' "substring index"' "charlength"' "default keyword"' "sqrt"' "power"' "Scientific Notation Number"'                                      "Explain"' "msleep"' "KillStatement"' "now" };                  table.BeginLoadData();                  foreach (string keyword in words)                  {                      DataRow row = table.NewRow();                      row["ReservedWord"] = keyword;                      table.Rows.Add(row);                  }                  table.EndLoadData();                }              else if (collectionName == DbMetaDataCollectionNames.DataTypes)              {                  table.Columns.Add("TypeName"' typeof(string));  // The provider-specific data type name.                  table.Columns.Add("ProviderDbType"' typeof(int)); // The provider-specific type value that should be used when specifying                   //a parameter's type. For example' SqlDbType.Money or OracleType.Blob.                  table.Columns.Add("ColumnSize"' typeof(long));                  table.Columns.Add("CreateFormat"' typeof(string));                  table.Columns.Add("CreateParameters"' typeof(string));                  table.Columns.Add("DataType"' typeof(string));  // The name of the .NET Framework type of the data type.                  table.Columns.Add("IsAutoincrementable"' typeof(bool));                  table.Columns.Add("IsBestMatch"' typeof(bool));                  table.Columns.Add("IsCaseSensitive"' typeof(bool));                  table.Columns.Add("IsFixedLength"' typeof(bool));                  table.Columns.Add("IsFixedPrecisionScale"' typeof(bool));                  table.Columns.Add("IsLong"' typeof(bool));                  table.Columns.Add("IsNullable"' typeof(bool));                  table.Columns.Add("IsSearchable"' typeof(bool));                  table.Columns.Add("IsSearchableWithLike"' typeof(bool));                  table.Columns.Add("IsUnsigned"' typeof(bool));                  table.Columns.Add("MaximumScale"' typeof(short));                  table.Columns.Add("MinimumScale"' typeof(short));                  table.Columns.Add("IsConcurrencyType"' typeof(bool));                  table.Columns.Add("IsLiteralsSupported"' typeof(bool));                  table.Columns.Add("LiteralPrefix"' typeof(string));                  table.Columns.Add("LiteralSuffix"' typeof(string));                  table.Columns.Add("NativeDataType"' typeof(string));    // NativeDataType is an OLE DB specific column for exposing the OLE DB type of the data type .                    table.ReadXml(XmlReader.Create(typeof(NuoDbConnectionInternal).Assembly.GetManifestResourceStream("NuoDb.Data.Client.DataTypes.xml")));              }              else if (collectionName == "Tables")              {                  table.Columns.Add("TABLE_CATALOG"' typeof(string));                  table.Columns.Add("TABLE_SCHEMA"' typeof(string));                  table.Columns.Add("TABLE_NAME"' typeof(string));                  table.Columns.Add("TABLE_TYPE"' typeof(string));                  table.Columns.Add("REMARKS"' typeof(string));                  table.Columns.Add("VIEW_DEF"' typeof(string));                    tmConn.InternalConnection.dataStream.startMessage(Protocol.GetTables);                  tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                  for (int i = 1; i < 3; i++)                      if (restrictionValues != null && restrictionValues.Length > i)                          tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                      else                          tmConn.InternalConnection.dataStream.encodeNull();                  if (restrictionValues == null || restrictionValues.Length < 4 || restrictionValues[3] == null)                      tmConn.InternalConnection.dataStream.encodeInt(0);                  else                  {                      tmConn.InternalConnection.dataStream.encodeInt(1);                      tmConn.InternalConnection.dataStream.encodeString(restrictionValues[3]);                  }                    tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                  int handle = tmConn.InternalConnection.dataStream.getInt();                    if (handle != -1)                  {                      using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                      {                          table.BeginLoadData();                          string view_def_label="";                          try                           {                               reader.GetOrdinal("VIEW_DEF");                              view_def_label = "VIEW_DEF";                          }                          catch(Exception) {}                          try                           {                               reader.GetOrdinal("VIEWDEFINITION");                              view_def_label = "VIEWDEFINITION";                          }                          catch (Exception) { }                          while (reader.Read())                          {  #if DEBUG                          System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_NAME"] + "' " + reader["TABLE_TYPE"]);  #endif                              DataRow row = table.NewRow();                              row["TABLE_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                              row["TABLE_NAME"] = reader.GetFieldValue<string>("TABLE_NAME");                              row["TABLE_TYPE"] = reader.GetFieldValue<string>("TABLE_TYPE");                              row["REMARKS"] = reader.GetFieldValue<string>("REMARKS");                              if (view_def_label.Length != 0)                              {                                  row["VIEW_DEF"] = reader.GetFieldValue<string>(view_def_label);                              }                              table.Rows.Add(row);                          }                          table.EndLoadData();                      }                  }              }              else if (collectionName == "Columns")              {                  table.Columns.Add("COLUMN_CATALOG"' typeof(string));                  table.Columns.Add("COLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("COLUMN_TABLE"' typeof(string));                  table.Columns.Add("COLUMN_NAME"' typeof(string));                  table.Columns.Add("COLUMN_POSITION"' typeof(int));                  table.Columns.Add("COLUMN_TYPE"' typeof(string));                  table.Columns.Add("COLUMN_LENGTH"' typeof(int));                  table.Columns.Add("COLUMN_PRECISION"' typeof(int));                  table.Columns.Add("COLUMN_NULLABLE"' typeof(bool));                  table.Columns.Add("COLUMN_IDENTITY"' typeof(bool));                  table.Columns.Add("COLUMN_DEFAULT"' typeof(string));                  table.Columns.Add("COLUMN_SCALE"' typeof(int));                    tmConn.InternalConnection.dataStream.startMessage(Protocol.GetColumns);                  tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                  for (int i = 1; i < 4; i++)                      if (restrictionValues != null && restrictionValues.Length > i)                          tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                      else                          tmConn.InternalConnection.dataStream.encodeNull();                    tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                  int handle = tmConn.InternalConnection.dataStream.getInt();                    if (handle != -1)                  {                      using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                      {                          table.BeginLoadData();                          while (reader.Read())                          {                              DataRow row = table.NewRow();                              row["COLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                              row["COLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                              row["COLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                              row["COLUMN_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                              row["COLUMN_LENGTH"] = reader.GetFieldValue<int>("COLUMN_SIZE");                              row["COLUMN_PRECISION"] = reader.GetFieldValue<int>("BUFFER_LENGTH");                              row["COLUMN_SCALE"] = reader.GetFieldValue<int>("DECIMAL_DIGITS");                              if (isNumeric(reader.GetFieldValue<string>("TYPE_NAME")))                              {                                  if (reader.GetFieldValue<int>("DECIMAL_DIGITS") != 0)                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME") +                                           "(" + reader.GetFieldValue<int>("BUFFER_LENGTH") + "'" + reader.GetFieldValue<int>("DECIMAL_DIGITS") + ")";                                  else                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME");                              }                              else                              {                                  if (isVarLenType(reader.GetFieldValue<string>("TYPE_NAME")) && reader.GetFieldValue<int>("COLUMN_SIZE") != 0)                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME") +                                           "(" + reader.GetFieldValue<int>("COLUMN_SIZE") + ")";                                  else                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME");                              }                              if (!reader.IsDBNull(reader.GetOrdinal("IS_NULLABLE")))                                  row["COLUMN_NULLABLE"] = reader.GetFieldValue<string>("IS_NULLABLE").Equals("YES");                              if (!reader.IsDBNull(reader.GetOrdinal("IS_AUTOINCREMENT")))                                  row["COLUMN_IDENTITY"] = reader.GetFieldValue<string>("IS_AUTOINCREMENT").Equals("YES");                              row["COLUMN_DEFAULT"] = reader.GetFieldValue<string>("COLUMN_DEF");    #if DEBUG                              System.Diagnostics.Trace.WriteLine("-> " + row["COLUMN_NAME"] + " " + row["COLUMN_TYPE"]);  #endif                              table.Rows.Add(row);                          }                          table.EndLoadData();                      }                  }              }              else if (collectionName == "Indexes")              {                  table.Columns.Add("INDEX_CATALOG"' typeof(string));                  table.Columns.Add("INDEX_SCHEMA"' typeof(string));                  table.Columns.Add("INDEX_TABLE"' typeof(string));                  table.Columns.Add("INDEX_NAME"' typeof(string));                  table.Columns.Add("INDEX_TYPE"' typeof(string));                  table.Columns.Add("INDEX_UNIQUE"' typeof(bool));                  table.Columns.Add("INDEX_PRIMARY"' typeof(bool));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetIndexInfo);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // unique                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // approximate                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        // to avoid to insert the same index more than once                      HashSet<string> unique = new HashSet<string>();                      if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;                                  if (!unique.Add(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;                                  DataRow row = table.NewRow();                                  row["INDEX_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEX_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEX_NAME"] = reader.GetFieldValue<string>("INDEX_NAME");                                  switch (reader.GetFieldValue<int>("TYPE"))                                  {                                      case 0:                                          row["INDEX_TYPE"] = "Primary";                                          break;                                      case 1:                                          row["INDEX_TYPE"] = "Unique";                                          break;                                      case 2:                                          row["INDEX_TYPE"] = "Secondary";                                          break;                                      case 3:                                          row["INDEX_TYPE"] = "Foreign Key";                                          break;                                  }                                  row["INDEX_UNIQUE"] = (reader.GetFieldValue<int>("NON_UNIQUE") == 0) ? true : false;                                  row["INDEX_PRIMARY"] = (reader.GetFieldValue<int>("TYPE") == 0) ? true : false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                        tmConn.InternalConnection.dataStream.startMessage(Protocol.GetPrimaryKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              // use INDEX_NAME' if present; if missing' the name of the index is in PK_NAME                              string indexName = "PK_NAME";                              foreach (string column in reader.columnNames)                              {                                  if (column == "INDEX_NAME")                                  {                                      indexName = "INDEX_NAME";                                      break;                                  }                              }                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>(indexName)))                                      continue;                                  if (!unique.Add(reader.GetFieldValue<string>(indexName)))                                      continue;                                  DataRow row = table.NewRow();                                  row["INDEX_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEX_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEX_NAME"] = reader.GetFieldValue<string>(indexName);                                  row["INDEX_TYPE"] = "Primary";                                  row["INDEX_UNIQUE"] = true;                                  row["INDEX_PRIMARY"] = true;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "IndexColumns")              {                  table.Columns.Add("INDEXCOLUMN_CATALOG"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_TABLE"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_INDEX"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_NAME"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_POSITION"' typeof(int));                  table.Columns.Add("INDEXCOLUMN_ISPRIMARY"' typeof(bool));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetIndexInfo);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // unique                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // approximate                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_SCHEM"] + "." + reader["TABLE_NAME"] + "=" + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["INDEXCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEXCOLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEXCOLUMN_INDEX"] = reader.GetFieldValue<string>("INDEX_NAME");                                  row["INDEXCOLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["INDEXCOLUMN_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                                  row["INDEXCOLUMN_ISPRIMARY"] = false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                        tmConn.InternalConnection.dataStream.startMessage(Protocol.GetPrimaryKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              // use INDEX_NAME' if present; if missing' the name of the index is in PK_NAME                              string indexName = "PK_NAME";                              foreach (string column in reader.columnNames)                              {                                  if (column == "INDEX_NAME")                                  {                                      indexName = "INDEX_NAME";                                      break;                                  }                              }                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>(indexName)))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_SCHEM"] + "." + reader["TABLE_NAME"] + " (Primary) =" + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["INDEXCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEXCOLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEXCOLUMN_INDEX"] = reader.GetFieldValue<string>(indexName);                                  row["INDEXCOLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["INDEXCOLUMN_POSITION"] = reader.GetFieldValue<int>("KEY_SEQ");                                  row["INDEXCOLUMN_ISPRIMARY"] = true;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ForeignKeys")              {                  table.Columns.Add("FOREIGNKEY_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEY_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEY_TABLE"' typeof(string));                  table.Columns.Add("FOREIGNKEY_NAME"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_TABLE"' typeof(string));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetImportedKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  string name = "[" + reader.GetFieldValue<string>("FKTABLE_SCHEM") + "]" +                                                   reader.GetFieldValue<string>("FKTABLE_NAME") + "." +                                                   reader.GetFieldValue<string>("FKCOLUMN_NAME") + "->" +                                                  "[" + reader.GetFieldValue<string>("PKTABLE_SCHEM") + "]" +                                                   reader.GetFieldValue<string>("PKTABLE_NAME") + "." +                                                   reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(name))                                      continue;                                  DataRow row = table.NewRow();                                  row["FOREIGNKEY_SCHEMA"] = reader.GetFieldValue<string>("FKTABLE_SCHEM");                                  row["FOREIGNKEY_TABLE"] = reader.GetFieldValue<string>("FKTABLE_NAME");                                  row["FOREIGNKEY_NAME"] = name;                                  row["FOREIGNKEY_OTHER_SCHEMA"] = reader.GetFieldValue<string>("PKTABLE_SCHEM");                                  row["FOREIGNKEY_OTHER_TABLE"] = reader.GetFieldValue<string>("PKTABLE_NAME");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ForeignKeyColumns")              {                  table.Columns.Add("FOREIGNKEYCOLUMN_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_TABLE"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_KEY"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_NAME"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_ORDINAL"' typeof(int));                  table.Columns.Add("FOREIGNKEYCOLUMN_OTHER_COLUMN_NAME"' typeof(string));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetImportedKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  string name = "[" + reader.GetFieldValue<string>("FKTABLE_SCHEM") + "]" +                                                  reader.GetFieldValue<string>("FKTABLE_NAME") + "." +                                                  reader.GetFieldValue<string>("FKCOLUMN_NAME") + "->" +                                                  "[" + reader.GetFieldValue<string>("PKTABLE_SCHEM") + "]" +                                                  reader.GetFieldValue<string>("PKTABLE_NAME") + "." +                                                  reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(name))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["FKTABLE_SCHEM"] + "." + reader["FKTABLE_NAME"] + "=" + reader["FKCOLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["FOREIGNKEYCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("FKTABLE_SCHEM");                                  row["FOREIGNKEYCOLUMN_TABLE"] = reader.GetFieldValue<string>("FKTABLE_NAME");                                  row["FOREIGNKEYCOLUMN_KEY"] = name;                                  row["FOREIGNKEYCOLUMN_NAME"] = reader.GetFieldValue<string>("FKCOLUMN_NAME");                                  row["FOREIGNKEYCOLUMN_ORDINAL"] = reader.GetFieldValue<int>("KEY_SEQ");                                  row["FOREIGNKEYCOLUMN_OTHER_COLUMN_NAME"] = reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "Procedures")               {                  table.Columns.Add("PROCEDURE_CATALOG"' typeof(string));                  table.Columns.Add("PROCEDURE_SCHEMA"' typeof(string));                  table.Columns.Add("PROCEDURE_NAME"' typeof(string));                  table.Columns.Add("IS_SYSTEM_PROCEDURE"' typeof(bool));                    if (tmConn.InternalConnection.protocolVersion >= Protocol.PROTOCOL_VERSION12)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetProcedures);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      for (int i = 1; i < 3; i++)                          if (restrictionValues != null && restrictionValues.Length > i)                              tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                          else                              tmConn.InternalConnection.dataStream.encodeNull();                        tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["PROCEDURE_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["PROCEDURE_SCHEMA"] = reader.GetFieldValue<string>("PROCEDURE_SCHEM");                                  row["PROCEDURE_NAME"] = reader.GetFieldValue<string>("PROCEDURE_NAME");                                  row["IS_SYSTEM_PROCEDURE"] = false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ProcedureParameters")              {                  table.Columns.Add("PROCEDURE_CATALOG"' typeof(string));                  table.Columns.Add("PROCEDURE_SCHEMA"' typeof(string));                  table.Columns.Add("PROCEDURE_NAME"' typeof(string));                  table.Columns.Add("PARAMETER_NAME"' typeof(string));                  table.Columns.Add("ORDINAL_POSITION"' typeof(int));                  table.Columns.Add("PARAMETER_DATA_TYPE"' typeof(int));                  table.Columns.Add("PARAMETER_TYPE_NAME"' typeof(string));                  table.Columns.Add("PARAMETER_SIZE"' typeof(int));                  table.Columns.Add("NUMERIC_PRECISION"' typeof(int));                  table.Columns.Add("NUMERIC_SCALE"' typeof(int));                  table.Columns.Add("PARAMETER_DIRECTION"' typeof(int));                  table.Columns.Add("IS_NULLABLE"' typeof(bool));                    if (tmConn.InternalConnection.protocolVersion >= Protocol.PROTOCOL_VERSION12)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetProcedureColumns);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      for (int i = 1; i < 4; i++)                          if (restrictionValues != null && restrictionValues.Length > i)                              tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                          else                              tmConn.InternalConnection.dataStream.encodeNull();                        tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["PROCEDURE_NAME"] + "' " + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["PROCEDURE_SCHEMA"] = reader.GetFieldValue<string>("PROCEDURE_SCHEM");                                  row["PROCEDURE_NAME"] = reader.GetFieldValue<string>("PROCEDURE_NAME");                                  row["PARAMETER_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["ORDINAL_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                                  row["PARAMETER_TYPE_NAME"] = reader.GetFieldValue<string>("TYPE_NAME");                                  row["PARAMETER_DATA_TYPE"] = reader.GetFieldValue<int>("DATA_TYPE");                                  row["PARAMETER_SIZE"] = reader.GetFieldValue<int>("LENGTH");                                  row["NUMERIC_PRECISION"] = reader.GetFieldValue<int>("PRECISION");                                  row["NUMERIC_SCALE"] = reader.GetFieldValue<int>("SCALE");                                  row["PARAMETER_DIRECTION"] = reader.GetFieldValue<int>("COLUMN_TYPE");                                  row["IS_NULLABLE"] = !reader.GetFieldValue<string>("IS_NULLABLE").Equals("NO");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The following statement contains a magic number: if (collectionName == DbMetaDataCollectionNames.DataSourceInformation)              {                  // see http://msdn.microsoft.com/en-us/library/ms254501.aspx                  table.Columns.Add("CompositeIdentifierSeparatorPattern"' typeof(string));                  table.Columns.Add("DataSourceProductName"' typeof(string));                  table.Columns.Add("DataSourceProductVersion"' typeof(string));                  table.Columns.Add("DataSourceProductVersionNormalized"' typeof(string));                  table.Columns.Add("DataSourceInternalProductVersion"' typeof(string));                  table.Columns.Add("GroupByBehavior"' typeof(GroupByBehavior));                  table.Columns.Add("IdentifierPattern"' typeof(string));                  table.Columns.Add("IdentifierCase"' typeof(IdentifierCase));                  table.Columns.Add("OrderByColumnsInSelect"' typeof(bool));                  table.Columns.Add("ParameterMarkerFormat"' typeof(string));                  table.Columns.Add("ParameterMarkerPattern"' typeof(string));                  table.Columns.Add("ParameterNameMaxLength"' typeof(int));                  table.Columns.Add("ParameterNamePattern"' typeof(string));                  table.Columns.Add("QuotedIdentifierPattern"' typeof(string));  // Regex                  table.Columns.Add("QuotedIdentifierCase"' typeof(int));                  table.Columns.Add("StatementSeparatorPattern"' typeof(string));                  table.Columns.Add("StringLiteralPattern"' typeof(string));  // Regex                  table.Columns.Add("SupportedJoinOperators"' typeof(SupportedJoinOperators));                    table.BeginLoadData();                  DataRow row = table.NewRow();                  int databaseMajorVersion = 0' databaseMinorVersion = 0;                  try                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetDatabaseMetaData);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      for (int item; (item = tmConn.InternalConnection.dataStream.getInt()) != Protocol.DbmbFini; )                      {                          switch (item)                          {                              case Protocol.DbmbProductName:                                  row["DataSourceProductName"] = tmConn.InternalConnection.dataStream.getString();                                  break;                                case Protocol.DbmbProductVersion:                                  row["DataSourceProductVersion"] = tmConn.InternalConnection.dataStream.getString();                                  break;                                case Protocol.DbmbDatabaseMinorVersion:                                  databaseMinorVersion = tmConn.InternalConnection.dataStream.getInt();                                  break;                                case Protocol.DbmbDatabaseMajorVersion:                                  databaseMajorVersion = tmConn.InternalConnection.dataStream.getInt();                                  break;                                case Protocol.DbmbDefaultTransactionIsolation:                                  int defaultTransactionIsolation = tmConn.InternalConnection.dataStream.getInt();                                  break;                                default:                                  tmConn.InternalConnection.dataStream.decode();                                  break;                          }                      }                  }                  catch (Exception)                  {                  }                    row["DataSourceInternalProductVersion"] = String.Format("{0:D3}.{1:D3}"' databaseMajorVersion' databaseMinorVersion);                  // The regular expression to match the composite separators in a composite identifier.                   // For example' "\." (for SQL Server) or "@|\." (for Oracle).                  // A composite identifier is typically what is used for a database object name'                   // for example: pubs.dbo.authors or pubs@dbo.authors.                  row["CompositeIdentifierSeparatorPattern"] = "\\.";                  // A normalized version for the data source' such that it can be compared with String.Compare().                   // The format of this is consistent for all versions of the provider to prevent version 10 from sorting between version 1 and version 2.                  //row["DataSourceProductVersionNormalized"] = ??                  // Specifies the relationship between the columns in a GROUP BY clause and the non-aggregated columns in the select list.                  row["GroupByBehavior"] = GroupByBehavior.Unknown;                  // A regular expression that matches an identifier and has a match value of the identifier. For example "[A-Za-z0-9_#$]".                  row["IdentifierPattern"] = "(^\\[\\p{Lo}\\p{Lu}\\p{Ll}_@#][\\p{Lo}\\p{Lu}\\p{Ll}\\p{Nd}@$#_]*$)|(^\"[^\"\\0]|\"\"+\"$)";                  // Indicates whether non-quoted identifiers are treated as case sensitive or not.                  row["IdentifierCase"] = IdentifierCase.Insensitive;                  // Specifies whether columns in an ORDER BY clause must be in the select list.                   // A value of true indicates that they are required to be in the select list'                   // a value of false indicates that they are not required to be in the select list.                  row["OrderByColumnsInSelect"] = false;                  // For data sources that do not expect named parameters and expect the use of the ‘?’ character' the format string                  // can be specified as simply '?'' which would ignore the parameter name.                  row["ParameterMarkerFormat"] = "?";                  // if the data source doesn't support named parameters' this would simply be "?".                  row["ParameterMarkerPattern"] = "?";                  // If the data source does not support named parameters' this property returns zero.                  row["ParameterNameMaxLength"] = 0;                  // A regular expression that matches the valid parameter names                  row["ParameterNamePattern"] = "";                  // A regular expression that matches a quoted identifier and has a match value of the identifier itself without the quotes.                   // For example' if the data source used double-quotes to identify quoted identifiers' this would be: "(([^\"]|\"\")*)".                  row["QuotedIdentifierPattern"] = "\"([^\"]*)\"";                  // Indicates whether quoted identifiers are treated as case sensitive or not.                  row["QuotedIdentifierCase"] = IdentifierCase.Sensitive;                  // A regular expression that matches the statement separator.                  row["StatementSeparatorPattern"] = ";";                  // A regular expression that matches a string literal and has a match value of the literal itself.                   // For example' if the data source used single-quotes to identify strings' this would be: "('([^']|'')*')"'                  row["StringLiteralPattern"] = "'([^']*)'";                  // Specifies what types of SQL join statements are supported by the data source.                  row["SupportedJoinOperators"] = SupportedJoinOperators.None;                  table.Rows.Add(row);                  table.EndLoadData();              }              else if (collectionName == DbMetaDataCollectionNames.ReservedWords)              {                  table.Columns.Add("ReservedWord"' typeof(string));                  table.Columns.Add("MaximumVersion"' typeof(string));                  table.Columns.Add("MinimumVersion"' typeof(string));                    string[] words = { "select"' "Add field"' "Drop field"' "Alter table"' "Alter field"'                                      "Alter user"' "And"' "Or"' "Not"' "Create Index"' "Upgrade"' "Unique"'                                      "Table key"' "Table unique key"' "Primary Key"' "Create Table"'                                      "Upgrade Table"' "Rename Table"' "Create View"' "Upgrade View"'                                      "Drop View"' "Create Schema"' "Drop Schema"' "Integer"' "Smallint"'                                      "Bigint"' "Tinyint"' "float"' "double"' "Blob"' "bytes"' "boolean"'                                      "binary"' "varbinary"' "string"' "char"' "text"' "date"' "timestamp"'                                      "time"' "varchar"' "numeric"' "Decimal Number"' "Enum"' "Delete"' "Repair"'                                      "Field"' "Not Null"' "Default Value"' "searchable"' "not searchable"'                                      "collation"' "character_set"' "Foreign Key"' "Identifier"' "record number"'                                      "Insert"' "Replace"' "Name"' "Number"' "Order"' "Descending"' "limit"'                                      "Quoted String"' "Select Clause"' "Distinct"' "Gtr"' "Geq"' "Eql"'                                      "Leq"' "Lss"' "Neq"' "in list"' "in select"' "exists"' "Between"' "Like"'                                      "starts with"' "Containing"' "Matching"' "Regular expression"' "Null"'                                      "True"' "False"' "Execute"' "Parameter"' "Count"' "sum"' "min"' "max"'                                      "avg"' "Drop Index"' "Drop primary key"' "Drop foreign key"' "Drop Table"'                                      "If Exists"' "Describe"' "Statement"' "for_select"' "for_insert"' "while"'                                      "if then else"' "variable"' "declaration"' "throw"' "assignment"'                                      "Start transaction"' "read only"' "read write"' "read committed"' "write committed"'                                      "read uncommitted"' "repeatableread"' "serializable"' "Commit"' "Rollback"'                                      "Savepoint"' "Rollack Savepoint"' "Release Savepoint"' "Table"' "Derived Table"'                                      "Assign"' "Update"' "list"' "Constant"' "Function"' "Grant"' "Grant role"' "Alter"'                                      "Read"' "Identity"' "Check"' "Constraint"' "value constraint"' "auto increment"'                                      "generated"' "always"' "Domain"' "is null"' "is active_role"' "start with"' "reindex"'                                      "cursor"' "alias"' "push_namespace"' "pop_namespace"' "set_namespace"' "coalesce"'                                      "nod_nullif"' "case"' "case_search"' "add"' "subtract"' "multiply"' "divide"' "modulus"'                                      "negate"' "plus"' "cast"' "concatenation"' "create user"' "drop user"' "create role"'                                      "upgrade role"' "drop role"' "revoke"' "revoke role"' "assume"' "revert"' "negate"'                                      "priv insert"' "priv delete"' "priv execute"' "priv select"' "priv update"' "priv grant"'                                      "priv all"' "characters"' "octets"' "role"' "view"' "procedure"' "user"' "zone"' "admin"'                                      "default role"' "create sequence"' "upgrade sequence"' "drop sequence"' "next value"'                                      "create trigger"' "upgrade trigger"' "alter trigger"' "drop trigger"' "create procedure"'                                      "upgrade procedure"' "alter procedure"' "drop procedure"' "pre-insert"' "post-insert"'                                      "pre-update"' "post-update"' "pre-delete"' "post-delete"' "pre-commit"' "post-commit"'                                      "active"' "inactive"' "position"' "select-expr"' "create filterset"' "upgrade filterset"'                                      "drop filterset"' "enable filterset"' "disable filterset"' "table filter"' "left outer"'                                      "right outer"' "full outer"' "inner"' "join"' "join_term"' "trigger class"' "enable trigger class"'                                      "disable trigger class"' "create zone"' "upgrade zone"' "drop zone"' "range"' "ip address"'                                      "node_name"' "wildcard"' "create domain"' "upgrade domain"' "alter domain"' "upgrade schema"'                                      "delete cascade"' "index segment"' "for update"' "write committed"' "read committed"'                                       "consistent read"' "set dialect"' "set names"' "restrict"' "cascade"' "characters"' "octets"'                                      "create event"' "collate"' "truncate"' "restart"' "nameless constraint"' "drop constraint"'                                      "drop unique constraint"' "drop domain"' "with check option"' "not real"' "lower"' "upper"'                                      "substr"' "substring index"' "charlength"' "default keyword"' "sqrt"' "power"' "Scientific Notation Number"'                                      "Explain"' "msleep"' "KillStatement"' "now" };                  table.BeginLoadData();                  foreach (string keyword in words)                  {                      DataRow row = table.NewRow();                      row["ReservedWord"] = keyword;                      table.Rows.Add(row);                  }                  table.EndLoadData();                }              else if (collectionName == DbMetaDataCollectionNames.DataTypes)              {                  table.Columns.Add("TypeName"' typeof(string));  // The provider-specific data type name.                  table.Columns.Add("ProviderDbType"' typeof(int)); // The provider-specific type value that should be used when specifying                   //a parameter's type. For example' SqlDbType.Money or OracleType.Blob.                  table.Columns.Add("ColumnSize"' typeof(long));                  table.Columns.Add("CreateFormat"' typeof(string));                  table.Columns.Add("CreateParameters"' typeof(string));                  table.Columns.Add("DataType"' typeof(string));  // The name of the .NET Framework type of the data type.                  table.Columns.Add("IsAutoincrementable"' typeof(bool));                  table.Columns.Add("IsBestMatch"' typeof(bool));                  table.Columns.Add("IsCaseSensitive"' typeof(bool));                  table.Columns.Add("IsFixedLength"' typeof(bool));                  table.Columns.Add("IsFixedPrecisionScale"' typeof(bool));                  table.Columns.Add("IsLong"' typeof(bool));                  table.Columns.Add("IsNullable"' typeof(bool));                  table.Columns.Add("IsSearchable"' typeof(bool));                  table.Columns.Add("IsSearchableWithLike"' typeof(bool));                  table.Columns.Add("IsUnsigned"' typeof(bool));                  table.Columns.Add("MaximumScale"' typeof(short));                  table.Columns.Add("MinimumScale"' typeof(short));                  table.Columns.Add("IsConcurrencyType"' typeof(bool));                  table.Columns.Add("IsLiteralsSupported"' typeof(bool));                  table.Columns.Add("LiteralPrefix"' typeof(string));                  table.Columns.Add("LiteralSuffix"' typeof(string));                  table.Columns.Add("NativeDataType"' typeof(string));    // NativeDataType is an OLE DB specific column for exposing the OLE DB type of the data type .                    table.ReadXml(XmlReader.Create(typeof(NuoDbConnectionInternal).Assembly.GetManifestResourceStream("NuoDb.Data.Client.DataTypes.xml")));              }              else if (collectionName == "Tables")              {                  table.Columns.Add("TABLE_CATALOG"' typeof(string));                  table.Columns.Add("TABLE_SCHEMA"' typeof(string));                  table.Columns.Add("TABLE_NAME"' typeof(string));                  table.Columns.Add("TABLE_TYPE"' typeof(string));                  table.Columns.Add("REMARKS"' typeof(string));                  table.Columns.Add("VIEW_DEF"' typeof(string));                    tmConn.InternalConnection.dataStream.startMessage(Protocol.GetTables);                  tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                  for (int i = 1; i < 3; i++)                      if (restrictionValues != null && restrictionValues.Length > i)                          tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                      else                          tmConn.InternalConnection.dataStream.encodeNull();                  if (restrictionValues == null || restrictionValues.Length < 4 || restrictionValues[3] == null)                      tmConn.InternalConnection.dataStream.encodeInt(0);                  else                  {                      tmConn.InternalConnection.dataStream.encodeInt(1);                      tmConn.InternalConnection.dataStream.encodeString(restrictionValues[3]);                  }                    tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                  int handle = tmConn.InternalConnection.dataStream.getInt();                    if (handle != -1)                  {                      using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                      {                          table.BeginLoadData();                          string view_def_label="";                          try                           {                               reader.GetOrdinal("VIEW_DEF");                              view_def_label = "VIEW_DEF";                          }                          catch(Exception) {}                          try                           {                               reader.GetOrdinal("VIEWDEFINITION");                              view_def_label = "VIEWDEFINITION";                          }                          catch (Exception) { }                          while (reader.Read())                          {  #if DEBUG                          System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_NAME"] + "' " + reader["TABLE_TYPE"]);  #endif                              DataRow row = table.NewRow();                              row["TABLE_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                              row["TABLE_NAME"] = reader.GetFieldValue<string>("TABLE_NAME");                              row["TABLE_TYPE"] = reader.GetFieldValue<string>("TABLE_TYPE");                              row["REMARKS"] = reader.GetFieldValue<string>("REMARKS");                              if (view_def_label.Length != 0)                              {                                  row["VIEW_DEF"] = reader.GetFieldValue<string>(view_def_label);                              }                              table.Rows.Add(row);                          }                          table.EndLoadData();                      }                  }              }              else if (collectionName == "Columns")              {                  table.Columns.Add("COLUMN_CATALOG"' typeof(string));                  table.Columns.Add("COLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("COLUMN_TABLE"' typeof(string));                  table.Columns.Add("COLUMN_NAME"' typeof(string));                  table.Columns.Add("COLUMN_POSITION"' typeof(int));                  table.Columns.Add("COLUMN_TYPE"' typeof(string));                  table.Columns.Add("COLUMN_LENGTH"' typeof(int));                  table.Columns.Add("COLUMN_PRECISION"' typeof(int));                  table.Columns.Add("COLUMN_NULLABLE"' typeof(bool));                  table.Columns.Add("COLUMN_IDENTITY"' typeof(bool));                  table.Columns.Add("COLUMN_DEFAULT"' typeof(string));                  table.Columns.Add("COLUMN_SCALE"' typeof(int));                    tmConn.InternalConnection.dataStream.startMessage(Protocol.GetColumns);                  tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                  for (int i = 1; i < 4; i++)                      if (restrictionValues != null && restrictionValues.Length > i)                          tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                      else                          tmConn.InternalConnection.dataStream.encodeNull();                    tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                  int handle = tmConn.InternalConnection.dataStream.getInt();                    if (handle != -1)                  {                      using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                      {                          table.BeginLoadData();                          while (reader.Read())                          {                              DataRow row = table.NewRow();                              row["COLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                              row["COLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                              row["COLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                              row["COLUMN_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                              row["COLUMN_LENGTH"] = reader.GetFieldValue<int>("COLUMN_SIZE");                              row["COLUMN_PRECISION"] = reader.GetFieldValue<int>("BUFFER_LENGTH");                              row["COLUMN_SCALE"] = reader.GetFieldValue<int>("DECIMAL_DIGITS");                              if (isNumeric(reader.GetFieldValue<string>("TYPE_NAME")))                              {                                  if (reader.GetFieldValue<int>("DECIMAL_DIGITS") != 0)                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME") +                                           "(" + reader.GetFieldValue<int>("BUFFER_LENGTH") + "'" + reader.GetFieldValue<int>("DECIMAL_DIGITS") + ")";                                  else                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME");                              }                              else                              {                                  if (isVarLenType(reader.GetFieldValue<string>("TYPE_NAME")) && reader.GetFieldValue<int>("COLUMN_SIZE") != 0)                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME") +                                           "(" + reader.GetFieldValue<int>("COLUMN_SIZE") + ")";                                  else                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME");                              }                              if (!reader.IsDBNull(reader.GetOrdinal("IS_NULLABLE")))                                  row["COLUMN_NULLABLE"] = reader.GetFieldValue<string>("IS_NULLABLE").Equals("YES");                              if (!reader.IsDBNull(reader.GetOrdinal("IS_AUTOINCREMENT")))                                  row["COLUMN_IDENTITY"] = reader.GetFieldValue<string>("IS_AUTOINCREMENT").Equals("YES");                              row["COLUMN_DEFAULT"] = reader.GetFieldValue<string>("COLUMN_DEF");    #if DEBUG                              System.Diagnostics.Trace.WriteLine("-> " + row["COLUMN_NAME"] + " " + row["COLUMN_TYPE"]);  #endif                              table.Rows.Add(row);                          }                          table.EndLoadData();                      }                  }              }              else if (collectionName == "Indexes")              {                  table.Columns.Add("INDEX_CATALOG"' typeof(string));                  table.Columns.Add("INDEX_SCHEMA"' typeof(string));                  table.Columns.Add("INDEX_TABLE"' typeof(string));                  table.Columns.Add("INDEX_NAME"' typeof(string));                  table.Columns.Add("INDEX_TYPE"' typeof(string));                  table.Columns.Add("INDEX_UNIQUE"' typeof(bool));                  table.Columns.Add("INDEX_PRIMARY"' typeof(bool));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetIndexInfo);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // unique                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // approximate                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        // to avoid to insert the same index more than once                      HashSet<string> unique = new HashSet<string>();                      if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;                                  if (!unique.Add(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;                                  DataRow row = table.NewRow();                                  row["INDEX_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEX_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEX_NAME"] = reader.GetFieldValue<string>("INDEX_NAME");                                  switch (reader.GetFieldValue<int>("TYPE"))                                  {                                      case 0:                                          row["INDEX_TYPE"] = "Primary";                                          break;                                      case 1:                                          row["INDEX_TYPE"] = "Unique";                                          break;                                      case 2:                                          row["INDEX_TYPE"] = "Secondary";                                          break;                                      case 3:                                          row["INDEX_TYPE"] = "Foreign Key";                                          break;                                  }                                  row["INDEX_UNIQUE"] = (reader.GetFieldValue<int>("NON_UNIQUE") == 0) ? true : false;                                  row["INDEX_PRIMARY"] = (reader.GetFieldValue<int>("TYPE") == 0) ? true : false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                        tmConn.InternalConnection.dataStream.startMessage(Protocol.GetPrimaryKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              // use INDEX_NAME' if present; if missing' the name of the index is in PK_NAME                              string indexName = "PK_NAME";                              foreach (string column in reader.columnNames)                              {                                  if (column == "INDEX_NAME")                                  {                                      indexName = "INDEX_NAME";                                      break;                                  }                              }                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>(indexName)))                                      continue;                                  if (!unique.Add(reader.GetFieldValue<string>(indexName)))                                      continue;                                  DataRow row = table.NewRow();                                  row["INDEX_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEX_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEX_NAME"] = reader.GetFieldValue<string>(indexName);                                  row["INDEX_TYPE"] = "Primary";                                  row["INDEX_UNIQUE"] = true;                                  row["INDEX_PRIMARY"] = true;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "IndexColumns")              {                  table.Columns.Add("INDEXCOLUMN_CATALOG"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_TABLE"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_INDEX"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_NAME"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_POSITION"' typeof(int));                  table.Columns.Add("INDEXCOLUMN_ISPRIMARY"' typeof(bool));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetIndexInfo);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // unique                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // approximate                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_SCHEM"] + "." + reader["TABLE_NAME"] + "=" + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["INDEXCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEXCOLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEXCOLUMN_INDEX"] = reader.GetFieldValue<string>("INDEX_NAME");                                  row["INDEXCOLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["INDEXCOLUMN_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                                  row["INDEXCOLUMN_ISPRIMARY"] = false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                        tmConn.InternalConnection.dataStream.startMessage(Protocol.GetPrimaryKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              // use INDEX_NAME' if present; if missing' the name of the index is in PK_NAME                              string indexName = "PK_NAME";                              foreach (string column in reader.columnNames)                              {                                  if (column == "INDEX_NAME")                                  {                                      indexName = "INDEX_NAME";                                      break;                                  }                              }                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>(indexName)))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_SCHEM"] + "." + reader["TABLE_NAME"] + " (Primary) =" + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["INDEXCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEXCOLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEXCOLUMN_INDEX"] = reader.GetFieldValue<string>(indexName);                                  row["INDEXCOLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["INDEXCOLUMN_POSITION"] = reader.GetFieldValue<int>("KEY_SEQ");                                  row["INDEXCOLUMN_ISPRIMARY"] = true;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ForeignKeys")              {                  table.Columns.Add("FOREIGNKEY_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEY_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEY_TABLE"' typeof(string));                  table.Columns.Add("FOREIGNKEY_NAME"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_TABLE"' typeof(string));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetImportedKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  string name = "[" + reader.GetFieldValue<string>("FKTABLE_SCHEM") + "]" +                                                   reader.GetFieldValue<string>("FKTABLE_NAME") + "." +                                                   reader.GetFieldValue<string>("FKCOLUMN_NAME") + "->" +                                                  "[" + reader.GetFieldValue<string>("PKTABLE_SCHEM") + "]" +                                                   reader.GetFieldValue<string>("PKTABLE_NAME") + "." +                                                   reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(name))                                      continue;                                  DataRow row = table.NewRow();                                  row["FOREIGNKEY_SCHEMA"] = reader.GetFieldValue<string>("FKTABLE_SCHEM");                                  row["FOREIGNKEY_TABLE"] = reader.GetFieldValue<string>("FKTABLE_NAME");                                  row["FOREIGNKEY_NAME"] = name;                                  row["FOREIGNKEY_OTHER_SCHEMA"] = reader.GetFieldValue<string>("PKTABLE_SCHEM");                                  row["FOREIGNKEY_OTHER_TABLE"] = reader.GetFieldValue<string>("PKTABLE_NAME");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ForeignKeyColumns")              {                  table.Columns.Add("FOREIGNKEYCOLUMN_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_TABLE"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_KEY"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_NAME"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_ORDINAL"' typeof(int));                  table.Columns.Add("FOREIGNKEYCOLUMN_OTHER_COLUMN_NAME"' typeof(string));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetImportedKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  string name = "[" + reader.GetFieldValue<string>("FKTABLE_SCHEM") + "]" +                                                  reader.GetFieldValue<string>("FKTABLE_NAME") + "." +                                                  reader.GetFieldValue<string>("FKCOLUMN_NAME") + "->" +                                                  "[" + reader.GetFieldValue<string>("PKTABLE_SCHEM") + "]" +                                                  reader.GetFieldValue<string>("PKTABLE_NAME") + "." +                                                  reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(name))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["FKTABLE_SCHEM"] + "." + reader["FKTABLE_NAME"] + "=" + reader["FKCOLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["FOREIGNKEYCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("FKTABLE_SCHEM");                                  row["FOREIGNKEYCOLUMN_TABLE"] = reader.GetFieldValue<string>("FKTABLE_NAME");                                  row["FOREIGNKEYCOLUMN_KEY"] = name;                                  row["FOREIGNKEYCOLUMN_NAME"] = reader.GetFieldValue<string>("FKCOLUMN_NAME");                                  row["FOREIGNKEYCOLUMN_ORDINAL"] = reader.GetFieldValue<int>("KEY_SEQ");                                  row["FOREIGNKEYCOLUMN_OTHER_COLUMN_NAME"] = reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "Procedures")               {                  table.Columns.Add("PROCEDURE_CATALOG"' typeof(string));                  table.Columns.Add("PROCEDURE_SCHEMA"' typeof(string));                  table.Columns.Add("PROCEDURE_NAME"' typeof(string));                  table.Columns.Add("IS_SYSTEM_PROCEDURE"' typeof(bool));                    if (tmConn.InternalConnection.protocolVersion >= Protocol.PROTOCOL_VERSION12)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetProcedures);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      for (int i = 1; i < 3; i++)                          if (restrictionValues != null && restrictionValues.Length > i)                              tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                          else                              tmConn.InternalConnection.dataStream.encodeNull();                        tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["PROCEDURE_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["PROCEDURE_SCHEMA"] = reader.GetFieldValue<string>("PROCEDURE_SCHEM");                                  row["PROCEDURE_NAME"] = reader.GetFieldValue<string>("PROCEDURE_NAME");                                  row["IS_SYSTEM_PROCEDURE"] = false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ProcedureParameters")              {                  table.Columns.Add("PROCEDURE_CATALOG"' typeof(string));                  table.Columns.Add("PROCEDURE_SCHEMA"' typeof(string));                  table.Columns.Add("PROCEDURE_NAME"' typeof(string));                  table.Columns.Add("PARAMETER_NAME"' typeof(string));                  table.Columns.Add("ORDINAL_POSITION"' typeof(int));                  table.Columns.Add("PARAMETER_DATA_TYPE"' typeof(int));                  table.Columns.Add("PARAMETER_TYPE_NAME"' typeof(string));                  table.Columns.Add("PARAMETER_SIZE"' typeof(int));                  table.Columns.Add("NUMERIC_PRECISION"' typeof(int));                  table.Columns.Add("NUMERIC_SCALE"' typeof(int));                  table.Columns.Add("PARAMETER_DIRECTION"' typeof(int));                  table.Columns.Add("IS_NULLABLE"' typeof(bool));                    if (tmConn.InternalConnection.protocolVersion >= Protocol.PROTOCOL_VERSION12)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetProcedureColumns);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      for (int i = 1; i < 4; i++)                          if (restrictionValues != null && restrictionValues.Length > i)                              tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                          else                              tmConn.InternalConnection.dataStream.encodeNull();                        tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["PROCEDURE_NAME"] + "' " + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["PROCEDURE_SCHEMA"] = reader.GetFieldValue<string>("PROCEDURE_SCHEM");                                  row["PROCEDURE_NAME"] = reader.GetFieldValue<string>("PROCEDURE_NAME");                                  row["PARAMETER_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["ORDINAL_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                                  row["PARAMETER_TYPE_NAME"] = reader.GetFieldValue<string>("TYPE_NAME");                                  row["PARAMETER_DATA_TYPE"] = reader.GetFieldValue<int>("DATA_TYPE");                                  row["PARAMETER_SIZE"] = reader.GetFieldValue<int>("LENGTH");                                  row["NUMERIC_PRECISION"] = reader.GetFieldValue<int>("PRECISION");                                  row["NUMERIC_SCALE"] = reader.GetFieldValue<int>("SCALE");                                  row["PARAMETER_DIRECTION"] = reader.GetFieldValue<int>("COLUMN_TYPE");                                  row["IS_NULLABLE"] = !reader.GetFieldValue<string>("IS_NULLABLE").Equals("NO");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The following statement contains a magic number: if (collectionName == DbMetaDataCollectionNames.DataSourceInformation)              {                  // see http://msdn.microsoft.com/en-us/library/ms254501.aspx                  table.Columns.Add("CompositeIdentifierSeparatorPattern"' typeof(string));                  table.Columns.Add("DataSourceProductName"' typeof(string));                  table.Columns.Add("DataSourceProductVersion"' typeof(string));                  table.Columns.Add("DataSourceProductVersionNormalized"' typeof(string));                  table.Columns.Add("DataSourceInternalProductVersion"' typeof(string));                  table.Columns.Add("GroupByBehavior"' typeof(GroupByBehavior));                  table.Columns.Add("IdentifierPattern"' typeof(string));                  table.Columns.Add("IdentifierCase"' typeof(IdentifierCase));                  table.Columns.Add("OrderByColumnsInSelect"' typeof(bool));                  table.Columns.Add("ParameterMarkerFormat"' typeof(string));                  table.Columns.Add("ParameterMarkerPattern"' typeof(string));                  table.Columns.Add("ParameterNameMaxLength"' typeof(int));                  table.Columns.Add("ParameterNamePattern"' typeof(string));                  table.Columns.Add("QuotedIdentifierPattern"' typeof(string));  // Regex                  table.Columns.Add("QuotedIdentifierCase"' typeof(int));                  table.Columns.Add("StatementSeparatorPattern"' typeof(string));                  table.Columns.Add("StringLiteralPattern"' typeof(string));  // Regex                  table.Columns.Add("SupportedJoinOperators"' typeof(SupportedJoinOperators));                    table.BeginLoadData();                  DataRow row = table.NewRow();                  int databaseMajorVersion = 0' databaseMinorVersion = 0;                  try                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetDatabaseMetaData);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      for (int item; (item = tmConn.InternalConnection.dataStream.getInt()) != Protocol.DbmbFini; )                      {                          switch (item)                          {                              case Protocol.DbmbProductName:                                  row["DataSourceProductName"] = tmConn.InternalConnection.dataStream.getString();                                  break;                                case Protocol.DbmbProductVersion:                                  row["DataSourceProductVersion"] = tmConn.InternalConnection.dataStream.getString();                                  break;                                case Protocol.DbmbDatabaseMinorVersion:                                  databaseMinorVersion = tmConn.InternalConnection.dataStream.getInt();                                  break;                                case Protocol.DbmbDatabaseMajorVersion:                                  databaseMajorVersion = tmConn.InternalConnection.dataStream.getInt();                                  break;                                case Protocol.DbmbDefaultTransactionIsolation:                                  int defaultTransactionIsolation = tmConn.InternalConnection.dataStream.getInt();                                  break;                                default:                                  tmConn.InternalConnection.dataStream.decode();                                  break;                          }                      }                  }                  catch (Exception)                  {                  }                    row["DataSourceInternalProductVersion"] = String.Format("{0:D3}.{1:D3}"' databaseMajorVersion' databaseMinorVersion);                  // The regular expression to match the composite separators in a composite identifier.                   // For example' "\." (for SQL Server) or "@|\." (for Oracle).                  // A composite identifier is typically what is used for a database object name'                   // for example: pubs.dbo.authors or pubs@dbo.authors.                  row["CompositeIdentifierSeparatorPattern"] = "\\.";                  // A normalized version for the data source' such that it can be compared with String.Compare().                   // The format of this is consistent for all versions of the provider to prevent version 10 from sorting between version 1 and version 2.                  //row["DataSourceProductVersionNormalized"] = ??                  // Specifies the relationship between the columns in a GROUP BY clause and the non-aggregated columns in the select list.                  row["GroupByBehavior"] = GroupByBehavior.Unknown;                  // A regular expression that matches an identifier and has a match value of the identifier. For example "[A-Za-z0-9_#$]".                  row["IdentifierPattern"] = "(^\\[\\p{Lo}\\p{Lu}\\p{Ll}_@#][\\p{Lo}\\p{Lu}\\p{Ll}\\p{Nd}@$#_]*$)|(^\"[^\"\\0]|\"\"+\"$)";                  // Indicates whether non-quoted identifiers are treated as case sensitive or not.                  row["IdentifierCase"] = IdentifierCase.Insensitive;                  // Specifies whether columns in an ORDER BY clause must be in the select list.                   // A value of true indicates that they are required to be in the select list'                   // a value of false indicates that they are not required to be in the select list.                  row["OrderByColumnsInSelect"] = false;                  // For data sources that do not expect named parameters and expect the use of the ‘?’ character' the format string                  // can be specified as simply '?'' which would ignore the parameter name.                  row["ParameterMarkerFormat"] = "?";                  // if the data source doesn't support named parameters' this would simply be "?".                  row["ParameterMarkerPattern"] = "?";                  // If the data source does not support named parameters' this property returns zero.                  row["ParameterNameMaxLength"] = 0;                  // A regular expression that matches the valid parameter names                  row["ParameterNamePattern"] = "";                  // A regular expression that matches a quoted identifier and has a match value of the identifier itself without the quotes.                   // For example' if the data source used double-quotes to identify quoted identifiers' this would be: "(([^\"]|\"\")*)".                  row["QuotedIdentifierPattern"] = "\"([^\"]*)\"";                  // Indicates whether quoted identifiers are treated as case sensitive or not.                  row["QuotedIdentifierCase"] = IdentifierCase.Sensitive;                  // A regular expression that matches the statement separator.                  row["StatementSeparatorPattern"] = ";";                  // A regular expression that matches a string literal and has a match value of the literal itself.                   // For example' if the data source used single-quotes to identify strings' this would be: "('([^']|'')*')"'                  row["StringLiteralPattern"] = "'([^']*)'";                  // Specifies what types of SQL join statements are supported by the data source.                  row["SupportedJoinOperators"] = SupportedJoinOperators.None;                  table.Rows.Add(row);                  table.EndLoadData();              }              else if (collectionName == DbMetaDataCollectionNames.ReservedWords)              {                  table.Columns.Add("ReservedWord"' typeof(string));                  table.Columns.Add("MaximumVersion"' typeof(string));                  table.Columns.Add("MinimumVersion"' typeof(string));                    string[] words = { "select"' "Add field"' "Drop field"' "Alter table"' "Alter field"'                                      "Alter user"' "And"' "Or"' "Not"' "Create Index"' "Upgrade"' "Unique"'                                      "Table key"' "Table unique key"' "Primary Key"' "Create Table"'                                      "Upgrade Table"' "Rename Table"' "Create View"' "Upgrade View"'                                      "Drop View"' "Create Schema"' "Drop Schema"' "Integer"' "Smallint"'                                      "Bigint"' "Tinyint"' "float"' "double"' "Blob"' "bytes"' "boolean"'                                      "binary"' "varbinary"' "string"' "char"' "text"' "date"' "timestamp"'                                      "time"' "varchar"' "numeric"' "Decimal Number"' "Enum"' "Delete"' "Repair"'                                      "Field"' "Not Null"' "Default Value"' "searchable"' "not searchable"'                                      "collation"' "character_set"' "Foreign Key"' "Identifier"' "record number"'                                      "Insert"' "Replace"' "Name"' "Number"' "Order"' "Descending"' "limit"'                                      "Quoted String"' "Select Clause"' "Distinct"' "Gtr"' "Geq"' "Eql"'                                      "Leq"' "Lss"' "Neq"' "in list"' "in select"' "exists"' "Between"' "Like"'                                      "starts with"' "Containing"' "Matching"' "Regular expression"' "Null"'                                      "True"' "False"' "Execute"' "Parameter"' "Count"' "sum"' "min"' "max"'                                      "avg"' "Drop Index"' "Drop primary key"' "Drop foreign key"' "Drop Table"'                                      "If Exists"' "Describe"' "Statement"' "for_select"' "for_insert"' "while"'                                      "if then else"' "variable"' "declaration"' "throw"' "assignment"'                                      "Start transaction"' "read only"' "read write"' "read committed"' "write committed"'                                      "read uncommitted"' "repeatableread"' "serializable"' "Commit"' "Rollback"'                                      "Savepoint"' "Rollack Savepoint"' "Release Savepoint"' "Table"' "Derived Table"'                                      "Assign"' "Update"' "list"' "Constant"' "Function"' "Grant"' "Grant role"' "Alter"'                                      "Read"' "Identity"' "Check"' "Constraint"' "value constraint"' "auto increment"'                                      "generated"' "always"' "Domain"' "is null"' "is active_role"' "start with"' "reindex"'                                      "cursor"' "alias"' "push_namespace"' "pop_namespace"' "set_namespace"' "coalesce"'                                      "nod_nullif"' "case"' "case_search"' "add"' "subtract"' "multiply"' "divide"' "modulus"'                                      "negate"' "plus"' "cast"' "concatenation"' "create user"' "drop user"' "create role"'                                      "upgrade role"' "drop role"' "revoke"' "revoke role"' "assume"' "revert"' "negate"'                                      "priv insert"' "priv delete"' "priv execute"' "priv select"' "priv update"' "priv grant"'                                      "priv all"' "characters"' "octets"' "role"' "view"' "procedure"' "user"' "zone"' "admin"'                                      "default role"' "create sequence"' "upgrade sequence"' "drop sequence"' "next value"'                                      "create trigger"' "upgrade trigger"' "alter trigger"' "drop trigger"' "create procedure"'                                      "upgrade procedure"' "alter procedure"' "drop procedure"' "pre-insert"' "post-insert"'                                      "pre-update"' "post-update"' "pre-delete"' "post-delete"' "pre-commit"' "post-commit"'                                      "active"' "inactive"' "position"' "select-expr"' "create filterset"' "upgrade filterset"'                                      "drop filterset"' "enable filterset"' "disable filterset"' "table filter"' "left outer"'                                      "right outer"' "full outer"' "inner"' "join"' "join_term"' "trigger class"' "enable trigger class"'                                      "disable trigger class"' "create zone"' "upgrade zone"' "drop zone"' "range"' "ip address"'                                      "node_name"' "wildcard"' "create domain"' "upgrade domain"' "alter domain"' "upgrade schema"'                                      "delete cascade"' "index segment"' "for update"' "write committed"' "read committed"'                                       "consistent read"' "set dialect"' "set names"' "restrict"' "cascade"' "characters"' "octets"'                                      "create event"' "collate"' "truncate"' "restart"' "nameless constraint"' "drop constraint"'                                      "drop unique constraint"' "drop domain"' "with check option"' "not real"' "lower"' "upper"'                                      "substr"' "substring index"' "charlength"' "default keyword"' "sqrt"' "power"' "Scientific Notation Number"'                                      "Explain"' "msleep"' "KillStatement"' "now" };                  table.BeginLoadData();                  foreach (string keyword in words)                  {                      DataRow row = table.NewRow();                      row["ReservedWord"] = keyword;                      table.Rows.Add(row);                  }                  table.EndLoadData();                }              else if (collectionName == DbMetaDataCollectionNames.DataTypes)              {                  table.Columns.Add("TypeName"' typeof(string));  // The provider-specific data type name.                  table.Columns.Add("ProviderDbType"' typeof(int)); // The provider-specific type value that should be used when specifying                   //a parameter's type. For example' SqlDbType.Money or OracleType.Blob.                  table.Columns.Add("ColumnSize"' typeof(long));                  table.Columns.Add("CreateFormat"' typeof(string));                  table.Columns.Add("CreateParameters"' typeof(string));                  table.Columns.Add("DataType"' typeof(string));  // The name of the .NET Framework type of the data type.                  table.Columns.Add("IsAutoincrementable"' typeof(bool));                  table.Columns.Add("IsBestMatch"' typeof(bool));                  table.Columns.Add("IsCaseSensitive"' typeof(bool));                  table.Columns.Add("IsFixedLength"' typeof(bool));                  table.Columns.Add("IsFixedPrecisionScale"' typeof(bool));                  table.Columns.Add("IsLong"' typeof(bool));                  table.Columns.Add("IsNullable"' typeof(bool));                  table.Columns.Add("IsSearchable"' typeof(bool));                  table.Columns.Add("IsSearchableWithLike"' typeof(bool));                  table.Columns.Add("IsUnsigned"' typeof(bool));                  table.Columns.Add("MaximumScale"' typeof(short));                  table.Columns.Add("MinimumScale"' typeof(short));                  table.Columns.Add("IsConcurrencyType"' typeof(bool));                  table.Columns.Add("IsLiteralsSupported"' typeof(bool));                  table.Columns.Add("LiteralPrefix"' typeof(string));                  table.Columns.Add("LiteralSuffix"' typeof(string));                  table.Columns.Add("NativeDataType"' typeof(string));    // NativeDataType is an OLE DB specific column for exposing the OLE DB type of the data type .                    table.ReadXml(XmlReader.Create(typeof(NuoDbConnectionInternal).Assembly.GetManifestResourceStream("NuoDb.Data.Client.DataTypes.xml")));              }              else if (collectionName == "Tables")              {                  table.Columns.Add("TABLE_CATALOG"' typeof(string));                  table.Columns.Add("TABLE_SCHEMA"' typeof(string));                  table.Columns.Add("TABLE_NAME"' typeof(string));                  table.Columns.Add("TABLE_TYPE"' typeof(string));                  table.Columns.Add("REMARKS"' typeof(string));                  table.Columns.Add("VIEW_DEF"' typeof(string));                    tmConn.InternalConnection.dataStream.startMessage(Protocol.GetTables);                  tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                  for (int i = 1; i < 3; i++)                      if (restrictionValues != null && restrictionValues.Length > i)                          tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                      else                          tmConn.InternalConnection.dataStream.encodeNull();                  if (restrictionValues == null || restrictionValues.Length < 4 || restrictionValues[3] == null)                      tmConn.InternalConnection.dataStream.encodeInt(0);                  else                  {                      tmConn.InternalConnection.dataStream.encodeInt(1);                      tmConn.InternalConnection.dataStream.encodeString(restrictionValues[3]);                  }                    tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                  int handle = tmConn.InternalConnection.dataStream.getInt();                    if (handle != -1)                  {                      using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                      {                          table.BeginLoadData();                          string view_def_label="";                          try                           {                               reader.GetOrdinal("VIEW_DEF");                              view_def_label = "VIEW_DEF";                          }                          catch(Exception) {}                          try                           {                               reader.GetOrdinal("VIEWDEFINITION");                              view_def_label = "VIEWDEFINITION";                          }                          catch (Exception) { }                          while (reader.Read())                          {  #if DEBUG                          System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_NAME"] + "' " + reader["TABLE_TYPE"]);  #endif                              DataRow row = table.NewRow();                              row["TABLE_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                              row["TABLE_NAME"] = reader.GetFieldValue<string>("TABLE_NAME");                              row["TABLE_TYPE"] = reader.GetFieldValue<string>("TABLE_TYPE");                              row["REMARKS"] = reader.GetFieldValue<string>("REMARKS");                              if (view_def_label.Length != 0)                              {                                  row["VIEW_DEF"] = reader.GetFieldValue<string>(view_def_label);                              }                              table.Rows.Add(row);                          }                          table.EndLoadData();                      }                  }              }              else if (collectionName == "Columns")              {                  table.Columns.Add("COLUMN_CATALOG"' typeof(string));                  table.Columns.Add("COLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("COLUMN_TABLE"' typeof(string));                  table.Columns.Add("COLUMN_NAME"' typeof(string));                  table.Columns.Add("COLUMN_POSITION"' typeof(int));                  table.Columns.Add("COLUMN_TYPE"' typeof(string));                  table.Columns.Add("COLUMN_LENGTH"' typeof(int));                  table.Columns.Add("COLUMN_PRECISION"' typeof(int));                  table.Columns.Add("COLUMN_NULLABLE"' typeof(bool));                  table.Columns.Add("COLUMN_IDENTITY"' typeof(bool));                  table.Columns.Add("COLUMN_DEFAULT"' typeof(string));                  table.Columns.Add("COLUMN_SCALE"' typeof(int));                    tmConn.InternalConnection.dataStream.startMessage(Protocol.GetColumns);                  tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                  for (int i = 1; i < 4; i++)                      if (restrictionValues != null && restrictionValues.Length > i)                          tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                      else                          tmConn.InternalConnection.dataStream.encodeNull();                    tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                  int handle = tmConn.InternalConnection.dataStream.getInt();                    if (handle != -1)                  {                      using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                      {                          table.BeginLoadData();                          while (reader.Read())                          {                              DataRow row = table.NewRow();                              row["COLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                              row["COLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                              row["COLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                              row["COLUMN_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                              row["COLUMN_LENGTH"] = reader.GetFieldValue<int>("COLUMN_SIZE");                              row["COLUMN_PRECISION"] = reader.GetFieldValue<int>("BUFFER_LENGTH");                              row["COLUMN_SCALE"] = reader.GetFieldValue<int>("DECIMAL_DIGITS");                              if (isNumeric(reader.GetFieldValue<string>("TYPE_NAME")))                              {                                  if (reader.GetFieldValue<int>("DECIMAL_DIGITS") != 0)                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME") +                                           "(" + reader.GetFieldValue<int>("BUFFER_LENGTH") + "'" + reader.GetFieldValue<int>("DECIMAL_DIGITS") + ")";                                  else                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME");                              }                              else                              {                                  if (isVarLenType(reader.GetFieldValue<string>("TYPE_NAME")) && reader.GetFieldValue<int>("COLUMN_SIZE") != 0)                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME") +                                           "(" + reader.GetFieldValue<int>("COLUMN_SIZE") + ")";                                  else                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME");                              }                              if (!reader.IsDBNull(reader.GetOrdinal("IS_NULLABLE")))                                  row["COLUMN_NULLABLE"] = reader.GetFieldValue<string>("IS_NULLABLE").Equals("YES");                              if (!reader.IsDBNull(reader.GetOrdinal("IS_AUTOINCREMENT")))                                  row["COLUMN_IDENTITY"] = reader.GetFieldValue<string>("IS_AUTOINCREMENT").Equals("YES");                              row["COLUMN_DEFAULT"] = reader.GetFieldValue<string>("COLUMN_DEF");    #if DEBUG                              System.Diagnostics.Trace.WriteLine("-> " + row["COLUMN_NAME"] + " " + row["COLUMN_TYPE"]);  #endif                              table.Rows.Add(row);                          }                          table.EndLoadData();                      }                  }              }              else if (collectionName == "Indexes")              {                  table.Columns.Add("INDEX_CATALOG"' typeof(string));                  table.Columns.Add("INDEX_SCHEMA"' typeof(string));                  table.Columns.Add("INDEX_TABLE"' typeof(string));                  table.Columns.Add("INDEX_NAME"' typeof(string));                  table.Columns.Add("INDEX_TYPE"' typeof(string));                  table.Columns.Add("INDEX_UNIQUE"' typeof(bool));                  table.Columns.Add("INDEX_PRIMARY"' typeof(bool));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetIndexInfo);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // unique                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // approximate                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        // to avoid to insert the same index more than once                      HashSet<string> unique = new HashSet<string>();                      if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;                                  if (!unique.Add(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;                                  DataRow row = table.NewRow();                                  row["INDEX_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEX_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEX_NAME"] = reader.GetFieldValue<string>("INDEX_NAME");                                  switch (reader.GetFieldValue<int>("TYPE"))                                  {                                      case 0:                                          row["INDEX_TYPE"] = "Primary";                                          break;                                      case 1:                                          row["INDEX_TYPE"] = "Unique";                                          break;                                      case 2:                                          row["INDEX_TYPE"] = "Secondary";                                          break;                                      case 3:                                          row["INDEX_TYPE"] = "Foreign Key";                                          break;                                  }                                  row["INDEX_UNIQUE"] = (reader.GetFieldValue<int>("NON_UNIQUE") == 0) ? true : false;                                  row["INDEX_PRIMARY"] = (reader.GetFieldValue<int>("TYPE") == 0) ? true : false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                        tmConn.InternalConnection.dataStream.startMessage(Protocol.GetPrimaryKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              // use INDEX_NAME' if present; if missing' the name of the index is in PK_NAME                              string indexName = "PK_NAME";                              foreach (string column in reader.columnNames)                              {                                  if (column == "INDEX_NAME")                                  {                                      indexName = "INDEX_NAME";                                      break;                                  }                              }                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>(indexName)))                                      continue;                                  if (!unique.Add(reader.GetFieldValue<string>(indexName)))                                      continue;                                  DataRow row = table.NewRow();                                  row["INDEX_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEX_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEX_NAME"] = reader.GetFieldValue<string>(indexName);                                  row["INDEX_TYPE"] = "Primary";                                  row["INDEX_UNIQUE"] = true;                                  row["INDEX_PRIMARY"] = true;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "IndexColumns")              {                  table.Columns.Add("INDEXCOLUMN_CATALOG"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_TABLE"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_INDEX"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_NAME"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_POSITION"' typeof(int));                  table.Columns.Add("INDEXCOLUMN_ISPRIMARY"' typeof(bool));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetIndexInfo);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // unique                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // approximate                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_SCHEM"] + "." + reader["TABLE_NAME"] + "=" + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["INDEXCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEXCOLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEXCOLUMN_INDEX"] = reader.GetFieldValue<string>("INDEX_NAME");                                  row["INDEXCOLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["INDEXCOLUMN_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                                  row["INDEXCOLUMN_ISPRIMARY"] = false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                        tmConn.InternalConnection.dataStream.startMessage(Protocol.GetPrimaryKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              // use INDEX_NAME' if present; if missing' the name of the index is in PK_NAME                              string indexName = "PK_NAME";                              foreach (string column in reader.columnNames)                              {                                  if (column == "INDEX_NAME")                                  {                                      indexName = "INDEX_NAME";                                      break;                                  }                              }                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>(indexName)))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_SCHEM"] + "." + reader["TABLE_NAME"] + " (Primary) =" + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["INDEXCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEXCOLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEXCOLUMN_INDEX"] = reader.GetFieldValue<string>(indexName);                                  row["INDEXCOLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["INDEXCOLUMN_POSITION"] = reader.GetFieldValue<int>("KEY_SEQ");                                  row["INDEXCOLUMN_ISPRIMARY"] = true;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ForeignKeys")              {                  table.Columns.Add("FOREIGNKEY_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEY_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEY_TABLE"' typeof(string));                  table.Columns.Add("FOREIGNKEY_NAME"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_TABLE"' typeof(string));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetImportedKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  string name = "[" + reader.GetFieldValue<string>("FKTABLE_SCHEM") + "]" +                                                   reader.GetFieldValue<string>("FKTABLE_NAME") + "." +                                                   reader.GetFieldValue<string>("FKCOLUMN_NAME") + "->" +                                                  "[" + reader.GetFieldValue<string>("PKTABLE_SCHEM") + "]" +                                                   reader.GetFieldValue<string>("PKTABLE_NAME") + "." +                                                   reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(name))                                      continue;                                  DataRow row = table.NewRow();                                  row["FOREIGNKEY_SCHEMA"] = reader.GetFieldValue<string>("FKTABLE_SCHEM");                                  row["FOREIGNKEY_TABLE"] = reader.GetFieldValue<string>("FKTABLE_NAME");                                  row["FOREIGNKEY_NAME"] = name;                                  row["FOREIGNKEY_OTHER_SCHEMA"] = reader.GetFieldValue<string>("PKTABLE_SCHEM");                                  row["FOREIGNKEY_OTHER_TABLE"] = reader.GetFieldValue<string>("PKTABLE_NAME");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ForeignKeyColumns")              {                  table.Columns.Add("FOREIGNKEYCOLUMN_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_TABLE"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_KEY"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_NAME"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_ORDINAL"' typeof(int));                  table.Columns.Add("FOREIGNKEYCOLUMN_OTHER_COLUMN_NAME"' typeof(string));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetImportedKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  string name = "[" + reader.GetFieldValue<string>("FKTABLE_SCHEM") + "]" +                                                  reader.GetFieldValue<string>("FKTABLE_NAME") + "." +                                                  reader.GetFieldValue<string>("FKCOLUMN_NAME") + "->" +                                                  "[" + reader.GetFieldValue<string>("PKTABLE_SCHEM") + "]" +                                                  reader.GetFieldValue<string>("PKTABLE_NAME") + "." +                                                  reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(name))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["FKTABLE_SCHEM"] + "." + reader["FKTABLE_NAME"] + "=" + reader["FKCOLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["FOREIGNKEYCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("FKTABLE_SCHEM");                                  row["FOREIGNKEYCOLUMN_TABLE"] = reader.GetFieldValue<string>("FKTABLE_NAME");                                  row["FOREIGNKEYCOLUMN_KEY"] = name;                                  row["FOREIGNKEYCOLUMN_NAME"] = reader.GetFieldValue<string>("FKCOLUMN_NAME");                                  row["FOREIGNKEYCOLUMN_ORDINAL"] = reader.GetFieldValue<int>("KEY_SEQ");                                  row["FOREIGNKEYCOLUMN_OTHER_COLUMN_NAME"] = reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "Procedures")               {                  table.Columns.Add("PROCEDURE_CATALOG"' typeof(string));                  table.Columns.Add("PROCEDURE_SCHEMA"' typeof(string));                  table.Columns.Add("PROCEDURE_NAME"' typeof(string));                  table.Columns.Add("IS_SYSTEM_PROCEDURE"' typeof(bool));                    if (tmConn.InternalConnection.protocolVersion >= Protocol.PROTOCOL_VERSION12)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetProcedures);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      for (int i = 1; i < 3; i++)                          if (restrictionValues != null && restrictionValues.Length > i)                              tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                          else                              tmConn.InternalConnection.dataStream.encodeNull();                        tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["PROCEDURE_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["PROCEDURE_SCHEMA"] = reader.GetFieldValue<string>("PROCEDURE_SCHEM");                                  row["PROCEDURE_NAME"] = reader.GetFieldValue<string>("PROCEDURE_NAME");                                  row["IS_SYSTEM_PROCEDURE"] = false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ProcedureParameters")              {                  table.Columns.Add("PROCEDURE_CATALOG"' typeof(string));                  table.Columns.Add("PROCEDURE_SCHEMA"' typeof(string));                  table.Columns.Add("PROCEDURE_NAME"' typeof(string));                  table.Columns.Add("PARAMETER_NAME"' typeof(string));                  table.Columns.Add("ORDINAL_POSITION"' typeof(int));                  table.Columns.Add("PARAMETER_DATA_TYPE"' typeof(int));                  table.Columns.Add("PARAMETER_TYPE_NAME"' typeof(string));                  table.Columns.Add("PARAMETER_SIZE"' typeof(int));                  table.Columns.Add("NUMERIC_PRECISION"' typeof(int));                  table.Columns.Add("NUMERIC_SCALE"' typeof(int));                  table.Columns.Add("PARAMETER_DIRECTION"' typeof(int));                  table.Columns.Add("IS_NULLABLE"' typeof(bool));                    if (tmConn.InternalConnection.protocolVersion >= Protocol.PROTOCOL_VERSION12)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetProcedureColumns);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      for (int i = 1; i < 4; i++)                          if (restrictionValues != null && restrictionValues.Length > i)                              tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                          else                              tmConn.InternalConnection.dataStream.encodeNull();                        tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["PROCEDURE_NAME"] + "' " + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["PROCEDURE_SCHEMA"] = reader.GetFieldValue<string>("PROCEDURE_SCHEM");                                  row["PROCEDURE_NAME"] = reader.GetFieldValue<string>("PROCEDURE_NAME");                                  row["PARAMETER_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["ORDINAL_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                                  row["PARAMETER_TYPE_NAME"] = reader.GetFieldValue<string>("TYPE_NAME");                                  row["PARAMETER_DATA_TYPE"] = reader.GetFieldValue<int>("DATA_TYPE");                                  row["PARAMETER_SIZE"] = reader.GetFieldValue<int>("LENGTH");                                  row["NUMERIC_PRECISION"] = reader.GetFieldValue<int>("PRECISION");                                  row["NUMERIC_SCALE"] = reader.GetFieldValue<int>("SCALE");                                  row["PARAMETER_DIRECTION"] = reader.GetFieldValue<int>("COLUMN_TYPE");                                  row["IS_NULLABLE"] = !reader.GetFieldValue<string>("IS_NULLABLE").Equals("NO");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The following statement contains a magic number: if (collectionName == DbMetaDataCollectionNames.DataSourceInformation)              {                  // see http://msdn.microsoft.com/en-us/library/ms254501.aspx                  table.Columns.Add("CompositeIdentifierSeparatorPattern"' typeof(string));                  table.Columns.Add("DataSourceProductName"' typeof(string));                  table.Columns.Add("DataSourceProductVersion"' typeof(string));                  table.Columns.Add("DataSourceProductVersionNormalized"' typeof(string));                  table.Columns.Add("DataSourceInternalProductVersion"' typeof(string));                  table.Columns.Add("GroupByBehavior"' typeof(GroupByBehavior));                  table.Columns.Add("IdentifierPattern"' typeof(string));                  table.Columns.Add("IdentifierCase"' typeof(IdentifierCase));                  table.Columns.Add("OrderByColumnsInSelect"' typeof(bool));                  table.Columns.Add("ParameterMarkerFormat"' typeof(string));                  table.Columns.Add("ParameterMarkerPattern"' typeof(string));                  table.Columns.Add("ParameterNameMaxLength"' typeof(int));                  table.Columns.Add("ParameterNamePattern"' typeof(string));                  table.Columns.Add("QuotedIdentifierPattern"' typeof(string));  // Regex                  table.Columns.Add("QuotedIdentifierCase"' typeof(int));                  table.Columns.Add("StatementSeparatorPattern"' typeof(string));                  table.Columns.Add("StringLiteralPattern"' typeof(string));  // Regex                  table.Columns.Add("SupportedJoinOperators"' typeof(SupportedJoinOperators));                    table.BeginLoadData();                  DataRow row = table.NewRow();                  int databaseMajorVersion = 0' databaseMinorVersion = 0;                  try                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetDatabaseMetaData);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      for (int item; (item = tmConn.InternalConnection.dataStream.getInt()) != Protocol.DbmbFini; )                      {                          switch (item)                          {                              case Protocol.DbmbProductName:                                  row["DataSourceProductName"] = tmConn.InternalConnection.dataStream.getString();                                  break;                                case Protocol.DbmbProductVersion:                                  row["DataSourceProductVersion"] = tmConn.InternalConnection.dataStream.getString();                                  break;                                case Protocol.DbmbDatabaseMinorVersion:                                  databaseMinorVersion = tmConn.InternalConnection.dataStream.getInt();                                  break;                                case Protocol.DbmbDatabaseMajorVersion:                                  databaseMajorVersion = tmConn.InternalConnection.dataStream.getInt();                                  break;                                case Protocol.DbmbDefaultTransactionIsolation:                                  int defaultTransactionIsolation = tmConn.InternalConnection.dataStream.getInt();                                  break;                                default:                                  tmConn.InternalConnection.dataStream.decode();                                  break;                          }                      }                  }                  catch (Exception)                  {                  }                    row["DataSourceInternalProductVersion"] = String.Format("{0:D3}.{1:D3}"' databaseMajorVersion' databaseMinorVersion);                  // The regular expression to match the composite separators in a composite identifier.                   // For example' "\." (for SQL Server) or "@|\." (for Oracle).                  // A composite identifier is typically what is used for a database object name'                   // for example: pubs.dbo.authors or pubs@dbo.authors.                  row["CompositeIdentifierSeparatorPattern"] = "\\.";                  // A normalized version for the data source' such that it can be compared with String.Compare().                   // The format of this is consistent for all versions of the provider to prevent version 10 from sorting between version 1 and version 2.                  //row["DataSourceProductVersionNormalized"] = ??                  // Specifies the relationship between the columns in a GROUP BY clause and the non-aggregated columns in the select list.                  row["GroupByBehavior"] = GroupByBehavior.Unknown;                  // A regular expression that matches an identifier and has a match value of the identifier. For example "[A-Za-z0-9_#$]".                  row["IdentifierPattern"] = "(^\\[\\p{Lo}\\p{Lu}\\p{Ll}_@#][\\p{Lo}\\p{Lu}\\p{Ll}\\p{Nd}@$#_]*$)|(^\"[^\"\\0]|\"\"+\"$)";                  // Indicates whether non-quoted identifiers are treated as case sensitive or not.                  row["IdentifierCase"] = IdentifierCase.Insensitive;                  // Specifies whether columns in an ORDER BY clause must be in the select list.                   // A value of true indicates that they are required to be in the select list'                   // a value of false indicates that they are not required to be in the select list.                  row["OrderByColumnsInSelect"] = false;                  // For data sources that do not expect named parameters and expect the use of the ‘?’ character' the format string                  // can be specified as simply '?'' which would ignore the parameter name.                  row["ParameterMarkerFormat"] = "?";                  // if the data source doesn't support named parameters' this would simply be "?".                  row["ParameterMarkerPattern"] = "?";                  // If the data source does not support named parameters' this property returns zero.                  row["ParameterNameMaxLength"] = 0;                  // A regular expression that matches the valid parameter names                  row["ParameterNamePattern"] = "";                  // A regular expression that matches a quoted identifier and has a match value of the identifier itself without the quotes.                   // For example' if the data source used double-quotes to identify quoted identifiers' this would be: "(([^\"]|\"\")*)".                  row["QuotedIdentifierPattern"] = "\"([^\"]*)\"";                  // Indicates whether quoted identifiers are treated as case sensitive or not.                  row["QuotedIdentifierCase"] = IdentifierCase.Sensitive;                  // A regular expression that matches the statement separator.                  row["StatementSeparatorPattern"] = ";";                  // A regular expression that matches a string literal and has a match value of the literal itself.                   // For example' if the data source used single-quotes to identify strings' this would be: "('([^']|'')*')"'                  row["StringLiteralPattern"] = "'([^']*)'";                  // Specifies what types of SQL join statements are supported by the data source.                  row["SupportedJoinOperators"] = SupportedJoinOperators.None;                  table.Rows.Add(row);                  table.EndLoadData();              }              else if (collectionName == DbMetaDataCollectionNames.ReservedWords)              {                  table.Columns.Add("ReservedWord"' typeof(string));                  table.Columns.Add("MaximumVersion"' typeof(string));                  table.Columns.Add("MinimumVersion"' typeof(string));                    string[] words = { "select"' "Add field"' "Drop field"' "Alter table"' "Alter field"'                                      "Alter user"' "And"' "Or"' "Not"' "Create Index"' "Upgrade"' "Unique"'                                      "Table key"' "Table unique key"' "Primary Key"' "Create Table"'                                      "Upgrade Table"' "Rename Table"' "Create View"' "Upgrade View"'                                      "Drop View"' "Create Schema"' "Drop Schema"' "Integer"' "Smallint"'                                      "Bigint"' "Tinyint"' "float"' "double"' "Blob"' "bytes"' "boolean"'                                      "binary"' "varbinary"' "string"' "char"' "text"' "date"' "timestamp"'                                      "time"' "varchar"' "numeric"' "Decimal Number"' "Enum"' "Delete"' "Repair"'                                      "Field"' "Not Null"' "Default Value"' "searchable"' "not searchable"'                                      "collation"' "character_set"' "Foreign Key"' "Identifier"' "record number"'                                      "Insert"' "Replace"' "Name"' "Number"' "Order"' "Descending"' "limit"'                                      "Quoted String"' "Select Clause"' "Distinct"' "Gtr"' "Geq"' "Eql"'                                      "Leq"' "Lss"' "Neq"' "in list"' "in select"' "exists"' "Between"' "Like"'                                      "starts with"' "Containing"' "Matching"' "Regular expression"' "Null"'                                      "True"' "False"' "Execute"' "Parameter"' "Count"' "sum"' "min"' "max"'                                      "avg"' "Drop Index"' "Drop primary key"' "Drop foreign key"' "Drop Table"'                                      "If Exists"' "Describe"' "Statement"' "for_select"' "for_insert"' "while"'                                      "if then else"' "variable"' "declaration"' "throw"' "assignment"'                                      "Start transaction"' "read only"' "read write"' "read committed"' "write committed"'                                      "read uncommitted"' "repeatableread"' "serializable"' "Commit"' "Rollback"'                                      "Savepoint"' "Rollack Savepoint"' "Release Savepoint"' "Table"' "Derived Table"'                                      "Assign"' "Update"' "list"' "Constant"' "Function"' "Grant"' "Grant role"' "Alter"'                                      "Read"' "Identity"' "Check"' "Constraint"' "value constraint"' "auto increment"'                                      "generated"' "always"' "Domain"' "is null"' "is active_role"' "start with"' "reindex"'                                      "cursor"' "alias"' "push_namespace"' "pop_namespace"' "set_namespace"' "coalesce"'                                      "nod_nullif"' "case"' "case_search"' "add"' "subtract"' "multiply"' "divide"' "modulus"'                                      "negate"' "plus"' "cast"' "concatenation"' "create user"' "drop user"' "create role"'                                      "upgrade role"' "drop role"' "revoke"' "revoke role"' "assume"' "revert"' "negate"'                                      "priv insert"' "priv delete"' "priv execute"' "priv select"' "priv update"' "priv grant"'                                      "priv all"' "characters"' "octets"' "role"' "view"' "procedure"' "user"' "zone"' "admin"'                                      "default role"' "create sequence"' "upgrade sequence"' "drop sequence"' "next value"'                                      "create trigger"' "upgrade trigger"' "alter trigger"' "drop trigger"' "create procedure"'                                      "upgrade procedure"' "alter procedure"' "drop procedure"' "pre-insert"' "post-insert"'                                      "pre-update"' "post-update"' "pre-delete"' "post-delete"' "pre-commit"' "post-commit"'                                      "active"' "inactive"' "position"' "select-expr"' "create filterset"' "upgrade filterset"'                                      "drop filterset"' "enable filterset"' "disable filterset"' "table filter"' "left outer"'                                      "right outer"' "full outer"' "inner"' "join"' "join_term"' "trigger class"' "enable trigger class"'                                      "disable trigger class"' "create zone"' "upgrade zone"' "drop zone"' "range"' "ip address"'                                      "node_name"' "wildcard"' "create domain"' "upgrade domain"' "alter domain"' "upgrade schema"'                                      "delete cascade"' "index segment"' "for update"' "write committed"' "read committed"'                                       "consistent read"' "set dialect"' "set names"' "restrict"' "cascade"' "characters"' "octets"'                                      "create event"' "collate"' "truncate"' "restart"' "nameless constraint"' "drop constraint"'                                      "drop unique constraint"' "drop domain"' "with check option"' "not real"' "lower"' "upper"'                                      "substr"' "substring index"' "charlength"' "default keyword"' "sqrt"' "power"' "Scientific Notation Number"'                                      "Explain"' "msleep"' "KillStatement"' "now" };                  table.BeginLoadData();                  foreach (string keyword in words)                  {                      DataRow row = table.NewRow();                      row["ReservedWord"] = keyword;                      table.Rows.Add(row);                  }                  table.EndLoadData();                }              else if (collectionName == DbMetaDataCollectionNames.DataTypes)              {                  table.Columns.Add("TypeName"' typeof(string));  // The provider-specific data type name.                  table.Columns.Add("ProviderDbType"' typeof(int)); // The provider-specific type value that should be used when specifying                   //a parameter's type. For example' SqlDbType.Money or OracleType.Blob.                  table.Columns.Add("ColumnSize"' typeof(long));                  table.Columns.Add("CreateFormat"' typeof(string));                  table.Columns.Add("CreateParameters"' typeof(string));                  table.Columns.Add("DataType"' typeof(string));  // The name of the .NET Framework type of the data type.                  table.Columns.Add("IsAutoincrementable"' typeof(bool));                  table.Columns.Add("IsBestMatch"' typeof(bool));                  table.Columns.Add("IsCaseSensitive"' typeof(bool));                  table.Columns.Add("IsFixedLength"' typeof(bool));                  table.Columns.Add("IsFixedPrecisionScale"' typeof(bool));                  table.Columns.Add("IsLong"' typeof(bool));                  table.Columns.Add("IsNullable"' typeof(bool));                  table.Columns.Add("IsSearchable"' typeof(bool));                  table.Columns.Add("IsSearchableWithLike"' typeof(bool));                  table.Columns.Add("IsUnsigned"' typeof(bool));                  table.Columns.Add("MaximumScale"' typeof(short));                  table.Columns.Add("MinimumScale"' typeof(short));                  table.Columns.Add("IsConcurrencyType"' typeof(bool));                  table.Columns.Add("IsLiteralsSupported"' typeof(bool));                  table.Columns.Add("LiteralPrefix"' typeof(string));                  table.Columns.Add("LiteralSuffix"' typeof(string));                  table.Columns.Add("NativeDataType"' typeof(string));    // NativeDataType is an OLE DB specific column for exposing the OLE DB type of the data type .                    table.ReadXml(XmlReader.Create(typeof(NuoDbConnectionInternal).Assembly.GetManifestResourceStream("NuoDb.Data.Client.DataTypes.xml")));              }              else if (collectionName == "Tables")              {                  table.Columns.Add("TABLE_CATALOG"' typeof(string));                  table.Columns.Add("TABLE_SCHEMA"' typeof(string));                  table.Columns.Add("TABLE_NAME"' typeof(string));                  table.Columns.Add("TABLE_TYPE"' typeof(string));                  table.Columns.Add("REMARKS"' typeof(string));                  table.Columns.Add("VIEW_DEF"' typeof(string));                    tmConn.InternalConnection.dataStream.startMessage(Protocol.GetTables);                  tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                  for (int i = 1; i < 3; i++)                      if (restrictionValues != null && restrictionValues.Length > i)                          tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                      else                          tmConn.InternalConnection.dataStream.encodeNull();                  if (restrictionValues == null || restrictionValues.Length < 4 || restrictionValues[3] == null)                      tmConn.InternalConnection.dataStream.encodeInt(0);                  else                  {                      tmConn.InternalConnection.dataStream.encodeInt(1);                      tmConn.InternalConnection.dataStream.encodeString(restrictionValues[3]);                  }                    tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                  int handle = tmConn.InternalConnection.dataStream.getInt();                    if (handle != -1)                  {                      using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                      {                          table.BeginLoadData();                          string view_def_label="";                          try                           {                               reader.GetOrdinal("VIEW_DEF");                              view_def_label = "VIEW_DEF";                          }                          catch(Exception) {}                          try                           {                               reader.GetOrdinal("VIEWDEFINITION");                              view_def_label = "VIEWDEFINITION";                          }                          catch (Exception) { }                          while (reader.Read())                          {  #if DEBUG                          System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_NAME"] + "' " + reader["TABLE_TYPE"]);  #endif                              DataRow row = table.NewRow();                              row["TABLE_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                              row["TABLE_NAME"] = reader.GetFieldValue<string>("TABLE_NAME");                              row["TABLE_TYPE"] = reader.GetFieldValue<string>("TABLE_TYPE");                              row["REMARKS"] = reader.GetFieldValue<string>("REMARKS");                              if (view_def_label.Length != 0)                              {                                  row["VIEW_DEF"] = reader.GetFieldValue<string>(view_def_label);                              }                              table.Rows.Add(row);                          }                          table.EndLoadData();                      }                  }              }              else if (collectionName == "Columns")              {                  table.Columns.Add("COLUMN_CATALOG"' typeof(string));                  table.Columns.Add("COLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("COLUMN_TABLE"' typeof(string));                  table.Columns.Add("COLUMN_NAME"' typeof(string));                  table.Columns.Add("COLUMN_POSITION"' typeof(int));                  table.Columns.Add("COLUMN_TYPE"' typeof(string));                  table.Columns.Add("COLUMN_LENGTH"' typeof(int));                  table.Columns.Add("COLUMN_PRECISION"' typeof(int));                  table.Columns.Add("COLUMN_NULLABLE"' typeof(bool));                  table.Columns.Add("COLUMN_IDENTITY"' typeof(bool));                  table.Columns.Add("COLUMN_DEFAULT"' typeof(string));                  table.Columns.Add("COLUMN_SCALE"' typeof(int));                    tmConn.InternalConnection.dataStream.startMessage(Protocol.GetColumns);                  tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                  for (int i = 1; i < 4; i++)                      if (restrictionValues != null && restrictionValues.Length > i)                          tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                      else                          tmConn.InternalConnection.dataStream.encodeNull();                    tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                  int handle = tmConn.InternalConnection.dataStream.getInt();                    if (handle != -1)                  {                      using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                      {                          table.BeginLoadData();                          while (reader.Read())                          {                              DataRow row = table.NewRow();                              row["COLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                              row["COLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                              row["COLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                              row["COLUMN_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                              row["COLUMN_LENGTH"] = reader.GetFieldValue<int>("COLUMN_SIZE");                              row["COLUMN_PRECISION"] = reader.GetFieldValue<int>("BUFFER_LENGTH");                              row["COLUMN_SCALE"] = reader.GetFieldValue<int>("DECIMAL_DIGITS");                              if (isNumeric(reader.GetFieldValue<string>("TYPE_NAME")))                              {                                  if (reader.GetFieldValue<int>("DECIMAL_DIGITS") != 0)                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME") +                                           "(" + reader.GetFieldValue<int>("BUFFER_LENGTH") + "'" + reader.GetFieldValue<int>("DECIMAL_DIGITS") + ")";                                  else                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME");                              }                              else                              {                                  if (isVarLenType(reader.GetFieldValue<string>("TYPE_NAME")) && reader.GetFieldValue<int>("COLUMN_SIZE") != 0)                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME") +                                           "(" + reader.GetFieldValue<int>("COLUMN_SIZE") + ")";                                  else                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME");                              }                              if (!reader.IsDBNull(reader.GetOrdinal("IS_NULLABLE")))                                  row["COLUMN_NULLABLE"] = reader.GetFieldValue<string>("IS_NULLABLE").Equals("YES");                              if (!reader.IsDBNull(reader.GetOrdinal("IS_AUTOINCREMENT")))                                  row["COLUMN_IDENTITY"] = reader.GetFieldValue<string>("IS_AUTOINCREMENT").Equals("YES");                              row["COLUMN_DEFAULT"] = reader.GetFieldValue<string>("COLUMN_DEF");    #if DEBUG                              System.Diagnostics.Trace.WriteLine("-> " + row["COLUMN_NAME"] + " " + row["COLUMN_TYPE"]);  #endif                              table.Rows.Add(row);                          }                          table.EndLoadData();                      }                  }              }              else if (collectionName == "Indexes")              {                  table.Columns.Add("INDEX_CATALOG"' typeof(string));                  table.Columns.Add("INDEX_SCHEMA"' typeof(string));                  table.Columns.Add("INDEX_TABLE"' typeof(string));                  table.Columns.Add("INDEX_NAME"' typeof(string));                  table.Columns.Add("INDEX_TYPE"' typeof(string));                  table.Columns.Add("INDEX_UNIQUE"' typeof(bool));                  table.Columns.Add("INDEX_PRIMARY"' typeof(bool));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetIndexInfo);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // unique                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // approximate                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        // to avoid to insert the same index more than once                      HashSet<string> unique = new HashSet<string>();                      if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;                                  if (!unique.Add(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;                                  DataRow row = table.NewRow();                                  row["INDEX_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEX_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEX_NAME"] = reader.GetFieldValue<string>("INDEX_NAME");                                  switch (reader.GetFieldValue<int>("TYPE"))                                  {                                      case 0:                                          row["INDEX_TYPE"] = "Primary";                                          break;                                      case 1:                                          row["INDEX_TYPE"] = "Unique";                                          break;                                      case 2:                                          row["INDEX_TYPE"] = "Secondary";                                          break;                                      case 3:                                          row["INDEX_TYPE"] = "Foreign Key";                                          break;                                  }                                  row["INDEX_UNIQUE"] = (reader.GetFieldValue<int>("NON_UNIQUE") == 0) ? true : false;                                  row["INDEX_PRIMARY"] = (reader.GetFieldValue<int>("TYPE") == 0) ? true : false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                        tmConn.InternalConnection.dataStream.startMessage(Protocol.GetPrimaryKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              // use INDEX_NAME' if present; if missing' the name of the index is in PK_NAME                              string indexName = "PK_NAME";                              foreach (string column in reader.columnNames)                              {                                  if (column == "INDEX_NAME")                                  {                                      indexName = "INDEX_NAME";                                      break;                                  }                              }                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>(indexName)))                                      continue;                                  if (!unique.Add(reader.GetFieldValue<string>(indexName)))                                      continue;                                  DataRow row = table.NewRow();                                  row["INDEX_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEX_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEX_NAME"] = reader.GetFieldValue<string>(indexName);                                  row["INDEX_TYPE"] = "Primary";                                  row["INDEX_UNIQUE"] = true;                                  row["INDEX_PRIMARY"] = true;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "IndexColumns")              {                  table.Columns.Add("INDEXCOLUMN_CATALOG"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_TABLE"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_INDEX"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_NAME"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_POSITION"' typeof(int));                  table.Columns.Add("INDEXCOLUMN_ISPRIMARY"' typeof(bool));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetIndexInfo);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // unique                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // approximate                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_SCHEM"] + "." + reader["TABLE_NAME"] + "=" + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["INDEXCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEXCOLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEXCOLUMN_INDEX"] = reader.GetFieldValue<string>("INDEX_NAME");                                  row["INDEXCOLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["INDEXCOLUMN_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                                  row["INDEXCOLUMN_ISPRIMARY"] = false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                        tmConn.InternalConnection.dataStream.startMessage(Protocol.GetPrimaryKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              // use INDEX_NAME' if present; if missing' the name of the index is in PK_NAME                              string indexName = "PK_NAME";                              foreach (string column in reader.columnNames)                              {                                  if (column == "INDEX_NAME")                                  {                                      indexName = "INDEX_NAME";                                      break;                                  }                              }                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>(indexName)))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_SCHEM"] + "." + reader["TABLE_NAME"] + " (Primary) =" + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["INDEXCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEXCOLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEXCOLUMN_INDEX"] = reader.GetFieldValue<string>(indexName);                                  row["INDEXCOLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["INDEXCOLUMN_POSITION"] = reader.GetFieldValue<int>("KEY_SEQ");                                  row["INDEXCOLUMN_ISPRIMARY"] = true;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ForeignKeys")              {                  table.Columns.Add("FOREIGNKEY_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEY_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEY_TABLE"' typeof(string));                  table.Columns.Add("FOREIGNKEY_NAME"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_TABLE"' typeof(string));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetImportedKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  string name = "[" + reader.GetFieldValue<string>("FKTABLE_SCHEM") + "]" +                                                   reader.GetFieldValue<string>("FKTABLE_NAME") + "." +                                                   reader.GetFieldValue<string>("FKCOLUMN_NAME") + "->" +                                                  "[" + reader.GetFieldValue<string>("PKTABLE_SCHEM") + "]" +                                                   reader.GetFieldValue<string>("PKTABLE_NAME") + "." +                                                   reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(name))                                      continue;                                  DataRow row = table.NewRow();                                  row["FOREIGNKEY_SCHEMA"] = reader.GetFieldValue<string>("FKTABLE_SCHEM");                                  row["FOREIGNKEY_TABLE"] = reader.GetFieldValue<string>("FKTABLE_NAME");                                  row["FOREIGNKEY_NAME"] = name;                                  row["FOREIGNKEY_OTHER_SCHEMA"] = reader.GetFieldValue<string>("PKTABLE_SCHEM");                                  row["FOREIGNKEY_OTHER_TABLE"] = reader.GetFieldValue<string>("PKTABLE_NAME");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ForeignKeyColumns")              {                  table.Columns.Add("FOREIGNKEYCOLUMN_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_TABLE"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_KEY"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_NAME"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_ORDINAL"' typeof(int));                  table.Columns.Add("FOREIGNKEYCOLUMN_OTHER_COLUMN_NAME"' typeof(string));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetImportedKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  string name = "[" + reader.GetFieldValue<string>("FKTABLE_SCHEM") + "]" +                                                  reader.GetFieldValue<string>("FKTABLE_NAME") + "." +                                                  reader.GetFieldValue<string>("FKCOLUMN_NAME") + "->" +                                                  "[" + reader.GetFieldValue<string>("PKTABLE_SCHEM") + "]" +                                                  reader.GetFieldValue<string>("PKTABLE_NAME") + "." +                                                  reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(name))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["FKTABLE_SCHEM"] + "." + reader["FKTABLE_NAME"] + "=" + reader["FKCOLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["FOREIGNKEYCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("FKTABLE_SCHEM");                                  row["FOREIGNKEYCOLUMN_TABLE"] = reader.GetFieldValue<string>("FKTABLE_NAME");                                  row["FOREIGNKEYCOLUMN_KEY"] = name;                                  row["FOREIGNKEYCOLUMN_NAME"] = reader.GetFieldValue<string>("FKCOLUMN_NAME");                                  row["FOREIGNKEYCOLUMN_ORDINAL"] = reader.GetFieldValue<int>("KEY_SEQ");                                  row["FOREIGNKEYCOLUMN_OTHER_COLUMN_NAME"] = reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "Procedures")               {                  table.Columns.Add("PROCEDURE_CATALOG"' typeof(string));                  table.Columns.Add("PROCEDURE_SCHEMA"' typeof(string));                  table.Columns.Add("PROCEDURE_NAME"' typeof(string));                  table.Columns.Add("IS_SYSTEM_PROCEDURE"' typeof(bool));                    if (tmConn.InternalConnection.protocolVersion >= Protocol.PROTOCOL_VERSION12)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetProcedures);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      for (int i = 1; i < 3; i++)                          if (restrictionValues != null && restrictionValues.Length > i)                              tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                          else                              tmConn.InternalConnection.dataStream.encodeNull();                        tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["PROCEDURE_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["PROCEDURE_SCHEMA"] = reader.GetFieldValue<string>("PROCEDURE_SCHEM");                                  row["PROCEDURE_NAME"] = reader.GetFieldValue<string>("PROCEDURE_NAME");                                  row["IS_SYSTEM_PROCEDURE"] = false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ProcedureParameters")              {                  table.Columns.Add("PROCEDURE_CATALOG"' typeof(string));                  table.Columns.Add("PROCEDURE_SCHEMA"' typeof(string));                  table.Columns.Add("PROCEDURE_NAME"' typeof(string));                  table.Columns.Add("PARAMETER_NAME"' typeof(string));                  table.Columns.Add("ORDINAL_POSITION"' typeof(int));                  table.Columns.Add("PARAMETER_DATA_TYPE"' typeof(int));                  table.Columns.Add("PARAMETER_TYPE_NAME"' typeof(string));                  table.Columns.Add("PARAMETER_SIZE"' typeof(int));                  table.Columns.Add("NUMERIC_PRECISION"' typeof(int));                  table.Columns.Add("NUMERIC_SCALE"' typeof(int));                  table.Columns.Add("PARAMETER_DIRECTION"' typeof(int));                  table.Columns.Add("IS_NULLABLE"' typeof(bool));                    if (tmConn.InternalConnection.protocolVersion >= Protocol.PROTOCOL_VERSION12)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetProcedureColumns);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      for (int i = 1; i < 4; i++)                          if (restrictionValues != null && restrictionValues.Length > i)                              tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                          else                              tmConn.InternalConnection.dataStream.encodeNull();                        tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["PROCEDURE_NAME"] + "' " + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["PROCEDURE_SCHEMA"] = reader.GetFieldValue<string>("PROCEDURE_SCHEM");                                  row["PROCEDURE_NAME"] = reader.GetFieldValue<string>("PROCEDURE_NAME");                                  row["PARAMETER_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["ORDINAL_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                                  row["PARAMETER_TYPE_NAME"] = reader.GetFieldValue<string>("TYPE_NAME");                                  row["PARAMETER_DATA_TYPE"] = reader.GetFieldValue<int>("DATA_TYPE");                                  row["PARAMETER_SIZE"] = reader.GetFieldValue<int>("LENGTH");                                  row["NUMERIC_PRECISION"] = reader.GetFieldValue<int>("PRECISION");                                  row["NUMERIC_SCALE"] = reader.GetFieldValue<int>("SCALE");                                  row["PARAMETER_DIRECTION"] = reader.GetFieldValue<int>("COLUMN_TYPE");                                  row["IS_NULLABLE"] = !reader.GetFieldValue<string>("IS_NULLABLE").Equals("NO");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The following statement contains a magic number: if (collectionName == DbMetaDataCollectionNames.DataSourceInformation)              {                  // see http://msdn.microsoft.com/en-us/library/ms254501.aspx                  table.Columns.Add("CompositeIdentifierSeparatorPattern"' typeof(string));                  table.Columns.Add("DataSourceProductName"' typeof(string));                  table.Columns.Add("DataSourceProductVersion"' typeof(string));                  table.Columns.Add("DataSourceProductVersionNormalized"' typeof(string));                  table.Columns.Add("DataSourceInternalProductVersion"' typeof(string));                  table.Columns.Add("GroupByBehavior"' typeof(GroupByBehavior));                  table.Columns.Add("IdentifierPattern"' typeof(string));                  table.Columns.Add("IdentifierCase"' typeof(IdentifierCase));                  table.Columns.Add("OrderByColumnsInSelect"' typeof(bool));                  table.Columns.Add("ParameterMarkerFormat"' typeof(string));                  table.Columns.Add("ParameterMarkerPattern"' typeof(string));                  table.Columns.Add("ParameterNameMaxLength"' typeof(int));                  table.Columns.Add("ParameterNamePattern"' typeof(string));                  table.Columns.Add("QuotedIdentifierPattern"' typeof(string));  // Regex                  table.Columns.Add("QuotedIdentifierCase"' typeof(int));                  table.Columns.Add("StatementSeparatorPattern"' typeof(string));                  table.Columns.Add("StringLiteralPattern"' typeof(string));  // Regex                  table.Columns.Add("SupportedJoinOperators"' typeof(SupportedJoinOperators));                    table.BeginLoadData();                  DataRow row = table.NewRow();                  int databaseMajorVersion = 0' databaseMinorVersion = 0;                  try                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetDatabaseMetaData);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      for (int item; (item = tmConn.InternalConnection.dataStream.getInt()) != Protocol.DbmbFini; )                      {                          switch (item)                          {                              case Protocol.DbmbProductName:                                  row["DataSourceProductName"] = tmConn.InternalConnection.dataStream.getString();                                  break;                                case Protocol.DbmbProductVersion:                                  row["DataSourceProductVersion"] = tmConn.InternalConnection.dataStream.getString();                                  break;                                case Protocol.DbmbDatabaseMinorVersion:                                  databaseMinorVersion = tmConn.InternalConnection.dataStream.getInt();                                  break;                                case Protocol.DbmbDatabaseMajorVersion:                                  databaseMajorVersion = tmConn.InternalConnection.dataStream.getInt();                                  break;                                case Protocol.DbmbDefaultTransactionIsolation:                                  int defaultTransactionIsolation = tmConn.InternalConnection.dataStream.getInt();                                  break;                                default:                                  tmConn.InternalConnection.dataStream.decode();                                  break;                          }                      }                  }                  catch (Exception)                  {                  }                    row["DataSourceInternalProductVersion"] = String.Format("{0:D3}.{1:D3}"' databaseMajorVersion' databaseMinorVersion);                  // The regular expression to match the composite separators in a composite identifier.                   // For example' "\." (for SQL Server) or "@|\." (for Oracle).                  // A composite identifier is typically what is used for a database object name'                   // for example: pubs.dbo.authors or pubs@dbo.authors.                  row["CompositeIdentifierSeparatorPattern"] = "\\.";                  // A normalized version for the data source' such that it can be compared with String.Compare().                   // The format of this is consistent for all versions of the provider to prevent version 10 from sorting between version 1 and version 2.                  //row["DataSourceProductVersionNormalized"] = ??                  // Specifies the relationship between the columns in a GROUP BY clause and the non-aggregated columns in the select list.                  row["GroupByBehavior"] = GroupByBehavior.Unknown;                  // A regular expression that matches an identifier and has a match value of the identifier. For example "[A-Za-z0-9_#$]".                  row["IdentifierPattern"] = "(^\\[\\p{Lo}\\p{Lu}\\p{Ll}_@#][\\p{Lo}\\p{Lu}\\p{Ll}\\p{Nd}@$#_]*$)|(^\"[^\"\\0]|\"\"+\"$)";                  // Indicates whether non-quoted identifiers are treated as case sensitive or not.                  row["IdentifierCase"] = IdentifierCase.Insensitive;                  // Specifies whether columns in an ORDER BY clause must be in the select list.                   // A value of true indicates that they are required to be in the select list'                   // a value of false indicates that they are not required to be in the select list.                  row["OrderByColumnsInSelect"] = false;                  // For data sources that do not expect named parameters and expect the use of the ‘?’ character' the format string                  // can be specified as simply '?'' which would ignore the parameter name.                  row["ParameterMarkerFormat"] = "?";                  // if the data source doesn't support named parameters' this would simply be "?".                  row["ParameterMarkerPattern"] = "?";                  // If the data source does not support named parameters' this property returns zero.                  row["ParameterNameMaxLength"] = 0;                  // A regular expression that matches the valid parameter names                  row["ParameterNamePattern"] = "";                  // A regular expression that matches a quoted identifier and has a match value of the identifier itself without the quotes.                   // For example' if the data source used double-quotes to identify quoted identifiers' this would be: "(([^\"]|\"\")*)".                  row["QuotedIdentifierPattern"] = "\"([^\"]*)\"";                  // Indicates whether quoted identifiers are treated as case sensitive or not.                  row["QuotedIdentifierCase"] = IdentifierCase.Sensitive;                  // A regular expression that matches the statement separator.                  row["StatementSeparatorPattern"] = ";";                  // A regular expression that matches a string literal and has a match value of the literal itself.                   // For example' if the data source used single-quotes to identify strings' this would be: "('([^']|'')*')"'                  row["StringLiteralPattern"] = "'([^']*)'";                  // Specifies what types of SQL join statements are supported by the data source.                  row["SupportedJoinOperators"] = SupportedJoinOperators.None;                  table.Rows.Add(row);                  table.EndLoadData();              }              else if (collectionName == DbMetaDataCollectionNames.ReservedWords)              {                  table.Columns.Add("ReservedWord"' typeof(string));                  table.Columns.Add("MaximumVersion"' typeof(string));                  table.Columns.Add("MinimumVersion"' typeof(string));                    string[] words = { "select"' "Add field"' "Drop field"' "Alter table"' "Alter field"'                                      "Alter user"' "And"' "Or"' "Not"' "Create Index"' "Upgrade"' "Unique"'                                      "Table key"' "Table unique key"' "Primary Key"' "Create Table"'                                      "Upgrade Table"' "Rename Table"' "Create View"' "Upgrade View"'                                      "Drop View"' "Create Schema"' "Drop Schema"' "Integer"' "Smallint"'                                      "Bigint"' "Tinyint"' "float"' "double"' "Blob"' "bytes"' "boolean"'                                      "binary"' "varbinary"' "string"' "char"' "text"' "date"' "timestamp"'                                      "time"' "varchar"' "numeric"' "Decimal Number"' "Enum"' "Delete"' "Repair"'                                      "Field"' "Not Null"' "Default Value"' "searchable"' "not searchable"'                                      "collation"' "character_set"' "Foreign Key"' "Identifier"' "record number"'                                      "Insert"' "Replace"' "Name"' "Number"' "Order"' "Descending"' "limit"'                                      "Quoted String"' "Select Clause"' "Distinct"' "Gtr"' "Geq"' "Eql"'                                      "Leq"' "Lss"' "Neq"' "in list"' "in select"' "exists"' "Between"' "Like"'                                      "starts with"' "Containing"' "Matching"' "Regular expression"' "Null"'                                      "True"' "False"' "Execute"' "Parameter"' "Count"' "sum"' "min"' "max"'                                      "avg"' "Drop Index"' "Drop primary key"' "Drop foreign key"' "Drop Table"'                                      "If Exists"' "Describe"' "Statement"' "for_select"' "for_insert"' "while"'                                      "if then else"' "variable"' "declaration"' "throw"' "assignment"'                                      "Start transaction"' "read only"' "read write"' "read committed"' "write committed"'                                      "read uncommitted"' "repeatableread"' "serializable"' "Commit"' "Rollback"'                                      "Savepoint"' "Rollack Savepoint"' "Release Savepoint"' "Table"' "Derived Table"'                                      "Assign"' "Update"' "list"' "Constant"' "Function"' "Grant"' "Grant role"' "Alter"'                                      "Read"' "Identity"' "Check"' "Constraint"' "value constraint"' "auto increment"'                                      "generated"' "always"' "Domain"' "is null"' "is active_role"' "start with"' "reindex"'                                      "cursor"' "alias"' "push_namespace"' "pop_namespace"' "set_namespace"' "coalesce"'                                      "nod_nullif"' "case"' "case_search"' "add"' "subtract"' "multiply"' "divide"' "modulus"'                                      "negate"' "plus"' "cast"' "concatenation"' "create user"' "drop user"' "create role"'                                      "upgrade role"' "drop role"' "revoke"' "revoke role"' "assume"' "revert"' "negate"'                                      "priv insert"' "priv delete"' "priv execute"' "priv select"' "priv update"' "priv grant"'                                      "priv all"' "characters"' "octets"' "role"' "view"' "procedure"' "user"' "zone"' "admin"'                                      "default role"' "create sequence"' "upgrade sequence"' "drop sequence"' "next value"'                                      "create trigger"' "upgrade trigger"' "alter trigger"' "drop trigger"' "create procedure"'                                      "upgrade procedure"' "alter procedure"' "drop procedure"' "pre-insert"' "post-insert"'                                      "pre-update"' "post-update"' "pre-delete"' "post-delete"' "pre-commit"' "post-commit"'                                      "active"' "inactive"' "position"' "select-expr"' "create filterset"' "upgrade filterset"'                                      "drop filterset"' "enable filterset"' "disable filterset"' "table filter"' "left outer"'                                      "right outer"' "full outer"' "inner"' "join"' "join_term"' "trigger class"' "enable trigger class"'                                      "disable trigger class"' "create zone"' "upgrade zone"' "drop zone"' "range"' "ip address"'                                      "node_name"' "wildcard"' "create domain"' "upgrade domain"' "alter domain"' "upgrade schema"'                                      "delete cascade"' "index segment"' "for update"' "write committed"' "read committed"'                                       "consistent read"' "set dialect"' "set names"' "restrict"' "cascade"' "characters"' "octets"'                                      "create event"' "collate"' "truncate"' "restart"' "nameless constraint"' "drop constraint"'                                      "drop unique constraint"' "drop domain"' "with check option"' "not real"' "lower"' "upper"'                                      "substr"' "substring index"' "charlength"' "default keyword"' "sqrt"' "power"' "Scientific Notation Number"'                                      "Explain"' "msleep"' "KillStatement"' "now" };                  table.BeginLoadData();                  foreach (string keyword in words)                  {                      DataRow row = table.NewRow();                      row["ReservedWord"] = keyword;                      table.Rows.Add(row);                  }                  table.EndLoadData();                }              else if (collectionName == DbMetaDataCollectionNames.DataTypes)              {                  table.Columns.Add("TypeName"' typeof(string));  // The provider-specific data type name.                  table.Columns.Add("ProviderDbType"' typeof(int)); // The provider-specific type value that should be used when specifying                   //a parameter's type. For example' SqlDbType.Money or OracleType.Blob.                  table.Columns.Add("ColumnSize"' typeof(long));                  table.Columns.Add("CreateFormat"' typeof(string));                  table.Columns.Add("CreateParameters"' typeof(string));                  table.Columns.Add("DataType"' typeof(string));  // The name of the .NET Framework type of the data type.                  table.Columns.Add("IsAutoincrementable"' typeof(bool));                  table.Columns.Add("IsBestMatch"' typeof(bool));                  table.Columns.Add("IsCaseSensitive"' typeof(bool));                  table.Columns.Add("IsFixedLength"' typeof(bool));                  table.Columns.Add("IsFixedPrecisionScale"' typeof(bool));                  table.Columns.Add("IsLong"' typeof(bool));                  table.Columns.Add("IsNullable"' typeof(bool));                  table.Columns.Add("IsSearchable"' typeof(bool));                  table.Columns.Add("IsSearchableWithLike"' typeof(bool));                  table.Columns.Add("IsUnsigned"' typeof(bool));                  table.Columns.Add("MaximumScale"' typeof(short));                  table.Columns.Add("MinimumScale"' typeof(short));                  table.Columns.Add("IsConcurrencyType"' typeof(bool));                  table.Columns.Add("IsLiteralsSupported"' typeof(bool));                  table.Columns.Add("LiteralPrefix"' typeof(string));                  table.Columns.Add("LiteralSuffix"' typeof(string));                  table.Columns.Add("NativeDataType"' typeof(string));    // NativeDataType is an OLE DB specific column for exposing the OLE DB type of the data type .                    table.ReadXml(XmlReader.Create(typeof(NuoDbConnectionInternal).Assembly.GetManifestResourceStream("NuoDb.Data.Client.DataTypes.xml")));              }              else if (collectionName == "Tables")              {                  table.Columns.Add("TABLE_CATALOG"' typeof(string));                  table.Columns.Add("TABLE_SCHEMA"' typeof(string));                  table.Columns.Add("TABLE_NAME"' typeof(string));                  table.Columns.Add("TABLE_TYPE"' typeof(string));                  table.Columns.Add("REMARKS"' typeof(string));                  table.Columns.Add("VIEW_DEF"' typeof(string));                    tmConn.InternalConnection.dataStream.startMessage(Protocol.GetTables);                  tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                  for (int i = 1; i < 3; i++)                      if (restrictionValues != null && restrictionValues.Length > i)                          tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                      else                          tmConn.InternalConnection.dataStream.encodeNull();                  if (restrictionValues == null || restrictionValues.Length < 4 || restrictionValues[3] == null)                      tmConn.InternalConnection.dataStream.encodeInt(0);                  else                  {                      tmConn.InternalConnection.dataStream.encodeInt(1);                      tmConn.InternalConnection.dataStream.encodeString(restrictionValues[3]);                  }                    tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                  int handle = tmConn.InternalConnection.dataStream.getInt();                    if (handle != -1)                  {                      using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                      {                          table.BeginLoadData();                          string view_def_label="";                          try                           {                               reader.GetOrdinal("VIEW_DEF");                              view_def_label = "VIEW_DEF";                          }                          catch(Exception) {}                          try                           {                               reader.GetOrdinal("VIEWDEFINITION");                              view_def_label = "VIEWDEFINITION";                          }                          catch (Exception) { }                          while (reader.Read())                          {  #if DEBUG                          System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_NAME"] + "' " + reader["TABLE_TYPE"]);  #endif                              DataRow row = table.NewRow();                              row["TABLE_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                              row["TABLE_NAME"] = reader.GetFieldValue<string>("TABLE_NAME");                              row["TABLE_TYPE"] = reader.GetFieldValue<string>("TABLE_TYPE");                              row["REMARKS"] = reader.GetFieldValue<string>("REMARKS");                              if (view_def_label.Length != 0)                              {                                  row["VIEW_DEF"] = reader.GetFieldValue<string>(view_def_label);                              }                              table.Rows.Add(row);                          }                          table.EndLoadData();                      }                  }              }              else if (collectionName == "Columns")              {                  table.Columns.Add("COLUMN_CATALOG"' typeof(string));                  table.Columns.Add("COLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("COLUMN_TABLE"' typeof(string));                  table.Columns.Add("COLUMN_NAME"' typeof(string));                  table.Columns.Add("COLUMN_POSITION"' typeof(int));                  table.Columns.Add("COLUMN_TYPE"' typeof(string));                  table.Columns.Add("COLUMN_LENGTH"' typeof(int));                  table.Columns.Add("COLUMN_PRECISION"' typeof(int));                  table.Columns.Add("COLUMN_NULLABLE"' typeof(bool));                  table.Columns.Add("COLUMN_IDENTITY"' typeof(bool));                  table.Columns.Add("COLUMN_DEFAULT"' typeof(string));                  table.Columns.Add("COLUMN_SCALE"' typeof(int));                    tmConn.InternalConnection.dataStream.startMessage(Protocol.GetColumns);                  tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                  for (int i = 1; i < 4; i++)                      if (restrictionValues != null && restrictionValues.Length > i)                          tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                      else                          tmConn.InternalConnection.dataStream.encodeNull();                    tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                  int handle = tmConn.InternalConnection.dataStream.getInt();                    if (handle != -1)                  {                      using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                      {                          table.BeginLoadData();                          while (reader.Read())                          {                              DataRow row = table.NewRow();                              row["COLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                              row["COLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                              row["COLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                              row["COLUMN_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                              row["COLUMN_LENGTH"] = reader.GetFieldValue<int>("COLUMN_SIZE");                              row["COLUMN_PRECISION"] = reader.GetFieldValue<int>("BUFFER_LENGTH");                              row["COLUMN_SCALE"] = reader.GetFieldValue<int>("DECIMAL_DIGITS");                              if (isNumeric(reader.GetFieldValue<string>("TYPE_NAME")))                              {                                  if (reader.GetFieldValue<int>("DECIMAL_DIGITS") != 0)                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME") +                                           "(" + reader.GetFieldValue<int>("BUFFER_LENGTH") + "'" + reader.GetFieldValue<int>("DECIMAL_DIGITS") + ")";                                  else                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME");                              }                              else                              {                                  if (isVarLenType(reader.GetFieldValue<string>("TYPE_NAME")) && reader.GetFieldValue<int>("COLUMN_SIZE") != 0)                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME") +                                           "(" + reader.GetFieldValue<int>("COLUMN_SIZE") + ")";                                  else                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME");                              }                              if (!reader.IsDBNull(reader.GetOrdinal("IS_NULLABLE")))                                  row["COLUMN_NULLABLE"] = reader.GetFieldValue<string>("IS_NULLABLE").Equals("YES");                              if (!reader.IsDBNull(reader.GetOrdinal("IS_AUTOINCREMENT")))                                  row["COLUMN_IDENTITY"] = reader.GetFieldValue<string>("IS_AUTOINCREMENT").Equals("YES");                              row["COLUMN_DEFAULT"] = reader.GetFieldValue<string>("COLUMN_DEF");    #if DEBUG                              System.Diagnostics.Trace.WriteLine("-> " + row["COLUMN_NAME"] + " " + row["COLUMN_TYPE"]);  #endif                              table.Rows.Add(row);                          }                          table.EndLoadData();                      }                  }              }              else if (collectionName == "Indexes")              {                  table.Columns.Add("INDEX_CATALOG"' typeof(string));                  table.Columns.Add("INDEX_SCHEMA"' typeof(string));                  table.Columns.Add("INDEX_TABLE"' typeof(string));                  table.Columns.Add("INDEX_NAME"' typeof(string));                  table.Columns.Add("INDEX_TYPE"' typeof(string));                  table.Columns.Add("INDEX_UNIQUE"' typeof(bool));                  table.Columns.Add("INDEX_PRIMARY"' typeof(bool));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetIndexInfo);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // unique                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // approximate                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        // to avoid to insert the same index more than once                      HashSet<string> unique = new HashSet<string>();                      if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;                                  if (!unique.Add(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;                                  DataRow row = table.NewRow();                                  row["INDEX_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEX_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEX_NAME"] = reader.GetFieldValue<string>("INDEX_NAME");                                  switch (reader.GetFieldValue<int>("TYPE"))                                  {                                      case 0:                                          row["INDEX_TYPE"] = "Primary";                                          break;                                      case 1:                                          row["INDEX_TYPE"] = "Unique";                                          break;                                      case 2:                                          row["INDEX_TYPE"] = "Secondary";                                          break;                                      case 3:                                          row["INDEX_TYPE"] = "Foreign Key";                                          break;                                  }                                  row["INDEX_UNIQUE"] = (reader.GetFieldValue<int>("NON_UNIQUE") == 0) ? true : false;                                  row["INDEX_PRIMARY"] = (reader.GetFieldValue<int>("TYPE") == 0) ? true : false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                        tmConn.InternalConnection.dataStream.startMessage(Protocol.GetPrimaryKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              // use INDEX_NAME' if present; if missing' the name of the index is in PK_NAME                              string indexName = "PK_NAME";                              foreach (string column in reader.columnNames)                              {                                  if (column == "INDEX_NAME")                                  {                                      indexName = "INDEX_NAME";                                      break;                                  }                              }                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>(indexName)))                                      continue;                                  if (!unique.Add(reader.GetFieldValue<string>(indexName)))                                      continue;                                  DataRow row = table.NewRow();                                  row["INDEX_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEX_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEX_NAME"] = reader.GetFieldValue<string>(indexName);                                  row["INDEX_TYPE"] = "Primary";                                  row["INDEX_UNIQUE"] = true;                                  row["INDEX_PRIMARY"] = true;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "IndexColumns")              {                  table.Columns.Add("INDEXCOLUMN_CATALOG"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_TABLE"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_INDEX"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_NAME"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_POSITION"' typeof(int));                  table.Columns.Add("INDEXCOLUMN_ISPRIMARY"' typeof(bool));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetIndexInfo);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // unique                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // approximate                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_SCHEM"] + "." + reader["TABLE_NAME"] + "=" + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["INDEXCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEXCOLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEXCOLUMN_INDEX"] = reader.GetFieldValue<string>("INDEX_NAME");                                  row["INDEXCOLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["INDEXCOLUMN_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                                  row["INDEXCOLUMN_ISPRIMARY"] = false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                        tmConn.InternalConnection.dataStream.startMessage(Protocol.GetPrimaryKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              // use INDEX_NAME' if present; if missing' the name of the index is in PK_NAME                              string indexName = "PK_NAME";                              foreach (string column in reader.columnNames)                              {                                  if (column == "INDEX_NAME")                                  {                                      indexName = "INDEX_NAME";                                      break;                                  }                              }                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>(indexName)))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_SCHEM"] + "." + reader["TABLE_NAME"] + " (Primary) =" + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["INDEXCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEXCOLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEXCOLUMN_INDEX"] = reader.GetFieldValue<string>(indexName);                                  row["INDEXCOLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["INDEXCOLUMN_POSITION"] = reader.GetFieldValue<int>("KEY_SEQ");                                  row["INDEXCOLUMN_ISPRIMARY"] = true;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ForeignKeys")              {                  table.Columns.Add("FOREIGNKEY_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEY_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEY_TABLE"' typeof(string));                  table.Columns.Add("FOREIGNKEY_NAME"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_TABLE"' typeof(string));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetImportedKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  string name = "[" + reader.GetFieldValue<string>("FKTABLE_SCHEM") + "]" +                                                   reader.GetFieldValue<string>("FKTABLE_NAME") + "." +                                                   reader.GetFieldValue<string>("FKCOLUMN_NAME") + "->" +                                                  "[" + reader.GetFieldValue<string>("PKTABLE_SCHEM") + "]" +                                                   reader.GetFieldValue<string>("PKTABLE_NAME") + "." +                                                   reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(name))                                      continue;                                  DataRow row = table.NewRow();                                  row["FOREIGNKEY_SCHEMA"] = reader.GetFieldValue<string>("FKTABLE_SCHEM");                                  row["FOREIGNKEY_TABLE"] = reader.GetFieldValue<string>("FKTABLE_NAME");                                  row["FOREIGNKEY_NAME"] = name;                                  row["FOREIGNKEY_OTHER_SCHEMA"] = reader.GetFieldValue<string>("PKTABLE_SCHEM");                                  row["FOREIGNKEY_OTHER_TABLE"] = reader.GetFieldValue<string>("PKTABLE_NAME");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ForeignKeyColumns")              {                  table.Columns.Add("FOREIGNKEYCOLUMN_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_TABLE"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_KEY"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_NAME"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_ORDINAL"' typeof(int));                  table.Columns.Add("FOREIGNKEYCOLUMN_OTHER_COLUMN_NAME"' typeof(string));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetImportedKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  string name = "[" + reader.GetFieldValue<string>("FKTABLE_SCHEM") + "]" +                                                  reader.GetFieldValue<string>("FKTABLE_NAME") + "." +                                                  reader.GetFieldValue<string>("FKCOLUMN_NAME") + "->" +                                                  "[" + reader.GetFieldValue<string>("PKTABLE_SCHEM") + "]" +                                                  reader.GetFieldValue<string>("PKTABLE_NAME") + "." +                                                  reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(name))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["FKTABLE_SCHEM"] + "." + reader["FKTABLE_NAME"] + "=" + reader["FKCOLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["FOREIGNKEYCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("FKTABLE_SCHEM");                                  row["FOREIGNKEYCOLUMN_TABLE"] = reader.GetFieldValue<string>("FKTABLE_NAME");                                  row["FOREIGNKEYCOLUMN_KEY"] = name;                                  row["FOREIGNKEYCOLUMN_NAME"] = reader.GetFieldValue<string>("FKCOLUMN_NAME");                                  row["FOREIGNKEYCOLUMN_ORDINAL"] = reader.GetFieldValue<int>("KEY_SEQ");                                  row["FOREIGNKEYCOLUMN_OTHER_COLUMN_NAME"] = reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "Procedures")               {                  table.Columns.Add("PROCEDURE_CATALOG"' typeof(string));                  table.Columns.Add("PROCEDURE_SCHEMA"' typeof(string));                  table.Columns.Add("PROCEDURE_NAME"' typeof(string));                  table.Columns.Add("IS_SYSTEM_PROCEDURE"' typeof(bool));                    if (tmConn.InternalConnection.protocolVersion >= Protocol.PROTOCOL_VERSION12)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetProcedures);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      for (int i = 1; i < 3; i++)                          if (restrictionValues != null && restrictionValues.Length > i)                              tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                          else                              tmConn.InternalConnection.dataStream.encodeNull();                        tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["PROCEDURE_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["PROCEDURE_SCHEMA"] = reader.GetFieldValue<string>("PROCEDURE_SCHEM");                                  row["PROCEDURE_NAME"] = reader.GetFieldValue<string>("PROCEDURE_NAME");                                  row["IS_SYSTEM_PROCEDURE"] = false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ProcedureParameters")              {                  table.Columns.Add("PROCEDURE_CATALOG"' typeof(string));                  table.Columns.Add("PROCEDURE_SCHEMA"' typeof(string));                  table.Columns.Add("PROCEDURE_NAME"' typeof(string));                  table.Columns.Add("PARAMETER_NAME"' typeof(string));                  table.Columns.Add("ORDINAL_POSITION"' typeof(int));                  table.Columns.Add("PARAMETER_DATA_TYPE"' typeof(int));                  table.Columns.Add("PARAMETER_TYPE_NAME"' typeof(string));                  table.Columns.Add("PARAMETER_SIZE"' typeof(int));                  table.Columns.Add("NUMERIC_PRECISION"' typeof(int));                  table.Columns.Add("NUMERIC_SCALE"' typeof(int));                  table.Columns.Add("PARAMETER_DIRECTION"' typeof(int));                  table.Columns.Add("IS_NULLABLE"' typeof(bool));                    if (tmConn.InternalConnection.protocolVersion >= Protocol.PROTOCOL_VERSION12)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetProcedureColumns);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      for (int i = 1; i < 4; i++)                          if (restrictionValues != null && restrictionValues.Length > i)                              tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                          else                              tmConn.InternalConnection.dataStream.encodeNull();                        tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["PROCEDURE_NAME"] + "' " + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["PROCEDURE_SCHEMA"] = reader.GetFieldValue<string>("PROCEDURE_SCHEM");                                  row["PROCEDURE_NAME"] = reader.GetFieldValue<string>("PROCEDURE_NAME");                                  row["PARAMETER_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["ORDINAL_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                                  row["PARAMETER_TYPE_NAME"] = reader.GetFieldValue<string>("TYPE_NAME");                                  row["PARAMETER_DATA_TYPE"] = reader.GetFieldValue<int>("DATA_TYPE");                                  row["PARAMETER_SIZE"] = reader.GetFieldValue<int>("LENGTH");                                  row["NUMERIC_PRECISION"] = reader.GetFieldValue<int>("PRECISION");                                  row["NUMERIC_SCALE"] = reader.GetFieldValue<int>("SCALE");                                  row["PARAMETER_DIRECTION"] = reader.GetFieldValue<int>("COLUMN_TYPE");                                  row["IS_NULLABLE"] = !reader.GetFieldValue<string>("IS_NULLABLE").Equals("NO");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The following statement contains a magic number: if (collectionName == DbMetaDataCollectionNames.DataSourceInformation)              {                  // see http://msdn.microsoft.com/en-us/library/ms254501.aspx                  table.Columns.Add("CompositeIdentifierSeparatorPattern"' typeof(string));                  table.Columns.Add("DataSourceProductName"' typeof(string));                  table.Columns.Add("DataSourceProductVersion"' typeof(string));                  table.Columns.Add("DataSourceProductVersionNormalized"' typeof(string));                  table.Columns.Add("DataSourceInternalProductVersion"' typeof(string));                  table.Columns.Add("GroupByBehavior"' typeof(GroupByBehavior));                  table.Columns.Add("IdentifierPattern"' typeof(string));                  table.Columns.Add("IdentifierCase"' typeof(IdentifierCase));                  table.Columns.Add("OrderByColumnsInSelect"' typeof(bool));                  table.Columns.Add("ParameterMarkerFormat"' typeof(string));                  table.Columns.Add("ParameterMarkerPattern"' typeof(string));                  table.Columns.Add("ParameterNameMaxLength"' typeof(int));                  table.Columns.Add("ParameterNamePattern"' typeof(string));                  table.Columns.Add("QuotedIdentifierPattern"' typeof(string));  // Regex                  table.Columns.Add("QuotedIdentifierCase"' typeof(int));                  table.Columns.Add("StatementSeparatorPattern"' typeof(string));                  table.Columns.Add("StringLiteralPattern"' typeof(string));  // Regex                  table.Columns.Add("SupportedJoinOperators"' typeof(SupportedJoinOperators));                    table.BeginLoadData();                  DataRow row = table.NewRow();                  int databaseMajorVersion = 0' databaseMinorVersion = 0;                  try                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetDatabaseMetaData);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      for (int item; (item = tmConn.InternalConnection.dataStream.getInt()) != Protocol.DbmbFini; )                      {                          switch (item)                          {                              case Protocol.DbmbProductName:                                  row["DataSourceProductName"] = tmConn.InternalConnection.dataStream.getString();                                  break;                                case Protocol.DbmbProductVersion:                                  row["DataSourceProductVersion"] = tmConn.InternalConnection.dataStream.getString();                                  break;                                case Protocol.DbmbDatabaseMinorVersion:                                  databaseMinorVersion = tmConn.InternalConnection.dataStream.getInt();                                  break;                                case Protocol.DbmbDatabaseMajorVersion:                                  databaseMajorVersion = tmConn.InternalConnection.dataStream.getInt();                                  break;                                case Protocol.DbmbDefaultTransactionIsolation:                                  int defaultTransactionIsolation = tmConn.InternalConnection.dataStream.getInt();                                  break;                                default:                                  tmConn.InternalConnection.dataStream.decode();                                  break;                          }                      }                  }                  catch (Exception)                  {                  }                    row["DataSourceInternalProductVersion"] = String.Format("{0:D3}.{1:D3}"' databaseMajorVersion' databaseMinorVersion);                  // The regular expression to match the composite separators in a composite identifier.                   // For example' "\." (for SQL Server) or "@|\." (for Oracle).                  // A composite identifier is typically what is used for a database object name'                   // for example: pubs.dbo.authors or pubs@dbo.authors.                  row["CompositeIdentifierSeparatorPattern"] = "\\.";                  // A normalized version for the data source' such that it can be compared with String.Compare().                   // The format of this is consistent for all versions of the provider to prevent version 10 from sorting between version 1 and version 2.                  //row["DataSourceProductVersionNormalized"] = ??                  // Specifies the relationship between the columns in a GROUP BY clause and the non-aggregated columns in the select list.                  row["GroupByBehavior"] = GroupByBehavior.Unknown;                  // A regular expression that matches an identifier and has a match value of the identifier. For example "[A-Za-z0-9_#$]".                  row["IdentifierPattern"] = "(^\\[\\p{Lo}\\p{Lu}\\p{Ll}_@#][\\p{Lo}\\p{Lu}\\p{Ll}\\p{Nd}@$#_]*$)|(^\"[^\"\\0]|\"\"+\"$)";                  // Indicates whether non-quoted identifiers are treated as case sensitive or not.                  row["IdentifierCase"] = IdentifierCase.Insensitive;                  // Specifies whether columns in an ORDER BY clause must be in the select list.                   // A value of true indicates that they are required to be in the select list'                   // a value of false indicates that they are not required to be in the select list.                  row["OrderByColumnsInSelect"] = false;                  // For data sources that do not expect named parameters and expect the use of the ‘?’ character' the format string                  // can be specified as simply '?'' which would ignore the parameter name.                  row["ParameterMarkerFormat"] = "?";                  // if the data source doesn't support named parameters' this would simply be "?".                  row["ParameterMarkerPattern"] = "?";                  // If the data source does not support named parameters' this property returns zero.                  row["ParameterNameMaxLength"] = 0;                  // A regular expression that matches the valid parameter names                  row["ParameterNamePattern"] = "";                  // A regular expression that matches a quoted identifier and has a match value of the identifier itself without the quotes.                   // For example' if the data source used double-quotes to identify quoted identifiers' this would be: "(([^\"]|\"\")*)".                  row["QuotedIdentifierPattern"] = "\"([^\"]*)\"";                  // Indicates whether quoted identifiers are treated as case sensitive or not.                  row["QuotedIdentifierCase"] = IdentifierCase.Sensitive;                  // A regular expression that matches the statement separator.                  row["StatementSeparatorPattern"] = ";";                  // A regular expression that matches a string literal and has a match value of the literal itself.                   // For example' if the data source used single-quotes to identify strings' this would be: "('([^']|'')*')"'                  row["StringLiteralPattern"] = "'([^']*)'";                  // Specifies what types of SQL join statements are supported by the data source.                  row["SupportedJoinOperators"] = SupportedJoinOperators.None;                  table.Rows.Add(row);                  table.EndLoadData();              }              else if (collectionName == DbMetaDataCollectionNames.ReservedWords)              {                  table.Columns.Add("ReservedWord"' typeof(string));                  table.Columns.Add("MaximumVersion"' typeof(string));                  table.Columns.Add("MinimumVersion"' typeof(string));                    string[] words = { "select"' "Add field"' "Drop field"' "Alter table"' "Alter field"'                                      "Alter user"' "And"' "Or"' "Not"' "Create Index"' "Upgrade"' "Unique"'                                      "Table key"' "Table unique key"' "Primary Key"' "Create Table"'                                      "Upgrade Table"' "Rename Table"' "Create View"' "Upgrade View"'                                      "Drop View"' "Create Schema"' "Drop Schema"' "Integer"' "Smallint"'                                      "Bigint"' "Tinyint"' "float"' "double"' "Blob"' "bytes"' "boolean"'                                      "binary"' "varbinary"' "string"' "char"' "text"' "date"' "timestamp"'                                      "time"' "varchar"' "numeric"' "Decimal Number"' "Enum"' "Delete"' "Repair"'                                      "Field"' "Not Null"' "Default Value"' "searchable"' "not searchable"'                                      "collation"' "character_set"' "Foreign Key"' "Identifier"' "record number"'                                      "Insert"' "Replace"' "Name"' "Number"' "Order"' "Descending"' "limit"'                                      "Quoted String"' "Select Clause"' "Distinct"' "Gtr"' "Geq"' "Eql"'                                      "Leq"' "Lss"' "Neq"' "in list"' "in select"' "exists"' "Between"' "Like"'                                      "starts with"' "Containing"' "Matching"' "Regular expression"' "Null"'                                      "True"' "False"' "Execute"' "Parameter"' "Count"' "sum"' "min"' "max"'                                      "avg"' "Drop Index"' "Drop primary key"' "Drop foreign key"' "Drop Table"'                                      "If Exists"' "Describe"' "Statement"' "for_select"' "for_insert"' "while"'                                      "if then else"' "variable"' "declaration"' "throw"' "assignment"'                                      "Start transaction"' "read only"' "read write"' "read committed"' "write committed"'                                      "read uncommitted"' "repeatableread"' "serializable"' "Commit"' "Rollback"'                                      "Savepoint"' "Rollack Savepoint"' "Release Savepoint"' "Table"' "Derived Table"'                                      "Assign"' "Update"' "list"' "Constant"' "Function"' "Grant"' "Grant role"' "Alter"'                                      "Read"' "Identity"' "Check"' "Constraint"' "value constraint"' "auto increment"'                                      "generated"' "always"' "Domain"' "is null"' "is active_role"' "start with"' "reindex"'                                      "cursor"' "alias"' "push_namespace"' "pop_namespace"' "set_namespace"' "coalesce"'                                      "nod_nullif"' "case"' "case_search"' "add"' "subtract"' "multiply"' "divide"' "modulus"'                                      "negate"' "plus"' "cast"' "concatenation"' "create user"' "drop user"' "create role"'                                      "upgrade role"' "drop role"' "revoke"' "revoke role"' "assume"' "revert"' "negate"'                                      "priv insert"' "priv delete"' "priv execute"' "priv select"' "priv update"' "priv grant"'                                      "priv all"' "characters"' "octets"' "role"' "view"' "procedure"' "user"' "zone"' "admin"'                                      "default role"' "create sequence"' "upgrade sequence"' "drop sequence"' "next value"'                                      "create trigger"' "upgrade trigger"' "alter trigger"' "drop trigger"' "create procedure"'                                      "upgrade procedure"' "alter procedure"' "drop procedure"' "pre-insert"' "post-insert"'                                      "pre-update"' "post-update"' "pre-delete"' "post-delete"' "pre-commit"' "post-commit"'                                      "active"' "inactive"' "position"' "select-expr"' "create filterset"' "upgrade filterset"'                                      "drop filterset"' "enable filterset"' "disable filterset"' "table filter"' "left outer"'                                      "right outer"' "full outer"' "inner"' "join"' "join_term"' "trigger class"' "enable trigger class"'                                      "disable trigger class"' "create zone"' "upgrade zone"' "drop zone"' "range"' "ip address"'                                      "node_name"' "wildcard"' "create domain"' "upgrade domain"' "alter domain"' "upgrade schema"'                                      "delete cascade"' "index segment"' "for update"' "write committed"' "read committed"'                                       "consistent read"' "set dialect"' "set names"' "restrict"' "cascade"' "characters"' "octets"'                                      "create event"' "collate"' "truncate"' "restart"' "nameless constraint"' "drop constraint"'                                      "drop unique constraint"' "drop domain"' "with check option"' "not real"' "lower"' "upper"'                                      "substr"' "substring index"' "charlength"' "default keyword"' "sqrt"' "power"' "Scientific Notation Number"'                                      "Explain"' "msleep"' "KillStatement"' "now" };                  table.BeginLoadData();                  foreach (string keyword in words)                  {                      DataRow row = table.NewRow();                      row["ReservedWord"] = keyword;                      table.Rows.Add(row);                  }                  table.EndLoadData();                }              else if (collectionName == DbMetaDataCollectionNames.DataTypes)              {                  table.Columns.Add("TypeName"' typeof(string));  // The provider-specific data type name.                  table.Columns.Add("ProviderDbType"' typeof(int)); // The provider-specific type value that should be used when specifying                   //a parameter's type. For example' SqlDbType.Money or OracleType.Blob.                  table.Columns.Add("ColumnSize"' typeof(long));                  table.Columns.Add("CreateFormat"' typeof(string));                  table.Columns.Add("CreateParameters"' typeof(string));                  table.Columns.Add("DataType"' typeof(string));  // The name of the .NET Framework type of the data type.                  table.Columns.Add("IsAutoincrementable"' typeof(bool));                  table.Columns.Add("IsBestMatch"' typeof(bool));                  table.Columns.Add("IsCaseSensitive"' typeof(bool));                  table.Columns.Add("IsFixedLength"' typeof(bool));                  table.Columns.Add("IsFixedPrecisionScale"' typeof(bool));                  table.Columns.Add("IsLong"' typeof(bool));                  table.Columns.Add("IsNullable"' typeof(bool));                  table.Columns.Add("IsSearchable"' typeof(bool));                  table.Columns.Add("IsSearchableWithLike"' typeof(bool));                  table.Columns.Add("IsUnsigned"' typeof(bool));                  table.Columns.Add("MaximumScale"' typeof(short));                  table.Columns.Add("MinimumScale"' typeof(short));                  table.Columns.Add("IsConcurrencyType"' typeof(bool));                  table.Columns.Add("IsLiteralsSupported"' typeof(bool));                  table.Columns.Add("LiteralPrefix"' typeof(string));                  table.Columns.Add("LiteralSuffix"' typeof(string));                  table.Columns.Add("NativeDataType"' typeof(string));    // NativeDataType is an OLE DB specific column for exposing the OLE DB type of the data type .                    table.ReadXml(XmlReader.Create(typeof(NuoDbConnectionInternal).Assembly.GetManifestResourceStream("NuoDb.Data.Client.DataTypes.xml")));              }              else if (collectionName == "Tables")              {                  table.Columns.Add("TABLE_CATALOG"' typeof(string));                  table.Columns.Add("TABLE_SCHEMA"' typeof(string));                  table.Columns.Add("TABLE_NAME"' typeof(string));                  table.Columns.Add("TABLE_TYPE"' typeof(string));                  table.Columns.Add("REMARKS"' typeof(string));                  table.Columns.Add("VIEW_DEF"' typeof(string));                    tmConn.InternalConnection.dataStream.startMessage(Protocol.GetTables);                  tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                  for (int i = 1; i < 3; i++)                      if (restrictionValues != null && restrictionValues.Length > i)                          tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                      else                          tmConn.InternalConnection.dataStream.encodeNull();                  if (restrictionValues == null || restrictionValues.Length < 4 || restrictionValues[3] == null)                      tmConn.InternalConnection.dataStream.encodeInt(0);                  else                  {                      tmConn.InternalConnection.dataStream.encodeInt(1);                      tmConn.InternalConnection.dataStream.encodeString(restrictionValues[3]);                  }                    tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                  int handle = tmConn.InternalConnection.dataStream.getInt();                    if (handle != -1)                  {                      using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                      {                          table.BeginLoadData();                          string view_def_label="";                          try                           {                               reader.GetOrdinal("VIEW_DEF");                              view_def_label = "VIEW_DEF";                          }                          catch(Exception) {}                          try                           {                               reader.GetOrdinal("VIEWDEFINITION");                              view_def_label = "VIEWDEFINITION";                          }                          catch (Exception) { }                          while (reader.Read())                          {  #if DEBUG                          System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_NAME"] + "' " + reader["TABLE_TYPE"]);  #endif                              DataRow row = table.NewRow();                              row["TABLE_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                              row["TABLE_NAME"] = reader.GetFieldValue<string>("TABLE_NAME");                              row["TABLE_TYPE"] = reader.GetFieldValue<string>("TABLE_TYPE");                              row["REMARKS"] = reader.GetFieldValue<string>("REMARKS");                              if (view_def_label.Length != 0)                              {                                  row["VIEW_DEF"] = reader.GetFieldValue<string>(view_def_label);                              }                              table.Rows.Add(row);                          }                          table.EndLoadData();                      }                  }              }              else if (collectionName == "Columns")              {                  table.Columns.Add("COLUMN_CATALOG"' typeof(string));                  table.Columns.Add("COLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("COLUMN_TABLE"' typeof(string));                  table.Columns.Add("COLUMN_NAME"' typeof(string));                  table.Columns.Add("COLUMN_POSITION"' typeof(int));                  table.Columns.Add("COLUMN_TYPE"' typeof(string));                  table.Columns.Add("COLUMN_LENGTH"' typeof(int));                  table.Columns.Add("COLUMN_PRECISION"' typeof(int));                  table.Columns.Add("COLUMN_NULLABLE"' typeof(bool));                  table.Columns.Add("COLUMN_IDENTITY"' typeof(bool));                  table.Columns.Add("COLUMN_DEFAULT"' typeof(string));                  table.Columns.Add("COLUMN_SCALE"' typeof(int));                    tmConn.InternalConnection.dataStream.startMessage(Protocol.GetColumns);                  tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                  for (int i = 1; i < 4; i++)                      if (restrictionValues != null && restrictionValues.Length > i)                          tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                      else                          tmConn.InternalConnection.dataStream.encodeNull();                    tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                  int handle = tmConn.InternalConnection.dataStream.getInt();                    if (handle != -1)                  {                      using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                      {                          table.BeginLoadData();                          while (reader.Read())                          {                              DataRow row = table.NewRow();                              row["COLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                              row["COLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                              row["COLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                              row["COLUMN_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                              row["COLUMN_LENGTH"] = reader.GetFieldValue<int>("COLUMN_SIZE");                              row["COLUMN_PRECISION"] = reader.GetFieldValue<int>("BUFFER_LENGTH");                              row["COLUMN_SCALE"] = reader.GetFieldValue<int>("DECIMAL_DIGITS");                              if (isNumeric(reader.GetFieldValue<string>("TYPE_NAME")))                              {                                  if (reader.GetFieldValue<int>("DECIMAL_DIGITS") != 0)                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME") +                                           "(" + reader.GetFieldValue<int>("BUFFER_LENGTH") + "'" + reader.GetFieldValue<int>("DECIMAL_DIGITS") + ")";                                  else                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME");                              }                              else                              {                                  if (isVarLenType(reader.GetFieldValue<string>("TYPE_NAME")) && reader.GetFieldValue<int>("COLUMN_SIZE") != 0)                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME") +                                           "(" + reader.GetFieldValue<int>("COLUMN_SIZE") + ")";                                  else                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME");                              }                              if (!reader.IsDBNull(reader.GetOrdinal("IS_NULLABLE")))                                  row["COLUMN_NULLABLE"] = reader.GetFieldValue<string>("IS_NULLABLE").Equals("YES");                              if (!reader.IsDBNull(reader.GetOrdinal("IS_AUTOINCREMENT")))                                  row["COLUMN_IDENTITY"] = reader.GetFieldValue<string>("IS_AUTOINCREMENT").Equals("YES");                              row["COLUMN_DEFAULT"] = reader.GetFieldValue<string>("COLUMN_DEF");    #if DEBUG                              System.Diagnostics.Trace.WriteLine("-> " + row["COLUMN_NAME"] + " " + row["COLUMN_TYPE"]);  #endif                              table.Rows.Add(row);                          }                          table.EndLoadData();                      }                  }              }              else if (collectionName == "Indexes")              {                  table.Columns.Add("INDEX_CATALOG"' typeof(string));                  table.Columns.Add("INDEX_SCHEMA"' typeof(string));                  table.Columns.Add("INDEX_TABLE"' typeof(string));                  table.Columns.Add("INDEX_NAME"' typeof(string));                  table.Columns.Add("INDEX_TYPE"' typeof(string));                  table.Columns.Add("INDEX_UNIQUE"' typeof(bool));                  table.Columns.Add("INDEX_PRIMARY"' typeof(bool));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetIndexInfo);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // unique                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // approximate                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        // to avoid to insert the same index more than once                      HashSet<string> unique = new HashSet<string>();                      if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;                                  if (!unique.Add(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;                                  DataRow row = table.NewRow();                                  row["INDEX_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEX_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEX_NAME"] = reader.GetFieldValue<string>("INDEX_NAME");                                  switch (reader.GetFieldValue<int>("TYPE"))                                  {                                      case 0:                                          row["INDEX_TYPE"] = "Primary";                                          break;                                      case 1:                                          row["INDEX_TYPE"] = "Unique";                                          break;                                      case 2:                                          row["INDEX_TYPE"] = "Secondary";                                          break;                                      case 3:                                          row["INDEX_TYPE"] = "Foreign Key";                                          break;                                  }                                  row["INDEX_UNIQUE"] = (reader.GetFieldValue<int>("NON_UNIQUE") == 0) ? true : false;                                  row["INDEX_PRIMARY"] = (reader.GetFieldValue<int>("TYPE") == 0) ? true : false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                        tmConn.InternalConnection.dataStream.startMessage(Protocol.GetPrimaryKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              // use INDEX_NAME' if present; if missing' the name of the index is in PK_NAME                              string indexName = "PK_NAME";                              foreach (string column in reader.columnNames)                              {                                  if (column == "INDEX_NAME")                                  {                                      indexName = "INDEX_NAME";                                      break;                                  }                              }                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>(indexName)))                                      continue;                                  if (!unique.Add(reader.GetFieldValue<string>(indexName)))                                      continue;                                  DataRow row = table.NewRow();                                  row["INDEX_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEX_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEX_NAME"] = reader.GetFieldValue<string>(indexName);                                  row["INDEX_TYPE"] = "Primary";                                  row["INDEX_UNIQUE"] = true;                                  row["INDEX_PRIMARY"] = true;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "IndexColumns")              {                  table.Columns.Add("INDEXCOLUMN_CATALOG"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_TABLE"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_INDEX"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_NAME"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_POSITION"' typeof(int));                  table.Columns.Add("INDEXCOLUMN_ISPRIMARY"' typeof(bool));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetIndexInfo);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // unique                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // approximate                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_SCHEM"] + "." + reader["TABLE_NAME"] + "=" + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["INDEXCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEXCOLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEXCOLUMN_INDEX"] = reader.GetFieldValue<string>("INDEX_NAME");                                  row["INDEXCOLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["INDEXCOLUMN_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                                  row["INDEXCOLUMN_ISPRIMARY"] = false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                        tmConn.InternalConnection.dataStream.startMessage(Protocol.GetPrimaryKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              // use INDEX_NAME' if present; if missing' the name of the index is in PK_NAME                              string indexName = "PK_NAME";                              foreach (string column in reader.columnNames)                              {                                  if (column == "INDEX_NAME")                                  {                                      indexName = "INDEX_NAME";                                      break;                                  }                              }                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>(indexName)))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_SCHEM"] + "." + reader["TABLE_NAME"] + " (Primary) =" + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["INDEXCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEXCOLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEXCOLUMN_INDEX"] = reader.GetFieldValue<string>(indexName);                                  row["INDEXCOLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["INDEXCOLUMN_POSITION"] = reader.GetFieldValue<int>("KEY_SEQ");                                  row["INDEXCOLUMN_ISPRIMARY"] = true;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ForeignKeys")              {                  table.Columns.Add("FOREIGNKEY_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEY_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEY_TABLE"' typeof(string));                  table.Columns.Add("FOREIGNKEY_NAME"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_TABLE"' typeof(string));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetImportedKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  string name = "[" + reader.GetFieldValue<string>("FKTABLE_SCHEM") + "]" +                                                   reader.GetFieldValue<string>("FKTABLE_NAME") + "." +                                                   reader.GetFieldValue<string>("FKCOLUMN_NAME") + "->" +                                                  "[" + reader.GetFieldValue<string>("PKTABLE_SCHEM") + "]" +                                                   reader.GetFieldValue<string>("PKTABLE_NAME") + "." +                                                   reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(name))                                      continue;                                  DataRow row = table.NewRow();                                  row["FOREIGNKEY_SCHEMA"] = reader.GetFieldValue<string>("FKTABLE_SCHEM");                                  row["FOREIGNKEY_TABLE"] = reader.GetFieldValue<string>("FKTABLE_NAME");                                  row["FOREIGNKEY_NAME"] = name;                                  row["FOREIGNKEY_OTHER_SCHEMA"] = reader.GetFieldValue<string>("PKTABLE_SCHEM");                                  row["FOREIGNKEY_OTHER_TABLE"] = reader.GetFieldValue<string>("PKTABLE_NAME");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ForeignKeyColumns")              {                  table.Columns.Add("FOREIGNKEYCOLUMN_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_TABLE"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_KEY"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_NAME"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_ORDINAL"' typeof(int));                  table.Columns.Add("FOREIGNKEYCOLUMN_OTHER_COLUMN_NAME"' typeof(string));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetImportedKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  string name = "[" + reader.GetFieldValue<string>("FKTABLE_SCHEM") + "]" +                                                  reader.GetFieldValue<string>("FKTABLE_NAME") + "." +                                                  reader.GetFieldValue<string>("FKCOLUMN_NAME") + "->" +                                                  "[" + reader.GetFieldValue<string>("PKTABLE_SCHEM") + "]" +                                                  reader.GetFieldValue<string>("PKTABLE_NAME") + "." +                                                  reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(name))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["FKTABLE_SCHEM"] + "." + reader["FKTABLE_NAME"] + "=" + reader["FKCOLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["FOREIGNKEYCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("FKTABLE_SCHEM");                                  row["FOREIGNKEYCOLUMN_TABLE"] = reader.GetFieldValue<string>("FKTABLE_NAME");                                  row["FOREIGNKEYCOLUMN_KEY"] = name;                                  row["FOREIGNKEYCOLUMN_NAME"] = reader.GetFieldValue<string>("FKCOLUMN_NAME");                                  row["FOREIGNKEYCOLUMN_ORDINAL"] = reader.GetFieldValue<int>("KEY_SEQ");                                  row["FOREIGNKEYCOLUMN_OTHER_COLUMN_NAME"] = reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "Procedures")               {                  table.Columns.Add("PROCEDURE_CATALOG"' typeof(string));                  table.Columns.Add("PROCEDURE_SCHEMA"' typeof(string));                  table.Columns.Add("PROCEDURE_NAME"' typeof(string));                  table.Columns.Add("IS_SYSTEM_PROCEDURE"' typeof(bool));                    if (tmConn.InternalConnection.protocolVersion >= Protocol.PROTOCOL_VERSION12)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetProcedures);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      for (int i = 1; i < 3; i++)                          if (restrictionValues != null && restrictionValues.Length > i)                              tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                          else                              tmConn.InternalConnection.dataStream.encodeNull();                        tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["PROCEDURE_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["PROCEDURE_SCHEMA"] = reader.GetFieldValue<string>("PROCEDURE_SCHEM");                                  row["PROCEDURE_NAME"] = reader.GetFieldValue<string>("PROCEDURE_NAME");                                  row["IS_SYSTEM_PROCEDURE"] = false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ProcedureParameters")              {                  table.Columns.Add("PROCEDURE_CATALOG"' typeof(string));                  table.Columns.Add("PROCEDURE_SCHEMA"' typeof(string));                  table.Columns.Add("PROCEDURE_NAME"' typeof(string));                  table.Columns.Add("PARAMETER_NAME"' typeof(string));                  table.Columns.Add("ORDINAL_POSITION"' typeof(int));                  table.Columns.Add("PARAMETER_DATA_TYPE"' typeof(int));                  table.Columns.Add("PARAMETER_TYPE_NAME"' typeof(string));                  table.Columns.Add("PARAMETER_SIZE"' typeof(int));                  table.Columns.Add("NUMERIC_PRECISION"' typeof(int));                  table.Columns.Add("NUMERIC_SCALE"' typeof(int));                  table.Columns.Add("PARAMETER_DIRECTION"' typeof(int));                  table.Columns.Add("IS_NULLABLE"' typeof(bool));                    if (tmConn.InternalConnection.protocolVersion >= Protocol.PROTOCOL_VERSION12)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetProcedureColumns);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      for (int i = 1; i < 4; i++)                          if (restrictionValues != null && restrictionValues.Length > i)                              tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                          else                              tmConn.InternalConnection.dataStream.encodeNull();                        tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["PROCEDURE_NAME"] + "' " + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["PROCEDURE_SCHEMA"] = reader.GetFieldValue<string>("PROCEDURE_SCHEM");                                  row["PROCEDURE_NAME"] = reader.GetFieldValue<string>("PROCEDURE_NAME");                                  row["PARAMETER_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["ORDINAL_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                                  row["PARAMETER_TYPE_NAME"] = reader.GetFieldValue<string>("TYPE_NAME");                                  row["PARAMETER_DATA_TYPE"] = reader.GetFieldValue<int>("DATA_TYPE");                                  row["PARAMETER_SIZE"] = reader.GetFieldValue<int>("LENGTH");                                  row["NUMERIC_PRECISION"] = reader.GetFieldValue<int>("PRECISION");                                  row["NUMERIC_SCALE"] = reader.GetFieldValue<int>("SCALE");                                  row["PARAMETER_DIRECTION"] = reader.GetFieldValue<int>("COLUMN_TYPE");                                  row["IS_NULLABLE"] = !reader.GetFieldValue<string>("IS_NULLABLE").Equals("NO");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The following statement contains a magic number: if (collectionName == DbMetaDataCollectionNames.DataSourceInformation)              {                  // see http://msdn.microsoft.com/en-us/library/ms254501.aspx                  table.Columns.Add("CompositeIdentifierSeparatorPattern"' typeof(string));                  table.Columns.Add("DataSourceProductName"' typeof(string));                  table.Columns.Add("DataSourceProductVersion"' typeof(string));                  table.Columns.Add("DataSourceProductVersionNormalized"' typeof(string));                  table.Columns.Add("DataSourceInternalProductVersion"' typeof(string));                  table.Columns.Add("GroupByBehavior"' typeof(GroupByBehavior));                  table.Columns.Add("IdentifierPattern"' typeof(string));                  table.Columns.Add("IdentifierCase"' typeof(IdentifierCase));                  table.Columns.Add("OrderByColumnsInSelect"' typeof(bool));                  table.Columns.Add("ParameterMarkerFormat"' typeof(string));                  table.Columns.Add("ParameterMarkerPattern"' typeof(string));                  table.Columns.Add("ParameterNameMaxLength"' typeof(int));                  table.Columns.Add("ParameterNamePattern"' typeof(string));                  table.Columns.Add("QuotedIdentifierPattern"' typeof(string));  // Regex                  table.Columns.Add("QuotedIdentifierCase"' typeof(int));                  table.Columns.Add("StatementSeparatorPattern"' typeof(string));                  table.Columns.Add("StringLiteralPattern"' typeof(string));  // Regex                  table.Columns.Add("SupportedJoinOperators"' typeof(SupportedJoinOperators));                    table.BeginLoadData();                  DataRow row = table.NewRow();                  int databaseMajorVersion = 0' databaseMinorVersion = 0;                  try                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetDatabaseMetaData);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      for (int item; (item = tmConn.InternalConnection.dataStream.getInt()) != Protocol.DbmbFini; )                      {                          switch (item)                          {                              case Protocol.DbmbProductName:                                  row["DataSourceProductName"] = tmConn.InternalConnection.dataStream.getString();                                  break;                                case Protocol.DbmbProductVersion:                                  row["DataSourceProductVersion"] = tmConn.InternalConnection.dataStream.getString();                                  break;                                case Protocol.DbmbDatabaseMinorVersion:                                  databaseMinorVersion = tmConn.InternalConnection.dataStream.getInt();                                  break;                                case Protocol.DbmbDatabaseMajorVersion:                                  databaseMajorVersion = tmConn.InternalConnection.dataStream.getInt();                                  break;                                case Protocol.DbmbDefaultTransactionIsolation:                                  int defaultTransactionIsolation = tmConn.InternalConnection.dataStream.getInt();                                  break;                                default:                                  tmConn.InternalConnection.dataStream.decode();                                  break;                          }                      }                  }                  catch (Exception)                  {                  }                    row["DataSourceInternalProductVersion"] = String.Format("{0:D3}.{1:D3}"' databaseMajorVersion' databaseMinorVersion);                  // The regular expression to match the composite separators in a composite identifier.                   // For example' "\." (for SQL Server) or "@|\." (for Oracle).                  // A composite identifier is typically what is used for a database object name'                   // for example: pubs.dbo.authors or pubs@dbo.authors.                  row["CompositeIdentifierSeparatorPattern"] = "\\.";                  // A normalized version for the data source' such that it can be compared with String.Compare().                   // The format of this is consistent for all versions of the provider to prevent version 10 from sorting between version 1 and version 2.                  //row["DataSourceProductVersionNormalized"] = ??                  // Specifies the relationship between the columns in a GROUP BY clause and the non-aggregated columns in the select list.                  row["GroupByBehavior"] = GroupByBehavior.Unknown;                  // A regular expression that matches an identifier and has a match value of the identifier. For example "[A-Za-z0-9_#$]".                  row["IdentifierPattern"] = "(^\\[\\p{Lo}\\p{Lu}\\p{Ll}_@#][\\p{Lo}\\p{Lu}\\p{Ll}\\p{Nd}@$#_]*$)|(^\"[^\"\\0]|\"\"+\"$)";                  // Indicates whether non-quoted identifiers are treated as case sensitive or not.                  row["IdentifierCase"] = IdentifierCase.Insensitive;                  // Specifies whether columns in an ORDER BY clause must be in the select list.                   // A value of true indicates that they are required to be in the select list'                   // a value of false indicates that they are not required to be in the select list.                  row["OrderByColumnsInSelect"] = false;                  // For data sources that do not expect named parameters and expect the use of the ‘?’ character' the format string                  // can be specified as simply '?'' which would ignore the parameter name.                  row["ParameterMarkerFormat"] = "?";                  // if the data source doesn't support named parameters' this would simply be "?".                  row["ParameterMarkerPattern"] = "?";                  // If the data source does not support named parameters' this property returns zero.                  row["ParameterNameMaxLength"] = 0;                  // A regular expression that matches the valid parameter names                  row["ParameterNamePattern"] = "";                  // A regular expression that matches a quoted identifier and has a match value of the identifier itself without the quotes.                   // For example' if the data source used double-quotes to identify quoted identifiers' this would be: "(([^\"]|\"\")*)".                  row["QuotedIdentifierPattern"] = "\"([^\"]*)\"";                  // Indicates whether quoted identifiers are treated as case sensitive or not.                  row["QuotedIdentifierCase"] = IdentifierCase.Sensitive;                  // A regular expression that matches the statement separator.                  row["StatementSeparatorPattern"] = ";";                  // A regular expression that matches a string literal and has a match value of the literal itself.                   // For example' if the data source used single-quotes to identify strings' this would be: "('([^']|'')*')"'                  row["StringLiteralPattern"] = "'([^']*)'";                  // Specifies what types of SQL join statements are supported by the data source.                  row["SupportedJoinOperators"] = SupportedJoinOperators.None;                  table.Rows.Add(row);                  table.EndLoadData();              }              else if (collectionName == DbMetaDataCollectionNames.ReservedWords)              {                  table.Columns.Add("ReservedWord"' typeof(string));                  table.Columns.Add("MaximumVersion"' typeof(string));                  table.Columns.Add("MinimumVersion"' typeof(string));                    string[] words = { "select"' "Add field"' "Drop field"' "Alter table"' "Alter field"'                                      "Alter user"' "And"' "Or"' "Not"' "Create Index"' "Upgrade"' "Unique"'                                      "Table key"' "Table unique key"' "Primary Key"' "Create Table"'                                      "Upgrade Table"' "Rename Table"' "Create View"' "Upgrade View"'                                      "Drop View"' "Create Schema"' "Drop Schema"' "Integer"' "Smallint"'                                      "Bigint"' "Tinyint"' "float"' "double"' "Blob"' "bytes"' "boolean"'                                      "binary"' "varbinary"' "string"' "char"' "text"' "date"' "timestamp"'                                      "time"' "varchar"' "numeric"' "Decimal Number"' "Enum"' "Delete"' "Repair"'                                      "Field"' "Not Null"' "Default Value"' "searchable"' "not searchable"'                                      "collation"' "character_set"' "Foreign Key"' "Identifier"' "record number"'                                      "Insert"' "Replace"' "Name"' "Number"' "Order"' "Descending"' "limit"'                                      "Quoted String"' "Select Clause"' "Distinct"' "Gtr"' "Geq"' "Eql"'                                      "Leq"' "Lss"' "Neq"' "in list"' "in select"' "exists"' "Between"' "Like"'                                      "starts with"' "Containing"' "Matching"' "Regular expression"' "Null"'                                      "True"' "False"' "Execute"' "Parameter"' "Count"' "sum"' "min"' "max"'                                      "avg"' "Drop Index"' "Drop primary key"' "Drop foreign key"' "Drop Table"'                                      "If Exists"' "Describe"' "Statement"' "for_select"' "for_insert"' "while"'                                      "if then else"' "variable"' "declaration"' "throw"' "assignment"'                                      "Start transaction"' "read only"' "read write"' "read committed"' "write committed"'                                      "read uncommitted"' "repeatableread"' "serializable"' "Commit"' "Rollback"'                                      "Savepoint"' "Rollack Savepoint"' "Release Savepoint"' "Table"' "Derived Table"'                                      "Assign"' "Update"' "list"' "Constant"' "Function"' "Grant"' "Grant role"' "Alter"'                                      "Read"' "Identity"' "Check"' "Constraint"' "value constraint"' "auto increment"'                                      "generated"' "always"' "Domain"' "is null"' "is active_role"' "start with"' "reindex"'                                      "cursor"' "alias"' "push_namespace"' "pop_namespace"' "set_namespace"' "coalesce"'                                      "nod_nullif"' "case"' "case_search"' "add"' "subtract"' "multiply"' "divide"' "modulus"'                                      "negate"' "plus"' "cast"' "concatenation"' "create user"' "drop user"' "create role"'                                      "upgrade role"' "drop role"' "revoke"' "revoke role"' "assume"' "revert"' "negate"'                                      "priv insert"' "priv delete"' "priv execute"' "priv select"' "priv update"' "priv grant"'                                      "priv all"' "characters"' "octets"' "role"' "view"' "procedure"' "user"' "zone"' "admin"'                                      "default role"' "create sequence"' "upgrade sequence"' "drop sequence"' "next value"'                                      "create trigger"' "upgrade trigger"' "alter trigger"' "drop trigger"' "create procedure"'                                      "upgrade procedure"' "alter procedure"' "drop procedure"' "pre-insert"' "post-insert"'                                      "pre-update"' "post-update"' "pre-delete"' "post-delete"' "pre-commit"' "post-commit"'                                      "active"' "inactive"' "position"' "select-expr"' "create filterset"' "upgrade filterset"'                                      "drop filterset"' "enable filterset"' "disable filterset"' "table filter"' "left outer"'                                      "right outer"' "full outer"' "inner"' "join"' "join_term"' "trigger class"' "enable trigger class"'                                      "disable trigger class"' "create zone"' "upgrade zone"' "drop zone"' "range"' "ip address"'                                      "node_name"' "wildcard"' "create domain"' "upgrade domain"' "alter domain"' "upgrade schema"'                                      "delete cascade"' "index segment"' "for update"' "write committed"' "read committed"'                                       "consistent read"' "set dialect"' "set names"' "restrict"' "cascade"' "characters"' "octets"'                                      "create event"' "collate"' "truncate"' "restart"' "nameless constraint"' "drop constraint"'                                      "drop unique constraint"' "drop domain"' "with check option"' "not real"' "lower"' "upper"'                                      "substr"' "substring index"' "charlength"' "default keyword"' "sqrt"' "power"' "Scientific Notation Number"'                                      "Explain"' "msleep"' "KillStatement"' "now" };                  table.BeginLoadData();                  foreach (string keyword in words)                  {                      DataRow row = table.NewRow();                      row["ReservedWord"] = keyword;                      table.Rows.Add(row);                  }                  table.EndLoadData();                }              else if (collectionName == DbMetaDataCollectionNames.DataTypes)              {                  table.Columns.Add("TypeName"' typeof(string));  // The provider-specific data type name.                  table.Columns.Add("ProviderDbType"' typeof(int)); // The provider-specific type value that should be used when specifying                   //a parameter's type. For example' SqlDbType.Money or OracleType.Blob.                  table.Columns.Add("ColumnSize"' typeof(long));                  table.Columns.Add("CreateFormat"' typeof(string));                  table.Columns.Add("CreateParameters"' typeof(string));                  table.Columns.Add("DataType"' typeof(string));  // The name of the .NET Framework type of the data type.                  table.Columns.Add("IsAutoincrementable"' typeof(bool));                  table.Columns.Add("IsBestMatch"' typeof(bool));                  table.Columns.Add("IsCaseSensitive"' typeof(bool));                  table.Columns.Add("IsFixedLength"' typeof(bool));                  table.Columns.Add("IsFixedPrecisionScale"' typeof(bool));                  table.Columns.Add("IsLong"' typeof(bool));                  table.Columns.Add("IsNullable"' typeof(bool));                  table.Columns.Add("IsSearchable"' typeof(bool));                  table.Columns.Add("IsSearchableWithLike"' typeof(bool));                  table.Columns.Add("IsUnsigned"' typeof(bool));                  table.Columns.Add("MaximumScale"' typeof(short));                  table.Columns.Add("MinimumScale"' typeof(short));                  table.Columns.Add("IsConcurrencyType"' typeof(bool));                  table.Columns.Add("IsLiteralsSupported"' typeof(bool));                  table.Columns.Add("LiteralPrefix"' typeof(string));                  table.Columns.Add("LiteralSuffix"' typeof(string));                  table.Columns.Add("NativeDataType"' typeof(string));    // NativeDataType is an OLE DB specific column for exposing the OLE DB type of the data type .                    table.ReadXml(XmlReader.Create(typeof(NuoDbConnectionInternal).Assembly.GetManifestResourceStream("NuoDb.Data.Client.DataTypes.xml")));              }              else if (collectionName == "Tables")              {                  table.Columns.Add("TABLE_CATALOG"' typeof(string));                  table.Columns.Add("TABLE_SCHEMA"' typeof(string));                  table.Columns.Add("TABLE_NAME"' typeof(string));                  table.Columns.Add("TABLE_TYPE"' typeof(string));                  table.Columns.Add("REMARKS"' typeof(string));                  table.Columns.Add("VIEW_DEF"' typeof(string));                    tmConn.InternalConnection.dataStream.startMessage(Protocol.GetTables);                  tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                  for (int i = 1; i < 3; i++)                      if (restrictionValues != null && restrictionValues.Length > i)                          tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                      else                          tmConn.InternalConnection.dataStream.encodeNull();                  if (restrictionValues == null || restrictionValues.Length < 4 || restrictionValues[3] == null)                      tmConn.InternalConnection.dataStream.encodeInt(0);                  else                  {                      tmConn.InternalConnection.dataStream.encodeInt(1);                      tmConn.InternalConnection.dataStream.encodeString(restrictionValues[3]);                  }                    tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                  int handle = tmConn.InternalConnection.dataStream.getInt();                    if (handle != -1)                  {                      using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                      {                          table.BeginLoadData();                          string view_def_label="";                          try                           {                               reader.GetOrdinal("VIEW_DEF");                              view_def_label = "VIEW_DEF";                          }                          catch(Exception) {}                          try                           {                               reader.GetOrdinal("VIEWDEFINITION");                              view_def_label = "VIEWDEFINITION";                          }                          catch (Exception) { }                          while (reader.Read())                          {  #if DEBUG                          System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_NAME"] + "' " + reader["TABLE_TYPE"]);  #endif                              DataRow row = table.NewRow();                              row["TABLE_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                              row["TABLE_NAME"] = reader.GetFieldValue<string>("TABLE_NAME");                              row["TABLE_TYPE"] = reader.GetFieldValue<string>("TABLE_TYPE");                              row["REMARKS"] = reader.GetFieldValue<string>("REMARKS");                              if (view_def_label.Length != 0)                              {                                  row["VIEW_DEF"] = reader.GetFieldValue<string>(view_def_label);                              }                              table.Rows.Add(row);                          }                          table.EndLoadData();                      }                  }              }              else if (collectionName == "Columns")              {                  table.Columns.Add("COLUMN_CATALOG"' typeof(string));                  table.Columns.Add("COLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("COLUMN_TABLE"' typeof(string));                  table.Columns.Add("COLUMN_NAME"' typeof(string));                  table.Columns.Add("COLUMN_POSITION"' typeof(int));                  table.Columns.Add("COLUMN_TYPE"' typeof(string));                  table.Columns.Add("COLUMN_LENGTH"' typeof(int));                  table.Columns.Add("COLUMN_PRECISION"' typeof(int));                  table.Columns.Add("COLUMN_NULLABLE"' typeof(bool));                  table.Columns.Add("COLUMN_IDENTITY"' typeof(bool));                  table.Columns.Add("COLUMN_DEFAULT"' typeof(string));                  table.Columns.Add("COLUMN_SCALE"' typeof(int));                    tmConn.InternalConnection.dataStream.startMessage(Protocol.GetColumns);                  tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                  for (int i = 1; i < 4; i++)                      if (restrictionValues != null && restrictionValues.Length > i)                          tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                      else                          tmConn.InternalConnection.dataStream.encodeNull();                    tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                  int handle = tmConn.InternalConnection.dataStream.getInt();                    if (handle != -1)                  {                      using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                      {                          table.BeginLoadData();                          while (reader.Read())                          {                              DataRow row = table.NewRow();                              row["COLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                              row["COLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                              row["COLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                              row["COLUMN_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                              row["COLUMN_LENGTH"] = reader.GetFieldValue<int>("COLUMN_SIZE");                              row["COLUMN_PRECISION"] = reader.GetFieldValue<int>("BUFFER_LENGTH");                              row["COLUMN_SCALE"] = reader.GetFieldValue<int>("DECIMAL_DIGITS");                              if (isNumeric(reader.GetFieldValue<string>("TYPE_NAME")))                              {                                  if (reader.GetFieldValue<int>("DECIMAL_DIGITS") != 0)                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME") +                                           "(" + reader.GetFieldValue<int>("BUFFER_LENGTH") + "'" + reader.GetFieldValue<int>("DECIMAL_DIGITS") + ")";                                  else                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME");                              }                              else                              {                                  if (isVarLenType(reader.GetFieldValue<string>("TYPE_NAME")) && reader.GetFieldValue<int>("COLUMN_SIZE") != 0)                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME") +                                           "(" + reader.GetFieldValue<int>("COLUMN_SIZE") + ")";                                  else                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME");                              }                              if (!reader.IsDBNull(reader.GetOrdinal("IS_NULLABLE")))                                  row["COLUMN_NULLABLE"] = reader.GetFieldValue<string>("IS_NULLABLE").Equals("YES");                              if (!reader.IsDBNull(reader.GetOrdinal("IS_AUTOINCREMENT")))                                  row["COLUMN_IDENTITY"] = reader.GetFieldValue<string>("IS_AUTOINCREMENT").Equals("YES");                              row["COLUMN_DEFAULT"] = reader.GetFieldValue<string>("COLUMN_DEF");    #if DEBUG                              System.Diagnostics.Trace.WriteLine("-> " + row["COLUMN_NAME"] + " " + row["COLUMN_TYPE"]);  #endif                              table.Rows.Add(row);                          }                          table.EndLoadData();                      }                  }              }              else if (collectionName == "Indexes")              {                  table.Columns.Add("INDEX_CATALOG"' typeof(string));                  table.Columns.Add("INDEX_SCHEMA"' typeof(string));                  table.Columns.Add("INDEX_TABLE"' typeof(string));                  table.Columns.Add("INDEX_NAME"' typeof(string));                  table.Columns.Add("INDEX_TYPE"' typeof(string));                  table.Columns.Add("INDEX_UNIQUE"' typeof(bool));                  table.Columns.Add("INDEX_PRIMARY"' typeof(bool));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetIndexInfo);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // unique                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // approximate                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        // to avoid to insert the same index more than once                      HashSet<string> unique = new HashSet<string>();                      if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;                                  if (!unique.Add(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;                                  DataRow row = table.NewRow();                                  row["INDEX_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEX_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEX_NAME"] = reader.GetFieldValue<string>("INDEX_NAME");                                  switch (reader.GetFieldValue<int>("TYPE"))                                  {                                      case 0:                                          row["INDEX_TYPE"] = "Primary";                                          break;                                      case 1:                                          row["INDEX_TYPE"] = "Unique";                                          break;                                      case 2:                                          row["INDEX_TYPE"] = "Secondary";                                          break;                                      case 3:                                          row["INDEX_TYPE"] = "Foreign Key";                                          break;                                  }                                  row["INDEX_UNIQUE"] = (reader.GetFieldValue<int>("NON_UNIQUE") == 0) ? true : false;                                  row["INDEX_PRIMARY"] = (reader.GetFieldValue<int>("TYPE") == 0) ? true : false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                        tmConn.InternalConnection.dataStream.startMessage(Protocol.GetPrimaryKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              // use INDEX_NAME' if present; if missing' the name of the index is in PK_NAME                              string indexName = "PK_NAME";                              foreach (string column in reader.columnNames)                              {                                  if (column == "INDEX_NAME")                                  {                                      indexName = "INDEX_NAME";                                      break;                                  }                              }                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>(indexName)))                                      continue;                                  if (!unique.Add(reader.GetFieldValue<string>(indexName)))                                      continue;                                  DataRow row = table.NewRow();                                  row["INDEX_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEX_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEX_NAME"] = reader.GetFieldValue<string>(indexName);                                  row["INDEX_TYPE"] = "Primary";                                  row["INDEX_UNIQUE"] = true;                                  row["INDEX_PRIMARY"] = true;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "IndexColumns")              {                  table.Columns.Add("INDEXCOLUMN_CATALOG"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_TABLE"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_INDEX"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_NAME"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_POSITION"' typeof(int));                  table.Columns.Add("INDEXCOLUMN_ISPRIMARY"' typeof(bool));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetIndexInfo);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // unique                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // approximate                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_SCHEM"] + "." + reader["TABLE_NAME"] + "=" + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["INDEXCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEXCOLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEXCOLUMN_INDEX"] = reader.GetFieldValue<string>("INDEX_NAME");                                  row["INDEXCOLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["INDEXCOLUMN_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                                  row["INDEXCOLUMN_ISPRIMARY"] = false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                        tmConn.InternalConnection.dataStream.startMessage(Protocol.GetPrimaryKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              // use INDEX_NAME' if present; if missing' the name of the index is in PK_NAME                              string indexName = "PK_NAME";                              foreach (string column in reader.columnNames)                              {                                  if (column == "INDEX_NAME")                                  {                                      indexName = "INDEX_NAME";                                      break;                                  }                              }                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>(indexName)))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_SCHEM"] + "." + reader["TABLE_NAME"] + " (Primary) =" + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["INDEXCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEXCOLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEXCOLUMN_INDEX"] = reader.GetFieldValue<string>(indexName);                                  row["INDEXCOLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["INDEXCOLUMN_POSITION"] = reader.GetFieldValue<int>("KEY_SEQ");                                  row["INDEXCOLUMN_ISPRIMARY"] = true;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ForeignKeys")              {                  table.Columns.Add("FOREIGNKEY_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEY_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEY_TABLE"' typeof(string));                  table.Columns.Add("FOREIGNKEY_NAME"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_TABLE"' typeof(string));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetImportedKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  string name = "[" + reader.GetFieldValue<string>("FKTABLE_SCHEM") + "]" +                                                   reader.GetFieldValue<string>("FKTABLE_NAME") + "." +                                                   reader.GetFieldValue<string>("FKCOLUMN_NAME") + "->" +                                                  "[" + reader.GetFieldValue<string>("PKTABLE_SCHEM") + "]" +                                                   reader.GetFieldValue<string>("PKTABLE_NAME") + "." +                                                   reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(name))                                      continue;                                  DataRow row = table.NewRow();                                  row["FOREIGNKEY_SCHEMA"] = reader.GetFieldValue<string>("FKTABLE_SCHEM");                                  row["FOREIGNKEY_TABLE"] = reader.GetFieldValue<string>("FKTABLE_NAME");                                  row["FOREIGNKEY_NAME"] = name;                                  row["FOREIGNKEY_OTHER_SCHEMA"] = reader.GetFieldValue<string>("PKTABLE_SCHEM");                                  row["FOREIGNKEY_OTHER_TABLE"] = reader.GetFieldValue<string>("PKTABLE_NAME");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ForeignKeyColumns")              {                  table.Columns.Add("FOREIGNKEYCOLUMN_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_TABLE"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_KEY"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_NAME"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_ORDINAL"' typeof(int));                  table.Columns.Add("FOREIGNKEYCOLUMN_OTHER_COLUMN_NAME"' typeof(string));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetImportedKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  string name = "[" + reader.GetFieldValue<string>("FKTABLE_SCHEM") + "]" +                                                  reader.GetFieldValue<string>("FKTABLE_NAME") + "." +                                                  reader.GetFieldValue<string>("FKCOLUMN_NAME") + "->" +                                                  "[" + reader.GetFieldValue<string>("PKTABLE_SCHEM") + "]" +                                                  reader.GetFieldValue<string>("PKTABLE_NAME") + "." +                                                  reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(name))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["FKTABLE_SCHEM"] + "." + reader["FKTABLE_NAME"] + "=" + reader["FKCOLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["FOREIGNKEYCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("FKTABLE_SCHEM");                                  row["FOREIGNKEYCOLUMN_TABLE"] = reader.GetFieldValue<string>("FKTABLE_NAME");                                  row["FOREIGNKEYCOLUMN_KEY"] = name;                                  row["FOREIGNKEYCOLUMN_NAME"] = reader.GetFieldValue<string>("FKCOLUMN_NAME");                                  row["FOREIGNKEYCOLUMN_ORDINAL"] = reader.GetFieldValue<int>("KEY_SEQ");                                  row["FOREIGNKEYCOLUMN_OTHER_COLUMN_NAME"] = reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "Procedures")               {                  table.Columns.Add("PROCEDURE_CATALOG"' typeof(string));                  table.Columns.Add("PROCEDURE_SCHEMA"' typeof(string));                  table.Columns.Add("PROCEDURE_NAME"' typeof(string));                  table.Columns.Add("IS_SYSTEM_PROCEDURE"' typeof(bool));                    if (tmConn.InternalConnection.protocolVersion >= Protocol.PROTOCOL_VERSION12)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetProcedures);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      for (int i = 1; i < 3; i++)                          if (restrictionValues != null && restrictionValues.Length > i)                              tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                          else                              tmConn.InternalConnection.dataStream.encodeNull();                        tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["PROCEDURE_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["PROCEDURE_SCHEMA"] = reader.GetFieldValue<string>("PROCEDURE_SCHEM");                                  row["PROCEDURE_NAME"] = reader.GetFieldValue<string>("PROCEDURE_NAME");                                  row["IS_SYSTEM_PROCEDURE"] = false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ProcedureParameters")              {                  table.Columns.Add("PROCEDURE_CATALOG"' typeof(string));                  table.Columns.Add("PROCEDURE_SCHEMA"' typeof(string));                  table.Columns.Add("PROCEDURE_NAME"' typeof(string));                  table.Columns.Add("PARAMETER_NAME"' typeof(string));                  table.Columns.Add("ORDINAL_POSITION"' typeof(int));                  table.Columns.Add("PARAMETER_DATA_TYPE"' typeof(int));                  table.Columns.Add("PARAMETER_TYPE_NAME"' typeof(string));                  table.Columns.Add("PARAMETER_SIZE"' typeof(int));                  table.Columns.Add("NUMERIC_PRECISION"' typeof(int));                  table.Columns.Add("NUMERIC_SCALE"' typeof(int));                  table.Columns.Add("PARAMETER_DIRECTION"' typeof(int));                  table.Columns.Add("IS_NULLABLE"' typeof(bool));                    if (tmConn.InternalConnection.protocolVersion >= Protocol.PROTOCOL_VERSION12)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetProcedureColumns);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      for (int i = 1; i < 4; i++)                          if (restrictionValues != null && restrictionValues.Length > i)                              tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                          else                              tmConn.InternalConnection.dataStream.encodeNull();                        tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["PROCEDURE_NAME"] + "' " + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["PROCEDURE_SCHEMA"] = reader.GetFieldValue<string>("PROCEDURE_SCHEM");                                  row["PROCEDURE_NAME"] = reader.GetFieldValue<string>("PROCEDURE_NAME");                                  row["PARAMETER_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["ORDINAL_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                                  row["PARAMETER_TYPE_NAME"] = reader.GetFieldValue<string>("TYPE_NAME");                                  row["PARAMETER_DATA_TYPE"] = reader.GetFieldValue<int>("DATA_TYPE");                                  row["PARAMETER_SIZE"] = reader.GetFieldValue<int>("LENGTH");                                  row["NUMERIC_PRECISION"] = reader.GetFieldValue<int>("PRECISION");                                  row["NUMERIC_SCALE"] = reader.GetFieldValue<int>("SCALE");                                  row["PARAMETER_DIRECTION"] = reader.GetFieldValue<int>("COLUMN_TYPE");                                  row["IS_NULLABLE"] = !reader.GetFieldValue<string>("IS_NULLABLE").Equals("NO");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The following statement contains a magic number: if (collectionName == DbMetaDataCollectionNames.DataSourceInformation)              {                  // see http://msdn.microsoft.com/en-us/library/ms254501.aspx                  table.Columns.Add("CompositeIdentifierSeparatorPattern"' typeof(string));                  table.Columns.Add("DataSourceProductName"' typeof(string));                  table.Columns.Add("DataSourceProductVersion"' typeof(string));                  table.Columns.Add("DataSourceProductVersionNormalized"' typeof(string));                  table.Columns.Add("DataSourceInternalProductVersion"' typeof(string));                  table.Columns.Add("GroupByBehavior"' typeof(GroupByBehavior));                  table.Columns.Add("IdentifierPattern"' typeof(string));                  table.Columns.Add("IdentifierCase"' typeof(IdentifierCase));                  table.Columns.Add("OrderByColumnsInSelect"' typeof(bool));                  table.Columns.Add("ParameterMarkerFormat"' typeof(string));                  table.Columns.Add("ParameterMarkerPattern"' typeof(string));                  table.Columns.Add("ParameterNameMaxLength"' typeof(int));                  table.Columns.Add("ParameterNamePattern"' typeof(string));                  table.Columns.Add("QuotedIdentifierPattern"' typeof(string));  // Regex                  table.Columns.Add("QuotedIdentifierCase"' typeof(int));                  table.Columns.Add("StatementSeparatorPattern"' typeof(string));                  table.Columns.Add("StringLiteralPattern"' typeof(string));  // Regex                  table.Columns.Add("SupportedJoinOperators"' typeof(SupportedJoinOperators));                    table.BeginLoadData();                  DataRow row = table.NewRow();                  int databaseMajorVersion = 0' databaseMinorVersion = 0;                  try                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetDatabaseMetaData);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      for (int item; (item = tmConn.InternalConnection.dataStream.getInt()) != Protocol.DbmbFini; )                      {                          switch (item)                          {                              case Protocol.DbmbProductName:                                  row["DataSourceProductName"] = tmConn.InternalConnection.dataStream.getString();                                  break;                                case Protocol.DbmbProductVersion:                                  row["DataSourceProductVersion"] = tmConn.InternalConnection.dataStream.getString();                                  break;                                case Protocol.DbmbDatabaseMinorVersion:                                  databaseMinorVersion = tmConn.InternalConnection.dataStream.getInt();                                  break;                                case Protocol.DbmbDatabaseMajorVersion:                                  databaseMajorVersion = tmConn.InternalConnection.dataStream.getInt();                                  break;                                case Protocol.DbmbDefaultTransactionIsolation:                                  int defaultTransactionIsolation = tmConn.InternalConnection.dataStream.getInt();                                  break;                                default:                                  tmConn.InternalConnection.dataStream.decode();                                  break;                          }                      }                  }                  catch (Exception)                  {                  }                    row["DataSourceInternalProductVersion"] = String.Format("{0:D3}.{1:D3}"' databaseMajorVersion' databaseMinorVersion);                  // The regular expression to match the composite separators in a composite identifier.                   // For example' "\." (for SQL Server) or "@|\." (for Oracle).                  // A composite identifier is typically what is used for a database object name'                   // for example: pubs.dbo.authors or pubs@dbo.authors.                  row["CompositeIdentifierSeparatorPattern"] = "\\.";                  // A normalized version for the data source' such that it can be compared with String.Compare().                   // The format of this is consistent for all versions of the provider to prevent version 10 from sorting between version 1 and version 2.                  //row["DataSourceProductVersionNormalized"] = ??                  // Specifies the relationship between the columns in a GROUP BY clause and the non-aggregated columns in the select list.                  row["GroupByBehavior"] = GroupByBehavior.Unknown;                  // A regular expression that matches an identifier and has a match value of the identifier. For example "[A-Za-z0-9_#$]".                  row["IdentifierPattern"] = "(^\\[\\p{Lo}\\p{Lu}\\p{Ll}_@#][\\p{Lo}\\p{Lu}\\p{Ll}\\p{Nd}@$#_]*$)|(^\"[^\"\\0]|\"\"+\"$)";                  // Indicates whether non-quoted identifiers are treated as case sensitive or not.                  row["IdentifierCase"] = IdentifierCase.Insensitive;                  // Specifies whether columns in an ORDER BY clause must be in the select list.                   // A value of true indicates that they are required to be in the select list'                   // a value of false indicates that they are not required to be in the select list.                  row["OrderByColumnsInSelect"] = false;                  // For data sources that do not expect named parameters and expect the use of the ‘?’ character' the format string                  // can be specified as simply '?'' which would ignore the parameter name.                  row["ParameterMarkerFormat"] = "?";                  // if the data source doesn't support named parameters' this would simply be "?".                  row["ParameterMarkerPattern"] = "?";                  // If the data source does not support named parameters' this property returns zero.                  row["ParameterNameMaxLength"] = 0;                  // A regular expression that matches the valid parameter names                  row["ParameterNamePattern"] = "";                  // A regular expression that matches a quoted identifier and has a match value of the identifier itself without the quotes.                   // For example' if the data source used double-quotes to identify quoted identifiers' this would be: "(([^\"]|\"\")*)".                  row["QuotedIdentifierPattern"] = "\"([^\"]*)\"";                  // Indicates whether quoted identifiers are treated as case sensitive or not.                  row["QuotedIdentifierCase"] = IdentifierCase.Sensitive;                  // A regular expression that matches the statement separator.                  row["StatementSeparatorPattern"] = ";";                  // A regular expression that matches a string literal and has a match value of the literal itself.                   // For example' if the data source used single-quotes to identify strings' this would be: "('([^']|'')*')"'                  row["StringLiteralPattern"] = "'([^']*)'";                  // Specifies what types of SQL join statements are supported by the data source.                  row["SupportedJoinOperators"] = SupportedJoinOperators.None;                  table.Rows.Add(row);                  table.EndLoadData();              }              else if (collectionName == DbMetaDataCollectionNames.ReservedWords)              {                  table.Columns.Add("ReservedWord"' typeof(string));                  table.Columns.Add("MaximumVersion"' typeof(string));                  table.Columns.Add("MinimumVersion"' typeof(string));                    string[] words = { "select"' "Add field"' "Drop field"' "Alter table"' "Alter field"'                                      "Alter user"' "And"' "Or"' "Not"' "Create Index"' "Upgrade"' "Unique"'                                      "Table key"' "Table unique key"' "Primary Key"' "Create Table"'                                      "Upgrade Table"' "Rename Table"' "Create View"' "Upgrade View"'                                      "Drop View"' "Create Schema"' "Drop Schema"' "Integer"' "Smallint"'                                      "Bigint"' "Tinyint"' "float"' "double"' "Blob"' "bytes"' "boolean"'                                      "binary"' "varbinary"' "string"' "char"' "text"' "date"' "timestamp"'                                      "time"' "varchar"' "numeric"' "Decimal Number"' "Enum"' "Delete"' "Repair"'                                      "Field"' "Not Null"' "Default Value"' "searchable"' "not searchable"'                                      "collation"' "character_set"' "Foreign Key"' "Identifier"' "record number"'                                      "Insert"' "Replace"' "Name"' "Number"' "Order"' "Descending"' "limit"'                                      "Quoted String"' "Select Clause"' "Distinct"' "Gtr"' "Geq"' "Eql"'                                      "Leq"' "Lss"' "Neq"' "in list"' "in select"' "exists"' "Between"' "Like"'                                      "starts with"' "Containing"' "Matching"' "Regular expression"' "Null"'                                      "True"' "False"' "Execute"' "Parameter"' "Count"' "sum"' "min"' "max"'                                      "avg"' "Drop Index"' "Drop primary key"' "Drop foreign key"' "Drop Table"'                                      "If Exists"' "Describe"' "Statement"' "for_select"' "for_insert"' "while"'                                      "if then else"' "variable"' "declaration"' "throw"' "assignment"'                                      "Start transaction"' "read only"' "read write"' "read committed"' "write committed"'                                      "read uncommitted"' "repeatableread"' "serializable"' "Commit"' "Rollback"'                                      "Savepoint"' "Rollack Savepoint"' "Release Savepoint"' "Table"' "Derived Table"'                                      "Assign"' "Update"' "list"' "Constant"' "Function"' "Grant"' "Grant role"' "Alter"'                                      "Read"' "Identity"' "Check"' "Constraint"' "value constraint"' "auto increment"'                                      "generated"' "always"' "Domain"' "is null"' "is active_role"' "start with"' "reindex"'                                      "cursor"' "alias"' "push_namespace"' "pop_namespace"' "set_namespace"' "coalesce"'                                      "nod_nullif"' "case"' "case_search"' "add"' "subtract"' "multiply"' "divide"' "modulus"'                                      "negate"' "plus"' "cast"' "concatenation"' "create user"' "drop user"' "create role"'                                      "upgrade role"' "drop role"' "revoke"' "revoke role"' "assume"' "revert"' "negate"'                                      "priv insert"' "priv delete"' "priv execute"' "priv select"' "priv update"' "priv grant"'                                      "priv all"' "characters"' "octets"' "role"' "view"' "procedure"' "user"' "zone"' "admin"'                                      "default role"' "create sequence"' "upgrade sequence"' "drop sequence"' "next value"'                                      "create trigger"' "upgrade trigger"' "alter trigger"' "drop trigger"' "create procedure"'                                      "upgrade procedure"' "alter procedure"' "drop procedure"' "pre-insert"' "post-insert"'                                      "pre-update"' "post-update"' "pre-delete"' "post-delete"' "pre-commit"' "post-commit"'                                      "active"' "inactive"' "position"' "select-expr"' "create filterset"' "upgrade filterset"'                                      "drop filterset"' "enable filterset"' "disable filterset"' "table filter"' "left outer"'                                      "right outer"' "full outer"' "inner"' "join"' "join_term"' "trigger class"' "enable trigger class"'                                      "disable trigger class"' "create zone"' "upgrade zone"' "drop zone"' "range"' "ip address"'                                      "node_name"' "wildcard"' "create domain"' "upgrade domain"' "alter domain"' "upgrade schema"'                                      "delete cascade"' "index segment"' "for update"' "write committed"' "read committed"'                                       "consistent read"' "set dialect"' "set names"' "restrict"' "cascade"' "characters"' "octets"'                                      "create event"' "collate"' "truncate"' "restart"' "nameless constraint"' "drop constraint"'                                      "drop unique constraint"' "drop domain"' "with check option"' "not real"' "lower"' "upper"'                                      "substr"' "substring index"' "charlength"' "default keyword"' "sqrt"' "power"' "Scientific Notation Number"'                                      "Explain"' "msleep"' "KillStatement"' "now" };                  table.BeginLoadData();                  foreach (string keyword in words)                  {                      DataRow row = table.NewRow();                      row["ReservedWord"] = keyword;                      table.Rows.Add(row);                  }                  table.EndLoadData();                }              else if (collectionName == DbMetaDataCollectionNames.DataTypes)              {                  table.Columns.Add("TypeName"' typeof(string));  // The provider-specific data type name.                  table.Columns.Add("ProviderDbType"' typeof(int)); // The provider-specific type value that should be used when specifying                   //a parameter's type. For example' SqlDbType.Money or OracleType.Blob.                  table.Columns.Add("ColumnSize"' typeof(long));                  table.Columns.Add("CreateFormat"' typeof(string));                  table.Columns.Add("CreateParameters"' typeof(string));                  table.Columns.Add("DataType"' typeof(string));  // The name of the .NET Framework type of the data type.                  table.Columns.Add("IsAutoincrementable"' typeof(bool));                  table.Columns.Add("IsBestMatch"' typeof(bool));                  table.Columns.Add("IsCaseSensitive"' typeof(bool));                  table.Columns.Add("IsFixedLength"' typeof(bool));                  table.Columns.Add("IsFixedPrecisionScale"' typeof(bool));                  table.Columns.Add("IsLong"' typeof(bool));                  table.Columns.Add("IsNullable"' typeof(bool));                  table.Columns.Add("IsSearchable"' typeof(bool));                  table.Columns.Add("IsSearchableWithLike"' typeof(bool));                  table.Columns.Add("IsUnsigned"' typeof(bool));                  table.Columns.Add("MaximumScale"' typeof(short));                  table.Columns.Add("MinimumScale"' typeof(short));                  table.Columns.Add("IsConcurrencyType"' typeof(bool));                  table.Columns.Add("IsLiteralsSupported"' typeof(bool));                  table.Columns.Add("LiteralPrefix"' typeof(string));                  table.Columns.Add("LiteralSuffix"' typeof(string));                  table.Columns.Add("NativeDataType"' typeof(string));    // NativeDataType is an OLE DB specific column for exposing the OLE DB type of the data type .                    table.ReadXml(XmlReader.Create(typeof(NuoDbConnectionInternal).Assembly.GetManifestResourceStream("NuoDb.Data.Client.DataTypes.xml")));              }              else if (collectionName == "Tables")              {                  table.Columns.Add("TABLE_CATALOG"' typeof(string));                  table.Columns.Add("TABLE_SCHEMA"' typeof(string));                  table.Columns.Add("TABLE_NAME"' typeof(string));                  table.Columns.Add("TABLE_TYPE"' typeof(string));                  table.Columns.Add("REMARKS"' typeof(string));                  table.Columns.Add("VIEW_DEF"' typeof(string));                    tmConn.InternalConnection.dataStream.startMessage(Protocol.GetTables);                  tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                  for (int i = 1; i < 3; i++)                      if (restrictionValues != null && restrictionValues.Length > i)                          tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                      else                          tmConn.InternalConnection.dataStream.encodeNull();                  if (restrictionValues == null || restrictionValues.Length < 4 || restrictionValues[3] == null)                      tmConn.InternalConnection.dataStream.encodeInt(0);                  else                  {                      tmConn.InternalConnection.dataStream.encodeInt(1);                      tmConn.InternalConnection.dataStream.encodeString(restrictionValues[3]);                  }                    tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                  int handle = tmConn.InternalConnection.dataStream.getInt();                    if (handle != -1)                  {                      using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                      {                          table.BeginLoadData();                          string view_def_label="";                          try                           {                               reader.GetOrdinal("VIEW_DEF");                              view_def_label = "VIEW_DEF";                          }                          catch(Exception) {}                          try                           {                               reader.GetOrdinal("VIEWDEFINITION");                              view_def_label = "VIEWDEFINITION";                          }                          catch (Exception) { }                          while (reader.Read())                          {  #if DEBUG                          System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_NAME"] + "' " + reader["TABLE_TYPE"]);  #endif                              DataRow row = table.NewRow();                              row["TABLE_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                              row["TABLE_NAME"] = reader.GetFieldValue<string>("TABLE_NAME");                              row["TABLE_TYPE"] = reader.GetFieldValue<string>("TABLE_TYPE");                              row["REMARKS"] = reader.GetFieldValue<string>("REMARKS");                              if (view_def_label.Length != 0)                              {                                  row["VIEW_DEF"] = reader.GetFieldValue<string>(view_def_label);                              }                              table.Rows.Add(row);                          }                          table.EndLoadData();                      }                  }              }              else if (collectionName == "Columns")              {                  table.Columns.Add("COLUMN_CATALOG"' typeof(string));                  table.Columns.Add("COLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("COLUMN_TABLE"' typeof(string));                  table.Columns.Add("COLUMN_NAME"' typeof(string));                  table.Columns.Add("COLUMN_POSITION"' typeof(int));                  table.Columns.Add("COLUMN_TYPE"' typeof(string));                  table.Columns.Add("COLUMN_LENGTH"' typeof(int));                  table.Columns.Add("COLUMN_PRECISION"' typeof(int));                  table.Columns.Add("COLUMN_NULLABLE"' typeof(bool));                  table.Columns.Add("COLUMN_IDENTITY"' typeof(bool));                  table.Columns.Add("COLUMN_DEFAULT"' typeof(string));                  table.Columns.Add("COLUMN_SCALE"' typeof(int));                    tmConn.InternalConnection.dataStream.startMessage(Protocol.GetColumns);                  tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                  for (int i = 1; i < 4; i++)                      if (restrictionValues != null && restrictionValues.Length > i)                          tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                      else                          tmConn.InternalConnection.dataStream.encodeNull();                    tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                  int handle = tmConn.InternalConnection.dataStream.getInt();                    if (handle != -1)                  {                      using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                      {                          table.BeginLoadData();                          while (reader.Read())                          {                              DataRow row = table.NewRow();                              row["COLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                              row["COLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                              row["COLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                              row["COLUMN_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                              row["COLUMN_LENGTH"] = reader.GetFieldValue<int>("COLUMN_SIZE");                              row["COLUMN_PRECISION"] = reader.GetFieldValue<int>("BUFFER_LENGTH");                              row["COLUMN_SCALE"] = reader.GetFieldValue<int>("DECIMAL_DIGITS");                              if (isNumeric(reader.GetFieldValue<string>("TYPE_NAME")))                              {                                  if (reader.GetFieldValue<int>("DECIMAL_DIGITS") != 0)                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME") +                                           "(" + reader.GetFieldValue<int>("BUFFER_LENGTH") + "'" + reader.GetFieldValue<int>("DECIMAL_DIGITS") + ")";                                  else                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME");                              }                              else                              {                                  if (isVarLenType(reader.GetFieldValue<string>("TYPE_NAME")) && reader.GetFieldValue<int>("COLUMN_SIZE") != 0)                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME") +                                           "(" + reader.GetFieldValue<int>("COLUMN_SIZE") + ")";                                  else                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME");                              }                              if (!reader.IsDBNull(reader.GetOrdinal("IS_NULLABLE")))                                  row["COLUMN_NULLABLE"] = reader.GetFieldValue<string>("IS_NULLABLE").Equals("YES");                              if (!reader.IsDBNull(reader.GetOrdinal("IS_AUTOINCREMENT")))                                  row["COLUMN_IDENTITY"] = reader.GetFieldValue<string>("IS_AUTOINCREMENT").Equals("YES");                              row["COLUMN_DEFAULT"] = reader.GetFieldValue<string>("COLUMN_DEF");    #if DEBUG                              System.Diagnostics.Trace.WriteLine("-> " + row["COLUMN_NAME"] + " " + row["COLUMN_TYPE"]);  #endif                              table.Rows.Add(row);                          }                          table.EndLoadData();                      }                  }              }              else if (collectionName == "Indexes")              {                  table.Columns.Add("INDEX_CATALOG"' typeof(string));                  table.Columns.Add("INDEX_SCHEMA"' typeof(string));                  table.Columns.Add("INDEX_TABLE"' typeof(string));                  table.Columns.Add("INDEX_NAME"' typeof(string));                  table.Columns.Add("INDEX_TYPE"' typeof(string));                  table.Columns.Add("INDEX_UNIQUE"' typeof(bool));                  table.Columns.Add("INDEX_PRIMARY"' typeof(bool));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetIndexInfo);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // unique                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // approximate                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        // to avoid to insert the same index more than once                      HashSet<string> unique = new HashSet<string>();                      if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;                                  if (!unique.Add(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;                                  DataRow row = table.NewRow();                                  row["INDEX_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEX_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEX_NAME"] = reader.GetFieldValue<string>("INDEX_NAME");                                  switch (reader.GetFieldValue<int>("TYPE"))                                  {                                      case 0:                                          row["INDEX_TYPE"] = "Primary";                                          break;                                      case 1:                                          row["INDEX_TYPE"] = "Unique";                                          break;                                      case 2:                                          row["INDEX_TYPE"] = "Secondary";                                          break;                                      case 3:                                          row["INDEX_TYPE"] = "Foreign Key";                                          break;                                  }                                  row["INDEX_UNIQUE"] = (reader.GetFieldValue<int>("NON_UNIQUE") == 0) ? true : false;                                  row["INDEX_PRIMARY"] = (reader.GetFieldValue<int>("TYPE") == 0) ? true : false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                        tmConn.InternalConnection.dataStream.startMessage(Protocol.GetPrimaryKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              // use INDEX_NAME' if present; if missing' the name of the index is in PK_NAME                              string indexName = "PK_NAME";                              foreach (string column in reader.columnNames)                              {                                  if (column == "INDEX_NAME")                                  {                                      indexName = "INDEX_NAME";                                      break;                                  }                              }                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>(indexName)))                                      continue;                                  if (!unique.Add(reader.GetFieldValue<string>(indexName)))                                      continue;                                  DataRow row = table.NewRow();                                  row["INDEX_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEX_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEX_NAME"] = reader.GetFieldValue<string>(indexName);                                  row["INDEX_TYPE"] = "Primary";                                  row["INDEX_UNIQUE"] = true;                                  row["INDEX_PRIMARY"] = true;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "IndexColumns")              {                  table.Columns.Add("INDEXCOLUMN_CATALOG"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_TABLE"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_INDEX"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_NAME"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_POSITION"' typeof(int));                  table.Columns.Add("INDEXCOLUMN_ISPRIMARY"' typeof(bool));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetIndexInfo);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // unique                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // approximate                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_SCHEM"] + "." + reader["TABLE_NAME"] + "=" + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["INDEXCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEXCOLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEXCOLUMN_INDEX"] = reader.GetFieldValue<string>("INDEX_NAME");                                  row["INDEXCOLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["INDEXCOLUMN_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                                  row["INDEXCOLUMN_ISPRIMARY"] = false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                        tmConn.InternalConnection.dataStream.startMessage(Protocol.GetPrimaryKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              // use INDEX_NAME' if present; if missing' the name of the index is in PK_NAME                              string indexName = "PK_NAME";                              foreach (string column in reader.columnNames)                              {                                  if (column == "INDEX_NAME")                                  {                                      indexName = "INDEX_NAME";                                      break;                                  }                              }                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>(indexName)))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_SCHEM"] + "." + reader["TABLE_NAME"] + " (Primary) =" + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["INDEXCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEXCOLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEXCOLUMN_INDEX"] = reader.GetFieldValue<string>(indexName);                                  row["INDEXCOLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["INDEXCOLUMN_POSITION"] = reader.GetFieldValue<int>("KEY_SEQ");                                  row["INDEXCOLUMN_ISPRIMARY"] = true;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ForeignKeys")              {                  table.Columns.Add("FOREIGNKEY_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEY_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEY_TABLE"' typeof(string));                  table.Columns.Add("FOREIGNKEY_NAME"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_TABLE"' typeof(string));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetImportedKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  string name = "[" + reader.GetFieldValue<string>("FKTABLE_SCHEM") + "]" +                                                   reader.GetFieldValue<string>("FKTABLE_NAME") + "." +                                                   reader.GetFieldValue<string>("FKCOLUMN_NAME") + "->" +                                                  "[" + reader.GetFieldValue<string>("PKTABLE_SCHEM") + "]" +                                                   reader.GetFieldValue<string>("PKTABLE_NAME") + "." +                                                   reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(name))                                      continue;                                  DataRow row = table.NewRow();                                  row["FOREIGNKEY_SCHEMA"] = reader.GetFieldValue<string>("FKTABLE_SCHEM");                                  row["FOREIGNKEY_TABLE"] = reader.GetFieldValue<string>("FKTABLE_NAME");                                  row["FOREIGNKEY_NAME"] = name;                                  row["FOREIGNKEY_OTHER_SCHEMA"] = reader.GetFieldValue<string>("PKTABLE_SCHEM");                                  row["FOREIGNKEY_OTHER_TABLE"] = reader.GetFieldValue<string>("PKTABLE_NAME");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ForeignKeyColumns")              {                  table.Columns.Add("FOREIGNKEYCOLUMN_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_TABLE"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_KEY"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_NAME"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_ORDINAL"' typeof(int));                  table.Columns.Add("FOREIGNKEYCOLUMN_OTHER_COLUMN_NAME"' typeof(string));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetImportedKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  string name = "[" + reader.GetFieldValue<string>("FKTABLE_SCHEM") + "]" +                                                  reader.GetFieldValue<string>("FKTABLE_NAME") + "." +                                                  reader.GetFieldValue<string>("FKCOLUMN_NAME") + "->" +                                                  "[" + reader.GetFieldValue<string>("PKTABLE_SCHEM") + "]" +                                                  reader.GetFieldValue<string>("PKTABLE_NAME") + "." +                                                  reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(name))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["FKTABLE_SCHEM"] + "." + reader["FKTABLE_NAME"] + "=" + reader["FKCOLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["FOREIGNKEYCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("FKTABLE_SCHEM");                                  row["FOREIGNKEYCOLUMN_TABLE"] = reader.GetFieldValue<string>("FKTABLE_NAME");                                  row["FOREIGNKEYCOLUMN_KEY"] = name;                                  row["FOREIGNKEYCOLUMN_NAME"] = reader.GetFieldValue<string>("FKCOLUMN_NAME");                                  row["FOREIGNKEYCOLUMN_ORDINAL"] = reader.GetFieldValue<int>("KEY_SEQ");                                  row["FOREIGNKEYCOLUMN_OTHER_COLUMN_NAME"] = reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "Procedures")               {                  table.Columns.Add("PROCEDURE_CATALOG"' typeof(string));                  table.Columns.Add("PROCEDURE_SCHEMA"' typeof(string));                  table.Columns.Add("PROCEDURE_NAME"' typeof(string));                  table.Columns.Add("IS_SYSTEM_PROCEDURE"' typeof(bool));                    if (tmConn.InternalConnection.protocolVersion >= Protocol.PROTOCOL_VERSION12)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetProcedures);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      for (int i = 1; i < 3; i++)                          if (restrictionValues != null && restrictionValues.Length > i)                              tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                          else                              tmConn.InternalConnection.dataStream.encodeNull();                        tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["PROCEDURE_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["PROCEDURE_SCHEMA"] = reader.GetFieldValue<string>("PROCEDURE_SCHEM");                                  row["PROCEDURE_NAME"] = reader.GetFieldValue<string>("PROCEDURE_NAME");                                  row["IS_SYSTEM_PROCEDURE"] = false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ProcedureParameters")              {                  table.Columns.Add("PROCEDURE_CATALOG"' typeof(string));                  table.Columns.Add("PROCEDURE_SCHEMA"' typeof(string));                  table.Columns.Add("PROCEDURE_NAME"' typeof(string));                  table.Columns.Add("PARAMETER_NAME"' typeof(string));                  table.Columns.Add("ORDINAL_POSITION"' typeof(int));                  table.Columns.Add("PARAMETER_DATA_TYPE"' typeof(int));                  table.Columns.Add("PARAMETER_TYPE_NAME"' typeof(string));                  table.Columns.Add("PARAMETER_SIZE"' typeof(int));                  table.Columns.Add("NUMERIC_PRECISION"' typeof(int));                  table.Columns.Add("NUMERIC_SCALE"' typeof(int));                  table.Columns.Add("PARAMETER_DIRECTION"' typeof(int));                  table.Columns.Add("IS_NULLABLE"' typeof(bool));                    if (tmConn.InternalConnection.protocolVersion >= Protocol.PROTOCOL_VERSION12)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetProcedureColumns);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      for (int i = 1; i < 4; i++)                          if (restrictionValues != null && restrictionValues.Length > i)                              tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                          else                              tmConn.InternalConnection.dataStream.encodeNull();                        tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["PROCEDURE_NAME"] + "' " + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["PROCEDURE_SCHEMA"] = reader.GetFieldValue<string>("PROCEDURE_SCHEM");                                  row["PROCEDURE_NAME"] = reader.GetFieldValue<string>("PROCEDURE_NAME");                                  row["PARAMETER_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["ORDINAL_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                                  row["PARAMETER_TYPE_NAME"] = reader.GetFieldValue<string>("TYPE_NAME");                                  row["PARAMETER_DATA_TYPE"] = reader.GetFieldValue<int>("DATA_TYPE");                                  row["PARAMETER_SIZE"] = reader.GetFieldValue<int>("LENGTH");                                  row["NUMERIC_PRECISION"] = reader.GetFieldValue<int>("PRECISION");                                  row["NUMERIC_SCALE"] = reader.GetFieldValue<int>("SCALE");                                  row["PARAMETER_DIRECTION"] = reader.GetFieldValue<int>("COLUMN_TYPE");                                  row["IS_NULLABLE"] = !reader.GetFieldValue<string>("IS_NULLABLE").Equals("NO");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The following statement contains a magic number: if (collectionName == DbMetaDataCollectionNames.DataSourceInformation)              {                  // see http://msdn.microsoft.com/en-us/library/ms254501.aspx                  table.Columns.Add("CompositeIdentifierSeparatorPattern"' typeof(string));                  table.Columns.Add("DataSourceProductName"' typeof(string));                  table.Columns.Add("DataSourceProductVersion"' typeof(string));                  table.Columns.Add("DataSourceProductVersionNormalized"' typeof(string));                  table.Columns.Add("DataSourceInternalProductVersion"' typeof(string));                  table.Columns.Add("GroupByBehavior"' typeof(GroupByBehavior));                  table.Columns.Add("IdentifierPattern"' typeof(string));                  table.Columns.Add("IdentifierCase"' typeof(IdentifierCase));                  table.Columns.Add("OrderByColumnsInSelect"' typeof(bool));                  table.Columns.Add("ParameterMarkerFormat"' typeof(string));                  table.Columns.Add("ParameterMarkerPattern"' typeof(string));                  table.Columns.Add("ParameterNameMaxLength"' typeof(int));                  table.Columns.Add("ParameterNamePattern"' typeof(string));                  table.Columns.Add("QuotedIdentifierPattern"' typeof(string));  // Regex                  table.Columns.Add("QuotedIdentifierCase"' typeof(int));                  table.Columns.Add("StatementSeparatorPattern"' typeof(string));                  table.Columns.Add("StringLiteralPattern"' typeof(string));  // Regex                  table.Columns.Add("SupportedJoinOperators"' typeof(SupportedJoinOperators));                    table.BeginLoadData();                  DataRow row = table.NewRow();                  int databaseMajorVersion = 0' databaseMinorVersion = 0;                  try                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetDatabaseMetaData);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      for (int item; (item = tmConn.InternalConnection.dataStream.getInt()) != Protocol.DbmbFini; )                      {                          switch (item)                          {                              case Protocol.DbmbProductName:                                  row["DataSourceProductName"] = tmConn.InternalConnection.dataStream.getString();                                  break;                                case Protocol.DbmbProductVersion:                                  row["DataSourceProductVersion"] = tmConn.InternalConnection.dataStream.getString();                                  break;                                case Protocol.DbmbDatabaseMinorVersion:                                  databaseMinorVersion = tmConn.InternalConnection.dataStream.getInt();                                  break;                                case Protocol.DbmbDatabaseMajorVersion:                                  databaseMajorVersion = tmConn.InternalConnection.dataStream.getInt();                                  break;                                case Protocol.DbmbDefaultTransactionIsolation:                                  int defaultTransactionIsolation = tmConn.InternalConnection.dataStream.getInt();                                  break;                                default:                                  tmConn.InternalConnection.dataStream.decode();                                  break;                          }                      }                  }                  catch (Exception)                  {                  }                    row["DataSourceInternalProductVersion"] = String.Format("{0:D3}.{1:D3}"' databaseMajorVersion' databaseMinorVersion);                  // The regular expression to match the composite separators in a composite identifier.                   // For example' "\." (for SQL Server) or "@|\." (for Oracle).                  // A composite identifier is typically what is used for a database object name'                   // for example: pubs.dbo.authors or pubs@dbo.authors.                  row["CompositeIdentifierSeparatorPattern"] = "\\.";                  // A normalized version for the data source' such that it can be compared with String.Compare().                   // The format of this is consistent for all versions of the provider to prevent version 10 from sorting between version 1 and version 2.                  //row["DataSourceProductVersionNormalized"] = ??                  // Specifies the relationship between the columns in a GROUP BY clause and the non-aggregated columns in the select list.                  row["GroupByBehavior"] = GroupByBehavior.Unknown;                  // A regular expression that matches an identifier and has a match value of the identifier. For example "[A-Za-z0-9_#$]".                  row["IdentifierPattern"] = "(^\\[\\p{Lo}\\p{Lu}\\p{Ll}_@#][\\p{Lo}\\p{Lu}\\p{Ll}\\p{Nd}@$#_]*$)|(^\"[^\"\\0]|\"\"+\"$)";                  // Indicates whether non-quoted identifiers are treated as case sensitive or not.                  row["IdentifierCase"] = IdentifierCase.Insensitive;                  // Specifies whether columns in an ORDER BY clause must be in the select list.                   // A value of true indicates that they are required to be in the select list'                   // a value of false indicates that they are not required to be in the select list.                  row["OrderByColumnsInSelect"] = false;                  // For data sources that do not expect named parameters and expect the use of the ‘?’ character' the format string                  // can be specified as simply '?'' which would ignore the parameter name.                  row["ParameterMarkerFormat"] = "?";                  // if the data source doesn't support named parameters' this would simply be "?".                  row["ParameterMarkerPattern"] = "?";                  // If the data source does not support named parameters' this property returns zero.                  row["ParameterNameMaxLength"] = 0;                  // A regular expression that matches the valid parameter names                  row["ParameterNamePattern"] = "";                  // A regular expression that matches a quoted identifier and has a match value of the identifier itself without the quotes.                   // For example' if the data source used double-quotes to identify quoted identifiers' this would be: "(([^\"]|\"\")*)".                  row["QuotedIdentifierPattern"] = "\"([^\"]*)\"";                  // Indicates whether quoted identifiers are treated as case sensitive or not.                  row["QuotedIdentifierCase"] = IdentifierCase.Sensitive;                  // A regular expression that matches the statement separator.                  row["StatementSeparatorPattern"] = ";";                  // A regular expression that matches a string literal and has a match value of the literal itself.                   // For example' if the data source used single-quotes to identify strings' this would be: "('([^']|'')*')"'                  row["StringLiteralPattern"] = "'([^']*)'";                  // Specifies what types of SQL join statements are supported by the data source.                  row["SupportedJoinOperators"] = SupportedJoinOperators.None;                  table.Rows.Add(row);                  table.EndLoadData();              }              else if (collectionName == DbMetaDataCollectionNames.ReservedWords)              {                  table.Columns.Add("ReservedWord"' typeof(string));                  table.Columns.Add("MaximumVersion"' typeof(string));                  table.Columns.Add("MinimumVersion"' typeof(string));                    string[] words = { "select"' "Add field"' "Drop field"' "Alter table"' "Alter field"'                                      "Alter user"' "And"' "Or"' "Not"' "Create Index"' "Upgrade"' "Unique"'                                      "Table key"' "Table unique key"' "Primary Key"' "Create Table"'                                      "Upgrade Table"' "Rename Table"' "Create View"' "Upgrade View"'                                      "Drop View"' "Create Schema"' "Drop Schema"' "Integer"' "Smallint"'                                      "Bigint"' "Tinyint"' "float"' "double"' "Blob"' "bytes"' "boolean"'                                      "binary"' "varbinary"' "string"' "char"' "text"' "date"' "timestamp"'                                      "time"' "varchar"' "numeric"' "Decimal Number"' "Enum"' "Delete"' "Repair"'                                      "Field"' "Not Null"' "Default Value"' "searchable"' "not searchable"'                                      "collation"' "character_set"' "Foreign Key"' "Identifier"' "record number"'                                      "Insert"' "Replace"' "Name"' "Number"' "Order"' "Descending"' "limit"'                                      "Quoted String"' "Select Clause"' "Distinct"' "Gtr"' "Geq"' "Eql"'                                      "Leq"' "Lss"' "Neq"' "in list"' "in select"' "exists"' "Between"' "Like"'                                      "starts with"' "Containing"' "Matching"' "Regular expression"' "Null"'                                      "True"' "False"' "Execute"' "Parameter"' "Count"' "sum"' "min"' "max"'                                      "avg"' "Drop Index"' "Drop primary key"' "Drop foreign key"' "Drop Table"'                                      "If Exists"' "Describe"' "Statement"' "for_select"' "for_insert"' "while"'                                      "if then else"' "variable"' "declaration"' "throw"' "assignment"'                                      "Start transaction"' "read only"' "read write"' "read committed"' "write committed"'                                      "read uncommitted"' "repeatableread"' "serializable"' "Commit"' "Rollback"'                                      "Savepoint"' "Rollack Savepoint"' "Release Savepoint"' "Table"' "Derived Table"'                                      "Assign"' "Update"' "list"' "Constant"' "Function"' "Grant"' "Grant role"' "Alter"'                                      "Read"' "Identity"' "Check"' "Constraint"' "value constraint"' "auto increment"'                                      "generated"' "always"' "Domain"' "is null"' "is active_role"' "start with"' "reindex"'                                      "cursor"' "alias"' "push_namespace"' "pop_namespace"' "set_namespace"' "coalesce"'                                      "nod_nullif"' "case"' "case_search"' "add"' "subtract"' "multiply"' "divide"' "modulus"'                                      "negate"' "plus"' "cast"' "concatenation"' "create user"' "drop user"' "create role"'                                      "upgrade role"' "drop role"' "revoke"' "revoke role"' "assume"' "revert"' "negate"'                                      "priv insert"' "priv delete"' "priv execute"' "priv select"' "priv update"' "priv grant"'                                      "priv all"' "characters"' "octets"' "role"' "view"' "procedure"' "user"' "zone"' "admin"'                                      "default role"' "create sequence"' "upgrade sequence"' "drop sequence"' "next value"'                                      "create trigger"' "upgrade trigger"' "alter trigger"' "drop trigger"' "create procedure"'                                      "upgrade procedure"' "alter procedure"' "drop procedure"' "pre-insert"' "post-insert"'                                      "pre-update"' "post-update"' "pre-delete"' "post-delete"' "pre-commit"' "post-commit"'                                      "active"' "inactive"' "position"' "select-expr"' "create filterset"' "upgrade filterset"'                                      "drop filterset"' "enable filterset"' "disable filterset"' "table filter"' "left outer"'                                      "right outer"' "full outer"' "inner"' "join"' "join_term"' "trigger class"' "enable trigger class"'                                      "disable trigger class"' "create zone"' "upgrade zone"' "drop zone"' "range"' "ip address"'                                      "node_name"' "wildcard"' "create domain"' "upgrade domain"' "alter domain"' "upgrade schema"'                                      "delete cascade"' "index segment"' "for update"' "write committed"' "read committed"'                                       "consistent read"' "set dialect"' "set names"' "restrict"' "cascade"' "characters"' "octets"'                                      "create event"' "collate"' "truncate"' "restart"' "nameless constraint"' "drop constraint"'                                      "drop unique constraint"' "drop domain"' "with check option"' "not real"' "lower"' "upper"'                                      "substr"' "substring index"' "charlength"' "default keyword"' "sqrt"' "power"' "Scientific Notation Number"'                                      "Explain"' "msleep"' "KillStatement"' "now" };                  table.BeginLoadData();                  foreach (string keyword in words)                  {                      DataRow row = table.NewRow();                      row["ReservedWord"] = keyword;                      table.Rows.Add(row);                  }                  table.EndLoadData();                }              else if (collectionName == DbMetaDataCollectionNames.DataTypes)              {                  table.Columns.Add("TypeName"' typeof(string));  // The provider-specific data type name.                  table.Columns.Add("ProviderDbType"' typeof(int)); // The provider-specific type value that should be used when specifying                   //a parameter's type. For example' SqlDbType.Money or OracleType.Blob.                  table.Columns.Add("ColumnSize"' typeof(long));                  table.Columns.Add("CreateFormat"' typeof(string));                  table.Columns.Add("CreateParameters"' typeof(string));                  table.Columns.Add("DataType"' typeof(string));  // The name of the .NET Framework type of the data type.                  table.Columns.Add("IsAutoincrementable"' typeof(bool));                  table.Columns.Add("IsBestMatch"' typeof(bool));                  table.Columns.Add("IsCaseSensitive"' typeof(bool));                  table.Columns.Add("IsFixedLength"' typeof(bool));                  table.Columns.Add("IsFixedPrecisionScale"' typeof(bool));                  table.Columns.Add("IsLong"' typeof(bool));                  table.Columns.Add("IsNullable"' typeof(bool));                  table.Columns.Add("IsSearchable"' typeof(bool));                  table.Columns.Add("IsSearchableWithLike"' typeof(bool));                  table.Columns.Add("IsUnsigned"' typeof(bool));                  table.Columns.Add("MaximumScale"' typeof(short));                  table.Columns.Add("MinimumScale"' typeof(short));                  table.Columns.Add("IsConcurrencyType"' typeof(bool));                  table.Columns.Add("IsLiteralsSupported"' typeof(bool));                  table.Columns.Add("LiteralPrefix"' typeof(string));                  table.Columns.Add("LiteralSuffix"' typeof(string));                  table.Columns.Add("NativeDataType"' typeof(string));    // NativeDataType is an OLE DB specific column for exposing the OLE DB type of the data type .                    table.ReadXml(XmlReader.Create(typeof(NuoDbConnectionInternal).Assembly.GetManifestResourceStream("NuoDb.Data.Client.DataTypes.xml")));              }              else if (collectionName == "Tables")              {                  table.Columns.Add("TABLE_CATALOG"' typeof(string));                  table.Columns.Add("TABLE_SCHEMA"' typeof(string));                  table.Columns.Add("TABLE_NAME"' typeof(string));                  table.Columns.Add("TABLE_TYPE"' typeof(string));                  table.Columns.Add("REMARKS"' typeof(string));                  table.Columns.Add("VIEW_DEF"' typeof(string));                    tmConn.InternalConnection.dataStream.startMessage(Protocol.GetTables);                  tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                  for (int i = 1; i < 3; i++)                      if (restrictionValues != null && restrictionValues.Length > i)                          tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                      else                          tmConn.InternalConnection.dataStream.encodeNull();                  if (restrictionValues == null || restrictionValues.Length < 4 || restrictionValues[3] == null)                      tmConn.InternalConnection.dataStream.encodeInt(0);                  else                  {                      tmConn.InternalConnection.dataStream.encodeInt(1);                      tmConn.InternalConnection.dataStream.encodeString(restrictionValues[3]);                  }                    tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                  int handle = tmConn.InternalConnection.dataStream.getInt();                    if (handle != -1)                  {                      using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                      {                          table.BeginLoadData();                          string view_def_label="";                          try                           {                               reader.GetOrdinal("VIEW_DEF");                              view_def_label = "VIEW_DEF";                          }                          catch(Exception) {}                          try                           {                               reader.GetOrdinal("VIEWDEFINITION");                              view_def_label = "VIEWDEFINITION";                          }                          catch (Exception) { }                          while (reader.Read())                          {  #if DEBUG                          System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_NAME"] + "' " + reader["TABLE_TYPE"]);  #endif                              DataRow row = table.NewRow();                              row["TABLE_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                              row["TABLE_NAME"] = reader.GetFieldValue<string>("TABLE_NAME");                              row["TABLE_TYPE"] = reader.GetFieldValue<string>("TABLE_TYPE");                              row["REMARKS"] = reader.GetFieldValue<string>("REMARKS");                              if (view_def_label.Length != 0)                              {                                  row["VIEW_DEF"] = reader.GetFieldValue<string>(view_def_label);                              }                              table.Rows.Add(row);                          }                          table.EndLoadData();                      }                  }              }              else if (collectionName == "Columns")              {                  table.Columns.Add("COLUMN_CATALOG"' typeof(string));                  table.Columns.Add("COLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("COLUMN_TABLE"' typeof(string));                  table.Columns.Add("COLUMN_NAME"' typeof(string));                  table.Columns.Add("COLUMN_POSITION"' typeof(int));                  table.Columns.Add("COLUMN_TYPE"' typeof(string));                  table.Columns.Add("COLUMN_LENGTH"' typeof(int));                  table.Columns.Add("COLUMN_PRECISION"' typeof(int));                  table.Columns.Add("COLUMN_NULLABLE"' typeof(bool));                  table.Columns.Add("COLUMN_IDENTITY"' typeof(bool));                  table.Columns.Add("COLUMN_DEFAULT"' typeof(string));                  table.Columns.Add("COLUMN_SCALE"' typeof(int));                    tmConn.InternalConnection.dataStream.startMessage(Protocol.GetColumns);                  tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                  for (int i = 1; i < 4; i++)                      if (restrictionValues != null && restrictionValues.Length > i)                          tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                      else                          tmConn.InternalConnection.dataStream.encodeNull();                    tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                  int handle = tmConn.InternalConnection.dataStream.getInt();                    if (handle != -1)                  {                      using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                      {                          table.BeginLoadData();                          while (reader.Read())                          {                              DataRow row = table.NewRow();                              row["COLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                              row["COLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                              row["COLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                              row["COLUMN_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                              row["COLUMN_LENGTH"] = reader.GetFieldValue<int>("COLUMN_SIZE");                              row["COLUMN_PRECISION"] = reader.GetFieldValue<int>("BUFFER_LENGTH");                              row["COLUMN_SCALE"] = reader.GetFieldValue<int>("DECIMAL_DIGITS");                              if (isNumeric(reader.GetFieldValue<string>("TYPE_NAME")))                              {                                  if (reader.GetFieldValue<int>("DECIMAL_DIGITS") != 0)                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME") +                                           "(" + reader.GetFieldValue<int>("BUFFER_LENGTH") + "'" + reader.GetFieldValue<int>("DECIMAL_DIGITS") + ")";                                  else                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME");                              }                              else                              {                                  if (isVarLenType(reader.GetFieldValue<string>("TYPE_NAME")) && reader.GetFieldValue<int>("COLUMN_SIZE") != 0)                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME") +                                           "(" + reader.GetFieldValue<int>("COLUMN_SIZE") + ")";                                  else                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME");                              }                              if (!reader.IsDBNull(reader.GetOrdinal("IS_NULLABLE")))                                  row["COLUMN_NULLABLE"] = reader.GetFieldValue<string>("IS_NULLABLE").Equals("YES");                              if (!reader.IsDBNull(reader.GetOrdinal("IS_AUTOINCREMENT")))                                  row["COLUMN_IDENTITY"] = reader.GetFieldValue<string>("IS_AUTOINCREMENT").Equals("YES");                              row["COLUMN_DEFAULT"] = reader.GetFieldValue<string>("COLUMN_DEF");    #if DEBUG                              System.Diagnostics.Trace.WriteLine("-> " + row["COLUMN_NAME"] + " " + row["COLUMN_TYPE"]);  #endif                              table.Rows.Add(row);                          }                          table.EndLoadData();                      }                  }              }              else if (collectionName == "Indexes")              {                  table.Columns.Add("INDEX_CATALOG"' typeof(string));                  table.Columns.Add("INDEX_SCHEMA"' typeof(string));                  table.Columns.Add("INDEX_TABLE"' typeof(string));                  table.Columns.Add("INDEX_NAME"' typeof(string));                  table.Columns.Add("INDEX_TYPE"' typeof(string));                  table.Columns.Add("INDEX_UNIQUE"' typeof(bool));                  table.Columns.Add("INDEX_PRIMARY"' typeof(bool));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetIndexInfo);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // unique                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // approximate                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        // to avoid to insert the same index more than once                      HashSet<string> unique = new HashSet<string>();                      if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;                                  if (!unique.Add(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;                                  DataRow row = table.NewRow();                                  row["INDEX_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEX_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEX_NAME"] = reader.GetFieldValue<string>("INDEX_NAME");                                  switch (reader.GetFieldValue<int>("TYPE"))                                  {                                      case 0:                                          row["INDEX_TYPE"] = "Primary";                                          break;                                      case 1:                                          row["INDEX_TYPE"] = "Unique";                                          break;                                      case 2:                                          row["INDEX_TYPE"] = "Secondary";                                          break;                                      case 3:                                          row["INDEX_TYPE"] = "Foreign Key";                                          break;                                  }                                  row["INDEX_UNIQUE"] = (reader.GetFieldValue<int>("NON_UNIQUE") == 0) ? true : false;                                  row["INDEX_PRIMARY"] = (reader.GetFieldValue<int>("TYPE") == 0) ? true : false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                        tmConn.InternalConnection.dataStream.startMessage(Protocol.GetPrimaryKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              // use INDEX_NAME' if present; if missing' the name of the index is in PK_NAME                              string indexName = "PK_NAME";                              foreach (string column in reader.columnNames)                              {                                  if (column == "INDEX_NAME")                                  {                                      indexName = "INDEX_NAME";                                      break;                                  }                              }                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>(indexName)))                                      continue;                                  if (!unique.Add(reader.GetFieldValue<string>(indexName)))                                      continue;                                  DataRow row = table.NewRow();                                  row["INDEX_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEX_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEX_NAME"] = reader.GetFieldValue<string>(indexName);                                  row["INDEX_TYPE"] = "Primary";                                  row["INDEX_UNIQUE"] = true;                                  row["INDEX_PRIMARY"] = true;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "IndexColumns")              {                  table.Columns.Add("INDEXCOLUMN_CATALOG"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_TABLE"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_INDEX"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_NAME"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_POSITION"' typeof(int));                  table.Columns.Add("INDEXCOLUMN_ISPRIMARY"' typeof(bool));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetIndexInfo);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // unique                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // approximate                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_SCHEM"] + "." + reader["TABLE_NAME"] + "=" + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["INDEXCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEXCOLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEXCOLUMN_INDEX"] = reader.GetFieldValue<string>("INDEX_NAME");                                  row["INDEXCOLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["INDEXCOLUMN_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                                  row["INDEXCOLUMN_ISPRIMARY"] = false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                        tmConn.InternalConnection.dataStream.startMessage(Protocol.GetPrimaryKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              // use INDEX_NAME' if present; if missing' the name of the index is in PK_NAME                              string indexName = "PK_NAME";                              foreach (string column in reader.columnNames)                              {                                  if (column == "INDEX_NAME")                                  {                                      indexName = "INDEX_NAME";                                      break;                                  }                              }                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>(indexName)))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_SCHEM"] + "." + reader["TABLE_NAME"] + " (Primary) =" + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["INDEXCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEXCOLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEXCOLUMN_INDEX"] = reader.GetFieldValue<string>(indexName);                                  row["INDEXCOLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["INDEXCOLUMN_POSITION"] = reader.GetFieldValue<int>("KEY_SEQ");                                  row["INDEXCOLUMN_ISPRIMARY"] = true;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ForeignKeys")              {                  table.Columns.Add("FOREIGNKEY_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEY_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEY_TABLE"' typeof(string));                  table.Columns.Add("FOREIGNKEY_NAME"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_TABLE"' typeof(string));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetImportedKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  string name = "[" + reader.GetFieldValue<string>("FKTABLE_SCHEM") + "]" +                                                   reader.GetFieldValue<string>("FKTABLE_NAME") + "." +                                                   reader.GetFieldValue<string>("FKCOLUMN_NAME") + "->" +                                                  "[" + reader.GetFieldValue<string>("PKTABLE_SCHEM") + "]" +                                                   reader.GetFieldValue<string>("PKTABLE_NAME") + "." +                                                   reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(name))                                      continue;                                  DataRow row = table.NewRow();                                  row["FOREIGNKEY_SCHEMA"] = reader.GetFieldValue<string>("FKTABLE_SCHEM");                                  row["FOREIGNKEY_TABLE"] = reader.GetFieldValue<string>("FKTABLE_NAME");                                  row["FOREIGNKEY_NAME"] = name;                                  row["FOREIGNKEY_OTHER_SCHEMA"] = reader.GetFieldValue<string>("PKTABLE_SCHEM");                                  row["FOREIGNKEY_OTHER_TABLE"] = reader.GetFieldValue<string>("PKTABLE_NAME");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ForeignKeyColumns")              {                  table.Columns.Add("FOREIGNKEYCOLUMN_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_TABLE"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_KEY"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_NAME"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_ORDINAL"' typeof(int));                  table.Columns.Add("FOREIGNKEYCOLUMN_OTHER_COLUMN_NAME"' typeof(string));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetImportedKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  string name = "[" + reader.GetFieldValue<string>("FKTABLE_SCHEM") + "]" +                                                  reader.GetFieldValue<string>("FKTABLE_NAME") + "." +                                                  reader.GetFieldValue<string>("FKCOLUMN_NAME") + "->" +                                                  "[" + reader.GetFieldValue<string>("PKTABLE_SCHEM") + "]" +                                                  reader.GetFieldValue<string>("PKTABLE_NAME") + "." +                                                  reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(name))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["FKTABLE_SCHEM"] + "." + reader["FKTABLE_NAME"] + "=" + reader["FKCOLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["FOREIGNKEYCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("FKTABLE_SCHEM");                                  row["FOREIGNKEYCOLUMN_TABLE"] = reader.GetFieldValue<string>("FKTABLE_NAME");                                  row["FOREIGNKEYCOLUMN_KEY"] = name;                                  row["FOREIGNKEYCOLUMN_NAME"] = reader.GetFieldValue<string>("FKCOLUMN_NAME");                                  row["FOREIGNKEYCOLUMN_ORDINAL"] = reader.GetFieldValue<int>("KEY_SEQ");                                  row["FOREIGNKEYCOLUMN_OTHER_COLUMN_NAME"] = reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "Procedures")               {                  table.Columns.Add("PROCEDURE_CATALOG"' typeof(string));                  table.Columns.Add("PROCEDURE_SCHEMA"' typeof(string));                  table.Columns.Add("PROCEDURE_NAME"' typeof(string));                  table.Columns.Add("IS_SYSTEM_PROCEDURE"' typeof(bool));                    if (tmConn.InternalConnection.protocolVersion >= Protocol.PROTOCOL_VERSION12)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetProcedures);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      for (int i = 1; i < 3; i++)                          if (restrictionValues != null && restrictionValues.Length > i)                              tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                          else                              tmConn.InternalConnection.dataStream.encodeNull();                        tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["PROCEDURE_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["PROCEDURE_SCHEMA"] = reader.GetFieldValue<string>("PROCEDURE_SCHEM");                                  row["PROCEDURE_NAME"] = reader.GetFieldValue<string>("PROCEDURE_NAME");                                  row["IS_SYSTEM_PROCEDURE"] = false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ProcedureParameters")              {                  table.Columns.Add("PROCEDURE_CATALOG"' typeof(string));                  table.Columns.Add("PROCEDURE_SCHEMA"' typeof(string));                  table.Columns.Add("PROCEDURE_NAME"' typeof(string));                  table.Columns.Add("PARAMETER_NAME"' typeof(string));                  table.Columns.Add("ORDINAL_POSITION"' typeof(int));                  table.Columns.Add("PARAMETER_DATA_TYPE"' typeof(int));                  table.Columns.Add("PARAMETER_TYPE_NAME"' typeof(string));                  table.Columns.Add("PARAMETER_SIZE"' typeof(int));                  table.Columns.Add("NUMERIC_PRECISION"' typeof(int));                  table.Columns.Add("NUMERIC_SCALE"' typeof(int));                  table.Columns.Add("PARAMETER_DIRECTION"' typeof(int));                  table.Columns.Add("IS_NULLABLE"' typeof(bool));                    if (tmConn.InternalConnection.protocolVersion >= Protocol.PROTOCOL_VERSION12)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetProcedureColumns);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      for (int i = 1; i < 4; i++)                          if (restrictionValues != null && restrictionValues.Length > i)                              tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                          else                              tmConn.InternalConnection.dataStream.encodeNull();                        tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["PROCEDURE_NAME"] + "' " + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["PROCEDURE_SCHEMA"] = reader.GetFieldValue<string>("PROCEDURE_SCHEM");                                  row["PROCEDURE_NAME"] = reader.GetFieldValue<string>("PROCEDURE_NAME");                                  row["PARAMETER_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["ORDINAL_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                                  row["PARAMETER_TYPE_NAME"] = reader.GetFieldValue<string>("TYPE_NAME");                                  row["PARAMETER_DATA_TYPE"] = reader.GetFieldValue<int>("DATA_TYPE");                                  row["PARAMETER_SIZE"] = reader.GetFieldValue<int>("LENGTH");                                  row["NUMERIC_PRECISION"] = reader.GetFieldValue<int>("PRECISION");                                  row["NUMERIC_SCALE"] = reader.GetFieldValue<int>("SCALE");                                  row["PARAMETER_DIRECTION"] = reader.GetFieldValue<int>("COLUMN_TYPE");                                  row["IS_NULLABLE"] = !reader.GetFieldValue<string>("IS_NULLABLE").Equals("NO");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The following statement contains a magic number: if (collectionName == DbMetaDataCollectionNames.DataSourceInformation)              {                  // see http://msdn.microsoft.com/en-us/library/ms254501.aspx                  table.Columns.Add("CompositeIdentifierSeparatorPattern"' typeof(string));                  table.Columns.Add("DataSourceProductName"' typeof(string));                  table.Columns.Add("DataSourceProductVersion"' typeof(string));                  table.Columns.Add("DataSourceProductVersionNormalized"' typeof(string));                  table.Columns.Add("DataSourceInternalProductVersion"' typeof(string));                  table.Columns.Add("GroupByBehavior"' typeof(GroupByBehavior));                  table.Columns.Add("IdentifierPattern"' typeof(string));                  table.Columns.Add("IdentifierCase"' typeof(IdentifierCase));                  table.Columns.Add("OrderByColumnsInSelect"' typeof(bool));                  table.Columns.Add("ParameterMarkerFormat"' typeof(string));                  table.Columns.Add("ParameterMarkerPattern"' typeof(string));                  table.Columns.Add("ParameterNameMaxLength"' typeof(int));                  table.Columns.Add("ParameterNamePattern"' typeof(string));                  table.Columns.Add("QuotedIdentifierPattern"' typeof(string));  // Regex                  table.Columns.Add("QuotedIdentifierCase"' typeof(int));                  table.Columns.Add("StatementSeparatorPattern"' typeof(string));                  table.Columns.Add("StringLiteralPattern"' typeof(string));  // Regex                  table.Columns.Add("SupportedJoinOperators"' typeof(SupportedJoinOperators));                    table.BeginLoadData();                  DataRow row = table.NewRow();                  int databaseMajorVersion = 0' databaseMinorVersion = 0;                  try                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetDatabaseMetaData);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      for (int item; (item = tmConn.InternalConnection.dataStream.getInt()) != Protocol.DbmbFini; )                      {                          switch (item)                          {                              case Protocol.DbmbProductName:                                  row["DataSourceProductName"] = tmConn.InternalConnection.dataStream.getString();                                  break;                                case Protocol.DbmbProductVersion:                                  row["DataSourceProductVersion"] = tmConn.InternalConnection.dataStream.getString();                                  break;                                case Protocol.DbmbDatabaseMinorVersion:                                  databaseMinorVersion = tmConn.InternalConnection.dataStream.getInt();                                  break;                                case Protocol.DbmbDatabaseMajorVersion:                                  databaseMajorVersion = tmConn.InternalConnection.dataStream.getInt();                                  break;                                case Protocol.DbmbDefaultTransactionIsolation:                                  int defaultTransactionIsolation = tmConn.InternalConnection.dataStream.getInt();                                  break;                                default:                                  tmConn.InternalConnection.dataStream.decode();                                  break;                          }                      }                  }                  catch (Exception)                  {                  }                    row["DataSourceInternalProductVersion"] = String.Format("{0:D3}.{1:D3}"' databaseMajorVersion' databaseMinorVersion);                  // The regular expression to match the composite separators in a composite identifier.                   // For example' "\." (for SQL Server) or "@|\." (for Oracle).                  // A composite identifier is typically what is used for a database object name'                   // for example: pubs.dbo.authors or pubs@dbo.authors.                  row["CompositeIdentifierSeparatorPattern"] = "\\.";                  // A normalized version for the data source' such that it can be compared with String.Compare().                   // The format of this is consistent for all versions of the provider to prevent version 10 from sorting between version 1 and version 2.                  //row["DataSourceProductVersionNormalized"] = ??                  // Specifies the relationship between the columns in a GROUP BY clause and the non-aggregated columns in the select list.                  row["GroupByBehavior"] = GroupByBehavior.Unknown;                  // A regular expression that matches an identifier and has a match value of the identifier. For example "[A-Za-z0-9_#$]".                  row["IdentifierPattern"] = "(^\\[\\p{Lo}\\p{Lu}\\p{Ll}_@#][\\p{Lo}\\p{Lu}\\p{Ll}\\p{Nd}@$#_]*$)|(^\"[^\"\\0]|\"\"+\"$)";                  // Indicates whether non-quoted identifiers are treated as case sensitive or not.                  row["IdentifierCase"] = IdentifierCase.Insensitive;                  // Specifies whether columns in an ORDER BY clause must be in the select list.                   // A value of true indicates that they are required to be in the select list'                   // a value of false indicates that they are not required to be in the select list.                  row["OrderByColumnsInSelect"] = false;                  // For data sources that do not expect named parameters and expect the use of the ‘?’ character' the format string                  // can be specified as simply '?'' which would ignore the parameter name.                  row["ParameterMarkerFormat"] = "?";                  // if the data source doesn't support named parameters' this would simply be "?".                  row["ParameterMarkerPattern"] = "?";                  // If the data source does not support named parameters' this property returns zero.                  row["ParameterNameMaxLength"] = 0;                  // A regular expression that matches the valid parameter names                  row["ParameterNamePattern"] = "";                  // A regular expression that matches a quoted identifier and has a match value of the identifier itself without the quotes.                   // For example' if the data source used double-quotes to identify quoted identifiers' this would be: "(([^\"]|\"\")*)".                  row["QuotedIdentifierPattern"] = "\"([^\"]*)\"";                  // Indicates whether quoted identifiers are treated as case sensitive or not.                  row["QuotedIdentifierCase"] = IdentifierCase.Sensitive;                  // A regular expression that matches the statement separator.                  row["StatementSeparatorPattern"] = ";";                  // A regular expression that matches a string literal and has a match value of the literal itself.                   // For example' if the data source used single-quotes to identify strings' this would be: "('([^']|'')*')"'                  row["StringLiteralPattern"] = "'([^']*)'";                  // Specifies what types of SQL join statements are supported by the data source.                  row["SupportedJoinOperators"] = SupportedJoinOperators.None;                  table.Rows.Add(row);                  table.EndLoadData();              }              else if (collectionName == DbMetaDataCollectionNames.ReservedWords)              {                  table.Columns.Add("ReservedWord"' typeof(string));                  table.Columns.Add("MaximumVersion"' typeof(string));                  table.Columns.Add("MinimumVersion"' typeof(string));                    string[] words = { "select"' "Add field"' "Drop field"' "Alter table"' "Alter field"'                                      "Alter user"' "And"' "Or"' "Not"' "Create Index"' "Upgrade"' "Unique"'                                      "Table key"' "Table unique key"' "Primary Key"' "Create Table"'                                      "Upgrade Table"' "Rename Table"' "Create View"' "Upgrade View"'                                      "Drop View"' "Create Schema"' "Drop Schema"' "Integer"' "Smallint"'                                      "Bigint"' "Tinyint"' "float"' "double"' "Blob"' "bytes"' "boolean"'                                      "binary"' "varbinary"' "string"' "char"' "text"' "date"' "timestamp"'                                      "time"' "varchar"' "numeric"' "Decimal Number"' "Enum"' "Delete"' "Repair"'                                      "Field"' "Not Null"' "Default Value"' "searchable"' "not searchable"'                                      "collation"' "character_set"' "Foreign Key"' "Identifier"' "record number"'                                      "Insert"' "Replace"' "Name"' "Number"' "Order"' "Descending"' "limit"'                                      "Quoted String"' "Select Clause"' "Distinct"' "Gtr"' "Geq"' "Eql"'                                      "Leq"' "Lss"' "Neq"' "in list"' "in select"' "exists"' "Between"' "Like"'                                      "starts with"' "Containing"' "Matching"' "Regular expression"' "Null"'                                      "True"' "False"' "Execute"' "Parameter"' "Count"' "sum"' "min"' "max"'                                      "avg"' "Drop Index"' "Drop primary key"' "Drop foreign key"' "Drop Table"'                                      "If Exists"' "Describe"' "Statement"' "for_select"' "for_insert"' "while"'                                      "if then else"' "variable"' "declaration"' "throw"' "assignment"'                                      "Start transaction"' "read only"' "read write"' "read committed"' "write committed"'                                      "read uncommitted"' "repeatableread"' "serializable"' "Commit"' "Rollback"'                                      "Savepoint"' "Rollack Savepoint"' "Release Savepoint"' "Table"' "Derived Table"'                                      "Assign"' "Update"' "list"' "Constant"' "Function"' "Grant"' "Grant role"' "Alter"'                                      "Read"' "Identity"' "Check"' "Constraint"' "value constraint"' "auto increment"'                                      "generated"' "always"' "Domain"' "is null"' "is active_role"' "start with"' "reindex"'                                      "cursor"' "alias"' "push_namespace"' "pop_namespace"' "set_namespace"' "coalesce"'                                      "nod_nullif"' "case"' "case_search"' "add"' "subtract"' "multiply"' "divide"' "modulus"'                                      "negate"' "plus"' "cast"' "concatenation"' "create user"' "drop user"' "create role"'                                      "upgrade role"' "drop role"' "revoke"' "revoke role"' "assume"' "revert"' "negate"'                                      "priv insert"' "priv delete"' "priv execute"' "priv select"' "priv update"' "priv grant"'                                      "priv all"' "characters"' "octets"' "role"' "view"' "procedure"' "user"' "zone"' "admin"'                                      "default role"' "create sequence"' "upgrade sequence"' "drop sequence"' "next value"'                                      "create trigger"' "upgrade trigger"' "alter trigger"' "drop trigger"' "create procedure"'                                      "upgrade procedure"' "alter procedure"' "drop procedure"' "pre-insert"' "post-insert"'                                      "pre-update"' "post-update"' "pre-delete"' "post-delete"' "pre-commit"' "post-commit"'                                      "active"' "inactive"' "position"' "select-expr"' "create filterset"' "upgrade filterset"'                                      "drop filterset"' "enable filterset"' "disable filterset"' "table filter"' "left outer"'                                      "right outer"' "full outer"' "inner"' "join"' "join_term"' "trigger class"' "enable trigger class"'                                      "disable trigger class"' "create zone"' "upgrade zone"' "drop zone"' "range"' "ip address"'                                      "node_name"' "wildcard"' "create domain"' "upgrade domain"' "alter domain"' "upgrade schema"'                                      "delete cascade"' "index segment"' "for update"' "write committed"' "read committed"'                                       "consistent read"' "set dialect"' "set names"' "restrict"' "cascade"' "characters"' "octets"'                                      "create event"' "collate"' "truncate"' "restart"' "nameless constraint"' "drop constraint"'                                      "drop unique constraint"' "drop domain"' "with check option"' "not real"' "lower"' "upper"'                                      "substr"' "substring index"' "charlength"' "default keyword"' "sqrt"' "power"' "Scientific Notation Number"'                                      "Explain"' "msleep"' "KillStatement"' "now" };                  table.BeginLoadData();                  foreach (string keyword in words)                  {                      DataRow row = table.NewRow();                      row["ReservedWord"] = keyword;                      table.Rows.Add(row);                  }                  table.EndLoadData();                }              else if (collectionName == DbMetaDataCollectionNames.DataTypes)              {                  table.Columns.Add("TypeName"' typeof(string));  // The provider-specific data type name.                  table.Columns.Add("ProviderDbType"' typeof(int)); // The provider-specific type value that should be used when specifying                   //a parameter's type. For example' SqlDbType.Money or OracleType.Blob.                  table.Columns.Add("ColumnSize"' typeof(long));                  table.Columns.Add("CreateFormat"' typeof(string));                  table.Columns.Add("CreateParameters"' typeof(string));                  table.Columns.Add("DataType"' typeof(string));  // The name of the .NET Framework type of the data type.                  table.Columns.Add("IsAutoincrementable"' typeof(bool));                  table.Columns.Add("IsBestMatch"' typeof(bool));                  table.Columns.Add("IsCaseSensitive"' typeof(bool));                  table.Columns.Add("IsFixedLength"' typeof(bool));                  table.Columns.Add("IsFixedPrecisionScale"' typeof(bool));                  table.Columns.Add("IsLong"' typeof(bool));                  table.Columns.Add("IsNullable"' typeof(bool));                  table.Columns.Add("IsSearchable"' typeof(bool));                  table.Columns.Add("IsSearchableWithLike"' typeof(bool));                  table.Columns.Add("IsUnsigned"' typeof(bool));                  table.Columns.Add("MaximumScale"' typeof(short));                  table.Columns.Add("MinimumScale"' typeof(short));                  table.Columns.Add("IsConcurrencyType"' typeof(bool));                  table.Columns.Add("IsLiteralsSupported"' typeof(bool));                  table.Columns.Add("LiteralPrefix"' typeof(string));                  table.Columns.Add("LiteralSuffix"' typeof(string));                  table.Columns.Add("NativeDataType"' typeof(string));    // NativeDataType is an OLE DB specific column for exposing the OLE DB type of the data type .                    table.ReadXml(XmlReader.Create(typeof(NuoDbConnectionInternal).Assembly.GetManifestResourceStream("NuoDb.Data.Client.DataTypes.xml")));              }              else if (collectionName == "Tables")              {                  table.Columns.Add("TABLE_CATALOG"' typeof(string));                  table.Columns.Add("TABLE_SCHEMA"' typeof(string));                  table.Columns.Add("TABLE_NAME"' typeof(string));                  table.Columns.Add("TABLE_TYPE"' typeof(string));                  table.Columns.Add("REMARKS"' typeof(string));                  table.Columns.Add("VIEW_DEF"' typeof(string));                    tmConn.InternalConnection.dataStream.startMessage(Protocol.GetTables);                  tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                  for (int i = 1; i < 3; i++)                      if (restrictionValues != null && restrictionValues.Length > i)                          tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                      else                          tmConn.InternalConnection.dataStream.encodeNull();                  if (restrictionValues == null || restrictionValues.Length < 4 || restrictionValues[3] == null)                      tmConn.InternalConnection.dataStream.encodeInt(0);                  else                  {                      tmConn.InternalConnection.dataStream.encodeInt(1);                      tmConn.InternalConnection.dataStream.encodeString(restrictionValues[3]);                  }                    tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                  int handle = tmConn.InternalConnection.dataStream.getInt();                    if (handle != -1)                  {                      using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                      {                          table.BeginLoadData();                          string view_def_label="";                          try                           {                               reader.GetOrdinal("VIEW_DEF");                              view_def_label = "VIEW_DEF";                          }                          catch(Exception) {}                          try                           {                               reader.GetOrdinal("VIEWDEFINITION");                              view_def_label = "VIEWDEFINITION";                          }                          catch (Exception) { }                          while (reader.Read())                          {  #if DEBUG                          System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_NAME"] + "' " + reader["TABLE_TYPE"]);  #endif                              DataRow row = table.NewRow();                              row["TABLE_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                              row["TABLE_NAME"] = reader.GetFieldValue<string>("TABLE_NAME");                              row["TABLE_TYPE"] = reader.GetFieldValue<string>("TABLE_TYPE");                              row["REMARKS"] = reader.GetFieldValue<string>("REMARKS");                              if (view_def_label.Length != 0)                              {                                  row["VIEW_DEF"] = reader.GetFieldValue<string>(view_def_label);                              }                              table.Rows.Add(row);                          }                          table.EndLoadData();                      }                  }              }              else if (collectionName == "Columns")              {                  table.Columns.Add("COLUMN_CATALOG"' typeof(string));                  table.Columns.Add("COLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("COLUMN_TABLE"' typeof(string));                  table.Columns.Add("COLUMN_NAME"' typeof(string));                  table.Columns.Add("COLUMN_POSITION"' typeof(int));                  table.Columns.Add("COLUMN_TYPE"' typeof(string));                  table.Columns.Add("COLUMN_LENGTH"' typeof(int));                  table.Columns.Add("COLUMN_PRECISION"' typeof(int));                  table.Columns.Add("COLUMN_NULLABLE"' typeof(bool));                  table.Columns.Add("COLUMN_IDENTITY"' typeof(bool));                  table.Columns.Add("COLUMN_DEFAULT"' typeof(string));                  table.Columns.Add("COLUMN_SCALE"' typeof(int));                    tmConn.InternalConnection.dataStream.startMessage(Protocol.GetColumns);                  tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                  for (int i = 1; i < 4; i++)                      if (restrictionValues != null && restrictionValues.Length > i)                          tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                      else                          tmConn.InternalConnection.dataStream.encodeNull();                    tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                  int handle = tmConn.InternalConnection.dataStream.getInt();                    if (handle != -1)                  {                      using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                      {                          table.BeginLoadData();                          while (reader.Read())                          {                              DataRow row = table.NewRow();                              row["COLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                              row["COLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                              row["COLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                              row["COLUMN_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                              row["COLUMN_LENGTH"] = reader.GetFieldValue<int>("COLUMN_SIZE");                              row["COLUMN_PRECISION"] = reader.GetFieldValue<int>("BUFFER_LENGTH");                              row["COLUMN_SCALE"] = reader.GetFieldValue<int>("DECIMAL_DIGITS");                              if (isNumeric(reader.GetFieldValue<string>("TYPE_NAME")))                              {                                  if (reader.GetFieldValue<int>("DECIMAL_DIGITS") != 0)                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME") +                                           "(" + reader.GetFieldValue<int>("BUFFER_LENGTH") + "'" + reader.GetFieldValue<int>("DECIMAL_DIGITS") + ")";                                  else                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME");                              }                              else                              {                                  if (isVarLenType(reader.GetFieldValue<string>("TYPE_NAME")) && reader.GetFieldValue<int>("COLUMN_SIZE") != 0)                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME") +                                           "(" + reader.GetFieldValue<int>("COLUMN_SIZE") + ")";                                  else                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME");                              }                              if (!reader.IsDBNull(reader.GetOrdinal("IS_NULLABLE")))                                  row["COLUMN_NULLABLE"] = reader.GetFieldValue<string>("IS_NULLABLE").Equals("YES");                              if (!reader.IsDBNull(reader.GetOrdinal("IS_AUTOINCREMENT")))                                  row["COLUMN_IDENTITY"] = reader.GetFieldValue<string>("IS_AUTOINCREMENT").Equals("YES");                              row["COLUMN_DEFAULT"] = reader.GetFieldValue<string>("COLUMN_DEF");    #if DEBUG                              System.Diagnostics.Trace.WriteLine("-> " + row["COLUMN_NAME"] + " " + row["COLUMN_TYPE"]);  #endif                              table.Rows.Add(row);                          }                          table.EndLoadData();                      }                  }              }              else if (collectionName == "Indexes")              {                  table.Columns.Add("INDEX_CATALOG"' typeof(string));                  table.Columns.Add("INDEX_SCHEMA"' typeof(string));                  table.Columns.Add("INDEX_TABLE"' typeof(string));                  table.Columns.Add("INDEX_NAME"' typeof(string));                  table.Columns.Add("INDEX_TYPE"' typeof(string));                  table.Columns.Add("INDEX_UNIQUE"' typeof(bool));                  table.Columns.Add("INDEX_PRIMARY"' typeof(bool));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetIndexInfo);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // unique                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // approximate                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        // to avoid to insert the same index more than once                      HashSet<string> unique = new HashSet<string>();                      if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;                                  if (!unique.Add(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;                                  DataRow row = table.NewRow();                                  row["INDEX_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEX_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEX_NAME"] = reader.GetFieldValue<string>("INDEX_NAME");                                  switch (reader.GetFieldValue<int>("TYPE"))                                  {                                      case 0:                                          row["INDEX_TYPE"] = "Primary";                                          break;                                      case 1:                                          row["INDEX_TYPE"] = "Unique";                                          break;                                      case 2:                                          row["INDEX_TYPE"] = "Secondary";                                          break;                                      case 3:                                          row["INDEX_TYPE"] = "Foreign Key";                                          break;                                  }                                  row["INDEX_UNIQUE"] = (reader.GetFieldValue<int>("NON_UNIQUE") == 0) ? true : false;                                  row["INDEX_PRIMARY"] = (reader.GetFieldValue<int>("TYPE") == 0) ? true : false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                        tmConn.InternalConnection.dataStream.startMessage(Protocol.GetPrimaryKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              // use INDEX_NAME' if present; if missing' the name of the index is in PK_NAME                              string indexName = "PK_NAME";                              foreach (string column in reader.columnNames)                              {                                  if (column == "INDEX_NAME")                                  {                                      indexName = "INDEX_NAME";                                      break;                                  }                              }                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>(indexName)))                                      continue;                                  if (!unique.Add(reader.GetFieldValue<string>(indexName)))                                      continue;                                  DataRow row = table.NewRow();                                  row["INDEX_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEX_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEX_NAME"] = reader.GetFieldValue<string>(indexName);                                  row["INDEX_TYPE"] = "Primary";                                  row["INDEX_UNIQUE"] = true;                                  row["INDEX_PRIMARY"] = true;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "IndexColumns")              {                  table.Columns.Add("INDEXCOLUMN_CATALOG"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_TABLE"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_INDEX"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_NAME"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_POSITION"' typeof(int));                  table.Columns.Add("INDEXCOLUMN_ISPRIMARY"' typeof(bool));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetIndexInfo);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // unique                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // approximate                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_SCHEM"] + "." + reader["TABLE_NAME"] + "=" + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["INDEXCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEXCOLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEXCOLUMN_INDEX"] = reader.GetFieldValue<string>("INDEX_NAME");                                  row["INDEXCOLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["INDEXCOLUMN_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                                  row["INDEXCOLUMN_ISPRIMARY"] = false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                        tmConn.InternalConnection.dataStream.startMessage(Protocol.GetPrimaryKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              // use INDEX_NAME' if present; if missing' the name of the index is in PK_NAME                              string indexName = "PK_NAME";                              foreach (string column in reader.columnNames)                              {                                  if (column == "INDEX_NAME")                                  {                                      indexName = "INDEX_NAME";                                      break;                                  }                              }                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>(indexName)))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_SCHEM"] + "." + reader["TABLE_NAME"] + " (Primary) =" + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["INDEXCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEXCOLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEXCOLUMN_INDEX"] = reader.GetFieldValue<string>(indexName);                                  row["INDEXCOLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["INDEXCOLUMN_POSITION"] = reader.GetFieldValue<int>("KEY_SEQ");                                  row["INDEXCOLUMN_ISPRIMARY"] = true;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ForeignKeys")              {                  table.Columns.Add("FOREIGNKEY_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEY_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEY_TABLE"' typeof(string));                  table.Columns.Add("FOREIGNKEY_NAME"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_TABLE"' typeof(string));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetImportedKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  string name = "[" + reader.GetFieldValue<string>("FKTABLE_SCHEM") + "]" +                                                   reader.GetFieldValue<string>("FKTABLE_NAME") + "." +                                                   reader.GetFieldValue<string>("FKCOLUMN_NAME") + "->" +                                                  "[" + reader.GetFieldValue<string>("PKTABLE_SCHEM") + "]" +                                                   reader.GetFieldValue<string>("PKTABLE_NAME") + "." +                                                   reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(name))                                      continue;                                  DataRow row = table.NewRow();                                  row["FOREIGNKEY_SCHEMA"] = reader.GetFieldValue<string>("FKTABLE_SCHEM");                                  row["FOREIGNKEY_TABLE"] = reader.GetFieldValue<string>("FKTABLE_NAME");                                  row["FOREIGNKEY_NAME"] = name;                                  row["FOREIGNKEY_OTHER_SCHEMA"] = reader.GetFieldValue<string>("PKTABLE_SCHEM");                                  row["FOREIGNKEY_OTHER_TABLE"] = reader.GetFieldValue<string>("PKTABLE_NAME");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ForeignKeyColumns")              {                  table.Columns.Add("FOREIGNKEYCOLUMN_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_TABLE"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_KEY"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_NAME"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_ORDINAL"' typeof(int));                  table.Columns.Add("FOREIGNKEYCOLUMN_OTHER_COLUMN_NAME"' typeof(string));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetImportedKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  string name = "[" + reader.GetFieldValue<string>("FKTABLE_SCHEM") + "]" +                                                  reader.GetFieldValue<string>("FKTABLE_NAME") + "." +                                                  reader.GetFieldValue<string>("FKCOLUMN_NAME") + "->" +                                                  "[" + reader.GetFieldValue<string>("PKTABLE_SCHEM") + "]" +                                                  reader.GetFieldValue<string>("PKTABLE_NAME") + "." +                                                  reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(name))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["FKTABLE_SCHEM"] + "." + reader["FKTABLE_NAME"] + "=" + reader["FKCOLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["FOREIGNKEYCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("FKTABLE_SCHEM");                                  row["FOREIGNKEYCOLUMN_TABLE"] = reader.GetFieldValue<string>("FKTABLE_NAME");                                  row["FOREIGNKEYCOLUMN_KEY"] = name;                                  row["FOREIGNKEYCOLUMN_NAME"] = reader.GetFieldValue<string>("FKCOLUMN_NAME");                                  row["FOREIGNKEYCOLUMN_ORDINAL"] = reader.GetFieldValue<int>("KEY_SEQ");                                  row["FOREIGNKEYCOLUMN_OTHER_COLUMN_NAME"] = reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "Procedures")               {                  table.Columns.Add("PROCEDURE_CATALOG"' typeof(string));                  table.Columns.Add("PROCEDURE_SCHEMA"' typeof(string));                  table.Columns.Add("PROCEDURE_NAME"' typeof(string));                  table.Columns.Add("IS_SYSTEM_PROCEDURE"' typeof(bool));                    if (tmConn.InternalConnection.protocolVersion >= Protocol.PROTOCOL_VERSION12)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetProcedures);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      for (int i = 1; i < 3; i++)                          if (restrictionValues != null && restrictionValues.Length > i)                              tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                          else                              tmConn.InternalConnection.dataStream.encodeNull();                        tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["PROCEDURE_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["PROCEDURE_SCHEMA"] = reader.GetFieldValue<string>("PROCEDURE_SCHEM");                                  row["PROCEDURE_NAME"] = reader.GetFieldValue<string>("PROCEDURE_NAME");                                  row["IS_SYSTEM_PROCEDURE"] = false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ProcedureParameters")              {                  table.Columns.Add("PROCEDURE_CATALOG"' typeof(string));                  table.Columns.Add("PROCEDURE_SCHEMA"' typeof(string));                  table.Columns.Add("PROCEDURE_NAME"' typeof(string));                  table.Columns.Add("PARAMETER_NAME"' typeof(string));                  table.Columns.Add("ORDINAL_POSITION"' typeof(int));                  table.Columns.Add("PARAMETER_DATA_TYPE"' typeof(int));                  table.Columns.Add("PARAMETER_TYPE_NAME"' typeof(string));                  table.Columns.Add("PARAMETER_SIZE"' typeof(int));                  table.Columns.Add("NUMERIC_PRECISION"' typeof(int));                  table.Columns.Add("NUMERIC_SCALE"' typeof(int));                  table.Columns.Add("PARAMETER_DIRECTION"' typeof(int));                  table.Columns.Add("IS_NULLABLE"' typeof(bool));                    if (tmConn.InternalConnection.protocolVersion >= Protocol.PROTOCOL_VERSION12)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetProcedureColumns);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      for (int i = 1; i < 4; i++)                          if (restrictionValues != null && restrictionValues.Length > i)                              tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                          else                              tmConn.InternalConnection.dataStream.encodeNull();                        tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["PROCEDURE_NAME"] + "' " + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["PROCEDURE_SCHEMA"] = reader.GetFieldValue<string>("PROCEDURE_SCHEM");                                  row["PROCEDURE_NAME"] = reader.GetFieldValue<string>("PROCEDURE_NAME");                                  row["PARAMETER_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["ORDINAL_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                                  row["PARAMETER_TYPE_NAME"] = reader.GetFieldValue<string>("TYPE_NAME");                                  row["PARAMETER_DATA_TYPE"] = reader.GetFieldValue<int>("DATA_TYPE");                                  row["PARAMETER_SIZE"] = reader.GetFieldValue<int>("LENGTH");                                  row["NUMERIC_PRECISION"] = reader.GetFieldValue<int>("PRECISION");                                  row["NUMERIC_SCALE"] = reader.GetFieldValue<int>("SCALE");                                  row["PARAMETER_DIRECTION"] = reader.GetFieldValue<int>("COLUMN_TYPE");                                  row["IS_NULLABLE"] = !reader.GetFieldValue<string>("IS_NULLABLE").Equals("NO");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The following statement contains a magic number: if (collectionName == DbMetaDataCollectionNames.DataSourceInformation)              {                  // see http://msdn.microsoft.com/en-us/library/ms254501.aspx                  table.Columns.Add("CompositeIdentifierSeparatorPattern"' typeof(string));                  table.Columns.Add("DataSourceProductName"' typeof(string));                  table.Columns.Add("DataSourceProductVersion"' typeof(string));                  table.Columns.Add("DataSourceProductVersionNormalized"' typeof(string));                  table.Columns.Add("DataSourceInternalProductVersion"' typeof(string));                  table.Columns.Add("GroupByBehavior"' typeof(GroupByBehavior));                  table.Columns.Add("IdentifierPattern"' typeof(string));                  table.Columns.Add("IdentifierCase"' typeof(IdentifierCase));                  table.Columns.Add("OrderByColumnsInSelect"' typeof(bool));                  table.Columns.Add("ParameterMarkerFormat"' typeof(string));                  table.Columns.Add("ParameterMarkerPattern"' typeof(string));                  table.Columns.Add("ParameterNameMaxLength"' typeof(int));                  table.Columns.Add("ParameterNamePattern"' typeof(string));                  table.Columns.Add("QuotedIdentifierPattern"' typeof(string));  // Regex                  table.Columns.Add("QuotedIdentifierCase"' typeof(int));                  table.Columns.Add("StatementSeparatorPattern"' typeof(string));                  table.Columns.Add("StringLiteralPattern"' typeof(string));  // Regex                  table.Columns.Add("SupportedJoinOperators"' typeof(SupportedJoinOperators));                    table.BeginLoadData();                  DataRow row = table.NewRow();                  int databaseMajorVersion = 0' databaseMinorVersion = 0;                  try                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetDatabaseMetaData);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      for (int item; (item = tmConn.InternalConnection.dataStream.getInt()) != Protocol.DbmbFini; )                      {                          switch (item)                          {                              case Protocol.DbmbProductName:                                  row["DataSourceProductName"] = tmConn.InternalConnection.dataStream.getString();                                  break;                                case Protocol.DbmbProductVersion:                                  row["DataSourceProductVersion"] = tmConn.InternalConnection.dataStream.getString();                                  break;                                case Protocol.DbmbDatabaseMinorVersion:                                  databaseMinorVersion = tmConn.InternalConnection.dataStream.getInt();                                  break;                                case Protocol.DbmbDatabaseMajorVersion:                                  databaseMajorVersion = tmConn.InternalConnection.dataStream.getInt();                                  break;                                case Protocol.DbmbDefaultTransactionIsolation:                                  int defaultTransactionIsolation = tmConn.InternalConnection.dataStream.getInt();                                  break;                                default:                                  tmConn.InternalConnection.dataStream.decode();                                  break;                          }                      }                  }                  catch (Exception)                  {                  }                    row["DataSourceInternalProductVersion"] = String.Format("{0:D3}.{1:D3}"' databaseMajorVersion' databaseMinorVersion);                  // The regular expression to match the composite separators in a composite identifier.                   // For example' "\." (for SQL Server) or "@|\." (for Oracle).                  // A composite identifier is typically what is used for a database object name'                   // for example: pubs.dbo.authors or pubs@dbo.authors.                  row["CompositeIdentifierSeparatorPattern"] = "\\.";                  // A normalized version for the data source' such that it can be compared with String.Compare().                   // The format of this is consistent for all versions of the provider to prevent version 10 from sorting between version 1 and version 2.                  //row["DataSourceProductVersionNormalized"] = ??                  // Specifies the relationship between the columns in a GROUP BY clause and the non-aggregated columns in the select list.                  row["GroupByBehavior"] = GroupByBehavior.Unknown;                  // A regular expression that matches an identifier and has a match value of the identifier. For example "[A-Za-z0-9_#$]".                  row["IdentifierPattern"] = "(^\\[\\p{Lo}\\p{Lu}\\p{Ll}_@#][\\p{Lo}\\p{Lu}\\p{Ll}\\p{Nd}@$#_]*$)|(^\"[^\"\\0]|\"\"+\"$)";                  // Indicates whether non-quoted identifiers are treated as case sensitive or not.                  row["IdentifierCase"] = IdentifierCase.Insensitive;                  // Specifies whether columns in an ORDER BY clause must be in the select list.                   // A value of true indicates that they are required to be in the select list'                   // a value of false indicates that they are not required to be in the select list.                  row["OrderByColumnsInSelect"] = false;                  // For data sources that do not expect named parameters and expect the use of the ‘?’ character' the format string                  // can be specified as simply '?'' which would ignore the parameter name.                  row["ParameterMarkerFormat"] = "?";                  // if the data source doesn't support named parameters' this would simply be "?".                  row["ParameterMarkerPattern"] = "?";                  // If the data source does not support named parameters' this property returns zero.                  row["ParameterNameMaxLength"] = 0;                  // A regular expression that matches the valid parameter names                  row["ParameterNamePattern"] = "";                  // A regular expression that matches a quoted identifier and has a match value of the identifier itself without the quotes.                   // For example' if the data source used double-quotes to identify quoted identifiers' this would be: "(([^\"]|\"\")*)".                  row["QuotedIdentifierPattern"] = "\"([^\"]*)\"";                  // Indicates whether quoted identifiers are treated as case sensitive or not.                  row["QuotedIdentifierCase"] = IdentifierCase.Sensitive;                  // A regular expression that matches the statement separator.                  row["StatementSeparatorPattern"] = ";";                  // A regular expression that matches a string literal and has a match value of the literal itself.                   // For example' if the data source used single-quotes to identify strings' this would be: "('([^']|'')*')"'                  row["StringLiteralPattern"] = "'([^']*)'";                  // Specifies what types of SQL join statements are supported by the data source.                  row["SupportedJoinOperators"] = SupportedJoinOperators.None;                  table.Rows.Add(row);                  table.EndLoadData();              }              else if (collectionName == DbMetaDataCollectionNames.ReservedWords)              {                  table.Columns.Add("ReservedWord"' typeof(string));                  table.Columns.Add("MaximumVersion"' typeof(string));                  table.Columns.Add("MinimumVersion"' typeof(string));                    string[] words = { "select"' "Add field"' "Drop field"' "Alter table"' "Alter field"'                                      "Alter user"' "And"' "Or"' "Not"' "Create Index"' "Upgrade"' "Unique"'                                      "Table key"' "Table unique key"' "Primary Key"' "Create Table"'                                      "Upgrade Table"' "Rename Table"' "Create View"' "Upgrade View"'                                      "Drop View"' "Create Schema"' "Drop Schema"' "Integer"' "Smallint"'                                      "Bigint"' "Tinyint"' "float"' "double"' "Blob"' "bytes"' "boolean"'                                      "binary"' "varbinary"' "string"' "char"' "text"' "date"' "timestamp"'                                      "time"' "varchar"' "numeric"' "Decimal Number"' "Enum"' "Delete"' "Repair"'                                      "Field"' "Not Null"' "Default Value"' "searchable"' "not searchable"'                                      "collation"' "character_set"' "Foreign Key"' "Identifier"' "record number"'                                      "Insert"' "Replace"' "Name"' "Number"' "Order"' "Descending"' "limit"'                                      "Quoted String"' "Select Clause"' "Distinct"' "Gtr"' "Geq"' "Eql"'                                      "Leq"' "Lss"' "Neq"' "in list"' "in select"' "exists"' "Between"' "Like"'                                      "starts with"' "Containing"' "Matching"' "Regular expression"' "Null"'                                      "True"' "False"' "Execute"' "Parameter"' "Count"' "sum"' "min"' "max"'                                      "avg"' "Drop Index"' "Drop primary key"' "Drop foreign key"' "Drop Table"'                                      "If Exists"' "Describe"' "Statement"' "for_select"' "for_insert"' "while"'                                      "if then else"' "variable"' "declaration"' "throw"' "assignment"'                                      "Start transaction"' "read only"' "read write"' "read committed"' "write committed"'                                      "read uncommitted"' "repeatableread"' "serializable"' "Commit"' "Rollback"'                                      "Savepoint"' "Rollack Savepoint"' "Release Savepoint"' "Table"' "Derived Table"'                                      "Assign"' "Update"' "list"' "Constant"' "Function"' "Grant"' "Grant role"' "Alter"'                                      "Read"' "Identity"' "Check"' "Constraint"' "value constraint"' "auto increment"'                                      "generated"' "always"' "Domain"' "is null"' "is active_role"' "start with"' "reindex"'                                      "cursor"' "alias"' "push_namespace"' "pop_namespace"' "set_namespace"' "coalesce"'                                      "nod_nullif"' "case"' "case_search"' "add"' "subtract"' "multiply"' "divide"' "modulus"'                                      "negate"' "plus"' "cast"' "concatenation"' "create user"' "drop user"' "create role"'                                      "upgrade role"' "drop role"' "revoke"' "revoke role"' "assume"' "revert"' "negate"'                                      "priv insert"' "priv delete"' "priv execute"' "priv select"' "priv update"' "priv grant"'                                      "priv all"' "characters"' "octets"' "role"' "view"' "procedure"' "user"' "zone"' "admin"'                                      "default role"' "create sequence"' "upgrade sequence"' "drop sequence"' "next value"'                                      "create trigger"' "upgrade trigger"' "alter trigger"' "drop trigger"' "create procedure"'                                      "upgrade procedure"' "alter procedure"' "drop procedure"' "pre-insert"' "post-insert"'                                      "pre-update"' "post-update"' "pre-delete"' "post-delete"' "pre-commit"' "post-commit"'                                      "active"' "inactive"' "position"' "select-expr"' "create filterset"' "upgrade filterset"'                                      "drop filterset"' "enable filterset"' "disable filterset"' "table filter"' "left outer"'                                      "right outer"' "full outer"' "inner"' "join"' "join_term"' "trigger class"' "enable trigger class"'                                      "disable trigger class"' "create zone"' "upgrade zone"' "drop zone"' "range"' "ip address"'                                      "node_name"' "wildcard"' "create domain"' "upgrade domain"' "alter domain"' "upgrade schema"'                                      "delete cascade"' "index segment"' "for update"' "write committed"' "read committed"'                                       "consistent read"' "set dialect"' "set names"' "restrict"' "cascade"' "characters"' "octets"'                                      "create event"' "collate"' "truncate"' "restart"' "nameless constraint"' "drop constraint"'                                      "drop unique constraint"' "drop domain"' "with check option"' "not real"' "lower"' "upper"'                                      "substr"' "substring index"' "charlength"' "default keyword"' "sqrt"' "power"' "Scientific Notation Number"'                                      "Explain"' "msleep"' "KillStatement"' "now" };                  table.BeginLoadData();                  foreach (string keyword in words)                  {                      DataRow row = table.NewRow();                      row["ReservedWord"] = keyword;                      table.Rows.Add(row);                  }                  table.EndLoadData();                }              else if (collectionName == DbMetaDataCollectionNames.DataTypes)              {                  table.Columns.Add("TypeName"' typeof(string));  // The provider-specific data type name.                  table.Columns.Add("ProviderDbType"' typeof(int)); // The provider-specific type value that should be used when specifying                   //a parameter's type. For example' SqlDbType.Money or OracleType.Blob.                  table.Columns.Add("ColumnSize"' typeof(long));                  table.Columns.Add("CreateFormat"' typeof(string));                  table.Columns.Add("CreateParameters"' typeof(string));                  table.Columns.Add("DataType"' typeof(string));  // The name of the .NET Framework type of the data type.                  table.Columns.Add("IsAutoincrementable"' typeof(bool));                  table.Columns.Add("IsBestMatch"' typeof(bool));                  table.Columns.Add("IsCaseSensitive"' typeof(bool));                  table.Columns.Add("IsFixedLength"' typeof(bool));                  table.Columns.Add("IsFixedPrecisionScale"' typeof(bool));                  table.Columns.Add("IsLong"' typeof(bool));                  table.Columns.Add("IsNullable"' typeof(bool));                  table.Columns.Add("IsSearchable"' typeof(bool));                  table.Columns.Add("IsSearchableWithLike"' typeof(bool));                  table.Columns.Add("IsUnsigned"' typeof(bool));                  table.Columns.Add("MaximumScale"' typeof(short));                  table.Columns.Add("MinimumScale"' typeof(short));                  table.Columns.Add("IsConcurrencyType"' typeof(bool));                  table.Columns.Add("IsLiteralsSupported"' typeof(bool));                  table.Columns.Add("LiteralPrefix"' typeof(string));                  table.Columns.Add("LiteralSuffix"' typeof(string));                  table.Columns.Add("NativeDataType"' typeof(string));    // NativeDataType is an OLE DB specific column for exposing the OLE DB type of the data type .                    table.ReadXml(XmlReader.Create(typeof(NuoDbConnectionInternal).Assembly.GetManifestResourceStream("NuoDb.Data.Client.DataTypes.xml")));              }              else if (collectionName == "Tables")              {                  table.Columns.Add("TABLE_CATALOG"' typeof(string));                  table.Columns.Add("TABLE_SCHEMA"' typeof(string));                  table.Columns.Add("TABLE_NAME"' typeof(string));                  table.Columns.Add("TABLE_TYPE"' typeof(string));                  table.Columns.Add("REMARKS"' typeof(string));                  table.Columns.Add("VIEW_DEF"' typeof(string));                    tmConn.InternalConnection.dataStream.startMessage(Protocol.GetTables);                  tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                  for (int i = 1; i < 3; i++)                      if (restrictionValues != null && restrictionValues.Length > i)                          tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                      else                          tmConn.InternalConnection.dataStream.encodeNull();                  if (restrictionValues == null || restrictionValues.Length < 4 || restrictionValues[3] == null)                      tmConn.InternalConnection.dataStream.encodeInt(0);                  else                  {                      tmConn.InternalConnection.dataStream.encodeInt(1);                      tmConn.InternalConnection.dataStream.encodeString(restrictionValues[3]);                  }                    tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                  int handle = tmConn.InternalConnection.dataStream.getInt();                    if (handle != -1)                  {                      using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                      {                          table.BeginLoadData();                          string view_def_label="";                          try                           {                               reader.GetOrdinal("VIEW_DEF");                              view_def_label = "VIEW_DEF";                          }                          catch(Exception) {}                          try                           {                               reader.GetOrdinal("VIEWDEFINITION");                              view_def_label = "VIEWDEFINITION";                          }                          catch (Exception) { }                          while (reader.Read())                          {  #if DEBUG                          System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_NAME"] + "' " + reader["TABLE_TYPE"]);  #endif                              DataRow row = table.NewRow();                              row["TABLE_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                              row["TABLE_NAME"] = reader.GetFieldValue<string>("TABLE_NAME");                              row["TABLE_TYPE"] = reader.GetFieldValue<string>("TABLE_TYPE");                              row["REMARKS"] = reader.GetFieldValue<string>("REMARKS");                              if (view_def_label.Length != 0)                              {                                  row["VIEW_DEF"] = reader.GetFieldValue<string>(view_def_label);                              }                              table.Rows.Add(row);                          }                          table.EndLoadData();                      }                  }              }              else if (collectionName == "Columns")              {                  table.Columns.Add("COLUMN_CATALOG"' typeof(string));                  table.Columns.Add("COLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("COLUMN_TABLE"' typeof(string));                  table.Columns.Add("COLUMN_NAME"' typeof(string));                  table.Columns.Add("COLUMN_POSITION"' typeof(int));                  table.Columns.Add("COLUMN_TYPE"' typeof(string));                  table.Columns.Add("COLUMN_LENGTH"' typeof(int));                  table.Columns.Add("COLUMN_PRECISION"' typeof(int));                  table.Columns.Add("COLUMN_NULLABLE"' typeof(bool));                  table.Columns.Add("COLUMN_IDENTITY"' typeof(bool));                  table.Columns.Add("COLUMN_DEFAULT"' typeof(string));                  table.Columns.Add("COLUMN_SCALE"' typeof(int));                    tmConn.InternalConnection.dataStream.startMessage(Protocol.GetColumns);                  tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                  for (int i = 1; i < 4; i++)                      if (restrictionValues != null && restrictionValues.Length > i)                          tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                      else                          tmConn.InternalConnection.dataStream.encodeNull();                    tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                  int handle = tmConn.InternalConnection.dataStream.getInt();                    if (handle != -1)                  {                      using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                      {                          table.BeginLoadData();                          while (reader.Read())                          {                              DataRow row = table.NewRow();                              row["COLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                              row["COLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                              row["COLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                              row["COLUMN_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                              row["COLUMN_LENGTH"] = reader.GetFieldValue<int>("COLUMN_SIZE");                              row["COLUMN_PRECISION"] = reader.GetFieldValue<int>("BUFFER_LENGTH");                              row["COLUMN_SCALE"] = reader.GetFieldValue<int>("DECIMAL_DIGITS");                              if (isNumeric(reader.GetFieldValue<string>("TYPE_NAME")))                              {                                  if (reader.GetFieldValue<int>("DECIMAL_DIGITS") != 0)                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME") +                                           "(" + reader.GetFieldValue<int>("BUFFER_LENGTH") + "'" + reader.GetFieldValue<int>("DECIMAL_DIGITS") + ")";                                  else                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME");                              }                              else                              {                                  if (isVarLenType(reader.GetFieldValue<string>("TYPE_NAME")) && reader.GetFieldValue<int>("COLUMN_SIZE") != 0)                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME") +                                           "(" + reader.GetFieldValue<int>("COLUMN_SIZE") + ")";                                  else                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME");                              }                              if (!reader.IsDBNull(reader.GetOrdinal("IS_NULLABLE")))                                  row["COLUMN_NULLABLE"] = reader.GetFieldValue<string>("IS_NULLABLE").Equals("YES");                              if (!reader.IsDBNull(reader.GetOrdinal("IS_AUTOINCREMENT")))                                  row["COLUMN_IDENTITY"] = reader.GetFieldValue<string>("IS_AUTOINCREMENT").Equals("YES");                              row["COLUMN_DEFAULT"] = reader.GetFieldValue<string>("COLUMN_DEF");    #if DEBUG                              System.Diagnostics.Trace.WriteLine("-> " + row["COLUMN_NAME"] + " " + row["COLUMN_TYPE"]);  #endif                              table.Rows.Add(row);                          }                          table.EndLoadData();                      }                  }              }              else if (collectionName == "Indexes")              {                  table.Columns.Add("INDEX_CATALOG"' typeof(string));                  table.Columns.Add("INDEX_SCHEMA"' typeof(string));                  table.Columns.Add("INDEX_TABLE"' typeof(string));                  table.Columns.Add("INDEX_NAME"' typeof(string));                  table.Columns.Add("INDEX_TYPE"' typeof(string));                  table.Columns.Add("INDEX_UNIQUE"' typeof(bool));                  table.Columns.Add("INDEX_PRIMARY"' typeof(bool));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetIndexInfo);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // unique                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // approximate                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        // to avoid to insert the same index more than once                      HashSet<string> unique = new HashSet<string>();                      if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;                                  if (!unique.Add(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;                                  DataRow row = table.NewRow();                                  row["INDEX_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEX_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEX_NAME"] = reader.GetFieldValue<string>("INDEX_NAME");                                  switch (reader.GetFieldValue<int>("TYPE"))                                  {                                      case 0:                                          row["INDEX_TYPE"] = "Primary";                                          break;                                      case 1:                                          row["INDEX_TYPE"] = "Unique";                                          break;                                      case 2:                                          row["INDEX_TYPE"] = "Secondary";                                          break;                                      case 3:                                          row["INDEX_TYPE"] = "Foreign Key";                                          break;                                  }                                  row["INDEX_UNIQUE"] = (reader.GetFieldValue<int>("NON_UNIQUE") == 0) ? true : false;                                  row["INDEX_PRIMARY"] = (reader.GetFieldValue<int>("TYPE") == 0) ? true : false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                        tmConn.InternalConnection.dataStream.startMessage(Protocol.GetPrimaryKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              // use INDEX_NAME' if present; if missing' the name of the index is in PK_NAME                              string indexName = "PK_NAME";                              foreach (string column in reader.columnNames)                              {                                  if (column == "INDEX_NAME")                                  {                                      indexName = "INDEX_NAME";                                      break;                                  }                              }                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>(indexName)))                                      continue;                                  if (!unique.Add(reader.GetFieldValue<string>(indexName)))                                      continue;                                  DataRow row = table.NewRow();                                  row["INDEX_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEX_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEX_NAME"] = reader.GetFieldValue<string>(indexName);                                  row["INDEX_TYPE"] = "Primary";                                  row["INDEX_UNIQUE"] = true;                                  row["INDEX_PRIMARY"] = true;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "IndexColumns")              {                  table.Columns.Add("INDEXCOLUMN_CATALOG"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_TABLE"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_INDEX"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_NAME"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_POSITION"' typeof(int));                  table.Columns.Add("INDEXCOLUMN_ISPRIMARY"' typeof(bool));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetIndexInfo);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // unique                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // approximate                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_SCHEM"] + "." + reader["TABLE_NAME"] + "=" + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["INDEXCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEXCOLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEXCOLUMN_INDEX"] = reader.GetFieldValue<string>("INDEX_NAME");                                  row["INDEXCOLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["INDEXCOLUMN_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                                  row["INDEXCOLUMN_ISPRIMARY"] = false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                        tmConn.InternalConnection.dataStream.startMessage(Protocol.GetPrimaryKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              // use INDEX_NAME' if present; if missing' the name of the index is in PK_NAME                              string indexName = "PK_NAME";                              foreach (string column in reader.columnNames)                              {                                  if (column == "INDEX_NAME")                                  {                                      indexName = "INDEX_NAME";                                      break;                                  }                              }                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>(indexName)))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_SCHEM"] + "." + reader["TABLE_NAME"] + " (Primary) =" + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["INDEXCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEXCOLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEXCOLUMN_INDEX"] = reader.GetFieldValue<string>(indexName);                                  row["INDEXCOLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["INDEXCOLUMN_POSITION"] = reader.GetFieldValue<int>("KEY_SEQ");                                  row["INDEXCOLUMN_ISPRIMARY"] = true;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ForeignKeys")              {                  table.Columns.Add("FOREIGNKEY_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEY_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEY_TABLE"' typeof(string));                  table.Columns.Add("FOREIGNKEY_NAME"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_TABLE"' typeof(string));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetImportedKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  string name = "[" + reader.GetFieldValue<string>("FKTABLE_SCHEM") + "]" +                                                   reader.GetFieldValue<string>("FKTABLE_NAME") + "." +                                                   reader.GetFieldValue<string>("FKCOLUMN_NAME") + "->" +                                                  "[" + reader.GetFieldValue<string>("PKTABLE_SCHEM") + "]" +                                                   reader.GetFieldValue<string>("PKTABLE_NAME") + "." +                                                   reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(name))                                      continue;                                  DataRow row = table.NewRow();                                  row["FOREIGNKEY_SCHEMA"] = reader.GetFieldValue<string>("FKTABLE_SCHEM");                                  row["FOREIGNKEY_TABLE"] = reader.GetFieldValue<string>("FKTABLE_NAME");                                  row["FOREIGNKEY_NAME"] = name;                                  row["FOREIGNKEY_OTHER_SCHEMA"] = reader.GetFieldValue<string>("PKTABLE_SCHEM");                                  row["FOREIGNKEY_OTHER_TABLE"] = reader.GetFieldValue<string>("PKTABLE_NAME");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ForeignKeyColumns")              {                  table.Columns.Add("FOREIGNKEYCOLUMN_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_TABLE"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_KEY"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_NAME"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_ORDINAL"' typeof(int));                  table.Columns.Add("FOREIGNKEYCOLUMN_OTHER_COLUMN_NAME"' typeof(string));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetImportedKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  string name = "[" + reader.GetFieldValue<string>("FKTABLE_SCHEM") + "]" +                                                  reader.GetFieldValue<string>("FKTABLE_NAME") + "." +                                                  reader.GetFieldValue<string>("FKCOLUMN_NAME") + "->" +                                                  "[" + reader.GetFieldValue<string>("PKTABLE_SCHEM") + "]" +                                                  reader.GetFieldValue<string>("PKTABLE_NAME") + "." +                                                  reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(name))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["FKTABLE_SCHEM"] + "." + reader["FKTABLE_NAME"] + "=" + reader["FKCOLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["FOREIGNKEYCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("FKTABLE_SCHEM");                                  row["FOREIGNKEYCOLUMN_TABLE"] = reader.GetFieldValue<string>("FKTABLE_NAME");                                  row["FOREIGNKEYCOLUMN_KEY"] = name;                                  row["FOREIGNKEYCOLUMN_NAME"] = reader.GetFieldValue<string>("FKCOLUMN_NAME");                                  row["FOREIGNKEYCOLUMN_ORDINAL"] = reader.GetFieldValue<int>("KEY_SEQ");                                  row["FOREIGNKEYCOLUMN_OTHER_COLUMN_NAME"] = reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "Procedures")               {                  table.Columns.Add("PROCEDURE_CATALOG"' typeof(string));                  table.Columns.Add("PROCEDURE_SCHEMA"' typeof(string));                  table.Columns.Add("PROCEDURE_NAME"' typeof(string));                  table.Columns.Add("IS_SYSTEM_PROCEDURE"' typeof(bool));                    if (tmConn.InternalConnection.protocolVersion >= Protocol.PROTOCOL_VERSION12)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetProcedures);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      for (int i = 1; i < 3; i++)                          if (restrictionValues != null && restrictionValues.Length > i)                              tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                          else                              tmConn.InternalConnection.dataStream.encodeNull();                        tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["PROCEDURE_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["PROCEDURE_SCHEMA"] = reader.GetFieldValue<string>("PROCEDURE_SCHEM");                                  row["PROCEDURE_NAME"] = reader.GetFieldValue<string>("PROCEDURE_NAME");                                  row["IS_SYSTEM_PROCEDURE"] = false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ProcedureParameters")              {                  table.Columns.Add("PROCEDURE_CATALOG"' typeof(string));                  table.Columns.Add("PROCEDURE_SCHEMA"' typeof(string));                  table.Columns.Add("PROCEDURE_NAME"' typeof(string));                  table.Columns.Add("PARAMETER_NAME"' typeof(string));                  table.Columns.Add("ORDINAL_POSITION"' typeof(int));                  table.Columns.Add("PARAMETER_DATA_TYPE"' typeof(int));                  table.Columns.Add("PARAMETER_TYPE_NAME"' typeof(string));                  table.Columns.Add("PARAMETER_SIZE"' typeof(int));                  table.Columns.Add("NUMERIC_PRECISION"' typeof(int));                  table.Columns.Add("NUMERIC_SCALE"' typeof(int));                  table.Columns.Add("PARAMETER_DIRECTION"' typeof(int));                  table.Columns.Add("IS_NULLABLE"' typeof(bool));                    if (tmConn.InternalConnection.protocolVersion >= Protocol.PROTOCOL_VERSION12)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetProcedureColumns);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      for (int i = 1; i < 4; i++)                          if (restrictionValues != null && restrictionValues.Length > i)                              tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                          else                              tmConn.InternalConnection.dataStream.encodeNull();                        tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["PROCEDURE_NAME"] + "' " + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["PROCEDURE_SCHEMA"] = reader.GetFieldValue<string>("PROCEDURE_SCHEM");                                  row["PROCEDURE_NAME"] = reader.GetFieldValue<string>("PROCEDURE_NAME");                                  row["PARAMETER_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["ORDINAL_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                                  row["PARAMETER_TYPE_NAME"] = reader.GetFieldValue<string>("TYPE_NAME");                                  row["PARAMETER_DATA_TYPE"] = reader.GetFieldValue<int>("DATA_TYPE");                                  row["PARAMETER_SIZE"] = reader.GetFieldValue<int>("LENGTH");                                  row["NUMERIC_PRECISION"] = reader.GetFieldValue<int>("PRECISION");                                  row["NUMERIC_SCALE"] = reader.GetFieldValue<int>("SCALE");                                  row["PARAMETER_DIRECTION"] = reader.GetFieldValue<int>("COLUMN_TYPE");                                  row["IS_NULLABLE"] = !reader.GetFieldValue<string>("IS_NULLABLE").Equals("NO");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The following statement contains a magic number: if (collectionName == DbMetaDataCollectionNames.DataSourceInformation)              {                  // see http://msdn.microsoft.com/en-us/library/ms254501.aspx                  table.Columns.Add("CompositeIdentifierSeparatorPattern"' typeof(string));                  table.Columns.Add("DataSourceProductName"' typeof(string));                  table.Columns.Add("DataSourceProductVersion"' typeof(string));                  table.Columns.Add("DataSourceProductVersionNormalized"' typeof(string));                  table.Columns.Add("DataSourceInternalProductVersion"' typeof(string));                  table.Columns.Add("GroupByBehavior"' typeof(GroupByBehavior));                  table.Columns.Add("IdentifierPattern"' typeof(string));                  table.Columns.Add("IdentifierCase"' typeof(IdentifierCase));                  table.Columns.Add("OrderByColumnsInSelect"' typeof(bool));                  table.Columns.Add("ParameterMarkerFormat"' typeof(string));                  table.Columns.Add("ParameterMarkerPattern"' typeof(string));                  table.Columns.Add("ParameterNameMaxLength"' typeof(int));                  table.Columns.Add("ParameterNamePattern"' typeof(string));                  table.Columns.Add("QuotedIdentifierPattern"' typeof(string));  // Regex                  table.Columns.Add("QuotedIdentifierCase"' typeof(int));                  table.Columns.Add("StatementSeparatorPattern"' typeof(string));                  table.Columns.Add("StringLiteralPattern"' typeof(string));  // Regex                  table.Columns.Add("SupportedJoinOperators"' typeof(SupportedJoinOperators));                    table.BeginLoadData();                  DataRow row = table.NewRow();                  int databaseMajorVersion = 0' databaseMinorVersion = 0;                  try                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetDatabaseMetaData);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      for (int item; (item = tmConn.InternalConnection.dataStream.getInt()) != Protocol.DbmbFini; )                      {                          switch (item)                          {                              case Protocol.DbmbProductName:                                  row["DataSourceProductName"] = tmConn.InternalConnection.dataStream.getString();                                  break;                                case Protocol.DbmbProductVersion:                                  row["DataSourceProductVersion"] = tmConn.InternalConnection.dataStream.getString();                                  break;                                case Protocol.DbmbDatabaseMinorVersion:                                  databaseMinorVersion = tmConn.InternalConnection.dataStream.getInt();                                  break;                                case Protocol.DbmbDatabaseMajorVersion:                                  databaseMajorVersion = tmConn.InternalConnection.dataStream.getInt();                                  break;                                case Protocol.DbmbDefaultTransactionIsolation:                                  int defaultTransactionIsolation = tmConn.InternalConnection.dataStream.getInt();                                  break;                                default:                                  tmConn.InternalConnection.dataStream.decode();                                  break;                          }                      }                  }                  catch (Exception)                  {                  }                    row["DataSourceInternalProductVersion"] = String.Format("{0:D3}.{1:D3}"' databaseMajorVersion' databaseMinorVersion);                  // The regular expression to match the composite separators in a composite identifier.                   // For example' "\." (for SQL Server) or "@|\." (for Oracle).                  // A composite identifier is typically what is used for a database object name'                   // for example: pubs.dbo.authors or pubs@dbo.authors.                  row["CompositeIdentifierSeparatorPattern"] = "\\.";                  // A normalized version for the data source' such that it can be compared with String.Compare().                   // The format of this is consistent for all versions of the provider to prevent version 10 from sorting between version 1 and version 2.                  //row["DataSourceProductVersionNormalized"] = ??                  // Specifies the relationship between the columns in a GROUP BY clause and the non-aggregated columns in the select list.                  row["GroupByBehavior"] = GroupByBehavior.Unknown;                  // A regular expression that matches an identifier and has a match value of the identifier. For example "[A-Za-z0-9_#$]".                  row["IdentifierPattern"] = "(^\\[\\p{Lo}\\p{Lu}\\p{Ll}_@#][\\p{Lo}\\p{Lu}\\p{Ll}\\p{Nd}@$#_]*$)|(^\"[^\"\\0]|\"\"+\"$)";                  // Indicates whether non-quoted identifiers are treated as case sensitive or not.                  row["IdentifierCase"] = IdentifierCase.Insensitive;                  // Specifies whether columns in an ORDER BY clause must be in the select list.                   // A value of true indicates that they are required to be in the select list'                   // a value of false indicates that they are not required to be in the select list.                  row["OrderByColumnsInSelect"] = false;                  // For data sources that do not expect named parameters and expect the use of the ‘?’ character' the format string                  // can be specified as simply '?'' which would ignore the parameter name.                  row["ParameterMarkerFormat"] = "?";                  // if the data source doesn't support named parameters' this would simply be "?".                  row["ParameterMarkerPattern"] = "?";                  // If the data source does not support named parameters' this property returns zero.                  row["ParameterNameMaxLength"] = 0;                  // A regular expression that matches the valid parameter names                  row["ParameterNamePattern"] = "";                  // A regular expression that matches a quoted identifier and has a match value of the identifier itself without the quotes.                   // For example' if the data source used double-quotes to identify quoted identifiers' this would be: "(([^\"]|\"\")*)".                  row["QuotedIdentifierPattern"] = "\"([^\"]*)\"";                  // Indicates whether quoted identifiers are treated as case sensitive or not.                  row["QuotedIdentifierCase"] = IdentifierCase.Sensitive;                  // A regular expression that matches the statement separator.                  row["StatementSeparatorPattern"] = ";";                  // A regular expression that matches a string literal and has a match value of the literal itself.                   // For example' if the data source used single-quotes to identify strings' this would be: "('([^']|'')*')"'                  row["StringLiteralPattern"] = "'([^']*)'";                  // Specifies what types of SQL join statements are supported by the data source.                  row["SupportedJoinOperators"] = SupportedJoinOperators.None;                  table.Rows.Add(row);                  table.EndLoadData();              }              else if (collectionName == DbMetaDataCollectionNames.ReservedWords)              {                  table.Columns.Add("ReservedWord"' typeof(string));                  table.Columns.Add("MaximumVersion"' typeof(string));                  table.Columns.Add("MinimumVersion"' typeof(string));                    string[] words = { "select"' "Add field"' "Drop field"' "Alter table"' "Alter field"'                                      "Alter user"' "And"' "Or"' "Not"' "Create Index"' "Upgrade"' "Unique"'                                      "Table key"' "Table unique key"' "Primary Key"' "Create Table"'                                      "Upgrade Table"' "Rename Table"' "Create View"' "Upgrade View"'                                      "Drop View"' "Create Schema"' "Drop Schema"' "Integer"' "Smallint"'                                      "Bigint"' "Tinyint"' "float"' "double"' "Blob"' "bytes"' "boolean"'                                      "binary"' "varbinary"' "string"' "char"' "text"' "date"' "timestamp"'                                      "time"' "varchar"' "numeric"' "Decimal Number"' "Enum"' "Delete"' "Repair"'                                      "Field"' "Not Null"' "Default Value"' "searchable"' "not searchable"'                                      "collation"' "character_set"' "Foreign Key"' "Identifier"' "record number"'                                      "Insert"' "Replace"' "Name"' "Number"' "Order"' "Descending"' "limit"'                                      "Quoted String"' "Select Clause"' "Distinct"' "Gtr"' "Geq"' "Eql"'                                      "Leq"' "Lss"' "Neq"' "in list"' "in select"' "exists"' "Between"' "Like"'                                      "starts with"' "Containing"' "Matching"' "Regular expression"' "Null"'                                      "True"' "False"' "Execute"' "Parameter"' "Count"' "sum"' "min"' "max"'                                      "avg"' "Drop Index"' "Drop primary key"' "Drop foreign key"' "Drop Table"'                                      "If Exists"' "Describe"' "Statement"' "for_select"' "for_insert"' "while"'                                      "if then else"' "variable"' "declaration"' "throw"' "assignment"'                                      "Start transaction"' "read only"' "read write"' "read committed"' "write committed"'                                      "read uncommitted"' "repeatableread"' "serializable"' "Commit"' "Rollback"'                                      "Savepoint"' "Rollack Savepoint"' "Release Savepoint"' "Table"' "Derived Table"'                                      "Assign"' "Update"' "list"' "Constant"' "Function"' "Grant"' "Grant role"' "Alter"'                                      "Read"' "Identity"' "Check"' "Constraint"' "value constraint"' "auto increment"'                                      "generated"' "always"' "Domain"' "is null"' "is active_role"' "start with"' "reindex"'                                      "cursor"' "alias"' "push_namespace"' "pop_namespace"' "set_namespace"' "coalesce"'                                      "nod_nullif"' "case"' "case_search"' "add"' "subtract"' "multiply"' "divide"' "modulus"'                                      "negate"' "plus"' "cast"' "concatenation"' "create user"' "drop user"' "create role"'                                      "upgrade role"' "drop role"' "revoke"' "revoke role"' "assume"' "revert"' "negate"'                                      "priv insert"' "priv delete"' "priv execute"' "priv select"' "priv update"' "priv grant"'                                      "priv all"' "characters"' "octets"' "role"' "view"' "procedure"' "user"' "zone"' "admin"'                                      "default role"' "create sequence"' "upgrade sequence"' "drop sequence"' "next value"'                                      "create trigger"' "upgrade trigger"' "alter trigger"' "drop trigger"' "create procedure"'                                      "upgrade procedure"' "alter procedure"' "drop procedure"' "pre-insert"' "post-insert"'                                      "pre-update"' "post-update"' "pre-delete"' "post-delete"' "pre-commit"' "post-commit"'                                      "active"' "inactive"' "position"' "select-expr"' "create filterset"' "upgrade filterset"'                                      "drop filterset"' "enable filterset"' "disable filterset"' "table filter"' "left outer"'                                      "right outer"' "full outer"' "inner"' "join"' "join_term"' "trigger class"' "enable trigger class"'                                      "disable trigger class"' "create zone"' "upgrade zone"' "drop zone"' "range"' "ip address"'                                      "node_name"' "wildcard"' "create domain"' "upgrade domain"' "alter domain"' "upgrade schema"'                                      "delete cascade"' "index segment"' "for update"' "write committed"' "read committed"'                                       "consistent read"' "set dialect"' "set names"' "restrict"' "cascade"' "characters"' "octets"'                                      "create event"' "collate"' "truncate"' "restart"' "nameless constraint"' "drop constraint"'                                      "drop unique constraint"' "drop domain"' "with check option"' "not real"' "lower"' "upper"'                                      "substr"' "substring index"' "charlength"' "default keyword"' "sqrt"' "power"' "Scientific Notation Number"'                                      "Explain"' "msleep"' "KillStatement"' "now" };                  table.BeginLoadData();                  foreach (string keyword in words)                  {                      DataRow row = table.NewRow();                      row["ReservedWord"] = keyword;                      table.Rows.Add(row);                  }                  table.EndLoadData();                }              else if (collectionName == DbMetaDataCollectionNames.DataTypes)              {                  table.Columns.Add("TypeName"' typeof(string));  // The provider-specific data type name.                  table.Columns.Add("ProviderDbType"' typeof(int)); // The provider-specific type value that should be used when specifying                   //a parameter's type. For example' SqlDbType.Money or OracleType.Blob.                  table.Columns.Add("ColumnSize"' typeof(long));                  table.Columns.Add("CreateFormat"' typeof(string));                  table.Columns.Add("CreateParameters"' typeof(string));                  table.Columns.Add("DataType"' typeof(string));  // The name of the .NET Framework type of the data type.                  table.Columns.Add("IsAutoincrementable"' typeof(bool));                  table.Columns.Add("IsBestMatch"' typeof(bool));                  table.Columns.Add("IsCaseSensitive"' typeof(bool));                  table.Columns.Add("IsFixedLength"' typeof(bool));                  table.Columns.Add("IsFixedPrecisionScale"' typeof(bool));                  table.Columns.Add("IsLong"' typeof(bool));                  table.Columns.Add("IsNullable"' typeof(bool));                  table.Columns.Add("IsSearchable"' typeof(bool));                  table.Columns.Add("IsSearchableWithLike"' typeof(bool));                  table.Columns.Add("IsUnsigned"' typeof(bool));                  table.Columns.Add("MaximumScale"' typeof(short));                  table.Columns.Add("MinimumScale"' typeof(short));                  table.Columns.Add("IsConcurrencyType"' typeof(bool));                  table.Columns.Add("IsLiteralsSupported"' typeof(bool));                  table.Columns.Add("LiteralPrefix"' typeof(string));                  table.Columns.Add("LiteralSuffix"' typeof(string));                  table.Columns.Add("NativeDataType"' typeof(string));    // NativeDataType is an OLE DB specific column for exposing the OLE DB type of the data type .                    table.ReadXml(XmlReader.Create(typeof(NuoDbConnectionInternal).Assembly.GetManifestResourceStream("NuoDb.Data.Client.DataTypes.xml")));              }              else if (collectionName == "Tables")              {                  table.Columns.Add("TABLE_CATALOG"' typeof(string));                  table.Columns.Add("TABLE_SCHEMA"' typeof(string));                  table.Columns.Add("TABLE_NAME"' typeof(string));                  table.Columns.Add("TABLE_TYPE"' typeof(string));                  table.Columns.Add("REMARKS"' typeof(string));                  table.Columns.Add("VIEW_DEF"' typeof(string));                    tmConn.InternalConnection.dataStream.startMessage(Protocol.GetTables);                  tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                  for (int i = 1; i < 3; i++)                      if (restrictionValues != null && restrictionValues.Length > i)                          tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                      else                          tmConn.InternalConnection.dataStream.encodeNull();                  if (restrictionValues == null || restrictionValues.Length < 4 || restrictionValues[3] == null)                      tmConn.InternalConnection.dataStream.encodeInt(0);                  else                  {                      tmConn.InternalConnection.dataStream.encodeInt(1);                      tmConn.InternalConnection.dataStream.encodeString(restrictionValues[3]);                  }                    tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                  int handle = tmConn.InternalConnection.dataStream.getInt();                    if (handle != -1)                  {                      using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                      {                          table.BeginLoadData();                          string view_def_label="";                          try                           {                               reader.GetOrdinal("VIEW_DEF");                              view_def_label = "VIEW_DEF";                          }                          catch(Exception) {}                          try                           {                               reader.GetOrdinal("VIEWDEFINITION");                              view_def_label = "VIEWDEFINITION";                          }                          catch (Exception) { }                          while (reader.Read())                          {  #if DEBUG                          System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_NAME"] + "' " + reader["TABLE_TYPE"]);  #endif                              DataRow row = table.NewRow();                              row["TABLE_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                              row["TABLE_NAME"] = reader.GetFieldValue<string>("TABLE_NAME");                              row["TABLE_TYPE"] = reader.GetFieldValue<string>("TABLE_TYPE");                              row["REMARKS"] = reader.GetFieldValue<string>("REMARKS");                              if (view_def_label.Length != 0)                              {                                  row["VIEW_DEF"] = reader.GetFieldValue<string>(view_def_label);                              }                              table.Rows.Add(row);                          }                          table.EndLoadData();                      }                  }              }              else if (collectionName == "Columns")              {                  table.Columns.Add("COLUMN_CATALOG"' typeof(string));                  table.Columns.Add("COLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("COLUMN_TABLE"' typeof(string));                  table.Columns.Add("COLUMN_NAME"' typeof(string));                  table.Columns.Add("COLUMN_POSITION"' typeof(int));                  table.Columns.Add("COLUMN_TYPE"' typeof(string));                  table.Columns.Add("COLUMN_LENGTH"' typeof(int));                  table.Columns.Add("COLUMN_PRECISION"' typeof(int));                  table.Columns.Add("COLUMN_NULLABLE"' typeof(bool));                  table.Columns.Add("COLUMN_IDENTITY"' typeof(bool));                  table.Columns.Add("COLUMN_DEFAULT"' typeof(string));                  table.Columns.Add("COLUMN_SCALE"' typeof(int));                    tmConn.InternalConnection.dataStream.startMessage(Protocol.GetColumns);                  tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                  for (int i = 1; i < 4; i++)                      if (restrictionValues != null && restrictionValues.Length > i)                          tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                      else                          tmConn.InternalConnection.dataStream.encodeNull();                    tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                  int handle = tmConn.InternalConnection.dataStream.getInt();                    if (handle != -1)                  {                      using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                      {                          table.BeginLoadData();                          while (reader.Read())                          {                              DataRow row = table.NewRow();                              row["COLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                              row["COLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                              row["COLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                              row["COLUMN_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                              row["COLUMN_LENGTH"] = reader.GetFieldValue<int>("COLUMN_SIZE");                              row["COLUMN_PRECISION"] = reader.GetFieldValue<int>("BUFFER_LENGTH");                              row["COLUMN_SCALE"] = reader.GetFieldValue<int>("DECIMAL_DIGITS");                              if (isNumeric(reader.GetFieldValue<string>("TYPE_NAME")))                              {                                  if (reader.GetFieldValue<int>("DECIMAL_DIGITS") != 0)                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME") +                                           "(" + reader.GetFieldValue<int>("BUFFER_LENGTH") + "'" + reader.GetFieldValue<int>("DECIMAL_DIGITS") + ")";                                  else                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME");                              }                              else                              {                                  if (isVarLenType(reader.GetFieldValue<string>("TYPE_NAME")) && reader.GetFieldValue<int>("COLUMN_SIZE") != 0)                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME") +                                           "(" + reader.GetFieldValue<int>("COLUMN_SIZE") + ")";                                  else                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME");                              }                              if (!reader.IsDBNull(reader.GetOrdinal("IS_NULLABLE")))                                  row["COLUMN_NULLABLE"] = reader.GetFieldValue<string>("IS_NULLABLE").Equals("YES");                              if (!reader.IsDBNull(reader.GetOrdinal("IS_AUTOINCREMENT")))                                  row["COLUMN_IDENTITY"] = reader.GetFieldValue<string>("IS_AUTOINCREMENT").Equals("YES");                              row["COLUMN_DEFAULT"] = reader.GetFieldValue<string>("COLUMN_DEF");    #if DEBUG                              System.Diagnostics.Trace.WriteLine("-> " + row["COLUMN_NAME"] + " " + row["COLUMN_TYPE"]);  #endif                              table.Rows.Add(row);                          }                          table.EndLoadData();                      }                  }              }              else if (collectionName == "Indexes")              {                  table.Columns.Add("INDEX_CATALOG"' typeof(string));                  table.Columns.Add("INDEX_SCHEMA"' typeof(string));                  table.Columns.Add("INDEX_TABLE"' typeof(string));                  table.Columns.Add("INDEX_NAME"' typeof(string));                  table.Columns.Add("INDEX_TYPE"' typeof(string));                  table.Columns.Add("INDEX_UNIQUE"' typeof(bool));                  table.Columns.Add("INDEX_PRIMARY"' typeof(bool));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetIndexInfo);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // unique                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // approximate                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        // to avoid to insert the same index more than once                      HashSet<string> unique = new HashSet<string>();                      if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;                                  if (!unique.Add(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;                                  DataRow row = table.NewRow();                                  row["INDEX_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEX_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEX_NAME"] = reader.GetFieldValue<string>("INDEX_NAME");                                  switch (reader.GetFieldValue<int>("TYPE"))                                  {                                      case 0:                                          row["INDEX_TYPE"] = "Primary";                                          break;                                      case 1:                                          row["INDEX_TYPE"] = "Unique";                                          break;                                      case 2:                                          row["INDEX_TYPE"] = "Secondary";                                          break;                                      case 3:                                          row["INDEX_TYPE"] = "Foreign Key";                                          break;                                  }                                  row["INDEX_UNIQUE"] = (reader.GetFieldValue<int>("NON_UNIQUE") == 0) ? true : false;                                  row["INDEX_PRIMARY"] = (reader.GetFieldValue<int>("TYPE") == 0) ? true : false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                        tmConn.InternalConnection.dataStream.startMessage(Protocol.GetPrimaryKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              // use INDEX_NAME' if present; if missing' the name of the index is in PK_NAME                              string indexName = "PK_NAME";                              foreach (string column in reader.columnNames)                              {                                  if (column == "INDEX_NAME")                                  {                                      indexName = "INDEX_NAME";                                      break;                                  }                              }                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>(indexName)))                                      continue;                                  if (!unique.Add(reader.GetFieldValue<string>(indexName)))                                      continue;                                  DataRow row = table.NewRow();                                  row["INDEX_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEX_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEX_NAME"] = reader.GetFieldValue<string>(indexName);                                  row["INDEX_TYPE"] = "Primary";                                  row["INDEX_UNIQUE"] = true;                                  row["INDEX_PRIMARY"] = true;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "IndexColumns")              {                  table.Columns.Add("INDEXCOLUMN_CATALOG"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_TABLE"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_INDEX"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_NAME"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_POSITION"' typeof(int));                  table.Columns.Add("INDEXCOLUMN_ISPRIMARY"' typeof(bool));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetIndexInfo);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // unique                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // approximate                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_SCHEM"] + "." + reader["TABLE_NAME"] + "=" + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["INDEXCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEXCOLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEXCOLUMN_INDEX"] = reader.GetFieldValue<string>("INDEX_NAME");                                  row["INDEXCOLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["INDEXCOLUMN_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                                  row["INDEXCOLUMN_ISPRIMARY"] = false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                        tmConn.InternalConnection.dataStream.startMessage(Protocol.GetPrimaryKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              // use INDEX_NAME' if present; if missing' the name of the index is in PK_NAME                              string indexName = "PK_NAME";                              foreach (string column in reader.columnNames)                              {                                  if (column == "INDEX_NAME")                                  {                                      indexName = "INDEX_NAME";                                      break;                                  }                              }                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>(indexName)))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_SCHEM"] + "." + reader["TABLE_NAME"] + " (Primary) =" + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["INDEXCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEXCOLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEXCOLUMN_INDEX"] = reader.GetFieldValue<string>(indexName);                                  row["INDEXCOLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["INDEXCOLUMN_POSITION"] = reader.GetFieldValue<int>("KEY_SEQ");                                  row["INDEXCOLUMN_ISPRIMARY"] = true;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ForeignKeys")              {                  table.Columns.Add("FOREIGNKEY_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEY_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEY_TABLE"' typeof(string));                  table.Columns.Add("FOREIGNKEY_NAME"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_TABLE"' typeof(string));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetImportedKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  string name = "[" + reader.GetFieldValue<string>("FKTABLE_SCHEM") + "]" +                                                   reader.GetFieldValue<string>("FKTABLE_NAME") + "." +                                                   reader.GetFieldValue<string>("FKCOLUMN_NAME") + "->" +                                                  "[" + reader.GetFieldValue<string>("PKTABLE_SCHEM") + "]" +                                                   reader.GetFieldValue<string>("PKTABLE_NAME") + "." +                                                   reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(name))                                      continue;                                  DataRow row = table.NewRow();                                  row["FOREIGNKEY_SCHEMA"] = reader.GetFieldValue<string>("FKTABLE_SCHEM");                                  row["FOREIGNKEY_TABLE"] = reader.GetFieldValue<string>("FKTABLE_NAME");                                  row["FOREIGNKEY_NAME"] = name;                                  row["FOREIGNKEY_OTHER_SCHEMA"] = reader.GetFieldValue<string>("PKTABLE_SCHEM");                                  row["FOREIGNKEY_OTHER_TABLE"] = reader.GetFieldValue<string>("PKTABLE_NAME");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ForeignKeyColumns")              {                  table.Columns.Add("FOREIGNKEYCOLUMN_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_TABLE"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_KEY"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_NAME"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_ORDINAL"' typeof(int));                  table.Columns.Add("FOREIGNKEYCOLUMN_OTHER_COLUMN_NAME"' typeof(string));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetImportedKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  string name = "[" + reader.GetFieldValue<string>("FKTABLE_SCHEM") + "]" +                                                  reader.GetFieldValue<string>("FKTABLE_NAME") + "." +                                                  reader.GetFieldValue<string>("FKCOLUMN_NAME") + "->" +                                                  "[" + reader.GetFieldValue<string>("PKTABLE_SCHEM") + "]" +                                                  reader.GetFieldValue<string>("PKTABLE_NAME") + "." +                                                  reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(name))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["FKTABLE_SCHEM"] + "." + reader["FKTABLE_NAME"] + "=" + reader["FKCOLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["FOREIGNKEYCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("FKTABLE_SCHEM");                                  row["FOREIGNKEYCOLUMN_TABLE"] = reader.GetFieldValue<string>("FKTABLE_NAME");                                  row["FOREIGNKEYCOLUMN_KEY"] = name;                                  row["FOREIGNKEYCOLUMN_NAME"] = reader.GetFieldValue<string>("FKCOLUMN_NAME");                                  row["FOREIGNKEYCOLUMN_ORDINAL"] = reader.GetFieldValue<int>("KEY_SEQ");                                  row["FOREIGNKEYCOLUMN_OTHER_COLUMN_NAME"] = reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "Procedures")               {                  table.Columns.Add("PROCEDURE_CATALOG"' typeof(string));                  table.Columns.Add("PROCEDURE_SCHEMA"' typeof(string));                  table.Columns.Add("PROCEDURE_NAME"' typeof(string));                  table.Columns.Add("IS_SYSTEM_PROCEDURE"' typeof(bool));                    if (tmConn.InternalConnection.protocolVersion >= Protocol.PROTOCOL_VERSION12)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetProcedures);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      for (int i = 1; i < 3; i++)                          if (restrictionValues != null && restrictionValues.Length > i)                              tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                          else                              tmConn.InternalConnection.dataStream.encodeNull();                        tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["PROCEDURE_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["PROCEDURE_SCHEMA"] = reader.GetFieldValue<string>("PROCEDURE_SCHEM");                                  row["PROCEDURE_NAME"] = reader.GetFieldValue<string>("PROCEDURE_NAME");                                  row["IS_SYSTEM_PROCEDURE"] = false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ProcedureParameters")              {                  table.Columns.Add("PROCEDURE_CATALOG"' typeof(string));                  table.Columns.Add("PROCEDURE_SCHEMA"' typeof(string));                  table.Columns.Add("PROCEDURE_NAME"' typeof(string));                  table.Columns.Add("PARAMETER_NAME"' typeof(string));                  table.Columns.Add("ORDINAL_POSITION"' typeof(int));                  table.Columns.Add("PARAMETER_DATA_TYPE"' typeof(int));                  table.Columns.Add("PARAMETER_TYPE_NAME"' typeof(string));                  table.Columns.Add("PARAMETER_SIZE"' typeof(int));                  table.Columns.Add("NUMERIC_PRECISION"' typeof(int));                  table.Columns.Add("NUMERIC_SCALE"' typeof(int));                  table.Columns.Add("PARAMETER_DIRECTION"' typeof(int));                  table.Columns.Add("IS_NULLABLE"' typeof(bool));                    if (tmConn.InternalConnection.protocolVersion >= Protocol.PROTOCOL_VERSION12)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetProcedureColumns);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      for (int i = 1; i < 4; i++)                          if (restrictionValues != null && restrictionValues.Length > i)                              tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                          else                              tmConn.InternalConnection.dataStream.encodeNull();                        tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["PROCEDURE_NAME"] + "' " + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["PROCEDURE_SCHEMA"] = reader.GetFieldValue<string>("PROCEDURE_SCHEM");                                  row["PROCEDURE_NAME"] = reader.GetFieldValue<string>("PROCEDURE_NAME");                                  row["PARAMETER_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["ORDINAL_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                                  row["PARAMETER_TYPE_NAME"] = reader.GetFieldValue<string>("TYPE_NAME");                                  row["PARAMETER_DATA_TYPE"] = reader.GetFieldValue<int>("DATA_TYPE");                                  row["PARAMETER_SIZE"] = reader.GetFieldValue<int>("LENGTH");                                  row["NUMERIC_PRECISION"] = reader.GetFieldValue<int>("PRECISION");                                  row["NUMERIC_SCALE"] = reader.GetFieldValue<int>("SCALE");                                  row["PARAMETER_DIRECTION"] = reader.GetFieldValue<int>("COLUMN_TYPE");                                  row["IS_NULLABLE"] = !reader.GetFieldValue<string>("IS_NULLABLE").Equals("NO");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The following statement contains a magic number: if (collectionName == DbMetaDataCollectionNames.DataSourceInformation)              {                  // see http://msdn.microsoft.com/en-us/library/ms254501.aspx                  table.Columns.Add("CompositeIdentifierSeparatorPattern"' typeof(string));                  table.Columns.Add("DataSourceProductName"' typeof(string));                  table.Columns.Add("DataSourceProductVersion"' typeof(string));                  table.Columns.Add("DataSourceProductVersionNormalized"' typeof(string));                  table.Columns.Add("DataSourceInternalProductVersion"' typeof(string));                  table.Columns.Add("GroupByBehavior"' typeof(GroupByBehavior));                  table.Columns.Add("IdentifierPattern"' typeof(string));                  table.Columns.Add("IdentifierCase"' typeof(IdentifierCase));                  table.Columns.Add("OrderByColumnsInSelect"' typeof(bool));                  table.Columns.Add("ParameterMarkerFormat"' typeof(string));                  table.Columns.Add("ParameterMarkerPattern"' typeof(string));                  table.Columns.Add("ParameterNameMaxLength"' typeof(int));                  table.Columns.Add("ParameterNamePattern"' typeof(string));                  table.Columns.Add("QuotedIdentifierPattern"' typeof(string));  // Regex                  table.Columns.Add("QuotedIdentifierCase"' typeof(int));                  table.Columns.Add("StatementSeparatorPattern"' typeof(string));                  table.Columns.Add("StringLiteralPattern"' typeof(string));  // Regex                  table.Columns.Add("SupportedJoinOperators"' typeof(SupportedJoinOperators));                    table.BeginLoadData();                  DataRow row = table.NewRow();                  int databaseMajorVersion = 0' databaseMinorVersion = 0;                  try                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetDatabaseMetaData);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      for (int item; (item = tmConn.InternalConnection.dataStream.getInt()) != Protocol.DbmbFini; )                      {                          switch (item)                          {                              case Protocol.DbmbProductName:                                  row["DataSourceProductName"] = tmConn.InternalConnection.dataStream.getString();                                  break;                                case Protocol.DbmbProductVersion:                                  row["DataSourceProductVersion"] = tmConn.InternalConnection.dataStream.getString();                                  break;                                case Protocol.DbmbDatabaseMinorVersion:                                  databaseMinorVersion = tmConn.InternalConnection.dataStream.getInt();                                  break;                                case Protocol.DbmbDatabaseMajorVersion:                                  databaseMajorVersion = tmConn.InternalConnection.dataStream.getInt();                                  break;                                case Protocol.DbmbDefaultTransactionIsolation:                                  int defaultTransactionIsolation = tmConn.InternalConnection.dataStream.getInt();                                  break;                                default:                                  tmConn.InternalConnection.dataStream.decode();                                  break;                          }                      }                  }                  catch (Exception)                  {                  }                    row["DataSourceInternalProductVersion"] = String.Format("{0:D3}.{1:D3}"' databaseMajorVersion' databaseMinorVersion);                  // The regular expression to match the composite separators in a composite identifier.                   // For example' "\." (for SQL Server) or "@|\." (for Oracle).                  // A composite identifier is typically what is used for a database object name'                   // for example: pubs.dbo.authors or pubs@dbo.authors.                  row["CompositeIdentifierSeparatorPattern"] = "\\.";                  // A normalized version for the data source' such that it can be compared with String.Compare().                   // The format of this is consistent for all versions of the provider to prevent version 10 from sorting between version 1 and version 2.                  //row["DataSourceProductVersionNormalized"] = ??                  // Specifies the relationship between the columns in a GROUP BY clause and the non-aggregated columns in the select list.                  row["GroupByBehavior"] = GroupByBehavior.Unknown;                  // A regular expression that matches an identifier and has a match value of the identifier. For example "[A-Za-z0-9_#$]".                  row["IdentifierPattern"] = "(^\\[\\p{Lo}\\p{Lu}\\p{Ll}_@#][\\p{Lo}\\p{Lu}\\p{Ll}\\p{Nd}@$#_]*$)|(^\"[^\"\\0]|\"\"+\"$)";                  // Indicates whether non-quoted identifiers are treated as case sensitive or not.                  row["IdentifierCase"] = IdentifierCase.Insensitive;                  // Specifies whether columns in an ORDER BY clause must be in the select list.                   // A value of true indicates that they are required to be in the select list'                   // a value of false indicates that they are not required to be in the select list.                  row["OrderByColumnsInSelect"] = false;                  // For data sources that do not expect named parameters and expect the use of the ‘?’ character' the format string                  // can be specified as simply '?'' which would ignore the parameter name.                  row["ParameterMarkerFormat"] = "?";                  // if the data source doesn't support named parameters' this would simply be "?".                  row["ParameterMarkerPattern"] = "?";                  // If the data source does not support named parameters' this property returns zero.                  row["ParameterNameMaxLength"] = 0;                  // A regular expression that matches the valid parameter names                  row["ParameterNamePattern"] = "";                  // A regular expression that matches a quoted identifier and has a match value of the identifier itself without the quotes.                   // For example' if the data source used double-quotes to identify quoted identifiers' this would be: "(([^\"]|\"\")*)".                  row["QuotedIdentifierPattern"] = "\"([^\"]*)\"";                  // Indicates whether quoted identifiers are treated as case sensitive or not.                  row["QuotedIdentifierCase"] = IdentifierCase.Sensitive;                  // A regular expression that matches the statement separator.                  row["StatementSeparatorPattern"] = ";";                  // A regular expression that matches a string literal and has a match value of the literal itself.                   // For example' if the data source used single-quotes to identify strings' this would be: "('([^']|'')*')"'                  row["StringLiteralPattern"] = "'([^']*)'";                  // Specifies what types of SQL join statements are supported by the data source.                  row["SupportedJoinOperators"] = SupportedJoinOperators.None;                  table.Rows.Add(row);                  table.EndLoadData();              }              else if (collectionName == DbMetaDataCollectionNames.ReservedWords)              {                  table.Columns.Add("ReservedWord"' typeof(string));                  table.Columns.Add("MaximumVersion"' typeof(string));                  table.Columns.Add("MinimumVersion"' typeof(string));                    string[] words = { "select"' "Add field"' "Drop field"' "Alter table"' "Alter field"'                                      "Alter user"' "And"' "Or"' "Not"' "Create Index"' "Upgrade"' "Unique"'                                      "Table key"' "Table unique key"' "Primary Key"' "Create Table"'                                      "Upgrade Table"' "Rename Table"' "Create View"' "Upgrade View"'                                      "Drop View"' "Create Schema"' "Drop Schema"' "Integer"' "Smallint"'                                      "Bigint"' "Tinyint"' "float"' "double"' "Blob"' "bytes"' "boolean"'                                      "binary"' "varbinary"' "string"' "char"' "text"' "date"' "timestamp"'                                      "time"' "varchar"' "numeric"' "Decimal Number"' "Enum"' "Delete"' "Repair"'                                      "Field"' "Not Null"' "Default Value"' "searchable"' "not searchable"'                                      "collation"' "character_set"' "Foreign Key"' "Identifier"' "record number"'                                      "Insert"' "Replace"' "Name"' "Number"' "Order"' "Descending"' "limit"'                                      "Quoted String"' "Select Clause"' "Distinct"' "Gtr"' "Geq"' "Eql"'                                      "Leq"' "Lss"' "Neq"' "in list"' "in select"' "exists"' "Between"' "Like"'                                      "starts with"' "Containing"' "Matching"' "Regular expression"' "Null"'                                      "True"' "False"' "Execute"' "Parameter"' "Count"' "sum"' "min"' "max"'                                      "avg"' "Drop Index"' "Drop primary key"' "Drop foreign key"' "Drop Table"'                                      "If Exists"' "Describe"' "Statement"' "for_select"' "for_insert"' "while"'                                      "if then else"' "variable"' "declaration"' "throw"' "assignment"'                                      "Start transaction"' "read only"' "read write"' "read committed"' "write committed"'                                      "read uncommitted"' "repeatableread"' "serializable"' "Commit"' "Rollback"'                                      "Savepoint"' "Rollack Savepoint"' "Release Savepoint"' "Table"' "Derived Table"'                                      "Assign"' "Update"' "list"' "Constant"' "Function"' "Grant"' "Grant role"' "Alter"'                                      "Read"' "Identity"' "Check"' "Constraint"' "value constraint"' "auto increment"'                                      "generated"' "always"' "Domain"' "is null"' "is active_role"' "start with"' "reindex"'                                      "cursor"' "alias"' "push_namespace"' "pop_namespace"' "set_namespace"' "coalesce"'                                      "nod_nullif"' "case"' "case_search"' "add"' "subtract"' "multiply"' "divide"' "modulus"'                                      "negate"' "plus"' "cast"' "concatenation"' "create user"' "drop user"' "create role"'                                      "upgrade role"' "drop role"' "revoke"' "revoke role"' "assume"' "revert"' "negate"'                                      "priv insert"' "priv delete"' "priv execute"' "priv select"' "priv update"' "priv grant"'                                      "priv all"' "characters"' "octets"' "role"' "view"' "procedure"' "user"' "zone"' "admin"'                                      "default role"' "create sequence"' "upgrade sequence"' "drop sequence"' "next value"'                                      "create trigger"' "upgrade trigger"' "alter trigger"' "drop trigger"' "create procedure"'                                      "upgrade procedure"' "alter procedure"' "drop procedure"' "pre-insert"' "post-insert"'                                      "pre-update"' "post-update"' "pre-delete"' "post-delete"' "pre-commit"' "post-commit"'                                      "active"' "inactive"' "position"' "select-expr"' "create filterset"' "upgrade filterset"'                                      "drop filterset"' "enable filterset"' "disable filterset"' "table filter"' "left outer"'                                      "right outer"' "full outer"' "inner"' "join"' "join_term"' "trigger class"' "enable trigger class"'                                      "disable trigger class"' "create zone"' "upgrade zone"' "drop zone"' "range"' "ip address"'                                      "node_name"' "wildcard"' "create domain"' "upgrade domain"' "alter domain"' "upgrade schema"'                                      "delete cascade"' "index segment"' "for update"' "write committed"' "read committed"'                                       "consistent read"' "set dialect"' "set names"' "restrict"' "cascade"' "characters"' "octets"'                                      "create event"' "collate"' "truncate"' "restart"' "nameless constraint"' "drop constraint"'                                      "drop unique constraint"' "drop domain"' "with check option"' "not real"' "lower"' "upper"'                                      "substr"' "substring index"' "charlength"' "default keyword"' "sqrt"' "power"' "Scientific Notation Number"'                                      "Explain"' "msleep"' "KillStatement"' "now" };                  table.BeginLoadData();                  foreach (string keyword in words)                  {                      DataRow row = table.NewRow();                      row["ReservedWord"] = keyword;                      table.Rows.Add(row);                  }                  table.EndLoadData();                }              else if (collectionName == DbMetaDataCollectionNames.DataTypes)              {                  table.Columns.Add("TypeName"' typeof(string));  // The provider-specific data type name.                  table.Columns.Add("ProviderDbType"' typeof(int)); // The provider-specific type value that should be used when specifying                   //a parameter's type. For example' SqlDbType.Money or OracleType.Blob.                  table.Columns.Add("ColumnSize"' typeof(long));                  table.Columns.Add("CreateFormat"' typeof(string));                  table.Columns.Add("CreateParameters"' typeof(string));                  table.Columns.Add("DataType"' typeof(string));  // The name of the .NET Framework type of the data type.                  table.Columns.Add("IsAutoincrementable"' typeof(bool));                  table.Columns.Add("IsBestMatch"' typeof(bool));                  table.Columns.Add("IsCaseSensitive"' typeof(bool));                  table.Columns.Add("IsFixedLength"' typeof(bool));                  table.Columns.Add("IsFixedPrecisionScale"' typeof(bool));                  table.Columns.Add("IsLong"' typeof(bool));                  table.Columns.Add("IsNullable"' typeof(bool));                  table.Columns.Add("IsSearchable"' typeof(bool));                  table.Columns.Add("IsSearchableWithLike"' typeof(bool));                  table.Columns.Add("IsUnsigned"' typeof(bool));                  table.Columns.Add("MaximumScale"' typeof(short));                  table.Columns.Add("MinimumScale"' typeof(short));                  table.Columns.Add("IsConcurrencyType"' typeof(bool));                  table.Columns.Add("IsLiteralsSupported"' typeof(bool));                  table.Columns.Add("LiteralPrefix"' typeof(string));                  table.Columns.Add("LiteralSuffix"' typeof(string));                  table.Columns.Add("NativeDataType"' typeof(string));    // NativeDataType is an OLE DB specific column for exposing the OLE DB type of the data type .                    table.ReadXml(XmlReader.Create(typeof(NuoDbConnectionInternal).Assembly.GetManifestResourceStream("NuoDb.Data.Client.DataTypes.xml")));              }              else if (collectionName == "Tables")              {                  table.Columns.Add("TABLE_CATALOG"' typeof(string));                  table.Columns.Add("TABLE_SCHEMA"' typeof(string));                  table.Columns.Add("TABLE_NAME"' typeof(string));                  table.Columns.Add("TABLE_TYPE"' typeof(string));                  table.Columns.Add("REMARKS"' typeof(string));                  table.Columns.Add("VIEW_DEF"' typeof(string));                    tmConn.InternalConnection.dataStream.startMessage(Protocol.GetTables);                  tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                  for (int i = 1; i < 3; i++)                      if (restrictionValues != null && restrictionValues.Length > i)                          tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                      else                          tmConn.InternalConnection.dataStream.encodeNull();                  if (restrictionValues == null || restrictionValues.Length < 4 || restrictionValues[3] == null)                      tmConn.InternalConnection.dataStream.encodeInt(0);                  else                  {                      tmConn.InternalConnection.dataStream.encodeInt(1);                      tmConn.InternalConnection.dataStream.encodeString(restrictionValues[3]);                  }                    tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                  int handle = tmConn.InternalConnection.dataStream.getInt();                    if (handle != -1)                  {                      using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                      {                          table.BeginLoadData();                          string view_def_label="";                          try                           {                               reader.GetOrdinal("VIEW_DEF");                              view_def_label = "VIEW_DEF";                          }                          catch(Exception) {}                          try                           {                               reader.GetOrdinal("VIEWDEFINITION");                              view_def_label = "VIEWDEFINITION";                          }                          catch (Exception) { }                          while (reader.Read())                          {  #if DEBUG                          System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_NAME"] + "' " + reader["TABLE_TYPE"]);  #endif                              DataRow row = table.NewRow();                              row["TABLE_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                              row["TABLE_NAME"] = reader.GetFieldValue<string>("TABLE_NAME");                              row["TABLE_TYPE"] = reader.GetFieldValue<string>("TABLE_TYPE");                              row["REMARKS"] = reader.GetFieldValue<string>("REMARKS");                              if (view_def_label.Length != 0)                              {                                  row["VIEW_DEF"] = reader.GetFieldValue<string>(view_def_label);                              }                              table.Rows.Add(row);                          }                          table.EndLoadData();                      }                  }              }              else if (collectionName == "Columns")              {                  table.Columns.Add("COLUMN_CATALOG"' typeof(string));                  table.Columns.Add("COLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("COLUMN_TABLE"' typeof(string));                  table.Columns.Add("COLUMN_NAME"' typeof(string));                  table.Columns.Add("COLUMN_POSITION"' typeof(int));                  table.Columns.Add("COLUMN_TYPE"' typeof(string));                  table.Columns.Add("COLUMN_LENGTH"' typeof(int));                  table.Columns.Add("COLUMN_PRECISION"' typeof(int));                  table.Columns.Add("COLUMN_NULLABLE"' typeof(bool));                  table.Columns.Add("COLUMN_IDENTITY"' typeof(bool));                  table.Columns.Add("COLUMN_DEFAULT"' typeof(string));                  table.Columns.Add("COLUMN_SCALE"' typeof(int));                    tmConn.InternalConnection.dataStream.startMessage(Protocol.GetColumns);                  tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                  for (int i = 1; i < 4; i++)                      if (restrictionValues != null && restrictionValues.Length > i)                          tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                      else                          tmConn.InternalConnection.dataStream.encodeNull();                    tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                  int handle = tmConn.InternalConnection.dataStream.getInt();                    if (handle != -1)                  {                      using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                      {                          table.BeginLoadData();                          while (reader.Read())                          {                              DataRow row = table.NewRow();                              row["COLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                              row["COLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                              row["COLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                              row["COLUMN_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                              row["COLUMN_LENGTH"] = reader.GetFieldValue<int>("COLUMN_SIZE");                              row["COLUMN_PRECISION"] = reader.GetFieldValue<int>("BUFFER_LENGTH");                              row["COLUMN_SCALE"] = reader.GetFieldValue<int>("DECIMAL_DIGITS");                              if (isNumeric(reader.GetFieldValue<string>("TYPE_NAME")))                              {                                  if (reader.GetFieldValue<int>("DECIMAL_DIGITS") != 0)                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME") +                                           "(" + reader.GetFieldValue<int>("BUFFER_LENGTH") + "'" + reader.GetFieldValue<int>("DECIMAL_DIGITS") + ")";                                  else                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME");                              }                              else                              {                                  if (isVarLenType(reader.GetFieldValue<string>("TYPE_NAME")) && reader.GetFieldValue<int>("COLUMN_SIZE") != 0)                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME") +                                           "(" + reader.GetFieldValue<int>("COLUMN_SIZE") + ")";                                  else                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME");                              }                              if (!reader.IsDBNull(reader.GetOrdinal("IS_NULLABLE")))                                  row["COLUMN_NULLABLE"] = reader.GetFieldValue<string>("IS_NULLABLE").Equals("YES");                              if (!reader.IsDBNull(reader.GetOrdinal("IS_AUTOINCREMENT")))                                  row["COLUMN_IDENTITY"] = reader.GetFieldValue<string>("IS_AUTOINCREMENT").Equals("YES");                              row["COLUMN_DEFAULT"] = reader.GetFieldValue<string>("COLUMN_DEF");    #if DEBUG                              System.Diagnostics.Trace.WriteLine("-> " + row["COLUMN_NAME"] + " " + row["COLUMN_TYPE"]);  #endif                              table.Rows.Add(row);                          }                          table.EndLoadData();                      }                  }              }              else if (collectionName == "Indexes")              {                  table.Columns.Add("INDEX_CATALOG"' typeof(string));                  table.Columns.Add("INDEX_SCHEMA"' typeof(string));                  table.Columns.Add("INDEX_TABLE"' typeof(string));                  table.Columns.Add("INDEX_NAME"' typeof(string));                  table.Columns.Add("INDEX_TYPE"' typeof(string));                  table.Columns.Add("INDEX_UNIQUE"' typeof(bool));                  table.Columns.Add("INDEX_PRIMARY"' typeof(bool));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetIndexInfo);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // unique                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // approximate                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        // to avoid to insert the same index more than once                      HashSet<string> unique = new HashSet<string>();                      if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;                                  if (!unique.Add(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;                                  DataRow row = table.NewRow();                                  row["INDEX_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEX_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEX_NAME"] = reader.GetFieldValue<string>("INDEX_NAME");                                  switch (reader.GetFieldValue<int>("TYPE"))                                  {                                      case 0:                                          row["INDEX_TYPE"] = "Primary";                                          break;                                      case 1:                                          row["INDEX_TYPE"] = "Unique";                                          break;                                      case 2:                                          row["INDEX_TYPE"] = "Secondary";                                          break;                                      case 3:                                          row["INDEX_TYPE"] = "Foreign Key";                                          break;                                  }                                  row["INDEX_UNIQUE"] = (reader.GetFieldValue<int>("NON_UNIQUE") == 0) ? true : false;                                  row["INDEX_PRIMARY"] = (reader.GetFieldValue<int>("TYPE") == 0) ? true : false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                        tmConn.InternalConnection.dataStream.startMessage(Protocol.GetPrimaryKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              // use INDEX_NAME' if present; if missing' the name of the index is in PK_NAME                              string indexName = "PK_NAME";                              foreach (string column in reader.columnNames)                              {                                  if (column == "INDEX_NAME")                                  {                                      indexName = "INDEX_NAME";                                      break;                                  }                              }                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>(indexName)))                                      continue;                                  if (!unique.Add(reader.GetFieldValue<string>(indexName)))                                      continue;                                  DataRow row = table.NewRow();                                  row["INDEX_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEX_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEX_NAME"] = reader.GetFieldValue<string>(indexName);                                  row["INDEX_TYPE"] = "Primary";                                  row["INDEX_UNIQUE"] = true;                                  row["INDEX_PRIMARY"] = true;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "IndexColumns")              {                  table.Columns.Add("INDEXCOLUMN_CATALOG"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_TABLE"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_INDEX"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_NAME"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_POSITION"' typeof(int));                  table.Columns.Add("INDEXCOLUMN_ISPRIMARY"' typeof(bool));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetIndexInfo);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // unique                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // approximate                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_SCHEM"] + "." + reader["TABLE_NAME"] + "=" + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["INDEXCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEXCOLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEXCOLUMN_INDEX"] = reader.GetFieldValue<string>("INDEX_NAME");                                  row["INDEXCOLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["INDEXCOLUMN_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                                  row["INDEXCOLUMN_ISPRIMARY"] = false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                        tmConn.InternalConnection.dataStream.startMessage(Protocol.GetPrimaryKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              // use INDEX_NAME' if present; if missing' the name of the index is in PK_NAME                              string indexName = "PK_NAME";                              foreach (string column in reader.columnNames)                              {                                  if (column == "INDEX_NAME")                                  {                                      indexName = "INDEX_NAME";                                      break;                                  }                              }                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>(indexName)))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_SCHEM"] + "." + reader["TABLE_NAME"] + " (Primary) =" + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["INDEXCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEXCOLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEXCOLUMN_INDEX"] = reader.GetFieldValue<string>(indexName);                                  row["INDEXCOLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["INDEXCOLUMN_POSITION"] = reader.GetFieldValue<int>("KEY_SEQ");                                  row["INDEXCOLUMN_ISPRIMARY"] = true;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ForeignKeys")              {                  table.Columns.Add("FOREIGNKEY_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEY_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEY_TABLE"' typeof(string));                  table.Columns.Add("FOREIGNKEY_NAME"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_TABLE"' typeof(string));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetImportedKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  string name = "[" + reader.GetFieldValue<string>("FKTABLE_SCHEM") + "]" +                                                   reader.GetFieldValue<string>("FKTABLE_NAME") + "." +                                                   reader.GetFieldValue<string>("FKCOLUMN_NAME") + "->" +                                                  "[" + reader.GetFieldValue<string>("PKTABLE_SCHEM") + "]" +                                                   reader.GetFieldValue<string>("PKTABLE_NAME") + "." +                                                   reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(name))                                      continue;                                  DataRow row = table.NewRow();                                  row["FOREIGNKEY_SCHEMA"] = reader.GetFieldValue<string>("FKTABLE_SCHEM");                                  row["FOREIGNKEY_TABLE"] = reader.GetFieldValue<string>("FKTABLE_NAME");                                  row["FOREIGNKEY_NAME"] = name;                                  row["FOREIGNKEY_OTHER_SCHEMA"] = reader.GetFieldValue<string>("PKTABLE_SCHEM");                                  row["FOREIGNKEY_OTHER_TABLE"] = reader.GetFieldValue<string>("PKTABLE_NAME");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ForeignKeyColumns")              {                  table.Columns.Add("FOREIGNKEYCOLUMN_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_TABLE"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_KEY"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_NAME"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_ORDINAL"' typeof(int));                  table.Columns.Add("FOREIGNKEYCOLUMN_OTHER_COLUMN_NAME"' typeof(string));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetImportedKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  string name = "[" + reader.GetFieldValue<string>("FKTABLE_SCHEM") + "]" +                                                  reader.GetFieldValue<string>("FKTABLE_NAME") + "." +                                                  reader.GetFieldValue<string>("FKCOLUMN_NAME") + "->" +                                                  "[" + reader.GetFieldValue<string>("PKTABLE_SCHEM") + "]" +                                                  reader.GetFieldValue<string>("PKTABLE_NAME") + "." +                                                  reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(name))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["FKTABLE_SCHEM"] + "." + reader["FKTABLE_NAME"] + "=" + reader["FKCOLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["FOREIGNKEYCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("FKTABLE_SCHEM");                                  row["FOREIGNKEYCOLUMN_TABLE"] = reader.GetFieldValue<string>("FKTABLE_NAME");                                  row["FOREIGNKEYCOLUMN_KEY"] = name;                                  row["FOREIGNKEYCOLUMN_NAME"] = reader.GetFieldValue<string>("FKCOLUMN_NAME");                                  row["FOREIGNKEYCOLUMN_ORDINAL"] = reader.GetFieldValue<int>("KEY_SEQ");                                  row["FOREIGNKEYCOLUMN_OTHER_COLUMN_NAME"] = reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "Procedures")               {                  table.Columns.Add("PROCEDURE_CATALOG"' typeof(string));                  table.Columns.Add("PROCEDURE_SCHEMA"' typeof(string));                  table.Columns.Add("PROCEDURE_NAME"' typeof(string));                  table.Columns.Add("IS_SYSTEM_PROCEDURE"' typeof(bool));                    if (tmConn.InternalConnection.protocolVersion >= Protocol.PROTOCOL_VERSION12)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetProcedures);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      for (int i = 1; i < 3; i++)                          if (restrictionValues != null && restrictionValues.Length > i)                              tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                          else                              tmConn.InternalConnection.dataStream.encodeNull();                        tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["PROCEDURE_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["PROCEDURE_SCHEMA"] = reader.GetFieldValue<string>("PROCEDURE_SCHEM");                                  row["PROCEDURE_NAME"] = reader.GetFieldValue<string>("PROCEDURE_NAME");                                  row["IS_SYSTEM_PROCEDURE"] = false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ProcedureParameters")              {                  table.Columns.Add("PROCEDURE_CATALOG"' typeof(string));                  table.Columns.Add("PROCEDURE_SCHEMA"' typeof(string));                  table.Columns.Add("PROCEDURE_NAME"' typeof(string));                  table.Columns.Add("PARAMETER_NAME"' typeof(string));                  table.Columns.Add("ORDINAL_POSITION"' typeof(int));                  table.Columns.Add("PARAMETER_DATA_TYPE"' typeof(int));                  table.Columns.Add("PARAMETER_TYPE_NAME"' typeof(string));                  table.Columns.Add("PARAMETER_SIZE"' typeof(int));                  table.Columns.Add("NUMERIC_PRECISION"' typeof(int));                  table.Columns.Add("NUMERIC_SCALE"' typeof(int));                  table.Columns.Add("PARAMETER_DIRECTION"' typeof(int));                  table.Columns.Add("IS_NULLABLE"' typeof(bool));                    if (tmConn.InternalConnection.protocolVersion >= Protocol.PROTOCOL_VERSION12)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetProcedureColumns);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      for (int i = 1; i < 4; i++)                          if (restrictionValues != null && restrictionValues.Length > i)                              tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                          else                              tmConn.InternalConnection.dataStream.encodeNull();                        tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["PROCEDURE_NAME"] + "' " + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["PROCEDURE_SCHEMA"] = reader.GetFieldValue<string>("PROCEDURE_SCHEM");                                  row["PROCEDURE_NAME"] = reader.GetFieldValue<string>("PROCEDURE_NAME");                                  row["PARAMETER_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["ORDINAL_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                                  row["PARAMETER_TYPE_NAME"] = reader.GetFieldValue<string>("TYPE_NAME");                                  row["PARAMETER_DATA_TYPE"] = reader.GetFieldValue<int>("DATA_TYPE");                                  row["PARAMETER_SIZE"] = reader.GetFieldValue<int>("LENGTH");                                  row["NUMERIC_PRECISION"] = reader.GetFieldValue<int>("PRECISION");                                  row["NUMERIC_SCALE"] = reader.GetFieldValue<int>("SCALE");                                  row["PARAMETER_DIRECTION"] = reader.GetFieldValue<int>("COLUMN_TYPE");                                  row["IS_NULLABLE"] = !reader.GetFieldValue<string>("IS_NULLABLE").Equals("NO");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The following statement contains a magic number: if (collectionName == DbMetaDataCollectionNames.DataSourceInformation)              {                  // see http://msdn.microsoft.com/en-us/library/ms254501.aspx                  table.Columns.Add("CompositeIdentifierSeparatorPattern"' typeof(string));                  table.Columns.Add("DataSourceProductName"' typeof(string));                  table.Columns.Add("DataSourceProductVersion"' typeof(string));                  table.Columns.Add("DataSourceProductVersionNormalized"' typeof(string));                  table.Columns.Add("DataSourceInternalProductVersion"' typeof(string));                  table.Columns.Add("GroupByBehavior"' typeof(GroupByBehavior));                  table.Columns.Add("IdentifierPattern"' typeof(string));                  table.Columns.Add("IdentifierCase"' typeof(IdentifierCase));                  table.Columns.Add("OrderByColumnsInSelect"' typeof(bool));                  table.Columns.Add("ParameterMarkerFormat"' typeof(string));                  table.Columns.Add("ParameterMarkerPattern"' typeof(string));                  table.Columns.Add("ParameterNameMaxLength"' typeof(int));                  table.Columns.Add("ParameterNamePattern"' typeof(string));                  table.Columns.Add("QuotedIdentifierPattern"' typeof(string));  // Regex                  table.Columns.Add("QuotedIdentifierCase"' typeof(int));                  table.Columns.Add("StatementSeparatorPattern"' typeof(string));                  table.Columns.Add("StringLiteralPattern"' typeof(string));  // Regex                  table.Columns.Add("SupportedJoinOperators"' typeof(SupportedJoinOperators));                    table.BeginLoadData();                  DataRow row = table.NewRow();                  int databaseMajorVersion = 0' databaseMinorVersion = 0;                  try                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetDatabaseMetaData);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      for (int item; (item = tmConn.InternalConnection.dataStream.getInt()) != Protocol.DbmbFini; )                      {                          switch (item)                          {                              case Protocol.DbmbProductName:                                  row["DataSourceProductName"] = tmConn.InternalConnection.dataStream.getString();                                  break;                                case Protocol.DbmbProductVersion:                                  row["DataSourceProductVersion"] = tmConn.InternalConnection.dataStream.getString();                                  break;                                case Protocol.DbmbDatabaseMinorVersion:                                  databaseMinorVersion = tmConn.InternalConnection.dataStream.getInt();                                  break;                                case Protocol.DbmbDatabaseMajorVersion:                                  databaseMajorVersion = tmConn.InternalConnection.dataStream.getInt();                                  break;                                case Protocol.DbmbDefaultTransactionIsolation:                                  int defaultTransactionIsolation = tmConn.InternalConnection.dataStream.getInt();                                  break;                                default:                                  tmConn.InternalConnection.dataStream.decode();                                  break;                          }                      }                  }                  catch (Exception)                  {                  }                    row["DataSourceInternalProductVersion"] = String.Format("{0:D3}.{1:D3}"' databaseMajorVersion' databaseMinorVersion);                  // The regular expression to match the composite separators in a composite identifier.                   // For example' "\." (for SQL Server) or "@|\." (for Oracle).                  // A composite identifier is typically what is used for a database object name'                   // for example: pubs.dbo.authors or pubs@dbo.authors.                  row["CompositeIdentifierSeparatorPattern"] = "\\.";                  // A normalized version for the data source' such that it can be compared with String.Compare().                   // The format of this is consistent for all versions of the provider to prevent version 10 from sorting between version 1 and version 2.                  //row["DataSourceProductVersionNormalized"] = ??                  // Specifies the relationship between the columns in a GROUP BY clause and the non-aggregated columns in the select list.                  row["GroupByBehavior"] = GroupByBehavior.Unknown;                  // A regular expression that matches an identifier and has a match value of the identifier. For example "[A-Za-z0-9_#$]".                  row["IdentifierPattern"] = "(^\\[\\p{Lo}\\p{Lu}\\p{Ll}_@#][\\p{Lo}\\p{Lu}\\p{Ll}\\p{Nd}@$#_]*$)|(^\"[^\"\\0]|\"\"+\"$)";                  // Indicates whether non-quoted identifiers are treated as case sensitive or not.                  row["IdentifierCase"] = IdentifierCase.Insensitive;                  // Specifies whether columns in an ORDER BY clause must be in the select list.                   // A value of true indicates that they are required to be in the select list'                   // a value of false indicates that they are not required to be in the select list.                  row["OrderByColumnsInSelect"] = false;                  // For data sources that do not expect named parameters and expect the use of the ‘?’ character' the format string                  // can be specified as simply '?'' which would ignore the parameter name.                  row["ParameterMarkerFormat"] = "?";                  // if the data source doesn't support named parameters' this would simply be "?".                  row["ParameterMarkerPattern"] = "?";                  // If the data source does not support named parameters' this property returns zero.                  row["ParameterNameMaxLength"] = 0;                  // A regular expression that matches the valid parameter names                  row["ParameterNamePattern"] = "";                  // A regular expression that matches a quoted identifier and has a match value of the identifier itself without the quotes.                   // For example' if the data source used double-quotes to identify quoted identifiers' this would be: "(([^\"]|\"\")*)".                  row["QuotedIdentifierPattern"] = "\"([^\"]*)\"";                  // Indicates whether quoted identifiers are treated as case sensitive or not.                  row["QuotedIdentifierCase"] = IdentifierCase.Sensitive;                  // A regular expression that matches the statement separator.                  row["StatementSeparatorPattern"] = ";";                  // A regular expression that matches a string literal and has a match value of the literal itself.                   // For example' if the data source used single-quotes to identify strings' this would be: "('([^']|'')*')"'                  row["StringLiteralPattern"] = "'([^']*)'";                  // Specifies what types of SQL join statements are supported by the data source.                  row["SupportedJoinOperators"] = SupportedJoinOperators.None;                  table.Rows.Add(row);                  table.EndLoadData();              }              else if (collectionName == DbMetaDataCollectionNames.ReservedWords)              {                  table.Columns.Add("ReservedWord"' typeof(string));                  table.Columns.Add("MaximumVersion"' typeof(string));                  table.Columns.Add("MinimumVersion"' typeof(string));                    string[] words = { "select"' "Add field"' "Drop field"' "Alter table"' "Alter field"'                                      "Alter user"' "And"' "Or"' "Not"' "Create Index"' "Upgrade"' "Unique"'                                      "Table key"' "Table unique key"' "Primary Key"' "Create Table"'                                      "Upgrade Table"' "Rename Table"' "Create View"' "Upgrade View"'                                      "Drop View"' "Create Schema"' "Drop Schema"' "Integer"' "Smallint"'                                      "Bigint"' "Tinyint"' "float"' "double"' "Blob"' "bytes"' "boolean"'                                      "binary"' "varbinary"' "string"' "char"' "text"' "date"' "timestamp"'                                      "time"' "varchar"' "numeric"' "Decimal Number"' "Enum"' "Delete"' "Repair"'                                      "Field"' "Not Null"' "Default Value"' "searchable"' "not searchable"'                                      "collation"' "character_set"' "Foreign Key"' "Identifier"' "record number"'                                      "Insert"' "Replace"' "Name"' "Number"' "Order"' "Descending"' "limit"'                                      "Quoted String"' "Select Clause"' "Distinct"' "Gtr"' "Geq"' "Eql"'                                      "Leq"' "Lss"' "Neq"' "in list"' "in select"' "exists"' "Between"' "Like"'                                      "starts with"' "Containing"' "Matching"' "Regular expression"' "Null"'                                      "True"' "False"' "Execute"' "Parameter"' "Count"' "sum"' "min"' "max"'                                      "avg"' "Drop Index"' "Drop primary key"' "Drop foreign key"' "Drop Table"'                                      "If Exists"' "Describe"' "Statement"' "for_select"' "for_insert"' "while"'                                      "if then else"' "variable"' "declaration"' "throw"' "assignment"'                                      "Start transaction"' "read only"' "read write"' "read committed"' "write committed"'                                      "read uncommitted"' "repeatableread"' "serializable"' "Commit"' "Rollback"'                                      "Savepoint"' "Rollack Savepoint"' "Release Savepoint"' "Table"' "Derived Table"'                                      "Assign"' "Update"' "list"' "Constant"' "Function"' "Grant"' "Grant role"' "Alter"'                                      "Read"' "Identity"' "Check"' "Constraint"' "value constraint"' "auto increment"'                                      "generated"' "always"' "Domain"' "is null"' "is active_role"' "start with"' "reindex"'                                      "cursor"' "alias"' "push_namespace"' "pop_namespace"' "set_namespace"' "coalesce"'                                      "nod_nullif"' "case"' "case_search"' "add"' "subtract"' "multiply"' "divide"' "modulus"'                                      "negate"' "plus"' "cast"' "concatenation"' "create user"' "drop user"' "create role"'                                      "upgrade role"' "drop role"' "revoke"' "revoke role"' "assume"' "revert"' "negate"'                                      "priv insert"' "priv delete"' "priv execute"' "priv select"' "priv update"' "priv grant"'                                      "priv all"' "characters"' "octets"' "role"' "view"' "procedure"' "user"' "zone"' "admin"'                                      "default role"' "create sequence"' "upgrade sequence"' "drop sequence"' "next value"'                                      "create trigger"' "upgrade trigger"' "alter trigger"' "drop trigger"' "create procedure"'                                      "upgrade procedure"' "alter procedure"' "drop procedure"' "pre-insert"' "post-insert"'                                      "pre-update"' "post-update"' "pre-delete"' "post-delete"' "pre-commit"' "post-commit"'                                      "active"' "inactive"' "position"' "select-expr"' "create filterset"' "upgrade filterset"'                                      "drop filterset"' "enable filterset"' "disable filterset"' "table filter"' "left outer"'                                      "right outer"' "full outer"' "inner"' "join"' "join_term"' "trigger class"' "enable trigger class"'                                      "disable trigger class"' "create zone"' "upgrade zone"' "drop zone"' "range"' "ip address"'                                      "node_name"' "wildcard"' "create domain"' "upgrade domain"' "alter domain"' "upgrade schema"'                                      "delete cascade"' "index segment"' "for update"' "write committed"' "read committed"'                                       "consistent read"' "set dialect"' "set names"' "restrict"' "cascade"' "characters"' "octets"'                                      "create event"' "collate"' "truncate"' "restart"' "nameless constraint"' "drop constraint"'                                      "drop unique constraint"' "drop domain"' "with check option"' "not real"' "lower"' "upper"'                                      "substr"' "substring index"' "charlength"' "default keyword"' "sqrt"' "power"' "Scientific Notation Number"'                                      "Explain"' "msleep"' "KillStatement"' "now" };                  table.BeginLoadData();                  foreach (string keyword in words)                  {                      DataRow row = table.NewRow();                      row["ReservedWord"] = keyword;                      table.Rows.Add(row);                  }                  table.EndLoadData();                }              else if (collectionName == DbMetaDataCollectionNames.DataTypes)              {                  table.Columns.Add("TypeName"' typeof(string));  // The provider-specific data type name.                  table.Columns.Add("ProviderDbType"' typeof(int)); // The provider-specific type value that should be used when specifying                   //a parameter's type. For example' SqlDbType.Money or OracleType.Blob.                  table.Columns.Add("ColumnSize"' typeof(long));                  table.Columns.Add("CreateFormat"' typeof(string));                  table.Columns.Add("CreateParameters"' typeof(string));                  table.Columns.Add("DataType"' typeof(string));  // The name of the .NET Framework type of the data type.                  table.Columns.Add("IsAutoincrementable"' typeof(bool));                  table.Columns.Add("IsBestMatch"' typeof(bool));                  table.Columns.Add("IsCaseSensitive"' typeof(bool));                  table.Columns.Add("IsFixedLength"' typeof(bool));                  table.Columns.Add("IsFixedPrecisionScale"' typeof(bool));                  table.Columns.Add("IsLong"' typeof(bool));                  table.Columns.Add("IsNullable"' typeof(bool));                  table.Columns.Add("IsSearchable"' typeof(bool));                  table.Columns.Add("IsSearchableWithLike"' typeof(bool));                  table.Columns.Add("IsUnsigned"' typeof(bool));                  table.Columns.Add("MaximumScale"' typeof(short));                  table.Columns.Add("MinimumScale"' typeof(short));                  table.Columns.Add("IsConcurrencyType"' typeof(bool));                  table.Columns.Add("IsLiteralsSupported"' typeof(bool));                  table.Columns.Add("LiteralPrefix"' typeof(string));                  table.Columns.Add("LiteralSuffix"' typeof(string));                  table.Columns.Add("NativeDataType"' typeof(string));    // NativeDataType is an OLE DB specific column for exposing the OLE DB type of the data type .                    table.ReadXml(XmlReader.Create(typeof(NuoDbConnectionInternal).Assembly.GetManifestResourceStream("NuoDb.Data.Client.DataTypes.xml")));              }              else if (collectionName == "Tables")              {                  table.Columns.Add("TABLE_CATALOG"' typeof(string));                  table.Columns.Add("TABLE_SCHEMA"' typeof(string));                  table.Columns.Add("TABLE_NAME"' typeof(string));                  table.Columns.Add("TABLE_TYPE"' typeof(string));                  table.Columns.Add("REMARKS"' typeof(string));                  table.Columns.Add("VIEW_DEF"' typeof(string));                    tmConn.InternalConnection.dataStream.startMessage(Protocol.GetTables);                  tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                  for (int i = 1; i < 3; i++)                      if (restrictionValues != null && restrictionValues.Length > i)                          tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                      else                          tmConn.InternalConnection.dataStream.encodeNull();                  if (restrictionValues == null || restrictionValues.Length < 4 || restrictionValues[3] == null)                      tmConn.InternalConnection.dataStream.encodeInt(0);                  else                  {                      tmConn.InternalConnection.dataStream.encodeInt(1);                      tmConn.InternalConnection.dataStream.encodeString(restrictionValues[3]);                  }                    tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                  int handle = tmConn.InternalConnection.dataStream.getInt();                    if (handle != -1)                  {                      using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                      {                          table.BeginLoadData();                          string view_def_label="";                          try                           {                               reader.GetOrdinal("VIEW_DEF");                              view_def_label = "VIEW_DEF";                          }                          catch(Exception) {}                          try                           {                               reader.GetOrdinal("VIEWDEFINITION");                              view_def_label = "VIEWDEFINITION";                          }                          catch (Exception) { }                          while (reader.Read())                          {  #if DEBUG                          System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_NAME"] + "' " + reader["TABLE_TYPE"]);  #endif                              DataRow row = table.NewRow();                              row["TABLE_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                              row["TABLE_NAME"] = reader.GetFieldValue<string>("TABLE_NAME");                              row["TABLE_TYPE"] = reader.GetFieldValue<string>("TABLE_TYPE");                              row["REMARKS"] = reader.GetFieldValue<string>("REMARKS");                              if (view_def_label.Length != 0)                              {                                  row["VIEW_DEF"] = reader.GetFieldValue<string>(view_def_label);                              }                              table.Rows.Add(row);                          }                          table.EndLoadData();                      }                  }              }              else if (collectionName == "Columns")              {                  table.Columns.Add("COLUMN_CATALOG"' typeof(string));                  table.Columns.Add("COLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("COLUMN_TABLE"' typeof(string));                  table.Columns.Add("COLUMN_NAME"' typeof(string));                  table.Columns.Add("COLUMN_POSITION"' typeof(int));                  table.Columns.Add("COLUMN_TYPE"' typeof(string));                  table.Columns.Add("COLUMN_LENGTH"' typeof(int));                  table.Columns.Add("COLUMN_PRECISION"' typeof(int));                  table.Columns.Add("COLUMN_NULLABLE"' typeof(bool));                  table.Columns.Add("COLUMN_IDENTITY"' typeof(bool));                  table.Columns.Add("COLUMN_DEFAULT"' typeof(string));                  table.Columns.Add("COLUMN_SCALE"' typeof(int));                    tmConn.InternalConnection.dataStream.startMessage(Protocol.GetColumns);                  tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                  for (int i = 1; i < 4; i++)                      if (restrictionValues != null && restrictionValues.Length > i)                          tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                      else                          tmConn.InternalConnection.dataStream.encodeNull();                    tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                  int handle = tmConn.InternalConnection.dataStream.getInt();                    if (handle != -1)                  {                      using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                      {                          table.BeginLoadData();                          while (reader.Read())                          {                              DataRow row = table.NewRow();                              row["COLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                              row["COLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                              row["COLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                              row["COLUMN_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                              row["COLUMN_LENGTH"] = reader.GetFieldValue<int>("COLUMN_SIZE");                              row["COLUMN_PRECISION"] = reader.GetFieldValue<int>("BUFFER_LENGTH");                              row["COLUMN_SCALE"] = reader.GetFieldValue<int>("DECIMAL_DIGITS");                              if (isNumeric(reader.GetFieldValue<string>("TYPE_NAME")))                              {                                  if (reader.GetFieldValue<int>("DECIMAL_DIGITS") != 0)                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME") +                                           "(" + reader.GetFieldValue<int>("BUFFER_LENGTH") + "'" + reader.GetFieldValue<int>("DECIMAL_DIGITS") + ")";                                  else                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME");                              }                              else                              {                                  if (isVarLenType(reader.GetFieldValue<string>("TYPE_NAME")) && reader.GetFieldValue<int>("COLUMN_SIZE") != 0)                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME") +                                           "(" + reader.GetFieldValue<int>("COLUMN_SIZE") + ")";                                  else                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME");                              }                              if (!reader.IsDBNull(reader.GetOrdinal("IS_NULLABLE")))                                  row["COLUMN_NULLABLE"] = reader.GetFieldValue<string>("IS_NULLABLE").Equals("YES");                              if (!reader.IsDBNull(reader.GetOrdinal("IS_AUTOINCREMENT")))                                  row["COLUMN_IDENTITY"] = reader.GetFieldValue<string>("IS_AUTOINCREMENT").Equals("YES");                              row["COLUMN_DEFAULT"] = reader.GetFieldValue<string>("COLUMN_DEF");    #if DEBUG                              System.Diagnostics.Trace.WriteLine("-> " + row["COLUMN_NAME"] + " " + row["COLUMN_TYPE"]);  #endif                              table.Rows.Add(row);                          }                          table.EndLoadData();                      }                  }              }              else if (collectionName == "Indexes")              {                  table.Columns.Add("INDEX_CATALOG"' typeof(string));                  table.Columns.Add("INDEX_SCHEMA"' typeof(string));                  table.Columns.Add("INDEX_TABLE"' typeof(string));                  table.Columns.Add("INDEX_NAME"' typeof(string));                  table.Columns.Add("INDEX_TYPE"' typeof(string));                  table.Columns.Add("INDEX_UNIQUE"' typeof(bool));                  table.Columns.Add("INDEX_PRIMARY"' typeof(bool));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetIndexInfo);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // unique                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // approximate                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        // to avoid to insert the same index more than once                      HashSet<string> unique = new HashSet<string>();                      if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;                                  if (!unique.Add(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;                                  DataRow row = table.NewRow();                                  row["INDEX_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEX_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEX_NAME"] = reader.GetFieldValue<string>("INDEX_NAME");                                  switch (reader.GetFieldValue<int>("TYPE"))                                  {                                      case 0:                                          row["INDEX_TYPE"] = "Primary";                                          break;                                      case 1:                                          row["INDEX_TYPE"] = "Unique";                                          break;                                      case 2:                                          row["INDEX_TYPE"] = "Secondary";                                          break;                                      case 3:                                          row["INDEX_TYPE"] = "Foreign Key";                                          break;                                  }                                  row["INDEX_UNIQUE"] = (reader.GetFieldValue<int>("NON_UNIQUE") == 0) ? true : false;                                  row["INDEX_PRIMARY"] = (reader.GetFieldValue<int>("TYPE") == 0) ? true : false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                        tmConn.InternalConnection.dataStream.startMessage(Protocol.GetPrimaryKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              // use INDEX_NAME' if present; if missing' the name of the index is in PK_NAME                              string indexName = "PK_NAME";                              foreach (string column in reader.columnNames)                              {                                  if (column == "INDEX_NAME")                                  {                                      indexName = "INDEX_NAME";                                      break;                                  }                              }                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>(indexName)))                                      continue;                                  if (!unique.Add(reader.GetFieldValue<string>(indexName)))                                      continue;                                  DataRow row = table.NewRow();                                  row["INDEX_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEX_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEX_NAME"] = reader.GetFieldValue<string>(indexName);                                  row["INDEX_TYPE"] = "Primary";                                  row["INDEX_UNIQUE"] = true;                                  row["INDEX_PRIMARY"] = true;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "IndexColumns")              {                  table.Columns.Add("INDEXCOLUMN_CATALOG"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_TABLE"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_INDEX"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_NAME"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_POSITION"' typeof(int));                  table.Columns.Add("INDEXCOLUMN_ISPRIMARY"' typeof(bool));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetIndexInfo);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // unique                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // approximate                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_SCHEM"] + "." + reader["TABLE_NAME"] + "=" + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["INDEXCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEXCOLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEXCOLUMN_INDEX"] = reader.GetFieldValue<string>("INDEX_NAME");                                  row["INDEXCOLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["INDEXCOLUMN_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                                  row["INDEXCOLUMN_ISPRIMARY"] = false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                        tmConn.InternalConnection.dataStream.startMessage(Protocol.GetPrimaryKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              // use INDEX_NAME' if present; if missing' the name of the index is in PK_NAME                              string indexName = "PK_NAME";                              foreach (string column in reader.columnNames)                              {                                  if (column == "INDEX_NAME")                                  {                                      indexName = "INDEX_NAME";                                      break;                                  }                              }                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>(indexName)))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_SCHEM"] + "." + reader["TABLE_NAME"] + " (Primary) =" + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["INDEXCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEXCOLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEXCOLUMN_INDEX"] = reader.GetFieldValue<string>(indexName);                                  row["INDEXCOLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["INDEXCOLUMN_POSITION"] = reader.GetFieldValue<int>("KEY_SEQ");                                  row["INDEXCOLUMN_ISPRIMARY"] = true;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ForeignKeys")              {                  table.Columns.Add("FOREIGNKEY_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEY_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEY_TABLE"' typeof(string));                  table.Columns.Add("FOREIGNKEY_NAME"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_TABLE"' typeof(string));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetImportedKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  string name = "[" + reader.GetFieldValue<string>("FKTABLE_SCHEM") + "]" +                                                   reader.GetFieldValue<string>("FKTABLE_NAME") + "." +                                                   reader.GetFieldValue<string>("FKCOLUMN_NAME") + "->" +                                                  "[" + reader.GetFieldValue<string>("PKTABLE_SCHEM") + "]" +                                                   reader.GetFieldValue<string>("PKTABLE_NAME") + "." +                                                   reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(name))                                      continue;                                  DataRow row = table.NewRow();                                  row["FOREIGNKEY_SCHEMA"] = reader.GetFieldValue<string>("FKTABLE_SCHEM");                                  row["FOREIGNKEY_TABLE"] = reader.GetFieldValue<string>("FKTABLE_NAME");                                  row["FOREIGNKEY_NAME"] = name;                                  row["FOREIGNKEY_OTHER_SCHEMA"] = reader.GetFieldValue<string>("PKTABLE_SCHEM");                                  row["FOREIGNKEY_OTHER_TABLE"] = reader.GetFieldValue<string>("PKTABLE_NAME");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ForeignKeyColumns")              {                  table.Columns.Add("FOREIGNKEYCOLUMN_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_TABLE"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_KEY"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_NAME"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_ORDINAL"' typeof(int));                  table.Columns.Add("FOREIGNKEYCOLUMN_OTHER_COLUMN_NAME"' typeof(string));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetImportedKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  string name = "[" + reader.GetFieldValue<string>("FKTABLE_SCHEM") + "]" +                                                  reader.GetFieldValue<string>("FKTABLE_NAME") + "." +                                                  reader.GetFieldValue<string>("FKCOLUMN_NAME") + "->" +                                                  "[" + reader.GetFieldValue<string>("PKTABLE_SCHEM") + "]" +                                                  reader.GetFieldValue<string>("PKTABLE_NAME") + "." +                                                  reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(name))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["FKTABLE_SCHEM"] + "." + reader["FKTABLE_NAME"] + "=" + reader["FKCOLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["FOREIGNKEYCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("FKTABLE_SCHEM");                                  row["FOREIGNKEYCOLUMN_TABLE"] = reader.GetFieldValue<string>("FKTABLE_NAME");                                  row["FOREIGNKEYCOLUMN_KEY"] = name;                                  row["FOREIGNKEYCOLUMN_NAME"] = reader.GetFieldValue<string>("FKCOLUMN_NAME");                                  row["FOREIGNKEYCOLUMN_ORDINAL"] = reader.GetFieldValue<int>("KEY_SEQ");                                  row["FOREIGNKEYCOLUMN_OTHER_COLUMN_NAME"] = reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "Procedures")               {                  table.Columns.Add("PROCEDURE_CATALOG"' typeof(string));                  table.Columns.Add("PROCEDURE_SCHEMA"' typeof(string));                  table.Columns.Add("PROCEDURE_NAME"' typeof(string));                  table.Columns.Add("IS_SYSTEM_PROCEDURE"' typeof(bool));                    if (tmConn.InternalConnection.protocolVersion >= Protocol.PROTOCOL_VERSION12)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetProcedures);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      for (int i = 1; i < 3; i++)                          if (restrictionValues != null && restrictionValues.Length > i)                              tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                          else                              tmConn.InternalConnection.dataStream.encodeNull();                        tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["PROCEDURE_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["PROCEDURE_SCHEMA"] = reader.GetFieldValue<string>("PROCEDURE_SCHEM");                                  row["PROCEDURE_NAME"] = reader.GetFieldValue<string>("PROCEDURE_NAME");                                  row["IS_SYSTEM_PROCEDURE"] = false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ProcedureParameters")              {                  table.Columns.Add("PROCEDURE_CATALOG"' typeof(string));                  table.Columns.Add("PROCEDURE_SCHEMA"' typeof(string));                  table.Columns.Add("PROCEDURE_NAME"' typeof(string));                  table.Columns.Add("PARAMETER_NAME"' typeof(string));                  table.Columns.Add("ORDINAL_POSITION"' typeof(int));                  table.Columns.Add("PARAMETER_DATA_TYPE"' typeof(int));                  table.Columns.Add("PARAMETER_TYPE_NAME"' typeof(string));                  table.Columns.Add("PARAMETER_SIZE"' typeof(int));                  table.Columns.Add("NUMERIC_PRECISION"' typeof(int));                  table.Columns.Add("NUMERIC_SCALE"' typeof(int));                  table.Columns.Add("PARAMETER_DIRECTION"' typeof(int));                  table.Columns.Add("IS_NULLABLE"' typeof(bool));                    if (tmConn.InternalConnection.protocolVersion >= Protocol.PROTOCOL_VERSION12)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetProcedureColumns);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      for (int i = 1; i < 4; i++)                          if (restrictionValues != null && restrictionValues.Length > i)                              tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                          else                              tmConn.InternalConnection.dataStream.encodeNull();                        tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["PROCEDURE_NAME"] + "' " + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["PROCEDURE_SCHEMA"] = reader.GetFieldValue<string>("PROCEDURE_SCHEM");                                  row["PROCEDURE_NAME"] = reader.GetFieldValue<string>("PROCEDURE_NAME");                                  row["PARAMETER_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["ORDINAL_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                                  row["PARAMETER_TYPE_NAME"] = reader.GetFieldValue<string>("TYPE_NAME");                                  row["PARAMETER_DATA_TYPE"] = reader.GetFieldValue<int>("DATA_TYPE");                                  row["PARAMETER_SIZE"] = reader.GetFieldValue<int>("LENGTH");                                  row["NUMERIC_PRECISION"] = reader.GetFieldValue<int>("PRECISION");                                  row["NUMERIC_SCALE"] = reader.GetFieldValue<int>("SCALE");                                  row["PARAMETER_DIRECTION"] = reader.GetFieldValue<int>("COLUMN_TYPE");                                  row["IS_NULLABLE"] = !reader.GetFieldValue<string>("IS_NULLABLE").Equals("NO");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The following statement contains a magic number: if (collectionName == DbMetaDataCollectionNames.DataSourceInformation)              {                  // see http://msdn.microsoft.com/en-us/library/ms254501.aspx                  table.Columns.Add("CompositeIdentifierSeparatorPattern"' typeof(string));                  table.Columns.Add("DataSourceProductName"' typeof(string));                  table.Columns.Add("DataSourceProductVersion"' typeof(string));                  table.Columns.Add("DataSourceProductVersionNormalized"' typeof(string));                  table.Columns.Add("DataSourceInternalProductVersion"' typeof(string));                  table.Columns.Add("GroupByBehavior"' typeof(GroupByBehavior));                  table.Columns.Add("IdentifierPattern"' typeof(string));                  table.Columns.Add("IdentifierCase"' typeof(IdentifierCase));                  table.Columns.Add("OrderByColumnsInSelect"' typeof(bool));                  table.Columns.Add("ParameterMarkerFormat"' typeof(string));                  table.Columns.Add("ParameterMarkerPattern"' typeof(string));                  table.Columns.Add("ParameterNameMaxLength"' typeof(int));                  table.Columns.Add("ParameterNamePattern"' typeof(string));                  table.Columns.Add("QuotedIdentifierPattern"' typeof(string));  // Regex                  table.Columns.Add("QuotedIdentifierCase"' typeof(int));                  table.Columns.Add("StatementSeparatorPattern"' typeof(string));                  table.Columns.Add("StringLiteralPattern"' typeof(string));  // Regex                  table.Columns.Add("SupportedJoinOperators"' typeof(SupportedJoinOperators));                    table.BeginLoadData();                  DataRow row = table.NewRow();                  int databaseMajorVersion = 0' databaseMinorVersion = 0;                  try                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetDatabaseMetaData);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      for (int item; (item = tmConn.InternalConnection.dataStream.getInt()) != Protocol.DbmbFini; )                      {                          switch (item)                          {                              case Protocol.DbmbProductName:                                  row["DataSourceProductName"] = tmConn.InternalConnection.dataStream.getString();                                  break;                                case Protocol.DbmbProductVersion:                                  row["DataSourceProductVersion"] = tmConn.InternalConnection.dataStream.getString();                                  break;                                case Protocol.DbmbDatabaseMinorVersion:                                  databaseMinorVersion = tmConn.InternalConnection.dataStream.getInt();                                  break;                                case Protocol.DbmbDatabaseMajorVersion:                                  databaseMajorVersion = tmConn.InternalConnection.dataStream.getInt();                                  break;                                case Protocol.DbmbDefaultTransactionIsolation:                                  int defaultTransactionIsolation = tmConn.InternalConnection.dataStream.getInt();                                  break;                                default:                                  tmConn.InternalConnection.dataStream.decode();                                  break;                          }                      }                  }                  catch (Exception)                  {                  }                    row["DataSourceInternalProductVersion"] = String.Format("{0:D3}.{1:D3}"' databaseMajorVersion' databaseMinorVersion);                  // The regular expression to match the composite separators in a composite identifier.                   // For example' "\." (for SQL Server) or "@|\." (for Oracle).                  // A composite identifier is typically what is used for a database object name'                   // for example: pubs.dbo.authors or pubs@dbo.authors.                  row["CompositeIdentifierSeparatorPattern"] = "\\.";                  // A normalized version for the data source' such that it can be compared with String.Compare().                   // The format of this is consistent for all versions of the provider to prevent version 10 from sorting between version 1 and version 2.                  //row["DataSourceProductVersionNormalized"] = ??                  // Specifies the relationship between the columns in a GROUP BY clause and the non-aggregated columns in the select list.                  row["GroupByBehavior"] = GroupByBehavior.Unknown;                  // A regular expression that matches an identifier and has a match value of the identifier. For example "[A-Za-z0-9_#$]".                  row["IdentifierPattern"] = "(^\\[\\p{Lo}\\p{Lu}\\p{Ll}_@#][\\p{Lo}\\p{Lu}\\p{Ll}\\p{Nd}@$#_]*$)|(^\"[^\"\\0]|\"\"+\"$)";                  // Indicates whether non-quoted identifiers are treated as case sensitive or not.                  row["IdentifierCase"] = IdentifierCase.Insensitive;                  // Specifies whether columns in an ORDER BY clause must be in the select list.                   // A value of true indicates that they are required to be in the select list'                   // a value of false indicates that they are not required to be in the select list.                  row["OrderByColumnsInSelect"] = false;                  // For data sources that do not expect named parameters and expect the use of the ‘?’ character' the format string                  // can be specified as simply '?'' which would ignore the parameter name.                  row["ParameterMarkerFormat"] = "?";                  // if the data source doesn't support named parameters' this would simply be "?".                  row["ParameterMarkerPattern"] = "?";                  // If the data source does not support named parameters' this property returns zero.                  row["ParameterNameMaxLength"] = 0;                  // A regular expression that matches the valid parameter names                  row["ParameterNamePattern"] = "";                  // A regular expression that matches a quoted identifier and has a match value of the identifier itself without the quotes.                   // For example' if the data source used double-quotes to identify quoted identifiers' this would be: "(([^\"]|\"\")*)".                  row["QuotedIdentifierPattern"] = "\"([^\"]*)\"";                  // Indicates whether quoted identifiers are treated as case sensitive or not.                  row["QuotedIdentifierCase"] = IdentifierCase.Sensitive;                  // A regular expression that matches the statement separator.                  row["StatementSeparatorPattern"] = ";";                  // A regular expression that matches a string literal and has a match value of the literal itself.                   // For example' if the data source used single-quotes to identify strings' this would be: "('([^']|'')*')"'                  row["StringLiteralPattern"] = "'([^']*)'";                  // Specifies what types of SQL join statements are supported by the data source.                  row["SupportedJoinOperators"] = SupportedJoinOperators.None;                  table.Rows.Add(row);                  table.EndLoadData();              }              else if (collectionName == DbMetaDataCollectionNames.ReservedWords)              {                  table.Columns.Add("ReservedWord"' typeof(string));                  table.Columns.Add("MaximumVersion"' typeof(string));                  table.Columns.Add("MinimumVersion"' typeof(string));                    string[] words = { "select"' "Add field"' "Drop field"' "Alter table"' "Alter field"'                                      "Alter user"' "And"' "Or"' "Not"' "Create Index"' "Upgrade"' "Unique"'                                      "Table key"' "Table unique key"' "Primary Key"' "Create Table"'                                      "Upgrade Table"' "Rename Table"' "Create View"' "Upgrade View"'                                      "Drop View"' "Create Schema"' "Drop Schema"' "Integer"' "Smallint"'                                      "Bigint"' "Tinyint"' "float"' "double"' "Blob"' "bytes"' "boolean"'                                      "binary"' "varbinary"' "string"' "char"' "text"' "date"' "timestamp"'                                      "time"' "varchar"' "numeric"' "Decimal Number"' "Enum"' "Delete"' "Repair"'                                      "Field"' "Not Null"' "Default Value"' "searchable"' "not searchable"'                                      "collation"' "character_set"' "Foreign Key"' "Identifier"' "record number"'                                      "Insert"' "Replace"' "Name"' "Number"' "Order"' "Descending"' "limit"'                                      "Quoted String"' "Select Clause"' "Distinct"' "Gtr"' "Geq"' "Eql"'                                      "Leq"' "Lss"' "Neq"' "in list"' "in select"' "exists"' "Between"' "Like"'                                      "starts with"' "Containing"' "Matching"' "Regular expression"' "Null"'                                      "True"' "False"' "Execute"' "Parameter"' "Count"' "sum"' "min"' "max"'                                      "avg"' "Drop Index"' "Drop primary key"' "Drop foreign key"' "Drop Table"'                                      "If Exists"' "Describe"' "Statement"' "for_select"' "for_insert"' "while"'                                      "if then else"' "variable"' "declaration"' "throw"' "assignment"'                                      "Start transaction"' "read only"' "read write"' "read committed"' "write committed"'                                      "read uncommitted"' "repeatableread"' "serializable"' "Commit"' "Rollback"'                                      "Savepoint"' "Rollack Savepoint"' "Release Savepoint"' "Table"' "Derived Table"'                                      "Assign"' "Update"' "list"' "Constant"' "Function"' "Grant"' "Grant role"' "Alter"'                                      "Read"' "Identity"' "Check"' "Constraint"' "value constraint"' "auto increment"'                                      "generated"' "always"' "Domain"' "is null"' "is active_role"' "start with"' "reindex"'                                      "cursor"' "alias"' "push_namespace"' "pop_namespace"' "set_namespace"' "coalesce"'                                      "nod_nullif"' "case"' "case_search"' "add"' "subtract"' "multiply"' "divide"' "modulus"'                                      "negate"' "plus"' "cast"' "concatenation"' "create user"' "drop user"' "create role"'                                      "upgrade role"' "drop role"' "revoke"' "revoke role"' "assume"' "revert"' "negate"'                                      "priv insert"' "priv delete"' "priv execute"' "priv select"' "priv update"' "priv grant"'                                      "priv all"' "characters"' "octets"' "role"' "view"' "procedure"' "user"' "zone"' "admin"'                                      "default role"' "create sequence"' "upgrade sequence"' "drop sequence"' "next value"'                                      "create trigger"' "upgrade trigger"' "alter trigger"' "drop trigger"' "create procedure"'                                      "upgrade procedure"' "alter procedure"' "drop procedure"' "pre-insert"' "post-insert"'                                      "pre-update"' "post-update"' "pre-delete"' "post-delete"' "pre-commit"' "post-commit"'                                      "active"' "inactive"' "position"' "select-expr"' "create filterset"' "upgrade filterset"'                                      "drop filterset"' "enable filterset"' "disable filterset"' "table filter"' "left outer"'                                      "right outer"' "full outer"' "inner"' "join"' "join_term"' "trigger class"' "enable trigger class"'                                      "disable trigger class"' "create zone"' "upgrade zone"' "drop zone"' "range"' "ip address"'                                      "node_name"' "wildcard"' "create domain"' "upgrade domain"' "alter domain"' "upgrade schema"'                                      "delete cascade"' "index segment"' "for update"' "write committed"' "read committed"'                                       "consistent read"' "set dialect"' "set names"' "restrict"' "cascade"' "characters"' "octets"'                                      "create event"' "collate"' "truncate"' "restart"' "nameless constraint"' "drop constraint"'                                      "drop unique constraint"' "drop domain"' "with check option"' "not real"' "lower"' "upper"'                                      "substr"' "substring index"' "charlength"' "default keyword"' "sqrt"' "power"' "Scientific Notation Number"'                                      "Explain"' "msleep"' "KillStatement"' "now" };                  table.BeginLoadData();                  foreach (string keyword in words)                  {                      DataRow row = table.NewRow();                      row["ReservedWord"] = keyword;                      table.Rows.Add(row);                  }                  table.EndLoadData();                }              else if (collectionName == DbMetaDataCollectionNames.DataTypes)              {                  table.Columns.Add("TypeName"' typeof(string));  // The provider-specific data type name.                  table.Columns.Add("ProviderDbType"' typeof(int)); // The provider-specific type value that should be used when specifying                   //a parameter's type. For example' SqlDbType.Money or OracleType.Blob.                  table.Columns.Add("ColumnSize"' typeof(long));                  table.Columns.Add("CreateFormat"' typeof(string));                  table.Columns.Add("CreateParameters"' typeof(string));                  table.Columns.Add("DataType"' typeof(string));  // The name of the .NET Framework type of the data type.                  table.Columns.Add("IsAutoincrementable"' typeof(bool));                  table.Columns.Add("IsBestMatch"' typeof(bool));                  table.Columns.Add("IsCaseSensitive"' typeof(bool));                  table.Columns.Add("IsFixedLength"' typeof(bool));                  table.Columns.Add("IsFixedPrecisionScale"' typeof(bool));                  table.Columns.Add("IsLong"' typeof(bool));                  table.Columns.Add("IsNullable"' typeof(bool));                  table.Columns.Add("IsSearchable"' typeof(bool));                  table.Columns.Add("IsSearchableWithLike"' typeof(bool));                  table.Columns.Add("IsUnsigned"' typeof(bool));                  table.Columns.Add("MaximumScale"' typeof(short));                  table.Columns.Add("MinimumScale"' typeof(short));                  table.Columns.Add("IsConcurrencyType"' typeof(bool));                  table.Columns.Add("IsLiteralsSupported"' typeof(bool));                  table.Columns.Add("LiteralPrefix"' typeof(string));                  table.Columns.Add("LiteralSuffix"' typeof(string));                  table.Columns.Add("NativeDataType"' typeof(string));    // NativeDataType is an OLE DB specific column for exposing the OLE DB type of the data type .                    table.ReadXml(XmlReader.Create(typeof(NuoDbConnectionInternal).Assembly.GetManifestResourceStream("NuoDb.Data.Client.DataTypes.xml")));              }              else if (collectionName == "Tables")              {                  table.Columns.Add("TABLE_CATALOG"' typeof(string));                  table.Columns.Add("TABLE_SCHEMA"' typeof(string));                  table.Columns.Add("TABLE_NAME"' typeof(string));                  table.Columns.Add("TABLE_TYPE"' typeof(string));                  table.Columns.Add("REMARKS"' typeof(string));                  table.Columns.Add("VIEW_DEF"' typeof(string));                    tmConn.InternalConnection.dataStream.startMessage(Protocol.GetTables);                  tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                  for (int i = 1; i < 3; i++)                      if (restrictionValues != null && restrictionValues.Length > i)                          tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                      else                          tmConn.InternalConnection.dataStream.encodeNull();                  if (restrictionValues == null || restrictionValues.Length < 4 || restrictionValues[3] == null)                      tmConn.InternalConnection.dataStream.encodeInt(0);                  else                  {                      tmConn.InternalConnection.dataStream.encodeInt(1);                      tmConn.InternalConnection.dataStream.encodeString(restrictionValues[3]);                  }                    tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                  int handle = tmConn.InternalConnection.dataStream.getInt();                    if (handle != -1)                  {                      using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                      {                          table.BeginLoadData();                          string view_def_label="";                          try                           {                               reader.GetOrdinal("VIEW_DEF");                              view_def_label = "VIEW_DEF";                          }                          catch(Exception) {}                          try                           {                               reader.GetOrdinal("VIEWDEFINITION");                              view_def_label = "VIEWDEFINITION";                          }                          catch (Exception) { }                          while (reader.Read())                          {  #if DEBUG                          System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_NAME"] + "' " + reader["TABLE_TYPE"]);  #endif                              DataRow row = table.NewRow();                              row["TABLE_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                              row["TABLE_NAME"] = reader.GetFieldValue<string>("TABLE_NAME");                              row["TABLE_TYPE"] = reader.GetFieldValue<string>("TABLE_TYPE");                              row["REMARKS"] = reader.GetFieldValue<string>("REMARKS");                              if (view_def_label.Length != 0)                              {                                  row["VIEW_DEF"] = reader.GetFieldValue<string>(view_def_label);                              }                              table.Rows.Add(row);                          }                          table.EndLoadData();                      }                  }              }              else if (collectionName == "Columns")              {                  table.Columns.Add("COLUMN_CATALOG"' typeof(string));                  table.Columns.Add("COLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("COLUMN_TABLE"' typeof(string));                  table.Columns.Add("COLUMN_NAME"' typeof(string));                  table.Columns.Add("COLUMN_POSITION"' typeof(int));                  table.Columns.Add("COLUMN_TYPE"' typeof(string));                  table.Columns.Add("COLUMN_LENGTH"' typeof(int));                  table.Columns.Add("COLUMN_PRECISION"' typeof(int));                  table.Columns.Add("COLUMN_NULLABLE"' typeof(bool));                  table.Columns.Add("COLUMN_IDENTITY"' typeof(bool));                  table.Columns.Add("COLUMN_DEFAULT"' typeof(string));                  table.Columns.Add("COLUMN_SCALE"' typeof(int));                    tmConn.InternalConnection.dataStream.startMessage(Protocol.GetColumns);                  tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                  for (int i = 1; i < 4; i++)                      if (restrictionValues != null && restrictionValues.Length > i)                          tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                      else                          tmConn.InternalConnection.dataStream.encodeNull();                    tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                  int handle = tmConn.InternalConnection.dataStream.getInt();                    if (handle != -1)                  {                      using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                      {                          table.BeginLoadData();                          while (reader.Read())                          {                              DataRow row = table.NewRow();                              row["COLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                              row["COLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                              row["COLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                              row["COLUMN_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                              row["COLUMN_LENGTH"] = reader.GetFieldValue<int>("COLUMN_SIZE");                              row["COLUMN_PRECISION"] = reader.GetFieldValue<int>("BUFFER_LENGTH");                              row["COLUMN_SCALE"] = reader.GetFieldValue<int>("DECIMAL_DIGITS");                              if (isNumeric(reader.GetFieldValue<string>("TYPE_NAME")))                              {                                  if (reader.GetFieldValue<int>("DECIMAL_DIGITS") != 0)                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME") +                                           "(" + reader.GetFieldValue<int>("BUFFER_LENGTH") + "'" + reader.GetFieldValue<int>("DECIMAL_DIGITS") + ")";                                  else                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME");                              }                              else                              {                                  if (isVarLenType(reader.GetFieldValue<string>("TYPE_NAME")) && reader.GetFieldValue<int>("COLUMN_SIZE") != 0)                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME") +                                           "(" + reader.GetFieldValue<int>("COLUMN_SIZE") + ")";                                  else                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME");                              }                              if (!reader.IsDBNull(reader.GetOrdinal("IS_NULLABLE")))                                  row["COLUMN_NULLABLE"] = reader.GetFieldValue<string>("IS_NULLABLE").Equals("YES");                              if (!reader.IsDBNull(reader.GetOrdinal("IS_AUTOINCREMENT")))                                  row["COLUMN_IDENTITY"] = reader.GetFieldValue<string>("IS_AUTOINCREMENT").Equals("YES");                              row["COLUMN_DEFAULT"] = reader.GetFieldValue<string>("COLUMN_DEF");    #if DEBUG                              System.Diagnostics.Trace.WriteLine("-> " + row["COLUMN_NAME"] + " " + row["COLUMN_TYPE"]);  #endif                              table.Rows.Add(row);                          }                          table.EndLoadData();                      }                  }              }              else if (collectionName == "Indexes")              {                  table.Columns.Add("INDEX_CATALOG"' typeof(string));                  table.Columns.Add("INDEX_SCHEMA"' typeof(string));                  table.Columns.Add("INDEX_TABLE"' typeof(string));                  table.Columns.Add("INDEX_NAME"' typeof(string));                  table.Columns.Add("INDEX_TYPE"' typeof(string));                  table.Columns.Add("INDEX_UNIQUE"' typeof(bool));                  table.Columns.Add("INDEX_PRIMARY"' typeof(bool));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetIndexInfo);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // unique                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // approximate                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        // to avoid to insert the same index more than once                      HashSet<string> unique = new HashSet<string>();                      if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;                                  if (!unique.Add(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;                                  DataRow row = table.NewRow();                                  row["INDEX_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEX_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEX_NAME"] = reader.GetFieldValue<string>("INDEX_NAME");                                  switch (reader.GetFieldValue<int>("TYPE"))                                  {                                      case 0:                                          row["INDEX_TYPE"] = "Primary";                                          break;                                      case 1:                                          row["INDEX_TYPE"] = "Unique";                                          break;                                      case 2:                                          row["INDEX_TYPE"] = "Secondary";                                          break;                                      case 3:                                          row["INDEX_TYPE"] = "Foreign Key";                                          break;                                  }                                  row["INDEX_UNIQUE"] = (reader.GetFieldValue<int>("NON_UNIQUE") == 0) ? true : false;                                  row["INDEX_PRIMARY"] = (reader.GetFieldValue<int>("TYPE") == 0) ? true : false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                        tmConn.InternalConnection.dataStream.startMessage(Protocol.GetPrimaryKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              // use INDEX_NAME' if present; if missing' the name of the index is in PK_NAME                              string indexName = "PK_NAME";                              foreach (string column in reader.columnNames)                              {                                  if (column == "INDEX_NAME")                                  {                                      indexName = "INDEX_NAME";                                      break;                                  }                              }                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>(indexName)))                                      continue;                                  if (!unique.Add(reader.GetFieldValue<string>(indexName)))                                      continue;                                  DataRow row = table.NewRow();                                  row["INDEX_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEX_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEX_NAME"] = reader.GetFieldValue<string>(indexName);                                  row["INDEX_TYPE"] = "Primary";                                  row["INDEX_UNIQUE"] = true;                                  row["INDEX_PRIMARY"] = true;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "IndexColumns")              {                  table.Columns.Add("INDEXCOLUMN_CATALOG"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_TABLE"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_INDEX"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_NAME"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_POSITION"' typeof(int));                  table.Columns.Add("INDEXCOLUMN_ISPRIMARY"' typeof(bool));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetIndexInfo);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // unique                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // approximate                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_SCHEM"] + "." + reader["TABLE_NAME"] + "=" + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["INDEXCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEXCOLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEXCOLUMN_INDEX"] = reader.GetFieldValue<string>("INDEX_NAME");                                  row["INDEXCOLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["INDEXCOLUMN_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                                  row["INDEXCOLUMN_ISPRIMARY"] = false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                        tmConn.InternalConnection.dataStream.startMessage(Protocol.GetPrimaryKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              // use INDEX_NAME' if present; if missing' the name of the index is in PK_NAME                              string indexName = "PK_NAME";                              foreach (string column in reader.columnNames)                              {                                  if (column == "INDEX_NAME")                                  {                                      indexName = "INDEX_NAME";                                      break;                                  }                              }                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>(indexName)))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_SCHEM"] + "." + reader["TABLE_NAME"] + " (Primary) =" + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["INDEXCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEXCOLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEXCOLUMN_INDEX"] = reader.GetFieldValue<string>(indexName);                                  row["INDEXCOLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["INDEXCOLUMN_POSITION"] = reader.GetFieldValue<int>("KEY_SEQ");                                  row["INDEXCOLUMN_ISPRIMARY"] = true;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ForeignKeys")              {                  table.Columns.Add("FOREIGNKEY_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEY_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEY_TABLE"' typeof(string));                  table.Columns.Add("FOREIGNKEY_NAME"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_TABLE"' typeof(string));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetImportedKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  string name = "[" + reader.GetFieldValue<string>("FKTABLE_SCHEM") + "]" +                                                   reader.GetFieldValue<string>("FKTABLE_NAME") + "." +                                                   reader.GetFieldValue<string>("FKCOLUMN_NAME") + "->" +                                                  "[" + reader.GetFieldValue<string>("PKTABLE_SCHEM") + "]" +                                                   reader.GetFieldValue<string>("PKTABLE_NAME") + "." +                                                   reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(name))                                      continue;                                  DataRow row = table.NewRow();                                  row["FOREIGNKEY_SCHEMA"] = reader.GetFieldValue<string>("FKTABLE_SCHEM");                                  row["FOREIGNKEY_TABLE"] = reader.GetFieldValue<string>("FKTABLE_NAME");                                  row["FOREIGNKEY_NAME"] = name;                                  row["FOREIGNKEY_OTHER_SCHEMA"] = reader.GetFieldValue<string>("PKTABLE_SCHEM");                                  row["FOREIGNKEY_OTHER_TABLE"] = reader.GetFieldValue<string>("PKTABLE_NAME");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ForeignKeyColumns")              {                  table.Columns.Add("FOREIGNKEYCOLUMN_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_TABLE"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_KEY"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_NAME"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_ORDINAL"' typeof(int));                  table.Columns.Add("FOREIGNKEYCOLUMN_OTHER_COLUMN_NAME"' typeof(string));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetImportedKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  string name = "[" + reader.GetFieldValue<string>("FKTABLE_SCHEM") + "]" +                                                  reader.GetFieldValue<string>("FKTABLE_NAME") + "." +                                                  reader.GetFieldValue<string>("FKCOLUMN_NAME") + "->" +                                                  "[" + reader.GetFieldValue<string>("PKTABLE_SCHEM") + "]" +                                                  reader.GetFieldValue<string>("PKTABLE_NAME") + "." +                                                  reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(name))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["FKTABLE_SCHEM"] + "." + reader["FKTABLE_NAME"] + "=" + reader["FKCOLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["FOREIGNKEYCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("FKTABLE_SCHEM");                                  row["FOREIGNKEYCOLUMN_TABLE"] = reader.GetFieldValue<string>("FKTABLE_NAME");                                  row["FOREIGNKEYCOLUMN_KEY"] = name;                                  row["FOREIGNKEYCOLUMN_NAME"] = reader.GetFieldValue<string>("FKCOLUMN_NAME");                                  row["FOREIGNKEYCOLUMN_ORDINAL"] = reader.GetFieldValue<int>("KEY_SEQ");                                  row["FOREIGNKEYCOLUMN_OTHER_COLUMN_NAME"] = reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "Procedures")               {                  table.Columns.Add("PROCEDURE_CATALOG"' typeof(string));                  table.Columns.Add("PROCEDURE_SCHEMA"' typeof(string));                  table.Columns.Add("PROCEDURE_NAME"' typeof(string));                  table.Columns.Add("IS_SYSTEM_PROCEDURE"' typeof(bool));                    if (tmConn.InternalConnection.protocolVersion >= Protocol.PROTOCOL_VERSION12)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetProcedures);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      for (int i = 1; i < 3; i++)                          if (restrictionValues != null && restrictionValues.Length > i)                              tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                          else                              tmConn.InternalConnection.dataStream.encodeNull();                        tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["PROCEDURE_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["PROCEDURE_SCHEMA"] = reader.GetFieldValue<string>("PROCEDURE_SCHEM");                                  row["PROCEDURE_NAME"] = reader.GetFieldValue<string>("PROCEDURE_NAME");                                  row["IS_SYSTEM_PROCEDURE"] = false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ProcedureParameters")              {                  table.Columns.Add("PROCEDURE_CATALOG"' typeof(string));                  table.Columns.Add("PROCEDURE_SCHEMA"' typeof(string));                  table.Columns.Add("PROCEDURE_NAME"' typeof(string));                  table.Columns.Add("PARAMETER_NAME"' typeof(string));                  table.Columns.Add("ORDINAL_POSITION"' typeof(int));                  table.Columns.Add("PARAMETER_DATA_TYPE"' typeof(int));                  table.Columns.Add("PARAMETER_TYPE_NAME"' typeof(string));                  table.Columns.Add("PARAMETER_SIZE"' typeof(int));                  table.Columns.Add("NUMERIC_PRECISION"' typeof(int));                  table.Columns.Add("NUMERIC_SCALE"' typeof(int));                  table.Columns.Add("PARAMETER_DIRECTION"' typeof(int));                  table.Columns.Add("IS_NULLABLE"' typeof(bool));                    if (tmConn.InternalConnection.protocolVersion >= Protocol.PROTOCOL_VERSION12)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetProcedureColumns);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      for (int i = 1; i < 4; i++)                          if (restrictionValues != null && restrictionValues.Length > i)                              tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                          else                              tmConn.InternalConnection.dataStream.encodeNull();                        tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["PROCEDURE_NAME"] + "' " + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["PROCEDURE_SCHEMA"] = reader.GetFieldValue<string>("PROCEDURE_SCHEM");                                  row["PROCEDURE_NAME"] = reader.GetFieldValue<string>("PROCEDURE_NAME");                                  row["PARAMETER_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["ORDINAL_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                                  row["PARAMETER_TYPE_NAME"] = reader.GetFieldValue<string>("TYPE_NAME");                                  row["PARAMETER_DATA_TYPE"] = reader.GetFieldValue<int>("DATA_TYPE");                                  row["PARAMETER_SIZE"] = reader.GetFieldValue<int>("LENGTH");                                  row["NUMERIC_PRECISION"] = reader.GetFieldValue<int>("PRECISION");                                  row["NUMERIC_SCALE"] = reader.GetFieldValue<int>("SCALE");                                  row["PARAMETER_DIRECTION"] = reader.GetFieldValue<int>("COLUMN_TYPE");                                  row["IS_NULLABLE"] = !reader.GetFieldValue<string>("IS_NULLABLE").Equals("NO");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The following statement contains a magic number: if (collectionName == DbMetaDataCollectionNames.DataSourceInformation)              {                  // see http://msdn.microsoft.com/en-us/library/ms254501.aspx                  table.Columns.Add("CompositeIdentifierSeparatorPattern"' typeof(string));                  table.Columns.Add("DataSourceProductName"' typeof(string));                  table.Columns.Add("DataSourceProductVersion"' typeof(string));                  table.Columns.Add("DataSourceProductVersionNormalized"' typeof(string));                  table.Columns.Add("DataSourceInternalProductVersion"' typeof(string));                  table.Columns.Add("GroupByBehavior"' typeof(GroupByBehavior));                  table.Columns.Add("IdentifierPattern"' typeof(string));                  table.Columns.Add("IdentifierCase"' typeof(IdentifierCase));                  table.Columns.Add("OrderByColumnsInSelect"' typeof(bool));                  table.Columns.Add("ParameterMarkerFormat"' typeof(string));                  table.Columns.Add("ParameterMarkerPattern"' typeof(string));                  table.Columns.Add("ParameterNameMaxLength"' typeof(int));                  table.Columns.Add("ParameterNamePattern"' typeof(string));                  table.Columns.Add("QuotedIdentifierPattern"' typeof(string));  // Regex                  table.Columns.Add("QuotedIdentifierCase"' typeof(int));                  table.Columns.Add("StatementSeparatorPattern"' typeof(string));                  table.Columns.Add("StringLiteralPattern"' typeof(string));  // Regex                  table.Columns.Add("SupportedJoinOperators"' typeof(SupportedJoinOperators));                    table.BeginLoadData();                  DataRow row = table.NewRow();                  int databaseMajorVersion = 0' databaseMinorVersion = 0;                  try                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetDatabaseMetaData);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      for (int item; (item = tmConn.InternalConnection.dataStream.getInt()) != Protocol.DbmbFini; )                      {                          switch (item)                          {                              case Protocol.DbmbProductName:                                  row["DataSourceProductName"] = tmConn.InternalConnection.dataStream.getString();                                  break;                                case Protocol.DbmbProductVersion:                                  row["DataSourceProductVersion"] = tmConn.InternalConnection.dataStream.getString();                                  break;                                case Protocol.DbmbDatabaseMinorVersion:                                  databaseMinorVersion = tmConn.InternalConnection.dataStream.getInt();                                  break;                                case Protocol.DbmbDatabaseMajorVersion:                                  databaseMajorVersion = tmConn.InternalConnection.dataStream.getInt();                                  break;                                case Protocol.DbmbDefaultTransactionIsolation:                                  int defaultTransactionIsolation = tmConn.InternalConnection.dataStream.getInt();                                  break;                                default:                                  tmConn.InternalConnection.dataStream.decode();                                  break;                          }                      }                  }                  catch (Exception)                  {                  }                    row["DataSourceInternalProductVersion"] = String.Format("{0:D3}.{1:D3}"' databaseMajorVersion' databaseMinorVersion);                  // The regular expression to match the composite separators in a composite identifier.                   // For example' "\." (for SQL Server) or "@|\." (for Oracle).                  // A composite identifier is typically what is used for a database object name'                   // for example: pubs.dbo.authors or pubs@dbo.authors.                  row["CompositeIdentifierSeparatorPattern"] = "\\.";                  // A normalized version for the data source' such that it can be compared with String.Compare().                   // The format of this is consistent for all versions of the provider to prevent version 10 from sorting between version 1 and version 2.                  //row["DataSourceProductVersionNormalized"] = ??                  // Specifies the relationship between the columns in a GROUP BY clause and the non-aggregated columns in the select list.                  row["GroupByBehavior"] = GroupByBehavior.Unknown;                  // A regular expression that matches an identifier and has a match value of the identifier. For example "[A-Za-z0-9_#$]".                  row["IdentifierPattern"] = "(^\\[\\p{Lo}\\p{Lu}\\p{Ll}_@#][\\p{Lo}\\p{Lu}\\p{Ll}\\p{Nd}@$#_]*$)|(^\"[^\"\\0]|\"\"+\"$)";                  // Indicates whether non-quoted identifiers are treated as case sensitive or not.                  row["IdentifierCase"] = IdentifierCase.Insensitive;                  // Specifies whether columns in an ORDER BY clause must be in the select list.                   // A value of true indicates that they are required to be in the select list'                   // a value of false indicates that they are not required to be in the select list.                  row["OrderByColumnsInSelect"] = false;                  // For data sources that do not expect named parameters and expect the use of the ‘?’ character' the format string                  // can be specified as simply '?'' which would ignore the parameter name.                  row["ParameterMarkerFormat"] = "?";                  // if the data source doesn't support named parameters' this would simply be "?".                  row["ParameterMarkerPattern"] = "?";                  // If the data source does not support named parameters' this property returns zero.                  row["ParameterNameMaxLength"] = 0;                  // A regular expression that matches the valid parameter names                  row["ParameterNamePattern"] = "";                  // A regular expression that matches a quoted identifier and has a match value of the identifier itself without the quotes.                   // For example' if the data source used double-quotes to identify quoted identifiers' this would be: "(([^\"]|\"\")*)".                  row["QuotedIdentifierPattern"] = "\"([^\"]*)\"";                  // Indicates whether quoted identifiers are treated as case sensitive or not.                  row["QuotedIdentifierCase"] = IdentifierCase.Sensitive;                  // A regular expression that matches the statement separator.                  row["StatementSeparatorPattern"] = ";";                  // A regular expression that matches a string literal and has a match value of the literal itself.                   // For example' if the data source used single-quotes to identify strings' this would be: "('([^']|'')*')"'                  row["StringLiteralPattern"] = "'([^']*)'";                  // Specifies what types of SQL join statements are supported by the data source.                  row["SupportedJoinOperators"] = SupportedJoinOperators.None;                  table.Rows.Add(row);                  table.EndLoadData();              }              else if (collectionName == DbMetaDataCollectionNames.ReservedWords)              {                  table.Columns.Add("ReservedWord"' typeof(string));                  table.Columns.Add("MaximumVersion"' typeof(string));                  table.Columns.Add("MinimumVersion"' typeof(string));                    string[] words = { "select"' "Add field"' "Drop field"' "Alter table"' "Alter field"'                                      "Alter user"' "And"' "Or"' "Not"' "Create Index"' "Upgrade"' "Unique"'                                      "Table key"' "Table unique key"' "Primary Key"' "Create Table"'                                      "Upgrade Table"' "Rename Table"' "Create View"' "Upgrade View"'                                      "Drop View"' "Create Schema"' "Drop Schema"' "Integer"' "Smallint"'                                      "Bigint"' "Tinyint"' "float"' "double"' "Blob"' "bytes"' "boolean"'                                      "binary"' "varbinary"' "string"' "char"' "text"' "date"' "timestamp"'                                      "time"' "varchar"' "numeric"' "Decimal Number"' "Enum"' "Delete"' "Repair"'                                      "Field"' "Not Null"' "Default Value"' "searchable"' "not searchable"'                                      "collation"' "character_set"' "Foreign Key"' "Identifier"' "record number"'                                      "Insert"' "Replace"' "Name"' "Number"' "Order"' "Descending"' "limit"'                                      "Quoted String"' "Select Clause"' "Distinct"' "Gtr"' "Geq"' "Eql"'                                      "Leq"' "Lss"' "Neq"' "in list"' "in select"' "exists"' "Between"' "Like"'                                      "starts with"' "Containing"' "Matching"' "Regular expression"' "Null"'                                      "True"' "False"' "Execute"' "Parameter"' "Count"' "sum"' "min"' "max"'                                      "avg"' "Drop Index"' "Drop primary key"' "Drop foreign key"' "Drop Table"'                                      "If Exists"' "Describe"' "Statement"' "for_select"' "for_insert"' "while"'                                      "if then else"' "variable"' "declaration"' "throw"' "assignment"'                                      "Start transaction"' "read only"' "read write"' "read committed"' "write committed"'                                      "read uncommitted"' "repeatableread"' "serializable"' "Commit"' "Rollback"'                                      "Savepoint"' "Rollack Savepoint"' "Release Savepoint"' "Table"' "Derived Table"'                                      "Assign"' "Update"' "list"' "Constant"' "Function"' "Grant"' "Grant role"' "Alter"'                                      "Read"' "Identity"' "Check"' "Constraint"' "value constraint"' "auto increment"'                                      "generated"' "always"' "Domain"' "is null"' "is active_role"' "start with"' "reindex"'                                      "cursor"' "alias"' "push_namespace"' "pop_namespace"' "set_namespace"' "coalesce"'                                      "nod_nullif"' "case"' "case_search"' "add"' "subtract"' "multiply"' "divide"' "modulus"'                                      "negate"' "plus"' "cast"' "concatenation"' "create user"' "drop user"' "create role"'                                      "upgrade role"' "drop role"' "revoke"' "revoke role"' "assume"' "revert"' "negate"'                                      "priv insert"' "priv delete"' "priv execute"' "priv select"' "priv update"' "priv grant"'                                      "priv all"' "characters"' "octets"' "role"' "view"' "procedure"' "user"' "zone"' "admin"'                                      "default role"' "create sequence"' "upgrade sequence"' "drop sequence"' "next value"'                                      "create trigger"' "upgrade trigger"' "alter trigger"' "drop trigger"' "create procedure"'                                      "upgrade procedure"' "alter procedure"' "drop procedure"' "pre-insert"' "post-insert"'                                      "pre-update"' "post-update"' "pre-delete"' "post-delete"' "pre-commit"' "post-commit"'                                      "active"' "inactive"' "position"' "select-expr"' "create filterset"' "upgrade filterset"'                                      "drop filterset"' "enable filterset"' "disable filterset"' "table filter"' "left outer"'                                      "right outer"' "full outer"' "inner"' "join"' "join_term"' "trigger class"' "enable trigger class"'                                      "disable trigger class"' "create zone"' "upgrade zone"' "drop zone"' "range"' "ip address"'                                      "node_name"' "wildcard"' "create domain"' "upgrade domain"' "alter domain"' "upgrade schema"'                                      "delete cascade"' "index segment"' "for update"' "write committed"' "read committed"'                                       "consistent read"' "set dialect"' "set names"' "restrict"' "cascade"' "characters"' "octets"'                                      "create event"' "collate"' "truncate"' "restart"' "nameless constraint"' "drop constraint"'                                      "drop unique constraint"' "drop domain"' "with check option"' "not real"' "lower"' "upper"'                                      "substr"' "substring index"' "charlength"' "default keyword"' "sqrt"' "power"' "Scientific Notation Number"'                                      "Explain"' "msleep"' "KillStatement"' "now" };                  table.BeginLoadData();                  foreach (string keyword in words)                  {                      DataRow row = table.NewRow();                      row["ReservedWord"] = keyword;                      table.Rows.Add(row);                  }                  table.EndLoadData();                }              else if (collectionName == DbMetaDataCollectionNames.DataTypes)              {                  table.Columns.Add("TypeName"' typeof(string));  // The provider-specific data type name.                  table.Columns.Add("ProviderDbType"' typeof(int)); // The provider-specific type value that should be used when specifying                   //a parameter's type. For example' SqlDbType.Money or OracleType.Blob.                  table.Columns.Add("ColumnSize"' typeof(long));                  table.Columns.Add("CreateFormat"' typeof(string));                  table.Columns.Add("CreateParameters"' typeof(string));                  table.Columns.Add("DataType"' typeof(string));  // The name of the .NET Framework type of the data type.                  table.Columns.Add("IsAutoincrementable"' typeof(bool));                  table.Columns.Add("IsBestMatch"' typeof(bool));                  table.Columns.Add("IsCaseSensitive"' typeof(bool));                  table.Columns.Add("IsFixedLength"' typeof(bool));                  table.Columns.Add("IsFixedPrecisionScale"' typeof(bool));                  table.Columns.Add("IsLong"' typeof(bool));                  table.Columns.Add("IsNullable"' typeof(bool));                  table.Columns.Add("IsSearchable"' typeof(bool));                  table.Columns.Add("IsSearchableWithLike"' typeof(bool));                  table.Columns.Add("IsUnsigned"' typeof(bool));                  table.Columns.Add("MaximumScale"' typeof(short));                  table.Columns.Add("MinimumScale"' typeof(short));                  table.Columns.Add("IsConcurrencyType"' typeof(bool));                  table.Columns.Add("IsLiteralsSupported"' typeof(bool));                  table.Columns.Add("LiteralPrefix"' typeof(string));                  table.Columns.Add("LiteralSuffix"' typeof(string));                  table.Columns.Add("NativeDataType"' typeof(string));    // NativeDataType is an OLE DB specific column for exposing the OLE DB type of the data type .                    table.ReadXml(XmlReader.Create(typeof(NuoDbConnectionInternal).Assembly.GetManifestResourceStream("NuoDb.Data.Client.DataTypes.xml")));              }              else if (collectionName == "Tables")              {                  table.Columns.Add("TABLE_CATALOG"' typeof(string));                  table.Columns.Add("TABLE_SCHEMA"' typeof(string));                  table.Columns.Add("TABLE_NAME"' typeof(string));                  table.Columns.Add("TABLE_TYPE"' typeof(string));                  table.Columns.Add("REMARKS"' typeof(string));                  table.Columns.Add("VIEW_DEF"' typeof(string));                    tmConn.InternalConnection.dataStream.startMessage(Protocol.GetTables);                  tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                  for (int i = 1; i < 3; i++)                      if (restrictionValues != null && restrictionValues.Length > i)                          tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                      else                          tmConn.InternalConnection.dataStream.encodeNull();                  if (restrictionValues == null || restrictionValues.Length < 4 || restrictionValues[3] == null)                      tmConn.InternalConnection.dataStream.encodeInt(0);                  else                  {                      tmConn.InternalConnection.dataStream.encodeInt(1);                      tmConn.InternalConnection.dataStream.encodeString(restrictionValues[3]);                  }                    tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                  int handle = tmConn.InternalConnection.dataStream.getInt();                    if (handle != -1)                  {                      using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                      {                          table.BeginLoadData();                          string view_def_label="";                          try                           {                               reader.GetOrdinal("VIEW_DEF");                              view_def_label = "VIEW_DEF";                          }                          catch(Exception) {}                          try                           {                               reader.GetOrdinal("VIEWDEFINITION");                              view_def_label = "VIEWDEFINITION";                          }                          catch (Exception) { }                          while (reader.Read())                          {  #if DEBUG                          System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_NAME"] + "' " + reader["TABLE_TYPE"]);  #endif                              DataRow row = table.NewRow();                              row["TABLE_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                              row["TABLE_NAME"] = reader.GetFieldValue<string>("TABLE_NAME");                              row["TABLE_TYPE"] = reader.GetFieldValue<string>("TABLE_TYPE");                              row["REMARKS"] = reader.GetFieldValue<string>("REMARKS");                              if (view_def_label.Length != 0)                              {                                  row["VIEW_DEF"] = reader.GetFieldValue<string>(view_def_label);                              }                              table.Rows.Add(row);                          }                          table.EndLoadData();                      }                  }              }              else if (collectionName == "Columns")              {                  table.Columns.Add("COLUMN_CATALOG"' typeof(string));                  table.Columns.Add("COLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("COLUMN_TABLE"' typeof(string));                  table.Columns.Add("COLUMN_NAME"' typeof(string));                  table.Columns.Add("COLUMN_POSITION"' typeof(int));                  table.Columns.Add("COLUMN_TYPE"' typeof(string));                  table.Columns.Add("COLUMN_LENGTH"' typeof(int));                  table.Columns.Add("COLUMN_PRECISION"' typeof(int));                  table.Columns.Add("COLUMN_NULLABLE"' typeof(bool));                  table.Columns.Add("COLUMN_IDENTITY"' typeof(bool));                  table.Columns.Add("COLUMN_DEFAULT"' typeof(string));                  table.Columns.Add("COLUMN_SCALE"' typeof(int));                    tmConn.InternalConnection.dataStream.startMessage(Protocol.GetColumns);                  tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                  for (int i = 1; i < 4; i++)                      if (restrictionValues != null && restrictionValues.Length > i)                          tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                      else                          tmConn.InternalConnection.dataStream.encodeNull();                    tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                  int handle = tmConn.InternalConnection.dataStream.getInt();                    if (handle != -1)                  {                      using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                      {                          table.BeginLoadData();                          while (reader.Read())                          {                              DataRow row = table.NewRow();                              row["COLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                              row["COLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                              row["COLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                              row["COLUMN_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                              row["COLUMN_LENGTH"] = reader.GetFieldValue<int>("COLUMN_SIZE");                              row["COLUMN_PRECISION"] = reader.GetFieldValue<int>("BUFFER_LENGTH");                              row["COLUMN_SCALE"] = reader.GetFieldValue<int>("DECIMAL_DIGITS");                              if (isNumeric(reader.GetFieldValue<string>("TYPE_NAME")))                              {                                  if (reader.GetFieldValue<int>("DECIMAL_DIGITS") != 0)                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME") +                                           "(" + reader.GetFieldValue<int>("BUFFER_LENGTH") + "'" + reader.GetFieldValue<int>("DECIMAL_DIGITS") + ")";                                  else                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME");                              }                              else                              {                                  if (isVarLenType(reader.GetFieldValue<string>("TYPE_NAME")) && reader.GetFieldValue<int>("COLUMN_SIZE") != 0)                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME") +                                           "(" + reader.GetFieldValue<int>("COLUMN_SIZE") + ")";                                  else                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME");                              }                              if (!reader.IsDBNull(reader.GetOrdinal("IS_NULLABLE")))                                  row["COLUMN_NULLABLE"] = reader.GetFieldValue<string>("IS_NULLABLE").Equals("YES");                              if (!reader.IsDBNull(reader.GetOrdinal("IS_AUTOINCREMENT")))                                  row["COLUMN_IDENTITY"] = reader.GetFieldValue<string>("IS_AUTOINCREMENT").Equals("YES");                              row["COLUMN_DEFAULT"] = reader.GetFieldValue<string>("COLUMN_DEF");    #if DEBUG                              System.Diagnostics.Trace.WriteLine("-> " + row["COLUMN_NAME"] + " " + row["COLUMN_TYPE"]);  #endif                              table.Rows.Add(row);                          }                          table.EndLoadData();                      }                  }              }              else if (collectionName == "Indexes")              {                  table.Columns.Add("INDEX_CATALOG"' typeof(string));                  table.Columns.Add("INDEX_SCHEMA"' typeof(string));                  table.Columns.Add("INDEX_TABLE"' typeof(string));                  table.Columns.Add("INDEX_NAME"' typeof(string));                  table.Columns.Add("INDEX_TYPE"' typeof(string));                  table.Columns.Add("INDEX_UNIQUE"' typeof(bool));                  table.Columns.Add("INDEX_PRIMARY"' typeof(bool));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetIndexInfo);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // unique                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // approximate                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        // to avoid to insert the same index more than once                      HashSet<string> unique = new HashSet<string>();                      if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;                                  if (!unique.Add(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;                                  DataRow row = table.NewRow();                                  row["INDEX_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEX_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEX_NAME"] = reader.GetFieldValue<string>("INDEX_NAME");                                  switch (reader.GetFieldValue<int>("TYPE"))                                  {                                      case 0:                                          row["INDEX_TYPE"] = "Primary";                                          break;                                      case 1:                                          row["INDEX_TYPE"] = "Unique";                                          break;                                      case 2:                                          row["INDEX_TYPE"] = "Secondary";                                          break;                                      case 3:                                          row["INDEX_TYPE"] = "Foreign Key";                                          break;                                  }                                  row["INDEX_UNIQUE"] = (reader.GetFieldValue<int>("NON_UNIQUE") == 0) ? true : false;                                  row["INDEX_PRIMARY"] = (reader.GetFieldValue<int>("TYPE") == 0) ? true : false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                        tmConn.InternalConnection.dataStream.startMessage(Protocol.GetPrimaryKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              // use INDEX_NAME' if present; if missing' the name of the index is in PK_NAME                              string indexName = "PK_NAME";                              foreach (string column in reader.columnNames)                              {                                  if (column == "INDEX_NAME")                                  {                                      indexName = "INDEX_NAME";                                      break;                                  }                              }                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>(indexName)))                                      continue;                                  if (!unique.Add(reader.GetFieldValue<string>(indexName)))                                      continue;                                  DataRow row = table.NewRow();                                  row["INDEX_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEX_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEX_NAME"] = reader.GetFieldValue<string>(indexName);                                  row["INDEX_TYPE"] = "Primary";                                  row["INDEX_UNIQUE"] = true;                                  row["INDEX_PRIMARY"] = true;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "IndexColumns")              {                  table.Columns.Add("INDEXCOLUMN_CATALOG"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_TABLE"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_INDEX"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_NAME"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_POSITION"' typeof(int));                  table.Columns.Add("INDEXCOLUMN_ISPRIMARY"' typeof(bool));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetIndexInfo);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // unique                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // approximate                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_SCHEM"] + "." + reader["TABLE_NAME"] + "=" + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["INDEXCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEXCOLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEXCOLUMN_INDEX"] = reader.GetFieldValue<string>("INDEX_NAME");                                  row["INDEXCOLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["INDEXCOLUMN_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                                  row["INDEXCOLUMN_ISPRIMARY"] = false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                        tmConn.InternalConnection.dataStream.startMessage(Protocol.GetPrimaryKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              // use INDEX_NAME' if present; if missing' the name of the index is in PK_NAME                              string indexName = "PK_NAME";                              foreach (string column in reader.columnNames)                              {                                  if (column == "INDEX_NAME")                                  {                                      indexName = "INDEX_NAME";                                      break;                                  }                              }                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>(indexName)))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_SCHEM"] + "." + reader["TABLE_NAME"] + " (Primary) =" + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["INDEXCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEXCOLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEXCOLUMN_INDEX"] = reader.GetFieldValue<string>(indexName);                                  row["INDEXCOLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["INDEXCOLUMN_POSITION"] = reader.GetFieldValue<int>("KEY_SEQ");                                  row["INDEXCOLUMN_ISPRIMARY"] = true;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ForeignKeys")              {                  table.Columns.Add("FOREIGNKEY_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEY_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEY_TABLE"' typeof(string));                  table.Columns.Add("FOREIGNKEY_NAME"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_TABLE"' typeof(string));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetImportedKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  string name = "[" + reader.GetFieldValue<string>("FKTABLE_SCHEM") + "]" +                                                   reader.GetFieldValue<string>("FKTABLE_NAME") + "." +                                                   reader.GetFieldValue<string>("FKCOLUMN_NAME") + "->" +                                                  "[" + reader.GetFieldValue<string>("PKTABLE_SCHEM") + "]" +                                                   reader.GetFieldValue<string>("PKTABLE_NAME") + "." +                                                   reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(name))                                      continue;                                  DataRow row = table.NewRow();                                  row["FOREIGNKEY_SCHEMA"] = reader.GetFieldValue<string>("FKTABLE_SCHEM");                                  row["FOREIGNKEY_TABLE"] = reader.GetFieldValue<string>("FKTABLE_NAME");                                  row["FOREIGNKEY_NAME"] = name;                                  row["FOREIGNKEY_OTHER_SCHEMA"] = reader.GetFieldValue<string>("PKTABLE_SCHEM");                                  row["FOREIGNKEY_OTHER_TABLE"] = reader.GetFieldValue<string>("PKTABLE_NAME");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ForeignKeyColumns")              {                  table.Columns.Add("FOREIGNKEYCOLUMN_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_TABLE"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_KEY"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_NAME"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_ORDINAL"' typeof(int));                  table.Columns.Add("FOREIGNKEYCOLUMN_OTHER_COLUMN_NAME"' typeof(string));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetImportedKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  string name = "[" + reader.GetFieldValue<string>("FKTABLE_SCHEM") + "]" +                                                  reader.GetFieldValue<string>("FKTABLE_NAME") + "." +                                                  reader.GetFieldValue<string>("FKCOLUMN_NAME") + "->" +                                                  "[" + reader.GetFieldValue<string>("PKTABLE_SCHEM") + "]" +                                                  reader.GetFieldValue<string>("PKTABLE_NAME") + "." +                                                  reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(name))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["FKTABLE_SCHEM"] + "." + reader["FKTABLE_NAME"] + "=" + reader["FKCOLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["FOREIGNKEYCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("FKTABLE_SCHEM");                                  row["FOREIGNKEYCOLUMN_TABLE"] = reader.GetFieldValue<string>("FKTABLE_NAME");                                  row["FOREIGNKEYCOLUMN_KEY"] = name;                                  row["FOREIGNKEYCOLUMN_NAME"] = reader.GetFieldValue<string>("FKCOLUMN_NAME");                                  row["FOREIGNKEYCOLUMN_ORDINAL"] = reader.GetFieldValue<int>("KEY_SEQ");                                  row["FOREIGNKEYCOLUMN_OTHER_COLUMN_NAME"] = reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "Procedures")               {                  table.Columns.Add("PROCEDURE_CATALOG"' typeof(string));                  table.Columns.Add("PROCEDURE_SCHEMA"' typeof(string));                  table.Columns.Add("PROCEDURE_NAME"' typeof(string));                  table.Columns.Add("IS_SYSTEM_PROCEDURE"' typeof(bool));                    if (tmConn.InternalConnection.protocolVersion >= Protocol.PROTOCOL_VERSION12)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetProcedures);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      for (int i = 1; i < 3; i++)                          if (restrictionValues != null && restrictionValues.Length > i)                              tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                          else                              tmConn.InternalConnection.dataStream.encodeNull();                        tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["PROCEDURE_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["PROCEDURE_SCHEMA"] = reader.GetFieldValue<string>("PROCEDURE_SCHEM");                                  row["PROCEDURE_NAME"] = reader.GetFieldValue<string>("PROCEDURE_NAME");                                  row["IS_SYSTEM_PROCEDURE"] = false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ProcedureParameters")              {                  table.Columns.Add("PROCEDURE_CATALOG"' typeof(string));                  table.Columns.Add("PROCEDURE_SCHEMA"' typeof(string));                  table.Columns.Add("PROCEDURE_NAME"' typeof(string));                  table.Columns.Add("PARAMETER_NAME"' typeof(string));                  table.Columns.Add("ORDINAL_POSITION"' typeof(int));                  table.Columns.Add("PARAMETER_DATA_TYPE"' typeof(int));                  table.Columns.Add("PARAMETER_TYPE_NAME"' typeof(string));                  table.Columns.Add("PARAMETER_SIZE"' typeof(int));                  table.Columns.Add("NUMERIC_PRECISION"' typeof(int));                  table.Columns.Add("NUMERIC_SCALE"' typeof(int));                  table.Columns.Add("PARAMETER_DIRECTION"' typeof(int));                  table.Columns.Add("IS_NULLABLE"' typeof(bool));                    if (tmConn.InternalConnection.protocolVersion >= Protocol.PROTOCOL_VERSION12)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetProcedureColumns);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      for (int i = 1; i < 4; i++)                          if (restrictionValues != null && restrictionValues.Length > i)                              tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                          else                              tmConn.InternalConnection.dataStream.encodeNull();                        tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["PROCEDURE_NAME"] + "' " + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["PROCEDURE_SCHEMA"] = reader.GetFieldValue<string>("PROCEDURE_SCHEM");                                  row["PROCEDURE_NAME"] = reader.GetFieldValue<string>("PROCEDURE_NAME");                                  row["PARAMETER_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["ORDINAL_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                                  row["PARAMETER_TYPE_NAME"] = reader.GetFieldValue<string>("TYPE_NAME");                                  row["PARAMETER_DATA_TYPE"] = reader.GetFieldValue<int>("DATA_TYPE");                                  row["PARAMETER_SIZE"] = reader.GetFieldValue<int>("LENGTH");                                  row["NUMERIC_PRECISION"] = reader.GetFieldValue<int>("PRECISION");                                  row["NUMERIC_SCALE"] = reader.GetFieldValue<int>("SCALE");                                  row["PARAMETER_DIRECTION"] = reader.GetFieldValue<int>("COLUMN_TYPE");                                  row["IS_NULLABLE"] = !reader.GetFieldValue<string>("IS_NULLABLE").Equals("NO");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The following statement contains a magic number: if (collectionName == DbMetaDataCollectionNames.DataSourceInformation)              {                  // see http://msdn.microsoft.com/en-us/library/ms254501.aspx                  table.Columns.Add("CompositeIdentifierSeparatorPattern"' typeof(string));                  table.Columns.Add("DataSourceProductName"' typeof(string));                  table.Columns.Add("DataSourceProductVersion"' typeof(string));                  table.Columns.Add("DataSourceProductVersionNormalized"' typeof(string));                  table.Columns.Add("DataSourceInternalProductVersion"' typeof(string));                  table.Columns.Add("GroupByBehavior"' typeof(GroupByBehavior));                  table.Columns.Add("IdentifierPattern"' typeof(string));                  table.Columns.Add("IdentifierCase"' typeof(IdentifierCase));                  table.Columns.Add("OrderByColumnsInSelect"' typeof(bool));                  table.Columns.Add("ParameterMarkerFormat"' typeof(string));                  table.Columns.Add("ParameterMarkerPattern"' typeof(string));                  table.Columns.Add("ParameterNameMaxLength"' typeof(int));                  table.Columns.Add("ParameterNamePattern"' typeof(string));                  table.Columns.Add("QuotedIdentifierPattern"' typeof(string));  // Regex                  table.Columns.Add("QuotedIdentifierCase"' typeof(int));                  table.Columns.Add("StatementSeparatorPattern"' typeof(string));                  table.Columns.Add("StringLiteralPattern"' typeof(string));  // Regex                  table.Columns.Add("SupportedJoinOperators"' typeof(SupportedJoinOperators));                    table.BeginLoadData();                  DataRow row = table.NewRow();                  int databaseMajorVersion = 0' databaseMinorVersion = 0;                  try                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetDatabaseMetaData);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      for (int item; (item = tmConn.InternalConnection.dataStream.getInt()) != Protocol.DbmbFini; )                      {                          switch (item)                          {                              case Protocol.DbmbProductName:                                  row["DataSourceProductName"] = tmConn.InternalConnection.dataStream.getString();                                  break;                                case Protocol.DbmbProductVersion:                                  row["DataSourceProductVersion"] = tmConn.InternalConnection.dataStream.getString();                                  break;                                case Protocol.DbmbDatabaseMinorVersion:                                  databaseMinorVersion = tmConn.InternalConnection.dataStream.getInt();                                  break;                                case Protocol.DbmbDatabaseMajorVersion:                                  databaseMajorVersion = tmConn.InternalConnection.dataStream.getInt();                                  break;                                case Protocol.DbmbDefaultTransactionIsolation:                                  int defaultTransactionIsolation = tmConn.InternalConnection.dataStream.getInt();                                  break;                                default:                                  tmConn.InternalConnection.dataStream.decode();                                  break;                          }                      }                  }                  catch (Exception)                  {                  }                    row["DataSourceInternalProductVersion"] = String.Format("{0:D3}.{1:D3}"' databaseMajorVersion' databaseMinorVersion);                  // The regular expression to match the composite separators in a composite identifier.                   // For example' "\." (for SQL Server) or "@|\." (for Oracle).                  // A composite identifier is typically what is used for a database object name'                   // for example: pubs.dbo.authors or pubs@dbo.authors.                  row["CompositeIdentifierSeparatorPattern"] = "\\.";                  // A normalized version for the data source' such that it can be compared with String.Compare().                   // The format of this is consistent for all versions of the provider to prevent version 10 from sorting between version 1 and version 2.                  //row["DataSourceProductVersionNormalized"] = ??                  // Specifies the relationship between the columns in a GROUP BY clause and the non-aggregated columns in the select list.                  row["GroupByBehavior"] = GroupByBehavior.Unknown;                  // A regular expression that matches an identifier and has a match value of the identifier. For example "[A-Za-z0-9_#$]".                  row["IdentifierPattern"] = "(^\\[\\p{Lo}\\p{Lu}\\p{Ll}_@#][\\p{Lo}\\p{Lu}\\p{Ll}\\p{Nd}@$#_]*$)|(^\"[^\"\\0]|\"\"+\"$)";                  // Indicates whether non-quoted identifiers are treated as case sensitive or not.                  row["IdentifierCase"] = IdentifierCase.Insensitive;                  // Specifies whether columns in an ORDER BY clause must be in the select list.                   // A value of true indicates that they are required to be in the select list'                   // a value of false indicates that they are not required to be in the select list.                  row["OrderByColumnsInSelect"] = false;                  // For data sources that do not expect named parameters and expect the use of the ‘?’ character' the format string                  // can be specified as simply '?'' which would ignore the parameter name.                  row["ParameterMarkerFormat"] = "?";                  // if the data source doesn't support named parameters' this would simply be "?".                  row["ParameterMarkerPattern"] = "?";                  // If the data source does not support named parameters' this property returns zero.                  row["ParameterNameMaxLength"] = 0;                  // A regular expression that matches the valid parameter names                  row["ParameterNamePattern"] = "";                  // A regular expression that matches a quoted identifier and has a match value of the identifier itself without the quotes.                   // For example' if the data source used double-quotes to identify quoted identifiers' this would be: "(([^\"]|\"\")*)".                  row["QuotedIdentifierPattern"] = "\"([^\"]*)\"";                  // Indicates whether quoted identifiers are treated as case sensitive or not.                  row["QuotedIdentifierCase"] = IdentifierCase.Sensitive;                  // A regular expression that matches the statement separator.                  row["StatementSeparatorPattern"] = ";";                  // A regular expression that matches a string literal and has a match value of the literal itself.                   // For example' if the data source used single-quotes to identify strings' this would be: "('([^']|'')*')"'                  row["StringLiteralPattern"] = "'([^']*)'";                  // Specifies what types of SQL join statements are supported by the data source.                  row["SupportedJoinOperators"] = SupportedJoinOperators.None;                  table.Rows.Add(row);                  table.EndLoadData();              }              else if (collectionName == DbMetaDataCollectionNames.ReservedWords)              {                  table.Columns.Add("ReservedWord"' typeof(string));                  table.Columns.Add("MaximumVersion"' typeof(string));                  table.Columns.Add("MinimumVersion"' typeof(string));                    string[] words = { "select"' "Add field"' "Drop field"' "Alter table"' "Alter field"'                                      "Alter user"' "And"' "Or"' "Not"' "Create Index"' "Upgrade"' "Unique"'                                      "Table key"' "Table unique key"' "Primary Key"' "Create Table"'                                      "Upgrade Table"' "Rename Table"' "Create View"' "Upgrade View"'                                      "Drop View"' "Create Schema"' "Drop Schema"' "Integer"' "Smallint"'                                      "Bigint"' "Tinyint"' "float"' "double"' "Blob"' "bytes"' "boolean"'                                      "binary"' "varbinary"' "string"' "char"' "text"' "date"' "timestamp"'                                      "time"' "varchar"' "numeric"' "Decimal Number"' "Enum"' "Delete"' "Repair"'                                      "Field"' "Not Null"' "Default Value"' "searchable"' "not searchable"'                                      "collation"' "character_set"' "Foreign Key"' "Identifier"' "record number"'                                      "Insert"' "Replace"' "Name"' "Number"' "Order"' "Descending"' "limit"'                                      "Quoted String"' "Select Clause"' "Distinct"' "Gtr"' "Geq"' "Eql"'                                      "Leq"' "Lss"' "Neq"' "in list"' "in select"' "exists"' "Between"' "Like"'                                      "starts with"' "Containing"' "Matching"' "Regular expression"' "Null"'                                      "True"' "False"' "Execute"' "Parameter"' "Count"' "sum"' "min"' "max"'                                      "avg"' "Drop Index"' "Drop primary key"' "Drop foreign key"' "Drop Table"'                                      "If Exists"' "Describe"' "Statement"' "for_select"' "for_insert"' "while"'                                      "if then else"' "variable"' "declaration"' "throw"' "assignment"'                                      "Start transaction"' "read only"' "read write"' "read committed"' "write committed"'                                      "read uncommitted"' "repeatableread"' "serializable"' "Commit"' "Rollback"'                                      "Savepoint"' "Rollack Savepoint"' "Release Savepoint"' "Table"' "Derived Table"'                                      "Assign"' "Update"' "list"' "Constant"' "Function"' "Grant"' "Grant role"' "Alter"'                                      "Read"' "Identity"' "Check"' "Constraint"' "value constraint"' "auto increment"'                                      "generated"' "always"' "Domain"' "is null"' "is active_role"' "start with"' "reindex"'                                      "cursor"' "alias"' "push_namespace"' "pop_namespace"' "set_namespace"' "coalesce"'                                      "nod_nullif"' "case"' "case_search"' "add"' "subtract"' "multiply"' "divide"' "modulus"'                                      "negate"' "plus"' "cast"' "concatenation"' "create user"' "drop user"' "create role"'                                      "upgrade role"' "drop role"' "revoke"' "revoke role"' "assume"' "revert"' "negate"'                                      "priv insert"' "priv delete"' "priv execute"' "priv select"' "priv update"' "priv grant"'                                      "priv all"' "characters"' "octets"' "role"' "view"' "procedure"' "user"' "zone"' "admin"'                                      "default role"' "create sequence"' "upgrade sequence"' "drop sequence"' "next value"'                                      "create trigger"' "upgrade trigger"' "alter trigger"' "drop trigger"' "create procedure"'                                      "upgrade procedure"' "alter procedure"' "drop procedure"' "pre-insert"' "post-insert"'                                      "pre-update"' "post-update"' "pre-delete"' "post-delete"' "pre-commit"' "post-commit"'                                      "active"' "inactive"' "position"' "select-expr"' "create filterset"' "upgrade filterset"'                                      "drop filterset"' "enable filterset"' "disable filterset"' "table filter"' "left outer"'                                      "right outer"' "full outer"' "inner"' "join"' "join_term"' "trigger class"' "enable trigger class"'                                      "disable trigger class"' "create zone"' "upgrade zone"' "drop zone"' "range"' "ip address"'                                      "node_name"' "wildcard"' "create domain"' "upgrade domain"' "alter domain"' "upgrade schema"'                                      "delete cascade"' "index segment"' "for update"' "write committed"' "read committed"'                                       "consistent read"' "set dialect"' "set names"' "restrict"' "cascade"' "characters"' "octets"'                                      "create event"' "collate"' "truncate"' "restart"' "nameless constraint"' "drop constraint"'                                      "drop unique constraint"' "drop domain"' "with check option"' "not real"' "lower"' "upper"'                                      "substr"' "substring index"' "charlength"' "default keyword"' "sqrt"' "power"' "Scientific Notation Number"'                                      "Explain"' "msleep"' "KillStatement"' "now" };                  table.BeginLoadData();                  foreach (string keyword in words)                  {                      DataRow row = table.NewRow();                      row["ReservedWord"] = keyword;                      table.Rows.Add(row);                  }                  table.EndLoadData();                }              else if (collectionName == DbMetaDataCollectionNames.DataTypes)              {                  table.Columns.Add("TypeName"' typeof(string));  // The provider-specific data type name.                  table.Columns.Add("ProviderDbType"' typeof(int)); // The provider-specific type value that should be used when specifying                   //a parameter's type. For example' SqlDbType.Money or OracleType.Blob.                  table.Columns.Add("ColumnSize"' typeof(long));                  table.Columns.Add("CreateFormat"' typeof(string));                  table.Columns.Add("CreateParameters"' typeof(string));                  table.Columns.Add("DataType"' typeof(string));  // The name of the .NET Framework type of the data type.                  table.Columns.Add("IsAutoincrementable"' typeof(bool));                  table.Columns.Add("IsBestMatch"' typeof(bool));                  table.Columns.Add("IsCaseSensitive"' typeof(bool));                  table.Columns.Add("IsFixedLength"' typeof(bool));                  table.Columns.Add("IsFixedPrecisionScale"' typeof(bool));                  table.Columns.Add("IsLong"' typeof(bool));                  table.Columns.Add("IsNullable"' typeof(bool));                  table.Columns.Add("IsSearchable"' typeof(bool));                  table.Columns.Add("IsSearchableWithLike"' typeof(bool));                  table.Columns.Add("IsUnsigned"' typeof(bool));                  table.Columns.Add("MaximumScale"' typeof(short));                  table.Columns.Add("MinimumScale"' typeof(short));                  table.Columns.Add("IsConcurrencyType"' typeof(bool));                  table.Columns.Add("IsLiteralsSupported"' typeof(bool));                  table.Columns.Add("LiteralPrefix"' typeof(string));                  table.Columns.Add("LiteralSuffix"' typeof(string));                  table.Columns.Add("NativeDataType"' typeof(string));    // NativeDataType is an OLE DB specific column for exposing the OLE DB type of the data type .                    table.ReadXml(XmlReader.Create(typeof(NuoDbConnectionInternal).Assembly.GetManifestResourceStream("NuoDb.Data.Client.DataTypes.xml")));              }              else if (collectionName == "Tables")              {                  table.Columns.Add("TABLE_CATALOG"' typeof(string));                  table.Columns.Add("TABLE_SCHEMA"' typeof(string));                  table.Columns.Add("TABLE_NAME"' typeof(string));                  table.Columns.Add("TABLE_TYPE"' typeof(string));                  table.Columns.Add("REMARKS"' typeof(string));                  table.Columns.Add("VIEW_DEF"' typeof(string));                    tmConn.InternalConnection.dataStream.startMessage(Protocol.GetTables);                  tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                  for (int i = 1; i < 3; i++)                      if (restrictionValues != null && restrictionValues.Length > i)                          tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                      else                          tmConn.InternalConnection.dataStream.encodeNull();                  if (restrictionValues == null || restrictionValues.Length < 4 || restrictionValues[3] == null)                      tmConn.InternalConnection.dataStream.encodeInt(0);                  else                  {                      tmConn.InternalConnection.dataStream.encodeInt(1);                      tmConn.InternalConnection.dataStream.encodeString(restrictionValues[3]);                  }                    tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                  int handle = tmConn.InternalConnection.dataStream.getInt();                    if (handle != -1)                  {                      using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                      {                          table.BeginLoadData();                          string view_def_label="";                          try                           {                               reader.GetOrdinal("VIEW_DEF");                              view_def_label = "VIEW_DEF";                          }                          catch(Exception) {}                          try                           {                               reader.GetOrdinal("VIEWDEFINITION");                              view_def_label = "VIEWDEFINITION";                          }                          catch (Exception) { }                          while (reader.Read())                          {  #if DEBUG                          System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_NAME"] + "' " + reader["TABLE_TYPE"]);  #endif                              DataRow row = table.NewRow();                              row["TABLE_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                              row["TABLE_NAME"] = reader.GetFieldValue<string>("TABLE_NAME");                              row["TABLE_TYPE"] = reader.GetFieldValue<string>("TABLE_TYPE");                              row["REMARKS"] = reader.GetFieldValue<string>("REMARKS");                              if (view_def_label.Length != 0)                              {                                  row["VIEW_DEF"] = reader.GetFieldValue<string>(view_def_label);                              }                              table.Rows.Add(row);                          }                          table.EndLoadData();                      }                  }              }              else if (collectionName == "Columns")              {                  table.Columns.Add("COLUMN_CATALOG"' typeof(string));                  table.Columns.Add("COLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("COLUMN_TABLE"' typeof(string));                  table.Columns.Add("COLUMN_NAME"' typeof(string));                  table.Columns.Add("COLUMN_POSITION"' typeof(int));                  table.Columns.Add("COLUMN_TYPE"' typeof(string));                  table.Columns.Add("COLUMN_LENGTH"' typeof(int));                  table.Columns.Add("COLUMN_PRECISION"' typeof(int));                  table.Columns.Add("COLUMN_NULLABLE"' typeof(bool));                  table.Columns.Add("COLUMN_IDENTITY"' typeof(bool));                  table.Columns.Add("COLUMN_DEFAULT"' typeof(string));                  table.Columns.Add("COLUMN_SCALE"' typeof(int));                    tmConn.InternalConnection.dataStream.startMessage(Protocol.GetColumns);                  tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                  for (int i = 1; i < 4; i++)                      if (restrictionValues != null && restrictionValues.Length > i)                          tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                      else                          tmConn.InternalConnection.dataStream.encodeNull();                    tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                  int handle = tmConn.InternalConnection.dataStream.getInt();                    if (handle != -1)                  {                      using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                      {                          table.BeginLoadData();                          while (reader.Read())                          {                              DataRow row = table.NewRow();                              row["COLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                              row["COLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                              row["COLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                              row["COLUMN_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                              row["COLUMN_LENGTH"] = reader.GetFieldValue<int>("COLUMN_SIZE");                              row["COLUMN_PRECISION"] = reader.GetFieldValue<int>("BUFFER_LENGTH");                              row["COLUMN_SCALE"] = reader.GetFieldValue<int>("DECIMAL_DIGITS");                              if (isNumeric(reader.GetFieldValue<string>("TYPE_NAME")))                              {                                  if (reader.GetFieldValue<int>("DECIMAL_DIGITS") != 0)                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME") +                                           "(" + reader.GetFieldValue<int>("BUFFER_LENGTH") + "'" + reader.GetFieldValue<int>("DECIMAL_DIGITS") + ")";                                  else                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME");                              }                              else                              {                                  if (isVarLenType(reader.GetFieldValue<string>("TYPE_NAME")) && reader.GetFieldValue<int>("COLUMN_SIZE") != 0)                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME") +                                           "(" + reader.GetFieldValue<int>("COLUMN_SIZE") + ")";                                  else                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME");                              }                              if (!reader.IsDBNull(reader.GetOrdinal("IS_NULLABLE")))                                  row["COLUMN_NULLABLE"] = reader.GetFieldValue<string>("IS_NULLABLE").Equals("YES");                              if (!reader.IsDBNull(reader.GetOrdinal("IS_AUTOINCREMENT")))                                  row["COLUMN_IDENTITY"] = reader.GetFieldValue<string>("IS_AUTOINCREMENT").Equals("YES");                              row["COLUMN_DEFAULT"] = reader.GetFieldValue<string>("COLUMN_DEF");    #if DEBUG                              System.Diagnostics.Trace.WriteLine("-> " + row["COLUMN_NAME"] + " " + row["COLUMN_TYPE"]);  #endif                              table.Rows.Add(row);                          }                          table.EndLoadData();                      }                  }              }              else if (collectionName == "Indexes")              {                  table.Columns.Add("INDEX_CATALOG"' typeof(string));                  table.Columns.Add("INDEX_SCHEMA"' typeof(string));                  table.Columns.Add("INDEX_TABLE"' typeof(string));                  table.Columns.Add("INDEX_NAME"' typeof(string));                  table.Columns.Add("INDEX_TYPE"' typeof(string));                  table.Columns.Add("INDEX_UNIQUE"' typeof(bool));                  table.Columns.Add("INDEX_PRIMARY"' typeof(bool));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetIndexInfo);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // unique                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // approximate                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        // to avoid to insert the same index more than once                      HashSet<string> unique = new HashSet<string>();                      if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;                                  if (!unique.Add(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;                                  DataRow row = table.NewRow();                                  row["INDEX_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEX_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEX_NAME"] = reader.GetFieldValue<string>("INDEX_NAME");                                  switch (reader.GetFieldValue<int>("TYPE"))                                  {                                      case 0:                                          row["INDEX_TYPE"] = "Primary";                                          break;                                      case 1:                                          row["INDEX_TYPE"] = "Unique";                                          break;                                      case 2:                                          row["INDEX_TYPE"] = "Secondary";                                          break;                                      case 3:                                          row["INDEX_TYPE"] = "Foreign Key";                                          break;                                  }                                  row["INDEX_UNIQUE"] = (reader.GetFieldValue<int>("NON_UNIQUE") == 0) ? true : false;                                  row["INDEX_PRIMARY"] = (reader.GetFieldValue<int>("TYPE") == 0) ? true : false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                        tmConn.InternalConnection.dataStream.startMessage(Protocol.GetPrimaryKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              // use INDEX_NAME' if present; if missing' the name of the index is in PK_NAME                              string indexName = "PK_NAME";                              foreach (string column in reader.columnNames)                              {                                  if (column == "INDEX_NAME")                                  {                                      indexName = "INDEX_NAME";                                      break;                                  }                              }                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>(indexName)))                                      continue;                                  if (!unique.Add(reader.GetFieldValue<string>(indexName)))                                      continue;                                  DataRow row = table.NewRow();                                  row["INDEX_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEX_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEX_NAME"] = reader.GetFieldValue<string>(indexName);                                  row["INDEX_TYPE"] = "Primary";                                  row["INDEX_UNIQUE"] = true;                                  row["INDEX_PRIMARY"] = true;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "IndexColumns")              {                  table.Columns.Add("INDEXCOLUMN_CATALOG"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_TABLE"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_INDEX"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_NAME"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_POSITION"' typeof(int));                  table.Columns.Add("INDEXCOLUMN_ISPRIMARY"' typeof(bool));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetIndexInfo);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // unique                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // approximate                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_SCHEM"] + "." + reader["TABLE_NAME"] + "=" + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["INDEXCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEXCOLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEXCOLUMN_INDEX"] = reader.GetFieldValue<string>("INDEX_NAME");                                  row["INDEXCOLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["INDEXCOLUMN_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                                  row["INDEXCOLUMN_ISPRIMARY"] = false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                        tmConn.InternalConnection.dataStream.startMessage(Protocol.GetPrimaryKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              // use INDEX_NAME' if present; if missing' the name of the index is in PK_NAME                              string indexName = "PK_NAME";                              foreach (string column in reader.columnNames)                              {                                  if (column == "INDEX_NAME")                                  {                                      indexName = "INDEX_NAME";                                      break;                                  }                              }                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>(indexName)))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_SCHEM"] + "." + reader["TABLE_NAME"] + " (Primary) =" + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["INDEXCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEXCOLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEXCOLUMN_INDEX"] = reader.GetFieldValue<string>(indexName);                                  row["INDEXCOLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["INDEXCOLUMN_POSITION"] = reader.GetFieldValue<int>("KEY_SEQ");                                  row["INDEXCOLUMN_ISPRIMARY"] = true;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ForeignKeys")              {                  table.Columns.Add("FOREIGNKEY_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEY_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEY_TABLE"' typeof(string));                  table.Columns.Add("FOREIGNKEY_NAME"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_TABLE"' typeof(string));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetImportedKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  string name = "[" + reader.GetFieldValue<string>("FKTABLE_SCHEM") + "]" +                                                   reader.GetFieldValue<string>("FKTABLE_NAME") + "." +                                                   reader.GetFieldValue<string>("FKCOLUMN_NAME") + "->" +                                                  "[" + reader.GetFieldValue<string>("PKTABLE_SCHEM") + "]" +                                                   reader.GetFieldValue<string>("PKTABLE_NAME") + "." +                                                   reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(name))                                      continue;                                  DataRow row = table.NewRow();                                  row["FOREIGNKEY_SCHEMA"] = reader.GetFieldValue<string>("FKTABLE_SCHEM");                                  row["FOREIGNKEY_TABLE"] = reader.GetFieldValue<string>("FKTABLE_NAME");                                  row["FOREIGNKEY_NAME"] = name;                                  row["FOREIGNKEY_OTHER_SCHEMA"] = reader.GetFieldValue<string>("PKTABLE_SCHEM");                                  row["FOREIGNKEY_OTHER_TABLE"] = reader.GetFieldValue<string>("PKTABLE_NAME");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ForeignKeyColumns")              {                  table.Columns.Add("FOREIGNKEYCOLUMN_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_TABLE"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_KEY"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_NAME"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_ORDINAL"' typeof(int));                  table.Columns.Add("FOREIGNKEYCOLUMN_OTHER_COLUMN_NAME"' typeof(string));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetImportedKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  string name = "[" + reader.GetFieldValue<string>("FKTABLE_SCHEM") + "]" +                                                  reader.GetFieldValue<string>("FKTABLE_NAME") + "." +                                                  reader.GetFieldValue<string>("FKCOLUMN_NAME") + "->" +                                                  "[" + reader.GetFieldValue<string>("PKTABLE_SCHEM") + "]" +                                                  reader.GetFieldValue<string>("PKTABLE_NAME") + "." +                                                  reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(name))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["FKTABLE_SCHEM"] + "." + reader["FKTABLE_NAME"] + "=" + reader["FKCOLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["FOREIGNKEYCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("FKTABLE_SCHEM");                                  row["FOREIGNKEYCOLUMN_TABLE"] = reader.GetFieldValue<string>("FKTABLE_NAME");                                  row["FOREIGNKEYCOLUMN_KEY"] = name;                                  row["FOREIGNKEYCOLUMN_NAME"] = reader.GetFieldValue<string>("FKCOLUMN_NAME");                                  row["FOREIGNKEYCOLUMN_ORDINAL"] = reader.GetFieldValue<int>("KEY_SEQ");                                  row["FOREIGNKEYCOLUMN_OTHER_COLUMN_NAME"] = reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "Procedures")               {                  table.Columns.Add("PROCEDURE_CATALOG"' typeof(string));                  table.Columns.Add("PROCEDURE_SCHEMA"' typeof(string));                  table.Columns.Add("PROCEDURE_NAME"' typeof(string));                  table.Columns.Add("IS_SYSTEM_PROCEDURE"' typeof(bool));                    if (tmConn.InternalConnection.protocolVersion >= Protocol.PROTOCOL_VERSION12)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetProcedures);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      for (int i = 1; i < 3; i++)                          if (restrictionValues != null && restrictionValues.Length > i)                              tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                          else                              tmConn.InternalConnection.dataStream.encodeNull();                        tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["PROCEDURE_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["PROCEDURE_SCHEMA"] = reader.GetFieldValue<string>("PROCEDURE_SCHEM");                                  row["PROCEDURE_NAME"] = reader.GetFieldValue<string>("PROCEDURE_NAME");                                  row["IS_SYSTEM_PROCEDURE"] = false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ProcedureParameters")              {                  table.Columns.Add("PROCEDURE_CATALOG"' typeof(string));                  table.Columns.Add("PROCEDURE_SCHEMA"' typeof(string));                  table.Columns.Add("PROCEDURE_NAME"' typeof(string));                  table.Columns.Add("PARAMETER_NAME"' typeof(string));                  table.Columns.Add("ORDINAL_POSITION"' typeof(int));                  table.Columns.Add("PARAMETER_DATA_TYPE"' typeof(int));                  table.Columns.Add("PARAMETER_TYPE_NAME"' typeof(string));                  table.Columns.Add("PARAMETER_SIZE"' typeof(int));                  table.Columns.Add("NUMERIC_PRECISION"' typeof(int));                  table.Columns.Add("NUMERIC_SCALE"' typeof(int));                  table.Columns.Add("PARAMETER_DIRECTION"' typeof(int));                  table.Columns.Add("IS_NULLABLE"' typeof(bool));                    if (tmConn.InternalConnection.protocolVersion >= Protocol.PROTOCOL_VERSION12)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetProcedureColumns);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      for (int i = 1; i < 4; i++)                          if (restrictionValues != null && restrictionValues.Length > i)                              tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                          else                              tmConn.InternalConnection.dataStream.encodeNull();                        tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["PROCEDURE_NAME"] + "' " + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["PROCEDURE_SCHEMA"] = reader.GetFieldValue<string>("PROCEDURE_SCHEM");                                  row["PROCEDURE_NAME"] = reader.GetFieldValue<string>("PROCEDURE_NAME");                                  row["PARAMETER_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["ORDINAL_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                                  row["PARAMETER_TYPE_NAME"] = reader.GetFieldValue<string>("TYPE_NAME");                                  row["PARAMETER_DATA_TYPE"] = reader.GetFieldValue<int>("DATA_TYPE");                                  row["PARAMETER_SIZE"] = reader.GetFieldValue<int>("LENGTH");                                  row["NUMERIC_PRECISION"] = reader.GetFieldValue<int>("PRECISION");                                  row["NUMERIC_SCALE"] = reader.GetFieldValue<int>("SCALE");                                  row["PARAMETER_DIRECTION"] = reader.GetFieldValue<int>("COLUMN_TYPE");                                  row["IS_NULLABLE"] = !reader.GetFieldValue<string>("IS_NULLABLE").Equals("NO");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The following statement contains a magic number: if (collectionName == DbMetaDataCollectionNames.DataSourceInformation)              {                  // see http://msdn.microsoft.com/en-us/library/ms254501.aspx                  table.Columns.Add("CompositeIdentifierSeparatorPattern"' typeof(string));                  table.Columns.Add("DataSourceProductName"' typeof(string));                  table.Columns.Add("DataSourceProductVersion"' typeof(string));                  table.Columns.Add("DataSourceProductVersionNormalized"' typeof(string));                  table.Columns.Add("DataSourceInternalProductVersion"' typeof(string));                  table.Columns.Add("GroupByBehavior"' typeof(GroupByBehavior));                  table.Columns.Add("IdentifierPattern"' typeof(string));                  table.Columns.Add("IdentifierCase"' typeof(IdentifierCase));                  table.Columns.Add("OrderByColumnsInSelect"' typeof(bool));                  table.Columns.Add("ParameterMarkerFormat"' typeof(string));                  table.Columns.Add("ParameterMarkerPattern"' typeof(string));                  table.Columns.Add("ParameterNameMaxLength"' typeof(int));                  table.Columns.Add("ParameterNamePattern"' typeof(string));                  table.Columns.Add("QuotedIdentifierPattern"' typeof(string));  // Regex                  table.Columns.Add("QuotedIdentifierCase"' typeof(int));                  table.Columns.Add("StatementSeparatorPattern"' typeof(string));                  table.Columns.Add("StringLiteralPattern"' typeof(string));  // Regex                  table.Columns.Add("SupportedJoinOperators"' typeof(SupportedJoinOperators));                    table.BeginLoadData();                  DataRow row = table.NewRow();                  int databaseMajorVersion = 0' databaseMinorVersion = 0;                  try                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetDatabaseMetaData);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      for (int item; (item = tmConn.InternalConnection.dataStream.getInt()) != Protocol.DbmbFini; )                      {                          switch (item)                          {                              case Protocol.DbmbProductName:                                  row["DataSourceProductName"] = tmConn.InternalConnection.dataStream.getString();                                  break;                                case Protocol.DbmbProductVersion:                                  row["DataSourceProductVersion"] = tmConn.InternalConnection.dataStream.getString();                                  break;                                case Protocol.DbmbDatabaseMinorVersion:                                  databaseMinorVersion = tmConn.InternalConnection.dataStream.getInt();                                  break;                                case Protocol.DbmbDatabaseMajorVersion:                                  databaseMajorVersion = tmConn.InternalConnection.dataStream.getInt();                                  break;                                case Protocol.DbmbDefaultTransactionIsolation:                                  int defaultTransactionIsolation = tmConn.InternalConnection.dataStream.getInt();                                  break;                                default:                                  tmConn.InternalConnection.dataStream.decode();                                  break;                          }                      }                  }                  catch (Exception)                  {                  }                    row["DataSourceInternalProductVersion"] = String.Format("{0:D3}.{1:D3}"' databaseMajorVersion' databaseMinorVersion);                  // The regular expression to match the composite separators in a composite identifier.                   // For example' "\." (for SQL Server) or "@|\." (for Oracle).                  // A composite identifier is typically what is used for a database object name'                   // for example: pubs.dbo.authors or pubs@dbo.authors.                  row["CompositeIdentifierSeparatorPattern"] = "\\.";                  // A normalized version for the data source' such that it can be compared with String.Compare().                   // The format of this is consistent for all versions of the provider to prevent version 10 from sorting between version 1 and version 2.                  //row["DataSourceProductVersionNormalized"] = ??                  // Specifies the relationship between the columns in a GROUP BY clause and the non-aggregated columns in the select list.                  row["GroupByBehavior"] = GroupByBehavior.Unknown;                  // A regular expression that matches an identifier and has a match value of the identifier. For example "[A-Za-z0-9_#$]".                  row["IdentifierPattern"] = "(^\\[\\p{Lo}\\p{Lu}\\p{Ll}_@#][\\p{Lo}\\p{Lu}\\p{Ll}\\p{Nd}@$#_]*$)|(^\"[^\"\\0]|\"\"+\"$)";                  // Indicates whether non-quoted identifiers are treated as case sensitive or not.                  row["IdentifierCase"] = IdentifierCase.Insensitive;                  // Specifies whether columns in an ORDER BY clause must be in the select list.                   // A value of true indicates that they are required to be in the select list'                   // a value of false indicates that they are not required to be in the select list.                  row["OrderByColumnsInSelect"] = false;                  // For data sources that do not expect named parameters and expect the use of the ‘?’ character' the format string                  // can be specified as simply '?'' which would ignore the parameter name.                  row["ParameterMarkerFormat"] = "?";                  // if the data source doesn't support named parameters' this would simply be "?".                  row["ParameterMarkerPattern"] = "?";                  // If the data source does not support named parameters' this property returns zero.                  row["ParameterNameMaxLength"] = 0;                  // A regular expression that matches the valid parameter names                  row["ParameterNamePattern"] = "";                  // A regular expression that matches a quoted identifier and has a match value of the identifier itself without the quotes.                   // For example' if the data source used double-quotes to identify quoted identifiers' this would be: "(([^\"]|\"\")*)".                  row["QuotedIdentifierPattern"] = "\"([^\"]*)\"";                  // Indicates whether quoted identifiers are treated as case sensitive or not.                  row["QuotedIdentifierCase"] = IdentifierCase.Sensitive;                  // A regular expression that matches the statement separator.                  row["StatementSeparatorPattern"] = ";";                  // A regular expression that matches a string literal and has a match value of the literal itself.                   // For example' if the data source used single-quotes to identify strings' this would be: "('([^']|'')*')"'                  row["StringLiteralPattern"] = "'([^']*)'";                  // Specifies what types of SQL join statements are supported by the data source.                  row["SupportedJoinOperators"] = SupportedJoinOperators.None;                  table.Rows.Add(row);                  table.EndLoadData();              }              else if (collectionName == DbMetaDataCollectionNames.ReservedWords)              {                  table.Columns.Add("ReservedWord"' typeof(string));                  table.Columns.Add("MaximumVersion"' typeof(string));                  table.Columns.Add("MinimumVersion"' typeof(string));                    string[] words = { "select"' "Add field"' "Drop field"' "Alter table"' "Alter field"'                                      "Alter user"' "And"' "Or"' "Not"' "Create Index"' "Upgrade"' "Unique"'                                      "Table key"' "Table unique key"' "Primary Key"' "Create Table"'                                      "Upgrade Table"' "Rename Table"' "Create View"' "Upgrade View"'                                      "Drop View"' "Create Schema"' "Drop Schema"' "Integer"' "Smallint"'                                      "Bigint"' "Tinyint"' "float"' "double"' "Blob"' "bytes"' "boolean"'                                      "binary"' "varbinary"' "string"' "char"' "text"' "date"' "timestamp"'                                      "time"' "varchar"' "numeric"' "Decimal Number"' "Enum"' "Delete"' "Repair"'                                      "Field"' "Not Null"' "Default Value"' "searchable"' "not searchable"'                                      "collation"' "character_set"' "Foreign Key"' "Identifier"' "record number"'                                      "Insert"' "Replace"' "Name"' "Number"' "Order"' "Descending"' "limit"'                                      "Quoted String"' "Select Clause"' "Distinct"' "Gtr"' "Geq"' "Eql"'                                      "Leq"' "Lss"' "Neq"' "in list"' "in select"' "exists"' "Between"' "Like"'                                      "starts with"' "Containing"' "Matching"' "Regular expression"' "Null"'                                      "True"' "False"' "Execute"' "Parameter"' "Count"' "sum"' "min"' "max"'                                      "avg"' "Drop Index"' "Drop primary key"' "Drop foreign key"' "Drop Table"'                                      "If Exists"' "Describe"' "Statement"' "for_select"' "for_insert"' "while"'                                      "if then else"' "variable"' "declaration"' "throw"' "assignment"'                                      "Start transaction"' "read only"' "read write"' "read committed"' "write committed"'                                      "read uncommitted"' "repeatableread"' "serializable"' "Commit"' "Rollback"'                                      "Savepoint"' "Rollack Savepoint"' "Release Savepoint"' "Table"' "Derived Table"'                                      "Assign"' "Update"' "list"' "Constant"' "Function"' "Grant"' "Grant role"' "Alter"'                                      "Read"' "Identity"' "Check"' "Constraint"' "value constraint"' "auto increment"'                                      "generated"' "always"' "Domain"' "is null"' "is active_role"' "start with"' "reindex"'                                      "cursor"' "alias"' "push_namespace"' "pop_namespace"' "set_namespace"' "coalesce"'                                      "nod_nullif"' "case"' "case_search"' "add"' "subtract"' "multiply"' "divide"' "modulus"'                                      "negate"' "plus"' "cast"' "concatenation"' "create user"' "drop user"' "create role"'                                      "upgrade role"' "drop role"' "revoke"' "revoke role"' "assume"' "revert"' "negate"'                                      "priv insert"' "priv delete"' "priv execute"' "priv select"' "priv update"' "priv grant"'                                      "priv all"' "characters"' "octets"' "role"' "view"' "procedure"' "user"' "zone"' "admin"'                                      "default role"' "create sequence"' "upgrade sequence"' "drop sequence"' "next value"'                                      "create trigger"' "upgrade trigger"' "alter trigger"' "drop trigger"' "create procedure"'                                      "upgrade procedure"' "alter procedure"' "drop procedure"' "pre-insert"' "post-insert"'                                      "pre-update"' "post-update"' "pre-delete"' "post-delete"' "pre-commit"' "post-commit"'                                      "active"' "inactive"' "position"' "select-expr"' "create filterset"' "upgrade filterset"'                                      "drop filterset"' "enable filterset"' "disable filterset"' "table filter"' "left outer"'                                      "right outer"' "full outer"' "inner"' "join"' "join_term"' "trigger class"' "enable trigger class"'                                      "disable trigger class"' "create zone"' "upgrade zone"' "drop zone"' "range"' "ip address"'                                      "node_name"' "wildcard"' "create domain"' "upgrade domain"' "alter domain"' "upgrade schema"'                                      "delete cascade"' "index segment"' "for update"' "write committed"' "read committed"'                                       "consistent read"' "set dialect"' "set names"' "restrict"' "cascade"' "characters"' "octets"'                                      "create event"' "collate"' "truncate"' "restart"' "nameless constraint"' "drop constraint"'                                      "drop unique constraint"' "drop domain"' "with check option"' "not real"' "lower"' "upper"'                                      "substr"' "substring index"' "charlength"' "default keyword"' "sqrt"' "power"' "Scientific Notation Number"'                                      "Explain"' "msleep"' "KillStatement"' "now" };                  table.BeginLoadData();                  foreach (string keyword in words)                  {                      DataRow row = table.NewRow();                      row["ReservedWord"] = keyword;                      table.Rows.Add(row);                  }                  table.EndLoadData();                }              else if (collectionName == DbMetaDataCollectionNames.DataTypes)              {                  table.Columns.Add("TypeName"' typeof(string));  // The provider-specific data type name.                  table.Columns.Add("ProviderDbType"' typeof(int)); // The provider-specific type value that should be used when specifying                   //a parameter's type. For example' SqlDbType.Money or OracleType.Blob.                  table.Columns.Add("ColumnSize"' typeof(long));                  table.Columns.Add("CreateFormat"' typeof(string));                  table.Columns.Add("CreateParameters"' typeof(string));                  table.Columns.Add("DataType"' typeof(string));  // The name of the .NET Framework type of the data type.                  table.Columns.Add("IsAutoincrementable"' typeof(bool));                  table.Columns.Add("IsBestMatch"' typeof(bool));                  table.Columns.Add("IsCaseSensitive"' typeof(bool));                  table.Columns.Add("IsFixedLength"' typeof(bool));                  table.Columns.Add("IsFixedPrecisionScale"' typeof(bool));                  table.Columns.Add("IsLong"' typeof(bool));                  table.Columns.Add("IsNullable"' typeof(bool));                  table.Columns.Add("IsSearchable"' typeof(bool));                  table.Columns.Add("IsSearchableWithLike"' typeof(bool));                  table.Columns.Add("IsUnsigned"' typeof(bool));                  table.Columns.Add("MaximumScale"' typeof(short));                  table.Columns.Add("MinimumScale"' typeof(short));                  table.Columns.Add("IsConcurrencyType"' typeof(bool));                  table.Columns.Add("IsLiteralsSupported"' typeof(bool));                  table.Columns.Add("LiteralPrefix"' typeof(string));                  table.Columns.Add("LiteralSuffix"' typeof(string));                  table.Columns.Add("NativeDataType"' typeof(string));    // NativeDataType is an OLE DB specific column for exposing the OLE DB type of the data type .                    table.ReadXml(XmlReader.Create(typeof(NuoDbConnectionInternal).Assembly.GetManifestResourceStream("NuoDb.Data.Client.DataTypes.xml")));              }              else if (collectionName == "Tables")              {                  table.Columns.Add("TABLE_CATALOG"' typeof(string));                  table.Columns.Add("TABLE_SCHEMA"' typeof(string));                  table.Columns.Add("TABLE_NAME"' typeof(string));                  table.Columns.Add("TABLE_TYPE"' typeof(string));                  table.Columns.Add("REMARKS"' typeof(string));                  table.Columns.Add("VIEW_DEF"' typeof(string));                    tmConn.InternalConnection.dataStream.startMessage(Protocol.GetTables);                  tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                  for (int i = 1; i < 3; i++)                      if (restrictionValues != null && restrictionValues.Length > i)                          tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                      else                          tmConn.InternalConnection.dataStream.encodeNull();                  if (restrictionValues == null || restrictionValues.Length < 4 || restrictionValues[3] == null)                      tmConn.InternalConnection.dataStream.encodeInt(0);                  else                  {                      tmConn.InternalConnection.dataStream.encodeInt(1);                      tmConn.InternalConnection.dataStream.encodeString(restrictionValues[3]);                  }                    tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                  int handle = tmConn.InternalConnection.dataStream.getInt();                    if (handle != -1)                  {                      using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                      {                          table.BeginLoadData();                          string view_def_label="";                          try                           {                               reader.GetOrdinal("VIEW_DEF");                              view_def_label = "VIEW_DEF";                          }                          catch(Exception) {}                          try                           {                               reader.GetOrdinal("VIEWDEFINITION");                              view_def_label = "VIEWDEFINITION";                          }                          catch (Exception) { }                          while (reader.Read())                          {  #if DEBUG                          System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_NAME"] + "' " + reader["TABLE_TYPE"]);  #endif                              DataRow row = table.NewRow();                              row["TABLE_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                              row["TABLE_NAME"] = reader.GetFieldValue<string>("TABLE_NAME");                              row["TABLE_TYPE"] = reader.GetFieldValue<string>("TABLE_TYPE");                              row["REMARKS"] = reader.GetFieldValue<string>("REMARKS");                              if (view_def_label.Length != 0)                              {                                  row["VIEW_DEF"] = reader.GetFieldValue<string>(view_def_label);                              }                              table.Rows.Add(row);                          }                          table.EndLoadData();                      }                  }              }              else if (collectionName == "Columns")              {                  table.Columns.Add("COLUMN_CATALOG"' typeof(string));                  table.Columns.Add("COLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("COLUMN_TABLE"' typeof(string));                  table.Columns.Add("COLUMN_NAME"' typeof(string));                  table.Columns.Add("COLUMN_POSITION"' typeof(int));                  table.Columns.Add("COLUMN_TYPE"' typeof(string));                  table.Columns.Add("COLUMN_LENGTH"' typeof(int));                  table.Columns.Add("COLUMN_PRECISION"' typeof(int));                  table.Columns.Add("COLUMN_NULLABLE"' typeof(bool));                  table.Columns.Add("COLUMN_IDENTITY"' typeof(bool));                  table.Columns.Add("COLUMN_DEFAULT"' typeof(string));                  table.Columns.Add("COLUMN_SCALE"' typeof(int));                    tmConn.InternalConnection.dataStream.startMessage(Protocol.GetColumns);                  tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                  for (int i = 1; i < 4; i++)                      if (restrictionValues != null && restrictionValues.Length > i)                          tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                      else                          tmConn.InternalConnection.dataStream.encodeNull();                    tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                  int handle = tmConn.InternalConnection.dataStream.getInt();                    if (handle != -1)                  {                      using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                      {                          table.BeginLoadData();                          while (reader.Read())                          {                              DataRow row = table.NewRow();                              row["COLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                              row["COLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                              row["COLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                              row["COLUMN_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                              row["COLUMN_LENGTH"] = reader.GetFieldValue<int>("COLUMN_SIZE");                              row["COLUMN_PRECISION"] = reader.GetFieldValue<int>("BUFFER_LENGTH");                              row["COLUMN_SCALE"] = reader.GetFieldValue<int>("DECIMAL_DIGITS");                              if (isNumeric(reader.GetFieldValue<string>("TYPE_NAME")))                              {                                  if (reader.GetFieldValue<int>("DECIMAL_DIGITS") != 0)                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME") +                                           "(" + reader.GetFieldValue<int>("BUFFER_LENGTH") + "'" + reader.GetFieldValue<int>("DECIMAL_DIGITS") + ")";                                  else                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME");                              }                              else                              {                                  if (isVarLenType(reader.GetFieldValue<string>("TYPE_NAME")) && reader.GetFieldValue<int>("COLUMN_SIZE") != 0)                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME") +                                           "(" + reader.GetFieldValue<int>("COLUMN_SIZE") + ")";                                  else                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME");                              }                              if (!reader.IsDBNull(reader.GetOrdinal("IS_NULLABLE")))                                  row["COLUMN_NULLABLE"] = reader.GetFieldValue<string>("IS_NULLABLE").Equals("YES");                              if (!reader.IsDBNull(reader.GetOrdinal("IS_AUTOINCREMENT")))                                  row["COLUMN_IDENTITY"] = reader.GetFieldValue<string>("IS_AUTOINCREMENT").Equals("YES");                              row["COLUMN_DEFAULT"] = reader.GetFieldValue<string>("COLUMN_DEF");    #if DEBUG                              System.Diagnostics.Trace.WriteLine("-> " + row["COLUMN_NAME"] + " " + row["COLUMN_TYPE"]);  #endif                              table.Rows.Add(row);                          }                          table.EndLoadData();                      }                  }              }              else if (collectionName == "Indexes")              {                  table.Columns.Add("INDEX_CATALOG"' typeof(string));                  table.Columns.Add("INDEX_SCHEMA"' typeof(string));                  table.Columns.Add("INDEX_TABLE"' typeof(string));                  table.Columns.Add("INDEX_NAME"' typeof(string));                  table.Columns.Add("INDEX_TYPE"' typeof(string));                  table.Columns.Add("INDEX_UNIQUE"' typeof(bool));                  table.Columns.Add("INDEX_PRIMARY"' typeof(bool));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetIndexInfo);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // unique                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // approximate                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        // to avoid to insert the same index more than once                      HashSet<string> unique = new HashSet<string>();                      if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;                                  if (!unique.Add(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;                                  DataRow row = table.NewRow();                                  row["INDEX_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEX_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEX_NAME"] = reader.GetFieldValue<string>("INDEX_NAME");                                  switch (reader.GetFieldValue<int>("TYPE"))                                  {                                      case 0:                                          row["INDEX_TYPE"] = "Primary";                                          break;                                      case 1:                                          row["INDEX_TYPE"] = "Unique";                                          break;                                      case 2:                                          row["INDEX_TYPE"] = "Secondary";                                          break;                                      case 3:                                          row["INDEX_TYPE"] = "Foreign Key";                                          break;                                  }                                  row["INDEX_UNIQUE"] = (reader.GetFieldValue<int>("NON_UNIQUE") == 0) ? true : false;                                  row["INDEX_PRIMARY"] = (reader.GetFieldValue<int>("TYPE") == 0) ? true : false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                        tmConn.InternalConnection.dataStream.startMessage(Protocol.GetPrimaryKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              // use INDEX_NAME' if present; if missing' the name of the index is in PK_NAME                              string indexName = "PK_NAME";                              foreach (string column in reader.columnNames)                              {                                  if (column == "INDEX_NAME")                                  {                                      indexName = "INDEX_NAME";                                      break;                                  }                              }                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>(indexName)))                                      continue;                                  if (!unique.Add(reader.GetFieldValue<string>(indexName)))                                      continue;                                  DataRow row = table.NewRow();                                  row["INDEX_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEX_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEX_NAME"] = reader.GetFieldValue<string>(indexName);                                  row["INDEX_TYPE"] = "Primary";                                  row["INDEX_UNIQUE"] = true;                                  row["INDEX_PRIMARY"] = true;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "IndexColumns")              {                  table.Columns.Add("INDEXCOLUMN_CATALOG"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_TABLE"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_INDEX"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_NAME"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_POSITION"' typeof(int));                  table.Columns.Add("INDEXCOLUMN_ISPRIMARY"' typeof(bool));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetIndexInfo);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // unique                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // approximate                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_SCHEM"] + "." + reader["TABLE_NAME"] + "=" + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["INDEXCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEXCOLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEXCOLUMN_INDEX"] = reader.GetFieldValue<string>("INDEX_NAME");                                  row["INDEXCOLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["INDEXCOLUMN_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                                  row["INDEXCOLUMN_ISPRIMARY"] = false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                        tmConn.InternalConnection.dataStream.startMessage(Protocol.GetPrimaryKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              // use INDEX_NAME' if present; if missing' the name of the index is in PK_NAME                              string indexName = "PK_NAME";                              foreach (string column in reader.columnNames)                              {                                  if (column == "INDEX_NAME")                                  {                                      indexName = "INDEX_NAME";                                      break;                                  }                              }                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>(indexName)))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_SCHEM"] + "." + reader["TABLE_NAME"] + " (Primary) =" + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["INDEXCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEXCOLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEXCOLUMN_INDEX"] = reader.GetFieldValue<string>(indexName);                                  row["INDEXCOLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["INDEXCOLUMN_POSITION"] = reader.GetFieldValue<int>("KEY_SEQ");                                  row["INDEXCOLUMN_ISPRIMARY"] = true;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ForeignKeys")              {                  table.Columns.Add("FOREIGNKEY_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEY_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEY_TABLE"' typeof(string));                  table.Columns.Add("FOREIGNKEY_NAME"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_TABLE"' typeof(string));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetImportedKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  string name = "[" + reader.GetFieldValue<string>("FKTABLE_SCHEM") + "]" +                                                   reader.GetFieldValue<string>("FKTABLE_NAME") + "." +                                                   reader.GetFieldValue<string>("FKCOLUMN_NAME") + "->" +                                                  "[" + reader.GetFieldValue<string>("PKTABLE_SCHEM") + "]" +                                                   reader.GetFieldValue<string>("PKTABLE_NAME") + "." +                                                   reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(name))                                      continue;                                  DataRow row = table.NewRow();                                  row["FOREIGNKEY_SCHEMA"] = reader.GetFieldValue<string>("FKTABLE_SCHEM");                                  row["FOREIGNKEY_TABLE"] = reader.GetFieldValue<string>("FKTABLE_NAME");                                  row["FOREIGNKEY_NAME"] = name;                                  row["FOREIGNKEY_OTHER_SCHEMA"] = reader.GetFieldValue<string>("PKTABLE_SCHEM");                                  row["FOREIGNKEY_OTHER_TABLE"] = reader.GetFieldValue<string>("PKTABLE_NAME");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ForeignKeyColumns")              {                  table.Columns.Add("FOREIGNKEYCOLUMN_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_TABLE"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_KEY"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_NAME"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_ORDINAL"' typeof(int));                  table.Columns.Add("FOREIGNKEYCOLUMN_OTHER_COLUMN_NAME"' typeof(string));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetImportedKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  string name = "[" + reader.GetFieldValue<string>("FKTABLE_SCHEM") + "]" +                                                  reader.GetFieldValue<string>("FKTABLE_NAME") + "." +                                                  reader.GetFieldValue<string>("FKCOLUMN_NAME") + "->" +                                                  "[" + reader.GetFieldValue<string>("PKTABLE_SCHEM") + "]" +                                                  reader.GetFieldValue<string>("PKTABLE_NAME") + "." +                                                  reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(name))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["FKTABLE_SCHEM"] + "." + reader["FKTABLE_NAME"] + "=" + reader["FKCOLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["FOREIGNKEYCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("FKTABLE_SCHEM");                                  row["FOREIGNKEYCOLUMN_TABLE"] = reader.GetFieldValue<string>("FKTABLE_NAME");                                  row["FOREIGNKEYCOLUMN_KEY"] = name;                                  row["FOREIGNKEYCOLUMN_NAME"] = reader.GetFieldValue<string>("FKCOLUMN_NAME");                                  row["FOREIGNKEYCOLUMN_ORDINAL"] = reader.GetFieldValue<int>("KEY_SEQ");                                  row["FOREIGNKEYCOLUMN_OTHER_COLUMN_NAME"] = reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "Procedures")               {                  table.Columns.Add("PROCEDURE_CATALOG"' typeof(string));                  table.Columns.Add("PROCEDURE_SCHEMA"' typeof(string));                  table.Columns.Add("PROCEDURE_NAME"' typeof(string));                  table.Columns.Add("IS_SYSTEM_PROCEDURE"' typeof(bool));                    if (tmConn.InternalConnection.protocolVersion >= Protocol.PROTOCOL_VERSION12)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetProcedures);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      for (int i = 1; i < 3; i++)                          if (restrictionValues != null && restrictionValues.Length > i)                              tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                          else                              tmConn.InternalConnection.dataStream.encodeNull();                        tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["PROCEDURE_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["PROCEDURE_SCHEMA"] = reader.GetFieldValue<string>("PROCEDURE_SCHEM");                                  row["PROCEDURE_NAME"] = reader.GetFieldValue<string>("PROCEDURE_NAME");                                  row["IS_SYSTEM_PROCEDURE"] = false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ProcedureParameters")              {                  table.Columns.Add("PROCEDURE_CATALOG"' typeof(string));                  table.Columns.Add("PROCEDURE_SCHEMA"' typeof(string));                  table.Columns.Add("PROCEDURE_NAME"' typeof(string));                  table.Columns.Add("PARAMETER_NAME"' typeof(string));                  table.Columns.Add("ORDINAL_POSITION"' typeof(int));                  table.Columns.Add("PARAMETER_DATA_TYPE"' typeof(int));                  table.Columns.Add("PARAMETER_TYPE_NAME"' typeof(string));                  table.Columns.Add("PARAMETER_SIZE"' typeof(int));                  table.Columns.Add("NUMERIC_PRECISION"' typeof(int));                  table.Columns.Add("NUMERIC_SCALE"' typeof(int));                  table.Columns.Add("PARAMETER_DIRECTION"' typeof(int));                  table.Columns.Add("IS_NULLABLE"' typeof(bool));                    if (tmConn.InternalConnection.protocolVersion >= Protocol.PROTOCOL_VERSION12)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetProcedureColumns);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      for (int i = 1; i < 4; i++)                          if (restrictionValues != null && restrictionValues.Length > i)                              tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                          else                              tmConn.InternalConnection.dataStream.encodeNull();                        tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["PROCEDURE_NAME"] + "' " + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["PROCEDURE_SCHEMA"] = reader.GetFieldValue<string>("PROCEDURE_SCHEM");                                  row["PROCEDURE_NAME"] = reader.GetFieldValue<string>("PROCEDURE_NAME");                                  row["PARAMETER_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["ORDINAL_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                                  row["PARAMETER_TYPE_NAME"] = reader.GetFieldValue<string>("TYPE_NAME");                                  row["PARAMETER_DATA_TYPE"] = reader.GetFieldValue<int>("DATA_TYPE");                                  row["PARAMETER_SIZE"] = reader.GetFieldValue<int>("LENGTH");                                  row["NUMERIC_PRECISION"] = reader.GetFieldValue<int>("PRECISION");                                  row["NUMERIC_SCALE"] = reader.GetFieldValue<int>("SCALE");                                  row["PARAMETER_DIRECTION"] = reader.GetFieldValue<int>("COLUMN_TYPE");                                  row["IS_NULLABLE"] = !reader.GetFieldValue<string>("IS_NULLABLE").Equals("NO");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The following statement contains a magic number: if (collectionName == DbMetaDataCollectionNames.DataSourceInformation)              {                  // see http://msdn.microsoft.com/en-us/library/ms254501.aspx                  table.Columns.Add("CompositeIdentifierSeparatorPattern"' typeof(string));                  table.Columns.Add("DataSourceProductName"' typeof(string));                  table.Columns.Add("DataSourceProductVersion"' typeof(string));                  table.Columns.Add("DataSourceProductVersionNormalized"' typeof(string));                  table.Columns.Add("DataSourceInternalProductVersion"' typeof(string));                  table.Columns.Add("GroupByBehavior"' typeof(GroupByBehavior));                  table.Columns.Add("IdentifierPattern"' typeof(string));                  table.Columns.Add("IdentifierCase"' typeof(IdentifierCase));                  table.Columns.Add("OrderByColumnsInSelect"' typeof(bool));                  table.Columns.Add("ParameterMarkerFormat"' typeof(string));                  table.Columns.Add("ParameterMarkerPattern"' typeof(string));                  table.Columns.Add("ParameterNameMaxLength"' typeof(int));                  table.Columns.Add("ParameterNamePattern"' typeof(string));                  table.Columns.Add("QuotedIdentifierPattern"' typeof(string));  // Regex                  table.Columns.Add("QuotedIdentifierCase"' typeof(int));                  table.Columns.Add("StatementSeparatorPattern"' typeof(string));                  table.Columns.Add("StringLiteralPattern"' typeof(string));  // Regex                  table.Columns.Add("SupportedJoinOperators"' typeof(SupportedJoinOperators));                    table.BeginLoadData();                  DataRow row = table.NewRow();                  int databaseMajorVersion = 0' databaseMinorVersion = 0;                  try                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetDatabaseMetaData);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      for (int item; (item = tmConn.InternalConnection.dataStream.getInt()) != Protocol.DbmbFini; )                      {                          switch (item)                          {                              case Protocol.DbmbProductName:                                  row["DataSourceProductName"] = tmConn.InternalConnection.dataStream.getString();                                  break;                                case Protocol.DbmbProductVersion:                                  row["DataSourceProductVersion"] = tmConn.InternalConnection.dataStream.getString();                                  break;                                case Protocol.DbmbDatabaseMinorVersion:                                  databaseMinorVersion = tmConn.InternalConnection.dataStream.getInt();                                  break;                                case Protocol.DbmbDatabaseMajorVersion:                                  databaseMajorVersion = tmConn.InternalConnection.dataStream.getInt();                                  break;                                case Protocol.DbmbDefaultTransactionIsolation:                                  int defaultTransactionIsolation = tmConn.InternalConnection.dataStream.getInt();                                  break;                                default:                                  tmConn.InternalConnection.dataStream.decode();                                  break;                          }                      }                  }                  catch (Exception)                  {                  }                    row["DataSourceInternalProductVersion"] = String.Format("{0:D3}.{1:D3}"' databaseMajorVersion' databaseMinorVersion);                  // The regular expression to match the composite separators in a composite identifier.                   // For example' "\." (for SQL Server) or "@|\." (for Oracle).                  // A composite identifier is typically what is used for a database object name'                   // for example: pubs.dbo.authors or pubs@dbo.authors.                  row["CompositeIdentifierSeparatorPattern"] = "\\.";                  // A normalized version for the data source' such that it can be compared with String.Compare().                   // The format of this is consistent for all versions of the provider to prevent version 10 from sorting between version 1 and version 2.                  //row["DataSourceProductVersionNormalized"] = ??                  // Specifies the relationship between the columns in a GROUP BY clause and the non-aggregated columns in the select list.                  row["GroupByBehavior"] = GroupByBehavior.Unknown;                  // A regular expression that matches an identifier and has a match value of the identifier. For example "[A-Za-z0-9_#$]".                  row["IdentifierPattern"] = "(^\\[\\p{Lo}\\p{Lu}\\p{Ll}_@#][\\p{Lo}\\p{Lu}\\p{Ll}\\p{Nd}@$#_]*$)|(^\"[^\"\\0]|\"\"+\"$)";                  // Indicates whether non-quoted identifiers are treated as case sensitive or not.                  row["IdentifierCase"] = IdentifierCase.Insensitive;                  // Specifies whether columns in an ORDER BY clause must be in the select list.                   // A value of true indicates that they are required to be in the select list'                   // a value of false indicates that they are not required to be in the select list.                  row["OrderByColumnsInSelect"] = false;                  // For data sources that do not expect named parameters and expect the use of the ‘?’ character' the format string                  // can be specified as simply '?'' which would ignore the parameter name.                  row["ParameterMarkerFormat"] = "?";                  // if the data source doesn't support named parameters' this would simply be "?".                  row["ParameterMarkerPattern"] = "?";                  // If the data source does not support named parameters' this property returns zero.                  row["ParameterNameMaxLength"] = 0;                  // A regular expression that matches the valid parameter names                  row["ParameterNamePattern"] = "";                  // A regular expression that matches a quoted identifier and has a match value of the identifier itself without the quotes.                   // For example' if the data source used double-quotes to identify quoted identifiers' this would be: "(([^\"]|\"\")*)".                  row["QuotedIdentifierPattern"] = "\"([^\"]*)\"";                  // Indicates whether quoted identifiers are treated as case sensitive or not.                  row["QuotedIdentifierCase"] = IdentifierCase.Sensitive;                  // A regular expression that matches the statement separator.                  row["StatementSeparatorPattern"] = ";";                  // A regular expression that matches a string literal and has a match value of the literal itself.                   // For example' if the data source used single-quotes to identify strings' this would be: "('([^']|'')*')"'                  row["StringLiteralPattern"] = "'([^']*)'";                  // Specifies what types of SQL join statements are supported by the data source.                  row["SupportedJoinOperators"] = SupportedJoinOperators.None;                  table.Rows.Add(row);                  table.EndLoadData();              }              else if (collectionName == DbMetaDataCollectionNames.ReservedWords)              {                  table.Columns.Add("ReservedWord"' typeof(string));                  table.Columns.Add("MaximumVersion"' typeof(string));                  table.Columns.Add("MinimumVersion"' typeof(string));                    string[] words = { "select"' "Add field"' "Drop field"' "Alter table"' "Alter field"'                                      "Alter user"' "And"' "Or"' "Not"' "Create Index"' "Upgrade"' "Unique"'                                      "Table key"' "Table unique key"' "Primary Key"' "Create Table"'                                      "Upgrade Table"' "Rename Table"' "Create View"' "Upgrade View"'                                      "Drop View"' "Create Schema"' "Drop Schema"' "Integer"' "Smallint"'                                      "Bigint"' "Tinyint"' "float"' "double"' "Blob"' "bytes"' "boolean"'                                      "binary"' "varbinary"' "string"' "char"' "text"' "date"' "timestamp"'                                      "time"' "varchar"' "numeric"' "Decimal Number"' "Enum"' "Delete"' "Repair"'                                      "Field"' "Not Null"' "Default Value"' "searchable"' "not searchable"'                                      "collation"' "character_set"' "Foreign Key"' "Identifier"' "record number"'                                      "Insert"' "Replace"' "Name"' "Number"' "Order"' "Descending"' "limit"'                                      "Quoted String"' "Select Clause"' "Distinct"' "Gtr"' "Geq"' "Eql"'                                      "Leq"' "Lss"' "Neq"' "in list"' "in select"' "exists"' "Between"' "Like"'                                      "starts with"' "Containing"' "Matching"' "Regular expression"' "Null"'                                      "True"' "False"' "Execute"' "Parameter"' "Count"' "sum"' "min"' "max"'                                      "avg"' "Drop Index"' "Drop primary key"' "Drop foreign key"' "Drop Table"'                                      "If Exists"' "Describe"' "Statement"' "for_select"' "for_insert"' "while"'                                      "if then else"' "variable"' "declaration"' "throw"' "assignment"'                                      "Start transaction"' "read only"' "read write"' "read committed"' "write committed"'                                      "read uncommitted"' "repeatableread"' "serializable"' "Commit"' "Rollback"'                                      "Savepoint"' "Rollack Savepoint"' "Release Savepoint"' "Table"' "Derived Table"'                                      "Assign"' "Update"' "list"' "Constant"' "Function"' "Grant"' "Grant role"' "Alter"'                                      "Read"' "Identity"' "Check"' "Constraint"' "value constraint"' "auto increment"'                                      "generated"' "always"' "Domain"' "is null"' "is active_role"' "start with"' "reindex"'                                      "cursor"' "alias"' "push_namespace"' "pop_namespace"' "set_namespace"' "coalesce"'                                      "nod_nullif"' "case"' "case_search"' "add"' "subtract"' "multiply"' "divide"' "modulus"'                                      "negate"' "plus"' "cast"' "concatenation"' "create user"' "drop user"' "create role"'                                      "upgrade role"' "drop role"' "revoke"' "revoke role"' "assume"' "revert"' "negate"'                                      "priv insert"' "priv delete"' "priv execute"' "priv select"' "priv update"' "priv grant"'                                      "priv all"' "characters"' "octets"' "role"' "view"' "procedure"' "user"' "zone"' "admin"'                                      "default role"' "create sequence"' "upgrade sequence"' "drop sequence"' "next value"'                                      "create trigger"' "upgrade trigger"' "alter trigger"' "drop trigger"' "create procedure"'                                      "upgrade procedure"' "alter procedure"' "drop procedure"' "pre-insert"' "post-insert"'                                      "pre-update"' "post-update"' "pre-delete"' "post-delete"' "pre-commit"' "post-commit"'                                      "active"' "inactive"' "position"' "select-expr"' "create filterset"' "upgrade filterset"'                                      "drop filterset"' "enable filterset"' "disable filterset"' "table filter"' "left outer"'                                      "right outer"' "full outer"' "inner"' "join"' "join_term"' "trigger class"' "enable trigger class"'                                      "disable trigger class"' "create zone"' "upgrade zone"' "drop zone"' "range"' "ip address"'                                      "node_name"' "wildcard"' "create domain"' "upgrade domain"' "alter domain"' "upgrade schema"'                                      "delete cascade"' "index segment"' "for update"' "write committed"' "read committed"'                                       "consistent read"' "set dialect"' "set names"' "restrict"' "cascade"' "characters"' "octets"'                                      "create event"' "collate"' "truncate"' "restart"' "nameless constraint"' "drop constraint"'                                      "drop unique constraint"' "drop domain"' "with check option"' "not real"' "lower"' "upper"'                                      "substr"' "substring index"' "charlength"' "default keyword"' "sqrt"' "power"' "Scientific Notation Number"'                                      "Explain"' "msleep"' "KillStatement"' "now" };                  table.BeginLoadData();                  foreach (string keyword in words)                  {                      DataRow row = table.NewRow();                      row["ReservedWord"] = keyword;                      table.Rows.Add(row);                  }                  table.EndLoadData();                }              else if (collectionName == DbMetaDataCollectionNames.DataTypes)              {                  table.Columns.Add("TypeName"' typeof(string));  // The provider-specific data type name.                  table.Columns.Add("ProviderDbType"' typeof(int)); // The provider-specific type value that should be used when specifying                   //a parameter's type. For example' SqlDbType.Money or OracleType.Blob.                  table.Columns.Add("ColumnSize"' typeof(long));                  table.Columns.Add("CreateFormat"' typeof(string));                  table.Columns.Add("CreateParameters"' typeof(string));                  table.Columns.Add("DataType"' typeof(string));  // The name of the .NET Framework type of the data type.                  table.Columns.Add("IsAutoincrementable"' typeof(bool));                  table.Columns.Add("IsBestMatch"' typeof(bool));                  table.Columns.Add("IsCaseSensitive"' typeof(bool));                  table.Columns.Add("IsFixedLength"' typeof(bool));                  table.Columns.Add("IsFixedPrecisionScale"' typeof(bool));                  table.Columns.Add("IsLong"' typeof(bool));                  table.Columns.Add("IsNullable"' typeof(bool));                  table.Columns.Add("IsSearchable"' typeof(bool));                  table.Columns.Add("IsSearchableWithLike"' typeof(bool));                  table.Columns.Add("IsUnsigned"' typeof(bool));                  table.Columns.Add("MaximumScale"' typeof(short));                  table.Columns.Add("MinimumScale"' typeof(short));                  table.Columns.Add("IsConcurrencyType"' typeof(bool));                  table.Columns.Add("IsLiteralsSupported"' typeof(bool));                  table.Columns.Add("LiteralPrefix"' typeof(string));                  table.Columns.Add("LiteralSuffix"' typeof(string));                  table.Columns.Add("NativeDataType"' typeof(string));    // NativeDataType is an OLE DB specific column for exposing the OLE DB type of the data type .                    table.ReadXml(XmlReader.Create(typeof(NuoDbConnectionInternal).Assembly.GetManifestResourceStream("NuoDb.Data.Client.DataTypes.xml")));              }              else if (collectionName == "Tables")              {                  table.Columns.Add("TABLE_CATALOG"' typeof(string));                  table.Columns.Add("TABLE_SCHEMA"' typeof(string));                  table.Columns.Add("TABLE_NAME"' typeof(string));                  table.Columns.Add("TABLE_TYPE"' typeof(string));                  table.Columns.Add("REMARKS"' typeof(string));                  table.Columns.Add("VIEW_DEF"' typeof(string));                    tmConn.InternalConnection.dataStream.startMessage(Protocol.GetTables);                  tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                  for (int i = 1; i < 3; i++)                      if (restrictionValues != null && restrictionValues.Length > i)                          tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                      else                          tmConn.InternalConnection.dataStream.encodeNull();                  if (restrictionValues == null || restrictionValues.Length < 4 || restrictionValues[3] == null)                      tmConn.InternalConnection.dataStream.encodeInt(0);                  else                  {                      tmConn.InternalConnection.dataStream.encodeInt(1);                      tmConn.InternalConnection.dataStream.encodeString(restrictionValues[3]);                  }                    tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                  int handle = tmConn.InternalConnection.dataStream.getInt();                    if (handle != -1)                  {                      using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                      {                          table.BeginLoadData();                          string view_def_label="";                          try                           {                               reader.GetOrdinal("VIEW_DEF");                              view_def_label = "VIEW_DEF";                          }                          catch(Exception) {}                          try                           {                               reader.GetOrdinal("VIEWDEFINITION");                              view_def_label = "VIEWDEFINITION";                          }                          catch (Exception) { }                          while (reader.Read())                          {  #if DEBUG                          System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_NAME"] + "' " + reader["TABLE_TYPE"]);  #endif                              DataRow row = table.NewRow();                              row["TABLE_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                              row["TABLE_NAME"] = reader.GetFieldValue<string>("TABLE_NAME");                              row["TABLE_TYPE"] = reader.GetFieldValue<string>("TABLE_TYPE");                              row["REMARKS"] = reader.GetFieldValue<string>("REMARKS");                              if (view_def_label.Length != 0)                              {                                  row["VIEW_DEF"] = reader.GetFieldValue<string>(view_def_label);                              }                              table.Rows.Add(row);                          }                          table.EndLoadData();                      }                  }              }              else if (collectionName == "Columns")              {                  table.Columns.Add("COLUMN_CATALOG"' typeof(string));                  table.Columns.Add("COLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("COLUMN_TABLE"' typeof(string));                  table.Columns.Add("COLUMN_NAME"' typeof(string));                  table.Columns.Add("COLUMN_POSITION"' typeof(int));                  table.Columns.Add("COLUMN_TYPE"' typeof(string));                  table.Columns.Add("COLUMN_LENGTH"' typeof(int));                  table.Columns.Add("COLUMN_PRECISION"' typeof(int));                  table.Columns.Add("COLUMN_NULLABLE"' typeof(bool));                  table.Columns.Add("COLUMN_IDENTITY"' typeof(bool));                  table.Columns.Add("COLUMN_DEFAULT"' typeof(string));                  table.Columns.Add("COLUMN_SCALE"' typeof(int));                    tmConn.InternalConnection.dataStream.startMessage(Protocol.GetColumns);                  tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                  for (int i = 1; i < 4; i++)                      if (restrictionValues != null && restrictionValues.Length > i)                          tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                      else                          tmConn.InternalConnection.dataStream.encodeNull();                    tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                  int handle = tmConn.InternalConnection.dataStream.getInt();                    if (handle != -1)                  {                      using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                      {                          table.BeginLoadData();                          while (reader.Read())                          {                              DataRow row = table.NewRow();                              row["COLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                              row["COLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                              row["COLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                              row["COLUMN_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                              row["COLUMN_LENGTH"] = reader.GetFieldValue<int>("COLUMN_SIZE");                              row["COLUMN_PRECISION"] = reader.GetFieldValue<int>("BUFFER_LENGTH");                              row["COLUMN_SCALE"] = reader.GetFieldValue<int>("DECIMAL_DIGITS");                              if (isNumeric(reader.GetFieldValue<string>("TYPE_NAME")))                              {                                  if (reader.GetFieldValue<int>("DECIMAL_DIGITS") != 0)                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME") +                                           "(" + reader.GetFieldValue<int>("BUFFER_LENGTH") + "'" + reader.GetFieldValue<int>("DECIMAL_DIGITS") + ")";                                  else                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME");                              }                              else                              {                                  if (isVarLenType(reader.GetFieldValue<string>("TYPE_NAME")) && reader.GetFieldValue<int>("COLUMN_SIZE") != 0)                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME") +                                           "(" + reader.GetFieldValue<int>("COLUMN_SIZE") + ")";                                  else                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME");                              }                              if (!reader.IsDBNull(reader.GetOrdinal("IS_NULLABLE")))                                  row["COLUMN_NULLABLE"] = reader.GetFieldValue<string>("IS_NULLABLE").Equals("YES");                              if (!reader.IsDBNull(reader.GetOrdinal("IS_AUTOINCREMENT")))                                  row["COLUMN_IDENTITY"] = reader.GetFieldValue<string>("IS_AUTOINCREMENT").Equals("YES");                              row["COLUMN_DEFAULT"] = reader.GetFieldValue<string>("COLUMN_DEF");    #if DEBUG                              System.Diagnostics.Trace.WriteLine("-> " + row["COLUMN_NAME"] + " " + row["COLUMN_TYPE"]);  #endif                              table.Rows.Add(row);                          }                          table.EndLoadData();                      }                  }              }              else if (collectionName == "Indexes")              {                  table.Columns.Add("INDEX_CATALOG"' typeof(string));                  table.Columns.Add("INDEX_SCHEMA"' typeof(string));                  table.Columns.Add("INDEX_TABLE"' typeof(string));                  table.Columns.Add("INDEX_NAME"' typeof(string));                  table.Columns.Add("INDEX_TYPE"' typeof(string));                  table.Columns.Add("INDEX_UNIQUE"' typeof(bool));                  table.Columns.Add("INDEX_PRIMARY"' typeof(bool));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetIndexInfo);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // unique                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // approximate                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        // to avoid to insert the same index more than once                      HashSet<string> unique = new HashSet<string>();                      if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;                                  if (!unique.Add(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;                                  DataRow row = table.NewRow();                                  row["INDEX_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEX_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEX_NAME"] = reader.GetFieldValue<string>("INDEX_NAME");                                  switch (reader.GetFieldValue<int>("TYPE"))                                  {                                      case 0:                                          row["INDEX_TYPE"] = "Primary";                                          break;                                      case 1:                                          row["INDEX_TYPE"] = "Unique";                                          break;                                      case 2:                                          row["INDEX_TYPE"] = "Secondary";                                          break;                                      case 3:                                          row["INDEX_TYPE"] = "Foreign Key";                                          break;                                  }                                  row["INDEX_UNIQUE"] = (reader.GetFieldValue<int>("NON_UNIQUE") == 0) ? true : false;                                  row["INDEX_PRIMARY"] = (reader.GetFieldValue<int>("TYPE") == 0) ? true : false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                        tmConn.InternalConnection.dataStream.startMessage(Protocol.GetPrimaryKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              // use INDEX_NAME' if present; if missing' the name of the index is in PK_NAME                              string indexName = "PK_NAME";                              foreach (string column in reader.columnNames)                              {                                  if (column == "INDEX_NAME")                                  {                                      indexName = "INDEX_NAME";                                      break;                                  }                              }                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>(indexName)))                                      continue;                                  if (!unique.Add(reader.GetFieldValue<string>(indexName)))                                      continue;                                  DataRow row = table.NewRow();                                  row["INDEX_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEX_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEX_NAME"] = reader.GetFieldValue<string>(indexName);                                  row["INDEX_TYPE"] = "Primary";                                  row["INDEX_UNIQUE"] = true;                                  row["INDEX_PRIMARY"] = true;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "IndexColumns")              {                  table.Columns.Add("INDEXCOLUMN_CATALOG"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_TABLE"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_INDEX"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_NAME"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_POSITION"' typeof(int));                  table.Columns.Add("INDEXCOLUMN_ISPRIMARY"' typeof(bool));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetIndexInfo);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // unique                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // approximate                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_SCHEM"] + "." + reader["TABLE_NAME"] + "=" + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["INDEXCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEXCOLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEXCOLUMN_INDEX"] = reader.GetFieldValue<string>("INDEX_NAME");                                  row["INDEXCOLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["INDEXCOLUMN_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                                  row["INDEXCOLUMN_ISPRIMARY"] = false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                        tmConn.InternalConnection.dataStream.startMessage(Protocol.GetPrimaryKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              // use INDEX_NAME' if present; if missing' the name of the index is in PK_NAME                              string indexName = "PK_NAME";                              foreach (string column in reader.columnNames)                              {                                  if (column == "INDEX_NAME")                                  {                                      indexName = "INDEX_NAME";                                      break;                                  }                              }                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>(indexName)))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_SCHEM"] + "." + reader["TABLE_NAME"] + " (Primary) =" + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["INDEXCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEXCOLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEXCOLUMN_INDEX"] = reader.GetFieldValue<string>(indexName);                                  row["INDEXCOLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["INDEXCOLUMN_POSITION"] = reader.GetFieldValue<int>("KEY_SEQ");                                  row["INDEXCOLUMN_ISPRIMARY"] = true;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ForeignKeys")              {                  table.Columns.Add("FOREIGNKEY_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEY_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEY_TABLE"' typeof(string));                  table.Columns.Add("FOREIGNKEY_NAME"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_TABLE"' typeof(string));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetImportedKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  string name = "[" + reader.GetFieldValue<string>("FKTABLE_SCHEM") + "]" +                                                   reader.GetFieldValue<string>("FKTABLE_NAME") + "." +                                                   reader.GetFieldValue<string>("FKCOLUMN_NAME") + "->" +                                                  "[" + reader.GetFieldValue<string>("PKTABLE_SCHEM") + "]" +                                                   reader.GetFieldValue<string>("PKTABLE_NAME") + "." +                                                   reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(name))                                      continue;                                  DataRow row = table.NewRow();                                  row["FOREIGNKEY_SCHEMA"] = reader.GetFieldValue<string>("FKTABLE_SCHEM");                                  row["FOREIGNKEY_TABLE"] = reader.GetFieldValue<string>("FKTABLE_NAME");                                  row["FOREIGNKEY_NAME"] = name;                                  row["FOREIGNKEY_OTHER_SCHEMA"] = reader.GetFieldValue<string>("PKTABLE_SCHEM");                                  row["FOREIGNKEY_OTHER_TABLE"] = reader.GetFieldValue<string>("PKTABLE_NAME");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ForeignKeyColumns")              {                  table.Columns.Add("FOREIGNKEYCOLUMN_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_TABLE"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_KEY"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_NAME"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_ORDINAL"' typeof(int));                  table.Columns.Add("FOREIGNKEYCOLUMN_OTHER_COLUMN_NAME"' typeof(string));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetImportedKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  string name = "[" + reader.GetFieldValue<string>("FKTABLE_SCHEM") + "]" +                                                  reader.GetFieldValue<string>("FKTABLE_NAME") + "." +                                                  reader.GetFieldValue<string>("FKCOLUMN_NAME") + "->" +                                                  "[" + reader.GetFieldValue<string>("PKTABLE_SCHEM") + "]" +                                                  reader.GetFieldValue<string>("PKTABLE_NAME") + "." +                                                  reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(name))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["FKTABLE_SCHEM"] + "." + reader["FKTABLE_NAME"] + "=" + reader["FKCOLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["FOREIGNKEYCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("FKTABLE_SCHEM");                                  row["FOREIGNKEYCOLUMN_TABLE"] = reader.GetFieldValue<string>("FKTABLE_NAME");                                  row["FOREIGNKEYCOLUMN_KEY"] = name;                                  row["FOREIGNKEYCOLUMN_NAME"] = reader.GetFieldValue<string>("FKCOLUMN_NAME");                                  row["FOREIGNKEYCOLUMN_ORDINAL"] = reader.GetFieldValue<int>("KEY_SEQ");                                  row["FOREIGNKEYCOLUMN_OTHER_COLUMN_NAME"] = reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "Procedures")               {                  table.Columns.Add("PROCEDURE_CATALOG"' typeof(string));                  table.Columns.Add("PROCEDURE_SCHEMA"' typeof(string));                  table.Columns.Add("PROCEDURE_NAME"' typeof(string));                  table.Columns.Add("IS_SYSTEM_PROCEDURE"' typeof(bool));                    if (tmConn.InternalConnection.protocolVersion >= Protocol.PROTOCOL_VERSION12)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetProcedures);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      for (int i = 1; i < 3; i++)                          if (restrictionValues != null && restrictionValues.Length > i)                              tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                          else                              tmConn.InternalConnection.dataStream.encodeNull();                        tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["PROCEDURE_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["PROCEDURE_SCHEMA"] = reader.GetFieldValue<string>("PROCEDURE_SCHEM");                                  row["PROCEDURE_NAME"] = reader.GetFieldValue<string>("PROCEDURE_NAME");                                  row["IS_SYSTEM_PROCEDURE"] = false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ProcedureParameters")              {                  table.Columns.Add("PROCEDURE_CATALOG"' typeof(string));                  table.Columns.Add("PROCEDURE_SCHEMA"' typeof(string));                  table.Columns.Add("PROCEDURE_NAME"' typeof(string));                  table.Columns.Add("PARAMETER_NAME"' typeof(string));                  table.Columns.Add("ORDINAL_POSITION"' typeof(int));                  table.Columns.Add("PARAMETER_DATA_TYPE"' typeof(int));                  table.Columns.Add("PARAMETER_TYPE_NAME"' typeof(string));                  table.Columns.Add("PARAMETER_SIZE"' typeof(int));                  table.Columns.Add("NUMERIC_PRECISION"' typeof(int));                  table.Columns.Add("NUMERIC_SCALE"' typeof(int));                  table.Columns.Add("PARAMETER_DIRECTION"' typeof(int));                  table.Columns.Add("IS_NULLABLE"' typeof(bool));                    if (tmConn.InternalConnection.protocolVersion >= Protocol.PROTOCOL_VERSION12)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetProcedureColumns);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      for (int i = 1; i < 4; i++)                          if (restrictionValues != null && restrictionValues.Length > i)                              tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                          else                              tmConn.InternalConnection.dataStream.encodeNull();                        tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["PROCEDURE_NAME"] + "' " + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["PROCEDURE_SCHEMA"] = reader.GetFieldValue<string>("PROCEDURE_SCHEM");                                  row["PROCEDURE_NAME"] = reader.GetFieldValue<string>("PROCEDURE_NAME");                                  row["PARAMETER_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["ORDINAL_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                                  row["PARAMETER_TYPE_NAME"] = reader.GetFieldValue<string>("TYPE_NAME");                                  row["PARAMETER_DATA_TYPE"] = reader.GetFieldValue<int>("DATA_TYPE");                                  row["PARAMETER_SIZE"] = reader.GetFieldValue<int>("LENGTH");                                  row["NUMERIC_PRECISION"] = reader.GetFieldValue<int>("PRECISION");                                  row["NUMERIC_SCALE"] = reader.GetFieldValue<int>("SCALE");                                  row["PARAMETER_DIRECTION"] = reader.GetFieldValue<int>("COLUMN_TYPE");                                  row["IS_NULLABLE"] = !reader.GetFieldValue<string>("IS_NULLABLE").Equals("NO");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The following statement contains a magic number: if (collectionName == DbMetaDataCollectionNames.DataSourceInformation)              {                  // see http://msdn.microsoft.com/en-us/library/ms254501.aspx                  table.Columns.Add("CompositeIdentifierSeparatorPattern"' typeof(string));                  table.Columns.Add("DataSourceProductName"' typeof(string));                  table.Columns.Add("DataSourceProductVersion"' typeof(string));                  table.Columns.Add("DataSourceProductVersionNormalized"' typeof(string));                  table.Columns.Add("DataSourceInternalProductVersion"' typeof(string));                  table.Columns.Add("GroupByBehavior"' typeof(GroupByBehavior));                  table.Columns.Add("IdentifierPattern"' typeof(string));                  table.Columns.Add("IdentifierCase"' typeof(IdentifierCase));                  table.Columns.Add("OrderByColumnsInSelect"' typeof(bool));                  table.Columns.Add("ParameterMarkerFormat"' typeof(string));                  table.Columns.Add("ParameterMarkerPattern"' typeof(string));                  table.Columns.Add("ParameterNameMaxLength"' typeof(int));                  table.Columns.Add("ParameterNamePattern"' typeof(string));                  table.Columns.Add("QuotedIdentifierPattern"' typeof(string));  // Regex                  table.Columns.Add("QuotedIdentifierCase"' typeof(int));                  table.Columns.Add("StatementSeparatorPattern"' typeof(string));                  table.Columns.Add("StringLiteralPattern"' typeof(string));  // Regex                  table.Columns.Add("SupportedJoinOperators"' typeof(SupportedJoinOperators));                    table.BeginLoadData();                  DataRow row = table.NewRow();                  int databaseMajorVersion = 0' databaseMinorVersion = 0;                  try                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetDatabaseMetaData);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      for (int item; (item = tmConn.InternalConnection.dataStream.getInt()) != Protocol.DbmbFini; )                      {                          switch (item)                          {                              case Protocol.DbmbProductName:                                  row["DataSourceProductName"] = tmConn.InternalConnection.dataStream.getString();                                  break;                                case Protocol.DbmbProductVersion:                                  row["DataSourceProductVersion"] = tmConn.InternalConnection.dataStream.getString();                                  break;                                case Protocol.DbmbDatabaseMinorVersion:                                  databaseMinorVersion = tmConn.InternalConnection.dataStream.getInt();                                  break;                                case Protocol.DbmbDatabaseMajorVersion:                                  databaseMajorVersion = tmConn.InternalConnection.dataStream.getInt();                                  break;                                case Protocol.DbmbDefaultTransactionIsolation:                                  int defaultTransactionIsolation = tmConn.InternalConnection.dataStream.getInt();                                  break;                                default:                                  tmConn.InternalConnection.dataStream.decode();                                  break;                          }                      }                  }                  catch (Exception)                  {                  }                    row["DataSourceInternalProductVersion"] = String.Format("{0:D3}.{1:D3}"' databaseMajorVersion' databaseMinorVersion);                  // The regular expression to match the composite separators in a composite identifier.                   // For example' "\." (for SQL Server) or "@|\." (for Oracle).                  // A composite identifier is typically what is used for a database object name'                   // for example: pubs.dbo.authors or pubs@dbo.authors.                  row["CompositeIdentifierSeparatorPattern"] = "\\.";                  // A normalized version for the data source' such that it can be compared with String.Compare().                   // The format of this is consistent for all versions of the provider to prevent version 10 from sorting between version 1 and version 2.                  //row["DataSourceProductVersionNormalized"] = ??                  // Specifies the relationship between the columns in a GROUP BY clause and the non-aggregated columns in the select list.                  row["GroupByBehavior"] = GroupByBehavior.Unknown;                  // A regular expression that matches an identifier and has a match value of the identifier. For example "[A-Za-z0-9_#$]".                  row["IdentifierPattern"] = "(^\\[\\p{Lo}\\p{Lu}\\p{Ll}_@#][\\p{Lo}\\p{Lu}\\p{Ll}\\p{Nd}@$#_]*$)|(^\"[^\"\\0]|\"\"+\"$)";                  // Indicates whether non-quoted identifiers are treated as case sensitive or not.                  row["IdentifierCase"] = IdentifierCase.Insensitive;                  // Specifies whether columns in an ORDER BY clause must be in the select list.                   // A value of true indicates that they are required to be in the select list'                   // a value of false indicates that they are not required to be in the select list.                  row["OrderByColumnsInSelect"] = false;                  // For data sources that do not expect named parameters and expect the use of the ‘?’ character' the format string                  // can be specified as simply '?'' which would ignore the parameter name.                  row["ParameterMarkerFormat"] = "?";                  // if the data source doesn't support named parameters' this would simply be "?".                  row["ParameterMarkerPattern"] = "?";                  // If the data source does not support named parameters' this property returns zero.                  row["ParameterNameMaxLength"] = 0;                  // A regular expression that matches the valid parameter names                  row["ParameterNamePattern"] = "";                  // A regular expression that matches a quoted identifier and has a match value of the identifier itself without the quotes.                   // For example' if the data source used double-quotes to identify quoted identifiers' this would be: "(([^\"]|\"\")*)".                  row["QuotedIdentifierPattern"] = "\"([^\"]*)\"";                  // Indicates whether quoted identifiers are treated as case sensitive or not.                  row["QuotedIdentifierCase"] = IdentifierCase.Sensitive;                  // A regular expression that matches the statement separator.                  row["StatementSeparatorPattern"] = ";";                  // A regular expression that matches a string literal and has a match value of the literal itself.                   // For example' if the data source used single-quotes to identify strings' this would be: "('([^']|'')*')"'                  row["StringLiteralPattern"] = "'([^']*)'";                  // Specifies what types of SQL join statements are supported by the data source.                  row["SupportedJoinOperators"] = SupportedJoinOperators.None;                  table.Rows.Add(row);                  table.EndLoadData();              }              else if (collectionName == DbMetaDataCollectionNames.ReservedWords)              {                  table.Columns.Add("ReservedWord"' typeof(string));                  table.Columns.Add("MaximumVersion"' typeof(string));                  table.Columns.Add("MinimumVersion"' typeof(string));                    string[] words = { "select"' "Add field"' "Drop field"' "Alter table"' "Alter field"'                                      "Alter user"' "And"' "Or"' "Not"' "Create Index"' "Upgrade"' "Unique"'                                      "Table key"' "Table unique key"' "Primary Key"' "Create Table"'                                      "Upgrade Table"' "Rename Table"' "Create View"' "Upgrade View"'                                      "Drop View"' "Create Schema"' "Drop Schema"' "Integer"' "Smallint"'                                      "Bigint"' "Tinyint"' "float"' "double"' "Blob"' "bytes"' "boolean"'                                      "binary"' "varbinary"' "string"' "char"' "text"' "date"' "timestamp"'                                      "time"' "varchar"' "numeric"' "Decimal Number"' "Enum"' "Delete"' "Repair"'                                      "Field"' "Not Null"' "Default Value"' "searchable"' "not searchable"'                                      "collation"' "character_set"' "Foreign Key"' "Identifier"' "record number"'                                      "Insert"' "Replace"' "Name"' "Number"' "Order"' "Descending"' "limit"'                                      "Quoted String"' "Select Clause"' "Distinct"' "Gtr"' "Geq"' "Eql"'                                      "Leq"' "Lss"' "Neq"' "in list"' "in select"' "exists"' "Between"' "Like"'                                      "starts with"' "Containing"' "Matching"' "Regular expression"' "Null"'                                      "True"' "False"' "Execute"' "Parameter"' "Count"' "sum"' "min"' "max"'                                      "avg"' "Drop Index"' "Drop primary key"' "Drop foreign key"' "Drop Table"'                                      "If Exists"' "Describe"' "Statement"' "for_select"' "for_insert"' "while"'                                      "if then else"' "variable"' "declaration"' "throw"' "assignment"'                                      "Start transaction"' "read only"' "read write"' "read committed"' "write committed"'                                      "read uncommitted"' "repeatableread"' "serializable"' "Commit"' "Rollback"'                                      "Savepoint"' "Rollack Savepoint"' "Release Savepoint"' "Table"' "Derived Table"'                                      "Assign"' "Update"' "list"' "Constant"' "Function"' "Grant"' "Grant role"' "Alter"'                                      "Read"' "Identity"' "Check"' "Constraint"' "value constraint"' "auto increment"'                                      "generated"' "always"' "Domain"' "is null"' "is active_role"' "start with"' "reindex"'                                      "cursor"' "alias"' "push_namespace"' "pop_namespace"' "set_namespace"' "coalesce"'                                      "nod_nullif"' "case"' "case_search"' "add"' "subtract"' "multiply"' "divide"' "modulus"'                                      "negate"' "plus"' "cast"' "concatenation"' "create user"' "drop user"' "create role"'                                      "upgrade role"' "drop role"' "revoke"' "revoke role"' "assume"' "revert"' "negate"'                                      "priv insert"' "priv delete"' "priv execute"' "priv select"' "priv update"' "priv grant"'                                      "priv all"' "characters"' "octets"' "role"' "view"' "procedure"' "user"' "zone"' "admin"'                                      "default role"' "create sequence"' "upgrade sequence"' "drop sequence"' "next value"'                                      "create trigger"' "upgrade trigger"' "alter trigger"' "drop trigger"' "create procedure"'                                      "upgrade procedure"' "alter procedure"' "drop procedure"' "pre-insert"' "post-insert"'                                      "pre-update"' "post-update"' "pre-delete"' "post-delete"' "pre-commit"' "post-commit"'                                      "active"' "inactive"' "position"' "select-expr"' "create filterset"' "upgrade filterset"'                                      "drop filterset"' "enable filterset"' "disable filterset"' "table filter"' "left outer"'                                      "right outer"' "full outer"' "inner"' "join"' "join_term"' "trigger class"' "enable trigger class"'                                      "disable trigger class"' "create zone"' "upgrade zone"' "drop zone"' "range"' "ip address"'                                      "node_name"' "wildcard"' "create domain"' "upgrade domain"' "alter domain"' "upgrade schema"'                                      "delete cascade"' "index segment"' "for update"' "write committed"' "read committed"'                                       "consistent read"' "set dialect"' "set names"' "restrict"' "cascade"' "characters"' "octets"'                                      "create event"' "collate"' "truncate"' "restart"' "nameless constraint"' "drop constraint"'                                      "drop unique constraint"' "drop domain"' "with check option"' "not real"' "lower"' "upper"'                                      "substr"' "substring index"' "charlength"' "default keyword"' "sqrt"' "power"' "Scientific Notation Number"'                                      "Explain"' "msleep"' "KillStatement"' "now" };                  table.BeginLoadData();                  foreach (string keyword in words)                  {                      DataRow row = table.NewRow();                      row["ReservedWord"] = keyword;                      table.Rows.Add(row);                  }                  table.EndLoadData();                }              else if (collectionName == DbMetaDataCollectionNames.DataTypes)              {                  table.Columns.Add("TypeName"' typeof(string));  // The provider-specific data type name.                  table.Columns.Add("ProviderDbType"' typeof(int)); // The provider-specific type value that should be used when specifying                   //a parameter's type. For example' SqlDbType.Money or OracleType.Blob.                  table.Columns.Add("ColumnSize"' typeof(long));                  table.Columns.Add("CreateFormat"' typeof(string));                  table.Columns.Add("CreateParameters"' typeof(string));                  table.Columns.Add("DataType"' typeof(string));  // The name of the .NET Framework type of the data type.                  table.Columns.Add("IsAutoincrementable"' typeof(bool));                  table.Columns.Add("IsBestMatch"' typeof(bool));                  table.Columns.Add("IsCaseSensitive"' typeof(bool));                  table.Columns.Add("IsFixedLength"' typeof(bool));                  table.Columns.Add("IsFixedPrecisionScale"' typeof(bool));                  table.Columns.Add("IsLong"' typeof(bool));                  table.Columns.Add("IsNullable"' typeof(bool));                  table.Columns.Add("IsSearchable"' typeof(bool));                  table.Columns.Add("IsSearchableWithLike"' typeof(bool));                  table.Columns.Add("IsUnsigned"' typeof(bool));                  table.Columns.Add("MaximumScale"' typeof(short));                  table.Columns.Add("MinimumScale"' typeof(short));                  table.Columns.Add("IsConcurrencyType"' typeof(bool));                  table.Columns.Add("IsLiteralsSupported"' typeof(bool));                  table.Columns.Add("LiteralPrefix"' typeof(string));                  table.Columns.Add("LiteralSuffix"' typeof(string));                  table.Columns.Add("NativeDataType"' typeof(string));    // NativeDataType is an OLE DB specific column for exposing the OLE DB type of the data type .                    table.ReadXml(XmlReader.Create(typeof(NuoDbConnectionInternal).Assembly.GetManifestResourceStream("NuoDb.Data.Client.DataTypes.xml")));              }              else if (collectionName == "Tables")              {                  table.Columns.Add("TABLE_CATALOG"' typeof(string));                  table.Columns.Add("TABLE_SCHEMA"' typeof(string));                  table.Columns.Add("TABLE_NAME"' typeof(string));                  table.Columns.Add("TABLE_TYPE"' typeof(string));                  table.Columns.Add("REMARKS"' typeof(string));                  table.Columns.Add("VIEW_DEF"' typeof(string));                    tmConn.InternalConnection.dataStream.startMessage(Protocol.GetTables);                  tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                  for (int i = 1; i < 3; i++)                      if (restrictionValues != null && restrictionValues.Length > i)                          tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                      else                          tmConn.InternalConnection.dataStream.encodeNull();                  if (restrictionValues == null || restrictionValues.Length < 4 || restrictionValues[3] == null)                      tmConn.InternalConnection.dataStream.encodeInt(0);                  else                  {                      tmConn.InternalConnection.dataStream.encodeInt(1);                      tmConn.InternalConnection.dataStream.encodeString(restrictionValues[3]);                  }                    tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                  int handle = tmConn.InternalConnection.dataStream.getInt();                    if (handle != -1)                  {                      using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                      {                          table.BeginLoadData();                          string view_def_label="";                          try                           {                               reader.GetOrdinal("VIEW_DEF");                              view_def_label = "VIEW_DEF";                          }                          catch(Exception) {}                          try                           {                               reader.GetOrdinal("VIEWDEFINITION");                              view_def_label = "VIEWDEFINITION";                          }                          catch (Exception) { }                          while (reader.Read())                          {  #if DEBUG                          System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_NAME"] + "' " + reader["TABLE_TYPE"]);  #endif                              DataRow row = table.NewRow();                              row["TABLE_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                              row["TABLE_NAME"] = reader.GetFieldValue<string>("TABLE_NAME");                              row["TABLE_TYPE"] = reader.GetFieldValue<string>("TABLE_TYPE");                              row["REMARKS"] = reader.GetFieldValue<string>("REMARKS");                              if (view_def_label.Length != 0)                              {                                  row["VIEW_DEF"] = reader.GetFieldValue<string>(view_def_label);                              }                              table.Rows.Add(row);                          }                          table.EndLoadData();                      }                  }              }              else if (collectionName == "Columns")              {                  table.Columns.Add("COLUMN_CATALOG"' typeof(string));                  table.Columns.Add("COLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("COLUMN_TABLE"' typeof(string));                  table.Columns.Add("COLUMN_NAME"' typeof(string));                  table.Columns.Add("COLUMN_POSITION"' typeof(int));                  table.Columns.Add("COLUMN_TYPE"' typeof(string));                  table.Columns.Add("COLUMN_LENGTH"' typeof(int));                  table.Columns.Add("COLUMN_PRECISION"' typeof(int));                  table.Columns.Add("COLUMN_NULLABLE"' typeof(bool));                  table.Columns.Add("COLUMN_IDENTITY"' typeof(bool));                  table.Columns.Add("COLUMN_DEFAULT"' typeof(string));                  table.Columns.Add("COLUMN_SCALE"' typeof(int));                    tmConn.InternalConnection.dataStream.startMessage(Protocol.GetColumns);                  tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                  for (int i = 1; i < 4; i++)                      if (restrictionValues != null && restrictionValues.Length > i)                          tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                      else                          tmConn.InternalConnection.dataStream.encodeNull();                    tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                  int handle = tmConn.InternalConnection.dataStream.getInt();                    if (handle != -1)                  {                      using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                      {                          table.BeginLoadData();                          while (reader.Read())                          {                              DataRow row = table.NewRow();                              row["COLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                              row["COLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                              row["COLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                              row["COLUMN_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                              row["COLUMN_LENGTH"] = reader.GetFieldValue<int>("COLUMN_SIZE");                              row["COLUMN_PRECISION"] = reader.GetFieldValue<int>("BUFFER_LENGTH");                              row["COLUMN_SCALE"] = reader.GetFieldValue<int>("DECIMAL_DIGITS");                              if (isNumeric(reader.GetFieldValue<string>("TYPE_NAME")))                              {                                  if (reader.GetFieldValue<int>("DECIMAL_DIGITS") != 0)                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME") +                                           "(" + reader.GetFieldValue<int>("BUFFER_LENGTH") + "'" + reader.GetFieldValue<int>("DECIMAL_DIGITS") + ")";                                  else                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME");                              }                              else                              {                                  if (isVarLenType(reader.GetFieldValue<string>("TYPE_NAME")) && reader.GetFieldValue<int>("COLUMN_SIZE") != 0)                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME") +                                           "(" + reader.GetFieldValue<int>("COLUMN_SIZE") + ")";                                  else                                      row["COLUMN_TYPE"] = reader.GetFieldValue<string>("TYPE_NAME");                              }                              if (!reader.IsDBNull(reader.GetOrdinal("IS_NULLABLE")))                                  row["COLUMN_NULLABLE"] = reader.GetFieldValue<string>("IS_NULLABLE").Equals("YES");                              if (!reader.IsDBNull(reader.GetOrdinal("IS_AUTOINCREMENT")))                                  row["COLUMN_IDENTITY"] = reader.GetFieldValue<string>("IS_AUTOINCREMENT").Equals("YES");                              row["COLUMN_DEFAULT"] = reader.GetFieldValue<string>("COLUMN_DEF");    #if DEBUG                              System.Diagnostics.Trace.WriteLine("-> " + row["COLUMN_NAME"] + " " + row["COLUMN_TYPE"]);  #endif                              table.Rows.Add(row);                          }                          table.EndLoadData();                      }                  }              }              else if (collectionName == "Indexes")              {                  table.Columns.Add("INDEX_CATALOG"' typeof(string));                  table.Columns.Add("INDEX_SCHEMA"' typeof(string));                  table.Columns.Add("INDEX_TABLE"' typeof(string));                  table.Columns.Add("INDEX_NAME"' typeof(string));                  table.Columns.Add("INDEX_TYPE"' typeof(string));                  table.Columns.Add("INDEX_UNIQUE"' typeof(bool));                  table.Columns.Add("INDEX_PRIMARY"' typeof(bool));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetIndexInfo);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // unique                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // approximate                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        // to avoid to insert the same index more than once                      HashSet<string> unique = new HashSet<string>();                      if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;                                  if (!unique.Add(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;                                  DataRow row = table.NewRow();                                  row["INDEX_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEX_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEX_NAME"] = reader.GetFieldValue<string>("INDEX_NAME");                                  switch (reader.GetFieldValue<int>("TYPE"))                                  {                                      case 0:                                          row["INDEX_TYPE"] = "Primary";                                          break;                                      case 1:                                          row["INDEX_TYPE"] = "Unique";                                          break;                                      case 2:                                          row["INDEX_TYPE"] = "Secondary";                                          break;                                      case 3:                                          row["INDEX_TYPE"] = "Foreign Key";                                          break;                                  }                                  row["INDEX_UNIQUE"] = (reader.GetFieldValue<int>("NON_UNIQUE") == 0) ? true : false;                                  row["INDEX_PRIMARY"] = (reader.GetFieldValue<int>("TYPE") == 0) ? true : false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                        tmConn.InternalConnection.dataStream.startMessage(Protocol.GetPrimaryKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              // use INDEX_NAME' if present; if missing' the name of the index is in PK_NAME                              string indexName = "PK_NAME";                              foreach (string column in reader.columnNames)                              {                                  if (column == "INDEX_NAME")                                  {                                      indexName = "INDEX_NAME";                                      break;                                  }                              }                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>(indexName)))                                      continue;                                  if (!unique.Add(reader.GetFieldValue<string>(indexName)))                                      continue;                                  DataRow row = table.NewRow();                                  row["INDEX_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEX_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEX_NAME"] = reader.GetFieldValue<string>(indexName);                                  row["INDEX_TYPE"] = "Primary";                                  row["INDEX_UNIQUE"] = true;                                  row["INDEX_PRIMARY"] = true;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "IndexColumns")              {                  table.Columns.Add("INDEXCOLUMN_CATALOG"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_TABLE"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_INDEX"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_NAME"' typeof(string));                  table.Columns.Add("INDEXCOLUMN_POSITION"' typeof(int));                  table.Columns.Add("INDEXCOLUMN_ISPRIMARY"' typeof(bool));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetIndexInfo);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // unique                      tmConn.InternalConnection.dataStream.encodeBoolean(false);    // approximate                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>("INDEX_NAME")))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_SCHEM"] + "." + reader["TABLE_NAME"] + "=" + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["INDEXCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEXCOLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEXCOLUMN_INDEX"] = reader.GetFieldValue<string>("INDEX_NAME");                                  row["INDEXCOLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["INDEXCOLUMN_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                                  row["INDEXCOLUMN_ISPRIMARY"] = false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                        tmConn.InternalConnection.dataStream.startMessage(Protocol.GetPrimaryKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              // use INDEX_NAME' if present; if missing' the name of the index is in PK_NAME                              string indexName = "PK_NAME";                              foreach (string column in reader.columnNames)                              {                                  if (column == "INDEX_NAME")                                  {                                      indexName = "INDEX_NAME";                                      break;                                  }                              }                              table.BeginLoadData();                              while (reader.Read())                              {                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(reader.GetFieldValue<string>(indexName)))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["TABLE_SCHEM"] + "." + reader["TABLE_NAME"] + " (Primary) =" + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["INDEXCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("TABLE_SCHEM");                                  row["INDEXCOLUMN_TABLE"] = reader.GetFieldValue<string>("TABLE_NAME");                                  row["INDEXCOLUMN_INDEX"] = reader.GetFieldValue<string>(indexName);                                  row["INDEXCOLUMN_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["INDEXCOLUMN_POSITION"] = reader.GetFieldValue<int>("KEY_SEQ");                                  row["INDEXCOLUMN_ISPRIMARY"] = true;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ForeignKeys")              {                  table.Columns.Add("FOREIGNKEY_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEY_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEY_TABLE"' typeof(string));                  table.Columns.Add("FOREIGNKEY_NAME"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEY_OTHER_TABLE"' typeof(string));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetImportedKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  string name = "[" + reader.GetFieldValue<string>("FKTABLE_SCHEM") + "]" +                                                   reader.GetFieldValue<string>("FKTABLE_NAME") + "." +                                                   reader.GetFieldValue<string>("FKCOLUMN_NAME") + "->" +                                                  "[" + reader.GetFieldValue<string>("PKTABLE_SCHEM") + "]" +                                                   reader.GetFieldValue<string>("PKTABLE_NAME") + "." +                                                   reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(name))                                      continue;                                  DataRow row = table.NewRow();                                  row["FOREIGNKEY_SCHEMA"] = reader.GetFieldValue<string>("FKTABLE_SCHEM");                                  row["FOREIGNKEY_TABLE"] = reader.GetFieldValue<string>("FKTABLE_NAME");                                  row["FOREIGNKEY_NAME"] = name;                                  row["FOREIGNKEY_OTHER_SCHEMA"] = reader.GetFieldValue<string>("PKTABLE_SCHEM");                                  row["FOREIGNKEY_OTHER_TABLE"] = reader.GetFieldValue<string>("PKTABLE_NAME");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ForeignKeyColumns")              {                  table.Columns.Add("FOREIGNKEYCOLUMN_CATALOG"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_SCHEMA"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_TABLE"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_KEY"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_NAME"' typeof(string));                  table.Columns.Add("FOREIGNKEYCOLUMN_ORDINAL"' typeof(int));                  table.Columns.Add("FOREIGNKEYCOLUMN_OTHER_COLUMN_NAME"' typeof(string));                    List<KeyValuePair<string' string>> tables = RetrieveMatchingTables(tmConn' getItemAtIndex(restrictionValues' 1)' getItemAtIndex(restrictionValues' 2));                    foreach (KeyValuePair<string' string> t in tables)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetImportedKeys);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      tmConn.InternalConnection.dataStream.encodeString(t.Key);                      tmConn.InternalConnection.dataStream.encodeString(t.Value);                      tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {                                  string name = "[" + reader.GetFieldValue<string>("FKTABLE_SCHEM") + "]" +                                                  reader.GetFieldValue<string>("FKTABLE_NAME") + "." +                                                  reader.GetFieldValue<string>("FKCOLUMN_NAME") + "->" +                                                  "[" + reader.GetFieldValue<string>("PKTABLE_SCHEM") + "]" +                                                  reader.GetFieldValue<string>("PKTABLE_NAME") + "." +                                                  reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  // enforce the restriction on the index name                                  if (restrictionValues != null && restrictionValues.Length > 3 && restrictionValues[3] != null &&                                      !restrictionValues[3].Equals(name))                                      continue;  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["FKTABLE_SCHEM"] + "." + reader["FKTABLE_NAME"] + "=" + reader["FKCOLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["FOREIGNKEYCOLUMN_SCHEMA"] = reader.GetFieldValue<string>("FKTABLE_SCHEM");                                  row["FOREIGNKEYCOLUMN_TABLE"] = reader.GetFieldValue<string>("FKTABLE_NAME");                                  row["FOREIGNKEYCOLUMN_KEY"] = name;                                  row["FOREIGNKEYCOLUMN_NAME"] = reader.GetFieldValue<string>("FKCOLUMN_NAME");                                  row["FOREIGNKEYCOLUMN_ORDINAL"] = reader.GetFieldValue<int>("KEY_SEQ");                                  row["FOREIGNKEYCOLUMN_OTHER_COLUMN_NAME"] = reader.GetFieldValue<string>("PKCOLUMN_NAME");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "Procedures")               {                  table.Columns.Add("PROCEDURE_CATALOG"' typeof(string));                  table.Columns.Add("PROCEDURE_SCHEMA"' typeof(string));                  table.Columns.Add("PROCEDURE_NAME"' typeof(string));                  table.Columns.Add("IS_SYSTEM_PROCEDURE"' typeof(bool));                    if (tmConn.InternalConnection.protocolVersion >= Protocol.PROTOCOL_VERSION12)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetProcedures);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      for (int i = 1; i < 3; i++)                          if (restrictionValues != null && restrictionValues.Length > i)                              tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                          else                              tmConn.InternalConnection.dataStream.encodeNull();                        tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["PROCEDURE_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["PROCEDURE_SCHEMA"] = reader.GetFieldValue<string>("PROCEDURE_SCHEM");                                  row["PROCEDURE_NAME"] = reader.GetFieldValue<string>("PROCEDURE_NAME");                                  row["IS_SYSTEM_PROCEDURE"] = false;                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }              else if (collectionName == "ProcedureParameters")              {                  table.Columns.Add("PROCEDURE_CATALOG"' typeof(string));                  table.Columns.Add("PROCEDURE_SCHEMA"' typeof(string));                  table.Columns.Add("PROCEDURE_NAME"' typeof(string));                  table.Columns.Add("PARAMETER_NAME"' typeof(string));                  table.Columns.Add("ORDINAL_POSITION"' typeof(int));                  table.Columns.Add("PARAMETER_DATA_TYPE"' typeof(int));                  table.Columns.Add("PARAMETER_TYPE_NAME"' typeof(string));                  table.Columns.Add("PARAMETER_SIZE"' typeof(int));                  table.Columns.Add("NUMERIC_PRECISION"' typeof(int));                  table.Columns.Add("NUMERIC_SCALE"' typeof(int));                  table.Columns.Add("PARAMETER_DIRECTION"' typeof(int));                  table.Columns.Add("IS_NULLABLE"' typeof(bool));                    if (tmConn.InternalConnection.protocolVersion >= Protocol.PROTOCOL_VERSION12)                  {                      tmConn.InternalConnection.dataStream.startMessage(Protocol.GetProcedureColumns);                      tmConn.InternalConnection.dataStream.encodeNull(); // catalog is always null                      for (int i = 1; i < 4; i++)                          if (restrictionValues != null && restrictionValues.Length > i)                              tmConn.InternalConnection.dataStream.encodeString(restrictionValues[i]);                          else                              tmConn.InternalConnection.dataStream.encodeNull();                        tmConn.InternalConnection.sendAndReceive(tmConn.InternalConnection.dataStream);                      int handle = tmConn.InternalConnection.dataStream.getInt();                        if (handle != -1)                      {                          using (NuoDbDataReader reader = new NuoDbDataReader(tmConn' handle' tmConn.InternalConnection.dataStream' null' true))                          {                              table.BeginLoadData();                              while (reader.Read())                              {  #if DEBUG                                  System.Diagnostics.Trace.WriteLine("-> " + reader["PROCEDURE_NAME"] + "' " + reader["COLUMN_NAME"]);  #endif                                  DataRow row = table.NewRow();                                  row["PROCEDURE_SCHEMA"] = reader.GetFieldValue<string>("PROCEDURE_SCHEM");                                  row["PROCEDURE_NAME"] = reader.GetFieldValue<string>("PROCEDURE_NAME");                                  row["PARAMETER_NAME"] = reader.GetFieldValue<string>("COLUMN_NAME");                                  row["ORDINAL_POSITION"] = reader.GetFieldValue<int>("ORDINAL_POSITION");                                  row["PARAMETER_TYPE_NAME"] = reader.GetFieldValue<string>("TYPE_NAME");                                  row["PARAMETER_DATA_TYPE"] = reader.GetFieldValue<int>("DATA_TYPE");                                  row["PARAMETER_SIZE"] = reader.GetFieldValue<int>("LENGTH");                                  row["NUMERIC_PRECISION"] = reader.GetFieldValue<int>("PRECISION");                                  row["NUMERIC_SCALE"] = reader.GetFieldValue<int>("SCALE");                                  row["PARAMETER_DIRECTION"] = reader.GetFieldValue<int>("COLUMN_TYPE");                                  row["IS_NULLABLE"] = !reader.GetFieldValue<string>("IS_NULLABLE").Equals("NO");                                  table.Rows.Add(row);                              }                              table.EndLoadData();                          }                      }                  }              }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapJavaSqlToDbType,The following statement contains a magic number: switch (jSQL)              {                  case -7: //BIT                      return DbType.Boolean;                  case -6: //TINYINT                  case 5: //SMALLINT                  case 4: //INTEGER                      return DbType.Int32;                  case -5: //BIGINT                      return DbType.Int64;                  case 6: //FLOAT                  case 7: //REAL                      return DbType.Single;                  case 8: //DOUBLE                      return DbType.Double;                  case 2: //NUMERIC                  case 3: //DECIMAL                      return DbType.Decimal;                  case 1: //CHAR                  case 12: //VARCHAR                  case -1: //LONGVARCHAR                      return DbType.String;                  case 91: //DATE                      return DbType.Date;                  case 92: //TIME                      return DbType.Time;                  case 93: //TIMESTAMP                      return DbType.DateTime;                  case -2: //BINARY                  case -3: //VARBINARY                  case -4: //LONGVARBINARY                      return DbType.Binary;                  case 0: //NULL                  case 1111: //OTHER                  case 2000: //JAVA_OBJECT                  case 2001: //DISTINCT                  case 2002: //STRUCT                  case 2003: //ARRAY                  case 2004: //BLOB                  case 2005: //CLOB                  case 2006: //REF                  case 70: //DATALINK                      return DbType.Object;                  case 16: //BOOLEAN                      return DbType.Boolean;                  //------------------------- JDBC 4.0 -----------------------------------                  case -15: //NCHAR                  case -9: //NVARCHAR                   case -16: //LONGNVARCHAR                  case 2011: //NCLOB                      return DbType.String;                  case 2009: //SQLXML                       return DbType.Xml;                  case -8: //ROWID                      return DbType.Object;              }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapJavaSqlToDbType,The following statement contains a magic number: switch (jSQL)              {                  case -7: //BIT                      return DbType.Boolean;                  case -6: //TINYINT                  case 5: //SMALLINT                  case 4: //INTEGER                      return DbType.Int32;                  case -5: //BIGINT                      return DbType.Int64;                  case 6: //FLOAT                  case 7: //REAL                      return DbType.Single;                  case 8: //DOUBLE                      return DbType.Double;                  case 2: //NUMERIC                  case 3: //DECIMAL                      return DbType.Decimal;                  case 1: //CHAR                  case 12: //VARCHAR                  case -1: //LONGVARCHAR                      return DbType.String;                  case 91: //DATE                      return DbType.Date;                  case 92: //TIME                      return DbType.Time;                  case 93: //TIMESTAMP                      return DbType.DateTime;                  case -2: //BINARY                  case -3: //VARBINARY                  case -4: //LONGVARBINARY                      return DbType.Binary;                  case 0: //NULL                  case 1111: //OTHER                  case 2000: //JAVA_OBJECT                  case 2001: //DISTINCT                  case 2002: //STRUCT                  case 2003: //ARRAY                  case 2004: //BLOB                  case 2005: //CLOB                  case 2006: //REF                  case 70: //DATALINK                      return DbType.Object;                  case 16: //BOOLEAN                      return DbType.Boolean;                  //------------------------- JDBC 4.0 -----------------------------------                  case -15: //NCHAR                  case -9: //NVARCHAR                   case -16: //LONGNVARCHAR                  case 2011: //NCLOB                      return DbType.String;                  case 2009: //SQLXML                       return DbType.Xml;                  case -8: //ROWID                      return DbType.Object;              }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapJavaSqlToDbType,The following statement contains a magic number: switch (jSQL)              {                  case -7: //BIT                      return DbType.Boolean;                  case -6: //TINYINT                  case 5: //SMALLINT                  case 4: //INTEGER                      return DbType.Int32;                  case -5: //BIGINT                      return DbType.Int64;                  case 6: //FLOAT                  case 7: //REAL                      return DbType.Single;                  case 8: //DOUBLE                      return DbType.Double;                  case 2: //NUMERIC                  case 3: //DECIMAL                      return DbType.Decimal;                  case 1: //CHAR                  case 12: //VARCHAR                  case -1: //LONGVARCHAR                      return DbType.String;                  case 91: //DATE                      return DbType.Date;                  case 92: //TIME                      return DbType.Time;                  case 93: //TIMESTAMP                      return DbType.DateTime;                  case -2: //BINARY                  case -3: //VARBINARY                  case -4: //LONGVARBINARY                      return DbType.Binary;                  case 0: //NULL                  case 1111: //OTHER                  case 2000: //JAVA_OBJECT                  case 2001: //DISTINCT                  case 2002: //STRUCT                  case 2003: //ARRAY                  case 2004: //BLOB                  case 2005: //CLOB                  case 2006: //REF                  case 70: //DATALINK                      return DbType.Object;                  case 16: //BOOLEAN                      return DbType.Boolean;                  //------------------------- JDBC 4.0 -----------------------------------                  case -15: //NCHAR                  case -9: //NVARCHAR                   case -16: //LONGNVARCHAR                  case 2011: //NCLOB                      return DbType.String;                  case 2009: //SQLXML                       return DbType.Xml;                  case -8: //ROWID                      return DbType.Object;              }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapJavaSqlToDbType,The following statement contains a magic number: switch (jSQL)              {                  case -7: //BIT                      return DbType.Boolean;                  case -6: //TINYINT                  case 5: //SMALLINT                  case 4: //INTEGER                      return DbType.Int32;                  case -5: //BIGINT                      return DbType.Int64;                  case 6: //FLOAT                  case 7: //REAL                      return DbType.Single;                  case 8: //DOUBLE                      return DbType.Double;                  case 2: //NUMERIC                  case 3: //DECIMAL                      return DbType.Decimal;                  case 1: //CHAR                  case 12: //VARCHAR                  case -1: //LONGVARCHAR                      return DbType.String;                  case 91: //DATE                      return DbType.Date;                  case 92: //TIME                      return DbType.Time;                  case 93: //TIMESTAMP                      return DbType.DateTime;                  case -2: //BINARY                  case -3: //VARBINARY                  case -4: //LONGVARBINARY                      return DbType.Binary;                  case 0: //NULL                  case 1111: //OTHER                  case 2000: //JAVA_OBJECT                  case 2001: //DISTINCT                  case 2002: //STRUCT                  case 2003: //ARRAY                  case 2004: //BLOB                  case 2005: //CLOB                  case 2006: //REF                  case 70: //DATALINK                      return DbType.Object;                  case 16: //BOOLEAN                      return DbType.Boolean;                  //------------------------- JDBC 4.0 -----------------------------------                  case -15: //NCHAR                  case -9: //NVARCHAR                   case -16: //LONGNVARCHAR                  case 2011: //NCLOB                      return DbType.String;                  case 2009: //SQLXML                       return DbType.Xml;                  case -8: //ROWID                      return DbType.Object;              }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapJavaSqlToDbType,The following statement contains a magic number: switch (jSQL)              {                  case -7: //BIT                      return DbType.Boolean;                  case -6: //TINYINT                  case 5: //SMALLINT                  case 4: //INTEGER                      return DbType.Int32;                  case -5: //BIGINT                      return DbType.Int64;                  case 6: //FLOAT                  case 7: //REAL                      return DbType.Single;                  case 8: //DOUBLE                      return DbType.Double;                  case 2: //NUMERIC                  case 3: //DECIMAL                      return DbType.Decimal;                  case 1: //CHAR                  case 12: //VARCHAR                  case -1: //LONGVARCHAR                      return DbType.String;                  case 91: //DATE                      return DbType.Date;                  case 92: //TIME                      return DbType.Time;                  case 93: //TIMESTAMP                      return DbType.DateTime;                  case -2: //BINARY                  case -3: //VARBINARY                  case -4: //LONGVARBINARY                      return DbType.Binary;                  case 0: //NULL                  case 1111: //OTHER                  case 2000: //JAVA_OBJECT                  case 2001: //DISTINCT                  case 2002: //STRUCT                  case 2003: //ARRAY                  case 2004: //BLOB                  case 2005: //CLOB                  case 2006: //REF                  case 70: //DATALINK                      return DbType.Object;                  case 16: //BOOLEAN                      return DbType.Boolean;                  //------------------------- JDBC 4.0 -----------------------------------                  case -15: //NCHAR                  case -9: //NVARCHAR                   case -16: //LONGNVARCHAR                  case 2011: //NCLOB                      return DbType.String;                  case 2009: //SQLXML                       return DbType.Xml;                  case -8: //ROWID                      return DbType.Object;              }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapJavaSqlToDbType,The following statement contains a magic number: switch (jSQL)              {                  case -7: //BIT                      return DbType.Boolean;                  case -6: //TINYINT                  case 5: //SMALLINT                  case 4: //INTEGER                      return DbType.Int32;                  case -5: //BIGINT                      return DbType.Int64;                  case 6: //FLOAT                  case 7: //REAL                      return DbType.Single;                  case 8: //DOUBLE                      return DbType.Double;                  case 2: //NUMERIC                  case 3: //DECIMAL                      return DbType.Decimal;                  case 1: //CHAR                  case 12: //VARCHAR                  case -1: //LONGVARCHAR                      return DbType.String;                  case 91: //DATE                      return DbType.Date;                  case 92: //TIME                      return DbType.Time;                  case 93: //TIMESTAMP                      return DbType.DateTime;                  case -2: //BINARY                  case -3: //VARBINARY                  case -4: //LONGVARBINARY                      return DbType.Binary;                  case 0: //NULL                  case 1111: //OTHER                  case 2000: //JAVA_OBJECT                  case 2001: //DISTINCT                  case 2002: //STRUCT                  case 2003: //ARRAY                  case 2004: //BLOB                  case 2005: //CLOB                  case 2006: //REF                  case 70: //DATALINK                      return DbType.Object;                  case 16: //BOOLEAN                      return DbType.Boolean;                  //------------------------- JDBC 4.0 -----------------------------------                  case -15: //NCHAR                  case -9: //NVARCHAR                   case -16: //LONGNVARCHAR                  case 2011: //NCLOB                      return DbType.String;                  case 2009: //SQLXML                       return DbType.Xml;                  case -8: //ROWID                      return DbType.Object;              }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapJavaSqlToDbType,The following statement contains a magic number: switch (jSQL)              {                  case -7: //BIT                      return DbType.Boolean;                  case -6: //TINYINT                  case 5: //SMALLINT                  case 4: //INTEGER                      return DbType.Int32;                  case -5: //BIGINT                      return DbType.Int64;                  case 6: //FLOAT                  case 7: //REAL                      return DbType.Single;                  case 8: //DOUBLE                      return DbType.Double;                  case 2: //NUMERIC                  case 3: //DECIMAL                      return DbType.Decimal;                  case 1: //CHAR                  case 12: //VARCHAR                  case -1: //LONGVARCHAR                      return DbType.String;                  case 91: //DATE                      return DbType.Date;                  case 92: //TIME                      return DbType.Time;                  case 93: //TIMESTAMP                      return DbType.DateTime;                  case -2: //BINARY                  case -3: //VARBINARY                  case -4: //LONGVARBINARY                      return DbType.Binary;                  case 0: //NULL                  case 1111: //OTHER                  case 2000: //JAVA_OBJECT                  case 2001: //DISTINCT                  case 2002: //STRUCT                  case 2003: //ARRAY                  case 2004: //BLOB                  case 2005: //CLOB                  case 2006: //REF                  case 70: //DATALINK                      return DbType.Object;                  case 16: //BOOLEAN                      return DbType.Boolean;                  //------------------------- JDBC 4.0 -----------------------------------                  case -15: //NCHAR                  case -9: //NVARCHAR                   case -16: //LONGNVARCHAR                  case 2011: //NCLOB                      return DbType.String;                  case 2009: //SQLXML                       return DbType.Xml;                  case -8: //ROWID                      return DbType.Object;              }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapJavaSqlToDbType,The following statement contains a magic number: switch (jSQL)              {                  case -7: //BIT                      return DbType.Boolean;                  case -6: //TINYINT                  case 5: //SMALLINT                  case 4: //INTEGER                      return DbType.Int32;                  case -5: //BIGINT                      return DbType.Int64;                  case 6: //FLOAT                  case 7: //REAL                      return DbType.Single;                  case 8: //DOUBLE                      return DbType.Double;                  case 2: //NUMERIC                  case 3: //DECIMAL                      return DbType.Decimal;                  case 1: //CHAR                  case 12: //VARCHAR                  case -1: //LONGVARCHAR                      return DbType.String;                  case 91: //DATE                      return DbType.Date;                  case 92: //TIME                      return DbType.Time;                  case 93: //TIMESTAMP                      return DbType.DateTime;                  case -2: //BINARY                  case -3: //VARBINARY                  case -4: //LONGVARBINARY                      return DbType.Binary;                  case 0: //NULL                  case 1111: //OTHER                  case 2000: //JAVA_OBJECT                  case 2001: //DISTINCT                  case 2002: //STRUCT                  case 2003: //ARRAY                  case 2004: //BLOB                  case 2005: //CLOB                  case 2006: //REF                  case 70: //DATALINK                      return DbType.Object;                  case 16: //BOOLEAN                      return DbType.Boolean;                  //------------------------- JDBC 4.0 -----------------------------------                  case -15: //NCHAR                  case -9: //NVARCHAR                   case -16: //LONGNVARCHAR                  case 2011: //NCLOB                      return DbType.String;                  case 2009: //SQLXML                       return DbType.Xml;                  case -8: //ROWID                      return DbType.Object;              }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapJavaSqlToDbType,The following statement contains a magic number: switch (jSQL)              {                  case -7: //BIT                      return DbType.Boolean;                  case -6: //TINYINT                  case 5: //SMALLINT                  case 4: //INTEGER                      return DbType.Int32;                  case -5: //BIGINT                      return DbType.Int64;                  case 6: //FLOAT                  case 7: //REAL                      return DbType.Single;                  case 8: //DOUBLE                      return DbType.Double;                  case 2: //NUMERIC                  case 3: //DECIMAL                      return DbType.Decimal;                  case 1: //CHAR                  case 12: //VARCHAR                  case -1: //LONGVARCHAR                      return DbType.String;                  case 91: //DATE                      return DbType.Date;                  case 92: //TIME                      return DbType.Time;                  case 93: //TIMESTAMP                      return DbType.DateTime;                  case -2: //BINARY                  case -3: //VARBINARY                  case -4: //LONGVARBINARY                      return DbType.Binary;                  case 0: //NULL                  case 1111: //OTHER                  case 2000: //JAVA_OBJECT                  case 2001: //DISTINCT                  case 2002: //STRUCT                  case 2003: //ARRAY                  case 2004: //BLOB                  case 2005: //CLOB                  case 2006: //REF                  case 70: //DATALINK                      return DbType.Object;                  case 16: //BOOLEAN                      return DbType.Boolean;                  //------------------------- JDBC 4.0 -----------------------------------                  case -15: //NCHAR                  case -9: //NVARCHAR                   case -16: //LONGNVARCHAR                  case 2011: //NCLOB                      return DbType.String;                  case 2009: //SQLXML                       return DbType.Xml;                  case -8: //ROWID                      return DbType.Object;              }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapJavaSqlToDbType,The following statement contains a magic number: switch (jSQL)              {                  case -7: //BIT                      return DbType.Boolean;                  case -6: //TINYINT                  case 5: //SMALLINT                  case 4: //INTEGER                      return DbType.Int32;                  case -5: //BIGINT                      return DbType.Int64;                  case 6: //FLOAT                  case 7: //REAL                      return DbType.Single;                  case 8: //DOUBLE                      return DbType.Double;                  case 2: //NUMERIC                  case 3: //DECIMAL                      return DbType.Decimal;                  case 1: //CHAR                  case 12: //VARCHAR                  case -1: //LONGVARCHAR                      return DbType.String;                  case 91: //DATE                      return DbType.Date;                  case 92: //TIME                      return DbType.Time;                  case 93: //TIMESTAMP                      return DbType.DateTime;                  case -2: //BINARY                  case -3: //VARBINARY                  case -4: //LONGVARBINARY                      return DbType.Binary;                  case 0: //NULL                  case 1111: //OTHER                  case 2000: //JAVA_OBJECT                  case 2001: //DISTINCT                  case 2002: //STRUCT                  case 2003: //ARRAY                  case 2004: //BLOB                  case 2005: //CLOB                  case 2006: //REF                  case 70: //DATALINK                      return DbType.Object;                  case 16: //BOOLEAN                      return DbType.Boolean;                  //------------------------- JDBC 4.0 -----------------------------------                  case -15: //NCHAR                  case -9: //NVARCHAR                   case -16: //LONGNVARCHAR                  case 2011: //NCLOB                      return DbType.String;                  case 2009: //SQLXML                       return DbType.Xml;                  case -8: //ROWID                      return DbType.Object;              }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapJavaSqlToDbType,The following statement contains a magic number: switch (jSQL)              {                  case -7: //BIT                      return DbType.Boolean;                  case -6: //TINYINT                  case 5: //SMALLINT                  case 4: //INTEGER                      return DbType.Int32;                  case -5: //BIGINT                      return DbType.Int64;                  case 6: //FLOAT                  case 7: //REAL                      return DbType.Single;                  case 8: //DOUBLE                      return DbType.Double;                  case 2: //NUMERIC                  case 3: //DECIMAL                      return DbType.Decimal;                  case 1: //CHAR                  case 12: //VARCHAR                  case -1: //LONGVARCHAR                      return DbType.String;                  case 91: //DATE                      return DbType.Date;                  case 92: //TIME                      return DbType.Time;                  case 93: //TIMESTAMP                      return DbType.DateTime;                  case -2: //BINARY                  case -3: //VARBINARY                  case -4: //LONGVARBINARY                      return DbType.Binary;                  case 0: //NULL                  case 1111: //OTHER                  case 2000: //JAVA_OBJECT                  case 2001: //DISTINCT                  case 2002: //STRUCT                  case 2003: //ARRAY                  case 2004: //BLOB                  case 2005: //CLOB                  case 2006: //REF                  case 70: //DATALINK                      return DbType.Object;                  case 16: //BOOLEAN                      return DbType.Boolean;                  //------------------------- JDBC 4.0 -----------------------------------                  case -15: //NCHAR                  case -9: //NVARCHAR                   case -16: //LONGNVARCHAR                  case 2011: //NCLOB                      return DbType.String;                  case 2009: //SQLXML                       return DbType.Xml;                  case -8: //ROWID                      return DbType.Object;              }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapJavaSqlToDbType,The following statement contains a magic number: switch (jSQL)              {                  case -7: //BIT                      return DbType.Boolean;                  case -6: //TINYINT                  case 5: //SMALLINT                  case 4: //INTEGER                      return DbType.Int32;                  case -5: //BIGINT                      return DbType.Int64;                  case 6: //FLOAT                  case 7: //REAL                      return DbType.Single;                  case 8: //DOUBLE                      return DbType.Double;                  case 2: //NUMERIC                  case 3: //DECIMAL                      return DbType.Decimal;                  case 1: //CHAR                  case 12: //VARCHAR                  case -1: //LONGVARCHAR                      return DbType.String;                  case 91: //DATE                      return DbType.Date;                  case 92: //TIME                      return DbType.Time;                  case 93: //TIMESTAMP                      return DbType.DateTime;                  case -2: //BINARY                  case -3: //VARBINARY                  case -4: //LONGVARBINARY                      return DbType.Binary;                  case 0: //NULL                  case 1111: //OTHER                  case 2000: //JAVA_OBJECT                  case 2001: //DISTINCT                  case 2002: //STRUCT                  case 2003: //ARRAY                  case 2004: //BLOB                  case 2005: //CLOB                  case 2006: //REF                  case 70: //DATALINK                      return DbType.Object;                  case 16: //BOOLEAN                      return DbType.Boolean;                  //------------------------- JDBC 4.0 -----------------------------------                  case -15: //NCHAR                  case -9: //NVARCHAR                   case -16: //LONGNVARCHAR                  case 2011: //NCLOB                      return DbType.String;                  case 2009: //SQLXML                       return DbType.Xml;                  case -8: //ROWID                      return DbType.Object;              }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapJavaSqlToDbType,The following statement contains a magic number: switch (jSQL)              {                  case -7: //BIT                      return DbType.Boolean;                  case -6: //TINYINT                  case 5: //SMALLINT                  case 4: //INTEGER                      return DbType.Int32;                  case -5: //BIGINT                      return DbType.Int64;                  case 6: //FLOAT                  case 7: //REAL                      return DbType.Single;                  case 8: //DOUBLE                      return DbType.Double;                  case 2: //NUMERIC                  case 3: //DECIMAL                      return DbType.Decimal;                  case 1: //CHAR                  case 12: //VARCHAR                  case -1: //LONGVARCHAR                      return DbType.String;                  case 91: //DATE                      return DbType.Date;                  case 92: //TIME                      return DbType.Time;                  case 93: //TIMESTAMP                      return DbType.DateTime;                  case -2: //BINARY                  case -3: //VARBINARY                  case -4: //LONGVARBINARY                      return DbType.Binary;                  case 0: //NULL                  case 1111: //OTHER                  case 2000: //JAVA_OBJECT                  case 2001: //DISTINCT                  case 2002: //STRUCT                  case 2003: //ARRAY                  case 2004: //BLOB                  case 2005: //CLOB                  case 2006: //REF                  case 70: //DATALINK                      return DbType.Object;                  case 16: //BOOLEAN                      return DbType.Boolean;                  //------------------------- JDBC 4.0 -----------------------------------                  case -15: //NCHAR                  case -9: //NVARCHAR                   case -16: //LONGNVARCHAR                  case 2011: //NCLOB                      return DbType.String;                  case 2009: //SQLXML                       return DbType.Xml;                  case -8: //ROWID                      return DbType.Object;              }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapJavaSqlToDbType,The following statement contains a magic number: switch (jSQL)              {                  case -7: //BIT                      return DbType.Boolean;                  case -6: //TINYINT                  case 5: //SMALLINT                  case 4: //INTEGER                      return DbType.Int32;                  case -5: //BIGINT                      return DbType.Int64;                  case 6: //FLOAT                  case 7: //REAL                      return DbType.Single;                  case 8: //DOUBLE                      return DbType.Double;                  case 2: //NUMERIC                  case 3: //DECIMAL                      return DbType.Decimal;                  case 1: //CHAR                  case 12: //VARCHAR                  case -1: //LONGVARCHAR                      return DbType.String;                  case 91: //DATE                      return DbType.Date;                  case 92: //TIME                      return DbType.Time;                  case 93: //TIMESTAMP                      return DbType.DateTime;                  case -2: //BINARY                  case -3: //VARBINARY                  case -4: //LONGVARBINARY                      return DbType.Binary;                  case 0: //NULL                  case 1111: //OTHER                  case 2000: //JAVA_OBJECT                  case 2001: //DISTINCT                  case 2002: //STRUCT                  case 2003: //ARRAY                  case 2004: //BLOB                  case 2005: //CLOB                  case 2006: //REF                  case 70: //DATALINK                      return DbType.Object;                  case 16: //BOOLEAN                      return DbType.Boolean;                  //------------------------- JDBC 4.0 -----------------------------------                  case -15: //NCHAR                  case -9: //NVARCHAR                   case -16: //LONGNVARCHAR                  case 2011: //NCLOB                      return DbType.String;                  case 2009: //SQLXML                       return DbType.Xml;                  case -8: //ROWID                      return DbType.Object;              }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapJavaSqlToDbType,The following statement contains a magic number: switch (jSQL)              {                  case -7: //BIT                      return DbType.Boolean;                  case -6: //TINYINT                  case 5: //SMALLINT                  case 4: //INTEGER                      return DbType.Int32;                  case -5: //BIGINT                      return DbType.Int64;                  case 6: //FLOAT                  case 7: //REAL                      return DbType.Single;                  case 8: //DOUBLE                      return DbType.Double;                  case 2: //NUMERIC                  case 3: //DECIMAL                      return DbType.Decimal;                  case 1: //CHAR                  case 12: //VARCHAR                  case -1: //LONGVARCHAR                      return DbType.String;                  case 91: //DATE                      return DbType.Date;                  case 92: //TIME                      return DbType.Time;                  case 93: //TIMESTAMP                      return DbType.DateTime;                  case -2: //BINARY                  case -3: //VARBINARY                  case -4: //LONGVARBINARY                      return DbType.Binary;                  case 0: //NULL                  case 1111: //OTHER                  case 2000: //JAVA_OBJECT                  case 2001: //DISTINCT                  case 2002: //STRUCT                  case 2003: //ARRAY                  case 2004: //BLOB                  case 2005: //CLOB                  case 2006: //REF                  case 70: //DATALINK                      return DbType.Object;                  case 16: //BOOLEAN                      return DbType.Boolean;                  //------------------------- JDBC 4.0 -----------------------------------                  case -15: //NCHAR                  case -9: //NVARCHAR                   case -16: //LONGNVARCHAR                  case 2011: //NCLOB                      return DbType.String;                  case 2009: //SQLXML                       return DbType.Xml;                  case -8: //ROWID                      return DbType.Object;              }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapJavaSqlToDbType,The following statement contains a magic number: switch (jSQL)              {                  case -7: //BIT                      return DbType.Boolean;                  case -6: //TINYINT                  case 5: //SMALLINT                  case 4: //INTEGER                      return DbType.Int32;                  case -5: //BIGINT                      return DbType.Int64;                  case 6: //FLOAT                  case 7: //REAL                      return DbType.Single;                  case 8: //DOUBLE                      return DbType.Double;                  case 2: //NUMERIC                  case 3: //DECIMAL                      return DbType.Decimal;                  case 1: //CHAR                  case 12: //VARCHAR                  case -1: //LONGVARCHAR                      return DbType.String;                  case 91: //DATE                      return DbType.Date;                  case 92: //TIME                      return DbType.Time;                  case 93: //TIMESTAMP                      return DbType.DateTime;                  case -2: //BINARY                  case -3: //VARBINARY                  case -4: //LONGVARBINARY                      return DbType.Binary;                  case 0: //NULL                  case 1111: //OTHER                  case 2000: //JAVA_OBJECT                  case 2001: //DISTINCT                  case 2002: //STRUCT                  case 2003: //ARRAY                  case 2004: //BLOB                  case 2005: //CLOB                  case 2006: //REF                  case 70: //DATALINK                      return DbType.Object;                  case 16: //BOOLEAN                      return DbType.Boolean;                  //------------------------- JDBC 4.0 -----------------------------------                  case -15: //NCHAR                  case -9: //NVARCHAR                   case -16: //LONGNVARCHAR                  case 2011: //NCLOB                      return DbType.String;                  case 2009: //SQLXML                       return DbType.Xml;                  case -8: //ROWID                      return DbType.Object;              }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapJavaSqlToDbType,The following statement contains a magic number: switch (jSQL)              {                  case -7: //BIT                      return DbType.Boolean;                  case -6: //TINYINT                  case 5: //SMALLINT                  case 4: //INTEGER                      return DbType.Int32;                  case -5: //BIGINT                      return DbType.Int64;                  case 6: //FLOAT                  case 7: //REAL                      return DbType.Single;                  case 8: //DOUBLE                      return DbType.Double;                  case 2: //NUMERIC                  case 3: //DECIMAL                      return DbType.Decimal;                  case 1: //CHAR                  case 12: //VARCHAR                  case -1: //LONGVARCHAR                      return DbType.String;                  case 91: //DATE                      return DbType.Date;                  case 92: //TIME                      return DbType.Time;                  case 93: //TIMESTAMP                      return DbType.DateTime;                  case -2: //BINARY                  case -3: //VARBINARY                  case -4: //LONGVARBINARY                      return DbType.Binary;                  case 0: //NULL                  case 1111: //OTHER                  case 2000: //JAVA_OBJECT                  case 2001: //DISTINCT                  case 2002: //STRUCT                  case 2003: //ARRAY                  case 2004: //BLOB                  case 2005: //CLOB                  case 2006: //REF                  case 70: //DATALINK                      return DbType.Object;                  case 16: //BOOLEAN                      return DbType.Boolean;                  //------------------------- JDBC 4.0 -----------------------------------                  case -15: //NCHAR                  case -9: //NVARCHAR                   case -16: //LONGNVARCHAR                  case 2011: //NCLOB                      return DbType.String;                  case 2009: //SQLXML                       return DbType.Xml;                  case -8: //ROWID                      return DbType.Object;              }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapJavaSqlToDbType,The following statement contains a magic number: switch (jSQL)              {                  case -7: //BIT                      return DbType.Boolean;                  case -6: //TINYINT                  case 5: //SMALLINT                  case 4: //INTEGER                      return DbType.Int32;                  case -5: //BIGINT                      return DbType.Int64;                  case 6: //FLOAT                  case 7: //REAL                      return DbType.Single;                  case 8: //DOUBLE                      return DbType.Double;                  case 2: //NUMERIC                  case 3: //DECIMAL                      return DbType.Decimal;                  case 1: //CHAR                  case 12: //VARCHAR                  case -1: //LONGVARCHAR                      return DbType.String;                  case 91: //DATE                      return DbType.Date;                  case 92: //TIME                      return DbType.Time;                  case 93: //TIMESTAMP                      return DbType.DateTime;                  case -2: //BINARY                  case -3: //VARBINARY                  case -4: //LONGVARBINARY                      return DbType.Binary;                  case 0: //NULL                  case 1111: //OTHER                  case 2000: //JAVA_OBJECT                  case 2001: //DISTINCT                  case 2002: //STRUCT                  case 2003: //ARRAY                  case 2004: //BLOB                  case 2005: //CLOB                  case 2006: //REF                  case 70: //DATALINK                      return DbType.Object;                  case 16: //BOOLEAN                      return DbType.Boolean;                  //------------------------- JDBC 4.0 -----------------------------------                  case -15: //NCHAR                  case -9: //NVARCHAR                   case -16: //LONGNVARCHAR                  case 2011: //NCLOB                      return DbType.String;                  case 2009: //SQLXML                       return DbType.Xml;                  case -8: //ROWID                      return DbType.Object;              }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapJavaSqlToDbType,The following statement contains a magic number: switch (jSQL)              {                  case -7: //BIT                      return DbType.Boolean;                  case -6: //TINYINT                  case 5: //SMALLINT                  case 4: //INTEGER                      return DbType.Int32;                  case -5: //BIGINT                      return DbType.Int64;                  case 6: //FLOAT                  case 7: //REAL                      return DbType.Single;                  case 8: //DOUBLE                      return DbType.Double;                  case 2: //NUMERIC                  case 3: //DECIMAL                      return DbType.Decimal;                  case 1: //CHAR                  case 12: //VARCHAR                  case -1: //LONGVARCHAR                      return DbType.String;                  case 91: //DATE                      return DbType.Date;                  case 92: //TIME                      return DbType.Time;                  case 93: //TIMESTAMP                      return DbType.DateTime;                  case -2: //BINARY                  case -3: //VARBINARY                  case -4: //LONGVARBINARY                      return DbType.Binary;                  case 0: //NULL                  case 1111: //OTHER                  case 2000: //JAVA_OBJECT                  case 2001: //DISTINCT                  case 2002: //STRUCT                  case 2003: //ARRAY                  case 2004: //BLOB                  case 2005: //CLOB                  case 2006: //REF                  case 70: //DATALINK                      return DbType.Object;                  case 16: //BOOLEAN                      return DbType.Boolean;                  //------------------------- JDBC 4.0 -----------------------------------                  case -15: //NCHAR                  case -9: //NVARCHAR                   case -16: //LONGNVARCHAR                  case 2011: //NCLOB                      return DbType.String;                  case 2009: //SQLXML                       return DbType.Xml;                  case -8: //ROWID                      return DbType.Object;              }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapJavaSqlToDbType,The following statement contains a magic number: switch (jSQL)              {                  case -7: //BIT                      return DbType.Boolean;                  case -6: //TINYINT                  case 5: //SMALLINT                  case 4: //INTEGER                      return DbType.Int32;                  case -5: //BIGINT                      return DbType.Int64;                  case 6: //FLOAT                  case 7: //REAL                      return DbType.Single;                  case 8: //DOUBLE                      return DbType.Double;                  case 2: //NUMERIC                  case 3: //DECIMAL                      return DbType.Decimal;                  case 1: //CHAR                  case 12: //VARCHAR                  case -1: //LONGVARCHAR                      return DbType.String;                  case 91: //DATE                      return DbType.Date;                  case 92: //TIME                      return DbType.Time;                  case 93: //TIMESTAMP                      return DbType.DateTime;                  case -2: //BINARY                  case -3: //VARBINARY                  case -4: //LONGVARBINARY                      return DbType.Binary;                  case 0: //NULL                  case 1111: //OTHER                  case 2000: //JAVA_OBJECT                  case 2001: //DISTINCT                  case 2002: //STRUCT                  case 2003: //ARRAY                  case 2004: //BLOB                  case 2005: //CLOB                  case 2006: //REF                  case 70: //DATALINK                      return DbType.Object;                  case 16: //BOOLEAN                      return DbType.Boolean;                  //------------------------- JDBC 4.0 -----------------------------------                  case -15: //NCHAR                  case -9: //NVARCHAR                   case -16: //LONGNVARCHAR                  case 2011: //NCLOB                      return DbType.String;                  case 2009: //SQLXML                       return DbType.Xml;                  case -8: //ROWID                      return DbType.Object;              }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapJavaSqlToDbType,The following statement contains a magic number: switch (jSQL)              {                  case -7: //BIT                      return DbType.Boolean;                  case -6: //TINYINT                  case 5: //SMALLINT                  case 4: //INTEGER                      return DbType.Int32;                  case -5: //BIGINT                      return DbType.Int64;                  case 6: //FLOAT                  case 7: //REAL                      return DbType.Single;                  case 8: //DOUBLE                      return DbType.Double;                  case 2: //NUMERIC                  case 3: //DECIMAL                      return DbType.Decimal;                  case 1: //CHAR                  case 12: //VARCHAR                  case -1: //LONGVARCHAR                      return DbType.String;                  case 91: //DATE                      return DbType.Date;                  case 92: //TIME                      return DbType.Time;                  case 93: //TIMESTAMP                      return DbType.DateTime;                  case -2: //BINARY                  case -3: //VARBINARY                  case -4: //LONGVARBINARY                      return DbType.Binary;                  case 0: //NULL                  case 1111: //OTHER                  case 2000: //JAVA_OBJECT                  case 2001: //DISTINCT                  case 2002: //STRUCT                  case 2003: //ARRAY                  case 2004: //BLOB                  case 2005: //CLOB                  case 2006: //REF                  case 70: //DATALINK                      return DbType.Object;                  case 16: //BOOLEAN                      return DbType.Boolean;                  //------------------------- JDBC 4.0 -----------------------------------                  case -15: //NCHAR                  case -9: //NVARCHAR                   case -16: //LONGNVARCHAR                  case 2011: //NCLOB                      return DbType.String;                  case 2009: //SQLXML                       return DbType.Xml;                  case -8: //ROWID                      return DbType.Object;              }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapJavaSqlToDbType,The following statement contains a magic number: switch (jSQL)              {                  case -7: //BIT                      return DbType.Boolean;                  case -6: //TINYINT                  case 5: //SMALLINT                  case 4: //INTEGER                      return DbType.Int32;                  case -5: //BIGINT                      return DbType.Int64;                  case 6: //FLOAT                  case 7: //REAL                      return DbType.Single;                  case 8: //DOUBLE                      return DbType.Double;                  case 2: //NUMERIC                  case 3: //DECIMAL                      return DbType.Decimal;                  case 1: //CHAR                  case 12: //VARCHAR                  case -1: //LONGVARCHAR                      return DbType.String;                  case 91: //DATE                      return DbType.Date;                  case 92: //TIME                      return DbType.Time;                  case 93: //TIMESTAMP                      return DbType.DateTime;                  case -2: //BINARY                  case -3: //VARBINARY                  case -4: //LONGVARBINARY                      return DbType.Binary;                  case 0: //NULL                  case 1111: //OTHER                  case 2000: //JAVA_OBJECT                  case 2001: //DISTINCT                  case 2002: //STRUCT                  case 2003: //ARRAY                  case 2004: //BLOB                  case 2005: //CLOB                  case 2006: //REF                  case 70: //DATALINK                      return DbType.Object;                  case 16: //BOOLEAN                      return DbType.Boolean;                  //------------------------- JDBC 4.0 -----------------------------------                  case -15: //NCHAR                  case -9: //NVARCHAR                   case -16: //LONGNVARCHAR                  case 2011: //NCLOB                      return DbType.String;                  case 2009: //SQLXML                       return DbType.Xml;                  case -8: //ROWID                      return DbType.Object;              }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapJavaSqlToDbType,The following statement contains a magic number: switch (jSQL)              {                  case -7: //BIT                      return DbType.Boolean;                  case -6: //TINYINT                  case 5: //SMALLINT                  case 4: //INTEGER                      return DbType.Int32;                  case -5: //BIGINT                      return DbType.Int64;                  case 6: //FLOAT                  case 7: //REAL                      return DbType.Single;                  case 8: //DOUBLE                      return DbType.Double;                  case 2: //NUMERIC                  case 3: //DECIMAL                      return DbType.Decimal;                  case 1: //CHAR                  case 12: //VARCHAR                  case -1: //LONGVARCHAR                      return DbType.String;                  case 91: //DATE                      return DbType.Date;                  case 92: //TIME                      return DbType.Time;                  case 93: //TIMESTAMP                      return DbType.DateTime;                  case -2: //BINARY                  case -3: //VARBINARY                  case -4: //LONGVARBINARY                      return DbType.Binary;                  case 0: //NULL                  case 1111: //OTHER                  case 2000: //JAVA_OBJECT                  case 2001: //DISTINCT                  case 2002: //STRUCT                  case 2003: //ARRAY                  case 2004: //BLOB                  case 2005: //CLOB                  case 2006: //REF                  case 70: //DATALINK                      return DbType.Object;                  case 16: //BOOLEAN                      return DbType.Boolean;                  //------------------------- JDBC 4.0 -----------------------------------                  case -15: //NCHAR                  case -9: //NVARCHAR                   case -16: //LONGNVARCHAR                  case 2011: //NCLOB                      return DbType.String;                  case 2009: //SQLXML                       return DbType.Xml;                  case -8: //ROWID                      return DbType.Object;              }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapJavaSqlToDbType,The following statement contains a magic number: switch (jSQL)              {                  case -7: //BIT                      return DbType.Boolean;                  case -6: //TINYINT                  case 5: //SMALLINT                  case 4: //INTEGER                      return DbType.Int32;                  case -5: //BIGINT                      return DbType.Int64;                  case 6: //FLOAT                  case 7: //REAL                      return DbType.Single;                  case 8: //DOUBLE                      return DbType.Double;                  case 2: //NUMERIC                  case 3: //DECIMAL                      return DbType.Decimal;                  case 1: //CHAR                  case 12: //VARCHAR                  case -1: //LONGVARCHAR                      return DbType.String;                  case 91: //DATE                      return DbType.Date;                  case 92: //TIME                      return DbType.Time;                  case 93: //TIMESTAMP                      return DbType.DateTime;                  case -2: //BINARY                  case -3: //VARBINARY                  case -4: //LONGVARBINARY                      return DbType.Binary;                  case 0: //NULL                  case 1111: //OTHER                  case 2000: //JAVA_OBJECT                  case 2001: //DISTINCT                  case 2002: //STRUCT                  case 2003: //ARRAY                  case 2004: //BLOB                  case 2005: //CLOB                  case 2006: //REF                  case 70: //DATALINK                      return DbType.Object;                  case 16: //BOOLEAN                      return DbType.Boolean;                  //------------------------- JDBC 4.0 -----------------------------------                  case -15: //NCHAR                  case -9: //NVARCHAR                   case -16: //LONGNVARCHAR                  case 2011: //NCLOB                      return DbType.String;                  case 2009: //SQLXML                       return DbType.Xml;                  case -8: //ROWID                      return DbType.Object;              }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapJavaSqlToDbType,The following statement contains a magic number: switch (jSQL)              {                  case -7: //BIT                      return DbType.Boolean;                  case -6: //TINYINT                  case 5: //SMALLINT                  case 4: //INTEGER                      return DbType.Int32;                  case -5: //BIGINT                      return DbType.Int64;                  case 6: //FLOAT                  case 7: //REAL                      return DbType.Single;                  case 8: //DOUBLE                      return DbType.Double;                  case 2: //NUMERIC                  case 3: //DECIMAL                      return DbType.Decimal;                  case 1: //CHAR                  case 12: //VARCHAR                  case -1: //LONGVARCHAR                      return DbType.String;                  case 91: //DATE                      return DbType.Date;                  case 92: //TIME                      return DbType.Time;                  case 93: //TIMESTAMP                      return DbType.DateTime;                  case -2: //BINARY                  case -3: //VARBINARY                  case -4: //LONGVARBINARY                      return DbType.Binary;                  case 0: //NULL                  case 1111: //OTHER                  case 2000: //JAVA_OBJECT                  case 2001: //DISTINCT                  case 2002: //STRUCT                  case 2003: //ARRAY                  case 2004: //BLOB                  case 2005: //CLOB                  case 2006: //REF                  case 70: //DATALINK                      return DbType.Object;                  case 16: //BOOLEAN                      return DbType.Boolean;                  //------------------------- JDBC 4.0 -----------------------------------                  case -15: //NCHAR                  case -9: //NVARCHAR                   case -16: //LONGNVARCHAR                  case 2011: //NCLOB                      return DbType.String;                  case 2009: //SQLXML                       return DbType.Xml;                  case -8: //ROWID                      return DbType.Object;              }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapJavaSqlToDbType,The following statement contains a magic number: switch (jSQL)              {                  case -7: //BIT                      return DbType.Boolean;                  case -6: //TINYINT                  case 5: //SMALLINT                  case 4: //INTEGER                      return DbType.Int32;                  case -5: //BIGINT                      return DbType.Int64;                  case 6: //FLOAT                  case 7: //REAL                      return DbType.Single;                  case 8: //DOUBLE                      return DbType.Double;                  case 2: //NUMERIC                  case 3: //DECIMAL                      return DbType.Decimal;                  case 1: //CHAR                  case 12: //VARCHAR                  case -1: //LONGVARCHAR                      return DbType.String;                  case 91: //DATE                      return DbType.Date;                  case 92: //TIME                      return DbType.Time;                  case 93: //TIMESTAMP                      return DbType.DateTime;                  case -2: //BINARY                  case -3: //VARBINARY                  case -4: //LONGVARBINARY                      return DbType.Binary;                  case 0: //NULL                  case 1111: //OTHER                  case 2000: //JAVA_OBJECT                  case 2001: //DISTINCT                  case 2002: //STRUCT                  case 2003: //ARRAY                  case 2004: //BLOB                  case 2005: //CLOB                  case 2006: //REF                  case 70: //DATALINK                      return DbType.Object;                  case 16: //BOOLEAN                      return DbType.Boolean;                  //------------------------- JDBC 4.0 -----------------------------------                  case -15: //NCHAR                  case -9: //NVARCHAR                   case -16: //LONGNVARCHAR                  case 2011: //NCLOB                      return DbType.String;                  case 2009: //SQLXML                       return DbType.Xml;                  case -8: //ROWID                      return DbType.Object;              }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapJavaSqlToDbType,The following statement contains a magic number: switch (jSQL)              {                  case -7: //BIT                      return DbType.Boolean;                  case -6: //TINYINT                  case 5: //SMALLINT                  case 4: //INTEGER                      return DbType.Int32;                  case -5: //BIGINT                      return DbType.Int64;                  case 6: //FLOAT                  case 7: //REAL                      return DbType.Single;                  case 8: //DOUBLE                      return DbType.Double;                  case 2: //NUMERIC                  case 3: //DECIMAL                      return DbType.Decimal;                  case 1: //CHAR                  case 12: //VARCHAR                  case -1: //LONGVARCHAR                      return DbType.String;                  case 91: //DATE                      return DbType.Date;                  case 92: //TIME                      return DbType.Time;                  case 93: //TIMESTAMP                      return DbType.DateTime;                  case -2: //BINARY                  case -3: //VARBINARY                  case -4: //LONGVARBINARY                      return DbType.Binary;                  case 0: //NULL                  case 1111: //OTHER                  case 2000: //JAVA_OBJECT                  case 2001: //DISTINCT                  case 2002: //STRUCT                  case 2003: //ARRAY                  case 2004: //BLOB                  case 2005: //CLOB                  case 2006: //REF                  case 70: //DATALINK                      return DbType.Object;                  case 16: //BOOLEAN                      return DbType.Boolean;                  //------------------------- JDBC 4.0 -----------------------------------                  case -15: //NCHAR                  case -9: //NVARCHAR                   case -16: //LONGNVARCHAR                  case 2011: //NCLOB                      return DbType.String;                  case 2009: //SQLXML                       return DbType.Xml;                  case -8: //ROWID                      return DbType.Object;              }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapJavaSqlToDbType,The following statement contains a magic number: switch (jSQL)              {                  case -7: //BIT                      return DbType.Boolean;                  case -6: //TINYINT                  case 5: //SMALLINT                  case 4: //INTEGER                      return DbType.Int32;                  case -5: //BIGINT                      return DbType.Int64;                  case 6: //FLOAT                  case 7: //REAL                      return DbType.Single;                  case 8: //DOUBLE                      return DbType.Double;                  case 2: //NUMERIC                  case 3: //DECIMAL                      return DbType.Decimal;                  case 1: //CHAR                  case 12: //VARCHAR                  case -1: //LONGVARCHAR                      return DbType.String;                  case 91: //DATE                      return DbType.Date;                  case 92: //TIME                      return DbType.Time;                  case 93: //TIMESTAMP                      return DbType.DateTime;                  case -2: //BINARY                  case -3: //VARBINARY                  case -4: //LONGVARBINARY                      return DbType.Binary;                  case 0: //NULL                  case 1111: //OTHER                  case 2000: //JAVA_OBJECT                  case 2001: //DISTINCT                  case 2002: //STRUCT                  case 2003: //ARRAY                  case 2004: //BLOB                  case 2005: //CLOB                  case 2006: //REF                  case 70: //DATALINK                      return DbType.Object;                  case 16: //BOOLEAN                      return DbType.Boolean;                  //------------------------- JDBC 4.0 -----------------------------------                  case -15: //NCHAR                  case -9: //NVARCHAR                   case -16: //LONGNVARCHAR                  case 2011: //NCLOB                      return DbType.String;                  case 2009: //SQLXML                       return DbType.Xml;                  case -8: //ROWID                      return DbType.Object;              }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapJavaSqlToDbType,The following statement contains a magic number: switch (jSQL)              {                  case -7: //BIT                      return DbType.Boolean;                  case -6: //TINYINT                  case 5: //SMALLINT                  case 4: //INTEGER                      return DbType.Int32;                  case -5: //BIGINT                      return DbType.Int64;                  case 6: //FLOAT                  case 7: //REAL                      return DbType.Single;                  case 8: //DOUBLE                      return DbType.Double;                  case 2: //NUMERIC                  case 3: //DECIMAL                      return DbType.Decimal;                  case 1: //CHAR                  case 12: //VARCHAR                  case -1: //LONGVARCHAR                      return DbType.String;                  case 91: //DATE                      return DbType.Date;                  case 92: //TIME                      return DbType.Time;                  case 93: //TIMESTAMP                      return DbType.DateTime;                  case -2: //BINARY                  case -3: //VARBINARY                  case -4: //LONGVARBINARY                      return DbType.Binary;                  case 0: //NULL                  case 1111: //OTHER                  case 2000: //JAVA_OBJECT                  case 2001: //DISTINCT                  case 2002: //STRUCT                  case 2003: //ARRAY                  case 2004: //BLOB                  case 2005: //CLOB                  case 2006: //REF                  case 70: //DATALINK                      return DbType.Object;                  case 16: //BOOLEAN                      return DbType.Boolean;                  //------------------------- JDBC 4.0 -----------------------------------                  case -15: //NCHAR                  case -9: //NVARCHAR                   case -16: //LONGNVARCHAR                  case 2011: //NCLOB                      return DbType.String;                  case 2009: //SQLXML                       return DbType.Xml;                  case -8: //ROWID                      return DbType.Object;              }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapJavaSqlToDbType,The following statement contains a magic number: switch (jSQL)              {                  case -7: //BIT                      return DbType.Boolean;                  case -6: //TINYINT                  case 5: //SMALLINT                  case 4: //INTEGER                      return DbType.Int32;                  case -5: //BIGINT                      return DbType.Int64;                  case 6: //FLOAT                  case 7: //REAL                      return DbType.Single;                  case 8: //DOUBLE                      return DbType.Double;                  case 2: //NUMERIC                  case 3: //DECIMAL                      return DbType.Decimal;                  case 1: //CHAR                  case 12: //VARCHAR                  case -1: //LONGVARCHAR                      return DbType.String;                  case 91: //DATE                      return DbType.Date;                  case 92: //TIME                      return DbType.Time;                  case 93: //TIMESTAMP                      return DbType.DateTime;                  case -2: //BINARY                  case -3: //VARBINARY                  case -4: //LONGVARBINARY                      return DbType.Binary;                  case 0: //NULL                  case 1111: //OTHER                  case 2000: //JAVA_OBJECT                  case 2001: //DISTINCT                  case 2002: //STRUCT                  case 2003: //ARRAY                  case 2004: //BLOB                  case 2005: //CLOB                  case 2006: //REF                  case 70: //DATALINK                      return DbType.Object;                  case 16: //BOOLEAN                      return DbType.Boolean;                  //------------------------- JDBC 4.0 -----------------------------------                  case -15: //NCHAR                  case -9: //NVARCHAR                   case -16: //LONGNVARCHAR                  case 2011: //NCLOB                      return DbType.String;                  case 2009: //SQLXML                       return DbType.Xml;                  case -8: //ROWID                      return DbType.Object;              }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapJavaSqlToDbType,The following statement contains a magic number: switch (jSQL)              {                  case -7: //BIT                      return DbType.Boolean;                  case -6: //TINYINT                  case 5: //SMALLINT                  case 4: //INTEGER                      return DbType.Int32;                  case -5: //BIGINT                      return DbType.Int64;                  case 6: //FLOAT                  case 7: //REAL                      return DbType.Single;                  case 8: //DOUBLE                      return DbType.Double;                  case 2: //NUMERIC                  case 3: //DECIMAL                      return DbType.Decimal;                  case 1: //CHAR                  case 12: //VARCHAR                  case -1: //LONGVARCHAR                      return DbType.String;                  case 91: //DATE                      return DbType.Date;                  case 92: //TIME                      return DbType.Time;                  case 93: //TIMESTAMP                      return DbType.DateTime;                  case -2: //BINARY                  case -3: //VARBINARY                  case -4: //LONGVARBINARY                      return DbType.Binary;                  case 0: //NULL                  case 1111: //OTHER                  case 2000: //JAVA_OBJECT                  case 2001: //DISTINCT                  case 2002: //STRUCT                  case 2003: //ARRAY                  case 2004: //BLOB                  case 2005: //CLOB                  case 2006: //REF                  case 70: //DATALINK                      return DbType.Object;                  case 16: //BOOLEAN                      return DbType.Boolean;                  //------------------------- JDBC 4.0 -----------------------------------                  case -15: //NCHAR                  case -9: //NVARCHAR                   case -16: //LONGNVARCHAR                  case 2011: //NCLOB                      return DbType.String;                  case 2009: //SQLXML                       return DbType.Xml;                  case -8: //ROWID                      return DbType.Object;              }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapJavaSqlToDbType,The following statement contains a magic number: switch (jSQL)              {                  case -7: //BIT                      return DbType.Boolean;                  case -6: //TINYINT                  case 5: //SMALLINT                  case 4: //INTEGER                      return DbType.Int32;                  case -5: //BIGINT                      return DbType.Int64;                  case 6: //FLOAT                  case 7: //REAL                      return DbType.Single;                  case 8: //DOUBLE                      return DbType.Double;                  case 2: //NUMERIC                  case 3: //DECIMAL                      return DbType.Decimal;                  case 1: //CHAR                  case 12: //VARCHAR                  case -1: //LONGVARCHAR                      return DbType.String;                  case 91: //DATE                      return DbType.Date;                  case 92: //TIME                      return DbType.Time;                  case 93: //TIMESTAMP                      return DbType.DateTime;                  case -2: //BINARY                  case -3: //VARBINARY                  case -4: //LONGVARBINARY                      return DbType.Binary;                  case 0: //NULL                  case 1111: //OTHER                  case 2000: //JAVA_OBJECT                  case 2001: //DISTINCT                  case 2002: //STRUCT                  case 2003: //ARRAY                  case 2004: //BLOB                  case 2005: //CLOB                  case 2006: //REF                  case 70: //DATALINK                      return DbType.Object;                  case 16: //BOOLEAN                      return DbType.Boolean;                  //------------------------- JDBC 4.0 -----------------------------------                  case -15: //NCHAR                  case -9: //NVARCHAR                   case -16: //LONGNVARCHAR                  case 2011: //NCLOB                      return DbType.String;                  case 2009: //SQLXML                       return DbType.Xml;                  case -8: //ROWID                      return DbType.Object;              }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapJavaSqlToDbType,The following statement contains a magic number: switch (jSQL)              {                  case -7: //BIT                      return DbType.Boolean;                  case -6: //TINYINT                  case 5: //SMALLINT                  case 4: //INTEGER                      return DbType.Int32;                  case -5: //BIGINT                      return DbType.Int64;                  case 6: //FLOAT                  case 7: //REAL                      return DbType.Single;                  case 8: //DOUBLE                      return DbType.Double;                  case 2: //NUMERIC                  case 3: //DECIMAL                      return DbType.Decimal;                  case 1: //CHAR                  case 12: //VARCHAR                  case -1: //LONGVARCHAR                      return DbType.String;                  case 91: //DATE                      return DbType.Date;                  case 92: //TIME                      return DbType.Time;                  case 93: //TIMESTAMP                      return DbType.DateTime;                  case -2: //BINARY                  case -3: //VARBINARY                  case -4: //LONGVARBINARY                      return DbType.Binary;                  case 0: //NULL                  case 1111: //OTHER                  case 2000: //JAVA_OBJECT                  case 2001: //DISTINCT                  case 2002: //STRUCT                  case 2003: //ARRAY                  case 2004: //BLOB                  case 2005: //CLOB                  case 2006: //REF                  case 70: //DATALINK                      return DbType.Object;                  case 16: //BOOLEAN                      return DbType.Boolean;                  //------------------------- JDBC 4.0 -----------------------------------                  case -15: //NCHAR                  case -9: //NVARCHAR                   case -16: //LONGNVARCHAR                  case 2011: //NCLOB                      return DbType.String;                  case 2009: //SQLXML                       return DbType.Xml;                  case -8: //ROWID                      return DbType.Object;              }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapDbTypeToJavaSql,The following statement contains a magic number: switch (dbType)              {                  case DbType.Boolean:                      return 16; //BOOLEAN                  case DbType.Int32:                      return 4; //INTEGER                  case DbType.Int64:                      return -5; //BIGINT                  case DbType.Single:                      return 7; //REAL                  case DbType.Double:                      return 8; //DOUBLE                  case DbType.Decimal:                      return 3; //DECIMAL                  case DbType.Xml:                  case DbType.String:                      return 12; //VARCHAR                  case DbType.Date:                      return 91; //DATE                  case DbType.Time:                      return 92; //TIME                  case DbType.DateTime:                      return 93; //TIMESTAMP                  case DbType.Binary:                      return -3; //VARBINARY                  case DbType.Object:                      return 2004; //BLOB              }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapDbTypeToJavaSql,The following statement contains a magic number: switch (dbType)              {                  case DbType.Boolean:                      return 16; //BOOLEAN                  case DbType.Int32:                      return 4; //INTEGER                  case DbType.Int64:                      return -5; //BIGINT                  case DbType.Single:                      return 7; //REAL                  case DbType.Double:                      return 8; //DOUBLE                  case DbType.Decimal:                      return 3; //DECIMAL                  case DbType.Xml:                  case DbType.String:                      return 12; //VARCHAR                  case DbType.Date:                      return 91; //DATE                  case DbType.Time:                      return 92; //TIME                  case DbType.DateTime:                      return 93; //TIMESTAMP                  case DbType.Binary:                      return -3; //VARBINARY                  case DbType.Object:                      return 2004; //BLOB              }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapDbTypeToJavaSql,The following statement contains a magic number: switch (dbType)              {                  case DbType.Boolean:                      return 16; //BOOLEAN                  case DbType.Int32:                      return 4; //INTEGER                  case DbType.Int64:                      return -5; //BIGINT                  case DbType.Single:                      return 7; //REAL                  case DbType.Double:                      return 8; //DOUBLE                  case DbType.Decimal:                      return 3; //DECIMAL                  case DbType.Xml:                  case DbType.String:                      return 12; //VARCHAR                  case DbType.Date:                      return 91; //DATE                  case DbType.Time:                      return 92; //TIME                  case DbType.DateTime:                      return 93; //TIMESTAMP                  case DbType.Binary:                      return -3; //VARBINARY                  case DbType.Object:                      return 2004; //BLOB              }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapDbTypeToJavaSql,The following statement contains a magic number: switch (dbType)              {                  case DbType.Boolean:                      return 16; //BOOLEAN                  case DbType.Int32:                      return 4; //INTEGER                  case DbType.Int64:                      return -5; //BIGINT                  case DbType.Single:                      return 7; //REAL                  case DbType.Double:                      return 8; //DOUBLE                  case DbType.Decimal:                      return 3; //DECIMAL                  case DbType.Xml:                  case DbType.String:                      return 12; //VARCHAR                  case DbType.Date:                      return 91; //DATE                  case DbType.Time:                      return 92; //TIME                  case DbType.DateTime:                      return 93; //TIMESTAMP                  case DbType.Binary:                      return -3; //VARBINARY                  case DbType.Object:                      return 2004; //BLOB              }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapDbTypeToJavaSql,The following statement contains a magic number: switch (dbType)              {                  case DbType.Boolean:                      return 16; //BOOLEAN                  case DbType.Int32:                      return 4; //INTEGER                  case DbType.Int64:                      return -5; //BIGINT                  case DbType.Single:                      return 7; //REAL                  case DbType.Double:                      return 8; //DOUBLE                  case DbType.Decimal:                      return 3; //DECIMAL                  case DbType.Xml:                  case DbType.String:                      return 12; //VARCHAR                  case DbType.Date:                      return 91; //DATE                  case DbType.Time:                      return 92; //TIME                  case DbType.DateTime:                      return 93; //TIMESTAMP                  case DbType.Binary:                      return -3; //VARBINARY                  case DbType.Object:                      return 2004; //BLOB              }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapDbTypeToJavaSql,The following statement contains a magic number: switch (dbType)              {                  case DbType.Boolean:                      return 16; //BOOLEAN                  case DbType.Int32:                      return 4; //INTEGER                  case DbType.Int64:                      return -5; //BIGINT                  case DbType.Single:                      return 7; //REAL                  case DbType.Double:                      return 8; //DOUBLE                  case DbType.Decimal:                      return 3; //DECIMAL                  case DbType.Xml:                  case DbType.String:                      return 12; //VARCHAR                  case DbType.Date:                      return 91; //DATE                  case DbType.Time:                      return 92; //TIME                  case DbType.DateTime:                      return 93; //TIMESTAMP                  case DbType.Binary:                      return -3; //VARBINARY                  case DbType.Object:                      return 2004; //BLOB              }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapDbTypeToJavaSql,The following statement contains a magic number: switch (dbType)              {                  case DbType.Boolean:                      return 16; //BOOLEAN                  case DbType.Int32:                      return 4; //INTEGER                  case DbType.Int64:                      return -5; //BIGINT                  case DbType.Single:                      return 7; //REAL                  case DbType.Double:                      return 8; //DOUBLE                  case DbType.Decimal:                      return 3; //DECIMAL                  case DbType.Xml:                  case DbType.String:                      return 12; //VARCHAR                  case DbType.Date:                      return 91; //DATE                  case DbType.Time:                      return 92; //TIME                  case DbType.DateTime:                      return 93; //TIMESTAMP                  case DbType.Binary:                      return -3; //VARBINARY                  case DbType.Object:                      return 2004; //BLOB              }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapDbTypeToJavaSql,The following statement contains a magic number: switch (dbType)              {                  case DbType.Boolean:                      return 16; //BOOLEAN                  case DbType.Int32:                      return 4; //INTEGER                  case DbType.Int64:                      return -5; //BIGINT                  case DbType.Single:                      return 7; //REAL                  case DbType.Double:                      return 8; //DOUBLE                  case DbType.Decimal:                      return 3; //DECIMAL                  case DbType.Xml:                  case DbType.String:                      return 12; //VARCHAR                  case DbType.Date:                      return 91; //DATE                  case DbType.Time:                      return 92; //TIME                  case DbType.DateTime:                      return 93; //TIMESTAMP                  case DbType.Binary:                      return -3; //VARBINARY                  case DbType.Object:                      return 2004; //BLOB              }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapDbTypeToJavaSql,The following statement contains a magic number: switch (dbType)              {                  case DbType.Boolean:                      return 16; //BOOLEAN                  case DbType.Int32:                      return 4; //INTEGER                  case DbType.Int64:                      return -5; //BIGINT                  case DbType.Single:                      return 7; //REAL                  case DbType.Double:                      return 8; //DOUBLE                  case DbType.Decimal:                      return 3; //DECIMAL                  case DbType.Xml:                  case DbType.String:                      return 12; //VARCHAR                  case DbType.Date:                      return 91; //DATE                  case DbType.Time:                      return 92; //TIME                  case DbType.DateTime:                      return 93; //TIMESTAMP                  case DbType.Binary:                      return -3; //VARBINARY                  case DbType.Object:                      return 2004; //BLOB              }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapDbTypeToJavaSql,The following statement contains a magic number: switch (dbType)              {                  case DbType.Boolean:                      return 16; //BOOLEAN                  case DbType.Int32:                      return 4; //INTEGER                  case DbType.Int64:                      return -5; //BIGINT                  case DbType.Single:                      return 7; //REAL                  case DbType.Double:                      return 8; //DOUBLE                  case DbType.Decimal:                      return 3; //DECIMAL                  case DbType.Xml:                  case DbType.String:                      return 12; //VARCHAR                  case DbType.Date:                      return 91; //DATE                  case DbType.Time:                      return 92; //TIME                  case DbType.DateTime:                      return 93; //TIMESTAMP                  case DbType.Binary:                      return -3; //VARBINARY                  case DbType.Object:                      return 2004; //BLOB              }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapDbTypeToJavaSql,The following statement contains a magic number: switch (dbType)              {                  case DbType.Boolean:                      return 16; //BOOLEAN                  case DbType.Int32:                      return 4; //INTEGER                  case DbType.Int64:                      return -5; //BIGINT                  case DbType.Single:                      return 7; //REAL                  case DbType.Double:                      return 8; //DOUBLE                  case DbType.Decimal:                      return 3; //DECIMAL                  case DbType.Xml:                  case DbType.String:                      return 12; //VARCHAR                  case DbType.Date:                      return 91; //DATE                  case DbType.Time:                      return 92; //TIME                  case DbType.DateTime:                      return 93; //TIMESTAMP                  case DbType.Binary:                      return -3; //VARBINARY                  case DbType.Object:                      return 2004; //BLOB              }
Magic Number,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapDbTypeToJavaSql,The following statement contains a magic number: switch (dbType)              {                  case DbType.Boolean:                      return 16; //BOOLEAN                  case DbType.Int32:                      return 4; //INTEGER                  case DbType.Int64:                      return -5; //BIGINT                  case DbType.Single:                      return 7; //REAL                  case DbType.Double:                      return 8; //DOUBLE                  case DbType.Decimal:                      return 3; //DECIMAL                  case DbType.Xml:                  case DbType.String:                      return 12; //VARCHAR                  case DbType.Date:                      return 91; //DATE                  case DbType.Time:                      return 92; //TIME                  case DbType.DateTime:                      return 93; //TIMESTAMP                  case DbType.Binary:                      return -3; //VARBINARY                  case DbType.Object:                      return 2004; //BLOB              }
Magic Number,NuoDb.Data.Client,NuoDbDataReader,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbDataReader.cs,GetSchemaTable,The following statement contains a magic number: for (int n = 0; n < numberColumns; ++n)              {                  DataRow row = metadata.NewRow();                  row["ColumnOrdinal"] = n;                  // data fields must be read in this exact order!                  row["BaseCatalogName"] = dataStream.getString();                  row["BaseSchemaName"] = dataStream.getString();                  row["BaseTableName"] = dataStream.getString();                  row["BaseColumnName"] = dataStream.getString();                  row["ColumnName"] = dataStream.getString();                  string collationSequence = dataStream.getString();                  row["DataTypeName"] = dataStream.getString();                  row["ProviderType"] = NuoDbConnectionInternal.mapJavaSqlToDbType(dataStream.getInt());                  row["ColumnSize"] = dataStream.getInt();                  row["NumericPrecision"] = dataStream.getInt();                  row["NumericScale"] = dataStream.getInt();                  if (((DbType)row["ProviderType"] == DbType.Int16 || (DbType)row["ProviderType"] == DbType.Int32 || (DbType)row["ProviderType"] == DbType.Int64) &&                      (int)row["NumericScale"] != 0)                  {                      row["ProviderType"] = DbType.Decimal;                  }                  row["DataType"] = Type.GetType(NuoDbConnectionInternal.mapNuoDbToNetType((string)row["DataTypeName"]' (int)row["NumericPrecision"]' (int)row["NumericScale"]));                  int flags = dataStream.getInt();                  const int rsmdSearchable = (1 << 1);                  const int rsmdAutoIncrement = (1 << 2);                  const int rsmdCaseSensitive = (1 << 3);                  const int rsmdCurrency = (1 << 4);                  const int rsmdDefinitelyWritable = (1 << 5);                  const int rsmdWritable = (1 << 6);                  const int rsmdReadOnly = (1 << 7);                  const int rsmdSigned = (1 << 8);                  const int rsmdNullable = (1 << 9);                  row["IsAutoIncrement"] = (flags & rsmdAutoIncrement) != 0;                  row["IsReadOnly"] = (flags & rsmdReadOnly) != 0;                  row["AllowDBNull"] = (flags & rsmdNullable) != 0;                  // for the moment' set the column to be a normal one; later we will look for primary indexes                  row["IsKey"] = row["IsIdentity"] = row["IsUnique"] = false;                  row["IsLong"] = row["IsRowVersion"] = row["IsExpression"] = false;                  metadata.Rows.Add(row);    #if DEBUG                  System.Diagnostics.Trace.WriteLine("-> " + row["ColumnName"] + "' " +                                                              row["DataTypeName"] + "(" + row["NumericPrecision"] + "'" + row["NumericScale"] + ") " +                                                              row["DataType"]);  #endif              }
Magic Number,NuoDb.Data.Client,NuoDbDataReader,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbDataReader.cs,GetSchemaTable,The following statement contains a magic number: for (int n = 0; n < numberColumns; ++n)              {                  DataRow row = metadata.NewRow();                  row["ColumnOrdinal"] = n;                  // data fields must be read in this exact order!                  row["BaseCatalogName"] = dataStream.getString();                  row["BaseSchemaName"] = dataStream.getString();                  row["BaseTableName"] = dataStream.getString();                  row["BaseColumnName"] = dataStream.getString();                  row["ColumnName"] = dataStream.getString();                  string collationSequence = dataStream.getString();                  row["DataTypeName"] = dataStream.getString();                  row["ProviderType"] = NuoDbConnectionInternal.mapJavaSqlToDbType(dataStream.getInt());                  row["ColumnSize"] = dataStream.getInt();                  row["NumericPrecision"] = dataStream.getInt();                  row["NumericScale"] = dataStream.getInt();                  if (((DbType)row["ProviderType"] == DbType.Int16 || (DbType)row["ProviderType"] == DbType.Int32 || (DbType)row["ProviderType"] == DbType.Int64) &&                      (int)row["NumericScale"] != 0)                  {                      row["ProviderType"] = DbType.Decimal;                  }                  row["DataType"] = Type.GetType(NuoDbConnectionInternal.mapNuoDbToNetType((string)row["DataTypeName"]' (int)row["NumericPrecision"]' (int)row["NumericScale"]));                  int flags = dataStream.getInt();                  const int rsmdSearchable = (1 << 1);                  const int rsmdAutoIncrement = (1 << 2);                  const int rsmdCaseSensitive = (1 << 3);                  const int rsmdCurrency = (1 << 4);                  const int rsmdDefinitelyWritable = (1 << 5);                  const int rsmdWritable = (1 << 6);                  const int rsmdReadOnly = (1 << 7);                  const int rsmdSigned = (1 << 8);                  const int rsmdNullable = (1 << 9);                  row["IsAutoIncrement"] = (flags & rsmdAutoIncrement) != 0;                  row["IsReadOnly"] = (flags & rsmdReadOnly) != 0;                  row["AllowDBNull"] = (flags & rsmdNullable) != 0;                  // for the moment' set the column to be a normal one; later we will look for primary indexes                  row["IsKey"] = row["IsIdentity"] = row["IsUnique"] = false;                  row["IsLong"] = row["IsRowVersion"] = row["IsExpression"] = false;                  metadata.Rows.Add(row);    #if DEBUG                  System.Diagnostics.Trace.WriteLine("-> " + row["ColumnName"] + "' " +                                                              row["DataTypeName"] + "(" + row["NumericPrecision"] + "'" + row["NumericScale"] + ") " +                                                              row["DataType"]);  #endif              }
Magic Number,NuoDb.Data.Client,NuoDbDataReader,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbDataReader.cs,GetSchemaTable,The following statement contains a magic number: for (int n = 0; n < numberColumns; ++n)              {                  DataRow row = metadata.NewRow();                  row["ColumnOrdinal"] = n;                  // data fields must be read in this exact order!                  row["BaseCatalogName"] = dataStream.getString();                  row["BaseSchemaName"] = dataStream.getString();                  row["BaseTableName"] = dataStream.getString();                  row["BaseColumnName"] = dataStream.getString();                  row["ColumnName"] = dataStream.getString();                  string collationSequence = dataStream.getString();                  row["DataTypeName"] = dataStream.getString();                  row["ProviderType"] = NuoDbConnectionInternal.mapJavaSqlToDbType(dataStream.getInt());                  row["ColumnSize"] = dataStream.getInt();                  row["NumericPrecision"] = dataStream.getInt();                  row["NumericScale"] = dataStream.getInt();                  if (((DbType)row["ProviderType"] == DbType.Int16 || (DbType)row["ProviderType"] == DbType.Int32 || (DbType)row["ProviderType"] == DbType.Int64) &&                      (int)row["NumericScale"] != 0)                  {                      row["ProviderType"] = DbType.Decimal;                  }                  row["DataType"] = Type.GetType(NuoDbConnectionInternal.mapNuoDbToNetType((string)row["DataTypeName"]' (int)row["NumericPrecision"]' (int)row["NumericScale"]));                  int flags = dataStream.getInt();                  const int rsmdSearchable = (1 << 1);                  const int rsmdAutoIncrement = (1 << 2);                  const int rsmdCaseSensitive = (1 << 3);                  const int rsmdCurrency = (1 << 4);                  const int rsmdDefinitelyWritable = (1 << 5);                  const int rsmdWritable = (1 << 6);                  const int rsmdReadOnly = (1 << 7);                  const int rsmdSigned = (1 << 8);                  const int rsmdNullable = (1 << 9);                  row["IsAutoIncrement"] = (flags & rsmdAutoIncrement) != 0;                  row["IsReadOnly"] = (flags & rsmdReadOnly) != 0;                  row["AllowDBNull"] = (flags & rsmdNullable) != 0;                  // for the moment' set the column to be a normal one; later we will look for primary indexes                  row["IsKey"] = row["IsIdentity"] = row["IsUnique"] = false;                  row["IsLong"] = row["IsRowVersion"] = row["IsExpression"] = false;                  metadata.Rows.Add(row);    #if DEBUG                  System.Diagnostics.Trace.WriteLine("-> " + row["ColumnName"] + "' " +                                                              row["DataTypeName"] + "(" + row["NumericPrecision"] + "'" + row["NumericScale"] + ") " +                                                              row["DataType"]);  #endif              }
Magic Number,NuoDb.Data.Client,NuoDbDataReader,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbDataReader.cs,GetSchemaTable,The following statement contains a magic number: for (int n = 0; n < numberColumns; ++n)              {                  DataRow row = metadata.NewRow();                  row["ColumnOrdinal"] = n;                  // data fields must be read in this exact order!                  row["BaseCatalogName"] = dataStream.getString();                  row["BaseSchemaName"] = dataStream.getString();                  row["BaseTableName"] = dataStream.getString();                  row["BaseColumnName"] = dataStream.getString();                  row["ColumnName"] = dataStream.getString();                  string collationSequence = dataStream.getString();                  row["DataTypeName"] = dataStream.getString();                  row["ProviderType"] = NuoDbConnectionInternal.mapJavaSqlToDbType(dataStream.getInt());                  row["ColumnSize"] = dataStream.getInt();                  row["NumericPrecision"] = dataStream.getInt();                  row["NumericScale"] = dataStream.getInt();                  if (((DbType)row["ProviderType"] == DbType.Int16 || (DbType)row["ProviderType"] == DbType.Int32 || (DbType)row["ProviderType"] == DbType.Int64) &&                      (int)row["NumericScale"] != 0)                  {                      row["ProviderType"] = DbType.Decimal;                  }                  row["DataType"] = Type.GetType(NuoDbConnectionInternal.mapNuoDbToNetType((string)row["DataTypeName"]' (int)row["NumericPrecision"]' (int)row["NumericScale"]));                  int flags = dataStream.getInt();                  const int rsmdSearchable = (1 << 1);                  const int rsmdAutoIncrement = (1 << 2);                  const int rsmdCaseSensitive = (1 << 3);                  const int rsmdCurrency = (1 << 4);                  const int rsmdDefinitelyWritable = (1 << 5);                  const int rsmdWritable = (1 << 6);                  const int rsmdReadOnly = (1 << 7);                  const int rsmdSigned = (1 << 8);                  const int rsmdNullable = (1 << 9);                  row["IsAutoIncrement"] = (flags & rsmdAutoIncrement) != 0;                  row["IsReadOnly"] = (flags & rsmdReadOnly) != 0;                  row["AllowDBNull"] = (flags & rsmdNullable) != 0;                  // for the moment' set the column to be a normal one; later we will look for primary indexes                  row["IsKey"] = row["IsIdentity"] = row["IsUnique"] = false;                  row["IsLong"] = row["IsRowVersion"] = row["IsExpression"] = false;                  metadata.Rows.Add(row);    #if DEBUG                  System.Diagnostics.Trace.WriteLine("-> " + row["ColumnName"] + "' " +                                                              row["DataTypeName"] + "(" + row["NumericPrecision"] + "'" + row["NumericScale"] + ") " +                                                              row["DataType"]);  #endif              }
Magic Number,NuoDb.Data.Client,NuoDbDataReader,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbDataReader.cs,GetSchemaTable,The following statement contains a magic number: for (int n = 0; n < numberColumns; ++n)              {                  DataRow row = metadata.NewRow();                  row["ColumnOrdinal"] = n;                  // data fields must be read in this exact order!                  row["BaseCatalogName"] = dataStream.getString();                  row["BaseSchemaName"] = dataStream.getString();                  row["BaseTableName"] = dataStream.getString();                  row["BaseColumnName"] = dataStream.getString();                  row["ColumnName"] = dataStream.getString();                  string collationSequence = dataStream.getString();                  row["DataTypeName"] = dataStream.getString();                  row["ProviderType"] = NuoDbConnectionInternal.mapJavaSqlToDbType(dataStream.getInt());                  row["ColumnSize"] = dataStream.getInt();                  row["NumericPrecision"] = dataStream.getInt();                  row["NumericScale"] = dataStream.getInt();                  if (((DbType)row["ProviderType"] == DbType.Int16 || (DbType)row["ProviderType"] == DbType.Int32 || (DbType)row["ProviderType"] == DbType.Int64) &&                      (int)row["NumericScale"] != 0)                  {                      row["ProviderType"] = DbType.Decimal;                  }                  row["DataType"] = Type.GetType(NuoDbConnectionInternal.mapNuoDbToNetType((string)row["DataTypeName"]' (int)row["NumericPrecision"]' (int)row["NumericScale"]));                  int flags = dataStream.getInt();                  const int rsmdSearchable = (1 << 1);                  const int rsmdAutoIncrement = (1 << 2);                  const int rsmdCaseSensitive = (1 << 3);                  const int rsmdCurrency = (1 << 4);                  const int rsmdDefinitelyWritable = (1 << 5);                  const int rsmdWritable = (1 << 6);                  const int rsmdReadOnly = (1 << 7);                  const int rsmdSigned = (1 << 8);                  const int rsmdNullable = (1 << 9);                  row["IsAutoIncrement"] = (flags & rsmdAutoIncrement) != 0;                  row["IsReadOnly"] = (flags & rsmdReadOnly) != 0;                  row["AllowDBNull"] = (flags & rsmdNullable) != 0;                  // for the moment' set the column to be a normal one; later we will look for primary indexes                  row["IsKey"] = row["IsIdentity"] = row["IsUnique"] = false;                  row["IsLong"] = row["IsRowVersion"] = row["IsExpression"] = false;                  metadata.Rows.Add(row);    #if DEBUG                  System.Diagnostics.Trace.WriteLine("-> " + row["ColumnName"] + "' " +                                                              row["DataTypeName"] + "(" + row["NumericPrecision"] + "'" + row["NumericScale"] + ") " +                                                              row["DataType"]);  #endif              }
Magic Number,NuoDb.Data.Client,NuoDbDataReader,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbDataReader.cs,GetSchemaTable,The following statement contains a magic number: for (int n = 0; n < numberColumns; ++n)              {                  DataRow row = metadata.NewRow();                  row["ColumnOrdinal"] = n;                  // data fields must be read in this exact order!                  row["BaseCatalogName"] = dataStream.getString();                  row["BaseSchemaName"] = dataStream.getString();                  row["BaseTableName"] = dataStream.getString();                  row["BaseColumnName"] = dataStream.getString();                  row["ColumnName"] = dataStream.getString();                  string collationSequence = dataStream.getString();                  row["DataTypeName"] = dataStream.getString();                  row["ProviderType"] = NuoDbConnectionInternal.mapJavaSqlToDbType(dataStream.getInt());                  row["ColumnSize"] = dataStream.getInt();                  row["NumericPrecision"] = dataStream.getInt();                  row["NumericScale"] = dataStream.getInt();                  if (((DbType)row["ProviderType"] == DbType.Int16 || (DbType)row["ProviderType"] == DbType.Int32 || (DbType)row["ProviderType"] == DbType.Int64) &&                      (int)row["NumericScale"] != 0)                  {                      row["ProviderType"] = DbType.Decimal;                  }                  row["DataType"] = Type.GetType(NuoDbConnectionInternal.mapNuoDbToNetType((string)row["DataTypeName"]' (int)row["NumericPrecision"]' (int)row["NumericScale"]));                  int flags = dataStream.getInt();                  const int rsmdSearchable = (1 << 1);                  const int rsmdAutoIncrement = (1 << 2);                  const int rsmdCaseSensitive = (1 << 3);                  const int rsmdCurrency = (1 << 4);                  const int rsmdDefinitelyWritable = (1 << 5);                  const int rsmdWritable = (1 << 6);                  const int rsmdReadOnly = (1 << 7);                  const int rsmdSigned = (1 << 8);                  const int rsmdNullable = (1 << 9);                  row["IsAutoIncrement"] = (flags & rsmdAutoIncrement) != 0;                  row["IsReadOnly"] = (flags & rsmdReadOnly) != 0;                  row["AllowDBNull"] = (flags & rsmdNullable) != 0;                  // for the moment' set the column to be a normal one; later we will look for primary indexes                  row["IsKey"] = row["IsIdentity"] = row["IsUnique"] = false;                  row["IsLong"] = row["IsRowVersion"] = row["IsExpression"] = false;                  metadata.Rows.Add(row);    #if DEBUG                  System.Diagnostics.Trace.WriteLine("-> " + row["ColumnName"] + "' " +                                                              row["DataTypeName"] + "(" + row["NumericPrecision"] + "'" + row["NumericScale"] + ") " +                                                              row["DataType"]);  #endif              }
Magic Number,NuoDb.Data.Client,NuoDbDataReader,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbDataReader.cs,GetSchemaTable,The following statement contains a magic number: for (int n = 0; n < numberColumns; ++n)              {                  DataRow row = metadata.NewRow();                  row["ColumnOrdinal"] = n;                  // data fields must be read in this exact order!                  row["BaseCatalogName"] = dataStream.getString();                  row["BaseSchemaName"] = dataStream.getString();                  row["BaseTableName"] = dataStream.getString();                  row["BaseColumnName"] = dataStream.getString();                  row["ColumnName"] = dataStream.getString();                  string collationSequence = dataStream.getString();                  row["DataTypeName"] = dataStream.getString();                  row["ProviderType"] = NuoDbConnectionInternal.mapJavaSqlToDbType(dataStream.getInt());                  row["ColumnSize"] = dataStream.getInt();                  row["NumericPrecision"] = dataStream.getInt();                  row["NumericScale"] = dataStream.getInt();                  if (((DbType)row["ProviderType"] == DbType.Int16 || (DbType)row["ProviderType"] == DbType.Int32 || (DbType)row["ProviderType"] == DbType.Int64) &&                      (int)row["NumericScale"] != 0)                  {                      row["ProviderType"] = DbType.Decimal;                  }                  row["DataType"] = Type.GetType(NuoDbConnectionInternal.mapNuoDbToNetType((string)row["DataTypeName"]' (int)row["NumericPrecision"]' (int)row["NumericScale"]));                  int flags = dataStream.getInt();                  const int rsmdSearchable = (1 << 1);                  const int rsmdAutoIncrement = (1 << 2);                  const int rsmdCaseSensitive = (1 << 3);                  const int rsmdCurrency = (1 << 4);                  const int rsmdDefinitelyWritable = (1 << 5);                  const int rsmdWritable = (1 << 6);                  const int rsmdReadOnly = (1 << 7);                  const int rsmdSigned = (1 << 8);                  const int rsmdNullable = (1 << 9);                  row["IsAutoIncrement"] = (flags & rsmdAutoIncrement) != 0;                  row["IsReadOnly"] = (flags & rsmdReadOnly) != 0;                  row["AllowDBNull"] = (flags & rsmdNullable) != 0;                  // for the moment' set the column to be a normal one; later we will look for primary indexes                  row["IsKey"] = row["IsIdentity"] = row["IsUnique"] = false;                  row["IsLong"] = row["IsRowVersion"] = row["IsExpression"] = false;                  metadata.Rows.Add(row);    #if DEBUG                  System.Diagnostics.Trace.WriteLine("-> " + row["ColumnName"] + "' " +                                                              row["DataTypeName"] + "(" + row["NumericPrecision"] + "'" + row["NumericScale"] + ") " +                                                              row["DataType"]);  #endif              }
Magic Number,NuoDb.Data.Client,NuoDbDataReader,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbDataReader.cs,GetSchemaTable,The following statement contains a magic number: for (int n = 0; n < numberColumns; ++n)              {                  DataRow row = metadata.NewRow();                  row["ColumnOrdinal"] = n;                  // data fields must be read in this exact order!                  row["BaseCatalogName"] = dataStream.getString();                  row["BaseSchemaName"] = dataStream.getString();                  row["BaseTableName"] = dataStream.getString();                  row["BaseColumnName"] = dataStream.getString();                  row["ColumnName"] = dataStream.getString();                  string collationSequence = dataStream.getString();                  row["DataTypeName"] = dataStream.getString();                  row["ProviderType"] = NuoDbConnectionInternal.mapJavaSqlToDbType(dataStream.getInt());                  row["ColumnSize"] = dataStream.getInt();                  row["NumericPrecision"] = dataStream.getInt();                  row["NumericScale"] = dataStream.getInt();                  if (((DbType)row["ProviderType"] == DbType.Int16 || (DbType)row["ProviderType"] == DbType.Int32 || (DbType)row["ProviderType"] == DbType.Int64) &&                      (int)row["NumericScale"] != 0)                  {                      row["ProviderType"] = DbType.Decimal;                  }                  row["DataType"] = Type.GetType(NuoDbConnectionInternal.mapNuoDbToNetType((string)row["DataTypeName"]' (int)row["NumericPrecision"]' (int)row["NumericScale"]));                  int flags = dataStream.getInt();                  const int rsmdSearchable = (1 << 1);                  const int rsmdAutoIncrement = (1 << 2);                  const int rsmdCaseSensitive = (1 << 3);                  const int rsmdCurrency = (1 << 4);                  const int rsmdDefinitelyWritable = (1 << 5);                  const int rsmdWritable = (1 << 6);                  const int rsmdReadOnly = (1 << 7);                  const int rsmdSigned = (1 << 8);                  const int rsmdNullable = (1 << 9);                  row["IsAutoIncrement"] = (flags & rsmdAutoIncrement) != 0;                  row["IsReadOnly"] = (flags & rsmdReadOnly) != 0;                  row["AllowDBNull"] = (flags & rsmdNullable) != 0;                  // for the moment' set the column to be a normal one; later we will look for primary indexes                  row["IsKey"] = row["IsIdentity"] = row["IsUnique"] = false;                  row["IsLong"] = row["IsRowVersion"] = row["IsExpression"] = false;                  metadata.Rows.Add(row);    #if DEBUG                  System.Diagnostics.Trace.WriteLine("-> " + row["ColumnName"] + "' " +                                                              row["DataTypeName"] + "(" + row["NumericPrecision"] + "'" + row["NumericScale"] + ") " +                                                              row["DataType"]);  #endif              }
Magic Number,NuoDb.Data.Client,DataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\DataStream.cs,DataStream,The following statement contains a magic number: base64Lookup = new byte[256];
Magic Number,NuoDb.Data.Client,DataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\DataStream.cs,DataStream,The following statement contains a magic number: base64Digits = new byte[64];
Magic Number,NuoDb.Data.Client,DataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\DataStream.cs,DataStream,The following statement contains a magic number: for (int n = 0; n < 64; ++n)              {                  char c = alphabet[n];                  base64Lookup[c] = (byte)n;                  base64Digits[n] = (byte)c;              }
Magic Number,NuoDb.Data.Client,DataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\DataStream.cs,setBase64,The following statement contains a magic number: allocate((length + 2) * 3 / 4);
Magic Number,NuoDb.Data.Client,DataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\DataStream.cs,setBase64,The following statement contains a magic number: allocate((length + 2) * 3 / 4);
Magic Number,NuoDb.Data.Client,DataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\DataStream.cs,setBase64,The following statement contains a magic number: allocate((length + 2) * 3 / 4);
Magic Number,NuoDb.Data.Client,DataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\DataStream.cs,setBase64,The following statement contains a magic number: for (int n = 0; n < length; ++n)              {                  char c = data[@in++];                  int digit = base64Lookup[c];                    if (c == '=')                  {                      if (bitsRemaining > 0)                      {                          buffer[@out++] = (byte)(bits << (6 - bitsRemaining));                          bitsRemaining = 0;                      }                  }                  else if (digit != 0xff)                  {                      bits = (bits << 6) | digit;                      bitsRemaining += 6;                  }                    if (bitsRemaining >= 8)                  {                      bitsRemaining -= 8;                      buffer[@out++] = (byte)(bits >> bitsRemaining);                  }              }
Magic Number,NuoDb.Data.Client,DataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\DataStream.cs,setBase64,The following statement contains a magic number: for (int n = 0; n < length; ++n)              {                  char c = data[@in++];                  int digit = base64Lookup[c];                    if (c == '=')                  {                      if (bitsRemaining > 0)                      {                          buffer[@out++] = (byte)(bits << (6 - bitsRemaining));                          bitsRemaining = 0;                      }                  }                  else if (digit != 0xff)                  {                      bits = (bits << 6) | digit;                      bitsRemaining += 6;                  }                    if (bitsRemaining >= 8)                  {                      bitsRemaining -= 8;                      buffer[@out++] = (byte)(bits >> bitsRemaining);                  }              }
Magic Number,NuoDb.Data.Client,DataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\DataStream.cs,setBase64,The following statement contains a magic number: for (int n = 0; n < length; ++n)              {                  char c = data[@in++];                  int digit = base64Lookup[c];                    if (c == '=')                  {                      if (bitsRemaining > 0)                      {                          buffer[@out++] = (byte)(bits << (6 - bitsRemaining));                          bitsRemaining = 0;                      }                  }                  else if (digit != 0xff)                  {                      bits = (bits << 6) | digit;                      bitsRemaining += 6;                  }                    if (bitsRemaining >= 8)                  {                      bitsRemaining -= 8;                      buffer[@out++] = (byte)(bits >> bitsRemaining);                  }              }
Magic Number,NuoDb.Data.Client,DataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\DataStream.cs,setBase64,The following statement contains a magic number: for (int n = 0; n < length; ++n)              {                  char c = data[@in++];                  int digit = base64Lookup[c];                    if (c == '=')                  {                      if (bitsRemaining > 0)                      {                          buffer[@out++] = (byte)(bits << (6 - bitsRemaining));                          bitsRemaining = 0;                      }                  }                  else if (digit != 0xff)                  {                      bits = (bits << 6) | digit;                      bitsRemaining += 6;                  }                    if (bitsRemaining >= 8)                  {                      bitsRemaining -= 8;                      buffer[@out++] = (byte)(bits >> bitsRemaining);                  }              }
Magic Number,NuoDb.Data.Client,DataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\DataStream.cs,setBase64,The following statement contains a magic number: for (int n = 0; n < length; ++n)              {                  char c = data[@in++];                  int digit = base64Lookup[c];                    if (c == '=')                  {                      if (bitsRemaining > 0)                      {                          buffer[@out++] = (byte)(bits << (6 - bitsRemaining));                          bitsRemaining = 0;                      }                  }                  else if (digit != 0xff)                  {                      bits = (bits << 6) | digit;                      bitsRemaining += 6;                  }                    if (bitsRemaining >= 8)                  {                      bitsRemaining -= 8;                      buffer[@out++] = (byte)(bits >> bitsRemaining);                  }              }
Magic Number,NuoDb.Data.Client,DataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\DataStream.cs,putBase64,The following statement contains a magic number: for (DataSegment segment = firstSegment; segment != null; segment = segment.next)              {                  length += segment.length;                    for (int n = 0; n < segment.length; )                  {                      if (bitsRemaining < 6)                      {                          bits = (bits << 8) | (segment.buffer[n++] & 0xff);                          bitsRemaining += 8;                      }                        while (bitsRemaining >= 6)                      {                          bitsRemaining -= 6;                          int digit = (bits >> bitsRemaining) & 0x3f;                          byte c = base64Digits[digit];                          ++@out;                          outputStream.WriteByte(c);                      }                  }              }
Magic Number,NuoDb.Data.Client,DataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\DataStream.cs,putBase64,The following statement contains a magic number: for (DataSegment segment = firstSegment; segment != null; segment = segment.next)              {                  length += segment.length;                    for (int n = 0; n < segment.length; )                  {                      if (bitsRemaining < 6)                      {                          bits = (bits << 8) | (segment.buffer[n++] & 0xff);                          bitsRemaining += 8;                      }                        while (bitsRemaining >= 6)                      {                          bitsRemaining -= 6;                          int digit = (bits >> bitsRemaining) & 0x3f;                          byte c = base64Digits[digit];                          ++@out;                          outputStream.WriteByte(c);                      }                  }              }
Magic Number,NuoDb.Data.Client,DataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\DataStream.cs,putBase64,The following statement contains a magic number: for (DataSegment segment = firstSegment; segment != null; segment = segment.next)              {                  length += segment.length;                    for (int n = 0; n < segment.length; )                  {                      if (bitsRemaining < 6)                      {                          bits = (bits << 8) | (segment.buffer[n++] & 0xff);                          bitsRemaining += 8;                      }                        while (bitsRemaining >= 6)                      {                          bitsRemaining -= 6;                          int digit = (bits >> bitsRemaining) & 0x3f;                          byte c = base64Digits[digit];                          ++@out;                          outputStream.WriteByte(c);                      }                  }              }
Magic Number,NuoDb.Data.Client,DataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\DataStream.cs,putBase64,The following statement contains a magic number: for (DataSegment segment = firstSegment; segment != null; segment = segment.next)              {                  length += segment.length;                    for (int n = 0; n < segment.length; )                  {                      if (bitsRemaining < 6)                      {                          bits = (bits << 8) | (segment.buffer[n++] & 0xff);                          bitsRemaining += 8;                      }                        while (bitsRemaining >= 6)                      {                          bitsRemaining -= 6;                          int digit = (bits >> bitsRemaining) & 0x3f;                          byte c = base64Digits[digit];                          ++@out;                          outputStream.WriteByte(c);                      }                  }              }
Magic Number,NuoDb.Data.Client,DataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\DataStream.cs,putBase64,The following statement contains a magic number: for (DataSegment segment = firstSegment; segment != null; segment = segment.next)              {                  length += segment.length;                    for (int n = 0; n < segment.length; )                  {                      if (bitsRemaining < 6)                      {                          bits = (bits << 8) | (segment.buffer[n++] & 0xff);                          bitsRemaining += 8;                      }                        while (bitsRemaining >= 6)                      {                          bitsRemaining -= 6;                          int digit = (bits >> bitsRemaining) & 0x3f;                          byte c = base64Digits[digit];                          ++@out;                          outputStream.WriteByte(c);                      }                  }              }
Magic Number,NuoDb.Data.Client,DataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\DataStream.cs,putBase64,The following statement contains a magic number: int mod = length % 3;
Magic Number,NuoDb.Data.Client,DataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\DataStream.cs,putBase64,The following statement contains a magic number: if (mod > 0)              {                  outputStream.WriteByte(base64Digits[(bits << (6 - bitsRemaining)) & 0x3f]);                    for (int n = 3; n > mod; --n)                  {                      outputStream.WriteByte((byte)'=');                  }              }
Magic Number,NuoDb.Data.Client,DataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\DataStream.cs,putBase64,The following statement contains a magic number: if (mod > 0)              {                  outputStream.WriteByte(base64Digits[(bits << (6 - bitsRemaining)) & 0x3f]);                    for (int n = 3; n > mod; --n)                  {                      outputStream.WriteByte((byte)'=');                  }              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,ConvertToScaledDecimal,The following statement contains a magic number: while ((temp % 1) != 0)              {                  scale++;                  temp *= 10;              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,The following statement contains a magic number: if (n >= 0)              {                  if (n < (1 << 7))                  {                      return 1;                  }                    if (n < (1 << 15))                  {                      return 2;                  }                    if (n < (1 << 23))                  {                      return 3;                  }                    return 4;              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,The following statement contains a magic number: if (n >= 0)              {                  if (n < (1 << 7))                  {                      return 1;                  }                    if (n < (1 << 15))                  {                      return 2;                  }                    if (n < (1 << 23))                  {                      return 3;                  }                    return 4;              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,The following statement contains a magic number: if (n >= 0)              {                  if (n < (1 << 7))                  {                      return 1;                  }                    if (n < (1 << 15))                  {                      return 2;                  }                    if (n < (1 << 23))                  {                      return 3;                  }                    return 4;              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,The following statement contains a magic number: if (n >= 0)              {                  if (n < (1 << 7))                  {                      return 1;                  }                    if (n < (1 << 15))                  {                      return 2;                  }                    if (n < (1 << 23))                  {                      return 3;                  }                    return 4;              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,The following statement contains a magic number: if (n >= 0)              {                  if (n < (1 << 7))                  {                      return 1;                  }                    if (n < (1 << 15))                  {                      return 2;                  }                    if (n < (1 << 23))                  {                      return 3;                  }                    return 4;              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,The following statement contains a magic number: if (n >= 0)              {                  if (n < (1 << 7))                  {                      return 1;                  }                    if (n < (1 << 15))                  {                      return 2;                  }                    if (n < (1 << 23))                  {                      return 3;                  }                    return 4;              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,The following statement contains a magic number: if (n >= -(1 << 7))              {                  return 1;              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,The following statement contains a magic number: if (n >= -(1 << 15))              {                  return 2;              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,The following statement contains a magic number: if (n >= -(1 << 15))              {                  return 2;              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,The following statement contains a magic number: if (n >= -(1 << 23))              {                  return 3;              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,The following statement contains a magic number: if (n >= -(1 << 23))              {                  return 3;              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,The following statement contains a magic number: return 4;
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,The following statement contains a magic number: if (n > 0)              {                  if (n == 0)                  {                      return 0;                  }                    if (n < (1L << 7))                  {                      return 1;                  }                    if (n < (1L << 15))                  {                      return 2;                  }                    if (n < (1L << 23))                  {                      return 3;                  }                    if (n < (1L << 31))                  {                      return 4;                  }                    if (n < (1L << 39))                  {                      return 5;                  }                    if (n < (1L << 47))                  {                      return 6;                  }                    if (n < (1L << 55))                  {                      return 7;                  }                    return 8;              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,The following statement contains a magic number: if (n > 0)              {                  if (n == 0)                  {                      return 0;                  }                    if (n < (1L << 7))                  {                      return 1;                  }                    if (n < (1L << 15))                  {                      return 2;                  }                    if (n < (1L << 23))                  {                      return 3;                  }                    if (n < (1L << 31))                  {                      return 4;                  }                    if (n < (1L << 39))                  {                      return 5;                  }                    if (n < (1L << 47))                  {                      return 6;                  }                    if (n < (1L << 55))                  {                      return 7;                  }                    return 8;              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,The following statement contains a magic number: if (n > 0)              {                  if (n == 0)                  {                      return 0;                  }                    if (n < (1L << 7))                  {                      return 1;                  }                    if (n < (1L << 15))                  {                      return 2;                  }                    if (n < (1L << 23))                  {                      return 3;                  }                    if (n < (1L << 31))                  {                      return 4;                  }                    if (n < (1L << 39))                  {                      return 5;                  }                    if (n < (1L << 47))                  {                      return 6;                  }                    if (n < (1L << 55))                  {                      return 7;                  }                    return 8;              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,The following statement contains a magic number: if (n > 0)              {                  if (n == 0)                  {                      return 0;                  }                    if (n < (1L << 7))                  {                      return 1;                  }                    if (n < (1L << 15))                  {                      return 2;                  }                    if (n < (1L << 23))                  {                      return 3;                  }                    if (n < (1L << 31))                  {                      return 4;                  }                    if (n < (1L << 39))                  {                      return 5;                  }                    if (n < (1L << 47))                  {                      return 6;                  }                    if (n < (1L << 55))                  {                      return 7;                  }                    return 8;              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,The following statement contains a magic number: if (n > 0)              {                  if (n == 0)                  {                      return 0;                  }                    if (n < (1L << 7))                  {                      return 1;                  }                    if (n < (1L << 15))                  {                      return 2;                  }                    if (n < (1L << 23))                  {                      return 3;                  }                    if (n < (1L << 31))                  {                      return 4;                  }                    if (n < (1L << 39))                  {                      return 5;                  }                    if (n < (1L << 47))                  {                      return 6;                  }                    if (n < (1L << 55))                  {                      return 7;                  }                    return 8;              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,The following statement contains a magic number: if (n > 0)              {                  if (n == 0)                  {                      return 0;                  }                    if (n < (1L << 7))                  {                      return 1;                  }                    if (n < (1L << 15))                  {                      return 2;                  }                    if (n < (1L << 23))                  {                      return 3;                  }                    if (n < (1L << 31))                  {                      return 4;                  }                    if (n < (1L << 39))                  {                      return 5;                  }                    if (n < (1L << 47))                  {                      return 6;                  }                    if (n < (1L << 55))                  {                      return 7;                  }                    return 8;              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,The following statement contains a magic number: if (n > 0)              {                  if (n == 0)                  {                      return 0;                  }                    if (n < (1L << 7))                  {                      return 1;                  }                    if (n < (1L << 15))                  {                      return 2;                  }                    if (n < (1L << 23))                  {                      return 3;                  }                    if (n < (1L << 31))                  {                      return 4;                  }                    if (n < (1L << 39))                  {                      return 5;                  }                    if (n < (1L << 47))                  {                      return 6;                  }                    if (n < (1L << 55))                  {                      return 7;                  }                    return 8;              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,The following statement contains a magic number: if (n > 0)              {                  if (n == 0)                  {                      return 0;                  }                    if (n < (1L << 7))                  {                      return 1;                  }                    if (n < (1L << 15))                  {                      return 2;                  }                    if (n < (1L << 23))                  {                      return 3;                  }                    if (n < (1L << 31))                  {                      return 4;                  }                    if (n < (1L << 39))                  {                      return 5;                  }                    if (n < (1L << 47))                  {                      return 6;                  }                    if (n < (1L << 55))                  {                      return 7;                  }                    return 8;              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,The following statement contains a magic number: if (n > 0)              {                  if (n == 0)                  {                      return 0;                  }                    if (n < (1L << 7))                  {                      return 1;                  }                    if (n < (1L << 15))                  {                      return 2;                  }                    if (n < (1L << 23))                  {                      return 3;                  }                    if (n < (1L << 31))                  {                      return 4;                  }                    if (n < (1L << 39))                  {                      return 5;                  }                    if (n < (1L << 47))                  {                      return 6;                  }                    if (n < (1L << 55))                  {                      return 7;                  }                    return 8;              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,The following statement contains a magic number: if (n > 0)              {                  if (n == 0)                  {                      return 0;                  }                    if (n < (1L << 7))                  {                      return 1;                  }                    if (n < (1L << 15))                  {                      return 2;                  }                    if (n < (1L << 23))                  {                      return 3;                  }                    if (n < (1L << 31))                  {                      return 4;                  }                    if (n < (1L << 39))                  {                      return 5;                  }                    if (n < (1L << 47))                  {                      return 6;                  }                    if (n < (1L << 55))                  {                      return 7;                  }                    return 8;              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,The following statement contains a magic number: if (n > 0)              {                  if (n == 0)                  {                      return 0;                  }                    if (n < (1L << 7))                  {                      return 1;                  }                    if (n < (1L << 15))                  {                      return 2;                  }                    if (n < (1L << 23))                  {                      return 3;                  }                    if (n < (1L << 31))                  {                      return 4;                  }                    if (n < (1L << 39))                  {                      return 5;                  }                    if (n < (1L << 47))                  {                      return 6;                  }                    if (n < (1L << 55))                  {                      return 7;                  }                    return 8;              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,The following statement contains a magic number: if (n > 0)              {                  if (n == 0)                  {                      return 0;                  }                    if (n < (1L << 7))                  {                      return 1;                  }                    if (n < (1L << 15))                  {                      return 2;                  }                    if (n < (1L << 23))                  {                      return 3;                  }                    if (n < (1L << 31))                  {                      return 4;                  }                    if (n < (1L << 39))                  {                      return 5;                  }                    if (n < (1L << 47))                  {                      return 6;                  }                    if (n < (1L << 55))                  {                      return 7;                  }                    return 8;              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,The following statement contains a magic number: if (n > 0)              {                  if (n == 0)                  {                      return 0;                  }                    if (n < (1L << 7))                  {                      return 1;                  }                    if (n < (1L << 15))                  {                      return 2;                  }                    if (n < (1L << 23))                  {                      return 3;                  }                    if (n < (1L << 31))                  {                      return 4;                  }                    if (n < (1L << 39))                  {                      return 5;                  }                    if (n < (1L << 47))                  {                      return 6;                  }                    if (n < (1L << 55))                  {                      return 7;                  }                    return 8;              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,The following statement contains a magic number: if (n > 0)              {                  if (n == 0)                  {                      return 0;                  }                    if (n < (1L << 7))                  {                      return 1;                  }                    if (n < (1L << 15))                  {                      return 2;                  }                    if (n < (1L << 23))                  {                      return 3;                  }                    if (n < (1L << 31))                  {                      return 4;                  }                    if (n < (1L << 39))                  {                      return 5;                  }                    if (n < (1L << 47))                  {                      return 6;                  }                    if (n < (1L << 55))                  {                      return 7;                  }                    return 8;              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,The following statement contains a magic number: if (n >= -(1L << 7))              {                  return 1;              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,The following statement contains a magic number: if (n >= -(1L << 15))              {                  return 2;              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,The following statement contains a magic number: if (n >= -(1L << 15))              {                  return 2;              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,The following statement contains a magic number: if (n >= -(1L << 23))              {                  return 3;              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,The following statement contains a magic number: if (n >= -(1L << 23))              {                  return 3;              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,The following statement contains a magic number: if (n >= -(1L << 31))              {                  return 4;              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,The following statement contains a magic number: if (n >= -(1L << 31))              {                  return 4;              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,The following statement contains a magic number: if (n >= -(1L << 39))              {                  return 5;              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,The following statement contains a magic number: if (n >= -(1L << 39))              {                  return 5;              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,The following statement contains a magic number: if (n >= -(1L << 47))              {                  return 6;              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,The following statement contains a magic number: if (n >= -(1L << 47))              {                  return 6;              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,The following statement contains a magic number: if (n >= -(1L << 55))              {                  return 7;              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,The following statement contains a magic number: if (n >= -(1L << 55))              {                  return 7;              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,byteCount,The following statement contains a magic number: return 8;
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,encodeArray,The following statement contains a magic number: for (int shift = (count - 1) * 8; shift >= 0; shift -= 8)              {                  write(rows.Length >> shift);              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,encodeArray,The following statement contains a magic number: for (int shift = (count - 1) * 8; shift >= 0; shift -= 8)              {                  write(rows.Length >> shift);              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,encodeArray,The following statement contains a magic number: foreach (IDataRecord record in rows)              {                  int numFields = record.FieldCount;                    write(edsArrayLen1 + numFields - 1);                    for (int shift = (numFields - 1) * 8; shift >= 0; shift -= 8)                  {                      write(numFields >> shift);                  }                  for (int column = 0; column < numFields; column++)                  {                      encodeDotNetObject(record[column]);                  }              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,encodeArray,The following statement contains a magic number: foreach (IDataRecord record in rows)              {                  int numFields = record.FieldCount;                    write(edsArrayLen1 + numFields - 1);                    for (int shift = (numFields - 1) * 8; shift >= 0; shift -= 8)                  {                      write(numFields >> shift);                  }                  for (int column = 0; column < numFields; column++)                  {                      encodeDotNetObject(record[column]);                  }              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,encodeArray,The following statement contains a magic number: for (int shift = (count - 1) * 8; shift >= 0; shift -= 8)              {                  write(rows.Rows.Count >> shift);              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,encodeArray,The following statement contains a magic number: for (int shift = (count - 1) * 8; shift >= 0; shift -= 8)              {                  write(rows.Rows.Count >> shift);              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,encodeArray,The following statement contains a magic number: foreach (DataRow record in rows.Rows)              {                  int numFields = record.ItemArray.Length;                    write(edsArrayLen1 + numFields - 1);                    for (int shift = (numFields - 1) * 8; shift >= 0; shift -= 8)                  {                      write(numFields >> shift);                  }                  for (int column = 0; column < numFields; column++)                  {                      encodeDotNetObject(record[column]);                  }              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,encodeArray,The following statement contains a magic number: foreach (DataRow record in rows.Rows)              {                  int numFields = record.ItemArray.Length;                    write(edsArrayLen1 + numFields - 1);                    for (int shift = (numFields - 1) * 8; shift >= 0; shift -= 8)                  {                      write(numFields >> shift);                  }                  for (int column = 0; column < numFields; column++)                  {                      encodeDotNetObject(record[column]);                  }              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,encodeInt,The following statement contains a magic number: for (int shift = (count - 1) * 8; shift >= 0; shift -= 8)              {                  write(value >> shift);              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,encodeInt,The following statement contains a magic number: for (int shift = (count - 1) * 8; shift >= 0; shift -= 8)              {                  write(value >> shift);              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,encodeLong,The following statement contains a magic number: for (int shift = (count - 1) * 8; shift >= 0; shift -= 8)              {                  write((int)(value >> shift));              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,encodeLong,The following statement contains a magic number: for (int shift = (count - 1) * 8; shift >= 0; shift -= 8)              {                  write((int)(value >> shift));              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,encodeLong,The following statement contains a magic number: for (int shift = (count - 1) * 8; shift >= 0; shift -= 8)              {                  write((int)(value >> shift));              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,encodeLong,The following statement contains a magic number: for (int shift = (count - 1) * 8; shift >= 0; shift -= 8)              {                  write((int)(value >> shift));              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,encodeInt,The following statement contains a magic number: for (int shift = (count - 1) * 8; shift >= 0; shift -= 8)              {                  write(value >> shift);              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,encodeInt,The following statement contains a magic number: for (int shift = (count - 1) * 8; shift >= 0; shift -= 8)              {                  write(value >> shift);              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,encodeTimestamp,The following statement contains a magic number: for (int shift = (count - 1) * 8; shift >= 0; shift -= 8)              {                  write((int)(value >> shift));              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,encodeTimestamp,The following statement contains a magic number: for (int shift = (count - 1) * 8; shift >= 0; shift -= 8)              {                  write((int)(value >> shift));              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,encodeScaledTimestamp,The following statement contains a magic number: for (int shift = (count - 1) * 8; shift >= 0; shift -= 8)              {                  write((int)(nanos >> shift));              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,encodeScaledTimestamp,The following statement contains a magic number: for (int shift = (count - 1) * 8; shift >= 0; shift -= 8)              {                  write((int)(nanos >> shift));              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,decode,The following statement contains a magic number: switch (code)              {                  case edsNull:                      type = edsTypeNull;                      break;                    case edsTrue:                      type = edsTypeBoolean;                      @bool = true;                      break;                    case edsFalse:                      type = edsTypeBoolean;                      @bool = false;                      break;                    case edsIntMinus10:                  case edsIntMinus9:                  case edsIntMinus8:                  case edsIntMinus7:                  case edsIntMinus6:                  case edsIntMinus5:                  case edsIntMinus4:                  case edsIntMinus3:                  case edsIntMinus2:                  case edsIntMinus1:                  case edsInt0:                  case edsInt1:                  case edsInt2:                  case edsInt3:                  case edsInt4:                  case edsInt5:                  case edsInt6:                  case edsInt7:                  case edsInt8:                  case edsInt9:                  case edsInt10:                  case edsInt11:                  case edsInt12:                  case edsInt13:                  case edsInt14:                  case edsInt15:                  case edsInt16:                  case edsInt17:                  case edsInt18:                  case edsInt19:                  case edsInt20:                  case edsInt21:                  case edsInt22:                  case edsInt23:                  case edsInt24:                  case edsInt25:                  case edsInt26:                  case edsInt27:                  case edsInt28:                  case edsInt29:                  case edsInt30:                  case edsInt31:                      integer32 = code - edsInt0;                      scale = 0;                      type = edsTypeInt32;                      break;                    case edsIntLen1:                      type = edsTypeInt32;                      scale = 0;                      integer32 = (sbyte)source[offset++];                      break;                    case edsIntLen2:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset] << 8) | (source[offset + 1] & 0xff);                      offset += 2;                      break;                    case edsIntLen3:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset]) << 16 | (source[offset + 1] & 0xff) << 8 | (source[offset + 2] & 0xff);                      offset += 3;                      break;                    case edsIntLen4:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset]) << 24 | (source[offset + 1] & 0xff) << 16 | (source[offset + 2] & 0xff) << 8 | (source[offset + 3] & 0xff);                      offset += 4;                      break;                    case edsIntLen5:                  case edsIntLen6:                  case edsIntLen7:                  case edsIntLen8:                      l = code - edsIntLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeInt64;                      break;                    case edsScaledLen0:                      scale = (sbyte)source[offset++];                      integer64 = 0;                      type = edsTypeScaled;                      break;                    case edsScaledLen1:                  case edsScaledLen2:                  case edsScaledLen3:                  case edsScaledLen4:                  case edsScaledLen5:                  case edsScaledLen6:                  case edsScaledLen7:                  case edsScaledLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaled;                      break;                    case edsUtf8Len0:                  case edsUtf8Len1:                  case edsUtf8Len2:                  case edsUtf8Len3:                  case edsUtf8Len4:                  case edsUtf8Len5:                  case edsUtf8Len6:                  case edsUtf8Len7:                  case edsUtf8Len8:                  case edsUtf8Len9:                  case edsUtf8Len10:                  case edsUtf8Len11:                  case edsUtf8Len12:                  case edsUtf8Len13:                  case edsUtf8Len14:                  case edsUtf8Len15:                  case edsUtf8Len16:                  case edsUtf8Len17:                  case edsUtf8Len18:                  case edsUtf8Len19:                  case edsUtf8Len20:                  case edsUtf8Len21:                  case edsUtf8Len22:                  case edsUtf8Len23:                  case edsUtf8Len24:                  case edsUtf8Len25:                  case edsUtf8Len26:                  case edsUtf8Len27:                  case edsUtf8Len28:                  case edsUtf8Len29:                  case edsUtf8Len30:                  case edsUtf8Len31:                  case edsUtf8Len32:                  case edsUtf8Len33:                  case edsUtf8Len34:                  case edsUtf8Len35:                  case edsUtf8Len36:                  case edsUtf8Len37:                  case edsUtf8Len38:                  case edsUtf8Len39:                      l = code - edsUtf8Len0;                      @string = getString(source' offset' l);                      offset += l;                      type = edsTypeUtf8;                      break;                    case edsUtf8Count1:                  case edsUtf8Count2:                  case edsUtf8Count3:                  case edsUtf8Count4:                      count = code - edsUtf8Count1;                      int length = source[offset++] & 0xff;                        for (int n = 0; n < count; ++n)                      {                          length = length << 8 | (source[offset++] & 0xff);                      }                        @string = getString(source' offset' length);                      offset += length;                      type = edsTypeUtf8;                      break;                    case edsOpaqueLen0:                  case edsOpaqueLen1:                  case edsOpaqueLen2:                  case edsOpaqueLen3:                  case edsOpaqueLen4:                  case edsOpaqueLen5:                  case edsOpaqueLen6:                  case edsOpaqueLen7:                  case edsOpaqueLen8:                  case edsOpaqueLen9:                  case edsOpaqueLen10:                  case edsOpaqueLen11:                  case edsOpaqueLen12:                  case edsOpaqueLen13:                  case edsOpaqueLen14:                  case edsOpaqueLen15:                  case edsOpaqueLen16:                  case edsOpaqueLen17:                  case edsOpaqueLen18:                  case edsOpaqueLen19:                  case edsOpaqueLen20:                  case edsOpaqueLen21:                  case edsOpaqueLen22:                  case edsOpaqueLen23:                  case edsOpaqueLen24:                  case edsOpaqueLen25:                  case edsOpaqueLen26:                  case edsOpaqueLen27:                  case edsOpaqueLen28:                  case edsOpaqueLen29:                  case edsOpaqueLen30:                  case edsOpaqueLen31:                  case edsOpaqueLen32:                  case edsOpaqueLen33:                  case edsOpaqueLen34:                  case edsOpaqueLen35:                  case edsOpaqueLen36:                  case edsOpaqueLen37:                  case edsOpaqueLen38:                  case edsOpaqueLen39:                      l = code - edsOpaqueLen0;                      bytes = new byte[l];                      Array.Copy(source' offset' bytes' 0' l);                      offset += l;                      type = edsTypeOpaque;                      break;                    case edsOpaqueCount1:                  case edsOpaqueCount2:                  case edsOpaqueCount3:                  case edsOpaqueCount4:                      count = code - edsOpaqueCount1 + 1;                      l = source[offset++] & 0xff;                        for (int n = 1; n < count; ++n)                      {                          l = l << 8 | (source[offset++] & 0xff);                      }                        bytes = new byte[l];                      Array.Copy(source' offset' bytes' 0' l);                      offset += l;                      type = edsTypeOpaque;                      break;                    case edsDoubleLen0:                  case edsDoubleLen1:                  case edsDoubleLen2:                  case edsDoubleLen3:                  case edsDoubleLen4:                  case edsDoubleLen5:                  case edsDoubleLen6:                  case edsDoubleLen7:                  case edsDoubleLen8:                      count = code - edsDoubleLen0;                      long lvalue = 0;                        for (int n = 0; n < count; ++n)                      {                          lvalue = (lvalue << 8) | (source[offset++] & 0xff);                      }                        lvalue <<= (8 - count) * 8;                      dbl = BitConverter.Int64BitsToDouble(lvalue);                      type = edsTypeDouble;                      break;                    case edsTimeLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeTime;                      break;                    case edsTimeLen1:                  case edsTimeLen2:                  case edsTimeLen3:                  case edsTimeLen4:                      l = code - edsTimeLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeTime;                      break;                    case edsMilliSecLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeMilliseconds;                      break;                    case edsMilliSecLen1:                  case edsMilliSecLen2:                  case edsMilliSecLen3:                  case edsMilliSecLen4:                  case edsMilliSecLen5:                  case edsMilliSecLen6:                  case edsMilliSecLen7:                  case edsMilliSecLen8:                      l = code - edsMilliSecLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeMilliseconds;                      break;                    case edsNanoSecLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeNanoseconds;                      break;                    case edsNanoSecLen1:                  case edsNanoSecLen2:                  case edsNanoSecLen3:                  case edsNanoSecLen4:                  case edsNanoSecLen5:                  case edsNanoSecLen6:                  case edsNanoSecLen7:                  case edsNanoSecLen8:                      l = code - edsNanoSecLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeNanoseconds;                      break;                    //                  // 09/2012 Added support for new scaled date/times encoding. These replace the old encoding                  // edsTimeLen' edsMilliSecLen and edsNanoSecLen.                  //                    case edsScaledTimeLen1:                  case edsScaledTimeLen2:                  case edsScaledTimeLen3:                  case edsScaledTimeLen4:                  case edsScaledTimeLen5:                  case edsScaledTimeLen6:                  case edsScaledTimeLen7:                  case edsScaledTimeLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledTimeLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledTime;                      break;                    case edsScaledDateLen1:                  case edsScaledDateLen2:                  case edsScaledDateLen3:                  case edsScaledDateLen4:                  case edsScaledDateLen5:                  case edsScaledDateLen6:                  case edsScaledDateLen7:                  case edsScaledDateLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledDateLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledDate;                      break;                    case edsScaledTimestampLen1:                  case edsScaledTimestampLen2:                  case edsScaledTimestampLen3:                  case edsScaledTimestampLen4:                  case edsScaledTimestampLen5:                  case edsScaledTimestampLen6:                  case edsScaledTimestampLen7:                  case edsScaledTimestampLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledTimestampLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledTimestamp;                      break;                    case edsClobLen0:                      blobId = 0;                      type = edsTypeClob;                      break;                    case edsClobLen1:                  case edsClobLen2:                  case edsClobLen3:                  case edsClobLen4:                      l = code - edsClobLen1;                      blobId = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          blobId = (blobId << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeClob;                      break;                    case edsBlobLen0:                      blobId = 0;                      type = edsTypeBlob;                      break;                    case edsBlobLen1:                  case edsBlobLen2:                  case edsBlobLen3:                  case edsBlobLen4:                      l = code - edsBlobLen1;                      blobId = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          blobId = (blobId << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeBlob;                      break;                    case edsScaledCount1:                      {                          // For some reason C++ EncodedStream expects the encoded                          // length to be length+1.                            length = (source[offset++] & 0xff) - 1;                          scale = (sbyte)source[offset++];                          type = edsTypeBigInt;                          bytes = new byte[length];                          Array.Copy(source' offset' bytes' 0' length);                          offset += length;                          int sign = ((bytes[0] & 0x80) > 0) ? -1 : 1;                            if (sign == -1)                          {                              bytes[0] &= 0x7f;                          }                            BigInteger bi = new BigInteger(bytes);                          bigDecimal = Decimal.Parse(bi.ToString());                      }                      break;                    case edsScaledCount2:                      {                          // For some reason C++ EncodedStream expects the encoded                          // length to be length+1.                            scale = (sbyte)source[offset++];                          sbyte sign = (sbyte)source[offset++];                          length = (source[offset++] & 0xff); // in bytes                          type = edsTypeBigInt;                          bytes = new byte[length];                          Array.Copy(source' offset' bytes' 0' length);                          offset += length;                            if (sign == -1)                              bytes[0] &= 0x7f;                          else                              sign = 1;                            BigInteger bi = new BigInteger(bytes);                          if (sign == -1)                              bi = -bi;                          bigDecimal = ScaleDecimal(Decimal.Parse(bi.ToString())' scale);                      }                      break;                    case edsUUID:                      {                          byte[] buff = new byte[16];                            for (int n = 0; n < 16; ++n)                          {                              buff[n] = (byte)(source[offset++] & 0xff);                          }                            uuid = new Guid(buff);                          type = edsTypeUUID;                      }                      break;                    default:                      type = edsTypeUnknown;                      break;              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,decode,The following statement contains a magic number: switch (code)              {                  case edsNull:                      type = edsTypeNull;                      break;                    case edsTrue:                      type = edsTypeBoolean;                      @bool = true;                      break;                    case edsFalse:                      type = edsTypeBoolean;                      @bool = false;                      break;                    case edsIntMinus10:                  case edsIntMinus9:                  case edsIntMinus8:                  case edsIntMinus7:                  case edsIntMinus6:                  case edsIntMinus5:                  case edsIntMinus4:                  case edsIntMinus3:                  case edsIntMinus2:                  case edsIntMinus1:                  case edsInt0:                  case edsInt1:                  case edsInt2:                  case edsInt3:                  case edsInt4:                  case edsInt5:                  case edsInt6:                  case edsInt7:                  case edsInt8:                  case edsInt9:                  case edsInt10:                  case edsInt11:                  case edsInt12:                  case edsInt13:                  case edsInt14:                  case edsInt15:                  case edsInt16:                  case edsInt17:                  case edsInt18:                  case edsInt19:                  case edsInt20:                  case edsInt21:                  case edsInt22:                  case edsInt23:                  case edsInt24:                  case edsInt25:                  case edsInt26:                  case edsInt27:                  case edsInt28:                  case edsInt29:                  case edsInt30:                  case edsInt31:                      integer32 = code - edsInt0;                      scale = 0;                      type = edsTypeInt32;                      break;                    case edsIntLen1:                      type = edsTypeInt32;                      scale = 0;                      integer32 = (sbyte)source[offset++];                      break;                    case edsIntLen2:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset] << 8) | (source[offset + 1] & 0xff);                      offset += 2;                      break;                    case edsIntLen3:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset]) << 16 | (source[offset + 1] & 0xff) << 8 | (source[offset + 2] & 0xff);                      offset += 3;                      break;                    case edsIntLen4:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset]) << 24 | (source[offset + 1] & 0xff) << 16 | (source[offset + 2] & 0xff) << 8 | (source[offset + 3] & 0xff);                      offset += 4;                      break;                    case edsIntLen5:                  case edsIntLen6:                  case edsIntLen7:                  case edsIntLen8:                      l = code - edsIntLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeInt64;                      break;                    case edsScaledLen0:                      scale = (sbyte)source[offset++];                      integer64 = 0;                      type = edsTypeScaled;                      break;                    case edsScaledLen1:                  case edsScaledLen2:                  case edsScaledLen3:                  case edsScaledLen4:                  case edsScaledLen5:                  case edsScaledLen6:                  case edsScaledLen7:                  case edsScaledLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaled;                      break;                    case edsUtf8Len0:                  case edsUtf8Len1:                  case edsUtf8Len2:                  case edsUtf8Len3:                  case edsUtf8Len4:                  case edsUtf8Len5:                  case edsUtf8Len6:                  case edsUtf8Len7:                  case edsUtf8Len8:                  case edsUtf8Len9:                  case edsUtf8Len10:                  case edsUtf8Len11:                  case edsUtf8Len12:                  case edsUtf8Len13:                  case edsUtf8Len14:                  case edsUtf8Len15:                  case edsUtf8Len16:                  case edsUtf8Len17:                  case edsUtf8Len18:                  case edsUtf8Len19:                  case edsUtf8Len20:                  case edsUtf8Len21:                  case edsUtf8Len22:                  case edsUtf8Len23:                  case edsUtf8Len24:                  case edsUtf8Len25:                  case edsUtf8Len26:                  case edsUtf8Len27:                  case edsUtf8Len28:                  case edsUtf8Len29:                  case edsUtf8Len30:                  case edsUtf8Len31:                  case edsUtf8Len32:                  case edsUtf8Len33:                  case edsUtf8Len34:                  case edsUtf8Len35:                  case edsUtf8Len36:                  case edsUtf8Len37:                  case edsUtf8Len38:                  case edsUtf8Len39:                      l = code - edsUtf8Len0;                      @string = getString(source' offset' l);                      offset += l;                      type = edsTypeUtf8;                      break;                    case edsUtf8Count1:                  case edsUtf8Count2:                  case edsUtf8Count3:                  case edsUtf8Count4:                      count = code - edsUtf8Count1;                      int length = source[offset++] & 0xff;                        for (int n = 0; n < count; ++n)                      {                          length = length << 8 | (source[offset++] & 0xff);                      }                        @string = getString(source' offset' length);                      offset += length;                      type = edsTypeUtf8;                      break;                    case edsOpaqueLen0:                  case edsOpaqueLen1:                  case edsOpaqueLen2:                  case edsOpaqueLen3:                  case edsOpaqueLen4:                  case edsOpaqueLen5:                  case edsOpaqueLen6:                  case edsOpaqueLen7:                  case edsOpaqueLen8:                  case edsOpaqueLen9:                  case edsOpaqueLen10:                  case edsOpaqueLen11:                  case edsOpaqueLen12:                  case edsOpaqueLen13:                  case edsOpaqueLen14:                  case edsOpaqueLen15:                  case edsOpaqueLen16:                  case edsOpaqueLen17:                  case edsOpaqueLen18:                  case edsOpaqueLen19:                  case edsOpaqueLen20:                  case edsOpaqueLen21:                  case edsOpaqueLen22:                  case edsOpaqueLen23:                  case edsOpaqueLen24:                  case edsOpaqueLen25:                  case edsOpaqueLen26:                  case edsOpaqueLen27:                  case edsOpaqueLen28:                  case edsOpaqueLen29:                  case edsOpaqueLen30:                  case edsOpaqueLen31:                  case edsOpaqueLen32:                  case edsOpaqueLen33:                  case edsOpaqueLen34:                  case edsOpaqueLen35:                  case edsOpaqueLen36:                  case edsOpaqueLen37:                  case edsOpaqueLen38:                  case edsOpaqueLen39:                      l = code - edsOpaqueLen0;                      bytes = new byte[l];                      Array.Copy(source' offset' bytes' 0' l);                      offset += l;                      type = edsTypeOpaque;                      break;                    case edsOpaqueCount1:                  case edsOpaqueCount2:                  case edsOpaqueCount3:                  case edsOpaqueCount4:                      count = code - edsOpaqueCount1 + 1;                      l = source[offset++] & 0xff;                        for (int n = 1; n < count; ++n)                      {                          l = l << 8 | (source[offset++] & 0xff);                      }                        bytes = new byte[l];                      Array.Copy(source' offset' bytes' 0' l);                      offset += l;                      type = edsTypeOpaque;                      break;                    case edsDoubleLen0:                  case edsDoubleLen1:                  case edsDoubleLen2:                  case edsDoubleLen3:                  case edsDoubleLen4:                  case edsDoubleLen5:                  case edsDoubleLen6:                  case edsDoubleLen7:                  case edsDoubleLen8:                      count = code - edsDoubleLen0;                      long lvalue = 0;                        for (int n = 0; n < count; ++n)                      {                          lvalue = (lvalue << 8) | (source[offset++] & 0xff);                      }                        lvalue <<= (8 - count) * 8;                      dbl = BitConverter.Int64BitsToDouble(lvalue);                      type = edsTypeDouble;                      break;                    case edsTimeLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeTime;                      break;                    case edsTimeLen1:                  case edsTimeLen2:                  case edsTimeLen3:                  case edsTimeLen4:                      l = code - edsTimeLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeTime;                      break;                    case edsMilliSecLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeMilliseconds;                      break;                    case edsMilliSecLen1:                  case edsMilliSecLen2:                  case edsMilliSecLen3:                  case edsMilliSecLen4:                  case edsMilliSecLen5:                  case edsMilliSecLen6:                  case edsMilliSecLen7:                  case edsMilliSecLen8:                      l = code - edsMilliSecLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeMilliseconds;                      break;                    case edsNanoSecLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeNanoseconds;                      break;                    case edsNanoSecLen1:                  case edsNanoSecLen2:                  case edsNanoSecLen3:                  case edsNanoSecLen4:                  case edsNanoSecLen5:                  case edsNanoSecLen6:                  case edsNanoSecLen7:                  case edsNanoSecLen8:                      l = code - edsNanoSecLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeNanoseconds;                      break;                    //                  // 09/2012 Added support for new scaled date/times encoding. These replace the old encoding                  // edsTimeLen' edsMilliSecLen and edsNanoSecLen.                  //                    case edsScaledTimeLen1:                  case edsScaledTimeLen2:                  case edsScaledTimeLen3:                  case edsScaledTimeLen4:                  case edsScaledTimeLen5:                  case edsScaledTimeLen6:                  case edsScaledTimeLen7:                  case edsScaledTimeLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledTimeLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledTime;                      break;                    case edsScaledDateLen1:                  case edsScaledDateLen2:                  case edsScaledDateLen3:                  case edsScaledDateLen4:                  case edsScaledDateLen5:                  case edsScaledDateLen6:                  case edsScaledDateLen7:                  case edsScaledDateLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledDateLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledDate;                      break;                    case edsScaledTimestampLen1:                  case edsScaledTimestampLen2:                  case edsScaledTimestampLen3:                  case edsScaledTimestampLen4:                  case edsScaledTimestampLen5:                  case edsScaledTimestampLen6:                  case edsScaledTimestampLen7:                  case edsScaledTimestampLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledTimestampLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledTimestamp;                      break;                    case edsClobLen0:                      blobId = 0;                      type = edsTypeClob;                      break;                    case edsClobLen1:                  case edsClobLen2:                  case edsClobLen3:                  case edsClobLen4:                      l = code - edsClobLen1;                      blobId = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          blobId = (blobId << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeClob;                      break;                    case edsBlobLen0:                      blobId = 0;                      type = edsTypeBlob;                      break;                    case edsBlobLen1:                  case edsBlobLen2:                  case edsBlobLen3:                  case edsBlobLen4:                      l = code - edsBlobLen1;                      blobId = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          blobId = (blobId << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeBlob;                      break;                    case edsScaledCount1:                      {                          // For some reason C++ EncodedStream expects the encoded                          // length to be length+1.                            length = (source[offset++] & 0xff) - 1;                          scale = (sbyte)source[offset++];                          type = edsTypeBigInt;                          bytes = new byte[length];                          Array.Copy(source' offset' bytes' 0' length);                          offset += length;                          int sign = ((bytes[0] & 0x80) > 0) ? -1 : 1;                            if (sign == -1)                          {                              bytes[0] &= 0x7f;                          }                            BigInteger bi = new BigInteger(bytes);                          bigDecimal = Decimal.Parse(bi.ToString());                      }                      break;                    case edsScaledCount2:                      {                          // For some reason C++ EncodedStream expects the encoded                          // length to be length+1.                            scale = (sbyte)source[offset++];                          sbyte sign = (sbyte)source[offset++];                          length = (source[offset++] & 0xff); // in bytes                          type = edsTypeBigInt;                          bytes = new byte[length];                          Array.Copy(source' offset' bytes' 0' length);                          offset += length;                            if (sign == -1)                              bytes[0] &= 0x7f;                          else                              sign = 1;                            BigInteger bi = new BigInteger(bytes);                          if (sign == -1)                              bi = -bi;                          bigDecimal = ScaleDecimal(Decimal.Parse(bi.ToString())' scale);                      }                      break;                    case edsUUID:                      {                          byte[] buff = new byte[16];                            for (int n = 0; n < 16; ++n)                          {                              buff[n] = (byte)(source[offset++] & 0xff);                          }                            uuid = new Guid(buff);                          type = edsTypeUUID;                      }                      break;                    default:                      type = edsTypeUnknown;                      break;              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,decode,The following statement contains a magic number: switch (code)              {                  case edsNull:                      type = edsTypeNull;                      break;                    case edsTrue:                      type = edsTypeBoolean;                      @bool = true;                      break;                    case edsFalse:                      type = edsTypeBoolean;                      @bool = false;                      break;                    case edsIntMinus10:                  case edsIntMinus9:                  case edsIntMinus8:                  case edsIntMinus7:                  case edsIntMinus6:                  case edsIntMinus5:                  case edsIntMinus4:                  case edsIntMinus3:                  case edsIntMinus2:                  case edsIntMinus1:                  case edsInt0:                  case edsInt1:                  case edsInt2:                  case edsInt3:                  case edsInt4:                  case edsInt5:                  case edsInt6:                  case edsInt7:                  case edsInt8:                  case edsInt9:                  case edsInt10:                  case edsInt11:                  case edsInt12:                  case edsInt13:                  case edsInt14:                  case edsInt15:                  case edsInt16:                  case edsInt17:                  case edsInt18:                  case edsInt19:                  case edsInt20:                  case edsInt21:                  case edsInt22:                  case edsInt23:                  case edsInt24:                  case edsInt25:                  case edsInt26:                  case edsInt27:                  case edsInt28:                  case edsInt29:                  case edsInt30:                  case edsInt31:                      integer32 = code - edsInt0;                      scale = 0;                      type = edsTypeInt32;                      break;                    case edsIntLen1:                      type = edsTypeInt32;                      scale = 0;                      integer32 = (sbyte)source[offset++];                      break;                    case edsIntLen2:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset] << 8) | (source[offset + 1] & 0xff);                      offset += 2;                      break;                    case edsIntLen3:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset]) << 16 | (source[offset + 1] & 0xff) << 8 | (source[offset + 2] & 0xff);                      offset += 3;                      break;                    case edsIntLen4:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset]) << 24 | (source[offset + 1] & 0xff) << 16 | (source[offset + 2] & 0xff) << 8 | (source[offset + 3] & 0xff);                      offset += 4;                      break;                    case edsIntLen5:                  case edsIntLen6:                  case edsIntLen7:                  case edsIntLen8:                      l = code - edsIntLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeInt64;                      break;                    case edsScaledLen0:                      scale = (sbyte)source[offset++];                      integer64 = 0;                      type = edsTypeScaled;                      break;                    case edsScaledLen1:                  case edsScaledLen2:                  case edsScaledLen3:                  case edsScaledLen4:                  case edsScaledLen5:                  case edsScaledLen6:                  case edsScaledLen7:                  case edsScaledLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaled;                      break;                    case edsUtf8Len0:                  case edsUtf8Len1:                  case edsUtf8Len2:                  case edsUtf8Len3:                  case edsUtf8Len4:                  case edsUtf8Len5:                  case edsUtf8Len6:                  case edsUtf8Len7:                  case edsUtf8Len8:                  case edsUtf8Len9:                  case edsUtf8Len10:                  case edsUtf8Len11:                  case edsUtf8Len12:                  case edsUtf8Len13:                  case edsUtf8Len14:                  case edsUtf8Len15:                  case edsUtf8Len16:                  case edsUtf8Len17:                  case edsUtf8Len18:                  case edsUtf8Len19:                  case edsUtf8Len20:                  case edsUtf8Len21:                  case edsUtf8Len22:                  case edsUtf8Len23:                  case edsUtf8Len24:                  case edsUtf8Len25:                  case edsUtf8Len26:                  case edsUtf8Len27:                  case edsUtf8Len28:                  case edsUtf8Len29:                  case edsUtf8Len30:                  case edsUtf8Len31:                  case edsUtf8Len32:                  case edsUtf8Len33:                  case edsUtf8Len34:                  case edsUtf8Len35:                  case edsUtf8Len36:                  case edsUtf8Len37:                  case edsUtf8Len38:                  case edsUtf8Len39:                      l = code - edsUtf8Len0;                      @string = getString(source' offset' l);                      offset += l;                      type = edsTypeUtf8;                      break;                    case edsUtf8Count1:                  case edsUtf8Count2:                  case edsUtf8Count3:                  case edsUtf8Count4:                      count = code - edsUtf8Count1;                      int length = source[offset++] & 0xff;                        for (int n = 0; n < count; ++n)                      {                          length = length << 8 | (source[offset++] & 0xff);                      }                        @string = getString(source' offset' length);                      offset += length;                      type = edsTypeUtf8;                      break;                    case edsOpaqueLen0:                  case edsOpaqueLen1:                  case edsOpaqueLen2:                  case edsOpaqueLen3:                  case edsOpaqueLen4:                  case edsOpaqueLen5:                  case edsOpaqueLen6:                  case edsOpaqueLen7:                  case edsOpaqueLen8:                  case edsOpaqueLen9:                  case edsOpaqueLen10:                  case edsOpaqueLen11:                  case edsOpaqueLen12:                  case edsOpaqueLen13:                  case edsOpaqueLen14:                  case edsOpaqueLen15:                  case edsOpaqueLen16:                  case edsOpaqueLen17:                  case edsOpaqueLen18:                  case edsOpaqueLen19:                  case edsOpaqueLen20:                  case edsOpaqueLen21:                  case edsOpaqueLen22:                  case edsOpaqueLen23:                  case edsOpaqueLen24:                  case edsOpaqueLen25:                  case edsOpaqueLen26:                  case edsOpaqueLen27:                  case edsOpaqueLen28:                  case edsOpaqueLen29:                  case edsOpaqueLen30:                  case edsOpaqueLen31:                  case edsOpaqueLen32:                  case edsOpaqueLen33:                  case edsOpaqueLen34:                  case edsOpaqueLen35:                  case edsOpaqueLen36:                  case edsOpaqueLen37:                  case edsOpaqueLen38:                  case edsOpaqueLen39:                      l = code - edsOpaqueLen0;                      bytes = new byte[l];                      Array.Copy(source' offset' bytes' 0' l);                      offset += l;                      type = edsTypeOpaque;                      break;                    case edsOpaqueCount1:                  case edsOpaqueCount2:                  case edsOpaqueCount3:                  case edsOpaqueCount4:                      count = code - edsOpaqueCount1 + 1;                      l = source[offset++] & 0xff;                        for (int n = 1; n < count; ++n)                      {                          l = l << 8 | (source[offset++] & 0xff);                      }                        bytes = new byte[l];                      Array.Copy(source' offset' bytes' 0' l);                      offset += l;                      type = edsTypeOpaque;                      break;                    case edsDoubleLen0:                  case edsDoubleLen1:                  case edsDoubleLen2:                  case edsDoubleLen3:                  case edsDoubleLen4:                  case edsDoubleLen5:                  case edsDoubleLen6:                  case edsDoubleLen7:                  case edsDoubleLen8:                      count = code - edsDoubleLen0;                      long lvalue = 0;                        for (int n = 0; n < count; ++n)                      {                          lvalue = (lvalue << 8) | (source[offset++] & 0xff);                      }                        lvalue <<= (8 - count) * 8;                      dbl = BitConverter.Int64BitsToDouble(lvalue);                      type = edsTypeDouble;                      break;                    case edsTimeLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeTime;                      break;                    case edsTimeLen1:                  case edsTimeLen2:                  case edsTimeLen3:                  case edsTimeLen4:                      l = code - edsTimeLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeTime;                      break;                    case edsMilliSecLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeMilliseconds;                      break;                    case edsMilliSecLen1:                  case edsMilliSecLen2:                  case edsMilliSecLen3:                  case edsMilliSecLen4:                  case edsMilliSecLen5:                  case edsMilliSecLen6:                  case edsMilliSecLen7:                  case edsMilliSecLen8:                      l = code - edsMilliSecLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeMilliseconds;                      break;                    case edsNanoSecLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeNanoseconds;                      break;                    case edsNanoSecLen1:                  case edsNanoSecLen2:                  case edsNanoSecLen3:                  case edsNanoSecLen4:                  case edsNanoSecLen5:                  case edsNanoSecLen6:                  case edsNanoSecLen7:                  case edsNanoSecLen8:                      l = code - edsNanoSecLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeNanoseconds;                      break;                    //                  // 09/2012 Added support for new scaled date/times encoding. These replace the old encoding                  // edsTimeLen' edsMilliSecLen and edsNanoSecLen.                  //                    case edsScaledTimeLen1:                  case edsScaledTimeLen2:                  case edsScaledTimeLen3:                  case edsScaledTimeLen4:                  case edsScaledTimeLen5:                  case edsScaledTimeLen6:                  case edsScaledTimeLen7:                  case edsScaledTimeLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledTimeLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledTime;                      break;                    case edsScaledDateLen1:                  case edsScaledDateLen2:                  case edsScaledDateLen3:                  case edsScaledDateLen4:                  case edsScaledDateLen5:                  case edsScaledDateLen6:                  case edsScaledDateLen7:                  case edsScaledDateLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledDateLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledDate;                      break;                    case edsScaledTimestampLen1:                  case edsScaledTimestampLen2:                  case edsScaledTimestampLen3:                  case edsScaledTimestampLen4:                  case edsScaledTimestampLen5:                  case edsScaledTimestampLen6:                  case edsScaledTimestampLen7:                  case edsScaledTimestampLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledTimestampLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledTimestamp;                      break;                    case edsClobLen0:                      blobId = 0;                      type = edsTypeClob;                      break;                    case edsClobLen1:                  case edsClobLen2:                  case edsClobLen3:                  case edsClobLen4:                      l = code - edsClobLen1;                      blobId = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          blobId = (blobId << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeClob;                      break;                    case edsBlobLen0:                      blobId = 0;                      type = edsTypeBlob;                      break;                    case edsBlobLen1:                  case edsBlobLen2:                  case edsBlobLen3:                  case edsBlobLen4:                      l = code - edsBlobLen1;                      blobId = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          blobId = (blobId << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeBlob;                      break;                    case edsScaledCount1:                      {                          // For some reason C++ EncodedStream expects the encoded                          // length to be length+1.                            length = (source[offset++] & 0xff) - 1;                          scale = (sbyte)source[offset++];                          type = edsTypeBigInt;                          bytes = new byte[length];                          Array.Copy(source' offset' bytes' 0' length);                          offset += length;                          int sign = ((bytes[0] & 0x80) > 0) ? -1 : 1;                            if (sign == -1)                          {                              bytes[0] &= 0x7f;                          }                            BigInteger bi = new BigInteger(bytes);                          bigDecimal = Decimal.Parse(bi.ToString());                      }                      break;                    case edsScaledCount2:                      {                          // For some reason C++ EncodedStream expects the encoded                          // length to be length+1.                            scale = (sbyte)source[offset++];                          sbyte sign = (sbyte)source[offset++];                          length = (source[offset++] & 0xff); // in bytes                          type = edsTypeBigInt;                          bytes = new byte[length];                          Array.Copy(source' offset' bytes' 0' length);                          offset += length;                            if (sign == -1)                              bytes[0] &= 0x7f;                          else                              sign = 1;                            BigInteger bi = new BigInteger(bytes);                          if (sign == -1)                              bi = -bi;                          bigDecimal = ScaleDecimal(Decimal.Parse(bi.ToString())' scale);                      }                      break;                    case edsUUID:                      {                          byte[] buff = new byte[16];                            for (int n = 0; n < 16; ++n)                          {                              buff[n] = (byte)(source[offset++] & 0xff);                          }                            uuid = new Guid(buff);                          type = edsTypeUUID;                      }                      break;                    default:                      type = edsTypeUnknown;                      break;              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,decode,The following statement contains a magic number: switch (code)              {                  case edsNull:                      type = edsTypeNull;                      break;                    case edsTrue:                      type = edsTypeBoolean;                      @bool = true;                      break;                    case edsFalse:                      type = edsTypeBoolean;                      @bool = false;                      break;                    case edsIntMinus10:                  case edsIntMinus9:                  case edsIntMinus8:                  case edsIntMinus7:                  case edsIntMinus6:                  case edsIntMinus5:                  case edsIntMinus4:                  case edsIntMinus3:                  case edsIntMinus2:                  case edsIntMinus1:                  case edsInt0:                  case edsInt1:                  case edsInt2:                  case edsInt3:                  case edsInt4:                  case edsInt5:                  case edsInt6:                  case edsInt7:                  case edsInt8:                  case edsInt9:                  case edsInt10:                  case edsInt11:                  case edsInt12:                  case edsInt13:                  case edsInt14:                  case edsInt15:                  case edsInt16:                  case edsInt17:                  case edsInt18:                  case edsInt19:                  case edsInt20:                  case edsInt21:                  case edsInt22:                  case edsInt23:                  case edsInt24:                  case edsInt25:                  case edsInt26:                  case edsInt27:                  case edsInt28:                  case edsInt29:                  case edsInt30:                  case edsInt31:                      integer32 = code - edsInt0;                      scale = 0;                      type = edsTypeInt32;                      break;                    case edsIntLen1:                      type = edsTypeInt32;                      scale = 0;                      integer32 = (sbyte)source[offset++];                      break;                    case edsIntLen2:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset] << 8) | (source[offset + 1] & 0xff);                      offset += 2;                      break;                    case edsIntLen3:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset]) << 16 | (source[offset + 1] & 0xff) << 8 | (source[offset + 2] & 0xff);                      offset += 3;                      break;                    case edsIntLen4:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset]) << 24 | (source[offset + 1] & 0xff) << 16 | (source[offset + 2] & 0xff) << 8 | (source[offset + 3] & 0xff);                      offset += 4;                      break;                    case edsIntLen5:                  case edsIntLen6:                  case edsIntLen7:                  case edsIntLen8:                      l = code - edsIntLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeInt64;                      break;                    case edsScaledLen0:                      scale = (sbyte)source[offset++];                      integer64 = 0;                      type = edsTypeScaled;                      break;                    case edsScaledLen1:                  case edsScaledLen2:                  case edsScaledLen3:                  case edsScaledLen4:                  case edsScaledLen5:                  case edsScaledLen6:                  case edsScaledLen7:                  case edsScaledLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaled;                      break;                    case edsUtf8Len0:                  case edsUtf8Len1:                  case edsUtf8Len2:                  case edsUtf8Len3:                  case edsUtf8Len4:                  case edsUtf8Len5:                  case edsUtf8Len6:                  case edsUtf8Len7:                  case edsUtf8Len8:                  case edsUtf8Len9:                  case edsUtf8Len10:                  case edsUtf8Len11:                  case edsUtf8Len12:                  case edsUtf8Len13:                  case edsUtf8Len14:                  case edsUtf8Len15:                  case edsUtf8Len16:                  case edsUtf8Len17:                  case edsUtf8Len18:                  case edsUtf8Len19:                  case edsUtf8Len20:                  case edsUtf8Len21:                  case edsUtf8Len22:                  case edsUtf8Len23:                  case edsUtf8Len24:                  case edsUtf8Len25:                  case edsUtf8Len26:                  case edsUtf8Len27:                  case edsUtf8Len28:                  case edsUtf8Len29:                  case edsUtf8Len30:                  case edsUtf8Len31:                  case edsUtf8Len32:                  case edsUtf8Len33:                  case edsUtf8Len34:                  case edsUtf8Len35:                  case edsUtf8Len36:                  case edsUtf8Len37:                  case edsUtf8Len38:                  case edsUtf8Len39:                      l = code - edsUtf8Len0;                      @string = getString(source' offset' l);                      offset += l;                      type = edsTypeUtf8;                      break;                    case edsUtf8Count1:                  case edsUtf8Count2:                  case edsUtf8Count3:                  case edsUtf8Count4:                      count = code - edsUtf8Count1;                      int length = source[offset++] & 0xff;                        for (int n = 0; n < count; ++n)                      {                          length = length << 8 | (source[offset++] & 0xff);                      }                        @string = getString(source' offset' length);                      offset += length;                      type = edsTypeUtf8;                      break;                    case edsOpaqueLen0:                  case edsOpaqueLen1:                  case edsOpaqueLen2:                  case edsOpaqueLen3:                  case edsOpaqueLen4:                  case edsOpaqueLen5:                  case edsOpaqueLen6:                  case edsOpaqueLen7:                  case edsOpaqueLen8:                  case edsOpaqueLen9:                  case edsOpaqueLen10:                  case edsOpaqueLen11:                  case edsOpaqueLen12:                  case edsOpaqueLen13:                  case edsOpaqueLen14:                  case edsOpaqueLen15:                  case edsOpaqueLen16:                  case edsOpaqueLen17:                  case edsOpaqueLen18:                  case edsOpaqueLen19:                  case edsOpaqueLen20:                  case edsOpaqueLen21:                  case edsOpaqueLen22:                  case edsOpaqueLen23:                  case edsOpaqueLen24:                  case edsOpaqueLen25:                  case edsOpaqueLen26:                  case edsOpaqueLen27:                  case edsOpaqueLen28:                  case edsOpaqueLen29:                  case edsOpaqueLen30:                  case edsOpaqueLen31:                  case edsOpaqueLen32:                  case edsOpaqueLen33:                  case edsOpaqueLen34:                  case edsOpaqueLen35:                  case edsOpaqueLen36:                  case edsOpaqueLen37:                  case edsOpaqueLen38:                  case edsOpaqueLen39:                      l = code - edsOpaqueLen0;                      bytes = new byte[l];                      Array.Copy(source' offset' bytes' 0' l);                      offset += l;                      type = edsTypeOpaque;                      break;                    case edsOpaqueCount1:                  case edsOpaqueCount2:                  case edsOpaqueCount3:                  case edsOpaqueCount4:                      count = code - edsOpaqueCount1 + 1;                      l = source[offset++] & 0xff;                        for (int n = 1; n < count; ++n)                      {                          l = l << 8 | (source[offset++] & 0xff);                      }                        bytes = new byte[l];                      Array.Copy(source' offset' bytes' 0' l);                      offset += l;                      type = edsTypeOpaque;                      break;                    case edsDoubleLen0:                  case edsDoubleLen1:                  case edsDoubleLen2:                  case edsDoubleLen3:                  case edsDoubleLen4:                  case edsDoubleLen5:                  case edsDoubleLen6:                  case edsDoubleLen7:                  case edsDoubleLen8:                      count = code - edsDoubleLen0;                      long lvalue = 0;                        for (int n = 0; n < count; ++n)                      {                          lvalue = (lvalue << 8) | (source[offset++] & 0xff);                      }                        lvalue <<= (8 - count) * 8;                      dbl = BitConverter.Int64BitsToDouble(lvalue);                      type = edsTypeDouble;                      break;                    case edsTimeLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeTime;                      break;                    case edsTimeLen1:                  case edsTimeLen2:                  case edsTimeLen3:                  case edsTimeLen4:                      l = code - edsTimeLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeTime;                      break;                    case edsMilliSecLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeMilliseconds;                      break;                    case edsMilliSecLen1:                  case edsMilliSecLen2:                  case edsMilliSecLen3:                  case edsMilliSecLen4:                  case edsMilliSecLen5:                  case edsMilliSecLen6:                  case edsMilliSecLen7:                  case edsMilliSecLen8:                      l = code - edsMilliSecLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeMilliseconds;                      break;                    case edsNanoSecLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeNanoseconds;                      break;                    case edsNanoSecLen1:                  case edsNanoSecLen2:                  case edsNanoSecLen3:                  case edsNanoSecLen4:                  case edsNanoSecLen5:                  case edsNanoSecLen6:                  case edsNanoSecLen7:                  case edsNanoSecLen8:                      l = code - edsNanoSecLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeNanoseconds;                      break;                    //                  // 09/2012 Added support for new scaled date/times encoding. These replace the old encoding                  // edsTimeLen' edsMilliSecLen and edsNanoSecLen.                  //                    case edsScaledTimeLen1:                  case edsScaledTimeLen2:                  case edsScaledTimeLen3:                  case edsScaledTimeLen4:                  case edsScaledTimeLen5:                  case edsScaledTimeLen6:                  case edsScaledTimeLen7:                  case edsScaledTimeLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledTimeLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledTime;                      break;                    case edsScaledDateLen1:                  case edsScaledDateLen2:                  case edsScaledDateLen3:                  case edsScaledDateLen4:                  case edsScaledDateLen5:                  case edsScaledDateLen6:                  case edsScaledDateLen7:                  case edsScaledDateLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledDateLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledDate;                      break;                    case edsScaledTimestampLen1:                  case edsScaledTimestampLen2:                  case edsScaledTimestampLen3:                  case edsScaledTimestampLen4:                  case edsScaledTimestampLen5:                  case edsScaledTimestampLen6:                  case edsScaledTimestampLen7:                  case edsScaledTimestampLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledTimestampLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledTimestamp;                      break;                    case edsClobLen0:                      blobId = 0;                      type = edsTypeClob;                      break;                    case edsClobLen1:                  case edsClobLen2:                  case edsClobLen3:                  case edsClobLen4:                      l = code - edsClobLen1;                      blobId = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          blobId = (blobId << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeClob;                      break;                    case edsBlobLen0:                      blobId = 0;                      type = edsTypeBlob;                      break;                    case edsBlobLen1:                  case edsBlobLen2:                  case edsBlobLen3:                  case edsBlobLen4:                      l = code - edsBlobLen1;                      blobId = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          blobId = (blobId << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeBlob;                      break;                    case edsScaledCount1:                      {                          // For some reason C++ EncodedStream expects the encoded                          // length to be length+1.                            length = (source[offset++] & 0xff) - 1;                          scale = (sbyte)source[offset++];                          type = edsTypeBigInt;                          bytes = new byte[length];                          Array.Copy(source' offset' bytes' 0' length);                          offset += length;                          int sign = ((bytes[0] & 0x80) > 0) ? -1 : 1;                            if (sign == -1)                          {                              bytes[0] &= 0x7f;                          }                            BigInteger bi = new BigInteger(bytes);                          bigDecimal = Decimal.Parse(bi.ToString());                      }                      break;                    case edsScaledCount2:                      {                          // For some reason C++ EncodedStream expects the encoded                          // length to be length+1.                            scale = (sbyte)source[offset++];                          sbyte sign = (sbyte)source[offset++];                          length = (source[offset++] & 0xff); // in bytes                          type = edsTypeBigInt;                          bytes = new byte[length];                          Array.Copy(source' offset' bytes' 0' length);                          offset += length;                            if (sign == -1)                              bytes[0] &= 0x7f;                          else                              sign = 1;                            BigInteger bi = new BigInteger(bytes);                          if (sign == -1)                              bi = -bi;                          bigDecimal = ScaleDecimal(Decimal.Parse(bi.ToString())' scale);                      }                      break;                    case edsUUID:                      {                          byte[] buff = new byte[16];                            for (int n = 0; n < 16; ++n)                          {                              buff[n] = (byte)(source[offset++] & 0xff);                          }                            uuid = new Guid(buff);                          type = edsTypeUUID;                      }                      break;                    default:                      type = edsTypeUnknown;                      break;              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,decode,The following statement contains a magic number: switch (code)              {                  case edsNull:                      type = edsTypeNull;                      break;                    case edsTrue:                      type = edsTypeBoolean;                      @bool = true;                      break;                    case edsFalse:                      type = edsTypeBoolean;                      @bool = false;                      break;                    case edsIntMinus10:                  case edsIntMinus9:                  case edsIntMinus8:                  case edsIntMinus7:                  case edsIntMinus6:                  case edsIntMinus5:                  case edsIntMinus4:                  case edsIntMinus3:                  case edsIntMinus2:                  case edsIntMinus1:                  case edsInt0:                  case edsInt1:                  case edsInt2:                  case edsInt3:                  case edsInt4:                  case edsInt5:                  case edsInt6:                  case edsInt7:                  case edsInt8:                  case edsInt9:                  case edsInt10:                  case edsInt11:                  case edsInt12:                  case edsInt13:                  case edsInt14:                  case edsInt15:                  case edsInt16:                  case edsInt17:                  case edsInt18:                  case edsInt19:                  case edsInt20:                  case edsInt21:                  case edsInt22:                  case edsInt23:                  case edsInt24:                  case edsInt25:                  case edsInt26:                  case edsInt27:                  case edsInt28:                  case edsInt29:                  case edsInt30:                  case edsInt31:                      integer32 = code - edsInt0;                      scale = 0;                      type = edsTypeInt32;                      break;                    case edsIntLen1:                      type = edsTypeInt32;                      scale = 0;                      integer32 = (sbyte)source[offset++];                      break;                    case edsIntLen2:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset] << 8) | (source[offset + 1] & 0xff);                      offset += 2;                      break;                    case edsIntLen3:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset]) << 16 | (source[offset + 1] & 0xff) << 8 | (source[offset + 2] & 0xff);                      offset += 3;                      break;                    case edsIntLen4:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset]) << 24 | (source[offset + 1] & 0xff) << 16 | (source[offset + 2] & 0xff) << 8 | (source[offset + 3] & 0xff);                      offset += 4;                      break;                    case edsIntLen5:                  case edsIntLen6:                  case edsIntLen7:                  case edsIntLen8:                      l = code - edsIntLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeInt64;                      break;                    case edsScaledLen0:                      scale = (sbyte)source[offset++];                      integer64 = 0;                      type = edsTypeScaled;                      break;                    case edsScaledLen1:                  case edsScaledLen2:                  case edsScaledLen3:                  case edsScaledLen4:                  case edsScaledLen5:                  case edsScaledLen6:                  case edsScaledLen7:                  case edsScaledLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaled;                      break;                    case edsUtf8Len0:                  case edsUtf8Len1:                  case edsUtf8Len2:                  case edsUtf8Len3:                  case edsUtf8Len4:                  case edsUtf8Len5:                  case edsUtf8Len6:                  case edsUtf8Len7:                  case edsUtf8Len8:                  case edsUtf8Len9:                  case edsUtf8Len10:                  case edsUtf8Len11:                  case edsUtf8Len12:                  case edsUtf8Len13:                  case edsUtf8Len14:                  case edsUtf8Len15:                  case edsUtf8Len16:                  case edsUtf8Len17:                  case edsUtf8Len18:                  case edsUtf8Len19:                  case edsUtf8Len20:                  case edsUtf8Len21:                  case edsUtf8Len22:                  case edsUtf8Len23:                  case edsUtf8Len24:                  case edsUtf8Len25:                  case edsUtf8Len26:                  case edsUtf8Len27:                  case edsUtf8Len28:                  case edsUtf8Len29:                  case edsUtf8Len30:                  case edsUtf8Len31:                  case edsUtf8Len32:                  case edsUtf8Len33:                  case edsUtf8Len34:                  case edsUtf8Len35:                  case edsUtf8Len36:                  case edsUtf8Len37:                  case edsUtf8Len38:                  case edsUtf8Len39:                      l = code - edsUtf8Len0;                      @string = getString(source' offset' l);                      offset += l;                      type = edsTypeUtf8;                      break;                    case edsUtf8Count1:                  case edsUtf8Count2:                  case edsUtf8Count3:                  case edsUtf8Count4:                      count = code - edsUtf8Count1;                      int length = source[offset++] & 0xff;                        for (int n = 0; n < count; ++n)                      {                          length = length << 8 | (source[offset++] & 0xff);                      }                        @string = getString(source' offset' length);                      offset += length;                      type = edsTypeUtf8;                      break;                    case edsOpaqueLen0:                  case edsOpaqueLen1:                  case edsOpaqueLen2:                  case edsOpaqueLen3:                  case edsOpaqueLen4:                  case edsOpaqueLen5:                  case edsOpaqueLen6:                  case edsOpaqueLen7:                  case edsOpaqueLen8:                  case edsOpaqueLen9:                  case edsOpaqueLen10:                  case edsOpaqueLen11:                  case edsOpaqueLen12:                  case edsOpaqueLen13:                  case edsOpaqueLen14:                  case edsOpaqueLen15:                  case edsOpaqueLen16:                  case edsOpaqueLen17:                  case edsOpaqueLen18:                  case edsOpaqueLen19:                  case edsOpaqueLen20:                  case edsOpaqueLen21:                  case edsOpaqueLen22:                  case edsOpaqueLen23:                  case edsOpaqueLen24:                  case edsOpaqueLen25:                  case edsOpaqueLen26:                  case edsOpaqueLen27:                  case edsOpaqueLen28:                  case edsOpaqueLen29:                  case edsOpaqueLen30:                  case edsOpaqueLen31:                  case edsOpaqueLen32:                  case edsOpaqueLen33:                  case edsOpaqueLen34:                  case edsOpaqueLen35:                  case edsOpaqueLen36:                  case edsOpaqueLen37:                  case edsOpaqueLen38:                  case edsOpaqueLen39:                      l = code - edsOpaqueLen0;                      bytes = new byte[l];                      Array.Copy(source' offset' bytes' 0' l);                      offset += l;                      type = edsTypeOpaque;                      break;                    case edsOpaqueCount1:                  case edsOpaqueCount2:                  case edsOpaqueCount3:                  case edsOpaqueCount4:                      count = code - edsOpaqueCount1 + 1;                      l = source[offset++] & 0xff;                        for (int n = 1; n < count; ++n)                      {                          l = l << 8 | (source[offset++] & 0xff);                      }                        bytes = new byte[l];                      Array.Copy(source' offset' bytes' 0' l);                      offset += l;                      type = edsTypeOpaque;                      break;                    case edsDoubleLen0:                  case edsDoubleLen1:                  case edsDoubleLen2:                  case edsDoubleLen3:                  case edsDoubleLen4:                  case edsDoubleLen5:                  case edsDoubleLen6:                  case edsDoubleLen7:                  case edsDoubleLen8:                      count = code - edsDoubleLen0;                      long lvalue = 0;                        for (int n = 0; n < count; ++n)                      {                          lvalue = (lvalue << 8) | (source[offset++] & 0xff);                      }                        lvalue <<= (8 - count) * 8;                      dbl = BitConverter.Int64BitsToDouble(lvalue);                      type = edsTypeDouble;                      break;                    case edsTimeLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeTime;                      break;                    case edsTimeLen1:                  case edsTimeLen2:                  case edsTimeLen3:                  case edsTimeLen4:                      l = code - edsTimeLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeTime;                      break;                    case edsMilliSecLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeMilliseconds;                      break;                    case edsMilliSecLen1:                  case edsMilliSecLen2:                  case edsMilliSecLen3:                  case edsMilliSecLen4:                  case edsMilliSecLen5:                  case edsMilliSecLen6:                  case edsMilliSecLen7:                  case edsMilliSecLen8:                      l = code - edsMilliSecLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeMilliseconds;                      break;                    case edsNanoSecLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeNanoseconds;                      break;                    case edsNanoSecLen1:                  case edsNanoSecLen2:                  case edsNanoSecLen3:                  case edsNanoSecLen4:                  case edsNanoSecLen5:                  case edsNanoSecLen6:                  case edsNanoSecLen7:                  case edsNanoSecLen8:                      l = code - edsNanoSecLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeNanoseconds;                      break;                    //                  // 09/2012 Added support for new scaled date/times encoding. These replace the old encoding                  // edsTimeLen' edsMilliSecLen and edsNanoSecLen.                  //                    case edsScaledTimeLen1:                  case edsScaledTimeLen2:                  case edsScaledTimeLen3:                  case edsScaledTimeLen4:                  case edsScaledTimeLen5:                  case edsScaledTimeLen6:                  case edsScaledTimeLen7:                  case edsScaledTimeLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledTimeLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledTime;                      break;                    case edsScaledDateLen1:                  case edsScaledDateLen2:                  case edsScaledDateLen3:                  case edsScaledDateLen4:                  case edsScaledDateLen5:                  case edsScaledDateLen6:                  case edsScaledDateLen7:                  case edsScaledDateLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledDateLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledDate;                      break;                    case edsScaledTimestampLen1:                  case edsScaledTimestampLen2:                  case edsScaledTimestampLen3:                  case edsScaledTimestampLen4:                  case edsScaledTimestampLen5:                  case edsScaledTimestampLen6:                  case edsScaledTimestampLen7:                  case edsScaledTimestampLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledTimestampLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledTimestamp;                      break;                    case edsClobLen0:                      blobId = 0;                      type = edsTypeClob;                      break;                    case edsClobLen1:                  case edsClobLen2:                  case edsClobLen3:                  case edsClobLen4:                      l = code - edsClobLen1;                      blobId = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          blobId = (blobId << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeClob;                      break;                    case edsBlobLen0:                      blobId = 0;                      type = edsTypeBlob;                      break;                    case edsBlobLen1:                  case edsBlobLen2:                  case edsBlobLen3:                  case edsBlobLen4:                      l = code - edsBlobLen1;                      blobId = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          blobId = (blobId << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeBlob;                      break;                    case edsScaledCount1:                      {                          // For some reason C++ EncodedStream expects the encoded                          // length to be length+1.                            length = (source[offset++] & 0xff) - 1;                          scale = (sbyte)source[offset++];                          type = edsTypeBigInt;                          bytes = new byte[length];                          Array.Copy(source' offset' bytes' 0' length);                          offset += length;                          int sign = ((bytes[0] & 0x80) > 0) ? -1 : 1;                            if (sign == -1)                          {                              bytes[0] &= 0x7f;                          }                            BigInteger bi = new BigInteger(bytes);                          bigDecimal = Decimal.Parse(bi.ToString());                      }                      break;                    case edsScaledCount2:                      {                          // For some reason C++ EncodedStream expects the encoded                          // length to be length+1.                            scale = (sbyte)source[offset++];                          sbyte sign = (sbyte)source[offset++];                          length = (source[offset++] & 0xff); // in bytes                          type = edsTypeBigInt;                          bytes = new byte[length];                          Array.Copy(source' offset' bytes' 0' length);                          offset += length;                            if (sign == -1)                              bytes[0] &= 0x7f;                          else                              sign = 1;                            BigInteger bi = new BigInteger(bytes);                          if (sign == -1)                              bi = -bi;                          bigDecimal = ScaleDecimal(Decimal.Parse(bi.ToString())' scale);                      }                      break;                    case edsUUID:                      {                          byte[] buff = new byte[16];                            for (int n = 0; n < 16; ++n)                          {                              buff[n] = (byte)(source[offset++] & 0xff);                          }                            uuid = new Guid(buff);                          type = edsTypeUUID;                      }                      break;                    default:                      type = edsTypeUnknown;                      break;              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,decode,The following statement contains a magic number: switch (code)              {                  case edsNull:                      type = edsTypeNull;                      break;                    case edsTrue:                      type = edsTypeBoolean;                      @bool = true;                      break;                    case edsFalse:                      type = edsTypeBoolean;                      @bool = false;                      break;                    case edsIntMinus10:                  case edsIntMinus9:                  case edsIntMinus8:                  case edsIntMinus7:                  case edsIntMinus6:                  case edsIntMinus5:                  case edsIntMinus4:                  case edsIntMinus3:                  case edsIntMinus2:                  case edsIntMinus1:                  case edsInt0:                  case edsInt1:                  case edsInt2:                  case edsInt3:                  case edsInt4:                  case edsInt5:                  case edsInt6:                  case edsInt7:                  case edsInt8:                  case edsInt9:                  case edsInt10:                  case edsInt11:                  case edsInt12:                  case edsInt13:                  case edsInt14:                  case edsInt15:                  case edsInt16:                  case edsInt17:                  case edsInt18:                  case edsInt19:                  case edsInt20:                  case edsInt21:                  case edsInt22:                  case edsInt23:                  case edsInt24:                  case edsInt25:                  case edsInt26:                  case edsInt27:                  case edsInt28:                  case edsInt29:                  case edsInt30:                  case edsInt31:                      integer32 = code - edsInt0;                      scale = 0;                      type = edsTypeInt32;                      break;                    case edsIntLen1:                      type = edsTypeInt32;                      scale = 0;                      integer32 = (sbyte)source[offset++];                      break;                    case edsIntLen2:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset] << 8) | (source[offset + 1] & 0xff);                      offset += 2;                      break;                    case edsIntLen3:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset]) << 16 | (source[offset + 1] & 0xff) << 8 | (source[offset + 2] & 0xff);                      offset += 3;                      break;                    case edsIntLen4:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset]) << 24 | (source[offset + 1] & 0xff) << 16 | (source[offset + 2] & 0xff) << 8 | (source[offset + 3] & 0xff);                      offset += 4;                      break;                    case edsIntLen5:                  case edsIntLen6:                  case edsIntLen7:                  case edsIntLen8:                      l = code - edsIntLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeInt64;                      break;                    case edsScaledLen0:                      scale = (sbyte)source[offset++];                      integer64 = 0;                      type = edsTypeScaled;                      break;                    case edsScaledLen1:                  case edsScaledLen2:                  case edsScaledLen3:                  case edsScaledLen4:                  case edsScaledLen5:                  case edsScaledLen6:                  case edsScaledLen7:                  case edsScaledLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaled;                      break;                    case edsUtf8Len0:                  case edsUtf8Len1:                  case edsUtf8Len2:                  case edsUtf8Len3:                  case edsUtf8Len4:                  case edsUtf8Len5:                  case edsUtf8Len6:                  case edsUtf8Len7:                  case edsUtf8Len8:                  case edsUtf8Len9:                  case edsUtf8Len10:                  case edsUtf8Len11:                  case edsUtf8Len12:                  case edsUtf8Len13:                  case edsUtf8Len14:                  case edsUtf8Len15:                  case edsUtf8Len16:                  case edsUtf8Len17:                  case edsUtf8Len18:                  case edsUtf8Len19:                  case edsUtf8Len20:                  case edsUtf8Len21:                  case edsUtf8Len22:                  case edsUtf8Len23:                  case edsUtf8Len24:                  case edsUtf8Len25:                  case edsUtf8Len26:                  case edsUtf8Len27:                  case edsUtf8Len28:                  case edsUtf8Len29:                  case edsUtf8Len30:                  case edsUtf8Len31:                  case edsUtf8Len32:                  case edsUtf8Len33:                  case edsUtf8Len34:                  case edsUtf8Len35:                  case edsUtf8Len36:                  case edsUtf8Len37:                  case edsUtf8Len38:                  case edsUtf8Len39:                      l = code - edsUtf8Len0;                      @string = getString(source' offset' l);                      offset += l;                      type = edsTypeUtf8;                      break;                    case edsUtf8Count1:                  case edsUtf8Count2:                  case edsUtf8Count3:                  case edsUtf8Count4:                      count = code - edsUtf8Count1;                      int length = source[offset++] & 0xff;                        for (int n = 0; n < count; ++n)                      {                          length = length << 8 | (source[offset++] & 0xff);                      }                        @string = getString(source' offset' length);                      offset += length;                      type = edsTypeUtf8;                      break;                    case edsOpaqueLen0:                  case edsOpaqueLen1:                  case edsOpaqueLen2:                  case edsOpaqueLen3:                  case edsOpaqueLen4:                  case edsOpaqueLen5:                  case edsOpaqueLen6:                  case edsOpaqueLen7:                  case edsOpaqueLen8:                  case edsOpaqueLen9:                  case edsOpaqueLen10:                  case edsOpaqueLen11:                  case edsOpaqueLen12:                  case edsOpaqueLen13:                  case edsOpaqueLen14:                  case edsOpaqueLen15:                  case edsOpaqueLen16:                  case edsOpaqueLen17:                  case edsOpaqueLen18:                  case edsOpaqueLen19:                  case edsOpaqueLen20:                  case edsOpaqueLen21:                  case edsOpaqueLen22:                  case edsOpaqueLen23:                  case edsOpaqueLen24:                  case edsOpaqueLen25:                  case edsOpaqueLen26:                  case edsOpaqueLen27:                  case edsOpaqueLen28:                  case edsOpaqueLen29:                  case edsOpaqueLen30:                  case edsOpaqueLen31:                  case edsOpaqueLen32:                  case edsOpaqueLen33:                  case edsOpaqueLen34:                  case edsOpaqueLen35:                  case edsOpaqueLen36:                  case edsOpaqueLen37:                  case edsOpaqueLen38:                  case edsOpaqueLen39:                      l = code - edsOpaqueLen0;                      bytes = new byte[l];                      Array.Copy(source' offset' bytes' 0' l);                      offset += l;                      type = edsTypeOpaque;                      break;                    case edsOpaqueCount1:                  case edsOpaqueCount2:                  case edsOpaqueCount3:                  case edsOpaqueCount4:                      count = code - edsOpaqueCount1 + 1;                      l = source[offset++] & 0xff;                        for (int n = 1; n < count; ++n)                      {                          l = l << 8 | (source[offset++] & 0xff);                      }                        bytes = new byte[l];                      Array.Copy(source' offset' bytes' 0' l);                      offset += l;                      type = edsTypeOpaque;                      break;                    case edsDoubleLen0:                  case edsDoubleLen1:                  case edsDoubleLen2:                  case edsDoubleLen3:                  case edsDoubleLen4:                  case edsDoubleLen5:                  case edsDoubleLen6:                  case edsDoubleLen7:                  case edsDoubleLen8:                      count = code - edsDoubleLen0;                      long lvalue = 0;                        for (int n = 0; n < count; ++n)                      {                          lvalue = (lvalue << 8) | (source[offset++] & 0xff);                      }                        lvalue <<= (8 - count) * 8;                      dbl = BitConverter.Int64BitsToDouble(lvalue);                      type = edsTypeDouble;                      break;                    case edsTimeLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeTime;                      break;                    case edsTimeLen1:                  case edsTimeLen2:                  case edsTimeLen3:                  case edsTimeLen4:                      l = code - edsTimeLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeTime;                      break;                    case edsMilliSecLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeMilliseconds;                      break;                    case edsMilliSecLen1:                  case edsMilliSecLen2:                  case edsMilliSecLen3:                  case edsMilliSecLen4:                  case edsMilliSecLen5:                  case edsMilliSecLen6:                  case edsMilliSecLen7:                  case edsMilliSecLen8:                      l = code - edsMilliSecLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeMilliseconds;                      break;                    case edsNanoSecLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeNanoseconds;                      break;                    case edsNanoSecLen1:                  case edsNanoSecLen2:                  case edsNanoSecLen3:                  case edsNanoSecLen4:                  case edsNanoSecLen5:                  case edsNanoSecLen6:                  case edsNanoSecLen7:                  case edsNanoSecLen8:                      l = code - edsNanoSecLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeNanoseconds;                      break;                    //                  // 09/2012 Added support for new scaled date/times encoding. These replace the old encoding                  // edsTimeLen' edsMilliSecLen and edsNanoSecLen.                  //                    case edsScaledTimeLen1:                  case edsScaledTimeLen2:                  case edsScaledTimeLen3:                  case edsScaledTimeLen4:                  case edsScaledTimeLen5:                  case edsScaledTimeLen6:                  case edsScaledTimeLen7:                  case edsScaledTimeLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledTimeLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledTime;                      break;                    case edsScaledDateLen1:                  case edsScaledDateLen2:                  case edsScaledDateLen3:                  case edsScaledDateLen4:                  case edsScaledDateLen5:                  case edsScaledDateLen6:                  case edsScaledDateLen7:                  case edsScaledDateLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledDateLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledDate;                      break;                    case edsScaledTimestampLen1:                  case edsScaledTimestampLen2:                  case edsScaledTimestampLen3:                  case edsScaledTimestampLen4:                  case edsScaledTimestampLen5:                  case edsScaledTimestampLen6:                  case edsScaledTimestampLen7:                  case edsScaledTimestampLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledTimestampLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledTimestamp;                      break;                    case edsClobLen0:                      blobId = 0;                      type = edsTypeClob;                      break;                    case edsClobLen1:                  case edsClobLen2:                  case edsClobLen3:                  case edsClobLen4:                      l = code - edsClobLen1;                      blobId = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          blobId = (blobId << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeClob;                      break;                    case edsBlobLen0:                      blobId = 0;                      type = edsTypeBlob;                      break;                    case edsBlobLen1:                  case edsBlobLen2:                  case edsBlobLen3:                  case edsBlobLen4:                      l = code - edsBlobLen1;                      blobId = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          blobId = (blobId << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeBlob;                      break;                    case edsScaledCount1:                      {                          // For some reason C++ EncodedStream expects the encoded                          // length to be length+1.                            length = (source[offset++] & 0xff) - 1;                          scale = (sbyte)source[offset++];                          type = edsTypeBigInt;                          bytes = new byte[length];                          Array.Copy(source' offset' bytes' 0' length);                          offset += length;                          int sign = ((bytes[0] & 0x80) > 0) ? -1 : 1;                            if (sign == -1)                          {                              bytes[0] &= 0x7f;                          }                            BigInteger bi = new BigInteger(bytes);                          bigDecimal = Decimal.Parse(bi.ToString());                      }                      break;                    case edsScaledCount2:                      {                          // For some reason C++ EncodedStream expects the encoded                          // length to be length+1.                            scale = (sbyte)source[offset++];                          sbyte sign = (sbyte)source[offset++];                          length = (source[offset++] & 0xff); // in bytes                          type = edsTypeBigInt;                          bytes = new byte[length];                          Array.Copy(source' offset' bytes' 0' length);                          offset += length;                            if (sign == -1)                              bytes[0] &= 0x7f;                          else                              sign = 1;                            BigInteger bi = new BigInteger(bytes);                          if (sign == -1)                              bi = -bi;                          bigDecimal = ScaleDecimal(Decimal.Parse(bi.ToString())' scale);                      }                      break;                    case edsUUID:                      {                          byte[] buff = new byte[16];                            for (int n = 0; n < 16; ++n)                          {                              buff[n] = (byte)(source[offset++] & 0xff);                          }                            uuid = new Guid(buff);                          type = edsTypeUUID;                      }                      break;                    default:                      type = edsTypeUnknown;                      break;              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,decode,The following statement contains a magic number: switch (code)              {                  case edsNull:                      type = edsTypeNull;                      break;                    case edsTrue:                      type = edsTypeBoolean;                      @bool = true;                      break;                    case edsFalse:                      type = edsTypeBoolean;                      @bool = false;                      break;                    case edsIntMinus10:                  case edsIntMinus9:                  case edsIntMinus8:                  case edsIntMinus7:                  case edsIntMinus6:                  case edsIntMinus5:                  case edsIntMinus4:                  case edsIntMinus3:                  case edsIntMinus2:                  case edsIntMinus1:                  case edsInt0:                  case edsInt1:                  case edsInt2:                  case edsInt3:                  case edsInt4:                  case edsInt5:                  case edsInt6:                  case edsInt7:                  case edsInt8:                  case edsInt9:                  case edsInt10:                  case edsInt11:                  case edsInt12:                  case edsInt13:                  case edsInt14:                  case edsInt15:                  case edsInt16:                  case edsInt17:                  case edsInt18:                  case edsInt19:                  case edsInt20:                  case edsInt21:                  case edsInt22:                  case edsInt23:                  case edsInt24:                  case edsInt25:                  case edsInt26:                  case edsInt27:                  case edsInt28:                  case edsInt29:                  case edsInt30:                  case edsInt31:                      integer32 = code - edsInt0;                      scale = 0;                      type = edsTypeInt32;                      break;                    case edsIntLen1:                      type = edsTypeInt32;                      scale = 0;                      integer32 = (sbyte)source[offset++];                      break;                    case edsIntLen2:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset] << 8) | (source[offset + 1] & 0xff);                      offset += 2;                      break;                    case edsIntLen3:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset]) << 16 | (source[offset + 1] & 0xff) << 8 | (source[offset + 2] & 0xff);                      offset += 3;                      break;                    case edsIntLen4:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset]) << 24 | (source[offset + 1] & 0xff) << 16 | (source[offset + 2] & 0xff) << 8 | (source[offset + 3] & 0xff);                      offset += 4;                      break;                    case edsIntLen5:                  case edsIntLen6:                  case edsIntLen7:                  case edsIntLen8:                      l = code - edsIntLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeInt64;                      break;                    case edsScaledLen0:                      scale = (sbyte)source[offset++];                      integer64 = 0;                      type = edsTypeScaled;                      break;                    case edsScaledLen1:                  case edsScaledLen2:                  case edsScaledLen3:                  case edsScaledLen4:                  case edsScaledLen5:                  case edsScaledLen6:                  case edsScaledLen7:                  case edsScaledLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaled;                      break;                    case edsUtf8Len0:                  case edsUtf8Len1:                  case edsUtf8Len2:                  case edsUtf8Len3:                  case edsUtf8Len4:                  case edsUtf8Len5:                  case edsUtf8Len6:                  case edsUtf8Len7:                  case edsUtf8Len8:                  case edsUtf8Len9:                  case edsUtf8Len10:                  case edsUtf8Len11:                  case edsUtf8Len12:                  case edsUtf8Len13:                  case edsUtf8Len14:                  case edsUtf8Len15:                  case edsUtf8Len16:                  case edsUtf8Len17:                  case edsUtf8Len18:                  case edsUtf8Len19:                  case edsUtf8Len20:                  case edsUtf8Len21:                  case edsUtf8Len22:                  case edsUtf8Len23:                  case edsUtf8Len24:                  case edsUtf8Len25:                  case edsUtf8Len26:                  case edsUtf8Len27:                  case edsUtf8Len28:                  case edsUtf8Len29:                  case edsUtf8Len30:                  case edsUtf8Len31:                  case edsUtf8Len32:                  case edsUtf8Len33:                  case edsUtf8Len34:                  case edsUtf8Len35:                  case edsUtf8Len36:                  case edsUtf8Len37:                  case edsUtf8Len38:                  case edsUtf8Len39:                      l = code - edsUtf8Len0;                      @string = getString(source' offset' l);                      offset += l;                      type = edsTypeUtf8;                      break;                    case edsUtf8Count1:                  case edsUtf8Count2:                  case edsUtf8Count3:                  case edsUtf8Count4:                      count = code - edsUtf8Count1;                      int length = source[offset++] & 0xff;                        for (int n = 0; n < count; ++n)                      {                          length = length << 8 | (source[offset++] & 0xff);                      }                        @string = getString(source' offset' length);                      offset += length;                      type = edsTypeUtf8;                      break;                    case edsOpaqueLen0:                  case edsOpaqueLen1:                  case edsOpaqueLen2:                  case edsOpaqueLen3:                  case edsOpaqueLen4:                  case edsOpaqueLen5:                  case edsOpaqueLen6:                  case edsOpaqueLen7:                  case edsOpaqueLen8:                  case edsOpaqueLen9:                  case edsOpaqueLen10:                  case edsOpaqueLen11:                  case edsOpaqueLen12:                  case edsOpaqueLen13:                  case edsOpaqueLen14:                  case edsOpaqueLen15:                  case edsOpaqueLen16:                  case edsOpaqueLen17:                  case edsOpaqueLen18:                  case edsOpaqueLen19:                  case edsOpaqueLen20:                  case edsOpaqueLen21:                  case edsOpaqueLen22:                  case edsOpaqueLen23:                  case edsOpaqueLen24:                  case edsOpaqueLen25:                  case edsOpaqueLen26:                  case edsOpaqueLen27:                  case edsOpaqueLen28:                  case edsOpaqueLen29:                  case edsOpaqueLen30:                  case edsOpaqueLen31:                  case edsOpaqueLen32:                  case edsOpaqueLen33:                  case edsOpaqueLen34:                  case edsOpaqueLen35:                  case edsOpaqueLen36:                  case edsOpaqueLen37:                  case edsOpaqueLen38:                  case edsOpaqueLen39:                      l = code - edsOpaqueLen0;                      bytes = new byte[l];                      Array.Copy(source' offset' bytes' 0' l);                      offset += l;                      type = edsTypeOpaque;                      break;                    case edsOpaqueCount1:                  case edsOpaqueCount2:                  case edsOpaqueCount3:                  case edsOpaqueCount4:                      count = code - edsOpaqueCount1 + 1;                      l = source[offset++] & 0xff;                        for (int n = 1; n < count; ++n)                      {                          l = l << 8 | (source[offset++] & 0xff);                      }                        bytes = new byte[l];                      Array.Copy(source' offset' bytes' 0' l);                      offset += l;                      type = edsTypeOpaque;                      break;                    case edsDoubleLen0:                  case edsDoubleLen1:                  case edsDoubleLen2:                  case edsDoubleLen3:                  case edsDoubleLen4:                  case edsDoubleLen5:                  case edsDoubleLen6:                  case edsDoubleLen7:                  case edsDoubleLen8:                      count = code - edsDoubleLen0;                      long lvalue = 0;                        for (int n = 0; n < count; ++n)                      {                          lvalue = (lvalue << 8) | (source[offset++] & 0xff);                      }                        lvalue <<= (8 - count) * 8;                      dbl = BitConverter.Int64BitsToDouble(lvalue);                      type = edsTypeDouble;                      break;                    case edsTimeLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeTime;                      break;                    case edsTimeLen1:                  case edsTimeLen2:                  case edsTimeLen3:                  case edsTimeLen4:                      l = code - edsTimeLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeTime;                      break;                    case edsMilliSecLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeMilliseconds;                      break;                    case edsMilliSecLen1:                  case edsMilliSecLen2:                  case edsMilliSecLen3:                  case edsMilliSecLen4:                  case edsMilliSecLen5:                  case edsMilliSecLen6:                  case edsMilliSecLen7:                  case edsMilliSecLen8:                      l = code - edsMilliSecLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeMilliseconds;                      break;                    case edsNanoSecLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeNanoseconds;                      break;                    case edsNanoSecLen1:                  case edsNanoSecLen2:                  case edsNanoSecLen3:                  case edsNanoSecLen4:                  case edsNanoSecLen5:                  case edsNanoSecLen6:                  case edsNanoSecLen7:                  case edsNanoSecLen8:                      l = code - edsNanoSecLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeNanoseconds;                      break;                    //                  // 09/2012 Added support for new scaled date/times encoding. These replace the old encoding                  // edsTimeLen' edsMilliSecLen and edsNanoSecLen.                  //                    case edsScaledTimeLen1:                  case edsScaledTimeLen2:                  case edsScaledTimeLen3:                  case edsScaledTimeLen4:                  case edsScaledTimeLen5:                  case edsScaledTimeLen6:                  case edsScaledTimeLen7:                  case edsScaledTimeLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledTimeLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledTime;                      break;                    case edsScaledDateLen1:                  case edsScaledDateLen2:                  case edsScaledDateLen3:                  case edsScaledDateLen4:                  case edsScaledDateLen5:                  case edsScaledDateLen6:                  case edsScaledDateLen7:                  case edsScaledDateLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledDateLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledDate;                      break;                    case edsScaledTimestampLen1:                  case edsScaledTimestampLen2:                  case edsScaledTimestampLen3:                  case edsScaledTimestampLen4:                  case edsScaledTimestampLen5:                  case edsScaledTimestampLen6:                  case edsScaledTimestampLen7:                  case edsScaledTimestampLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledTimestampLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledTimestamp;                      break;                    case edsClobLen0:                      blobId = 0;                      type = edsTypeClob;                      break;                    case edsClobLen1:                  case edsClobLen2:                  case edsClobLen3:                  case edsClobLen4:                      l = code - edsClobLen1;                      blobId = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          blobId = (blobId << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeClob;                      break;                    case edsBlobLen0:                      blobId = 0;                      type = edsTypeBlob;                      break;                    case edsBlobLen1:                  case edsBlobLen2:                  case edsBlobLen3:                  case edsBlobLen4:                      l = code - edsBlobLen1;                      blobId = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          blobId = (blobId << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeBlob;                      break;                    case edsScaledCount1:                      {                          // For some reason C++ EncodedStream expects the encoded                          // length to be length+1.                            length = (source[offset++] & 0xff) - 1;                          scale = (sbyte)source[offset++];                          type = edsTypeBigInt;                          bytes = new byte[length];                          Array.Copy(source' offset' bytes' 0' length);                          offset += length;                          int sign = ((bytes[0] & 0x80) > 0) ? -1 : 1;                            if (sign == -1)                          {                              bytes[0] &= 0x7f;                          }                            BigInteger bi = new BigInteger(bytes);                          bigDecimal = Decimal.Parse(bi.ToString());                      }                      break;                    case edsScaledCount2:                      {                          // For some reason C++ EncodedStream expects the encoded                          // length to be length+1.                            scale = (sbyte)source[offset++];                          sbyte sign = (sbyte)source[offset++];                          length = (source[offset++] & 0xff); // in bytes                          type = edsTypeBigInt;                          bytes = new byte[length];                          Array.Copy(source' offset' bytes' 0' length);                          offset += length;                            if (sign == -1)                              bytes[0] &= 0x7f;                          else                              sign = 1;                            BigInteger bi = new BigInteger(bytes);                          if (sign == -1)                              bi = -bi;                          bigDecimal = ScaleDecimal(Decimal.Parse(bi.ToString())' scale);                      }                      break;                    case edsUUID:                      {                          byte[] buff = new byte[16];                            for (int n = 0; n < 16; ++n)                          {                              buff[n] = (byte)(source[offset++] & 0xff);                          }                            uuid = new Guid(buff);                          type = edsTypeUUID;                      }                      break;                    default:                      type = edsTypeUnknown;                      break;              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,decode,The following statement contains a magic number: switch (code)              {                  case edsNull:                      type = edsTypeNull;                      break;                    case edsTrue:                      type = edsTypeBoolean;                      @bool = true;                      break;                    case edsFalse:                      type = edsTypeBoolean;                      @bool = false;                      break;                    case edsIntMinus10:                  case edsIntMinus9:                  case edsIntMinus8:                  case edsIntMinus7:                  case edsIntMinus6:                  case edsIntMinus5:                  case edsIntMinus4:                  case edsIntMinus3:                  case edsIntMinus2:                  case edsIntMinus1:                  case edsInt0:                  case edsInt1:                  case edsInt2:                  case edsInt3:                  case edsInt4:                  case edsInt5:                  case edsInt6:                  case edsInt7:                  case edsInt8:                  case edsInt9:                  case edsInt10:                  case edsInt11:                  case edsInt12:                  case edsInt13:                  case edsInt14:                  case edsInt15:                  case edsInt16:                  case edsInt17:                  case edsInt18:                  case edsInt19:                  case edsInt20:                  case edsInt21:                  case edsInt22:                  case edsInt23:                  case edsInt24:                  case edsInt25:                  case edsInt26:                  case edsInt27:                  case edsInt28:                  case edsInt29:                  case edsInt30:                  case edsInt31:                      integer32 = code - edsInt0;                      scale = 0;                      type = edsTypeInt32;                      break;                    case edsIntLen1:                      type = edsTypeInt32;                      scale = 0;                      integer32 = (sbyte)source[offset++];                      break;                    case edsIntLen2:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset] << 8) | (source[offset + 1] & 0xff);                      offset += 2;                      break;                    case edsIntLen3:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset]) << 16 | (source[offset + 1] & 0xff) << 8 | (source[offset + 2] & 0xff);                      offset += 3;                      break;                    case edsIntLen4:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset]) << 24 | (source[offset + 1] & 0xff) << 16 | (source[offset + 2] & 0xff) << 8 | (source[offset + 3] & 0xff);                      offset += 4;                      break;                    case edsIntLen5:                  case edsIntLen6:                  case edsIntLen7:                  case edsIntLen8:                      l = code - edsIntLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeInt64;                      break;                    case edsScaledLen0:                      scale = (sbyte)source[offset++];                      integer64 = 0;                      type = edsTypeScaled;                      break;                    case edsScaledLen1:                  case edsScaledLen2:                  case edsScaledLen3:                  case edsScaledLen4:                  case edsScaledLen5:                  case edsScaledLen6:                  case edsScaledLen7:                  case edsScaledLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaled;                      break;                    case edsUtf8Len0:                  case edsUtf8Len1:                  case edsUtf8Len2:                  case edsUtf8Len3:                  case edsUtf8Len4:                  case edsUtf8Len5:                  case edsUtf8Len6:                  case edsUtf8Len7:                  case edsUtf8Len8:                  case edsUtf8Len9:                  case edsUtf8Len10:                  case edsUtf8Len11:                  case edsUtf8Len12:                  case edsUtf8Len13:                  case edsUtf8Len14:                  case edsUtf8Len15:                  case edsUtf8Len16:                  case edsUtf8Len17:                  case edsUtf8Len18:                  case edsUtf8Len19:                  case edsUtf8Len20:                  case edsUtf8Len21:                  case edsUtf8Len22:                  case edsUtf8Len23:                  case edsUtf8Len24:                  case edsUtf8Len25:                  case edsUtf8Len26:                  case edsUtf8Len27:                  case edsUtf8Len28:                  case edsUtf8Len29:                  case edsUtf8Len30:                  case edsUtf8Len31:                  case edsUtf8Len32:                  case edsUtf8Len33:                  case edsUtf8Len34:                  case edsUtf8Len35:                  case edsUtf8Len36:                  case edsUtf8Len37:                  case edsUtf8Len38:                  case edsUtf8Len39:                      l = code - edsUtf8Len0;                      @string = getString(source' offset' l);                      offset += l;                      type = edsTypeUtf8;                      break;                    case edsUtf8Count1:                  case edsUtf8Count2:                  case edsUtf8Count3:                  case edsUtf8Count4:                      count = code - edsUtf8Count1;                      int length = source[offset++] & 0xff;                        for (int n = 0; n < count; ++n)                      {                          length = length << 8 | (source[offset++] & 0xff);                      }                        @string = getString(source' offset' length);                      offset += length;                      type = edsTypeUtf8;                      break;                    case edsOpaqueLen0:                  case edsOpaqueLen1:                  case edsOpaqueLen2:                  case edsOpaqueLen3:                  case edsOpaqueLen4:                  case edsOpaqueLen5:                  case edsOpaqueLen6:                  case edsOpaqueLen7:                  case edsOpaqueLen8:                  case edsOpaqueLen9:                  case edsOpaqueLen10:                  case edsOpaqueLen11:                  case edsOpaqueLen12:                  case edsOpaqueLen13:                  case edsOpaqueLen14:                  case edsOpaqueLen15:                  case edsOpaqueLen16:                  case edsOpaqueLen17:                  case edsOpaqueLen18:                  case edsOpaqueLen19:                  case edsOpaqueLen20:                  case edsOpaqueLen21:                  case edsOpaqueLen22:                  case edsOpaqueLen23:                  case edsOpaqueLen24:                  case edsOpaqueLen25:                  case edsOpaqueLen26:                  case edsOpaqueLen27:                  case edsOpaqueLen28:                  case edsOpaqueLen29:                  case edsOpaqueLen30:                  case edsOpaqueLen31:                  case edsOpaqueLen32:                  case edsOpaqueLen33:                  case edsOpaqueLen34:                  case edsOpaqueLen35:                  case edsOpaqueLen36:                  case edsOpaqueLen37:                  case edsOpaqueLen38:                  case edsOpaqueLen39:                      l = code - edsOpaqueLen0;                      bytes = new byte[l];                      Array.Copy(source' offset' bytes' 0' l);                      offset += l;                      type = edsTypeOpaque;                      break;                    case edsOpaqueCount1:                  case edsOpaqueCount2:                  case edsOpaqueCount3:                  case edsOpaqueCount4:                      count = code - edsOpaqueCount1 + 1;                      l = source[offset++] & 0xff;                        for (int n = 1; n < count; ++n)                      {                          l = l << 8 | (source[offset++] & 0xff);                      }                        bytes = new byte[l];                      Array.Copy(source' offset' bytes' 0' l);                      offset += l;                      type = edsTypeOpaque;                      break;                    case edsDoubleLen0:                  case edsDoubleLen1:                  case edsDoubleLen2:                  case edsDoubleLen3:                  case edsDoubleLen4:                  case edsDoubleLen5:                  case edsDoubleLen6:                  case edsDoubleLen7:                  case edsDoubleLen8:                      count = code - edsDoubleLen0;                      long lvalue = 0;                        for (int n = 0; n < count; ++n)                      {                          lvalue = (lvalue << 8) | (source[offset++] & 0xff);                      }                        lvalue <<= (8 - count) * 8;                      dbl = BitConverter.Int64BitsToDouble(lvalue);                      type = edsTypeDouble;                      break;                    case edsTimeLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeTime;                      break;                    case edsTimeLen1:                  case edsTimeLen2:                  case edsTimeLen3:                  case edsTimeLen4:                      l = code - edsTimeLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeTime;                      break;                    case edsMilliSecLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeMilliseconds;                      break;                    case edsMilliSecLen1:                  case edsMilliSecLen2:                  case edsMilliSecLen3:                  case edsMilliSecLen4:                  case edsMilliSecLen5:                  case edsMilliSecLen6:                  case edsMilliSecLen7:                  case edsMilliSecLen8:                      l = code - edsMilliSecLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeMilliseconds;                      break;                    case edsNanoSecLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeNanoseconds;                      break;                    case edsNanoSecLen1:                  case edsNanoSecLen2:                  case edsNanoSecLen3:                  case edsNanoSecLen4:                  case edsNanoSecLen5:                  case edsNanoSecLen6:                  case edsNanoSecLen7:                  case edsNanoSecLen8:                      l = code - edsNanoSecLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeNanoseconds;                      break;                    //                  // 09/2012 Added support for new scaled date/times encoding. These replace the old encoding                  // edsTimeLen' edsMilliSecLen and edsNanoSecLen.                  //                    case edsScaledTimeLen1:                  case edsScaledTimeLen2:                  case edsScaledTimeLen3:                  case edsScaledTimeLen4:                  case edsScaledTimeLen5:                  case edsScaledTimeLen6:                  case edsScaledTimeLen7:                  case edsScaledTimeLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledTimeLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledTime;                      break;                    case edsScaledDateLen1:                  case edsScaledDateLen2:                  case edsScaledDateLen3:                  case edsScaledDateLen4:                  case edsScaledDateLen5:                  case edsScaledDateLen6:                  case edsScaledDateLen7:                  case edsScaledDateLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledDateLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledDate;                      break;                    case edsScaledTimestampLen1:                  case edsScaledTimestampLen2:                  case edsScaledTimestampLen3:                  case edsScaledTimestampLen4:                  case edsScaledTimestampLen5:                  case edsScaledTimestampLen6:                  case edsScaledTimestampLen7:                  case edsScaledTimestampLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledTimestampLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledTimestamp;                      break;                    case edsClobLen0:                      blobId = 0;                      type = edsTypeClob;                      break;                    case edsClobLen1:                  case edsClobLen2:                  case edsClobLen3:                  case edsClobLen4:                      l = code - edsClobLen1;                      blobId = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          blobId = (blobId << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeClob;                      break;                    case edsBlobLen0:                      blobId = 0;                      type = edsTypeBlob;                      break;                    case edsBlobLen1:                  case edsBlobLen2:                  case edsBlobLen3:                  case edsBlobLen4:                      l = code - edsBlobLen1;                      blobId = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          blobId = (blobId << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeBlob;                      break;                    case edsScaledCount1:                      {                          // For some reason C++ EncodedStream expects the encoded                          // length to be length+1.                            length = (source[offset++] & 0xff) - 1;                          scale = (sbyte)source[offset++];                          type = edsTypeBigInt;                          bytes = new byte[length];                          Array.Copy(source' offset' bytes' 0' length);                          offset += length;                          int sign = ((bytes[0] & 0x80) > 0) ? -1 : 1;                            if (sign == -1)                          {                              bytes[0] &= 0x7f;                          }                            BigInteger bi = new BigInteger(bytes);                          bigDecimal = Decimal.Parse(bi.ToString());                      }                      break;                    case edsScaledCount2:                      {                          // For some reason C++ EncodedStream expects the encoded                          // length to be length+1.                            scale = (sbyte)source[offset++];                          sbyte sign = (sbyte)source[offset++];                          length = (source[offset++] & 0xff); // in bytes                          type = edsTypeBigInt;                          bytes = new byte[length];                          Array.Copy(source' offset' bytes' 0' length);                          offset += length;                            if (sign == -1)                              bytes[0] &= 0x7f;                          else                              sign = 1;                            BigInteger bi = new BigInteger(bytes);                          if (sign == -1)                              bi = -bi;                          bigDecimal = ScaleDecimal(Decimal.Parse(bi.ToString())' scale);                      }                      break;                    case edsUUID:                      {                          byte[] buff = new byte[16];                            for (int n = 0; n < 16; ++n)                          {                              buff[n] = (byte)(source[offset++] & 0xff);                          }                            uuid = new Guid(buff);                          type = edsTypeUUID;                      }                      break;                    default:                      type = edsTypeUnknown;                      break;              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,decode,The following statement contains a magic number: switch (code)              {                  case edsNull:                      type = edsTypeNull;                      break;                    case edsTrue:                      type = edsTypeBoolean;                      @bool = true;                      break;                    case edsFalse:                      type = edsTypeBoolean;                      @bool = false;                      break;                    case edsIntMinus10:                  case edsIntMinus9:                  case edsIntMinus8:                  case edsIntMinus7:                  case edsIntMinus6:                  case edsIntMinus5:                  case edsIntMinus4:                  case edsIntMinus3:                  case edsIntMinus2:                  case edsIntMinus1:                  case edsInt0:                  case edsInt1:                  case edsInt2:                  case edsInt3:                  case edsInt4:                  case edsInt5:                  case edsInt6:                  case edsInt7:                  case edsInt8:                  case edsInt9:                  case edsInt10:                  case edsInt11:                  case edsInt12:                  case edsInt13:                  case edsInt14:                  case edsInt15:                  case edsInt16:                  case edsInt17:                  case edsInt18:                  case edsInt19:                  case edsInt20:                  case edsInt21:                  case edsInt22:                  case edsInt23:                  case edsInt24:                  case edsInt25:                  case edsInt26:                  case edsInt27:                  case edsInt28:                  case edsInt29:                  case edsInt30:                  case edsInt31:                      integer32 = code - edsInt0;                      scale = 0;                      type = edsTypeInt32;                      break;                    case edsIntLen1:                      type = edsTypeInt32;                      scale = 0;                      integer32 = (sbyte)source[offset++];                      break;                    case edsIntLen2:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset] << 8) | (source[offset + 1] & 0xff);                      offset += 2;                      break;                    case edsIntLen3:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset]) << 16 | (source[offset + 1] & 0xff) << 8 | (source[offset + 2] & 0xff);                      offset += 3;                      break;                    case edsIntLen4:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset]) << 24 | (source[offset + 1] & 0xff) << 16 | (source[offset + 2] & 0xff) << 8 | (source[offset + 3] & 0xff);                      offset += 4;                      break;                    case edsIntLen5:                  case edsIntLen6:                  case edsIntLen7:                  case edsIntLen8:                      l = code - edsIntLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeInt64;                      break;                    case edsScaledLen0:                      scale = (sbyte)source[offset++];                      integer64 = 0;                      type = edsTypeScaled;                      break;                    case edsScaledLen1:                  case edsScaledLen2:                  case edsScaledLen3:                  case edsScaledLen4:                  case edsScaledLen5:                  case edsScaledLen6:                  case edsScaledLen7:                  case edsScaledLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaled;                      break;                    case edsUtf8Len0:                  case edsUtf8Len1:                  case edsUtf8Len2:                  case edsUtf8Len3:                  case edsUtf8Len4:                  case edsUtf8Len5:                  case edsUtf8Len6:                  case edsUtf8Len7:                  case edsUtf8Len8:                  case edsUtf8Len9:                  case edsUtf8Len10:                  case edsUtf8Len11:                  case edsUtf8Len12:                  case edsUtf8Len13:                  case edsUtf8Len14:                  case edsUtf8Len15:                  case edsUtf8Len16:                  case edsUtf8Len17:                  case edsUtf8Len18:                  case edsUtf8Len19:                  case edsUtf8Len20:                  case edsUtf8Len21:                  case edsUtf8Len22:                  case edsUtf8Len23:                  case edsUtf8Len24:                  case edsUtf8Len25:                  case edsUtf8Len26:                  case edsUtf8Len27:                  case edsUtf8Len28:                  case edsUtf8Len29:                  case edsUtf8Len30:                  case edsUtf8Len31:                  case edsUtf8Len32:                  case edsUtf8Len33:                  case edsUtf8Len34:                  case edsUtf8Len35:                  case edsUtf8Len36:                  case edsUtf8Len37:                  case edsUtf8Len38:                  case edsUtf8Len39:                      l = code - edsUtf8Len0;                      @string = getString(source' offset' l);                      offset += l;                      type = edsTypeUtf8;                      break;                    case edsUtf8Count1:                  case edsUtf8Count2:                  case edsUtf8Count3:                  case edsUtf8Count4:                      count = code - edsUtf8Count1;                      int length = source[offset++] & 0xff;                        for (int n = 0; n < count; ++n)                      {                          length = length << 8 | (source[offset++] & 0xff);                      }                        @string = getString(source' offset' length);                      offset += length;                      type = edsTypeUtf8;                      break;                    case edsOpaqueLen0:                  case edsOpaqueLen1:                  case edsOpaqueLen2:                  case edsOpaqueLen3:                  case edsOpaqueLen4:                  case edsOpaqueLen5:                  case edsOpaqueLen6:                  case edsOpaqueLen7:                  case edsOpaqueLen8:                  case edsOpaqueLen9:                  case edsOpaqueLen10:                  case edsOpaqueLen11:                  case edsOpaqueLen12:                  case edsOpaqueLen13:                  case edsOpaqueLen14:                  case edsOpaqueLen15:                  case edsOpaqueLen16:                  case edsOpaqueLen17:                  case edsOpaqueLen18:                  case edsOpaqueLen19:                  case edsOpaqueLen20:                  case edsOpaqueLen21:                  case edsOpaqueLen22:                  case edsOpaqueLen23:                  case edsOpaqueLen24:                  case edsOpaqueLen25:                  case edsOpaqueLen26:                  case edsOpaqueLen27:                  case edsOpaqueLen28:                  case edsOpaqueLen29:                  case edsOpaqueLen30:                  case edsOpaqueLen31:                  case edsOpaqueLen32:                  case edsOpaqueLen33:                  case edsOpaqueLen34:                  case edsOpaqueLen35:                  case edsOpaqueLen36:                  case edsOpaqueLen37:                  case edsOpaqueLen38:                  case edsOpaqueLen39:                      l = code - edsOpaqueLen0;                      bytes = new byte[l];                      Array.Copy(source' offset' bytes' 0' l);                      offset += l;                      type = edsTypeOpaque;                      break;                    case edsOpaqueCount1:                  case edsOpaqueCount2:                  case edsOpaqueCount3:                  case edsOpaqueCount4:                      count = code - edsOpaqueCount1 + 1;                      l = source[offset++] & 0xff;                        for (int n = 1; n < count; ++n)                      {                          l = l << 8 | (source[offset++] & 0xff);                      }                        bytes = new byte[l];                      Array.Copy(source' offset' bytes' 0' l);                      offset += l;                      type = edsTypeOpaque;                      break;                    case edsDoubleLen0:                  case edsDoubleLen1:                  case edsDoubleLen2:                  case edsDoubleLen3:                  case edsDoubleLen4:                  case edsDoubleLen5:                  case edsDoubleLen6:                  case edsDoubleLen7:                  case edsDoubleLen8:                      count = code - edsDoubleLen0;                      long lvalue = 0;                        for (int n = 0; n < count; ++n)                      {                          lvalue = (lvalue << 8) | (source[offset++] & 0xff);                      }                        lvalue <<= (8 - count) * 8;                      dbl = BitConverter.Int64BitsToDouble(lvalue);                      type = edsTypeDouble;                      break;                    case edsTimeLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeTime;                      break;                    case edsTimeLen1:                  case edsTimeLen2:                  case edsTimeLen3:                  case edsTimeLen4:                      l = code - edsTimeLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeTime;                      break;                    case edsMilliSecLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeMilliseconds;                      break;                    case edsMilliSecLen1:                  case edsMilliSecLen2:                  case edsMilliSecLen3:                  case edsMilliSecLen4:                  case edsMilliSecLen5:                  case edsMilliSecLen6:                  case edsMilliSecLen7:                  case edsMilliSecLen8:                      l = code - edsMilliSecLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeMilliseconds;                      break;                    case edsNanoSecLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeNanoseconds;                      break;                    case edsNanoSecLen1:                  case edsNanoSecLen2:                  case edsNanoSecLen3:                  case edsNanoSecLen4:                  case edsNanoSecLen5:                  case edsNanoSecLen6:                  case edsNanoSecLen7:                  case edsNanoSecLen8:                      l = code - edsNanoSecLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeNanoseconds;                      break;                    //                  // 09/2012 Added support for new scaled date/times encoding. These replace the old encoding                  // edsTimeLen' edsMilliSecLen and edsNanoSecLen.                  //                    case edsScaledTimeLen1:                  case edsScaledTimeLen2:                  case edsScaledTimeLen3:                  case edsScaledTimeLen4:                  case edsScaledTimeLen5:                  case edsScaledTimeLen6:                  case edsScaledTimeLen7:                  case edsScaledTimeLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledTimeLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledTime;                      break;                    case edsScaledDateLen1:                  case edsScaledDateLen2:                  case edsScaledDateLen3:                  case edsScaledDateLen4:                  case edsScaledDateLen5:                  case edsScaledDateLen6:                  case edsScaledDateLen7:                  case edsScaledDateLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledDateLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledDate;                      break;                    case edsScaledTimestampLen1:                  case edsScaledTimestampLen2:                  case edsScaledTimestampLen3:                  case edsScaledTimestampLen4:                  case edsScaledTimestampLen5:                  case edsScaledTimestampLen6:                  case edsScaledTimestampLen7:                  case edsScaledTimestampLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledTimestampLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledTimestamp;                      break;                    case edsClobLen0:                      blobId = 0;                      type = edsTypeClob;                      break;                    case edsClobLen1:                  case edsClobLen2:                  case edsClobLen3:                  case edsClobLen4:                      l = code - edsClobLen1;                      blobId = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          blobId = (blobId << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeClob;                      break;                    case edsBlobLen0:                      blobId = 0;                      type = edsTypeBlob;                      break;                    case edsBlobLen1:                  case edsBlobLen2:                  case edsBlobLen3:                  case edsBlobLen4:                      l = code - edsBlobLen1;                      blobId = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          blobId = (blobId << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeBlob;                      break;                    case edsScaledCount1:                      {                          // For some reason C++ EncodedStream expects the encoded                          // length to be length+1.                            length = (source[offset++] & 0xff) - 1;                          scale = (sbyte)source[offset++];                          type = edsTypeBigInt;                          bytes = new byte[length];                          Array.Copy(source' offset' bytes' 0' length);                          offset += length;                          int sign = ((bytes[0] & 0x80) > 0) ? -1 : 1;                            if (sign == -1)                          {                              bytes[0] &= 0x7f;                          }                            BigInteger bi = new BigInteger(bytes);                          bigDecimal = Decimal.Parse(bi.ToString());                      }                      break;                    case edsScaledCount2:                      {                          // For some reason C++ EncodedStream expects the encoded                          // length to be length+1.                            scale = (sbyte)source[offset++];                          sbyte sign = (sbyte)source[offset++];                          length = (source[offset++] & 0xff); // in bytes                          type = edsTypeBigInt;                          bytes = new byte[length];                          Array.Copy(source' offset' bytes' 0' length);                          offset += length;                            if (sign == -1)                              bytes[0] &= 0x7f;                          else                              sign = 1;                            BigInteger bi = new BigInteger(bytes);                          if (sign == -1)                              bi = -bi;                          bigDecimal = ScaleDecimal(Decimal.Parse(bi.ToString())' scale);                      }                      break;                    case edsUUID:                      {                          byte[] buff = new byte[16];                            for (int n = 0; n < 16; ++n)                          {                              buff[n] = (byte)(source[offset++] & 0xff);                          }                            uuid = new Guid(buff);                          type = edsTypeUUID;                      }                      break;                    default:                      type = edsTypeUnknown;                      break;              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,decode,The following statement contains a magic number: switch (code)              {                  case edsNull:                      type = edsTypeNull;                      break;                    case edsTrue:                      type = edsTypeBoolean;                      @bool = true;                      break;                    case edsFalse:                      type = edsTypeBoolean;                      @bool = false;                      break;                    case edsIntMinus10:                  case edsIntMinus9:                  case edsIntMinus8:                  case edsIntMinus7:                  case edsIntMinus6:                  case edsIntMinus5:                  case edsIntMinus4:                  case edsIntMinus3:                  case edsIntMinus2:                  case edsIntMinus1:                  case edsInt0:                  case edsInt1:                  case edsInt2:                  case edsInt3:                  case edsInt4:                  case edsInt5:                  case edsInt6:                  case edsInt7:                  case edsInt8:                  case edsInt9:                  case edsInt10:                  case edsInt11:                  case edsInt12:                  case edsInt13:                  case edsInt14:                  case edsInt15:                  case edsInt16:                  case edsInt17:                  case edsInt18:                  case edsInt19:                  case edsInt20:                  case edsInt21:                  case edsInt22:                  case edsInt23:                  case edsInt24:                  case edsInt25:                  case edsInt26:                  case edsInt27:                  case edsInt28:                  case edsInt29:                  case edsInt30:                  case edsInt31:                      integer32 = code - edsInt0;                      scale = 0;                      type = edsTypeInt32;                      break;                    case edsIntLen1:                      type = edsTypeInt32;                      scale = 0;                      integer32 = (sbyte)source[offset++];                      break;                    case edsIntLen2:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset] << 8) | (source[offset + 1] & 0xff);                      offset += 2;                      break;                    case edsIntLen3:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset]) << 16 | (source[offset + 1] & 0xff) << 8 | (source[offset + 2] & 0xff);                      offset += 3;                      break;                    case edsIntLen4:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset]) << 24 | (source[offset + 1] & 0xff) << 16 | (source[offset + 2] & 0xff) << 8 | (source[offset + 3] & 0xff);                      offset += 4;                      break;                    case edsIntLen5:                  case edsIntLen6:                  case edsIntLen7:                  case edsIntLen8:                      l = code - edsIntLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeInt64;                      break;                    case edsScaledLen0:                      scale = (sbyte)source[offset++];                      integer64 = 0;                      type = edsTypeScaled;                      break;                    case edsScaledLen1:                  case edsScaledLen2:                  case edsScaledLen3:                  case edsScaledLen4:                  case edsScaledLen5:                  case edsScaledLen6:                  case edsScaledLen7:                  case edsScaledLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaled;                      break;                    case edsUtf8Len0:                  case edsUtf8Len1:                  case edsUtf8Len2:                  case edsUtf8Len3:                  case edsUtf8Len4:                  case edsUtf8Len5:                  case edsUtf8Len6:                  case edsUtf8Len7:                  case edsUtf8Len8:                  case edsUtf8Len9:                  case edsUtf8Len10:                  case edsUtf8Len11:                  case edsUtf8Len12:                  case edsUtf8Len13:                  case edsUtf8Len14:                  case edsUtf8Len15:                  case edsUtf8Len16:                  case edsUtf8Len17:                  case edsUtf8Len18:                  case edsUtf8Len19:                  case edsUtf8Len20:                  case edsUtf8Len21:                  case edsUtf8Len22:                  case edsUtf8Len23:                  case edsUtf8Len24:                  case edsUtf8Len25:                  case edsUtf8Len26:                  case edsUtf8Len27:                  case edsUtf8Len28:                  case edsUtf8Len29:                  case edsUtf8Len30:                  case edsUtf8Len31:                  case edsUtf8Len32:                  case edsUtf8Len33:                  case edsUtf8Len34:                  case edsUtf8Len35:                  case edsUtf8Len36:                  case edsUtf8Len37:                  case edsUtf8Len38:                  case edsUtf8Len39:                      l = code - edsUtf8Len0;                      @string = getString(source' offset' l);                      offset += l;                      type = edsTypeUtf8;                      break;                    case edsUtf8Count1:                  case edsUtf8Count2:                  case edsUtf8Count3:                  case edsUtf8Count4:                      count = code - edsUtf8Count1;                      int length = source[offset++] & 0xff;                        for (int n = 0; n < count; ++n)                      {                          length = length << 8 | (source[offset++] & 0xff);                      }                        @string = getString(source' offset' length);                      offset += length;                      type = edsTypeUtf8;                      break;                    case edsOpaqueLen0:                  case edsOpaqueLen1:                  case edsOpaqueLen2:                  case edsOpaqueLen3:                  case edsOpaqueLen4:                  case edsOpaqueLen5:                  case edsOpaqueLen6:                  case edsOpaqueLen7:                  case edsOpaqueLen8:                  case edsOpaqueLen9:                  case edsOpaqueLen10:                  case edsOpaqueLen11:                  case edsOpaqueLen12:                  case edsOpaqueLen13:                  case edsOpaqueLen14:                  case edsOpaqueLen15:                  case edsOpaqueLen16:                  case edsOpaqueLen17:                  case edsOpaqueLen18:                  case edsOpaqueLen19:                  case edsOpaqueLen20:                  case edsOpaqueLen21:                  case edsOpaqueLen22:                  case edsOpaqueLen23:                  case edsOpaqueLen24:                  case edsOpaqueLen25:                  case edsOpaqueLen26:                  case edsOpaqueLen27:                  case edsOpaqueLen28:                  case edsOpaqueLen29:                  case edsOpaqueLen30:                  case edsOpaqueLen31:                  case edsOpaqueLen32:                  case edsOpaqueLen33:                  case edsOpaqueLen34:                  case edsOpaqueLen35:                  case edsOpaqueLen36:                  case edsOpaqueLen37:                  case edsOpaqueLen38:                  case edsOpaqueLen39:                      l = code - edsOpaqueLen0;                      bytes = new byte[l];                      Array.Copy(source' offset' bytes' 0' l);                      offset += l;                      type = edsTypeOpaque;                      break;                    case edsOpaqueCount1:                  case edsOpaqueCount2:                  case edsOpaqueCount3:                  case edsOpaqueCount4:                      count = code - edsOpaqueCount1 + 1;                      l = source[offset++] & 0xff;                        for (int n = 1; n < count; ++n)                      {                          l = l << 8 | (source[offset++] & 0xff);                      }                        bytes = new byte[l];                      Array.Copy(source' offset' bytes' 0' l);                      offset += l;                      type = edsTypeOpaque;                      break;                    case edsDoubleLen0:                  case edsDoubleLen1:                  case edsDoubleLen2:                  case edsDoubleLen3:                  case edsDoubleLen4:                  case edsDoubleLen5:                  case edsDoubleLen6:                  case edsDoubleLen7:                  case edsDoubleLen8:                      count = code - edsDoubleLen0;                      long lvalue = 0;                        for (int n = 0; n < count; ++n)                      {                          lvalue = (lvalue << 8) | (source[offset++] & 0xff);                      }                        lvalue <<= (8 - count) * 8;                      dbl = BitConverter.Int64BitsToDouble(lvalue);                      type = edsTypeDouble;                      break;                    case edsTimeLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeTime;                      break;                    case edsTimeLen1:                  case edsTimeLen2:                  case edsTimeLen3:                  case edsTimeLen4:                      l = code - edsTimeLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeTime;                      break;                    case edsMilliSecLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeMilliseconds;                      break;                    case edsMilliSecLen1:                  case edsMilliSecLen2:                  case edsMilliSecLen3:                  case edsMilliSecLen4:                  case edsMilliSecLen5:                  case edsMilliSecLen6:                  case edsMilliSecLen7:                  case edsMilliSecLen8:                      l = code - edsMilliSecLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeMilliseconds;                      break;                    case edsNanoSecLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeNanoseconds;                      break;                    case edsNanoSecLen1:                  case edsNanoSecLen2:                  case edsNanoSecLen3:                  case edsNanoSecLen4:                  case edsNanoSecLen5:                  case edsNanoSecLen6:                  case edsNanoSecLen7:                  case edsNanoSecLen8:                      l = code - edsNanoSecLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeNanoseconds;                      break;                    //                  // 09/2012 Added support for new scaled date/times encoding. These replace the old encoding                  // edsTimeLen' edsMilliSecLen and edsNanoSecLen.                  //                    case edsScaledTimeLen1:                  case edsScaledTimeLen2:                  case edsScaledTimeLen3:                  case edsScaledTimeLen4:                  case edsScaledTimeLen5:                  case edsScaledTimeLen6:                  case edsScaledTimeLen7:                  case edsScaledTimeLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledTimeLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledTime;                      break;                    case edsScaledDateLen1:                  case edsScaledDateLen2:                  case edsScaledDateLen3:                  case edsScaledDateLen4:                  case edsScaledDateLen5:                  case edsScaledDateLen6:                  case edsScaledDateLen7:                  case edsScaledDateLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledDateLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledDate;                      break;                    case edsScaledTimestampLen1:                  case edsScaledTimestampLen2:                  case edsScaledTimestampLen3:                  case edsScaledTimestampLen4:                  case edsScaledTimestampLen5:                  case edsScaledTimestampLen6:                  case edsScaledTimestampLen7:                  case edsScaledTimestampLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledTimestampLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledTimestamp;                      break;                    case edsClobLen0:                      blobId = 0;                      type = edsTypeClob;                      break;                    case edsClobLen1:                  case edsClobLen2:                  case edsClobLen3:                  case edsClobLen4:                      l = code - edsClobLen1;                      blobId = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          blobId = (blobId << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeClob;                      break;                    case edsBlobLen0:                      blobId = 0;                      type = edsTypeBlob;                      break;                    case edsBlobLen1:                  case edsBlobLen2:                  case edsBlobLen3:                  case edsBlobLen4:                      l = code - edsBlobLen1;                      blobId = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          blobId = (blobId << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeBlob;                      break;                    case edsScaledCount1:                      {                          // For some reason C++ EncodedStream expects the encoded                          // length to be length+1.                            length = (source[offset++] & 0xff) - 1;                          scale = (sbyte)source[offset++];                          type = edsTypeBigInt;                          bytes = new byte[length];                          Array.Copy(source' offset' bytes' 0' length);                          offset += length;                          int sign = ((bytes[0] & 0x80) > 0) ? -1 : 1;                            if (sign == -1)                          {                              bytes[0] &= 0x7f;                          }                            BigInteger bi = new BigInteger(bytes);                          bigDecimal = Decimal.Parse(bi.ToString());                      }                      break;                    case edsScaledCount2:                      {                          // For some reason C++ EncodedStream expects the encoded                          // length to be length+1.                            scale = (sbyte)source[offset++];                          sbyte sign = (sbyte)source[offset++];                          length = (source[offset++] & 0xff); // in bytes                          type = edsTypeBigInt;                          bytes = new byte[length];                          Array.Copy(source' offset' bytes' 0' length);                          offset += length;                            if (sign == -1)                              bytes[0] &= 0x7f;                          else                              sign = 1;                            BigInteger bi = new BigInteger(bytes);                          if (sign == -1)                              bi = -bi;                          bigDecimal = ScaleDecimal(Decimal.Parse(bi.ToString())' scale);                      }                      break;                    case edsUUID:                      {                          byte[] buff = new byte[16];                            for (int n = 0; n < 16; ++n)                          {                              buff[n] = (byte)(source[offset++] & 0xff);                          }                            uuid = new Guid(buff);                          type = edsTypeUUID;                      }                      break;                    default:                      type = edsTypeUnknown;                      break;              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,decode,The following statement contains a magic number: switch (code)              {                  case edsNull:                      type = edsTypeNull;                      break;                    case edsTrue:                      type = edsTypeBoolean;                      @bool = true;                      break;                    case edsFalse:                      type = edsTypeBoolean;                      @bool = false;                      break;                    case edsIntMinus10:                  case edsIntMinus9:                  case edsIntMinus8:                  case edsIntMinus7:                  case edsIntMinus6:                  case edsIntMinus5:                  case edsIntMinus4:                  case edsIntMinus3:                  case edsIntMinus2:                  case edsIntMinus1:                  case edsInt0:                  case edsInt1:                  case edsInt2:                  case edsInt3:                  case edsInt4:                  case edsInt5:                  case edsInt6:                  case edsInt7:                  case edsInt8:                  case edsInt9:                  case edsInt10:                  case edsInt11:                  case edsInt12:                  case edsInt13:                  case edsInt14:                  case edsInt15:                  case edsInt16:                  case edsInt17:                  case edsInt18:                  case edsInt19:                  case edsInt20:                  case edsInt21:                  case edsInt22:                  case edsInt23:                  case edsInt24:                  case edsInt25:                  case edsInt26:                  case edsInt27:                  case edsInt28:                  case edsInt29:                  case edsInt30:                  case edsInt31:                      integer32 = code - edsInt0;                      scale = 0;                      type = edsTypeInt32;                      break;                    case edsIntLen1:                      type = edsTypeInt32;                      scale = 0;                      integer32 = (sbyte)source[offset++];                      break;                    case edsIntLen2:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset] << 8) | (source[offset + 1] & 0xff);                      offset += 2;                      break;                    case edsIntLen3:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset]) << 16 | (source[offset + 1] & 0xff) << 8 | (source[offset + 2] & 0xff);                      offset += 3;                      break;                    case edsIntLen4:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset]) << 24 | (source[offset + 1] & 0xff) << 16 | (source[offset + 2] & 0xff) << 8 | (source[offset + 3] & 0xff);                      offset += 4;                      break;                    case edsIntLen5:                  case edsIntLen6:                  case edsIntLen7:                  case edsIntLen8:                      l = code - edsIntLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeInt64;                      break;                    case edsScaledLen0:                      scale = (sbyte)source[offset++];                      integer64 = 0;                      type = edsTypeScaled;                      break;                    case edsScaledLen1:                  case edsScaledLen2:                  case edsScaledLen3:                  case edsScaledLen4:                  case edsScaledLen5:                  case edsScaledLen6:                  case edsScaledLen7:                  case edsScaledLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaled;                      break;                    case edsUtf8Len0:                  case edsUtf8Len1:                  case edsUtf8Len2:                  case edsUtf8Len3:                  case edsUtf8Len4:                  case edsUtf8Len5:                  case edsUtf8Len6:                  case edsUtf8Len7:                  case edsUtf8Len8:                  case edsUtf8Len9:                  case edsUtf8Len10:                  case edsUtf8Len11:                  case edsUtf8Len12:                  case edsUtf8Len13:                  case edsUtf8Len14:                  case edsUtf8Len15:                  case edsUtf8Len16:                  case edsUtf8Len17:                  case edsUtf8Len18:                  case edsUtf8Len19:                  case edsUtf8Len20:                  case edsUtf8Len21:                  case edsUtf8Len22:                  case edsUtf8Len23:                  case edsUtf8Len24:                  case edsUtf8Len25:                  case edsUtf8Len26:                  case edsUtf8Len27:                  case edsUtf8Len28:                  case edsUtf8Len29:                  case edsUtf8Len30:                  case edsUtf8Len31:                  case edsUtf8Len32:                  case edsUtf8Len33:                  case edsUtf8Len34:                  case edsUtf8Len35:                  case edsUtf8Len36:                  case edsUtf8Len37:                  case edsUtf8Len38:                  case edsUtf8Len39:                      l = code - edsUtf8Len0;                      @string = getString(source' offset' l);                      offset += l;                      type = edsTypeUtf8;                      break;                    case edsUtf8Count1:                  case edsUtf8Count2:                  case edsUtf8Count3:                  case edsUtf8Count4:                      count = code - edsUtf8Count1;                      int length = source[offset++] & 0xff;                        for (int n = 0; n < count; ++n)                      {                          length = length << 8 | (source[offset++] & 0xff);                      }                        @string = getString(source' offset' length);                      offset += length;                      type = edsTypeUtf8;                      break;                    case edsOpaqueLen0:                  case edsOpaqueLen1:                  case edsOpaqueLen2:                  case edsOpaqueLen3:                  case edsOpaqueLen4:                  case edsOpaqueLen5:                  case edsOpaqueLen6:                  case edsOpaqueLen7:                  case edsOpaqueLen8:                  case edsOpaqueLen9:                  case edsOpaqueLen10:                  case edsOpaqueLen11:                  case edsOpaqueLen12:                  case edsOpaqueLen13:                  case edsOpaqueLen14:                  case edsOpaqueLen15:                  case edsOpaqueLen16:                  case edsOpaqueLen17:                  case edsOpaqueLen18:                  case edsOpaqueLen19:                  case edsOpaqueLen20:                  case edsOpaqueLen21:                  case edsOpaqueLen22:                  case edsOpaqueLen23:                  case edsOpaqueLen24:                  case edsOpaqueLen25:                  case edsOpaqueLen26:                  case edsOpaqueLen27:                  case edsOpaqueLen28:                  case edsOpaqueLen29:                  case edsOpaqueLen30:                  case edsOpaqueLen31:                  case edsOpaqueLen32:                  case edsOpaqueLen33:                  case edsOpaqueLen34:                  case edsOpaqueLen35:                  case edsOpaqueLen36:                  case edsOpaqueLen37:                  case edsOpaqueLen38:                  case edsOpaqueLen39:                      l = code - edsOpaqueLen0;                      bytes = new byte[l];                      Array.Copy(source' offset' bytes' 0' l);                      offset += l;                      type = edsTypeOpaque;                      break;                    case edsOpaqueCount1:                  case edsOpaqueCount2:                  case edsOpaqueCount3:                  case edsOpaqueCount4:                      count = code - edsOpaqueCount1 + 1;                      l = source[offset++] & 0xff;                        for (int n = 1; n < count; ++n)                      {                          l = l << 8 | (source[offset++] & 0xff);                      }                        bytes = new byte[l];                      Array.Copy(source' offset' bytes' 0' l);                      offset += l;                      type = edsTypeOpaque;                      break;                    case edsDoubleLen0:                  case edsDoubleLen1:                  case edsDoubleLen2:                  case edsDoubleLen3:                  case edsDoubleLen4:                  case edsDoubleLen5:                  case edsDoubleLen6:                  case edsDoubleLen7:                  case edsDoubleLen8:                      count = code - edsDoubleLen0;                      long lvalue = 0;                        for (int n = 0; n < count; ++n)                      {                          lvalue = (lvalue << 8) | (source[offset++] & 0xff);                      }                        lvalue <<= (8 - count) * 8;                      dbl = BitConverter.Int64BitsToDouble(lvalue);                      type = edsTypeDouble;                      break;                    case edsTimeLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeTime;                      break;                    case edsTimeLen1:                  case edsTimeLen2:                  case edsTimeLen3:                  case edsTimeLen4:                      l = code - edsTimeLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeTime;                      break;                    case edsMilliSecLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeMilliseconds;                      break;                    case edsMilliSecLen1:                  case edsMilliSecLen2:                  case edsMilliSecLen3:                  case edsMilliSecLen4:                  case edsMilliSecLen5:                  case edsMilliSecLen6:                  case edsMilliSecLen7:                  case edsMilliSecLen8:                      l = code - edsMilliSecLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeMilliseconds;                      break;                    case edsNanoSecLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeNanoseconds;                      break;                    case edsNanoSecLen1:                  case edsNanoSecLen2:                  case edsNanoSecLen3:                  case edsNanoSecLen4:                  case edsNanoSecLen5:                  case edsNanoSecLen6:                  case edsNanoSecLen7:                  case edsNanoSecLen8:                      l = code - edsNanoSecLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeNanoseconds;                      break;                    //                  // 09/2012 Added support for new scaled date/times encoding. These replace the old encoding                  // edsTimeLen' edsMilliSecLen and edsNanoSecLen.                  //                    case edsScaledTimeLen1:                  case edsScaledTimeLen2:                  case edsScaledTimeLen3:                  case edsScaledTimeLen4:                  case edsScaledTimeLen5:                  case edsScaledTimeLen6:                  case edsScaledTimeLen7:                  case edsScaledTimeLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledTimeLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledTime;                      break;                    case edsScaledDateLen1:                  case edsScaledDateLen2:                  case edsScaledDateLen3:                  case edsScaledDateLen4:                  case edsScaledDateLen5:                  case edsScaledDateLen6:                  case edsScaledDateLen7:                  case edsScaledDateLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledDateLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledDate;                      break;                    case edsScaledTimestampLen1:                  case edsScaledTimestampLen2:                  case edsScaledTimestampLen3:                  case edsScaledTimestampLen4:                  case edsScaledTimestampLen5:                  case edsScaledTimestampLen6:                  case edsScaledTimestampLen7:                  case edsScaledTimestampLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledTimestampLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledTimestamp;                      break;                    case edsClobLen0:                      blobId = 0;                      type = edsTypeClob;                      break;                    case edsClobLen1:                  case edsClobLen2:                  case edsClobLen3:                  case edsClobLen4:                      l = code - edsClobLen1;                      blobId = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          blobId = (blobId << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeClob;                      break;                    case edsBlobLen0:                      blobId = 0;                      type = edsTypeBlob;                      break;                    case edsBlobLen1:                  case edsBlobLen2:                  case edsBlobLen3:                  case edsBlobLen4:                      l = code - edsBlobLen1;                      blobId = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          blobId = (blobId << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeBlob;                      break;                    case edsScaledCount1:                      {                          // For some reason C++ EncodedStream expects the encoded                          // length to be length+1.                            length = (source[offset++] & 0xff) - 1;                          scale = (sbyte)source[offset++];                          type = edsTypeBigInt;                          bytes = new byte[length];                          Array.Copy(source' offset' bytes' 0' length);                          offset += length;                          int sign = ((bytes[0] & 0x80) > 0) ? -1 : 1;                            if (sign == -1)                          {                              bytes[0] &= 0x7f;                          }                            BigInteger bi = new BigInteger(bytes);                          bigDecimal = Decimal.Parse(bi.ToString());                      }                      break;                    case edsScaledCount2:                      {                          // For some reason C++ EncodedStream expects the encoded                          // length to be length+1.                            scale = (sbyte)source[offset++];                          sbyte sign = (sbyte)source[offset++];                          length = (source[offset++] & 0xff); // in bytes                          type = edsTypeBigInt;                          bytes = new byte[length];                          Array.Copy(source' offset' bytes' 0' length);                          offset += length;                            if (sign == -1)                              bytes[0] &= 0x7f;                          else                              sign = 1;                            BigInteger bi = new BigInteger(bytes);                          if (sign == -1)                              bi = -bi;                          bigDecimal = ScaleDecimal(Decimal.Parse(bi.ToString())' scale);                      }                      break;                    case edsUUID:                      {                          byte[] buff = new byte[16];                            for (int n = 0; n < 16; ++n)                          {                              buff[n] = (byte)(source[offset++] & 0xff);                          }                            uuid = new Guid(buff);                          type = edsTypeUUID;                      }                      break;                    default:                      type = edsTypeUnknown;                      break;              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,decode,The following statement contains a magic number: switch (code)              {                  case edsNull:                      type = edsTypeNull;                      break;                    case edsTrue:                      type = edsTypeBoolean;                      @bool = true;                      break;                    case edsFalse:                      type = edsTypeBoolean;                      @bool = false;                      break;                    case edsIntMinus10:                  case edsIntMinus9:                  case edsIntMinus8:                  case edsIntMinus7:                  case edsIntMinus6:                  case edsIntMinus5:                  case edsIntMinus4:                  case edsIntMinus3:                  case edsIntMinus2:                  case edsIntMinus1:                  case edsInt0:                  case edsInt1:                  case edsInt2:                  case edsInt3:                  case edsInt4:                  case edsInt5:                  case edsInt6:                  case edsInt7:                  case edsInt8:                  case edsInt9:                  case edsInt10:                  case edsInt11:                  case edsInt12:                  case edsInt13:                  case edsInt14:                  case edsInt15:                  case edsInt16:                  case edsInt17:                  case edsInt18:                  case edsInt19:                  case edsInt20:                  case edsInt21:                  case edsInt22:                  case edsInt23:                  case edsInt24:                  case edsInt25:                  case edsInt26:                  case edsInt27:                  case edsInt28:                  case edsInt29:                  case edsInt30:                  case edsInt31:                      integer32 = code - edsInt0;                      scale = 0;                      type = edsTypeInt32;                      break;                    case edsIntLen1:                      type = edsTypeInt32;                      scale = 0;                      integer32 = (sbyte)source[offset++];                      break;                    case edsIntLen2:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset] << 8) | (source[offset + 1] & 0xff);                      offset += 2;                      break;                    case edsIntLen3:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset]) << 16 | (source[offset + 1] & 0xff) << 8 | (source[offset + 2] & 0xff);                      offset += 3;                      break;                    case edsIntLen4:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset]) << 24 | (source[offset + 1] & 0xff) << 16 | (source[offset + 2] & 0xff) << 8 | (source[offset + 3] & 0xff);                      offset += 4;                      break;                    case edsIntLen5:                  case edsIntLen6:                  case edsIntLen7:                  case edsIntLen8:                      l = code - edsIntLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeInt64;                      break;                    case edsScaledLen0:                      scale = (sbyte)source[offset++];                      integer64 = 0;                      type = edsTypeScaled;                      break;                    case edsScaledLen1:                  case edsScaledLen2:                  case edsScaledLen3:                  case edsScaledLen4:                  case edsScaledLen5:                  case edsScaledLen6:                  case edsScaledLen7:                  case edsScaledLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaled;                      break;                    case edsUtf8Len0:                  case edsUtf8Len1:                  case edsUtf8Len2:                  case edsUtf8Len3:                  case edsUtf8Len4:                  case edsUtf8Len5:                  case edsUtf8Len6:                  case edsUtf8Len7:                  case edsUtf8Len8:                  case edsUtf8Len9:                  case edsUtf8Len10:                  case edsUtf8Len11:                  case edsUtf8Len12:                  case edsUtf8Len13:                  case edsUtf8Len14:                  case edsUtf8Len15:                  case edsUtf8Len16:                  case edsUtf8Len17:                  case edsUtf8Len18:                  case edsUtf8Len19:                  case edsUtf8Len20:                  case edsUtf8Len21:                  case edsUtf8Len22:                  case edsUtf8Len23:                  case edsUtf8Len24:                  case edsUtf8Len25:                  case edsUtf8Len26:                  case edsUtf8Len27:                  case edsUtf8Len28:                  case edsUtf8Len29:                  case edsUtf8Len30:                  case edsUtf8Len31:                  case edsUtf8Len32:                  case edsUtf8Len33:                  case edsUtf8Len34:                  case edsUtf8Len35:                  case edsUtf8Len36:                  case edsUtf8Len37:                  case edsUtf8Len38:                  case edsUtf8Len39:                      l = code - edsUtf8Len0;                      @string = getString(source' offset' l);                      offset += l;                      type = edsTypeUtf8;                      break;                    case edsUtf8Count1:                  case edsUtf8Count2:                  case edsUtf8Count3:                  case edsUtf8Count4:                      count = code - edsUtf8Count1;                      int length = source[offset++] & 0xff;                        for (int n = 0; n < count; ++n)                      {                          length = length << 8 | (source[offset++] & 0xff);                      }                        @string = getString(source' offset' length);                      offset += length;                      type = edsTypeUtf8;                      break;                    case edsOpaqueLen0:                  case edsOpaqueLen1:                  case edsOpaqueLen2:                  case edsOpaqueLen3:                  case edsOpaqueLen4:                  case edsOpaqueLen5:                  case edsOpaqueLen6:                  case edsOpaqueLen7:                  case edsOpaqueLen8:                  case edsOpaqueLen9:                  case edsOpaqueLen10:                  case edsOpaqueLen11:                  case edsOpaqueLen12:                  case edsOpaqueLen13:                  case edsOpaqueLen14:                  case edsOpaqueLen15:                  case edsOpaqueLen16:                  case edsOpaqueLen17:                  case edsOpaqueLen18:                  case edsOpaqueLen19:                  case edsOpaqueLen20:                  case edsOpaqueLen21:                  case edsOpaqueLen22:                  case edsOpaqueLen23:                  case edsOpaqueLen24:                  case edsOpaqueLen25:                  case edsOpaqueLen26:                  case edsOpaqueLen27:                  case edsOpaqueLen28:                  case edsOpaqueLen29:                  case edsOpaqueLen30:                  case edsOpaqueLen31:                  case edsOpaqueLen32:                  case edsOpaqueLen33:                  case edsOpaqueLen34:                  case edsOpaqueLen35:                  case edsOpaqueLen36:                  case edsOpaqueLen37:                  case edsOpaqueLen38:                  case edsOpaqueLen39:                      l = code - edsOpaqueLen0;                      bytes = new byte[l];                      Array.Copy(source' offset' bytes' 0' l);                      offset += l;                      type = edsTypeOpaque;                      break;                    case edsOpaqueCount1:                  case edsOpaqueCount2:                  case edsOpaqueCount3:                  case edsOpaqueCount4:                      count = code - edsOpaqueCount1 + 1;                      l = source[offset++] & 0xff;                        for (int n = 1; n < count; ++n)                      {                          l = l << 8 | (source[offset++] & 0xff);                      }                        bytes = new byte[l];                      Array.Copy(source' offset' bytes' 0' l);                      offset += l;                      type = edsTypeOpaque;                      break;                    case edsDoubleLen0:                  case edsDoubleLen1:                  case edsDoubleLen2:                  case edsDoubleLen3:                  case edsDoubleLen4:                  case edsDoubleLen5:                  case edsDoubleLen6:                  case edsDoubleLen7:                  case edsDoubleLen8:                      count = code - edsDoubleLen0;                      long lvalue = 0;                        for (int n = 0; n < count; ++n)                      {                          lvalue = (lvalue << 8) | (source[offset++] & 0xff);                      }                        lvalue <<= (8 - count) * 8;                      dbl = BitConverter.Int64BitsToDouble(lvalue);                      type = edsTypeDouble;                      break;                    case edsTimeLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeTime;                      break;                    case edsTimeLen1:                  case edsTimeLen2:                  case edsTimeLen3:                  case edsTimeLen4:                      l = code - edsTimeLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeTime;                      break;                    case edsMilliSecLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeMilliseconds;                      break;                    case edsMilliSecLen1:                  case edsMilliSecLen2:                  case edsMilliSecLen3:                  case edsMilliSecLen4:                  case edsMilliSecLen5:                  case edsMilliSecLen6:                  case edsMilliSecLen7:                  case edsMilliSecLen8:                      l = code - edsMilliSecLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeMilliseconds;                      break;                    case edsNanoSecLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeNanoseconds;                      break;                    case edsNanoSecLen1:                  case edsNanoSecLen2:                  case edsNanoSecLen3:                  case edsNanoSecLen4:                  case edsNanoSecLen5:                  case edsNanoSecLen6:                  case edsNanoSecLen7:                  case edsNanoSecLen8:                      l = code - edsNanoSecLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeNanoseconds;                      break;                    //                  // 09/2012 Added support for new scaled date/times encoding. These replace the old encoding                  // edsTimeLen' edsMilliSecLen and edsNanoSecLen.                  //                    case edsScaledTimeLen1:                  case edsScaledTimeLen2:                  case edsScaledTimeLen3:                  case edsScaledTimeLen4:                  case edsScaledTimeLen5:                  case edsScaledTimeLen6:                  case edsScaledTimeLen7:                  case edsScaledTimeLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledTimeLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledTime;                      break;                    case edsScaledDateLen1:                  case edsScaledDateLen2:                  case edsScaledDateLen3:                  case edsScaledDateLen4:                  case edsScaledDateLen5:                  case edsScaledDateLen6:                  case edsScaledDateLen7:                  case edsScaledDateLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledDateLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledDate;                      break;                    case edsScaledTimestampLen1:                  case edsScaledTimestampLen2:                  case edsScaledTimestampLen3:                  case edsScaledTimestampLen4:                  case edsScaledTimestampLen5:                  case edsScaledTimestampLen6:                  case edsScaledTimestampLen7:                  case edsScaledTimestampLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledTimestampLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledTimestamp;                      break;                    case edsClobLen0:                      blobId = 0;                      type = edsTypeClob;                      break;                    case edsClobLen1:                  case edsClobLen2:                  case edsClobLen3:                  case edsClobLen4:                      l = code - edsClobLen1;                      blobId = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          blobId = (blobId << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeClob;                      break;                    case edsBlobLen0:                      blobId = 0;                      type = edsTypeBlob;                      break;                    case edsBlobLen1:                  case edsBlobLen2:                  case edsBlobLen3:                  case edsBlobLen4:                      l = code - edsBlobLen1;                      blobId = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          blobId = (blobId << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeBlob;                      break;                    case edsScaledCount1:                      {                          // For some reason C++ EncodedStream expects the encoded                          // length to be length+1.                            length = (source[offset++] & 0xff) - 1;                          scale = (sbyte)source[offset++];                          type = edsTypeBigInt;                          bytes = new byte[length];                          Array.Copy(source' offset' bytes' 0' length);                          offset += length;                          int sign = ((bytes[0] & 0x80) > 0) ? -1 : 1;                            if (sign == -1)                          {                              bytes[0] &= 0x7f;                          }                            BigInteger bi = new BigInteger(bytes);                          bigDecimal = Decimal.Parse(bi.ToString());                      }                      break;                    case edsScaledCount2:                      {                          // For some reason C++ EncodedStream expects the encoded                          // length to be length+1.                            scale = (sbyte)source[offset++];                          sbyte sign = (sbyte)source[offset++];                          length = (source[offset++] & 0xff); // in bytes                          type = edsTypeBigInt;                          bytes = new byte[length];                          Array.Copy(source' offset' bytes' 0' length);                          offset += length;                            if (sign == -1)                              bytes[0] &= 0x7f;                          else                              sign = 1;                            BigInteger bi = new BigInteger(bytes);                          if (sign == -1)                              bi = -bi;                          bigDecimal = ScaleDecimal(Decimal.Parse(bi.ToString())' scale);                      }                      break;                    case edsUUID:                      {                          byte[] buff = new byte[16];                            for (int n = 0; n < 16; ++n)                          {                              buff[n] = (byte)(source[offset++] & 0xff);                          }                            uuid = new Guid(buff);                          type = edsTypeUUID;                      }                      break;                    default:                      type = edsTypeUnknown;                      break;              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,decode,The following statement contains a magic number: switch (code)              {                  case edsNull:                      type = edsTypeNull;                      break;                    case edsTrue:                      type = edsTypeBoolean;                      @bool = true;                      break;                    case edsFalse:                      type = edsTypeBoolean;                      @bool = false;                      break;                    case edsIntMinus10:                  case edsIntMinus9:                  case edsIntMinus8:                  case edsIntMinus7:                  case edsIntMinus6:                  case edsIntMinus5:                  case edsIntMinus4:                  case edsIntMinus3:                  case edsIntMinus2:                  case edsIntMinus1:                  case edsInt0:                  case edsInt1:                  case edsInt2:                  case edsInt3:                  case edsInt4:                  case edsInt5:                  case edsInt6:                  case edsInt7:                  case edsInt8:                  case edsInt9:                  case edsInt10:                  case edsInt11:                  case edsInt12:                  case edsInt13:                  case edsInt14:                  case edsInt15:                  case edsInt16:                  case edsInt17:                  case edsInt18:                  case edsInt19:                  case edsInt20:                  case edsInt21:                  case edsInt22:                  case edsInt23:                  case edsInt24:                  case edsInt25:                  case edsInt26:                  case edsInt27:                  case edsInt28:                  case edsInt29:                  case edsInt30:                  case edsInt31:                      integer32 = code - edsInt0;                      scale = 0;                      type = edsTypeInt32;                      break;                    case edsIntLen1:                      type = edsTypeInt32;                      scale = 0;                      integer32 = (sbyte)source[offset++];                      break;                    case edsIntLen2:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset] << 8) | (source[offset + 1] & 0xff);                      offset += 2;                      break;                    case edsIntLen3:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset]) << 16 | (source[offset + 1] & 0xff) << 8 | (source[offset + 2] & 0xff);                      offset += 3;                      break;                    case edsIntLen4:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset]) << 24 | (source[offset + 1] & 0xff) << 16 | (source[offset + 2] & 0xff) << 8 | (source[offset + 3] & 0xff);                      offset += 4;                      break;                    case edsIntLen5:                  case edsIntLen6:                  case edsIntLen7:                  case edsIntLen8:                      l = code - edsIntLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeInt64;                      break;                    case edsScaledLen0:                      scale = (sbyte)source[offset++];                      integer64 = 0;                      type = edsTypeScaled;                      break;                    case edsScaledLen1:                  case edsScaledLen2:                  case edsScaledLen3:                  case edsScaledLen4:                  case edsScaledLen5:                  case edsScaledLen6:                  case edsScaledLen7:                  case edsScaledLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaled;                      break;                    case edsUtf8Len0:                  case edsUtf8Len1:                  case edsUtf8Len2:                  case edsUtf8Len3:                  case edsUtf8Len4:                  case edsUtf8Len5:                  case edsUtf8Len6:                  case edsUtf8Len7:                  case edsUtf8Len8:                  case edsUtf8Len9:                  case edsUtf8Len10:                  case edsUtf8Len11:                  case edsUtf8Len12:                  case edsUtf8Len13:                  case edsUtf8Len14:                  case edsUtf8Len15:                  case edsUtf8Len16:                  case edsUtf8Len17:                  case edsUtf8Len18:                  case edsUtf8Len19:                  case edsUtf8Len20:                  case edsUtf8Len21:                  case edsUtf8Len22:                  case edsUtf8Len23:                  case edsUtf8Len24:                  case edsUtf8Len25:                  case edsUtf8Len26:                  case edsUtf8Len27:                  case edsUtf8Len28:                  case edsUtf8Len29:                  case edsUtf8Len30:                  case edsUtf8Len31:                  case edsUtf8Len32:                  case edsUtf8Len33:                  case edsUtf8Len34:                  case edsUtf8Len35:                  case edsUtf8Len36:                  case edsUtf8Len37:                  case edsUtf8Len38:                  case edsUtf8Len39:                      l = code - edsUtf8Len0;                      @string = getString(source' offset' l);                      offset += l;                      type = edsTypeUtf8;                      break;                    case edsUtf8Count1:                  case edsUtf8Count2:                  case edsUtf8Count3:                  case edsUtf8Count4:                      count = code - edsUtf8Count1;                      int length = source[offset++] & 0xff;                        for (int n = 0; n < count; ++n)                      {                          length = length << 8 | (source[offset++] & 0xff);                      }                        @string = getString(source' offset' length);                      offset += length;                      type = edsTypeUtf8;                      break;                    case edsOpaqueLen0:                  case edsOpaqueLen1:                  case edsOpaqueLen2:                  case edsOpaqueLen3:                  case edsOpaqueLen4:                  case edsOpaqueLen5:                  case edsOpaqueLen6:                  case edsOpaqueLen7:                  case edsOpaqueLen8:                  case edsOpaqueLen9:                  case edsOpaqueLen10:                  case edsOpaqueLen11:                  case edsOpaqueLen12:                  case edsOpaqueLen13:                  case edsOpaqueLen14:                  case edsOpaqueLen15:                  case edsOpaqueLen16:                  case edsOpaqueLen17:                  case edsOpaqueLen18:                  case edsOpaqueLen19:                  case edsOpaqueLen20:                  case edsOpaqueLen21:                  case edsOpaqueLen22:                  case edsOpaqueLen23:                  case edsOpaqueLen24:                  case edsOpaqueLen25:                  case edsOpaqueLen26:                  case edsOpaqueLen27:                  case edsOpaqueLen28:                  case edsOpaqueLen29:                  case edsOpaqueLen30:                  case edsOpaqueLen31:                  case edsOpaqueLen32:                  case edsOpaqueLen33:                  case edsOpaqueLen34:                  case edsOpaqueLen35:                  case edsOpaqueLen36:                  case edsOpaqueLen37:                  case edsOpaqueLen38:                  case edsOpaqueLen39:                      l = code - edsOpaqueLen0;                      bytes = new byte[l];                      Array.Copy(source' offset' bytes' 0' l);                      offset += l;                      type = edsTypeOpaque;                      break;                    case edsOpaqueCount1:                  case edsOpaqueCount2:                  case edsOpaqueCount3:                  case edsOpaqueCount4:                      count = code - edsOpaqueCount1 + 1;                      l = source[offset++] & 0xff;                        for (int n = 1; n < count; ++n)                      {                          l = l << 8 | (source[offset++] & 0xff);                      }                        bytes = new byte[l];                      Array.Copy(source' offset' bytes' 0' l);                      offset += l;                      type = edsTypeOpaque;                      break;                    case edsDoubleLen0:                  case edsDoubleLen1:                  case edsDoubleLen2:                  case edsDoubleLen3:                  case edsDoubleLen4:                  case edsDoubleLen5:                  case edsDoubleLen6:                  case edsDoubleLen7:                  case edsDoubleLen8:                      count = code - edsDoubleLen0;                      long lvalue = 0;                        for (int n = 0; n < count; ++n)                      {                          lvalue = (lvalue << 8) | (source[offset++] & 0xff);                      }                        lvalue <<= (8 - count) * 8;                      dbl = BitConverter.Int64BitsToDouble(lvalue);                      type = edsTypeDouble;                      break;                    case edsTimeLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeTime;                      break;                    case edsTimeLen1:                  case edsTimeLen2:                  case edsTimeLen3:                  case edsTimeLen4:                      l = code - edsTimeLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeTime;                      break;                    case edsMilliSecLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeMilliseconds;                      break;                    case edsMilliSecLen1:                  case edsMilliSecLen2:                  case edsMilliSecLen3:                  case edsMilliSecLen4:                  case edsMilliSecLen5:                  case edsMilliSecLen6:                  case edsMilliSecLen7:                  case edsMilliSecLen8:                      l = code - edsMilliSecLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeMilliseconds;                      break;                    case edsNanoSecLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeNanoseconds;                      break;                    case edsNanoSecLen1:                  case edsNanoSecLen2:                  case edsNanoSecLen3:                  case edsNanoSecLen4:                  case edsNanoSecLen5:                  case edsNanoSecLen6:                  case edsNanoSecLen7:                  case edsNanoSecLen8:                      l = code - edsNanoSecLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeNanoseconds;                      break;                    //                  // 09/2012 Added support for new scaled date/times encoding. These replace the old encoding                  // edsTimeLen' edsMilliSecLen and edsNanoSecLen.                  //                    case edsScaledTimeLen1:                  case edsScaledTimeLen2:                  case edsScaledTimeLen3:                  case edsScaledTimeLen4:                  case edsScaledTimeLen5:                  case edsScaledTimeLen6:                  case edsScaledTimeLen7:                  case edsScaledTimeLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledTimeLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledTime;                      break;                    case edsScaledDateLen1:                  case edsScaledDateLen2:                  case edsScaledDateLen3:                  case edsScaledDateLen4:                  case edsScaledDateLen5:                  case edsScaledDateLen6:                  case edsScaledDateLen7:                  case edsScaledDateLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledDateLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledDate;                      break;                    case edsScaledTimestampLen1:                  case edsScaledTimestampLen2:                  case edsScaledTimestampLen3:                  case edsScaledTimestampLen4:                  case edsScaledTimestampLen5:                  case edsScaledTimestampLen6:                  case edsScaledTimestampLen7:                  case edsScaledTimestampLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledTimestampLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledTimestamp;                      break;                    case edsClobLen0:                      blobId = 0;                      type = edsTypeClob;                      break;                    case edsClobLen1:                  case edsClobLen2:                  case edsClobLen3:                  case edsClobLen4:                      l = code - edsClobLen1;                      blobId = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          blobId = (blobId << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeClob;                      break;                    case edsBlobLen0:                      blobId = 0;                      type = edsTypeBlob;                      break;                    case edsBlobLen1:                  case edsBlobLen2:                  case edsBlobLen3:                  case edsBlobLen4:                      l = code - edsBlobLen1;                      blobId = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          blobId = (blobId << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeBlob;                      break;                    case edsScaledCount1:                      {                          // For some reason C++ EncodedStream expects the encoded                          // length to be length+1.                            length = (source[offset++] & 0xff) - 1;                          scale = (sbyte)source[offset++];                          type = edsTypeBigInt;                          bytes = new byte[length];                          Array.Copy(source' offset' bytes' 0' length);                          offset += length;                          int sign = ((bytes[0] & 0x80) > 0) ? -1 : 1;                            if (sign == -1)                          {                              bytes[0] &= 0x7f;                          }                            BigInteger bi = new BigInteger(bytes);                          bigDecimal = Decimal.Parse(bi.ToString());                      }                      break;                    case edsScaledCount2:                      {                          // For some reason C++ EncodedStream expects the encoded                          // length to be length+1.                            scale = (sbyte)source[offset++];                          sbyte sign = (sbyte)source[offset++];                          length = (source[offset++] & 0xff); // in bytes                          type = edsTypeBigInt;                          bytes = new byte[length];                          Array.Copy(source' offset' bytes' 0' length);                          offset += length;                            if (sign == -1)                              bytes[0] &= 0x7f;                          else                              sign = 1;                            BigInteger bi = new BigInteger(bytes);                          if (sign == -1)                              bi = -bi;                          bigDecimal = ScaleDecimal(Decimal.Parse(bi.ToString())' scale);                      }                      break;                    case edsUUID:                      {                          byte[] buff = new byte[16];                            for (int n = 0; n < 16; ++n)                          {                              buff[n] = (byte)(source[offset++] & 0xff);                          }                            uuid = new Guid(buff);                          type = edsTypeUUID;                      }                      break;                    default:                      type = edsTypeUnknown;                      break;              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,decode,The following statement contains a magic number: switch (code)              {                  case edsNull:                      type = edsTypeNull;                      break;                    case edsTrue:                      type = edsTypeBoolean;                      @bool = true;                      break;                    case edsFalse:                      type = edsTypeBoolean;                      @bool = false;                      break;                    case edsIntMinus10:                  case edsIntMinus9:                  case edsIntMinus8:                  case edsIntMinus7:                  case edsIntMinus6:                  case edsIntMinus5:                  case edsIntMinus4:                  case edsIntMinus3:                  case edsIntMinus2:                  case edsIntMinus1:                  case edsInt0:                  case edsInt1:                  case edsInt2:                  case edsInt3:                  case edsInt4:                  case edsInt5:                  case edsInt6:                  case edsInt7:                  case edsInt8:                  case edsInt9:                  case edsInt10:                  case edsInt11:                  case edsInt12:                  case edsInt13:                  case edsInt14:                  case edsInt15:                  case edsInt16:                  case edsInt17:                  case edsInt18:                  case edsInt19:                  case edsInt20:                  case edsInt21:                  case edsInt22:                  case edsInt23:                  case edsInt24:                  case edsInt25:                  case edsInt26:                  case edsInt27:                  case edsInt28:                  case edsInt29:                  case edsInt30:                  case edsInt31:                      integer32 = code - edsInt0;                      scale = 0;                      type = edsTypeInt32;                      break;                    case edsIntLen1:                      type = edsTypeInt32;                      scale = 0;                      integer32 = (sbyte)source[offset++];                      break;                    case edsIntLen2:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset] << 8) | (source[offset + 1] & 0xff);                      offset += 2;                      break;                    case edsIntLen3:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset]) << 16 | (source[offset + 1] & 0xff) << 8 | (source[offset + 2] & 0xff);                      offset += 3;                      break;                    case edsIntLen4:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset]) << 24 | (source[offset + 1] & 0xff) << 16 | (source[offset + 2] & 0xff) << 8 | (source[offset + 3] & 0xff);                      offset += 4;                      break;                    case edsIntLen5:                  case edsIntLen6:                  case edsIntLen7:                  case edsIntLen8:                      l = code - edsIntLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeInt64;                      break;                    case edsScaledLen0:                      scale = (sbyte)source[offset++];                      integer64 = 0;                      type = edsTypeScaled;                      break;                    case edsScaledLen1:                  case edsScaledLen2:                  case edsScaledLen3:                  case edsScaledLen4:                  case edsScaledLen5:                  case edsScaledLen6:                  case edsScaledLen7:                  case edsScaledLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaled;                      break;                    case edsUtf8Len0:                  case edsUtf8Len1:                  case edsUtf8Len2:                  case edsUtf8Len3:                  case edsUtf8Len4:                  case edsUtf8Len5:                  case edsUtf8Len6:                  case edsUtf8Len7:                  case edsUtf8Len8:                  case edsUtf8Len9:                  case edsUtf8Len10:                  case edsUtf8Len11:                  case edsUtf8Len12:                  case edsUtf8Len13:                  case edsUtf8Len14:                  case edsUtf8Len15:                  case edsUtf8Len16:                  case edsUtf8Len17:                  case edsUtf8Len18:                  case edsUtf8Len19:                  case edsUtf8Len20:                  case edsUtf8Len21:                  case edsUtf8Len22:                  case edsUtf8Len23:                  case edsUtf8Len24:                  case edsUtf8Len25:                  case edsUtf8Len26:                  case edsUtf8Len27:                  case edsUtf8Len28:                  case edsUtf8Len29:                  case edsUtf8Len30:                  case edsUtf8Len31:                  case edsUtf8Len32:                  case edsUtf8Len33:                  case edsUtf8Len34:                  case edsUtf8Len35:                  case edsUtf8Len36:                  case edsUtf8Len37:                  case edsUtf8Len38:                  case edsUtf8Len39:                      l = code - edsUtf8Len0;                      @string = getString(source' offset' l);                      offset += l;                      type = edsTypeUtf8;                      break;                    case edsUtf8Count1:                  case edsUtf8Count2:                  case edsUtf8Count3:                  case edsUtf8Count4:                      count = code - edsUtf8Count1;                      int length = source[offset++] & 0xff;                        for (int n = 0; n < count; ++n)                      {                          length = length << 8 | (source[offset++] & 0xff);                      }                        @string = getString(source' offset' length);                      offset += length;                      type = edsTypeUtf8;                      break;                    case edsOpaqueLen0:                  case edsOpaqueLen1:                  case edsOpaqueLen2:                  case edsOpaqueLen3:                  case edsOpaqueLen4:                  case edsOpaqueLen5:                  case edsOpaqueLen6:                  case edsOpaqueLen7:                  case edsOpaqueLen8:                  case edsOpaqueLen9:                  case edsOpaqueLen10:                  case edsOpaqueLen11:                  case edsOpaqueLen12:                  case edsOpaqueLen13:                  case edsOpaqueLen14:                  case edsOpaqueLen15:                  case edsOpaqueLen16:                  case edsOpaqueLen17:                  case edsOpaqueLen18:                  case edsOpaqueLen19:                  case edsOpaqueLen20:                  case edsOpaqueLen21:                  case edsOpaqueLen22:                  case edsOpaqueLen23:                  case edsOpaqueLen24:                  case edsOpaqueLen25:                  case edsOpaqueLen26:                  case edsOpaqueLen27:                  case edsOpaqueLen28:                  case edsOpaqueLen29:                  case edsOpaqueLen30:                  case edsOpaqueLen31:                  case edsOpaqueLen32:                  case edsOpaqueLen33:                  case edsOpaqueLen34:                  case edsOpaqueLen35:                  case edsOpaqueLen36:                  case edsOpaqueLen37:                  case edsOpaqueLen38:                  case edsOpaqueLen39:                      l = code - edsOpaqueLen0;                      bytes = new byte[l];                      Array.Copy(source' offset' bytes' 0' l);                      offset += l;                      type = edsTypeOpaque;                      break;                    case edsOpaqueCount1:                  case edsOpaqueCount2:                  case edsOpaqueCount3:                  case edsOpaqueCount4:                      count = code - edsOpaqueCount1 + 1;                      l = source[offset++] & 0xff;                        for (int n = 1; n < count; ++n)                      {                          l = l << 8 | (source[offset++] & 0xff);                      }                        bytes = new byte[l];                      Array.Copy(source' offset' bytes' 0' l);                      offset += l;                      type = edsTypeOpaque;                      break;                    case edsDoubleLen0:                  case edsDoubleLen1:                  case edsDoubleLen2:                  case edsDoubleLen3:                  case edsDoubleLen4:                  case edsDoubleLen5:                  case edsDoubleLen6:                  case edsDoubleLen7:                  case edsDoubleLen8:                      count = code - edsDoubleLen0;                      long lvalue = 0;                        for (int n = 0; n < count; ++n)                      {                          lvalue = (lvalue << 8) | (source[offset++] & 0xff);                      }                        lvalue <<= (8 - count) * 8;                      dbl = BitConverter.Int64BitsToDouble(lvalue);                      type = edsTypeDouble;                      break;                    case edsTimeLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeTime;                      break;                    case edsTimeLen1:                  case edsTimeLen2:                  case edsTimeLen3:                  case edsTimeLen4:                      l = code - edsTimeLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeTime;                      break;                    case edsMilliSecLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeMilliseconds;                      break;                    case edsMilliSecLen1:                  case edsMilliSecLen2:                  case edsMilliSecLen3:                  case edsMilliSecLen4:                  case edsMilliSecLen5:                  case edsMilliSecLen6:                  case edsMilliSecLen7:                  case edsMilliSecLen8:                      l = code - edsMilliSecLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeMilliseconds;                      break;                    case edsNanoSecLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeNanoseconds;                      break;                    case edsNanoSecLen1:                  case edsNanoSecLen2:                  case edsNanoSecLen3:                  case edsNanoSecLen4:                  case edsNanoSecLen5:                  case edsNanoSecLen6:                  case edsNanoSecLen7:                  case edsNanoSecLen8:                      l = code - edsNanoSecLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeNanoseconds;                      break;                    //                  // 09/2012 Added support for new scaled date/times encoding. These replace the old encoding                  // edsTimeLen' edsMilliSecLen and edsNanoSecLen.                  //                    case edsScaledTimeLen1:                  case edsScaledTimeLen2:                  case edsScaledTimeLen3:                  case edsScaledTimeLen4:                  case edsScaledTimeLen5:                  case edsScaledTimeLen6:                  case edsScaledTimeLen7:                  case edsScaledTimeLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledTimeLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledTime;                      break;                    case edsScaledDateLen1:                  case edsScaledDateLen2:                  case edsScaledDateLen3:                  case edsScaledDateLen4:                  case edsScaledDateLen5:                  case edsScaledDateLen6:                  case edsScaledDateLen7:                  case edsScaledDateLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledDateLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledDate;                      break;                    case edsScaledTimestampLen1:                  case edsScaledTimestampLen2:                  case edsScaledTimestampLen3:                  case edsScaledTimestampLen4:                  case edsScaledTimestampLen5:                  case edsScaledTimestampLen6:                  case edsScaledTimestampLen7:                  case edsScaledTimestampLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledTimestampLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledTimestamp;                      break;                    case edsClobLen0:                      blobId = 0;                      type = edsTypeClob;                      break;                    case edsClobLen1:                  case edsClobLen2:                  case edsClobLen3:                  case edsClobLen4:                      l = code - edsClobLen1;                      blobId = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          blobId = (blobId << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeClob;                      break;                    case edsBlobLen0:                      blobId = 0;                      type = edsTypeBlob;                      break;                    case edsBlobLen1:                  case edsBlobLen2:                  case edsBlobLen3:                  case edsBlobLen4:                      l = code - edsBlobLen1;                      blobId = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          blobId = (blobId << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeBlob;                      break;                    case edsScaledCount1:                      {                          // For some reason C++ EncodedStream expects the encoded                          // length to be length+1.                            length = (source[offset++] & 0xff) - 1;                          scale = (sbyte)source[offset++];                          type = edsTypeBigInt;                          bytes = new byte[length];                          Array.Copy(source' offset' bytes' 0' length);                          offset += length;                          int sign = ((bytes[0] & 0x80) > 0) ? -1 : 1;                            if (sign == -1)                          {                              bytes[0] &= 0x7f;                          }                            BigInteger bi = new BigInteger(bytes);                          bigDecimal = Decimal.Parse(bi.ToString());                      }                      break;                    case edsScaledCount2:                      {                          // For some reason C++ EncodedStream expects the encoded                          // length to be length+1.                            scale = (sbyte)source[offset++];                          sbyte sign = (sbyte)source[offset++];                          length = (source[offset++] & 0xff); // in bytes                          type = edsTypeBigInt;                          bytes = new byte[length];                          Array.Copy(source' offset' bytes' 0' length);                          offset += length;                            if (sign == -1)                              bytes[0] &= 0x7f;                          else                              sign = 1;                            BigInteger bi = new BigInteger(bytes);                          if (sign == -1)                              bi = -bi;                          bigDecimal = ScaleDecimal(Decimal.Parse(bi.ToString())' scale);                      }                      break;                    case edsUUID:                      {                          byte[] buff = new byte[16];                            for (int n = 0; n < 16; ++n)                          {                              buff[n] = (byte)(source[offset++] & 0xff);                          }                            uuid = new Guid(buff);                          type = edsTypeUUID;                      }                      break;                    default:                      type = edsTypeUnknown;                      break;              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,decode,The following statement contains a magic number: switch (code)              {                  case edsNull:                      type = edsTypeNull;                      break;                    case edsTrue:                      type = edsTypeBoolean;                      @bool = true;                      break;                    case edsFalse:                      type = edsTypeBoolean;                      @bool = false;                      break;                    case edsIntMinus10:                  case edsIntMinus9:                  case edsIntMinus8:                  case edsIntMinus7:                  case edsIntMinus6:                  case edsIntMinus5:                  case edsIntMinus4:                  case edsIntMinus3:                  case edsIntMinus2:                  case edsIntMinus1:                  case edsInt0:                  case edsInt1:                  case edsInt2:                  case edsInt3:                  case edsInt4:                  case edsInt5:                  case edsInt6:                  case edsInt7:                  case edsInt8:                  case edsInt9:                  case edsInt10:                  case edsInt11:                  case edsInt12:                  case edsInt13:                  case edsInt14:                  case edsInt15:                  case edsInt16:                  case edsInt17:                  case edsInt18:                  case edsInt19:                  case edsInt20:                  case edsInt21:                  case edsInt22:                  case edsInt23:                  case edsInt24:                  case edsInt25:                  case edsInt26:                  case edsInt27:                  case edsInt28:                  case edsInt29:                  case edsInt30:                  case edsInt31:                      integer32 = code - edsInt0;                      scale = 0;                      type = edsTypeInt32;                      break;                    case edsIntLen1:                      type = edsTypeInt32;                      scale = 0;                      integer32 = (sbyte)source[offset++];                      break;                    case edsIntLen2:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset] << 8) | (source[offset + 1] & 0xff);                      offset += 2;                      break;                    case edsIntLen3:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset]) << 16 | (source[offset + 1] & 0xff) << 8 | (source[offset + 2] & 0xff);                      offset += 3;                      break;                    case edsIntLen4:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset]) << 24 | (source[offset + 1] & 0xff) << 16 | (source[offset + 2] & 0xff) << 8 | (source[offset + 3] & 0xff);                      offset += 4;                      break;                    case edsIntLen5:                  case edsIntLen6:                  case edsIntLen7:                  case edsIntLen8:                      l = code - edsIntLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeInt64;                      break;                    case edsScaledLen0:                      scale = (sbyte)source[offset++];                      integer64 = 0;                      type = edsTypeScaled;                      break;                    case edsScaledLen1:                  case edsScaledLen2:                  case edsScaledLen3:                  case edsScaledLen4:                  case edsScaledLen5:                  case edsScaledLen6:                  case edsScaledLen7:                  case edsScaledLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaled;                      break;                    case edsUtf8Len0:                  case edsUtf8Len1:                  case edsUtf8Len2:                  case edsUtf8Len3:                  case edsUtf8Len4:                  case edsUtf8Len5:                  case edsUtf8Len6:                  case edsUtf8Len7:                  case edsUtf8Len8:                  case edsUtf8Len9:                  case edsUtf8Len10:                  case edsUtf8Len11:                  case edsUtf8Len12:                  case edsUtf8Len13:                  case edsUtf8Len14:                  case edsUtf8Len15:                  case edsUtf8Len16:                  case edsUtf8Len17:                  case edsUtf8Len18:                  case edsUtf8Len19:                  case edsUtf8Len20:                  case edsUtf8Len21:                  case edsUtf8Len22:                  case edsUtf8Len23:                  case edsUtf8Len24:                  case edsUtf8Len25:                  case edsUtf8Len26:                  case edsUtf8Len27:                  case edsUtf8Len28:                  case edsUtf8Len29:                  case edsUtf8Len30:                  case edsUtf8Len31:                  case edsUtf8Len32:                  case edsUtf8Len33:                  case edsUtf8Len34:                  case edsUtf8Len35:                  case edsUtf8Len36:                  case edsUtf8Len37:                  case edsUtf8Len38:                  case edsUtf8Len39:                      l = code - edsUtf8Len0;                      @string = getString(source' offset' l);                      offset += l;                      type = edsTypeUtf8;                      break;                    case edsUtf8Count1:                  case edsUtf8Count2:                  case edsUtf8Count3:                  case edsUtf8Count4:                      count = code - edsUtf8Count1;                      int length = source[offset++] & 0xff;                        for (int n = 0; n < count; ++n)                      {                          length = length << 8 | (source[offset++] & 0xff);                      }                        @string = getString(source' offset' length);                      offset += length;                      type = edsTypeUtf8;                      break;                    case edsOpaqueLen0:                  case edsOpaqueLen1:                  case edsOpaqueLen2:                  case edsOpaqueLen3:                  case edsOpaqueLen4:                  case edsOpaqueLen5:                  case edsOpaqueLen6:                  case edsOpaqueLen7:                  case edsOpaqueLen8:                  case edsOpaqueLen9:                  case edsOpaqueLen10:                  case edsOpaqueLen11:                  case edsOpaqueLen12:                  case edsOpaqueLen13:                  case edsOpaqueLen14:                  case edsOpaqueLen15:                  case edsOpaqueLen16:                  case edsOpaqueLen17:                  case edsOpaqueLen18:                  case edsOpaqueLen19:                  case edsOpaqueLen20:                  case edsOpaqueLen21:                  case edsOpaqueLen22:                  case edsOpaqueLen23:                  case edsOpaqueLen24:                  case edsOpaqueLen25:                  case edsOpaqueLen26:                  case edsOpaqueLen27:                  case edsOpaqueLen28:                  case edsOpaqueLen29:                  case edsOpaqueLen30:                  case edsOpaqueLen31:                  case edsOpaqueLen32:                  case edsOpaqueLen33:                  case edsOpaqueLen34:                  case edsOpaqueLen35:                  case edsOpaqueLen36:                  case edsOpaqueLen37:                  case edsOpaqueLen38:                  case edsOpaqueLen39:                      l = code - edsOpaqueLen0;                      bytes = new byte[l];                      Array.Copy(source' offset' bytes' 0' l);                      offset += l;                      type = edsTypeOpaque;                      break;                    case edsOpaqueCount1:                  case edsOpaqueCount2:                  case edsOpaqueCount3:                  case edsOpaqueCount4:                      count = code - edsOpaqueCount1 + 1;                      l = source[offset++] & 0xff;                        for (int n = 1; n < count; ++n)                      {                          l = l << 8 | (source[offset++] & 0xff);                      }                        bytes = new byte[l];                      Array.Copy(source' offset' bytes' 0' l);                      offset += l;                      type = edsTypeOpaque;                      break;                    case edsDoubleLen0:                  case edsDoubleLen1:                  case edsDoubleLen2:                  case edsDoubleLen3:                  case edsDoubleLen4:                  case edsDoubleLen5:                  case edsDoubleLen6:                  case edsDoubleLen7:                  case edsDoubleLen8:                      count = code - edsDoubleLen0;                      long lvalue = 0;                        for (int n = 0; n < count; ++n)                      {                          lvalue = (lvalue << 8) | (source[offset++] & 0xff);                      }                        lvalue <<= (8 - count) * 8;                      dbl = BitConverter.Int64BitsToDouble(lvalue);                      type = edsTypeDouble;                      break;                    case edsTimeLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeTime;                      break;                    case edsTimeLen1:                  case edsTimeLen2:                  case edsTimeLen3:                  case edsTimeLen4:                      l = code - edsTimeLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeTime;                      break;                    case edsMilliSecLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeMilliseconds;                      break;                    case edsMilliSecLen1:                  case edsMilliSecLen2:                  case edsMilliSecLen3:                  case edsMilliSecLen4:                  case edsMilliSecLen5:                  case edsMilliSecLen6:                  case edsMilliSecLen7:                  case edsMilliSecLen8:                      l = code - edsMilliSecLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeMilliseconds;                      break;                    case edsNanoSecLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeNanoseconds;                      break;                    case edsNanoSecLen1:                  case edsNanoSecLen2:                  case edsNanoSecLen3:                  case edsNanoSecLen4:                  case edsNanoSecLen5:                  case edsNanoSecLen6:                  case edsNanoSecLen7:                  case edsNanoSecLen8:                      l = code - edsNanoSecLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeNanoseconds;                      break;                    //                  // 09/2012 Added support for new scaled date/times encoding. These replace the old encoding                  // edsTimeLen' edsMilliSecLen and edsNanoSecLen.                  //                    case edsScaledTimeLen1:                  case edsScaledTimeLen2:                  case edsScaledTimeLen3:                  case edsScaledTimeLen4:                  case edsScaledTimeLen5:                  case edsScaledTimeLen6:                  case edsScaledTimeLen7:                  case edsScaledTimeLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledTimeLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledTime;                      break;                    case edsScaledDateLen1:                  case edsScaledDateLen2:                  case edsScaledDateLen3:                  case edsScaledDateLen4:                  case edsScaledDateLen5:                  case edsScaledDateLen6:                  case edsScaledDateLen7:                  case edsScaledDateLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledDateLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledDate;                      break;                    case edsScaledTimestampLen1:                  case edsScaledTimestampLen2:                  case edsScaledTimestampLen3:                  case edsScaledTimestampLen4:                  case edsScaledTimestampLen5:                  case edsScaledTimestampLen6:                  case edsScaledTimestampLen7:                  case edsScaledTimestampLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledTimestampLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledTimestamp;                      break;                    case edsClobLen0:                      blobId = 0;                      type = edsTypeClob;                      break;                    case edsClobLen1:                  case edsClobLen2:                  case edsClobLen3:                  case edsClobLen4:                      l = code - edsClobLen1;                      blobId = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          blobId = (blobId << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeClob;                      break;                    case edsBlobLen0:                      blobId = 0;                      type = edsTypeBlob;                      break;                    case edsBlobLen1:                  case edsBlobLen2:                  case edsBlobLen3:                  case edsBlobLen4:                      l = code - edsBlobLen1;                      blobId = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          blobId = (blobId << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeBlob;                      break;                    case edsScaledCount1:                      {                          // For some reason C++ EncodedStream expects the encoded                          // length to be length+1.                            length = (source[offset++] & 0xff) - 1;                          scale = (sbyte)source[offset++];                          type = edsTypeBigInt;                          bytes = new byte[length];                          Array.Copy(source' offset' bytes' 0' length);                          offset += length;                          int sign = ((bytes[0] & 0x80) > 0) ? -1 : 1;                            if (sign == -1)                          {                              bytes[0] &= 0x7f;                          }                            BigInteger bi = new BigInteger(bytes);                          bigDecimal = Decimal.Parse(bi.ToString());                      }                      break;                    case edsScaledCount2:                      {                          // For some reason C++ EncodedStream expects the encoded                          // length to be length+1.                            scale = (sbyte)source[offset++];                          sbyte sign = (sbyte)source[offset++];                          length = (source[offset++] & 0xff); // in bytes                          type = edsTypeBigInt;                          bytes = new byte[length];                          Array.Copy(source' offset' bytes' 0' length);                          offset += length;                            if (sign == -1)                              bytes[0] &= 0x7f;                          else                              sign = 1;                            BigInteger bi = new BigInteger(bytes);                          if (sign == -1)                              bi = -bi;                          bigDecimal = ScaleDecimal(Decimal.Parse(bi.ToString())' scale);                      }                      break;                    case edsUUID:                      {                          byte[] buff = new byte[16];                            for (int n = 0; n < 16; ++n)                          {                              buff[n] = (byte)(source[offset++] & 0xff);                          }                            uuid = new Guid(buff);                          type = edsTypeUUID;                      }                      break;                    default:                      type = edsTypeUnknown;                      break;              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,decode,The following statement contains a magic number: switch (code)              {                  case edsNull:                      type = edsTypeNull;                      break;                    case edsTrue:                      type = edsTypeBoolean;                      @bool = true;                      break;                    case edsFalse:                      type = edsTypeBoolean;                      @bool = false;                      break;                    case edsIntMinus10:                  case edsIntMinus9:                  case edsIntMinus8:                  case edsIntMinus7:                  case edsIntMinus6:                  case edsIntMinus5:                  case edsIntMinus4:                  case edsIntMinus3:                  case edsIntMinus2:                  case edsIntMinus1:                  case edsInt0:                  case edsInt1:                  case edsInt2:                  case edsInt3:                  case edsInt4:                  case edsInt5:                  case edsInt6:                  case edsInt7:                  case edsInt8:                  case edsInt9:                  case edsInt10:                  case edsInt11:                  case edsInt12:                  case edsInt13:                  case edsInt14:                  case edsInt15:                  case edsInt16:                  case edsInt17:                  case edsInt18:                  case edsInt19:                  case edsInt20:                  case edsInt21:                  case edsInt22:                  case edsInt23:                  case edsInt24:                  case edsInt25:                  case edsInt26:                  case edsInt27:                  case edsInt28:                  case edsInt29:                  case edsInt30:                  case edsInt31:                      integer32 = code - edsInt0;                      scale = 0;                      type = edsTypeInt32;                      break;                    case edsIntLen1:                      type = edsTypeInt32;                      scale = 0;                      integer32 = (sbyte)source[offset++];                      break;                    case edsIntLen2:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset] << 8) | (source[offset + 1] & 0xff);                      offset += 2;                      break;                    case edsIntLen3:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset]) << 16 | (source[offset + 1] & 0xff) << 8 | (source[offset + 2] & 0xff);                      offset += 3;                      break;                    case edsIntLen4:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset]) << 24 | (source[offset + 1] & 0xff) << 16 | (source[offset + 2] & 0xff) << 8 | (source[offset + 3] & 0xff);                      offset += 4;                      break;                    case edsIntLen5:                  case edsIntLen6:                  case edsIntLen7:                  case edsIntLen8:                      l = code - edsIntLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeInt64;                      break;                    case edsScaledLen0:                      scale = (sbyte)source[offset++];                      integer64 = 0;                      type = edsTypeScaled;                      break;                    case edsScaledLen1:                  case edsScaledLen2:                  case edsScaledLen3:                  case edsScaledLen4:                  case edsScaledLen5:                  case edsScaledLen6:                  case edsScaledLen7:                  case edsScaledLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaled;                      break;                    case edsUtf8Len0:                  case edsUtf8Len1:                  case edsUtf8Len2:                  case edsUtf8Len3:                  case edsUtf8Len4:                  case edsUtf8Len5:                  case edsUtf8Len6:                  case edsUtf8Len7:                  case edsUtf8Len8:                  case edsUtf8Len9:                  case edsUtf8Len10:                  case edsUtf8Len11:                  case edsUtf8Len12:                  case edsUtf8Len13:                  case edsUtf8Len14:                  case edsUtf8Len15:                  case edsUtf8Len16:                  case edsUtf8Len17:                  case edsUtf8Len18:                  case edsUtf8Len19:                  case edsUtf8Len20:                  case edsUtf8Len21:                  case edsUtf8Len22:                  case edsUtf8Len23:                  case edsUtf8Len24:                  case edsUtf8Len25:                  case edsUtf8Len26:                  case edsUtf8Len27:                  case edsUtf8Len28:                  case edsUtf8Len29:                  case edsUtf8Len30:                  case edsUtf8Len31:                  case edsUtf8Len32:                  case edsUtf8Len33:                  case edsUtf8Len34:                  case edsUtf8Len35:                  case edsUtf8Len36:                  case edsUtf8Len37:                  case edsUtf8Len38:                  case edsUtf8Len39:                      l = code - edsUtf8Len0;                      @string = getString(source' offset' l);                      offset += l;                      type = edsTypeUtf8;                      break;                    case edsUtf8Count1:                  case edsUtf8Count2:                  case edsUtf8Count3:                  case edsUtf8Count4:                      count = code - edsUtf8Count1;                      int length = source[offset++] & 0xff;                        for (int n = 0; n < count; ++n)                      {                          length = length << 8 | (source[offset++] & 0xff);                      }                        @string = getString(source' offset' length);                      offset += length;                      type = edsTypeUtf8;                      break;                    case edsOpaqueLen0:                  case edsOpaqueLen1:                  case edsOpaqueLen2:                  case edsOpaqueLen3:                  case edsOpaqueLen4:                  case edsOpaqueLen5:                  case edsOpaqueLen6:                  case edsOpaqueLen7:                  case edsOpaqueLen8:                  case edsOpaqueLen9:                  case edsOpaqueLen10:                  case edsOpaqueLen11:                  case edsOpaqueLen12:                  case edsOpaqueLen13:                  case edsOpaqueLen14:                  case edsOpaqueLen15:                  case edsOpaqueLen16:                  case edsOpaqueLen17:                  case edsOpaqueLen18:                  case edsOpaqueLen19:                  case edsOpaqueLen20:                  case edsOpaqueLen21:                  case edsOpaqueLen22:                  case edsOpaqueLen23:                  case edsOpaqueLen24:                  case edsOpaqueLen25:                  case edsOpaqueLen26:                  case edsOpaqueLen27:                  case edsOpaqueLen28:                  case edsOpaqueLen29:                  case edsOpaqueLen30:                  case edsOpaqueLen31:                  case edsOpaqueLen32:                  case edsOpaqueLen33:                  case edsOpaqueLen34:                  case edsOpaqueLen35:                  case edsOpaqueLen36:                  case edsOpaqueLen37:                  case edsOpaqueLen38:                  case edsOpaqueLen39:                      l = code - edsOpaqueLen0;                      bytes = new byte[l];                      Array.Copy(source' offset' bytes' 0' l);                      offset += l;                      type = edsTypeOpaque;                      break;                    case edsOpaqueCount1:                  case edsOpaqueCount2:                  case edsOpaqueCount3:                  case edsOpaqueCount4:                      count = code - edsOpaqueCount1 + 1;                      l = source[offset++] & 0xff;                        for (int n = 1; n < count; ++n)                      {                          l = l << 8 | (source[offset++] & 0xff);                      }                        bytes = new byte[l];                      Array.Copy(source' offset' bytes' 0' l);                      offset += l;                      type = edsTypeOpaque;                      break;                    case edsDoubleLen0:                  case edsDoubleLen1:                  case edsDoubleLen2:                  case edsDoubleLen3:                  case edsDoubleLen4:                  case edsDoubleLen5:                  case edsDoubleLen6:                  case edsDoubleLen7:                  case edsDoubleLen8:                      count = code - edsDoubleLen0;                      long lvalue = 0;                        for (int n = 0; n < count; ++n)                      {                          lvalue = (lvalue << 8) | (source[offset++] & 0xff);                      }                        lvalue <<= (8 - count) * 8;                      dbl = BitConverter.Int64BitsToDouble(lvalue);                      type = edsTypeDouble;                      break;                    case edsTimeLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeTime;                      break;                    case edsTimeLen1:                  case edsTimeLen2:                  case edsTimeLen3:                  case edsTimeLen4:                      l = code - edsTimeLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeTime;                      break;                    case edsMilliSecLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeMilliseconds;                      break;                    case edsMilliSecLen1:                  case edsMilliSecLen2:                  case edsMilliSecLen3:                  case edsMilliSecLen4:                  case edsMilliSecLen5:                  case edsMilliSecLen6:                  case edsMilliSecLen7:                  case edsMilliSecLen8:                      l = code - edsMilliSecLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeMilliseconds;                      break;                    case edsNanoSecLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeNanoseconds;                      break;                    case edsNanoSecLen1:                  case edsNanoSecLen2:                  case edsNanoSecLen3:                  case edsNanoSecLen4:                  case edsNanoSecLen5:                  case edsNanoSecLen6:                  case edsNanoSecLen7:                  case edsNanoSecLen8:                      l = code - edsNanoSecLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeNanoseconds;                      break;                    //                  // 09/2012 Added support for new scaled date/times encoding. These replace the old encoding                  // edsTimeLen' edsMilliSecLen and edsNanoSecLen.                  //                    case edsScaledTimeLen1:                  case edsScaledTimeLen2:                  case edsScaledTimeLen3:                  case edsScaledTimeLen4:                  case edsScaledTimeLen5:                  case edsScaledTimeLen6:                  case edsScaledTimeLen7:                  case edsScaledTimeLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledTimeLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledTime;                      break;                    case edsScaledDateLen1:                  case edsScaledDateLen2:                  case edsScaledDateLen3:                  case edsScaledDateLen4:                  case edsScaledDateLen5:                  case edsScaledDateLen6:                  case edsScaledDateLen7:                  case edsScaledDateLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledDateLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledDate;                      break;                    case edsScaledTimestampLen1:                  case edsScaledTimestampLen2:                  case edsScaledTimestampLen3:                  case edsScaledTimestampLen4:                  case edsScaledTimestampLen5:                  case edsScaledTimestampLen6:                  case edsScaledTimestampLen7:                  case edsScaledTimestampLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledTimestampLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledTimestamp;                      break;                    case edsClobLen0:                      blobId = 0;                      type = edsTypeClob;                      break;                    case edsClobLen1:                  case edsClobLen2:                  case edsClobLen3:                  case edsClobLen4:                      l = code - edsClobLen1;                      blobId = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          blobId = (blobId << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeClob;                      break;                    case edsBlobLen0:                      blobId = 0;                      type = edsTypeBlob;                      break;                    case edsBlobLen1:                  case edsBlobLen2:                  case edsBlobLen3:                  case edsBlobLen4:                      l = code - edsBlobLen1;                      blobId = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          blobId = (blobId << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeBlob;                      break;                    case edsScaledCount1:                      {                          // For some reason C++ EncodedStream expects the encoded                          // length to be length+1.                            length = (source[offset++] & 0xff) - 1;                          scale = (sbyte)source[offset++];                          type = edsTypeBigInt;                          bytes = new byte[length];                          Array.Copy(source' offset' bytes' 0' length);                          offset += length;                          int sign = ((bytes[0] & 0x80) > 0) ? -1 : 1;                            if (sign == -1)                          {                              bytes[0] &= 0x7f;                          }                            BigInteger bi = new BigInteger(bytes);                          bigDecimal = Decimal.Parse(bi.ToString());                      }                      break;                    case edsScaledCount2:                      {                          // For some reason C++ EncodedStream expects the encoded                          // length to be length+1.                            scale = (sbyte)source[offset++];                          sbyte sign = (sbyte)source[offset++];                          length = (source[offset++] & 0xff); // in bytes                          type = edsTypeBigInt;                          bytes = new byte[length];                          Array.Copy(source' offset' bytes' 0' length);                          offset += length;                            if (sign == -1)                              bytes[0] &= 0x7f;                          else                              sign = 1;                            BigInteger bi = new BigInteger(bytes);                          if (sign == -1)                              bi = -bi;                          bigDecimal = ScaleDecimal(Decimal.Parse(bi.ToString())' scale);                      }                      break;                    case edsUUID:                      {                          byte[] buff = new byte[16];                            for (int n = 0; n < 16; ++n)                          {                              buff[n] = (byte)(source[offset++] & 0xff);                          }                            uuid = new Guid(buff);                          type = edsTypeUUID;                      }                      break;                    default:                      type = edsTypeUnknown;                      break;              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,decode,The following statement contains a magic number: switch (code)              {                  case edsNull:                      type = edsTypeNull;                      break;                    case edsTrue:                      type = edsTypeBoolean;                      @bool = true;                      break;                    case edsFalse:                      type = edsTypeBoolean;                      @bool = false;                      break;                    case edsIntMinus10:                  case edsIntMinus9:                  case edsIntMinus8:                  case edsIntMinus7:                  case edsIntMinus6:                  case edsIntMinus5:                  case edsIntMinus4:                  case edsIntMinus3:                  case edsIntMinus2:                  case edsIntMinus1:                  case edsInt0:                  case edsInt1:                  case edsInt2:                  case edsInt3:                  case edsInt4:                  case edsInt5:                  case edsInt6:                  case edsInt7:                  case edsInt8:                  case edsInt9:                  case edsInt10:                  case edsInt11:                  case edsInt12:                  case edsInt13:                  case edsInt14:                  case edsInt15:                  case edsInt16:                  case edsInt17:                  case edsInt18:                  case edsInt19:                  case edsInt20:                  case edsInt21:                  case edsInt22:                  case edsInt23:                  case edsInt24:                  case edsInt25:                  case edsInt26:                  case edsInt27:                  case edsInt28:                  case edsInt29:                  case edsInt30:                  case edsInt31:                      integer32 = code - edsInt0;                      scale = 0;                      type = edsTypeInt32;                      break;                    case edsIntLen1:                      type = edsTypeInt32;                      scale = 0;                      integer32 = (sbyte)source[offset++];                      break;                    case edsIntLen2:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset] << 8) | (source[offset + 1] & 0xff);                      offset += 2;                      break;                    case edsIntLen3:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset]) << 16 | (source[offset + 1] & 0xff) << 8 | (source[offset + 2] & 0xff);                      offset += 3;                      break;                    case edsIntLen4:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset]) << 24 | (source[offset + 1] & 0xff) << 16 | (source[offset + 2] & 0xff) << 8 | (source[offset + 3] & 0xff);                      offset += 4;                      break;                    case edsIntLen5:                  case edsIntLen6:                  case edsIntLen7:                  case edsIntLen8:                      l = code - edsIntLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeInt64;                      break;                    case edsScaledLen0:                      scale = (sbyte)source[offset++];                      integer64 = 0;                      type = edsTypeScaled;                      break;                    case edsScaledLen1:                  case edsScaledLen2:                  case edsScaledLen3:                  case edsScaledLen4:                  case edsScaledLen5:                  case edsScaledLen6:                  case edsScaledLen7:                  case edsScaledLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaled;                      break;                    case edsUtf8Len0:                  case edsUtf8Len1:                  case edsUtf8Len2:                  case edsUtf8Len3:                  case edsUtf8Len4:                  case edsUtf8Len5:                  case edsUtf8Len6:                  case edsUtf8Len7:                  case edsUtf8Len8:                  case edsUtf8Len9:                  case edsUtf8Len10:                  case edsUtf8Len11:                  case edsUtf8Len12:                  case edsUtf8Len13:                  case edsUtf8Len14:                  case edsUtf8Len15:                  case edsUtf8Len16:                  case edsUtf8Len17:                  case edsUtf8Len18:                  case edsUtf8Len19:                  case edsUtf8Len20:                  case edsUtf8Len21:                  case edsUtf8Len22:                  case edsUtf8Len23:                  case edsUtf8Len24:                  case edsUtf8Len25:                  case edsUtf8Len26:                  case edsUtf8Len27:                  case edsUtf8Len28:                  case edsUtf8Len29:                  case edsUtf8Len30:                  case edsUtf8Len31:                  case edsUtf8Len32:                  case edsUtf8Len33:                  case edsUtf8Len34:                  case edsUtf8Len35:                  case edsUtf8Len36:                  case edsUtf8Len37:                  case edsUtf8Len38:                  case edsUtf8Len39:                      l = code - edsUtf8Len0;                      @string = getString(source' offset' l);                      offset += l;                      type = edsTypeUtf8;                      break;                    case edsUtf8Count1:                  case edsUtf8Count2:                  case edsUtf8Count3:                  case edsUtf8Count4:                      count = code - edsUtf8Count1;                      int length = source[offset++] & 0xff;                        for (int n = 0; n < count; ++n)                      {                          length = length << 8 | (source[offset++] & 0xff);                      }                        @string = getString(source' offset' length);                      offset += length;                      type = edsTypeUtf8;                      break;                    case edsOpaqueLen0:                  case edsOpaqueLen1:                  case edsOpaqueLen2:                  case edsOpaqueLen3:                  case edsOpaqueLen4:                  case edsOpaqueLen5:                  case edsOpaqueLen6:                  case edsOpaqueLen7:                  case edsOpaqueLen8:                  case edsOpaqueLen9:                  case edsOpaqueLen10:                  case edsOpaqueLen11:                  case edsOpaqueLen12:                  case edsOpaqueLen13:                  case edsOpaqueLen14:                  case edsOpaqueLen15:                  case edsOpaqueLen16:                  case edsOpaqueLen17:                  case edsOpaqueLen18:                  case edsOpaqueLen19:                  case edsOpaqueLen20:                  case edsOpaqueLen21:                  case edsOpaqueLen22:                  case edsOpaqueLen23:                  case edsOpaqueLen24:                  case edsOpaqueLen25:                  case edsOpaqueLen26:                  case edsOpaqueLen27:                  case edsOpaqueLen28:                  case edsOpaqueLen29:                  case edsOpaqueLen30:                  case edsOpaqueLen31:                  case edsOpaqueLen32:                  case edsOpaqueLen33:                  case edsOpaqueLen34:                  case edsOpaqueLen35:                  case edsOpaqueLen36:                  case edsOpaqueLen37:                  case edsOpaqueLen38:                  case edsOpaqueLen39:                      l = code - edsOpaqueLen0;                      bytes = new byte[l];                      Array.Copy(source' offset' bytes' 0' l);                      offset += l;                      type = edsTypeOpaque;                      break;                    case edsOpaqueCount1:                  case edsOpaqueCount2:                  case edsOpaqueCount3:                  case edsOpaqueCount4:                      count = code - edsOpaqueCount1 + 1;                      l = source[offset++] & 0xff;                        for (int n = 1; n < count; ++n)                      {                          l = l << 8 | (source[offset++] & 0xff);                      }                        bytes = new byte[l];                      Array.Copy(source' offset' bytes' 0' l);                      offset += l;                      type = edsTypeOpaque;                      break;                    case edsDoubleLen0:                  case edsDoubleLen1:                  case edsDoubleLen2:                  case edsDoubleLen3:                  case edsDoubleLen4:                  case edsDoubleLen5:                  case edsDoubleLen6:                  case edsDoubleLen7:                  case edsDoubleLen8:                      count = code - edsDoubleLen0;                      long lvalue = 0;                        for (int n = 0; n < count; ++n)                      {                          lvalue = (lvalue << 8) | (source[offset++] & 0xff);                      }                        lvalue <<= (8 - count) * 8;                      dbl = BitConverter.Int64BitsToDouble(lvalue);                      type = edsTypeDouble;                      break;                    case edsTimeLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeTime;                      break;                    case edsTimeLen1:                  case edsTimeLen2:                  case edsTimeLen3:                  case edsTimeLen4:                      l = code - edsTimeLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeTime;                      break;                    case edsMilliSecLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeMilliseconds;                      break;                    case edsMilliSecLen1:                  case edsMilliSecLen2:                  case edsMilliSecLen3:                  case edsMilliSecLen4:                  case edsMilliSecLen5:                  case edsMilliSecLen6:                  case edsMilliSecLen7:                  case edsMilliSecLen8:                      l = code - edsMilliSecLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeMilliseconds;                      break;                    case edsNanoSecLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeNanoseconds;                      break;                    case edsNanoSecLen1:                  case edsNanoSecLen2:                  case edsNanoSecLen3:                  case edsNanoSecLen4:                  case edsNanoSecLen5:                  case edsNanoSecLen6:                  case edsNanoSecLen7:                  case edsNanoSecLen8:                      l = code - edsNanoSecLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeNanoseconds;                      break;                    //                  // 09/2012 Added support for new scaled date/times encoding. These replace the old encoding                  // edsTimeLen' edsMilliSecLen and edsNanoSecLen.                  //                    case edsScaledTimeLen1:                  case edsScaledTimeLen2:                  case edsScaledTimeLen3:                  case edsScaledTimeLen4:                  case edsScaledTimeLen5:                  case edsScaledTimeLen6:                  case edsScaledTimeLen7:                  case edsScaledTimeLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledTimeLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledTime;                      break;                    case edsScaledDateLen1:                  case edsScaledDateLen2:                  case edsScaledDateLen3:                  case edsScaledDateLen4:                  case edsScaledDateLen5:                  case edsScaledDateLen6:                  case edsScaledDateLen7:                  case edsScaledDateLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledDateLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledDate;                      break;                    case edsScaledTimestampLen1:                  case edsScaledTimestampLen2:                  case edsScaledTimestampLen3:                  case edsScaledTimestampLen4:                  case edsScaledTimestampLen5:                  case edsScaledTimestampLen6:                  case edsScaledTimestampLen7:                  case edsScaledTimestampLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledTimestampLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledTimestamp;                      break;                    case edsClobLen0:                      blobId = 0;                      type = edsTypeClob;                      break;                    case edsClobLen1:                  case edsClobLen2:                  case edsClobLen3:                  case edsClobLen4:                      l = code - edsClobLen1;                      blobId = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          blobId = (blobId << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeClob;                      break;                    case edsBlobLen0:                      blobId = 0;                      type = edsTypeBlob;                      break;                    case edsBlobLen1:                  case edsBlobLen2:                  case edsBlobLen3:                  case edsBlobLen4:                      l = code - edsBlobLen1;                      blobId = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          blobId = (blobId << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeBlob;                      break;                    case edsScaledCount1:                      {                          // For some reason C++ EncodedStream expects the encoded                          // length to be length+1.                            length = (source[offset++] & 0xff) - 1;                          scale = (sbyte)source[offset++];                          type = edsTypeBigInt;                          bytes = new byte[length];                          Array.Copy(source' offset' bytes' 0' length);                          offset += length;                          int sign = ((bytes[0] & 0x80) > 0) ? -1 : 1;                            if (sign == -1)                          {                              bytes[0] &= 0x7f;                          }                            BigInteger bi = new BigInteger(bytes);                          bigDecimal = Decimal.Parse(bi.ToString());                      }                      break;                    case edsScaledCount2:                      {                          // For some reason C++ EncodedStream expects the encoded                          // length to be length+1.                            scale = (sbyte)source[offset++];                          sbyte sign = (sbyte)source[offset++];                          length = (source[offset++] & 0xff); // in bytes                          type = edsTypeBigInt;                          bytes = new byte[length];                          Array.Copy(source' offset' bytes' 0' length);                          offset += length;                            if (sign == -1)                              bytes[0] &= 0x7f;                          else                              sign = 1;                            BigInteger bi = new BigInteger(bytes);                          if (sign == -1)                              bi = -bi;                          bigDecimal = ScaleDecimal(Decimal.Parse(bi.ToString())' scale);                      }                      break;                    case edsUUID:                      {                          byte[] buff = new byte[16];                            for (int n = 0; n < 16; ++n)                          {                              buff[n] = (byte)(source[offset++] & 0xff);                          }                            uuid = new Guid(buff);                          type = edsTypeUUID;                      }                      break;                    default:                      type = edsTypeUnknown;                      break;              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,decode,The following statement contains a magic number: switch (code)              {                  case edsNull:                      type = edsTypeNull;                      break;                    case edsTrue:                      type = edsTypeBoolean;                      @bool = true;                      break;                    case edsFalse:                      type = edsTypeBoolean;                      @bool = false;                      break;                    case edsIntMinus10:                  case edsIntMinus9:                  case edsIntMinus8:                  case edsIntMinus7:                  case edsIntMinus6:                  case edsIntMinus5:                  case edsIntMinus4:                  case edsIntMinus3:                  case edsIntMinus2:                  case edsIntMinus1:                  case edsInt0:                  case edsInt1:                  case edsInt2:                  case edsInt3:                  case edsInt4:                  case edsInt5:                  case edsInt6:                  case edsInt7:                  case edsInt8:                  case edsInt9:                  case edsInt10:                  case edsInt11:                  case edsInt12:                  case edsInt13:                  case edsInt14:                  case edsInt15:                  case edsInt16:                  case edsInt17:                  case edsInt18:                  case edsInt19:                  case edsInt20:                  case edsInt21:                  case edsInt22:                  case edsInt23:                  case edsInt24:                  case edsInt25:                  case edsInt26:                  case edsInt27:                  case edsInt28:                  case edsInt29:                  case edsInt30:                  case edsInt31:                      integer32 = code - edsInt0;                      scale = 0;                      type = edsTypeInt32;                      break;                    case edsIntLen1:                      type = edsTypeInt32;                      scale = 0;                      integer32 = (sbyte)source[offset++];                      break;                    case edsIntLen2:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset] << 8) | (source[offset + 1] & 0xff);                      offset += 2;                      break;                    case edsIntLen3:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset]) << 16 | (source[offset + 1] & 0xff) << 8 | (source[offset + 2] & 0xff);                      offset += 3;                      break;                    case edsIntLen4:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset]) << 24 | (source[offset + 1] & 0xff) << 16 | (source[offset + 2] & 0xff) << 8 | (source[offset + 3] & 0xff);                      offset += 4;                      break;                    case edsIntLen5:                  case edsIntLen6:                  case edsIntLen7:                  case edsIntLen8:                      l = code - edsIntLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeInt64;                      break;                    case edsScaledLen0:                      scale = (sbyte)source[offset++];                      integer64 = 0;                      type = edsTypeScaled;                      break;                    case edsScaledLen1:                  case edsScaledLen2:                  case edsScaledLen3:                  case edsScaledLen4:                  case edsScaledLen5:                  case edsScaledLen6:                  case edsScaledLen7:                  case edsScaledLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaled;                      break;                    case edsUtf8Len0:                  case edsUtf8Len1:                  case edsUtf8Len2:                  case edsUtf8Len3:                  case edsUtf8Len4:                  case edsUtf8Len5:                  case edsUtf8Len6:                  case edsUtf8Len7:                  case edsUtf8Len8:                  case edsUtf8Len9:                  case edsUtf8Len10:                  case edsUtf8Len11:                  case edsUtf8Len12:                  case edsUtf8Len13:                  case edsUtf8Len14:                  case edsUtf8Len15:                  case edsUtf8Len16:                  case edsUtf8Len17:                  case edsUtf8Len18:                  case edsUtf8Len19:                  case edsUtf8Len20:                  case edsUtf8Len21:                  case edsUtf8Len22:                  case edsUtf8Len23:                  case edsUtf8Len24:                  case edsUtf8Len25:                  case edsUtf8Len26:                  case edsUtf8Len27:                  case edsUtf8Len28:                  case edsUtf8Len29:                  case edsUtf8Len30:                  case edsUtf8Len31:                  case edsUtf8Len32:                  case edsUtf8Len33:                  case edsUtf8Len34:                  case edsUtf8Len35:                  case edsUtf8Len36:                  case edsUtf8Len37:                  case edsUtf8Len38:                  case edsUtf8Len39:                      l = code - edsUtf8Len0;                      @string = getString(source' offset' l);                      offset += l;                      type = edsTypeUtf8;                      break;                    case edsUtf8Count1:                  case edsUtf8Count2:                  case edsUtf8Count3:                  case edsUtf8Count4:                      count = code - edsUtf8Count1;                      int length = source[offset++] & 0xff;                        for (int n = 0; n < count; ++n)                      {                          length = length << 8 | (source[offset++] & 0xff);                      }                        @string = getString(source' offset' length);                      offset += length;                      type = edsTypeUtf8;                      break;                    case edsOpaqueLen0:                  case edsOpaqueLen1:                  case edsOpaqueLen2:                  case edsOpaqueLen3:                  case edsOpaqueLen4:                  case edsOpaqueLen5:                  case edsOpaqueLen6:                  case edsOpaqueLen7:                  case edsOpaqueLen8:                  case edsOpaqueLen9:                  case edsOpaqueLen10:                  case edsOpaqueLen11:                  case edsOpaqueLen12:                  case edsOpaqueLen13:                  case edsOpaqueLen14:                  case edsOpaqueLen15:                  case edsOpaqueLen16:                  case edsOpaqueLen17:                  case edsOpaqueLen18:                  case edsOpaqueLen19:                  case edsOpaqueLen20:                  case edsOpaqueLen21:                  case edsOpaqueLen22:                  case edsOpaqueLen23:                  case edsOpaqueLen24:                  case edsOpaqueLen25:                  case edsOpaqueLen26:                  case edsOpaqueLen27:                  case edsOpaqueLen28:                  case edsOpaqueLen29:                  case edsOpaqueLen30:                  case edsOpaqueLen31:                  case edsOpaqueLen32:                  case edsOpaqueLen33:                  case edsOpaqueLen34:                  case edsOpaqueLen35:                  case edsOpaqueLen36:                  case edsOpaqueLen37:                  case edsOpaqueLen38:                  case edsOpaqueLen39:                      l = code - edsOpaqueLen0;                      bytes = new byte[l];                      Array.Copy(source' offset' bytes' 0' l);                      offset += l;                      type = edsTypeOpaque;                      break;                    case edsOpaqueCount1:                  case edsOpaqueCount2:                  case edsOpaqueCount3:                  case edsOpaqueCount4:                      count = code - edsOpaqueCount1 + 1;                      l = source[offset++] & 0xff;                        for (int n = 1; n < count; ++n)                      {                          l = l << 8 | (source[offset++] & 0xff);                      }                        bytes = new byte[l];                      Array.Copy(source' offset' bytes' 0' l);                      offset += l;                      type = edsTypeOpaque;                      break;                    case edsDoubleLen0:                  case edsDoubleLen1:                  case edsDoubleLen2:                  case edsDoubleLen3:                  case edsDoubleLen4:                  case edsDoubleLen5:                  case edsDoubleLen6:                  case edsDoubleLen7:                  case edsDoubleLen8:                      count = code - edsDoubleLen0;                      long lvalue = 0;                        for (int n = 0; n < count; ++n)                      {                          lvalue = (lvalue << 8) | (source[offset++] & 0xff);                      }                        lvalue <<= (8 - count) * 8;                      dbl = BitConverter.Int64BitsToDouble(lvalue);                      type = edsTypeDouble;                      break;                    case edsTimeLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeTime;                      break;                    case edsTimeLen1:                  case edsTimeLen2:                  case edsTimeLen3:                  case edsTimeLen4:                      l = code - edsTimeLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeTime;                      break;                    case edsMilliSecLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeMilliseconds;                      break;                    case edsMilliSecLen1:                  case edsMilliSecLen2:                  case edsMilliSecLen3:                  case edsMilliSecLen4:                  case edsMilliSecLen5:                  case edsMilliSecLen6:                  case edsMilliSecLen7:                  case edsMilliSecLen8:                      l = code - edsMilliSecLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeMilliseconds;                      break;                    case edsNanoSecLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeNanoseconds;                      break;                    case edsNanoSecLen1:                  case edsNanoSecLen2:                  case edsNanoSecLen3:                  case edsNanoSecLen4:                  case edsNanoSecLen5:                  case edsNanoSecLen6:                  case edsNanoSecLen7:                  case edsNanoSecLen8:                      l = code - edsNanoSecLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeNanoseconds;                      break;                    //                  // 09/2012 Added support for new scaled date/times encoding. These replace the old encoding                  // edsTimeLen' edsMilliSecLen and edsNanoSecLen.                  //                    case edsScaledTimeLen1:                  case edsScaledTimeLen2:                  case edsScaledTimeLen3:                  case edsScaledTimeLen4:                  case edsScaledTimeLen5:                  case edsScaledTimeLen6:                  case edsScaledTimeLen7:                  case edsScaledTimeLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledTimeLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledTime;                      break;                    case edsScaledDateLen1:                  case edsScaledDateLen2:                  case edsScaledDateLen3:                  case edsScaledDateLen4:                  case edsScaledDateLen5:                  case edsScaledDateLen6:                  case edsScaledDateLen7:                  case edsScaledDateLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledDateLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledDate;                      break;                    case edsScaledTimestampLen1:                  case edsScaledTimestampLen2:                  case edsScaledTimestampLen3:                  case edsScaledTimestampLen4:                  case edsScaledTimestampLen5:                  case edsScaledTimestampLen6:                  case edsScaledTimestampLen7:                  case edsScaledTimestampLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledTimestampLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledTimestamp;                      break;                    case edsClobLen0:                      blobId = 0;                      type = edsTypeClob;                      break;                    case edsClobLen1:                  case edsClobLen2:                  case edsClobLen3:                  case edsClobLen4:                      l = code - edsClobLen1;                      blobId = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          blobId = (blobId << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeClob;                      break;                    case edsBlobLen0:                      blobId = 0;                      type = edsTypeBlob;                      break;                    case edsBlobLen1:                  case edsBlobLen2:                  case edsBlobLen3:                  case edsBlobLen4:                      l = code - edsBlobLen1;                      blobId = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          blobId = (blobId << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeBlob;                      break;                    case edsScaledCount1:                      {                          // For some reason C++ EncodedStream expects the encoded                          // length to be length+1.                            length = (source[offset++] & 0xff) - 1;                          scale = (sbyte)source[offset++];                          type = edsTypeBigInt;                          bytes = new byte[length];                          Array.Copy(source' offset' bytes' 0' length);                          offset += length;                          int sign = ((bytes[0] & 0x80) > 0) ? -1 : 1;                            if (sign == -1)                          {                              bytes[0] &= 0x7f;                          }                            BigInteger bi = new BigInteger(bytes);                          bigDecimal = Decimal.Parse(bi.ToString());                      }                      break;                    case edsScaledCount2:                      {                          // For some reason C++ EncodedStream expects the encoded                          // length to be length+1.                            scale = (sbyte)source[offset++];                          sbyte sign = (sbyte)source[offset++];                          length = (source[offset++] & 0xff); // in bytes                          type = edsTypeBigInt;                          bytes = new byte[length];                          Array.Copy(source' offset' bytes' 0' length);                          offset += length;                            if (sign == -1)                              bytes[0] &= 0x7f;                          else                              sign = 1;                            BigInteger bi = new BigInteger(bytes);                          if (sign == -1)                              bi = -bi;                          bigDecimal = ScaleDecimal(Decimal.Parse(bi.ToString())' scale);                      }                      break;                    case edsUUID:                      {                          byte[] buff = new byte[16];                            for (int n = 0; n < 16; ++n)                          {                              buff[n] = (byte)(source[offset++] & 0xff);                          }                            uuid = new Guid(buff);                          type = edsTypeUUID;                      }                      break;                    default:                      type = edsTypeUnknown;                      break;              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,decode,The following statement contains a magic number: switch (code)              {                  case edsNull:                      type = edsTypeNull;                      break;                    case edsTrue:                      type = edsTypeBoolean;                      @bool = true;                      break;                    case edsFalse:                      type = edsTypeBoolean;                      @bool = false;                      break;                    case edsIntMinus10:                  case edsIntMinus9:                  case edsIntMinus8:                  case edsIntMinus7:                  case edsIntMinus6:                  case edsIntMinus5:                  case edsIntMinus4:                  case edsIntMinus3:                  case edsIntMinus2:                  case edsIntMinus1:                  case edsInt0:                  case edsInt1:                  case edsInt2:                  case edsInt3:                  case edsInt4:                  case edsInt5:                  case edsInt6:                  case edsInt7:                  case edsInt8:                  case edsInt9:                  case edsInt10:                  case edsInt11:                  case edsInt12:                  case edsInt13:                  case edsInt14:                  case edsInt15:                  case edsInt16:                  case edsInt17:                  case edsInt18:                  case edsInt19:                  case edsInt20:                  case edsInt21:                  case edsInt22:                  case edsInt23:                  case edsInt24:                  case edsInt25:                  case edsInt26:                  case edsInt27:                  case edsInt28:                  case edsInt29:                  case edsInt30:                  case edsInt31:                      integer32 = code - edsInt0;                      scale = 0;                      type = edsTypeInt32;                      break;                    case edsIntLen1:                      type = edsTypeInt32;                      scale = 0;                      integer32 = (sbyte)source[offset++];                      break;                    case edsIntLen2:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset] << 8) | (source[offset + 1] & 0xff);                      offset += 2;                      break;                    case edsIntLen3:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset]) << 16 | (source[offset + 1] & 0xff) << 8 | (source[offset + 2] & 0xff);                      offset += 3;                      break;                    case edsIntLen4:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset]) << 24 | (source[offset + 1] & 0xff) << 16 | (source[offset + 2] & 0xff) << 8 | (source[offset + 3] & 0xff);                      offset += 4;                      break;                    case edsIntLen5:                  case edsIntLen6:                  case edsIntLen7:                  case edsIntLen8:                      l = code - edsIntLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeInt64;                      break;                    case edsScaledLen0:                      scale = (sbyte)source[offset++];                      integer64 = 0;                      type = edsTypeScaled;                      break;                    case edsScaledLen1:                  case edsScaledLen2:                  case edsScaledLen3:                  case edsScaledLen4:                  case edsScaledLen5:                  case edsScaledLen6:                  case edsScaledLen7:                  case edsScaledLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaled;                      break;                    case edsUtf8Len0:                  case edsUtf8Len1:                  case edsUtf8Len2:                  case edsUtf8Len3:                  case edsUtf8Len4:                  case edsUtf8Len5:                  case edsUtf8Len6:                  case edsUtf8Len7:                  case edsUtf8Len8:                  case edsUtf8Len9:                  case edsUtf8Len10:                  case edsUtf8Len11:                  case edsUtf8Len12:                  case edsUtf8Len13:                  case edsUtf8Len14:                  case edsUtf8Len15:                  case edsUtf8Len16:                  case edsUtf8Len17:                  case edsUtf8Len18:                  case edsUtf8Len19:                  case edsUtf8Len20:                  case edsUtf8Len21:                  case edsUtf8Len22:                  case edsUtf8Len23:                  case edsUtf8Len24:                  case edsUtf8Len25:                  case edsUtf8Len26:                  case edsUtf8Len27:                  case edsUtf8Len28:                  case edsUtf8Len29:                  case edsUtf8Len30:                  case edsUtf8Len31:                  case edsUtf8Len32:                  case edsUtf8Len33:                  case edsUtf8Len34:                  case edsUtf8Len35:                  case edsUtf8Len36:                  case edsUtf8Len37:                  case edsUtf8Len38:                  case edsUtf8Len39:                      l = code - edsUtf8Len0;                      @string = getString(source' offset' l);                      offset += l;                      type = edsTypeUtf8;                      break;                    case edsUtf8Count1:                  case edsUtf8Count2:                  case edsUtf8Count3:                  case edsUtf8Count4:                      count = code - edsUtf8Count1;                      int length = source[offset++] & 0xff;                        for (int n = 0; n < count; ++n)                      {                          length = length << 8 | (source[offset++] & 0xff);                      }                        @string = getString(source' offset' length);                      offset += length;                      type = edsTypeUtf8;                      break;                    case edsOpaqueLen0:                  case edsOpaqueLen1:                  case edsOpaqueLen2:                  case edsOpaqueLen3:                  case edsOpaqueLen4:                  case edsOpaqueLen5:                  case edsOpaqueLen6:                  case edsOpaqueLen7:                  case edsOpaqueLen8:                  case edsOpaqueLen9:                  case edsOpaqueLen10:                  case edsOpaqueLen11:                  case edsOpaqueLen12:                  case edsOpaqueLen13:                  case edsOpaqueLen14:                  case edsOpaqueLen15:                  case edsOpaqueLen16:                  case edsOpaqueLen17:                  case edsOpaqueLen18:                  case edsOpaqueLen19:                  case edsOpaqueLen20:                  case edsOpaqueLen21:                  case edsOpaqueLen22:                  case edsOpaqueLen23:                  case edsOpaqueLen24:                  case edsOpaqueLen25:                  case edsOpaqueLen26:                  case edsOpaqueLen27:                  case edsOpaqueLen28:                  case edsOpaqueLen29:                  case edsOpaqueLen30:                  case edsOpaqueLen31:                  case edsOpaqueLen32:                  case edsOpaqueLen33:                  case edsOpaqueLen34:                  case edsOpaqueLen35:                  case edsOpaqueLen36:                  case edsOpaqueLen37:                  case edsOpaqueLen38:                  case edsOpaqueLen39:                      l = code - edsOpaqueLen0;                      bytes = new byte[l];                      Array.Copy(source' offset' bytes' 0' l);                      offset += l;                      type = edsTypeOpaque;                      break;                    case edsOpaqueCount1:                  case edsOpaqueCount2:                  case edsOpaqueCount3:                  case edsOpaqueCount4:                      count = code - edsOpaqueCount1 + 1;                      l = source[offset++] & 0xff;                        for (int n = 1; n < count; ++n)                      {                          l = l << 8 | (source[offset++] & 0xff);                      }                        bytes = new byte[l];                      Array.Copy(source' offset' bytes' 0' l);                      offset += l;                      type = edsTypeOpaque;                      break;                    case edsDoubleLen0:                  case edsDoubleLen1:                  case edsDoubleLen2:                  case edsDoubleLen3:                  case edsDoubleLen4:                  case edsDoubleLen5:                  case edsDoubleLen6:                  case edsDoubleLen7:                  case edsDoubleLen8:                      count = code - edsDoubleLen0;                      long lvalue = 0;                        for (int n = 0; n < count; ++n)                      {                          lvalue = (lvalue << 8) | (source[offset++] & 0xff);                      }                        lvalue <<= (8 - count) * 8;                      dbl = BitConverter.Int64BitsToDouble(lvalue);                      type = edsTypeDouble;                      break;                    case edsTimeLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeTime;                      break;                    case edsTimeLen1:                  case edsTimeLen2:                  case edsTimeLen3:                  case edsTimeLen4:                      l = code - edsTimeLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeTime;                      break;                    case edsMilliSecLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeMilliseconds;                      break;                    case edsMilliSecLen1:                  case edsMilliSecLen2:                  case edsMilliSecLen3:                  case edsMilliSecLen4:                  case edsMilliSecLen5:                  case edsMilliSecLen6:                  case edsMilliSecLen7:                  case edsMilliSecLen8:                      l = code - edsMilliSecLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeMilliseconds;                      break;                    case edsNanoSecLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeNanoseconds;                      break;                    case edsNanoSecLen1:                  case edsNanoSecLen2:                  case edsNanoSecLen3:                  case edsNanoSecLen4:                  case edsNanoSecLen5:                  case edsNanoSecLen6:                  case edsNanoSecLen7:                  case edsNanoSecLen8:                      l = code - edsNanoSecLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeNanoseconds;                      break;                    //                  // 09/2012 Added support for new scaled date/times encoding. These replace the old encoding                  // edsTimeLen' edsMilliSecLen and edsNanoSecLen.                  //                    case edsScaledTimeLen1:                  case edsScaledTimeLen2:                  case edsScaledTimeLen3:                  case edsScaledTimeLen4:                  case edsScaledTimeLen5:                  case edsScaledTimeLen6:                  case edsScaledTimeLen7:                  case edsScaledTimeLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledTimeLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledTime;                      break;                    case edsScaledDateLen1:                  case edsScaledDateLen2:                  case edsScaledDateLen3:                  case edsScaledDateLen4:                  case edsScaledDateLen5:                  case edsScaledDateLen6:                  case edsScaledDateLen7:                  case edsScaledDateLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledDateLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledDate;                      break;                    case edsScaledTimestampLen1:                  case edsScaledTimestampLen2:                  case edsScaledTimestampLen3:                  case edsScaledTimestampLen4:                  case edsScaledTimestampLen5:                  case edsScaledTimestampLen6:                  case edsScaledTimestampLen7:                  case edsScaledTimestampLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledTimestampLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledTimestamp;                      break;                    case edsClobLen0:                      blobId = 0;                      type = edsTypeClob;                      break;                    case edsClobLen1:                  case edsClobLen2:                  case edsClobLen3:                  case edsClobLen4:                      l = code - edsClobLen1;                      blobId = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          blobId = (blobId << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeClob;                      break;                    case edsBlobLen0:                      blobId = 0;                      type = edsTypeBlob;                      break;                    case edsBlobLen1:                  case edsBlobLen2:                  case edsBlobLen3:                  case edsBlobLen4:                      l = code - edsBlobLen1;                      blobId = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          blobId = (blobId << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeBlob;                      break;                    case edsScaledCount1:                      {                          // For some reason C++ EncodedStream expects the encoded                          // length to be length+1.                            length = (source[offset++] & 0xff) - 1;                          scale = (sbyte)source[offset++];                          type = edsTypeBigInt;                          bytes = new byte[length];                          Array.Copy(source' offset' bytes' 0' length);                          offset += length;                          int sign = ((bytes[0] & 0x80) > 0) ? -1 : 1;                            if (sign == -1)                          {                              bytes[0] &= 0x7f;                          }                            BigInteger bi = new BigInteger(bytes);                          bigDecimal = Decimal.Parse(bi.ToString());                      }                      break;                    case edsScaledCount2:                      {                          // For some reason C++ EncodedStream expects the encoded                          // length to be length+1.                            scale = (sbyte)source[offset++];                          sbyte sign = (sbyte)source[offset++];                          length = (source[offset++] & 0xff); // in bytes                          type = edsTypeBigInt;                          bytes = new byte[length];                          Array.Copy(source' offset' bytes' 0' length);                          offset += length;                            if (sign == -1)                              bytes[0] &= 0x7f;                          else                              sign = 1;                            BigInteger bi = new BigInteger(bytes);                          if (sign == -1)                              bi = -bi;                          bigDecimal = ScaleDecimal(Decimal.Parse(bi.ToString())' scale);                      }                      break;                    case edsUUID:                      {                          byte[] buff = new byte[16];                            for (int n = 0; n < 16; ++n)                          {                              buff[n] = (byte)(source[offset++] & 0xff);                          }                            uuid = new Guid(buff);                          type = edsTypeUUID;                      }                      break;                    default:                      type = edsTypeUnknown;                      break;              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,decode,The following statement contains a magic number: switch (code)              {                  case edsNull:                      type = edsTypeNull;                      break;                    case edsTrue:                      type = edsTypeBoolean;                      @bool = true;                      break;                    case edsFalse:                      type = edsTypeBoolean;                      @bool = false;                      break;                    case edsIntMinus10:                  case edsIntMinus9:                  case edsIntMinus8:                  case edsIntMinus7:                  case edsIntMinus6:                  case edsIntMinus5:                  case edsIntMinus4:                  case edsIntMinus3:                  case edsIntMinus2:                  case edsIntMinus1:                  case edsInt0:                  case edsInt1:                  case edsInt2:                  case edsInt3:                  case edsInt4:                  case edsInt5:                  case edsInt6:                  case edsInt7:                  case edsInt8:                  case edsInt9:                  case edsInt10:                  case edsInt11:                  case edsInt12:                  case edsInt13:                  case edsInt14:                  case edsInt15:                  case edsInt16:                  case edsInt17:                  case edsInt18:                  case edsInt19:                  case edsInt20:                  case edsInt21:                  case edsInt22:                  case edsInt23:                  case edsInt24:                  case edsInt25:                  case edsInt26:                  case edsInt27:                  case edsInt28:                  case edsInt29:                  case edsInt30:                  case edsInt31:                      integer32 = code - edsInt0;                      scale = 0;                      type = edsTypeInt32;                      break;                    case edsIntLen1:                      type = edsTypeInt32;                      scale = 0;                      integer32 = (sbyte)source[offset++];                      break;                    case edsIntLen2:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset] << 8) | (source[offset + 1] & 0xff);                      offset += 2;                      break;                    case edsIntLen3:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset]) << 16 | (source[offset + 1] & 0xff) << 8 | (source[offset + 2] & 0xff);                      offset += 3;                      break;                    case edsIntLen4:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset]) << 24 | (source[offset + 1] & 0xff) << 16 | (source[offset + 2] & 0xff) << 8 | (source[offset + 3] & 0xff);                      offset += 4;                      break;                    case edsIntLen5:                  case edsIntLen6:                  case edsIntLen7:                  case edsIntLen8:                      l = code - edsIntLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeInt64;                      break;                    case edsScaledLen0:                      scale = (sbyte)source[offset++];                      integer64 = 0;                      type = edsTypeScaled;                      break;                    case edsScaledLen1:                  case edsScaledLen2:                  case edsScaledLen3:                  case edsScaledLen4:                  case edsScaledLen5:                  case edsScaledLen6:                  case edsScaledLen7:                  case edsScaledLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaled;                      break;                    case edsUtf8Len0:                  case edsUtf8Len1:                  case edsUtf8Len2:                  case edsUtf8Len3:                  case edsUtf8Len4:                  case edsUtf8Len5:                  case edsUtf8Len6:                  case edsUtf8Len7:                  case edsUtf8Len8:                  case edsUtf8Len9:                  case edsUtf8Len10:                  case edsUtf8Len11:                  case edsUtf8Len12:                  case edsUtf8Len13:                  case edsUtf8Len14:                  case edsUtf8Len15:                  case edsUtf8Len16:                  case edsUtf8Len17:                  case edsUtf8Len18:                  case edsUtf8Len19:                  case edsUtf8Len20:                  case edsUtf8Len21:                  case edsUtf8Len22:                  case edsUtf8Len23:                  case edsUtf8Len24:                  case edsUtf8Len25:                  case edsUtf8Len26:                  case edsUtf8Len27:                  case edsUtf8Len28:                  case edsUtf8Len29:                  case edsUtf8Len30:                  case edsUtf8Len31:                  case edsUtf8Len32:                  case edsUtf8Len33:                  case edsUtf8Len34:                  case edsUtf8Len35:                  case edsUtf8Len36:                  case edsUtf8Len37:                  case edsUtf8Len38:                  case edsUtf8Len39:                      l = code - edsUtf8Len0;                      @string = getString(source' offset' l);                      offset += l;                      type = edsTypeUtf8;                      break;                    case edsUtf8Count1:                  case edsUtf8Count2:                  case edsUtf8Count3:                  case edsUtf8Count4:                      count = code - edsUtf8Count1;                      int length = source[offset++] & 0xff;                        for (int n = 0; n < count; ++n)                      {                          length = length << 8 | (source[offset++] & 0xff);                      }                        @string = getString(source' offset' length);                      offset += length;                      type = edsTypeUtf8;                      break;                    case edsOpaqueLen0:                  case edsOpaqueLen1:                  case edsOpaqueLen2:                  case edsOpaqueLen3:                  case edsOpaqueLen4:                  case edsOpaqueLen5:                  case edsOpaqueLen6:                  case edsOpaqueLen7:                  case edsOpaqueLen8:                  case edsOpaqueLen9:                  case edsOpaqueLen10:                  case edsOpaqueLen11:                  case edsOpaqueLen12:                  case edsOpaqueLen13:                  case edsOpaqueLen14:                  case edsOpaqueLen15:                  case edsOpaqueLen16:                  case edsOpaqueLen17:                  case edsOpaqueLen18:                  case edsOpaqueLen19:                  case edsOpaqueLen20:                  case edsOpaqueLen21:                  case edsOpaqueLen22:                  case edsOpaqueLen23:                  case edsOpaqueLen24:                  case edsOpaqueLen25:                  case edsOpaqueLen26:                  case edsOpaqueLen27:                  case edsOpaqueLen28:                  case edsOpaqueLen29:                  case edsOpaqueLen30:                  case edsOpaqueLen31:                  case edsOpaqueLen32:                  case edsOpaqueLen33:                  case edsOpaqueLen34:                  case edsOpaqueLen35:                  case edsOpaqueLen36:                  case edsOpaqueLen37:                  case edsOpaqueLen38:                  case edsOpaqueLen39:                      l = code - edsOpaqueLen0;                      bytes = new byte[l];                      Array.Copy(source' offset' bytes' 0' l);                      offset += l;                      type = edsTypeOpaque;                      break;                    case edsOpaqueCount1:                  case edsOpaqueCount2:                  case edsOpaqueCount3:                  case edsOpaqueCount4:                      count = code - edsOpaqueCount1 + 1;                      l = source[offset++] & 0xff;                        for (int n = 1; n < count; ++n)                      {                          l = l << 8 | (source[offset++] & 0xff);                      }                        bytes = new byte[l];                      Array.Copy(source' offset' bytes' 0' l);                      offset += l;                      type = edsTypeOpaque;                      break;                    case edsDoubleLen0:                  case edsDoubleLen1:                  case edsDoubleLen2:                  case edsDoubleLen3:                  case edsDoubleLen4:                  case edsDoubleLen5:                  case edsDoubleLen6:                  case edsDoubleLen7:                  case edsDoubleLen8:                      count = code - edsDoubleLen0;                      long lvalue = 0;                        for (int n = 0; n < count; ++n)                      {                          lvalue = (lvalue << 8) | (source[offset++] & 0xff);                      }                        lvalue <<= (8 - count) * 8;                      dbl = BitConverter.Int64BitsToDouble(lvalue);                      type = edsTypeDouble;                      break;                    case edsTimeLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeTime;                      break;                    case edsTimeLen1:                  case edsTimeLen2:                  case edsTimeLen3:                  case edsTimeLen4:                      l = code - edsTimeLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeTime;                      break;                    case edsMilliSecLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeMilliseconds;                      break;                    case edsMilliSecLen1:                  case edsMilliSecLen2:                  case edsMilliSecLen3:                  case edsMilliSecLen4:                  case edsMilliSecLen5:                  case edsMilliSecLen6:                  case edsMilliSecLen7:                  case edsMilliSecLen8:                      l = code - edsMilliSecLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeMilliseconds;                      break;                    case edsNanoSecLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeNanoseconds;                      break;                    case edsNanoSecLen1:                  case edsNanoSecLen2:                  case edsNanoSecLen3:                  case edsNanoSecLen4:                  case edsNanoSecLen5:                  case edsNanoSecLen6:                  case edsNanoSecLen7:                  case edsNanoSecLen8:                      l = code - edsNanoSecLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeNanoseconds;                      break;                    //                  // 09/2012 Added support for new scaled date/times encoding. These replace the old encoding                  // edsTimeLen' edsMilliSecLen and edsNanoSecLen.                  //                    case edsScaledTimeLen1:                  case edsScaledTimeLen2:                  case edsScaledTimeLen3:                  case edsScaledTimeLen4:                  case edsScaledTimeLen5:                  case edsScaledTimeLen6:                  case edsScaledTimeLen7:                  case edsScaledTimeLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledTimeLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledTime;                      break;                    case edsScaledDateLen1:                  case edsScaledDateLen2:                  case edsScaledDateLen3:                  case edsScaledDateLen4:                  case edsScaledDateLen5:                  case edsScaledDateLen6:                  case edsScaledDateLen7:                  case edsScaledDateLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledDateLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledDate;                      break;                    case edsScaledTimestampLen1:                  case edsScaledTimestampLen2:                  case edsScaledTimestampLen3:                  case edsScaledTimestampLen4:                  case edsScaledTimestampLen5:                  case edsScaledTimestampLen6:                  case edsScaledTimestampLen7:                  case edsScaledTimestampLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledTimestampLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledTimestamp;                      break;                    case edsClobLen0:                      blobId = 0;                      type = edsTypeClob;                      break;                    case edsClobLen1:                  case edsClobLen2:                  case edsClobLen3:                  case edsClobLen4:                      l = code - edsClobLen1;                      blobId = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          blobId = (blobId << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeClob;                      break;                    case edsBlobLen0:                      blobId = 0;                      type = edsTypeBlob;                      break;                    case edsBlobLen1:                  case edsBlobLen2:                  case edsBlobLen3:                  case edsBlobLen4:                      l = code - edsBlobLen1;                      blobId = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          blobId = (blobId << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeBlob;                      break;                    case edsScaledCount1:                      {                          // For some reason C++ EncodedStream expects the encoded                          // length to be length+1.                            length = (source[offset++] & 0xff) - 1;                          scale = (sbyte)source[offset++];                          type = edsTypeBigInt;                          bytes = new byte[length];                          Array.Copy(source' offset' bytes' 0' length);                          offset += length;                          int sign = ((bytes[0] & 0x80) > 0) ? -1 : 1;                            if (sign == -1)                          {                              bytes[0] &= 0x7f;                          }                            BigInteger bi = new BigInteger(bytes);                          bigDecimal = Decimal.Parse(bi.ToString());                      }                      break;                    case edsScaledCount2:                      {                          // For some reason C++ EncodedStream expects the encoded                          // length to be length+1.                            scale = (sbyte)source[offset++];                          sbyte sign = (sbyte)source[offset++];                          length = (source[offset++] & 0xff); // in bytes                          type = edsTypeBigInt;                          bytes = new byte[length];                          Array.Copy(source' offset' bytes' 0' length);                          offset += length;                            if (sign == -1)                              bytes[0] &= 0x7f;                          else                              sign = 1;                            BigInteger bi = new BigInteger(bytes);                          if (sign == -1)                              bi = -bi;                          bigDecimal = ScaleDecimal(Decimal.Parse(bi.ToString())' scale);                      }                      break;                    case edsUUID:                      {                          byte[] buff = new byte[16];                            for (int n = 0; n < 16; ++n)                          {                              buff[n] = (byte)(source[offset++] & 0xff);                          }                            uuid = new Guid(buff);                          type = edsTypeUUID;                      }                      break;                    default:                      type = edsTypeUnknown;                      break;              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,decode,The following statement contains a magic number: switch (code)              {                  case edsNull:                      type = edsTypeNull;                      break;                    case edsTrue:                      type = edsTypeBoolean;                      @bool = true;                      break;                    case edsFalse:                      type = edsTypeBoolean;                      @bool = false;                      break;                    case edsIntMinus10:                  case edsIntMinus9:                  case edsIntMinus8:                  case edsIntMinus7:                  case edsIntMinus6:                  case edsIntMinus5:                  case edsIntMinus4:                  case edsIntMinus3:                  case edsIntMinus2:                  case edsIntMinus1:                  case edsInt0:                  case edsInt1:                  case edsInt2:                  case edsInt3:                  case edsInt4:                  case edsInt5:                  case edsInt6:                  case edsInt7:                  case edsInt8:                  case edsInt9:                  case edsInt10:                  case edsInt11:                  case edsInt12:                  case edsInt13:                  case edsInt14:                  case edsInt15:                  case edsInt16:                  case edsInt17:                  case edsInt18:                  case edsInt19:                  case edsInt20:                  case edsInt21:                  case edsInt22:                  case edsInt23:                  case edsInt24:                  case edsInt25:                  case edsInt26:                  case edsInt27:                  case edsInt28:                  case edsInt29:                  case edsInt30:                  case edsInt31:                      integer32 = code - edsInt0;                      scale = 0;                      type = edsTypeInt32;                      break;                    case edsIntLen1:                      type = edsTypeInt32;                      scale = 0;                      integer32 = (sbyte)source[offset++];                      break;                    case edsIntLen2:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset] << 8) | (source[offset + 1] & 0xff);                      offset += 2;                      break;                    case edsIntLen3:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset]) << 16 | (source[offset + 1] & 0xff) << 8 | (source[offset + 2] & 0xff);                      offset += 3;                      break;                    case edsIntLen4:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset]) << 24 | (source[offset + 1] & 0xff) << 16 | (source[offset + 2] & 0xff) << 8 | (source[offset + 3] & 0xff);                      offset += 4;                      break;                    case edsIntLen5:                  case edsIntLen6:                  case edsIntLen7:                  case edsIntLen8:                      l = code - edsIntLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeInt64;                      break;                    case edsScaledLen0:                      scale = (sbyte)source[offset++];                      integer64 = 0;                      type = edsTypeScaled;                      break;                    case edsScaledLen1:                  case edsScaledLen2:                  case edsScaledLen3:                  case edsScaledLen4:                  case edsScaledLen5:                  case edsScaledLen6:                  case edsScaledLen7:                  case edsScaledLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaled;                      break;                    case edsUtf8Len0:                  case edsUtf8Len1:                  case edsUtf8Len2:                  case edsUtf8Len3:                  case edsUtf8Len4:                  case edsUtf8Len5:                  case edsUtf8Len6:                  case edsUtf8Len7:                  case edsUtf8Len8:                  case edsUtf8Len9:                  case edsUtf8Len10:                  case edsUtf8Len11:                  case edsUtf8Len12:                  case edsUtf8Len13:                  case edsUtf8Len14:                  case edsUtf8Len15:                  case edsUtf8Len16:                  case edsUtf8Len17:                  case edsUtf8Len18:                  case edsUtf8Len19:                  case edsUtf8Len20:                  case edsUtf8Len21:                  case edsUtf8Len22:                  case edsUtf8Len23:                  case edsUtf8Len24:                  case edsUtf8Len25:                  case edsUtf8Len26:                  case edsUtf8Len27:                  case edsUtf8Len28:                  case edsUtf8Len29:                  case edsUtf8Len30:                  case edsUtf8Len31:                  case edsUtf8Len32:                  case edsUtf8Len33:                  case edsUtf8Len34:                  case edsUtf8Len35:                  case edsUtf8Len36:                  case edsUtf8Len37:                  case edsUtf8Len38:                  case edsUtf8Len39:                      l = code - edsUtf8Len0;                      @string = getString(source' offset' l);                      offset += l;                      type = edsTypeUtf8;                      break;                    case edsUtf8Count1:                  case edsUtf8Count2:                  case edsUtf8Count3:                  case edsUtf8Count4:                      count = code - edsUtf8Count1;                      int length = source[offset++] & 0xff;                        for (int n = 0; n < count; ++n)                      {                          length = length << 8 | (source[offset++] & 0xff);                      }                        @string = getString(source' offset' length);                      offset += length;                      type = edsTypeUtf8;                      break;                    case edsOpaqueLen0:                  case edsOpaqueLen1:                  case edsOpaqueLen2:                  case edsOpaqueLen3:                  case edsOpaqueLen4:                  case edsOpaqueLen5:                  case edsOpaqueLen6:                  case edsOpaqueLen7:                  case edsOpaqueLen8:                  case edsOpaqueLen9:                  case edsOpaqueLen10:                  case edsOpaqueLen11:                  case edsOpaqueLen12:                  case edsOpaqueLen13:                  case edsOpaqueLen14:                  case edsOpaqueLen15:                  case edsOpaqueLen16:                  case edsOpaqueLen17:                  case edsOpaqueLen18:                  case edsOpaqueLen19:                  case edsOpaqueLen20:                  case edsOpaqueLen21:                  case edsOpaqueLen22:                  case edsOpaqueLen23:                  case edsOpaqueLen24:                  case edsOpaqueLen25:                  case edsOpaqueLen26:                  case edsOpaqueLen27:                  case edsOpaqueLen28:                  case edsOpaqueLen29:                  case edsOpaqueLen30:                  case edsOpaqueLen31:                  case edsOpaqueLen32:                  case edsOpaqueLen33:                  case edsOpaqueLen34:                  case edsOpaqueLen35:                  case edsOpaqueLen36:                  case edsOpaqueLen37:                  case edsOpaqueLen38:                  case edsOpaqueLen39:                      l = code - edsOpaqueLen0;                      bytes = new byte[l];                      Array.Copy(source' offset' bytes' 0' l);                      offset += l;                      type = edsTypeOpaque;                      break;                    case edsOpaqueCount1:                  case edsOpaqueCount2:                  case edsOpaqueCount3:                  case edsOpaqueCount4:                      count = code - edsOpaqueCount1 + 1;                      l = source[offset++] & 0xff;                        for (int n = 1; n < count; ++n)                      {                          l = l << 8 | (source[offset++] & 0xff);                      }                        bytes = new byte[l];                      Array.Copy(source' offset' bytes' 0' l);                      offset += l;                      type = edsTypeOpaque;                      break;                    case edsDoubleLen0:                  case edsDoubleLen1:                  case edsDoubleLen2:                  case edsDoubleLen3:                  case edsDoubleLen4:                  case edsDoubleLen5:                  case edsDoubleLen6:                  case edsDoubleLen7:                  case edsDoubleLen8:                      count = code - edsDoubleLen0;                      long lvalue = 0;                        for (int n = 0; n < count; ++n)                      {                          lvalue = (lvalue << 8) | (source[offset++] & 0xff);                      }                        lvalue <<= (8 - count) * 8;                      dbl = BitConverter.Int64BitsToDouble(lvalue);                      type = edsTypeDouble;                      break;                    case edsTimeLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeTime;                      break;                    case edsTimeLen1:                  case edsTimeLen2:                  case edsTimeLen3:                  case edsTimeLen4:                      l = code - edsTimeLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeTime;                      break;                    case edsMilliSecLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeMilliseconds;                      break;                    case edsMilliSecLen1:                  case edsMilliSecLen2:                  case edsMilliSecLen3:                  case edsMilliSecLen4:                  case edsMilliSecLen5:                  case edsMilliSecLen6:                  case edsMilliSecLen7:                  case edsMilliSecLen8:                      l = code - edsMilliSecLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeMilliseconds;                      break;                    case edsNanoSecLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeNanoseconds;                      break;                    case edsNanoSecLen1:                  case edsNanoSecLen2:                  case edsNanoSecLen3:                  case edsNanoSecLen4:                  case edsNanoSecLen5:                  case edsNanoSecLen6:                  case edsNanoSecLen7:                  case edsNanoSecLen8:                      l = code - edsNanoSecLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeNanoseconds;                      break;                    //                  // 09/2012 Added support for new scaled date/times encoding. These replace the old encoding                  // edsTimeLen' edsMilliSecLen and edsNanoSecLen.                  //                    case edsScaledTimeLen1:                  case edsScaledTimeLen2:                  case edsScaledTimeLen3:                  case edsScaledTimeLen4:                  case edsScaledTimeLen5:                  case edsScaledTimeLen6:                  case edsScaledTimeLen7:                  case edsScaledTimeLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledTimeLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledTime;                      break;                    case edsScaledDateLen1:                  case edsScaledDateLen2:                  case edsScaledDateLen3:                  case edsScaledDateLen4:                  case edsScaledDateLen5:                  case edsScaledDateLen6:                  case edsScaledDateLen7:                  case edsScaledDateLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledDateLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledDate;                      break;                    case edsScaledTimestampLen1:                  case edsScaledTimestampLen2:                  case edsScaledTimestampLen3:                  case edsScaledTimestampLen4:                  case edsScaledTimestampLen5:                  case edsScaledTimestampLen6:                  case edsScaledTimestampLen7:                  case edsScaledTimestampLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledTimestampLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledTimestamp;                      break;                    case edsClobLen0:                      blobId = 0;                      type = edsTypeClob;                      break;                    case edsClobLen1:                  case edsClobLen2:                  case edsClobLen3:                  case edsClobLen4:                      l = code - edsClobLen1;                      blobId = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          blobId = (blobId << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeClob;                      break;                    case edsBlobLen0:                      blobId = 0;                      type = edsTypeBlob;                      break;                    case edsBlobLen1:                  case edsBlobLen2:                  case edsBlobLen3:                  case edsBlobLen4:                      l = code - edsBlobLen1;                      blobId = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          blobId = (blobId << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeBlob;                      break;                    case edsScaledCount1:                      {                          // For some reason C++ EncodedStream expects the encoded                          // length to be length+1.                            length = (source[offset++] & 0xff) - 1;                          scale = (sbyte)source[offset++];                          type = edsTypeBigInt;                          bytes = new byte[length];                          Array.Copy(source' offset' bytes' 0' length);                          offset += length;                          int sign = ((bytes[0] & 0x80) > 0) ? -1 : 1;                            if (sign == -1)                          {                              bytes[0] &= 0x7f;                          }                            BigInteger bi = new BigInteger(bytes);                          bigDecimal = Decimal.Parse(bi.ToString());                      }                      break;                    case edsScaledCount2:                      {                          // For some reason C++ EncodedStream expects the encoded                          // length to be length+1.                            scale = (sbyte)source[offset++];                          sbyte sign = (sbyte)source[offset++];                          length = (source[offset++] & 0xff); // in bytes                          type = edsTypeBigInt;                          bytes = new byte[length];                          Array.Copy(source' offset' bytes' 0' length);                          offset += length;                            if (sign == -1)                              bytes[0] &= 0x7f;                          else                              sign = 1;                            BigInteger bi = new BigInteger(bytes);                          if (sign == -1)                              bi = -bi;                          bigDecimal = ScaleDecimal(Decimal.Parse(bi.ToString())' scale);                      }                      break;                    case edsUUID:                      {                          byte[] buff = new byte[16];                            for (int n = 0; n < 16; ++n)                          {                              buff[n] = (byte)(source[offset++] & 0xff);                          }                            uuid = new Guid(buff);                          type = edsTypeUUID;                      }                      break;                    default:                      type = edsTypeUnknown;                      break;              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,decode,The following statement contains a magic number: switch (code)              {                  case edsNull:                      type = edsTypeNull;                      break;                    case edsTrue:                      type = edsTypeBoolean;                      @bool = true;                      break;                    case edsFalse:                      type = edsTypeBoolean;                      @bool = false;                      break;                    case edsIntMinus10:                  case edsIntMinus9:                  case edsIntMinus8:                  case edsIntMinus7:                  case edsIntMinus6:                  case edsIntMinus5:                  case edsIntMinus4:                  case edsIntMinus3:                  case edsIntMinus2:                  case edsIntMinus1:                  case edsInt0:                  case edsInt1:                  case edsInt2:                  case edsInt3:                  case edsInt4:                  case edsInt5:                  case edsInt6:                  case edsInt7:                  case edsInt8:                  case edsInt9:                  case edsInt10:                  case edsInt11:                  case edsInt12:                  case edsInt13:                  case edsInt14:                  case edsInt15:                  case edsInt16:                  case edsInt17:                  case edsInt18:                  case edsInt19:                  case edsInt20:                  case edsInt21:                  case edsInt22:                  case edsInt23:                  case edsInt24:                  case edsInt25:                  case edsInt26:                  case edsInt27:                  case edsInt28:                  case edsInt29:                  case edsInt30:                  case edsInt31:                      integer32 = code - edsInt0;                      scale = 0;                      type = edsTypeInt32;                      break;                    case edsIntLen1:                      type = edsTypeInt32;                      scale = 0;                      integer32 = (sbyte)source[offset++];                      break;                    case edsIntLen2:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset] << 8) | (source[offset + 1] & 0xff);                      offset += 2;                      break;                    case edsIntLen3:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset]) << 16 | (source[offset + 1] & 0xff) << 8 | (source[offset + 2] & 0xff);                      offset += 3;                      break;                    case edsIntLen4:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset]) << 24 | (source[offset + 1] & 0xff) << 16 | (source[offset + 2] & 0xff) << 8 | (source[offset + 3] & 0xff);                      offset += 4;                      break;                    case edsIntLen5:                  case edsIntLen6:                  case edsIntLen7:                  case edsIntLen8:                      l = code - edsIntLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeInt64;                      break;                    case edsScaledLen0:                      scale = (sbyte)source[offset++];                      integer64 = 0;                      type = edsTypeScaled;                      break;                    case edsScaledLen1:                  case edsScaledLen2:                  case edsScaledLen3:                  case edsScaledLen4:                  case edsScaledLen5:                  case edsScaledLen6:                  case edsScaledLen7:                  case edsScaledLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaled;                      break;                    case edsUtf8Len0:                  case edsUtf8Len1:                  case edsUtf8Len2:                  case edsUtf8Len3:                  case edsUtf8Len4:                  case edsUtf8Len5:                  case edsUtf8Len6:                  case edsUtf8Len7:                  case edsUtf8Len8:                  case edsUtf8Len9:                  case edsUtf8Len10:                  case edsUtf8Len11:                  case edsUtf8Len12:                  case edsUtf8Len13:                  case edsUtf8Len14:                  case edsUtf8Len15:                  case edsUtf8Len16:                  case edsUtf8Len17:                  case edsUtf8Len18:                  case edsUtf8Len19:                  case edsUtf8Len20:                  case edsUtf8Len21:                  case edsUtf8Len22:                  case edsUtf8Len23:                  case edsUtf8Len24:                  case edsUtf8Len25:                  case edsUtf8Len26:                  case edsUtf8Len27:                  case edsUtf8Len28:                  case edsUtf8Len29:                  case edsUtf8Len30:                  case edsUtf8Len31:                  case edsUtf8Len32:                  case edsUtf8Len33:                  case edsUtf8Len34:                  case edsUtf8Len35:                  case edsUtf8Len36:                  case edsUtf8Len37:                  case edsUtf8Len38:                  case edsUtf8Len39:                      l = code - edsUtf8Len0;                      @string = getString(source' offset' l);                      offset += l;                      type = edsTypeUtf8;                      break;                    case edsUtf8Count1:                  case edsUtf8Count2:                  case edsUtf8Count3:                  case edsUtf8Count4:                      count = code - edsUtf8Count1;                      int length = source[offset++] & 0xff;                        for (int n = 0; n < count; ++n)                      {                          length = length << 8 | (source[offset++] & 0xff);                      }                        @string = getString(source' offset' length);                      offset += length;                      type = edsTypeUtf8;                      break;                    case edsOpaqueLen0:                  case edsOpaqueLen1:                  case edsOpaqueLen2:                  case edsOpaqueLen3:                  case edsOpaqueLen4:                  case edsOpaqueLen5:                  case edsOpaqueLen6:                  case edsOpaqueLen7:                  case edsOpaqueLen8:                  case edsOpaqueLen9:                  case edsOpaqueLen10:                  case edsOpaqueLen11:                  case edsOpaqueLen12:                  case edsOpaqueLen13:                  case edsOpaqueLen14:                  case edsOpaqueLen15:                  case edsOpaqueLen16:                  case edsOpaqueLen17:                  case edsOpaqueLen18:                  case edsOpaqueLen19:                  case edsOpaqueLen20:                  case edsOpaqueLen21:                  case edsOpaqueLen22:                  case edsOpaqueLen23:                  case edsOpaqueLen24:                  case edsOpaqueLen25:                  case edsOpaqueLen26:                  case edsOpaqueLen27:                  case edsOpaqueLen28:                  case edsOpaqueLen29:                  case edsOpaqueLen30:                  case edsOpaqueLen31:                  case edsOpaqueLen32:                  case edsOpaqueLen33:                  case edsOpaqueLen34:                  case edsOpaqueLen35:                  case edsOpaqueLen36:                  case edsOpaqueLen37:                  case edsOpaqueLen38:                  case edsOpaqueLen39:                      l = code - edsOpaqueLen0;                      bytes = new byte[l];                      Array.Copy(source' offset' bytes' 0' l);                      offset += l;                      type = edsTypeOpaque;                      break;                    case edsOpaqueCount1:                  case edsOpaqueCount2:                  case edsOpaqueCount3:                  case edsOpaqueCount4:                      count = code - edsOpaqueCount1 + 1;                      l = source[offset++] & 0xff;                        for (int n = 1; n < count; ++n)                      {                          l = l << 8 | (source[offset++] & 0xff);                      }                        bytes = new byte[l];                      Array.Copy(source' offset' bytes' 0' l);                      offset += l;                      type = edsTypeOpaque;                      break;                    case edsDoubleLen0:                  case edsDoubleLen1:                  case edsDoubleLen2:                  case edsDoubleLen3:                  case edsDoubleLen4:                  case edsDoubleLen5:                  case edsDoubleLen6:                  case edsDoubleLen7:                  case edsDoubleLen8:                      count = code - edsDoubleLen0;                      long lvalue = 0;                        for (int n = 0; n < count; ++n)                      {                          lvalue = (lvalue << 8) | (source[offset++] & 0xff);                      }                        lvalue <<= (8 - count) * 8;                      dbl = BitConverter.Int64BitsToDouble(lvalue);                      type = edsTypeDouble;                      break;                    case edsTimeLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeTime;                      break;                    case edsTimeLen1:                  case edsTimeLen2:                  case edsTimeLen3:                  case edsTimeLen4:                      l = code - edsTimeLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeTime;                      break;                    case edsMilliSecLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeMilliseconds;                      break;                    case edsMilliSecLen1:                  case edsMilliSecLen2:                  case edsMilliSecLen3:                  case edsMilliSecLen4:                  case edsMilliSecLen5:                  case edsMilliSecLen6:                  case edsMilliSecLen7:                  case edsMilliSecLen8:                      l = code - edsMilliSecLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeMilliseconds;                      break;                    case edsNanoSecLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeNanoseconds;                      break;                    case edsNanoSecLen1:                  case edsNanoSecLen2:                  case edsNanoSecLen3:                  case edsNanoSecLen4:                  case edsNanoSecLen5:                  case edsNanoSecLen6:                  case edsNanoSecLen7:                  case edsNanoSecLen8:                      l = code - edsNanoSecLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeNanoseconds;                      break;                    //                  // 09/2012 Added support for new scaled date/times encoding. These replace the old encoding                  // edsTimeLen' edsMilliSecLen and edsNanoSecLen.                  //                    case edsScaledTimeLen1:                  case edsScaledTimeLen2:                  case edsScaledTimeLen3:                  case edsScaledTimeLen4:                  case edsScaledTimeLen5:                  case edsScaledTimeLen6:                  case edsScaledTimeLen7:                  case edsScaledTimeLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledTimeLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledTime;                      break;                    case edsScaledDateLen1:                  case edsScaledDateLen2:                  case edsScaledDateLen3:                  case edsScaledDateLen4:                  case edsScaledDateLen5:                  case edsScaledDateLen6:                  case edsScaledDateLen7:                  case edsScaledDateLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledDateLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledDate;                      break;                    case edsScaledTimestampLen1:                  case edsScaledTimestampLen2:                  case edsScaledTimestampLen3:                  case edsScaledTimestampLen4:                  case edsScaledTimestampLen5:                  case edsScaledTimestampLen6:                  case edsScaledTimestampLen7:                  case edsScaledTimestampLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledTimestampLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledTimestamp;                      break;                    case edsClobLen0:                      blobId = 0;                      type = edsTypeClob;                      break;                    case edsClobLen1:                  case edsClobLen2:                  case edsClobLen3:                  case edsClobLen4:                      l = code - edsClobLen1;                      blobId = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          blobId = (blobId << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeClob;                      break;                    case edsBlobLen0:                      blobId = 0;                      type = edsTypeBlob;                      break;                    case edsBlobLen1:                  case edsBlobLen2:                  case edsBlobLen3:                  case edsBlobLen4:                      l = code - edsBlobLen1;                      blobId = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          blobId = (blobId << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeBlob;                      break;                    case edsScaledCount1:                      {                          // For some reason C++ EncodedStream expects the encoded                          // length to be length+1.                            length = (source[offset++] & 0xff) - 1;                          scale = (sbyte)source[offset++];                          type = edsTypeBigInt;                          bytes = new byte[length];                          Array.Copy(source' offset' bytes' 0' length);                          offset += length;                          int sign = ((bytes[0] & 0x80) > 0) ? -1 : 1;                            if (sign == -1)                          {                              bytes[0] &= 0x7f;                          }                            BigInteger bi = new BigInteger(bytes);                          bigDecimal = Decimal.Parse(bi.ToString());                      }                      break;                    case edsScaledCount2:                      {                          // For some reason C++ EncodedStream expects the encoded                          // length to be length+1.                            scale = (sbyte)source[offset++];                          sbyte sign = (sbyte)source[offset++];                          length = (source[offset++] & 0xff); // in bytes                          type = edsTypeBigInt;                          bytes = new byte[length];                          Array.Copy(source' offset' bytes' 0' length);                          offset += length;                            if (sign == -1)                              bytes[0] &= 0x7f;                          else                              sign = 1;                            BigInteger bi = new BigInteger(bytes);                          if (sign == -1)                              bi = -bi;                          bigDecimal = ScaleDecimal(Decimal.Parse(bi.ToString())' scale);                      }                      break;                    case edsUUID:                      {                          byte[] buff = new byte[16];                            for (int n = 0; n < 16; ++n)                          {                              buff[n] = (byte)(source[offset++] & 0xff);                          }                            uuid = new Guid(buff);                          type = edsTypeUUID;                      }                      break;                    default:                      type = edsTypeUnknown;                      break;              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,decode,The following statement contains a magic number: switch (code)              {                  case edsNull:                      type = edsTypeNull;                      break;                    case edsTrue:                      type = edsTypeBoolean;                      @bool = true;                      break;                    case edsFalse:                      type = edsTypeBoolean;                      @bool = false;                      break;                    case edsIntMinus10:                  case edsIntMinus9:                  case edsIntMinus8:                  case edsIntMinus7:                  case edsIntMinus6:                  case edsIntMinus5:                  case edsIntMinus4:                  case edsIntMinus3:                  case edsIntMinus2:                  case edsIntMinus1:                  case edsInt0:                  case edsInt1:                  case edsInt2:                  case edsInt3:                  case edsInt4:                  case edsInt5:                  case edsInt6:                  case edsInt7:                  case edsInt8:                  case edsInt9:                  case edsInt10:                  case edsInt11:                  case edsInt12:                  case edsInt13:                  case edsInt14:                  case edsInt15:                  case edsInt16:                  case edsInt17:                  case edsInt18:                  case edsInt19:                  case edsInt20:                  case edsInt21:                  case edsInt22:                  case edsInt23:                  case edsInt24:                  case edsInt25:                  case edsInt26:                  case edsInt27:                  case edsInt28:                  case edsInt29:                  case edsInt30:                  case edsInt31:                      integer32 = code - edsInt0;                      scale = 0;                      type = edsTypeInt32;                      break;                    case edsIntLen1:                      type = edsTypeInt32;                      scale = 0;                      integer32 = (sbyte)source[offset++];                      break;                    case edsIntLen2:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset] << 8) | (source[offset + 1] & 0xff);                      offset += 2;                      break;                    case edsIntLen3:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset]) << 16 | (source[offset + 1] & 0xff) << 8 | (source[offset + 2] & 0xff);                      offset += 3;                      break;                    case edsIntLen4:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset]) << 24 | (source[offset + 1] & 0xff) << 16 | (source[offset + 2] & 0xff) << 8 | (source[offset + 3] & 0xff);                      offset += 4;                      break;                    case edsIntLen5:                  case edsIntLen6:                  case edsIntLen7:                  case edsIntLen8:                      l = code - edsIntLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeInt64;                      break;                    case edsScaledLen0:                      scale = (sbyte)source[offset++];                      integer64 = 0;                      type = edsTypeScaled;                      break;                    case edsScaledLen1:                  case edsScaledLen2:                  case edsScaledLen3:                  case edsScaledLen4:                  case edsScaledLen5:                  case edsScaledLen6:                  case edsScaledLen7:                  case edsScaledLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaled;                      break;                    case edsUtf8Len0:                  case edsUtf8Len1:                  case edsUtf8Len2:                  case edsUtf8Len3:                  case edsUtf8Len4:                  case edsUtf8Len5:                  case edsUtf8Len6:                  case edsUtf8Len7:                  case edsUtf8Len8:                  case edsUtf8Len9:                  case edsUtf8Len10:                  case edsUtf8Len11:                  case edsUtf8Len12:                  case edsUtf8Len13:                  case edsUtf8Len14:                  case edsUtf8Len15:                  case edsUtf8Len16:                  case edsUtf8Len17:                  case edsUtf8Len18:                  case edsUtf8Len19:                  case edsUtf8Len20:                  case edsUtf8Len21:                  case edsUtf8Len22:                  case edsUtf8Len23:                  case edsUtf8Len24:                  case edsUtf8Len25:                  case edsUtf8Len26:                  case edsUtf8Len27:                  case edsUtf8Len28:                  case edsUtf8Len29:                  case edsUtf8Len30:                  case edsUtf8Len31:                  case edsUtf8Len32:                  case edsUtf8Len33:                  case edsUtf8Len34:                  case edsUtf8Len35:                  case edsUtf8Len36:                  case edsUtf8Len37:                  case edsUtf8Len38:                  case edsUtf8Len39:                      l = code - edsUtf8Len0;                      @string = getString(source' offset' l);                      offset += l;                      type = edsTypeUtf8;                      break;                    case edsUtf8Count1:                  case edsUtf8Count2:                  case edsUtf8Count3:                  case edsUtf8Count4:                      count = code - edsUtf8Count1;                      int length = source[offset++] & 0xff;                        for (int n = 0; n < count; ++n)                      {                          length = length << 8 | (source[offset++] & 0xff);                      }                        @string = getString(source' offset' length);                      offset += length;                      type = edsTypeUtf8;                      break;                    case edsOpaqueLen0:                  case edsOpaqueLen1:                  case edsOpaqueLen2:                  case edsOpaqueLen3:                  case edsOpaqueLen4:                  case edsOpaqueLen5:                  case edsOpaqueLen6:                  case edsOpaqueLen7:                  case edsOpaqueLen8:                  case edsOpaqueLen9:                  case edsOpaqueLen10:                  case edsOpaqueLen11:                  case edsOpaqueLen12:                  case edsOpaqueLen13:                  case edsOpaqueLen14:                  case edsOpaqueLen15:                  case edsOpaqueLen16:                  case edsOpaqueLen17:                  case edsOpaqueLen18:                  case edsOpaqueLen19:                  case edsOpaqueLen20:                  case edsOpaqueLen21:                  case edsOpaqueLen22:                  case edsOpaqueLen23:                  case edsOpaqueLen24:                  case edsOpaqueLen25:                  case edsOpaqueLen26:                  case edsOpaqueLen27:                  case edsOpaqueLen28:                  case edsOpaqueLen29:                  case edsOpaqueLen30:                  case edsOpaqueLen31:                  case edsOpaqueLen32:                  case edsOpaqueLen33:                  case edsOpaqueLen34:                  case edsOpaqueLen35:                  case edsOpaqueLen36:                  case edsOpaqueLen37:                  case edsOpaqueLen38:                  case edsOpaqueLen39:                      l = code - edsOpaqueLen0;                      bytes = new byte[l];                      Array.Copy(source' offset' bytes' 0' l);                      offset += l;                      type = edsTypeOpaque;                      break;                    case edsOpaqueCount1:                  case edsOpaqueCount2:                  case edsOpaqueCount3:                  case edsOpaqueCount4:                      count = code - edsOpaqueCount1 + 1;                      l = source[offset++] & 0xff;                        for (int n = 1; n < count; ++n)                      {                          l = l << 8 | (source[offset++] & 0xff);                      }                        bytes = new byte[l];                      Array.Copy(source' offset' bytes' 0' l);                      offset += l;                      type = edsTypeOpaque;                      break;                    case edsDoubleLen0:                  case edsDoubleLen1:                  case edsDoubleLen2:                  case edsDoubleLen3:                  case edsDoubleLen4:                  case edsDoubleLen5:                  case edsDoubleLen6:                  case edsDoubleLen7:                  case edsDoubleLen8:                      count = code - edsDoubleLen0;                      long lvalue = 0;                        for (int n = 0; n < count; ++n)                      {                          lvalue = (lvalue << 8) | (source[offset++] & 0xff);                      }                        lvalue <<= (8 - count) * 8;                      dbl = BitConverter.Int64BitsToDouble(lvalue);                      type = edsTypeDouble;                      break;                    case edsTimeLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeTime;                      break;                    case edsTimeLen1:                  case edsTimeLen2:                  case edsTimeLen3:                  case edsTimeLen4:                      l = code - edsTimeLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeTime;                      break;                    case edsMilliSecLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeMilliseconds;                      break;                    case edsMilliSecLen1:                  case edsMilliSecLen2:                  case edsMilliSecLen3:                  case edsMilliSecLen4:                  case edsMilliSecLen5:                  case edsMilliSecLen6:                  case edsMilliSecLen7:                  case edsMilliSecLen8:                      l = code - edsMilliSecLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeMilliseconds;                      break;                    case edsNanoSecLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeNanoseconds;                      break;                    case edsNanoSecLen1:                  case edsNanoSecLen2:                  case edsNanoSecLen3:                  case edsNanoSecLen4:                  case edsNanoSecLen5:                  case edsNanoSecLen6:                  case edsNanoSecLen7:                  case edsNanoSecLen8:                      l = code - edsNanoSecLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeNanoseconds;                      break;                    //                  // 09/2012 Added support for new scaled date/times encoding. These replace the old encoding                  // edsTimeLen' edsMilliSecLen and edsNanoSecLen.                  //                    case edsScaledTimeLen1:                  case edsScaledTimeLen2:                  case edsScaledTimeLen3:                  case edsScaledTimeLen4:                  case edsScaledTimeLen5:                  case edsScaledTimeLen6:                  case edsScaledTimeLen7:                  case edsScaledTimeLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledTimeLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledTime;                      break;                    case edsScaledDateLen1:                  case edsScaledDateLen2:                  case edsScaledDateLen3:                  case edsScaledDateLen4:                  case edsScaledDateLen5:                  case edsScaledDateLen6:                  case edsScaledDateLen7:                  case edsScaledDateLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledDateLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledDate;                      break;                    case edsScaledTimestampLen1:                  case edsScaledTimestampLen2:                  case edsScaledTimestampLen3:                  case edsScaledTimestampLen4:                  case edsScaledTimestampLen5:                  case edsScaledTimestampLen6:                  case edsScaledTimestampLen7:                  case edsScaledTimestampLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledTimestampLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledTimestamp;                      break;                    case edsClobLen0:                      blobId = 0;                      type = edsTypeClob;                      break;                    case edsClobLen1:                  case edsClobLen2:                  case edsClobLen3:                  case edsClobLen4:                      l = code - edsClobLen1;                      blobId = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          blobId = (blobId << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeClob;                      break;                    case edsBlobLen0:                      blobId = 0;                      type = edsTypeBlob;                      break;                    case edsBlobLen1:                  case edsBlobLen2:                  case edsBlobLen3:                  case edsBlobLen4:                      l = code - edsBlobLen1;                      blobId = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          blobId = (blobId << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeBlob;                      break;                    case edsScaledCount1:                      {                          // For some reason C++ EncodedStream expects the encoded                          // length to be length+1.                            length = (source[offset++] & 0xff) - 1;                          scale = (sbyte)source[offset++];                          type = edsTypeBigInt;                          bytes = new byte[length];                          Array.Copy(source' offset' bytes' 0' length);                          offset += length;                          int sign = ((bytes[0] & 0x80) > 0) ? -1 : 1;                            if (sign == -1)                          {                              bytes[0] &= 0x7f;                          }                            BigInteger bi = new BigInteger(bytes);                          bigDecimal = Decimal.Parse(bi.ToString());                      }                      break;                    case edsScaledCount2:                      {                          // For some reason C++ EncodedStream expects the encoded                          // length to be length+1.                            scale = (sbyte)source[offset++];                          sbyte sign = (sbyte)source[offset++];                          length = (source[offset++] & 0xff); // in bytes                          type = edsTypeBigInt;                          bytes = new byte[length];                          Array.Copy(source' offset' bytes' 0' length);                          offset += length;                            if (sign == -1)                              bytes[0] &= 0x7f;                          else                              sign = 1;                            BigInteger bi = new BigInteger(bytes);                          if (sign == -1)                              bi = -bi;                          bigDecimal = ScaleDecimal(Decimal.Parse(bi.ToString())' scale);                      }                      break;                    case edsUUID:                      {                          byte[] buff = new byte[16];                            for (int n = 0; n < 16; ++n)                          {                              buff[n] = (byte)(source[offset++] & 0xff);                          }                            uuid = new Guid(buff);                          type = edsTypeUUID;                      }                      break;                    default:                      type = edsTypeUnknown;                      break;              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,decode,The following statement contains a magic number: switch (code)              {                  case edsNull:                      type = edsTypeNull;                      break;                    case edsTrue:                      type = edsTypeBoolean;                      @bool = true;                      break;                    case edsFalse:                      type = edsTypeBoolean;                      @bool = false;                      break;                    case edsIntMinus10:                  case edsIntMinus9:                  case edsIntMinus8:                  case edsIntMinus7:                  case edsIntMinus6:                  case edsIntMinus5:                  case edsIntMinus4:                  case edsIntMinus3:                  case edsIntMinus2:                  case edsIntMinus1:                  case edsInt0:                  case edsInt1:                  case edsInt2:                  case edsInt3:                  case edsInt4:                  case edsInt5:                  case edsInt6:                  case edsInt7:                  case edsInt8:                  case edsInt9:                  case edsInt10:                  case edsInt11:                  case edsInt12:                  case edsInt13:                  case edsInt14:                  case edsInt15:                  case edsInt16:                  case edsInt17:                  case edsInt18:                  case edsInt19:                  case edsInt20:                  case edsInt21:                  case edsInt22:                  case edsInt23:                  case edsInt24:                  case edsInt25:                  case edsInt26:                  case edsInt27:                  case edsInt28:                  case edsInt29:                  case edsInt30:                  case edsInt31:                      integer32 = code - edsInt0;                      scale = 0;                      type = edsTypeInt32;                      break;                    case edsIntLen1:                      type = edsTypeInt32;                      scale = 0;                      integer32 = (sbyte)source[offset++];                      break;                    case edsIntLen2:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset] << 8) | (source[offset + 1] & 0xff);                      offset += 2;                      break;                    case edsIntLen3:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset]) << 16 | (source[offset + 1] & 0xff) << 8 | (source[offset + 2] & 0xff);                      offset += 3;                      break;                    case edsIntLen4:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset]) << 24 | (source[offset + 1] & 0xff) << 16 | (source[offset + 2] & 0xff) << 8 | (source[offset + 3] & 0xff);                      offset += 4;                      break;                    case edsIntLen5:                  case edsIntLen6:                  case edsIntLen7:                  case edsIntLen8:                      l = code - edsIntLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeInt64;                      break;                    case edsScaledLen0:                      scale = (sbyte)source[offset++];                      integer64 = 0;                      type = edsTypeScaled;                      break;                    case edsScaledLen1:                  case edsScaledLen2:                  case edsScaledLen3:                  case edsScaledLen4:                  case edsScaledLen5:                  case edsScaledLen6:                  case edsScaledLen7:                  case edsScaledLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaled;                      break;                    case edsUtf8Len0:                  case edsUtf8Len1:                  case edsUtf8Len2:                  case edsUtf8Len3:                  case edsUtf8Len4:                  case edsUtf8Len5:                  case edsUtf8Len6:                  case edsUtf8Len7:                  case edsUtf8Len8:                  case edsUtf8Len9:                  case edsUtf8Len10:                  case edsUtf8Len11:                  case edsUtf8Len12:                  case edsUtf8Len13:                  case edsUtf8Len14:                  case edsUtf8Len15:                  case edsUtf8Len16:                  case edsUtf8Len17:                  case edsUtf8Len18:                  case edsUtf8Len19:                  case edsUtf8Len20:                  case edsUtf8Len21:                  case edsUtf8Len22:                  case edsUtf8Len23:                  case edsUtf8Len24:                  case edsUtf8Len25:                  case edsUtf8Len26:                  case edsUtf8Len27:                  case edsUtf8Len28:                  case edsUtf8Len29:                  case edsUtf8Len30:                  case edsUtf8Len31:                  case edsUtf8Len32:                  case edsUtf8Len33:                  case edsUtf8Len34:                  case edsUtf8Len35:                  case edsUtf8Len36:                  case edsUtf8Len37:                  case edsUtf8Len38:                  case edsUtf8Len39:                      l = code - edsUtf8Len0;                      @string = getString(source' offset' l);                      offset += l;                      type = edsTypeUtf8;                      break;                    case edsUtf8Count1:                  case edsUtf8Count2:                  case edsUtf8Count3:                  case edsUtf8Count4:                      count = code - edsUtf8Count1;                      int length = source[offset++] & 0xff;                        for (int n = 0; n < count; ++n)                      {                          length = length << 8 | (source[offset++] & 0xff);                      }                        @string = getString(source' offset' length);                      offset += length;                      type = edsTypeUtf8;                      break;                    case edsOpaqueLen0:                  case edsOpaqueLen1:                  case edsOpaqueLen2:                  case edsOpaqueLen3:                  case edsOpaqueLen4:                  case edsOpaqueLen5:                  case edsOpaqueLen6:                  case edsOpaqueLen7:                  case edsOpaqueLen8:                  case edsOpaqueLen9:                  case edsOpaqueLen10:                  case edsOpaqueLen11:                  case edsOpaqueLen12:                  case edsOpaqueLen13:                  case edsOpaqueLen14:                  case edsOpaqueLen15:                  case edsOpaqueLen16:                  case edsOpaqueLen17:                  case edsOpaqueLen18:                  case edsOpaqueLen19:                  case edsOpaqueLen20:                  case edsOpaqueLen21:                  case edsOpaqueLen22:                  case edsOpaqueLen23:                  case edsOpaqueLen24:                  case edsOpaqueLen25:                  case edsOpaqueLen26:                  case edsOpaqueLen27:                  case edsOpaqueLen28:                  case edsOpaqueLen29:                  case edsOpaqueLen30:                  case edsOpaqueLen31:                  case edsOpaqueLen32:                  case edsOpaqueLen33:                  case edsOpaqueLen34:                  case edsOpaqueLen35:                  case edsOpaqueLen36:                  case edsOpaqueLen37:                  case edsOpaqueLen38:                  case edsOpaqueLen39:                      l = code - edsOpaqueLen0;                      bytes = new byte[l];                      Array.Copy(source' offset' bytes' 0' l);                      offset += l;                      type = edsTypeOpaque;                      break;                    case edsOpaqueCount1:                  case edsOpaqueCount2:                  case edsOpaqueCount3:                  case edsOpaqueCount4:                      count = code - edsOpaqueCount1 + 1;                      l = source[offset++] & 0xff;                        for (int n = 1; n < count; ++n)                      {                          l = l << 8 | (source[offset++] & 0xff);                      }                        bytes = new byte[l];                      Array.Copy(source' offset' bytes' 0' l);                      offset += l;                      type = edsTypeOpaque;                      break;                    case edsDoubleLen0:                  case edsDoubleLen1:                  case edsDoubleLen2:                  case edsDoubleLen3:                  case edsDoubleLen4:                  case edsDoubleLen5:                  case edsDoubleLen6:                  case edsDoubleLen7:                  case edsDoubleLen8:                      count = code - edsDoubleLen0;                      long lvalue = 0;                        for (int n = 0; n < count; ++n)                      {                          lvalue = (lvalue << 8) | (source[offset++] & 0xff);                      }                        lvalue <<= (8 - count) * 8;                      dbl = BitConverter.Int64BitsToDouble(lvalue);                      type = edsTypeDouble;                      break;                    case edsTimeLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeTime;                      break;                    case edsTimeLen1:                  case edsTimeLen2:                  case edsTimeLen3:                  case edsTimeLen4:                      l = code - edsTimeLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeTime;                      break;                    case edsMilliSecLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeMilliseconds;                      break;                    case edsMilliSecLen1:                  case edsMilliSecLen2:                  case edsMilliSecLen3:                  case edsMilliSecLen4:                  case edsMilliSecLen5:                  case edsMilliSecLen6:                  case edsMilliSecLen7:                  case edsMilliSecLen8:                      l = code - edsMilliSecLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeMilliseconds;                      break;                    case edsNanoSecLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeNanoseconds;                      break;                    case edsNanoSecLen1:                  case edsNanoSecLen2:                  case edsNanoSecLen3:                  case edsNanoSecLen4:                  case edsNanoSecLen5:                  case edsNanoSecLen6:                  case edsNanoSecLen7:                  case edsNanoSecLen8:                      l = code - edsNanoSecLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeNanoseconds;                      break;                    //                  // 09/2012 Added support for new scaled date/times encoding. These replace the old encoding                  // edsTimeLen' edsMilliSecLen and edsNanoSecLen.                  //                    case edsScaledTimeLen1:                  case edsScaledTimeLen2:                  case edsScaledTimeLen3:                  case edsScaledTimeLen4:                  case edsScaledTimeLen5:                  case edsScaledTimeLen6:                  case edsScaledTimeLen7:                  case edsScaledTimeLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledTimeLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledTime;                      break;                    case edsScaledDateLen1:                  case edsScaledDateLen2:                  case edsScaledDateLen3:                  case edsScaledDateLen4:                  case edsScaledDateLen5:                  case edsScaledDateLen6:                  case edsScaledDateLen7:                  case edsScaledDateLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledDateLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledDate;                      break;                    case edsScaledTimestampLen1:                  case edsScaledTimestampLen2:                  case edsScaledTimestampLen3:                  case edsScaledTimestampLen4:                  case edsScaledTimestampLen5:                  case edsScaledTimestampLen6:                  case edsScaledTimestampLen7:                  case edsScaledTimestampLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledTimestampLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledTimestamp;                      break;                    case edsClobLen0:                      blobId = 0;                      type = edsTypeClob;                      break;                    case edsClobLen1:                  case edsClobLen2:                  case edsClobLen3:                  case edsClobLen4:                      l = code - edsClobLen1;                      blobId = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          blobId = (blobId << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeClob;                      break;                    case edsBlobLen0:                      blobId = 0;                      type = edsTypeBlob;                      break;                    case edsBlobLen1:                  case edsBlobLen2:                  case edsBlobLen3:                  case edsBlobLen4:                      l = code - edsBlobLen1;                      blobId = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          blobId = (blobId << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeBlob;                      break;                    case edsScaledCount1:                      {                          // For some reason C++ EncodedStream expects the encoded                          // length to be length+1.                            length = (source[offset++] & 0xff) - 1;                          scale = (sbyte)source[offset++];                          type = edsTypeBigInt;                          bytes = new byte[length];                          Array.Copy(source' offset' bytes' 0' length);                          offset += length;                          int sign = ((bytes[0] & 0x80) > 0) ? -1 : 1;                            if (sign == -1)                          {                              bytes[0] &= 0x7f;                          }                            BigInteger bi = new BigInteger(bytes);                          bigDecimal = Decimal.Parse(bi.ToString());                      }                      break;                    case edsScaledCount2:                      {                          // For some reason C++ EncodedStream expects the encoded                          // length to be length+1.                            scale = (sbyte)source[offset++];                          sbyte sign = (sbyte)source[offset++];                          length = (source[offset++] & 0xff); // in bytes                          type = edsTypeBigInt;                          bytes = new byte[length];                          Array.Copy(source' offset' bytes' 0' length);                          offset += length;                            if (sign == -1)                              bytes[0] &= 0x7f;                          else                              sign = 1;                            BigInteger bi = new BigInteger(bytes);                          if (sign == -1)                              bi = -bi;                          bigDecimal = ScaleDecimal(Decimal.Parse(bi.ToString())' scale);                      }                      break;                    case edsUUID:                      {                          byte[] buff = new byte[16];                            for (int n = 0; n < 16; ++n)                          {                              buff[n] = (byte)(source[offset++] & 0xff);                          }                            uuid = new Guid(buff);                          type = edsTypeUUID;                      }                      break;                    default:                      type = edsTypeUnknown;                      break;              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,decode,The following statement contains a magic number: switch (code)              {                  case edsNull:                      type = edsTypeNull;                      break;                    case edsTrue:                      type = edsTypeBoolean;                      @bool = true;                      break;                    case edsFalse:                      type = edsTypeBoolean;                      @bool = false;                      break;                    case edsIntMinus10:                  case edsIntMinus9:                  case edsIntMinus8:                  case edsIntMinus7:                  case edsIntMinus6:                  case edsIntMinus5:                  case edsIntMinus4:                  case edsIntMinus3:                  case edsIntMinus2:                  case edsIntMinus1:                  case edsInt0:                  case edsInt1:                  case edsInt2:                  case edsInt3:                  case edsInt4:                  case edsInt5:                  case edsInt6:                  case edsInt7:                  case edsInt8:                  case edsInt9:                  case edsInt10:                  case edsInt11:                  case edsInt12:                  case edsInt13:                  case edsInt14:                  case edsInt15:                  case edsInt16:                  case edsInt17:                  case edsInt18:                  case edsInt19:                  case edsInt20:                  case edsInt21:                  case edsInt22:                  case edsInt23:                  case edsInt24:                  case edsInt25:                  case edsInt26:                  case edsInt27:                  case edsInt28:                  case edsInt29:                  case edsInt30:                  case edsInt31:                      integer32 = code - edsInt0;                      scale = 0;                      type = edsTypeInt32;                      break;                    case edsIntLen1:                      type = edsTypeInt32;                      scale = 0;                      integer32 = (sbyte)source[offset++];                      break;                    case edsIntLen2:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset] << 8) | (source[offset + 1] & 0xff);                      offset += 2;                      break;                    case edsIntLen3:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset]) << 16 | (source[offset + 1] & 0xff) << 8 | (source[offset + 2] & 0xff);                      offset += 3;                      break;                    case edsIntLen4:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset]) << 24 | (source[offset + 1] & 0xff) << 16 | (source[offset + 2] & 0xff) << 8 | (source[offset + 3] & 0xff);                      offset += 4;                      break;                    case edsIntLen5:                  case edsIntLen6:                  case edsIntLen7:                  case edsIntLen8:                      l = code - edsIntLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeInt64;                      break;                    case edsScaledLen0:                      scale = (sbyte)source[offset++];                      integer64 = 0;                      type = edsTypeScaled;                      break;                    case edsScaledLen1:                  case edsScaledLen2:                  case edsScaledLen3:                  case edsScaledLen4:                  case edsScaledLen5:                  case edsScaledLen6:                  case edsScaledLen7:                  case edsScaledLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaled;                      break;                    case edsUtf8Len0:                  case edsUtf8Len1:                  case edsUtf8Len2:                  case edsUtf8Len3:                  case edsUtf8Len4:                  case edsUtf8Len5:                  case edsUtf8Len6:                  case edsUtf8Len7:                  case edsUtf8Len8:                  case edsUtf8Len9:                  case edsUtf8Len10:                  case edsUtf8Len11:                  case edsUtf8Len12:                  case edsUtf8Len13:                  case edsUtf8Len14:                  case edsUtf8Len15:                  case edsUtf8Len16:                  case edsUtf8Len17:                  case edsUtf8Len18:                  case edsUtf8Len19:                  case edsUtf8Len20:                  case edsUtf8Len21:                  case edsUtf8Len22:                  case edsUtf8Len23:                  case edsUtf8Len24:                  case edsUtf8Len25:                  case edsUtf8Len26:                  case edsUtf8Len27:                  case edsUtf8Len28:                  case edsUtf8Len29:                  case edsUtf8Len30:                  case edsUtf8Len31:                  case edsUtf8Len32:                  case edsUtf8Len33:                  case edsUtf8Len34:                  case edsUtf8Len35:                  case edsUtf8Len36:                  case edsUtf8Len37:                  case edsUtf8Len38:                  case edsUtf8Len39:                      l = code - edsUtf8Len0;                      @string = getString(source' offset' l);                      offset += l;                      type = edsTypeUtf8;                      break;                    case edsUtf8Count1:                  case edsUtf8Count2:                  case edsUtf8Count3:                  case edsUtf8Count4:                      count = code - edsUtf8Count1;                      int length = source[offset++] & 0xff;                        for (int n = 0; n < count; ++n)                      {                          length = length << 8 | (source[offset++] & 0xff);                      }                        @string = getString(source' offset' length);                      offset += length;                      type = edsTypeUtf8;                      break;                    case edsOpaqueLen0:                  case edsOpaqueLen1:                  case edsOpaqueLen2:                  case edsOpaqueLen3:                  case edsOpaqueLen4:                  case edsOpaqueLen5:                  case edsOpaqueLen6:                  case edsOpaqueLen7:                  case edsOpaqueLen8:                  case edsOpaqueLen9:                  case edsOpaqueLen10:                  case edsOpaqueLen11:                  case edsOpaqueLen12:                  case edsOpaqueLen13:                  case edsOpaqueLen14:                  case edsOpaqueLen15:                  case edsOpaqueLen16:                  case edsOpaqueLen17:                  case edsOpaqueLen18:                  case edsOpaqueLen19:                  case edsOpaqueLen20:                  case edsOpaqueLen21:                  case edsOpaqueLen22:                  case edsOpaqueLen23:                  case edsOpaqueLen24:                  case edsOpaqueLen25:                  case edsOpaqueLen26:                  case edsOpaqueLen27:                  case edsOpaqueLen28:                  case edsOpaqueLen29:                  case edsOpaqueLen30:                  case edsOpaqueLen31:                  case edsOpaqueLen32:                  case edsOpaqueLen33:                  case edsOpaqueLen34:                  case edsOpaqueLen35:                  case edsOpaqueLen36:                  case edsOpaqueLen37:                  case edsOpaqueLen38:                  case edsOpaqueLen39:                      l = code - edsOpaqueLen0;                      bytes = new byte[l];                      Array.Copy(source' offset' bytes' 0' l);                      offset += l;                      type = edsTypeOpaque;                      break;                    case edsOpaqueCount1:                  case edsOpaqueCount2:                  case edsOpaqueCount3:                  case edsOpaqueCount4:                      count = code - edsOpaqueCount1 + 1;                      l = source[offset++] & 0xff;                        for (int n = 1; n < count; ++n)                      {                          l = l << 8 | (source[offset++] & 0xff);                      }                        bytes = new byte[l];                      Array.Copy(source' offset' bytes' 0' l);                      offset += l;                      type = edsTypeOpaque;                      break;                    case edsDoubleLen0:                  case edsDoubleLen1:                  case edsDoubleLen2:                  case edsDoubleLen3:                  case edsDoubleLen4:                  case edsDoubleLen5:                  case edsDoubleLen6:                  case edsDoubleLen7:                  case edsDoubleLen8:                      count = code - edsDoubleLen0;                      long lvalue = 0;                        for (int n = 0; n < count; ++n)                      {                          lvalue = (lvalue << 8) | (source[offset++] & 0xff);                      }                        lvalue <<= (8 - count) * 8;                      dbl = BitConverter.Int64BitsToDouble(lvalue);                      type = edsTypeDouble;                      break;                    case edsTimeLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeTime;                      break;                    case edsTimeLen1:                  case edsTimeLen2:                  case edsTimeLen3:                  case edsTimeLen4:                      l = code - edsTimeLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeTime;                      break;                    case edsMilliSecLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeMilliseconds;                      break;                    case edsMilliSecLen1:                  case edsMilliSecLen2:                  case edsMilliSecLen3:                  case edsMilliSecLen4:                  case edsMilliSecLen5:                  case edsMilliSecLen6:                  case edsMilliSecLen7:                  case edsMilliSecLen8:                      l = code - edsMilliSecLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeMilliseconds;                      break;                    case edsNanoSecLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeNanoseconds;                      break;                    case edsNanoSecLen1:                  case edsNanoSecLen2:                  case edsNanoSecLen3:                  case edsNanoSecLen4:                  case edsNanoSecLen5:                  case edsNanoSecLen6:                  case edsNanoSecLen7:                  case edsNanoSecLen8:                      l = code - edsNanoSecLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeNanoseconds;                      break;                    //                  // 09/2012 Added support for new scaled date/times encoding. These replace the old encoding                  // edsTimeLen' edsMilliSecLen and edsNanoSecLen.                  //                    case edsScaledTimeLen1:                  case edsScaledTimeLen2:                  case edsScaledTimeLen3:                  case edsScaledTimeLen4:                  case edsScaledTimeLen5:                  case edsScaledTimeLen6:                  case edsScaledTimeLen7:                  case edsScaledTimeLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledTimeLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledTime;                      break;                    case edsScaledDateLen1:                  case edsScaledDateLen2:                  case edsScaledDateLen3:                  case edsScaledDateLen4:                  case edsScaledDateLen5:                  case edsScaledDateLen6:                  case edsScaledDateLen7:                  case edsScaledDateLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledDateLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledDate;                      break;                    case edsScaledTimestampLen1:                  case edsScaledTimestampLen2:                  case edsScaledTimestampLen3:                  case edsScaledTimestampLen4:                  case edsScaledTimestampLen5:                  case edsScaledTimestampLen6:                  case edsScaledTimestampLen7:                  case edsScaledTimestampLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledTimestampLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledTimestamp;                      break;                    case edsClobLen0:                      blobId = 0;                      type = edsTypeClob;                      break;                    case edsClobLen1:                  case edsClobLen2:                  case edsClobLen3:                  case edsClobLen4:                      l = code - edsClobLen1;                      blobId = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          blobId = (blobId << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeClob;                      break;                    case edsBlobLen0:                      blobId = 0;                      type = edsTypeBlob;                      break;                    case edsBlobLen1:                  case edsBlobLen2:                  case edsBlobLen3:                  case edsBlobLen4:                      l = code - edsBlobLen1;                      blobId = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          blobId = (blobId << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeBlob;                      break;                    case edsScaledCount1:                      {                          // For some reason C++ EncodedStream expects the encoded                          // length to be length+1.                            length = (source[offset++] & 0xff) - 1;                          scale = (sbyte)source[offset++];                          type = edsTypeBigInt;                          bytes = new byte[length];                          Array.Copy(source' offset' bytes' 0' length);                          offset += length;                          int sign = ((bytes[0] & 0x80) > 0) ? -1 : 1;                            if (sign == -1)                          {                              bytes[0] &= 0x7f;                          }                            BigInteger bi = new BigInteger(bytes);                          bigDecimal = Decimal.Parse(bi.ToString());                      }                      break;                    case edsScaledCount2:                      {                          // For some reason C++ EncodedStream expects the encoded                          // length to be length+1.                            scale = (sbyte)source[offset++];                          sbyte sign = (sbyte)source[offset++];                          length = (source[offset++] & 0xff); // in bytes                          type = edsTypeBigInt;                          bytes = new byte[length];                          Array.Copy(source' offset' bytes' 0' length);                          offset += length;                            if (sign == -1)                              bytes[0] &= 0x7f;                          else                              sign = 1;                            BigInteger bi = new BigInteger(bytes);                          if (sign == -1)                              bi = -bi;                          bigDecimal = ScaleDecimal(Decimal.Parse(bi.ToString())' scale);                      }                      break;                    case edsUUID:                      {                          byte[] buff = new byte[16];                            for (int n = 0; n < 16; ++n)                          {                              buff[n] = (byte)(source[offset++] & 0xff);                          }                            uuid = new Guid(buff);                          type = edsTypeUUID;                      }                      break;                    default:                      type = edsTypeUnknown;                      break;              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,decode,The following statement contains a magic number: switch (code)              {                  case edsNull:                      type = edsTypeNull;                      break;                    case edsTrue:                      type = edsTypeBoolean;                      @bool = true;                      break;                    case edsFalse:                      type = edsTypeBoolean;                      @bool = false;                      break;                    case edsIntMinus10:                  case edsIntMinus9:                  case edsIntMinus8:                  case edsIntMinus7:                  case edsIntMinus6:                  case edsIntMinus5:                  case edsIntMinus4:                  case edsIntMinus3:                  case edsIntMinus2:                  case edsIntMinus1:                  case edsInt0:                  case edsInt1:                  case edsInt2:                  case edsInt3:                  case edsInt4:                  case edsInt5:                  case edsInt6:                  case edsInt7:                  case edsInt8:                  case edsInt9:                  case edsInt10:                  case edsInt11:                  case edsInt12:                  case edsInt13:                  case edsInt14:                  case edsInt15:                  case edsInt16:                  case edsInt17:                  case edsInt18:                  case edsInt19:                  case edsInt20:                  case edsInt21:                  case edsInt22:                  case edsInt23:                  case edsInt24:                  case edsInt25:                  case edsInt26:                  case edsInt27:                  case edsInt28:                  case edsInt29:                  case edsInt30:                  case edsInt31:                      integer32 = code - edsInt0;                      scale = 0;                      type = edsTypeInt32;                      break;                    case edsIntLen1:                      type = edsTypeInt32;                      scale = 0;                      integer32 = (sbyte)source[offset++];                      break;                    case edsIntLen2:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset] << 8) | (source[offset + 1] & 0xff);                      offset += 2;                      break;                    case edsIntLen3:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset]) << 16 | (source[offset + 1] & 0xff) << 8 | (source[offset + 2] & 0xff);                      offset += 3;                      break;                    case edsIntLen4:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset]) << 24 | (source[offset + 1] & 0xff) << 16 | (source[offset + 2] & 0xff) << 8 | (source[offset + 3] & 0xff);                      offset += 4;                      break;                    case edsIntLen5:                  case edsIntLen6:                  case edsIntLen7:                  case edsIntLen8:                      l = code - edsIntLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeInt64;                      break;                    case edsScaledLen0:                      scale = (sbyte)source[offset++];                      integer64 = 0;                      type = edsTypeScaled;                      break;                    case edsScaledLen1:                  case edsScaledLen2:                  case edsScaledLen3:                  case edsScaledLen4:                  case edsScaledLen5:                  case edsScaledLen6:                  case edsScaledLen7:                  case edsScaledLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaled;                      break;                    case edsUtf8Len0:                  case edsUtf8Len1:                  case edsUtf8Len2:                  case edsUtf8Len3:                  case edsUtf8Len4:                  case edsUtf8Len5:                  case edsUtf8Len6:                  case edsUtf8Len7:                  case edsUtf8Len8:                  case edsUtf8Len9:                  case edsUtf8Len10:                  case edsUtf8Len11:                  case edsUtf8Len12:                  case edsUtf8Len13:                  case edsUtf8Len14:                  case edsUtf8Len15:                  case edsUtf8Len16:                  case edsUtf8Len17:                  case edsUtf8Len18:                  case edsUtf8Len19:                  case edsUtf8Len20:                  case edsUtf8Len21:                  case edsUtf8Len22:                  case edsUtf8Len23:                  case edsUtf8Len24:                  case edsUtf8Len25:                  case edsUtf8Len26:                  case edsUtf8Len27:                  case edsUtf8Len28:                  case edsUtf8Len29:                  case edsUtf8Len30:                  case edsUtf8Len31:                  case edsUtf8Len32:                  case edsUtf8Len33:                  case edsUtf8Len34:                  case edsUtf8Len35:                  case edsUtf8Len36:                  case edsUtf8Len37:                  case edsUtf8Len38:                  case edsUtf8Len39:                      l = code - edsUtf8Len0;                      @string = getString(source' offset' l);                      offset += l;                      type = edsTypeUtf8;                      break;                    case edsUtf8Count1:                  case edsUtf8Count2:                  case edsUtf8Count3:                  case edsUtf8Count4:                      count = code - edsUtf8Count1;                      int length = source[offset++] & 0xff;                        for (int n = 0; n < count; ++n)                      {                          length = length << 8 | (source[offset++] & 0xff);                      }                        @string = getString(source' offset' length);                      offset += length;                      type = edsTypeUtf8;                      break;                    case edsOpaqueLen0:                  case edsOpaqueLen1:                  case edsOpaqueLen2:                  case edsOpaqueLen3:                  case edsOpaqueLen4:                  case edsOpaqueLen5:                  case edsOpaqueLen6:                  case edsOpaqueLen7:                  case edsOpaqueLen8:                  case edsOpaqueLen9:                  case edsOpaqueLen10:                  case edsOpaqueLen11:                  case edsOpaqueLen12:                  case edsOpaqueLen13:                  case edsOpaqueLen14:                  case edsOpaqueLen15:                  case edsOpaqueLen16:                  case edsOpaqueLen17:                  case edsOpaqueLen18:                  case edsOpaqueLen19:                  case edsOpaqueLen20:                  case edsOpaqueLen21:                  case edsOpaqueLen22:                  case edsOpaqueLen23:                  case edsOpaqueLen24:                  case edsOpaqueLen25:                  case edsOpaqueLen26:                  case edsOpaqueLen27:                  case edsOpaqueLen28:                  case edsOpaqueLen29:                  case edsOpaqueLen30:                  case edsOpaqueLen31:                  case edsOpaqueLen32:                  case edsOpaqueLen33:                  case edsOpaqueLen34:                  case edsOpaqueLen35:                  case edsOpaqueLen36:                  case edsOpaqueLen37:                  case edsOpaqueLen38:                  case edsOpaqueLen39:                      l = code - edsOpaqueLen0;                      bytes = new byte[l];                      Array.Copy(source' offset' bytes' 0' l);                      offset += l;                      type = edsTypeOpaque;                      break;                    case edsOpaqueCount1:                  case edsOpaqueCount2:                  case edsOpaqueCount3:                  case edsOpaqueCount4:                      count = code - edsOpaqueCount1 + 1;                      l = source[offset++] & 0xff;                        for (int n = 1; n < count; ++n)                      {                          l = l << 8 | (source[offset++] & 0xff);                      }                        bytes = new byte[l];                      Array.Copy(source' offset' bytes' 0' l);                      offset += l;                      type = edsTypeOpaque;                      break;                    case edsDoubleLen0:                  case edsDoubleLen1:                  case edsDoubleLen2:                  case edsDoubleLen3:                  case edsDoubleLen4:                  case edsDoubleLen5:                  case edsDoubleLen6:                  case edsDoubleLen7:                  case edsDoubleLen8:                      count = code - edsDoubleLen0;                      long lvalue = 0;                        for (int n = 0; n < count; ++n)                      {                          lvalue = (lvalue << 8) | (source[offset++] & 0xff);                      }                        lvalue <<= (8 - count) * 8;                      dbl = BitConverter.Int64BitsToDouble(lvalue);                      type = edsTypeDouble;                      break;                    case edsTimeLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeTime;                      break;                    case edsTimeLen1:                  case edsTimeLen2:                  case edsTimeLen3:                  case edsTimeLen4:                      l = code - edsTimeLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeTime;                      break;                    case edsMilliSecLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeMilliseconds;                      break;                    case edsMilliSecLen1:                  case edsMilliSecLen2:                  case edsMilliSecLen3:                  case edsMilliSecLen4:                  case edsMilliSecLen5:                  case edsMilliSecLen6:                  case edsMilliSecLen7:                  case edsMilliSecLen8:                      l = code - edsMilliSecLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeMilliseconds;                      break;                    case edsNanoSecLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeNanoseconds;                      break;                    case edsNanoSecLen1:                  case edsNanoSecLen2:                  case edsNanoSecLen3:                  case edsNanoSecLen4:                  case edsNanoSecLen5:                  case edsNanoSecLen6:                  case edsNanoSecLen7:                  case edsNanoSecLen8:                      l = code - edsNanoSecLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeNanoseconds;                      break;                    //                  // 09/2012 Added support for new scaled date/times encoding. These replace the old encoding                  // edsTimeLen' edsMilliSecLen and edsNanoSecLen.                  //                    case edsScaledTimeLen1:                  case edsScaledTimeLen2:                  case edsScaledTimeLen3:                  case edsScaledTimeLen4:                  case edsScaledTimeLen5:                  case edsScaledTimeLen6:                  case edsScaledTimeLen7:                  case edsScaledTimeLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledTimeLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledTime;                      break;                    case edsScaledDateLen1:                  case edsScaledDateLen2:                  case edsScaledDateLen3:                  case edsScaledDateLen4:                  case edsScaledDateLen5:                  case edsScaledDateLen6:                  case edsScaledDateLen7:                  case edsScaledDateLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledDateLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledDate;                      break;                    case edsScaledTimestampLen1:                  case edsScaledTimestampLen2:                  case edsScaledTimestampLen3:                  case edsScaledTimestampLen4:                  case edsScaledTimestampLen5:                  case edsScaledTimestampLen6:                  case edsScaledTimestampLen7:                  case edsScaledTimestampLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledTimestampLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledTimestamp;                      break;                    case edsClobLen0:                      blobId = 0;                      type = edsTypeClob;                      break;                    case edsClobLen1:                  case edsClobLen2:                  case edsClobLen3:                  case edsClobLen4:                      l = code - edsClobLen1;                      blobId = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          blobId = (blobId << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeClob;                      break;                    case edsBlobLen0:                      blobId = 0;                      type = edsTypeBlob;                      break;                    case edsBlobLen1:                  case edsBlobLen2:                  case edsBlobLen3:                  case edsBlobLen4:                      l = code - edsBlobLen1;                      blobId = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          blobId = (blobId << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeBlob;                      break;                    case edsScaledCount1:                      {                          // For some reason C++ EncodedStream expects the encoded                          // length to be length+1.                            length = (source[offset++] & 0xff) - 1;                          scale = (sbyte)source[offset++];                          type = edsTypeBigInt;                          bytes = new byte[length];                          Array.Copy(source' offset' bytes' 0' length);                          offset += length;                          int sign = ((bytes[0] & 0x80) > 0) ? -1 : 1;                            if (sign == -1)                          {                              bytes[0] &= 0x7f;                          }                            BigInteger bi = new BigInteger(bytes);                          bigDecimal = Decimal.Parse(bi.ToString());                      }                      break;                    case edsScaledCount2:                      {                          // For some reason C++ EncodedStream expects the encoded                          // length to be length+1.                            scale = (sbyte)source[offset++];                          sbyte sign = (sbyte)source[offset++];                          length = (source[offset++] & 0xff); // in bytes                          type = edsTypeBigInt;                          bytes = new byte[length];                          Array.Copy(source' offset' bytes' 0' length);                          offset += length;                            if (sign == -1)                              bytes[0] &= 0x7f;                          else                              sign = 1;                            BigInteger bi = new BigInteger(bytes);                          if (sign == -1)                              bi = -bi;                          bigDecimal = ScaleDecimal(Decimal.Parse(bi.ToString())' scale);                      }                      break;                    case edsUUID:                      {                          byte[] buff = new byte[16];                            for (int n = 0; n < 16; ++n)                          {                              buff[n] = (byte)(source[offset++] & 0xff);                          }                            uuid = new Guid(buff);                          type = edsTypeUUID;                      }                      break;                    default:                      type = edsTypeUnknown;                      break;              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,decode,The following statement contains a magic number: switch (code)              {                  case edsNull:                      type = edsTypeNull;                      break;                    case edsTrue:                      type = edsTypeBoolean;                      @bool = true;                      break;                    case edsFalse:                      type = edsTypeBoolean;                      @bool = false;                      break;                    case edsIntMinus10:                  case edsIntMinus9:                  case edsIntMinus8:                  case edsIntMinus7:                  case edsIntMinus6:                  case edsIntMinus5:                  case edsIntMinus4:                  case edsIntMinus3:                  case edsIntMinus2:                  case edsIntMinus1:                  case edsInt0:                  case edsInt1:                  case edsInt2:                  case edsInt3:                  case edsInt4:                  case edsInt5:                  case edsInt6:                  case edsInt7:                  case edsInt8:                  case edsInt9:                  case edsInt10:                  case edsInt11:                  case edsInt12:                  case edsInt13:                  case edsInt14:                  case edsInt15:                  case edsInt16:                  case edsInt17:                  case edsInt18:                  case edsInt19:                  case edsInt20:                  case edsInt21:                  case edsInt22:                  case edsInt23:                  case edsInt24:                  case edsInt25:                  case edsInt26:                  case edsInt27:                  case edsInt28:                  case edsInt29:                  case edsInt30:                  case edsInt31:                      integer32 = code - edsInt0;                      scale = 0;                      type = edsTypeInt32;                      break;                    case edsIntLen1:                      type = edsTypeInt32;                      scale = 0;                      integer32 = (sbyte)source[offset++];                      break;                    case edsIntLen2:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset] << 8) | (source[offset + 1] & 0xff);                      offset += 2;                      break;                    case edsIntLen3:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset]) << 16 | (source[offset + 1] & 0xff) << 8 | (source[offset + 2] & 0xff);                      offset += 3;                      break;                    case edsIntLen4:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset]) << 24 | (source[offset + 1] & 0xff) << 16 | (source[offset + 2] & 0xff) << 8 | (source[offset + 3] & 0xff);                      offset += 4;                      break;                    case edsIntLen5:                  case edsIntLen6:                  case edsIntLen7:                  case edsIntLen8:                      l = code - edsIntLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeInt64;                      break;                    case edsScaledLen0:                      scale = (sbyte)source[offset++];                      integer64 = 0;                      type = edsTypeScaled;                      break;                    case edsScaledLen1:                  case edsScaledLen2:                  case edsScaledLen3:                  case edsScaledLen4:                  case edsScaledLen5:                  case edsScaledLen6:                  case edsScaledLen7:                  case edsScaledLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaled;                      break;                    case edsUtf8Len0:                  case edsUtf8Len1:                  case edsUtf8Len2:                  case edsUtf8Len3:                  case edsUtf8Len4:                  case edsUtf8Len5:                  case edsUtf8Len6:                  case edsUtf8Len7:                  case edsUtf8Len8:                  case edsUtf8Len9:                  case edsUtf8Len10:                  case edsUtf8Len11:                  case edsUtf8Len12:                  case edsUtf8Len13:                  case edsUtf8Len14:                  case edsUtf8Len15:                  case edsUtf8Len16:                  case edsUtf8Len17:                  case edsUtf8Len18:                  case edsUtf8Len19:                  case edsUtf8Len20:                  case edsUtf8Len21:                  case edsUtf8Len22:                  case edsUtf8Len23:                  case edsUtf8Len24:                  case edsUtf8Len25:                  case edsUtf8Len26:                  case edsUtf8Len27:                  case edsUtf8Len28:                  case edsUtf8Len29:                  case edsUtf8Len30:                  case edsUtf8Len31:                  case edsUtf8Len32:                  case edsUtf8Len33:                  case edsUtf8Len34:                  case edsUtf8Len35:                  case edsUtf8Len36:                  case edsUtf8Len37:                  case edsUtf8Len38:                  case edsUtf8Len39:                      l = code - edsUtf8Len0;                      @string = getString(source' offset' l);                      offset += l;                      type = edsTypeUtf8;                      break;                    case edsUtf8Count1:                  case edsUtf8Count2:                  case edsUtf8Count3:                  case edsUtf8Count4:                      count = code - edsUtf8Count1;                      int length = source[offset++] & 0xff;                        for (int n = 0; n < count; ++n)                      {                          length = length << 8 | (source[offset++] & 0xff);                      }                        @string = getString(source' offset' length);                      offset += length;                      type = edsTypeUtf8;                      break;                    case edsOpaqueLen0:                  case edsOpaqueLen1:                  case edsOpaqueLen2:                  case edsOpaqueLen3:                  case edsOpaqueLen4:                  case edsOpaqueLen5:                  case edsOpaqueLen6:                  case edsOpaqueLen7:                  case edsOpaqueLen8:                  case edsOpaqueLen9:                  case edsOpaqueLen10:                  case edsOpaqueLen11:                  case edsOpaqueLen12:                  case edsOpaqueLen13:                  case edsOpaqueLen14:                  case edsOpaqueLen15:                  case edsOpaqueLen16:                  case edsOpaqueLen17:                  case edsOpaqueLen18:                  case edsOpaqueLen19:                  case edsOpaqueLen20:                  case edsOpaqueLen21:                  case edsOpaqueLen22:                  case edsOpaqueLen23:                  case edsOpaqueLen24:                  case edsOpaqueLen25:                  case edsOpaqueLen26:                  case edsOpaqueLen27:                  case edsOpaqueLen28:                  case edsOpaqueLen29:                  case edsOpaqueLen30:                  case edsOpaqueLen31:                  case edsOpaqueLen32:                  case edsOpaqueLen33:                  case edsOpaqueLen34:                  case edsOpaqueLen35:                  case edsOpaqueLen36:                  case edsOpaqueLen37:                  case edsOpaqueLen38:                  case edsOpaqueLen39:                      l = code - edsOpaqueLen0;                      bytes = new byte[l];                      Array.Copy(source' offset' bytes' 0' l);                      offset += l;                      type = edsTypeOpaque;                      break;                    case edsOpaqueCount1:                  case edsOpaqueCount2:                  case edsOpaqueCount3:                  case edsOpaqueCount4:                      count = code - edsOpaqueCount1 + 1;                      l = source[offset++] & 0xff;                        for (int n = 1; n < count; ++n)                      {                          l = l << 8 | (source[offset++] & 0xff);                      }                        bytes = new byte[l];                      Array.Copy(source' offset' bytes' 0' l);                      offset += l;                      type = edsTypeOpaque;                      break;                    case edsDoubleLen0:                  case edsDoubleLen1:                  case edsDoubleLen2:                  case edsDoubleLen3:                  case edsDoubleLen4:                  case edsDoubleLen5:                  case edsDoubleLen6:                  case edsDoubleLen7:                  case edsDoubleLen8:                      count = code - edsDoubleLen0;                      long lvalue = 0;                        for (int n = 0; n < count; ++n)                      {                          lvalue = (lvalue << 8) | (source[offset++] & 0xff);                      }                        lvalue <<= (8 - count) * 8;                      dbl = BitConverter.Int64BitsToDouble(lvalue);                      type = edsTypeDouble;                      break;                    case edsTimeLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeTime;                      break;                    case edsTimeLen1:                  case edsTimeLen2:                  case edsTimeLen3:                  case edsTimeLen4:                      l = code - edsTimeLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeTime;                      break;                    case edsMilliSecLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeMilliseconds;                      break;                    case edsMilliSecLen1:                  case edsMilliSecLen2:                  case edsMilliSecLen3:                  case edsMilliSecLen4:                  case edsMilliSecLen5:                  case edsMilliSecLen6:                  case edsMilliSecLen7:                  case edsMilliSecLen8:                      l = code - edsMilliSecLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeMilliseconds;                      break;                    case edsNanoSecLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeNanoseconds;                      break;                    case edsNanoSecLen1:                  case edsNanoSecLen2:                  case edsNanoSecLen3:                  case edsNanoSecLen4:                  case edsNanoSecLen5:                  case edsNanoSecLen6:                  case edsNanoSecLen7:                  case edsNanoSecLen8:                      l = code - edsNanoSecLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeNanoseconds;                      break;                    //                  // 09/2012 Added support for new scaled date/times encoding. These replace the old encoding                  // edsTimeLen' edsMilliSecLen and edsNanoSecLen.                  //                    case edsScaledTimeLen1:                  case edsScaledTimeLen2:                  case edsScaledTimeLen3:                  case edsScaledTimeLen4:                  case edsScaledTimeLen5:                  case edsScaledTimeLen6:                  case edsScaledTimeLen7:                  case edsScaledTimeLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledTimeLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledTime;                      break;                    case edsScaledDateLen1:                  case edsScaledDateLen2:                  case edsScaledDateLen3:                  case edsScaledDateLen4:                  case edsScaledDateLen5:                  case edsScaledDateLen6:                  case edsScaledDateLen7:                  case edsScaledDateLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledDateLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledDate;                      break;                    case edsScaledTimestampLen1:                  case edsScaledTimestampLen2:                  case edsScaledTimestampLen3:                  case edsScaledTimestampLen4:                  case edsScaledTimestampLen5:                  case edsScaledTimestampLen6:                  case edsScaledTimestampLen7:                  case edsScaledTimestampLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledTimestampLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledTimestamp;                      break;                    case edsClobLen0:                      blobId = 0;                      type = edsTypeClob;                      break;                    case edsClobLen1:                  case edsClobLen2:                  case edsClobLen3:                  case edsClobLen4:                      l = code - edsClobLen1;                      blobId = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          blobId = (blobId << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeClob;                      break;                    case edsBlobLen0:                      blobId = 0;                      type = edsTypeBlob;                      break;                    case edsBlobLen1:                  case edsBlobLen2:                  case edsBlobLen3:                  case edsBlobLen4:                      l = code - edsBlobLen1;                      blobId = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          blobId = (blobId << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeBlob;                      break;                    case edsScaledCount1:                      {                          // For some reason C++ EncodedStream expects the encoded                          // length to be length+1.                            length = (source[offset++] & 0xff) - 1;                          scale = (sbyte)source[offset++];                          type = edsTypeBigInt;                          bytes = new byte[length];                          Array.Copy(source' offset' bytes' 0' length);                          offset += length;                          int sign = ((bytes[0] & 0x80) > 0) ? -1 : 1;                            if (sign == -1)                          {                              bytes[0] &= 0x7f;                          }                            BigInteger bi = new BigInteger(bytes);                          bigDecimal = Decimal.Parse(bi.ToString());                      }                      break;                    case edsScaledCount2:                      {                          // For some reason C++ EncodedStream expects the encoded                          // length to be length+1.                            scale = (sbyte)source[offset++];                          sbyte sign = (sbyte)source[offset++];                          length = (source[offset++] & 0xff); // in bytes                          type = edsTypeBigInt;                          bytes = new byte[length];                          Array.Copy(source' offset' bytes' 0' length);                          offset += length;                            if (sign == -1)                              bytes[0] &= 0x7f;                          else                              sign = 1;                            BigInteger bi = new BigInteger(bytes);                          if (sign == -1)                              bi = -bi;                          bigDecimal = ScaleDecimal(Decimal.Parse(bi.ToString())' scale);                      }                      break;                    case edsUUID:                      {                          byte[] buff = new byte[16];                            for (int n = 0; n < 16; ++n)                          {                              buff[n] = (byte)(source[offset++] & 0xff);                          }                            uuid = new Guid(buff);                          type = edsTypeUUID;                      }                      break;                    default:                      type = edsTypeUnknown;                      break;              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,decode,The following statement contains a magic number: switch (code)              {                  case edsNull:                      type = edsTypeNull;                      break;                    case edsTrue:                      type = edsTypeBoolean;                      @bool = true;                      break;                    case edsFalse:                      type = edsTypeBoolean;                      @bool = false;                      break;                    case edsIntMinus10:                  case edsIntMinus9:                  case edsIntMinus8:                  case edsIntMinus7:                  case edsIntMinus6:                  case edsIntMinus5:                  case edsIntMinus4:                  case edsIntMinus3:                  case edsIntMinus2:                  case edsIntMinus1:                  case edsInt0:                  case edsInt1:                  case edsInt2:                  case edsInt3:                  case edsInt4:                  case edsInt5:                  case edsInt6:                  case edsInt7:                  case edsInt8:                  case edsInt9:                  case edsInt10:                  case edsInt11:                  case edsInt12:                  case edsInt13:                  case edsInt14:                  case edsInt15:                  case edsInt16:                  case edsInt17:                  case edsInt18:                  case edsInt19:                  case edsInt20:                  case edsInt21:                  case edsInt22:                  case edsInt23:                  case edsInt24:                  case edsInt25:                  case edsInt26:                  case edsInt27:                  case edsInt28:                  case edsInt29:                  case edsInt30:                  case edsInt31:                      integer32 = code - edsInt0;                      scale = 0;                      type = edsTypeInt32;                      break;                    case edsIntLen1:                      type = edsTypeInt32;                      scale = 0;                      integer32 = (sbyte)source[offset++];                      break;                    case edsIntLen2:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset] << 8) | (source[offset + 1] & 0xff);                      offset += 2;                      break;                    case edsIntLen3:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset]) << 16 | (source[offset + 1] & 0xff) << 8 | (source[offset + 2] & 0xff);                      offset += 3;                      break;                    case edsIntLen4:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset]) << 24 | (source[offset + 1] & 0xff) << 16 | (source[offset + 2] & 0xff) << 8 | (source[offset + 3] & 0xff);                      offset += 4;                      break;                    case edsIntLen5:                  case edsIntLen6:                  case edsIntLen7:                  case edsIntLen8:                      l = code - edsIntLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeInt64;                      break;                    case edsScaledLen0:                      scale = (sbyte)source[offset++];                      integer64 = 0;                      type = edsTypeScaled;                      break;                    case edsScaledLen1:                  case edsScaledLen2:                  case edsScaledLen3:                  case edsScaledLen4:                  case edsScaledLen5:                  case edsScaledLen6:                  case edsScaledLen7:                  case edsScaledLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaled;                      break;                    case edsUtf8Len0:                  case edsUtf8Len1:                  case edsUtf8Len2:                  case edsUtf8Len3:                  case edsUtf8Len4:                  case edsUtf8Len5:                  case edsUtf8Len6:                  case edsUtf8Len7:                  case edsUtf8Len8:                  case edsUtf8Len9:                  case edsUtf8Len10:                  case edsUtf8Len11:                  case edsUtf8Len12:                  case edsUtf8Len13:                  case edsUtf8Len14:                  case edsUtf8Len15:                  case edsUtf8Len16:                  case edsUtf8Len17:                  case edsUtf8Len18:                  case edsUtf8Len19:                  case edsUtf8Len20:                  case edsUtf8Len21:                  case edsUtf8Len22:                  case edsUtf8Len23:                  case edsUtf8Len24:                  case edsUtf8Len25:                  case edsUtf8Len26:                  case edsUtf8Len27:                  case edsUtf8Len28:                  case edsUtf8Len29:                  case edsUtf8Len30:                  case edsUtf8Len31:                  case edsUtf8Len32:                  case edsUtf8Len33:                  case edsUtf8Len34:                  case edsUtf8Len35:                  case edsUtf8Len36:                  case edsUtf8Len37:                  case edsUtf8Len38:                  case edsUtf8Len39:                      l = code - edsUtf8Len0;                      @string = getString(source' offset' l);                      offset += l;                      type = edsTypeUtf8;                      break;                    case edsUtf8Count1:                  case edsUtf8Count2:                  case edsUtf8Count3:                  case edsUtf8Count4:                      count = code - edsUtf8Count1;                      int length = source[offset++] & 0xff;                        for (int n = 0; n < count; ++n)                      {                          length = length << 8 | (source[offset++] & 0xff);                      }                        @string = getString(source' offset' length);                      offset += length;                      type = edsTypeUtf8;                      break;                    case edsOpaqueLen0:                  case edsOpaqueLen1:                  case edsOpaqueLen2:                  case edsOpaqueLen3:                  case edsOpaqueLen4:                  case edsOpaqueLen5:                  case edsOpaqueLen6:                  case edsOpaqueLen7:                  case edsOpaqueLen8:                  case edsOpaqueLen9:                  case edsOpaqueLen10:                  case edsOpaqueLen11:                  case edsOpaqueLen12:                  case edsOpaqueLen13:                  case edsOpaqueLen14:                  case edsOpaqueLen15:                  case edsOpaqueLen16:                  case edsOpaqueLen17:                  case edsOpaqueLen18:                  case edsOpaqueLen19:                  case edsOpaqueLen20:                  case edsOpaqueLen21:                  case edsOpaqueLen22:                  case edsOpaqueLen23:                  case edsOpaqueLen24:                  case edsOpaqueLen25:                  case edsOpaqueLen26:                  case edsOpaqueLen27:                  case edsOpaqueLen28:                  case edsOpaqueLen29:                  case edsOpaqueLen30:                  case edsOpaqueLen31:                  case edsOpaqueLen32:                  case edsOpaqueLen33:                  case edsOpaqueLen34:                  case edsOpaqueLen35:                  case edsOpaqueLen36:                  case edsOpaqueLen37:                  case edsOpaqueLen38:                  case edsOpaqueLen39:                      l = code - edsOpaqueLen0;                      bytes = new byte[l];                      Array.Copy(source' offset' bytes' 0' l);                      offset += l;                      type = edsTypeOpaque;                      break;                    case edsOpaqueCount1:                  case edsOpaqueCount2:                  case edsOpaqueCount3:                  case edsOpaqueCount4:                      count = code - edsOpaqueCount1 + 1;                      l = source[offset++] & 0xff;                        for (int n = 1; n < count; ++n)                      {                          l = l << 8 | (source[offset++] & 0xff);                      }                        bytes = new byte[l];                      Array.Copy(source' offset' bytes' 0' l);                      offset += l;                      type = edsTypeOpaque;                      break;                    case edsDoubleLen0:                  case edsDoubleLen1:                  case edsDoubleLen2:                  case edsDoubleLen3:                  case edsDoubleLen4:                  case edsDoubleLen5:                  case edsDoubleLen6:                  case edsDoubleLen7:                  case edsDoubleLen8:                      count = code - edsDoubleLen0;                      long lvalue = 0;                        for (int n = 0; n < count; ++n)                      {                          lvalue = (lvalue << 8) | (source[offset++] & 0xff);                      }                        lvalue <<= (8 - count) * 8;                      dbl = BitConverter.Int64BitsToDouble(lvalue);                      type = edsTypeDouble;                      break;                    case edsTimeLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeTime;                      break;                    case edsTimeLen1:                  case edsTimeLen2:                  case edsTimeLen3:                  case edsTimeLen4:                      l = code - edsTimeLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeTime;                      break;                    case edsMilliSecLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeMilliseconds;                      break;                    case edsMilliSecLen1:                  case edsMilliSecLen2:                  case edsMilliSecLen3:                  case edsMilliSecLen4:                  case edsMilliSecLen5:                  case edsMilliSecLen6:                  case edsMilliSecLen7:                  case edsMilliSecLen8:                      l = code - edsMilliSecLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeMilliseconds;                      break;                    case edsNanoSecLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeNanoseconds;                      break;                    case edsNanoSecLen1:                  case edsNanoSecLen2:                  case edsNanoSecLen3:                  case edsNanoSecLen4:                  case edsNanoSecLen5:                  case edsNanoSecLen6:                  case edsNanoSecLen7:                  case edsNanoSecLen8:                      l = code - edsNanoSecLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeNanoseconds;                      break;                    //                  // 09/2012 Added support for new scaled date/times encoding. These replace the old encoding                  // edsTimeLen' edsMilliSecLen and edsNanoSecLen.                  //                    case edsScaledTimeLen1:                  case edsScaledTimeLen2:                  case edsScaledTimeLen3:                  case edsScaledTimeLen4:                  case edsScaledTimeLen5:                  case edsScaledTimeLen6:                  case edsScaledTimeLen7:                  case edsScaledTimeLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledTimeLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledTime;                      break;                    case edsScaledDateLen1:                  case edsScaledDateLen2:                  case edsScaledDateLen3:                  case edsScaledDateLen4:                  case edsScaledDateLen5:                  case edsScaledDateLen6:                  case edsScaledDateLen7:                  case edsScaledDateLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledDateLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledDate;                      break;                    case edsScaledTimestampLen1:                  case edsScaledTimestampLen2:                  case edsScaledTimestampLen3:                  case edsScaledTimestampLen4:                  case edsScaledTimestampLen5:                  case edsScaledTimestampLen6:                  case edsScaledTimestampLen7:                  case edsScaledTimestampLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledTimestampLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledTimestamp;                      break;                    case edsClobLen0:                      blobId = 0;                      type = edsTypeClob;                      break;                    case edsClobLen1:                  case edsClobLen2:                  case edsClobLen3:                  case edsClobLen4:                      l = code - edsClobLen1;                      blobId = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          blobId = (blobId << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeClob;                      break;                    case edsBlobLen0:                      blobId = 0;                      type = edsTypeBlob;                      break;                    case edsBlobLen1:                  case edsBlobLen2:                  case edsBlobLen3:                  case edsBlobLen4:                      l = code - edsBlobLen1;                      blobId = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          blobId = (blobId << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeBlob;                      break;                    case edsScaledCount1:                      {                          // For some reason C++ EncodedStream expects the encoded                          // length to be length+1.                            length = (source[offset++] & 0xff) - 1;                          scale = (sbyte)source[offset++];                          type = edsTypeBigInt;                          bytes = new byte[length];                          Array.Copy(source' offset' bytes' 0' length);                          offset += length;                          int sign = ((bytes[0] & 0x80) > 0) ? -1 : 1;                            if (sign == -1)                          {                              bytes[0] &= 0x7f;                          }                            BigInteger bi = new BigInteger(bytes);                          bigDecimal = Decimal.Parse(bi.ToString());                      }                      break;                    case edsScaledCount2:                      {                          // For some reason C++ EncodedStream expects the encoded                          // length to be length+1.                            scale = (sbyte)source[offset++];                          sbyte sign = (sbyte)source[offset++];                          length = (source[offset++] & 0xff); // in bytes                          type = edsTypeBigInt;                          bytes = new byte[length];                          Array.Copy(source' offset' bytes' 0' length);                          offset += length;                            if (sign == -1)                              bytes[0] &= 0x7f;                          else                              sign = 1;                            BigInteger bi = new BigInteger(bytes);                          if (sign == -1)                              bi = -bi;                          bigDecimal = ScaleDecimal(Decimal.Parse(bi.ToString())' scale);                      }                      break;                    case edsUUID:                      {                          byte[] buff = new byte[16];                            for (int n = 0; n < 16; ++n)                          {                              buff[n] = (byte)(source[offset++] & 0xff);                          }                            uuid = new Guid(buff);                          type = edsTypeUUID;                      }                      break;                    default:                      type = edsTypeUnknown;                      break;              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,decode,The following statement contains a magic number: switch (code)              {                  case edsNull:                      type = edsTypeNull;                      break;                    case edsTrue:                      type = edsTypeBoolean;                      @bool = true;                      break;                    case edsFalse:                      type = edsTypeBoolean;                      @bool = false;                      break;                    case edsIntMinus10:                  case edsIntMinus9:                  case edsIntMinus8:                  case edsIntMinus7:                  case edsIntMinus6:                  case edsIntMinus5:                  case edsIntMinus4:                  case edsIntMinus3:                  case edsIntMinus2:                  case edsIntMinus1:                  case edsInt0:                  case edsInt1:                  case edsInt2:                  case edsInt3:                  case edsInt4:                  case edsInt5:                  case edsInt6:                  case edsInt7:                  case edsInt8:                  case edsInt9:                  case edsInt10:                  case edsInt11:                  case edsInt12:                  case edsInt13:                  case edsInt14:                  case edsInt15:                  case edsInt16:                  case edsInt17:                  case edsInt18:                  case edsInt19:                  case edsInt20:                  case edsInt21:                  case edsInt22:                  case edsInt23:                  case edsInt24:                  case edsInt25:                  case edsInt26:                  case edsInt27:                  case edsInt28:                  case edsInt29:                  case edsInt30:                  case edsInt31:                      integer32 = code - edsInt0;                      scale = 0;                      type = edsTypeInt32;                      break;                    case edsIntLen1:                      type = edsTypeInt32;                      scale = 0;                      integer32 = (sbyte)source[offset++];                      break;                    case edsIntLen2:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset] << 8) | (source[offset + 1] & 0xff);                      offset += 2;                      break;                    case edsIntLen3:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset]) << 16 | (source[offset + 1] & 0xff) << 8 | (source[offset + 2] & 0xff);                      offset += 3;                      break;                    case edsIntLen4:                      type = edsTypeInt32;                      scale = 0;                      integer32 = ((sbyte)source[offset]) << 24 | (source[offset + 1] & 0xff) << 16 | (source[offset + 2] & 0xff) << 8 | (source[offset + 3] & 0xff);                      offset += 4;                      break;                    case edsIntLen5:                  case edsIntLen6:                  case edsIntLen7:                  case edsIntLen8:                      l = code - edsIntLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeInt64;                      break;                    case edsScaledLen0:                      scale = (sbyte)source[offset++];                      integer64 = 0;                      type = edsTypeScaled;                      break;                    case edsScaledLen1:                  case edsScaledLen2:                  case edsScaledLen3:                  case edsScaledLen4:                  case edsScaledLen5:                  case edsScaledLen6:                  case edsScaledLen7:                  case edsScaledLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaled;                      break;                    case edsUtf8Len0:                  case edsUtf8Len1:                  case edsUtf8Len2:                  case edsUtf8Len3:                  case edsUtf8Len4:                  case edsUtf8Len5:                  case edsUtf8Len6:                  case edsUtf8Len7:                  case edsUtf8Len8:                  case edsUtf8Len9:                  case edsUtf8Len10:                  case edsUtf8Len11:                  case edsUtf8Len12:                  case edsUtf8Len13:                  case edsUtf8Len14:                  case edsUtf8Len15:                  case edsUtf8Len16:                  case edsUtf8Len17:                  case edsUtf8Len18:                  case edsUtf8Len19:                  case edsUtf8Len20:                  case edsUtf8Len21:                  case edsUtf8Len22:                  case edsUtf8Len23:                  case edsUtf8Len24:                  case edsUtf8Len25:                  case edsUtf8Len26:                  case edsUtf8Len27:                  case edsUtf8Len28:                  case edsUtf8Len29:                  case edsUtf8Len30:                  case edsUtf8Len31:                  case edsUtf8Len32:                  case edsUtf8Len33:                  case edsUtf8Len34:                  case edsUtf8Len35:                  case edsUtf8Len36:                  case edsUtf8Len37:                  case edsUtf8Len38:                  case edsUtf8Len39:                      l = code - edsUtf8Len0;                      @string = getString(source' offset' l);                      offset += l;                      type = edsTypeUtf8;                      break;                    case edsUtf8Count1:                  case edsUtf8Count2:                  case edsUtf8Count3:                  case edsUtf8Count4:                      count = code - edsUtf8Count1;                      int length = source[offset++] & 0xff;                        for (int n = 0; n < count; ++n)                      {                          length = length << 8 | (source[offset++] & 0xff);                      }                        @string = getString(source' offset' length);                      offset += length;                      type = edsTypeUtf8;                      break;                    case edsOpaqueLen0:                  case edsOpaqueLen1:                  case edsOpaqueLen2:                  case edsOpaqueLen3:                  case edsOpaqueLen4:                  case edsOpaqueLen5:                  case edsOpaqueLen6:                  case edsOpaqueLen7:                  case edsOpaqueLen8:                  case edsOpaqueLen9:                  case edsOpaqueLen10:                  case edsOpaqueLen11:                  case edsOpaqueLen12:                  case edsOpaqueLen13:                  case edsOpaqueLen14:                  case edsOpaqueLen15:                  case edsOpaqueLen16:                  case edsOpaqueLen17:                  case edsOpaqueLen18:                  case edsOpaqueLen19:                  case edsOpaqueLen20:                  case edsOpaqueLen21:                  case edsOpaqueLen22:                  case edsOpaqueLen23:                  case edsOpaqueLen24:                  case edsOpaqueLen25:                  case edsOpaqueLen26:                  case edsOpaqueLen27:                  case edsOpaqueLen28:                  case edsOpaqueLen29:                  case edsOpaqueLen30:                  case edsOpaqueLen31:                  case edsOpaqueLen32:                  case edsOpaqueLen33:                  case edsOpaqueLen34:                  case edsOpaqueLen35:                  case edsOpaqueLen36:                  case edsOpaqueLen37:                  case edsOpaqueLen38:                  case edsOpaqueLen39:                      l = code - edsOpaqueLen0;                      bytes = new byte[l];                      Array.Copy(source' offset' bytes' 0' l);                      offset += l;                      type = edsTypeOpaque;                      break;                    case edsOpaqueCount1:                  case edsOpaqueCount2:                  case edsOpaqueCount3:                  case edsOpaqueCount4:                      count = code - edsOpaqueCount1 + 1;                      l = source[offset++] & 0xff;                        for (int n = 1; n < count; ++n)                      {                          l = l << 8 | (source[offset++] & 0xff);                      }                        bytes = new byte[l];                      Array.Copy(source' offset' bytes' 0' l);                      offset += l;                      type = edsTypeOpaque;                      break;                    case edsDoubleLen0:                  case edsDoubleLen1:                  case edsDoubleLen2:                  case edsDoubleLen3:                  case edsDoubleLen4:                  case edsDoubleLen5:                  case edsDoubleLen6:                  case edsDoubleLen7:                  case edsDoubleLen8:                      count = code - edsDoubleLen0;                      long lvalue = 0;                        for (int n = 0; n < count; ++n)                      {                          lvalue = (lvalue << 8) | (source[offset++] & 0xff);                      }                        lvalue <<= (8 - count) * 8;                      dbl = BitConverter.Int64BitsToDouble(lvalue);                      type = edsTypeDouble;                      break;                    case edsTimeLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeTime;                      break;                    case edsTimeLen1:                  case edsTimeLen2:                  case edsTimeLen3:                  case edsTimeLen4:                      l = code - edsTimeLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeTime;                      break;                    case edsMilliSecLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeMilliseconds;                      break;                    case edsMilliSecLen1:                  case edsMilliSecLen2:                  case edsMilliSecLen3:                  case edsMilliSecLen4:                  case edsMilliSecLen5:                  case edsMilliSecLen6:                  case edsMilliSecLen7:                  case edsMilliSecLen8:                      l = code - edsMilliSecLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeMilliseconds;                      break;                    case edsNanoSecLen0:                      integer64 = 0;                      scale = 0;                      type = edsTypeNanoseconds;                      break;                    case edsNanoSecLen1:                  case edsNanoSecLen2:                  case edsNanoSecLen3:                  case edsNanoSecLen4:                  case edsNanoSecLen5:                  case edsNanoSecLen6:                  case edsNanoSecLen7:                  case edsNanoSecLen8:                      l = code - edsNanoSecLen1;                      integer64 = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        scale = 0;                      type = edsTypeNanoseconds;                      break;                    //                  // 09/2012 Added support for new scaled date/times encoding. These replace the old encoding                  // edsTimeLen' edsMilliSecLen and edsNanoSecLen.                  //                    case edsScaledTimeLen1:                  case edsScaledTimeLen2:                  case edsScaledTimeLen3:                  case edsScaledTimeLen4:                  case edsScaledTimeLen5:                  case edsScaledTimeLen6:                  case edsScaledTimeLen7:                  case edsScaledTimeLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledTimeLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledTime;                      break;                    case edsScaledDateLen1:                  case edsScaledDateLen2:                  case edsScaledDateLen3:                  case edsScaledDateLen4:                  case edsScaledDateLen5:                  case edsScaledDateLen6:                  case edsScaledDateLen7:                  case edsScaledDateLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledDateLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledDate;                      break;                    case edsScaledTimestampLen1:                  case edsScaledTimestampLen2:                  case edsScaledTimestampLen3:                  case edsScaledTimestampLen4:                  case edsScaledTimestampLen5:                  case edsScaledTimestampLen6:                  case edsScaledTimestampLen7:                  case edsScaledTimestampLen8:                      scale = (sbyte)source[offset++];                      l = code - edsScaledTimestampLen1 + 1;                      integer64 = (sbyte)source[offset++];                        for (int n = 1; n < l; ++n)                      {                          integer64 = (integer64 << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeScaledTimestamp;                      break;                    case edsClobLen0:                      blobId = 0;                      type = edsTypeClob;                      break;                    case edsClobLen1:                  case edsClobLen2:                  case edsClobLen3:                  case edsClobLen4:                      l = code - edsClobLen1;                      blobId = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          blobId = (blobId << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeClob;                      break;                    case edsBlobLen0:                      blobId = 0;                      type = edsTypeBlob;                      break;                    case edsBlobLen1:                  case edsBlobLen2:                  case edsBlobLen3:                  case edsBlobLen4:                      l = code - edsBlobLen1;                      blobId = (sbyte)source[offset++];                        for (int n = 0; n < l; ++n)                      {                          blobId = (blobId << 8) | (source[offset++] & 0xff);                      }                        type = edsTypeBlob;                      break;                    case edsScaledCount1:                      {                          // For some reason C++ EncodedStream expects the encoded                          // length to be length+1.                            length = (source[offset++] & 0xff) - 1;                          scale = (sbyte)source[offset++];                          type = edsTypeBigInt;                          bytes = new byte[length];                          Array.Copy(source' offset' bytes' 0' length);                          offset += length;                          int sign = ((bytes[0] & 0x80) > 0) ? -1 : 1;                            if (sign == -1)                          {                              bytes[0] &= 0x7f;                          }                            BigInteger bi = new BigInteger(bytes);                          bigDecimal = Decimal.Parse(bi.ToString());                      }                      break;                    case edsScaledCount2:                      {                          // For some reason C++ EncodedStream expects the encoded                          // length to be length+1.                            scale = (sbyte)source[offset++];                          sbyte sign = (sbyte)source[offset++];                          length = (source[offset++] & 0xff); // in bytes                          type = edsTypeBigInt;                          bytes = new byte[length];                          Array.Copy(source' offset' bytes' 0' length);                          offset += length;                            if (sign == -1)                              bytes[0] &= 0x7f;                          else                              sign = 1;                            BigInteger bi = new BigInteger(bytes);                          if (sign == -1)                              bi = -bi;                          bigDecimal = ScaleDecimal(Decimal.Parse(bi.ToString())' scale);                      }                      break;                    case edsUUID:                      {                          byte[] buff = new byte[16];                            for (int n = 0; n < 16; ++n)                          {                              buff[n] = (byte)(source[offset++] & 0xff);                          }                            uuid = new Guid(buff);                          type = edsTypeUUID;                      }                      break;                    default:                      type = edsTypeUnknown;                      break;              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,encodeDate,The following statement contains a magic number: for (int shift = (count - 1) * 8; shift >= 0; shift -= 8)              {                  write((int)(value >> shift));              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,encodeDate,The following statement contains a magic number: for (int shift = (count - 1) * 8; shift >= 0; shift -= 8)              {                  write((int)(value >> shift));              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,encodeScaledDate,The following statement contains a magic number: long value = (long)span.TotalMilliseconds / 1000;
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,encodeScaledDate,The following statement contains a magic number: for (int shift = (count - 1) * 8; shift >= 0; shift -= 8)              {                  write((int)(value >> shift));              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,encodeScaledDate,The following statement contains a magic number: for (int shift = (count - 1) * 8; shift >= 0; shift -= 8)              {                  write((int)(value >> shift));              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,encodeDouble,The following statement contains a magic number: write(edsDoubleLen0 + 8);
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,encodeDouble,The following statement contains a magic number: for (int n = 56; n >= 0; n -= 8)              {                  write((int)(value >> n) & 0xff);              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,encodeDouble,The following statement contains a magic number: for (int n = 56; n >= 0; n -= 8)              {                  write((int)(value >> n) & 0xff);              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,encodeBigDecimal,The following statement contains a magic number: if (temp.CompareTo(long.MinValue) > 0 && temp.CompareTo(long.MaxValue) < 0)                  encodeLong((long)temp' scale);              else              {                  BigInteger bi = new BigInteger(Decimal.Truncate(Math.Abs(temp)).ToString()' 10);                  byte[] byteArray = bi.ToByteArray();                    write(edsScaledCount2);                  write(scale);                  write(bd.CompareTo(Decimal.Zero));                  write(byteArray.Length);                  write(byteArray);              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,encodeOldBigDecimal,The following statement contains a magic number: BigInteger bi = new BigInteger(Decimal.Truncate(Math.Abs(temp)).ToString()' 10);
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,encodeTime,The following statement contains a magic number: for (int shift = (count - 1) * 8; shift >= 0; shift -= 8)              {                  write((int)(milliSecondsSinceMidnight >> shift));              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,encodeTime,The following statement contains a magic number: for (int shift = (count - 1) * 8; shift >= 0; shift -= 8)              {                  write((int)(milliSecondsSinceMidnight >> shift));              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,encodeScaledTime,The following statement contains a magic number: for (int shift = (count - 1) * 8; shift >= 0; shift -= 8)              {                  write((int)(value >> shift));              }
Magic Number,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,encodeScaledTime,The following statement contains a magic number: for (int shift = (count - 1) * 8; shift >= 0; shift -= 8)              {                  write((int)(value >> shift));              }
Magic Number,NuoDb.Data.Client,Value,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Value.cs,getString,The following statement contains a magic number: char[] chars = new char[23];
Magic Number,NuoDb.Data.Client,Value,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Value.cs,getString,The following statement contains a magic number: for (long n = (value >= 0) ? value : -value; n > 0 || digits <= scale; n /= 10)              {                  if (digits == scale)                  {                      chars[digits++] = '.';                      if (n == 0)                      {                          break;                      }                  }                    chars[digits++] = (char)('0' + n % 10);              }
Magic Number,NuoDb.Data.Client,Value,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Value.cs,getString,The following statement contains a magic number: for (long n = (value >= 0) ? value : -value; n > 0 || digits <= scale; n /= 10)              {                  if (digits == scale)                  {                      chars[digits++] = '.';                      if (n == 0)                      {                          break;                      }                  }                    chars[digits++] = (char)('0' + n % 10);              }
Magic Number,NuoDb.Data.Client,Value,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Value.cs,reScale,The following statement contains a magic number: if (delta > 0)              {                  for (int n = 0; n < delta; ++n)                  {                      number *= 10;                  }              }              else if (delta < 0)              {                  for (int n = 0; n > delta; --n)                  {                      number /= 10;                  }              }
Magic Number,NuoDb.Data.Client,Value,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Value.cs,reScale,The following statement contains a magic number: if (delta > 0)              {                  for (int n = 0; n < delta; ++n)                  {                      number *= 10;                  }              }              else if (delta < 0)              {                  for (int n = 0; n > delta; --n)                  {                      number /= 10;                  }              }
Magic Number,NuoDb.Data.Client.EntityFramework,NuoDbProviderManifest,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EntityFramework\NuoDbProviderManifest.cs,GetStoreType,The following statement contains a magic number: switch (primitiveType.PrimitiveTypeKind)              {                  case PrimitiveTypeKind.Boolean:                      return TypeUsage.CreateDefaultTypeUsage(StoreTypeNameToStorePrimitiveType["boolean"]);                    case PrimitiveTypeKind.Byte:                  case PrimitiveTypeKind.Int16:                      return TypeUsage.CreateDefaultTypeUsage(StoreTypeNameToStorePrimitiveType["smallint"]);                    case PrimitiveTypeKind.Int32:                      return TypeUsage.CreateDefaultTypeUsage(StoreTypeNameToStorePrimitiveType["integer"]);                    case PrimitiveTypeKind.Int64:                      return TypeUsage.CreateDefaultTypeUsage(StoreTypeNameToStorePrimitiveType["bigint"]);                    case PrimitiveTypeKind.Double:                      return TypeUsage.CreateDefaultTypeUsage(StoreTypeNameToStorePrimitiveType["double"]);                    case PrimitiveTypeKind.Single:                      return TypeUsage.CreateDefaultTypeUsage(StoreTypeNameToStorePrimitiveType["float"]);                    case PrimitiveTypeKind.Decimal: // decimal' numeric                      {                          byte precision = 9;                          if (facets.TryGetValue("Precision"' false' out f) && !f.IsUnbounded && f.Value != null)                              precision = (byte)f.Value;                          byte scale = 0;                          if (facets.TryGetValue("Scale"' false' out f) && !f.IsUnbounded && f.Value != null)                              scale = (byte)f.Value;                            return TypeUsage.CreateDecimalTypeUsage(StoreTypeNameToStorePrimitiveType["decimal"]' precision' scale);                      }                    case PrimitiveTypeKind.String: // char' varchar' text blob                      {                          bool isUnicode = true;                          if (facets.TryGetValue("Unicode"' false' out f) && !f.IsUnbounded && f.Value != null)                              isUnicode = (bool)f.Value;                          bool isFixedLength = true;                          if (facets.TryGetValue("FixedLength"' false' out f) && !f.IsUnbounded && f.Value != null)                              isFixedLength = (bool)f.Value;                          int maxLength = Int32.MinValue;                          if (facets.TryGetValue("MaxLength"' false' out f) && !f.IsUnbounded && f.Value != null)                              maxLength = (int)f.Value;                            PrimitiveType storePrimitiveType = StoreTypeNameToStorePrimitiveType[isFixedLength ? "char" : "varchar"];                          if (maxLength != Int32.MinValue)                              return TypeUsage.CreateStringTypeUsage(storePrimitiveType' isUnicode' isFixedLength' maxLength);                            return TypeUsage.CreateStringTypeUsage(storePrimitiveType' isUnicode' isFixedLength);                      }                    case PrimitiveTypeKind.DateTime: // datetime' date                      {                          byte precision = 4;                          if (facets.TryGetValue("Precision"' false' out f) && !f.IsUnbounded && f.Value != null)                              precision = (byte)f.Value;                            bool useTimestamp = (precision != 0);                            return TypeUsage.CreateDefaultTypeUsage(useTimestamp ? StoreTypeNameToStorePrimitiveType["datetime"] : StoreTypeNameToStorePrimitiveType["date"]);                      }                    case PrimitiveTypeKind.Time:                      return TypeUsage.CreateDefaultTypeUsage(StoreTypeNameToStorePrimitiveType["time"]);                    case PrimitiveTypeKind.Binary: // blob                      {                          bool isFixedLength = true;                          if (facets.TryGetValue("FixedLength"' false' out f) && !f.IsUnbounded && f.Value != null)                              isFixedLength = (bool)f.Value;                          int maxLength = Int32.MinValue;                          if (facets.TryGetValue("MaxLength"' false' out f) && !f.IsUnbounded && f.Value != null)                              maxLength = (int)f.Value;                            PrimitiveType storePrimitiveType = StoreTypeNameToStorePrimitiveType["binary"];                          if (maxLength != Int32.MinValue)                              return TypeUsage.CreateBinaryTypeUsage(storePrimitiveType' isFixedLength' maxLength);                            return TypeUsage.CreateBinaryTypeUsage(storePrimitiveType' isFixedLength);                      }                    case PrimitiveTypeKind.Guid:                      return TypeUsage.CreateDefaultTypeUsage(StoreTypeNameToStorePrimitiveType["guid_char"]);                    default:                      throw new NotSupportedException(string.Format("There is no store type corresponding to the EDM type '{0}' of primitive type '{1}'."' edmType' primitiveType.PrimitiveTypeKind));              }
Magic Number,NuoDb.Data.Client.EntityFramework,NuoDbProviderManifest,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EntityFramework\NuoDbProviderManifest.cs,GetStoreType,The following statement contains a magic number: switch (primitiveType.PrimitiveTypeKind)              {                  case PrimitiveTypeKind.Boolean:                      return TypeUsage.CreateDefaultTypeUsage(StoreTypeNameToStorePrimitiveType["boolean"]);                    case PrimitiveTypeKind.Byte:                  case PrimitiveTypeKind.Int16:                      return TypeUsage.CreateDefaultTypeUsage(StoreTypeNameToStorePrimitiveType["smallint"]);                    case PrimitiveTypeKind.Int32:                      return TypeUsage.CreateDefaultTypeUsage(StoreTypeNameToStorePrimitiveType["integer"]);                    case PrimitiveTypeKind.Int64:                      return TypeUsage.CreateDefaultTypeUsage(StoreTypeNameToStorePrimitiveType["bigint"]);                    case PrimitiveTypeKind.Double:                      return TypeUsage.CreateDefaultTypeUsage(StoreTypeNameToStorePrimitiveType["double"]);                    case PrimitiveTypeKind.Single:                      return TypeUsage.CreateDefaultTypeUsage(StoreTypeNameToStorePrimitiveType["float"]);                    case PrimitiveTypeKind.Decimal: // decimal' numeric                      {                          byte precision = 9;                          if (facets.TryGetValue("Precision"' false' out f) && !f.IsUnbounded && f.Value != null)                              precision = (byte)f.Value;                          byte scale = 0;                          if (facets.TryGetValue("Scale"' false' out f) && !f.IsUnbounded && f.Value != null)                              scale = (byte)f.Value;                            return TypeUsage.CreateDecimalTypeUsage(StoreTypeNameToStorePrimitiveType["decimal"]' precision' scale);                      }                    case PrimitiveTypeKind.String: // char' varchar' text blob                      {                          bool isUnicode = true;                          if (facets.TryGetValue("Unicode"' false' out f) && !f.IsUnbounded && f.Value != null)                              isUnicode = (bool)f.Value;                          bool isFixedLength = true;                          if (facets.TryGetValue("FixedLength"' false' out f) && !f.IsUnbounded && f.Value != null)                              isFixedLength = (bool)f.Value;                          int maxLength = Int32.MinValue;                          if (facets.TryGetValue("MaxLength"' false' out f) && !f.IsUnbounded && f.Value != null)                              maxLength = (int)f.Value;                            PrimitiveType storePrimitiveType = StoreTypeNameToStorePrimitiveType[isFixedLength ? "char" : "varchar"];                          if (maxLength != Int32.MinValue)                              return TypeUsage.CreateStringTypeUsage(storePrimitiveType' isUnicode' isFixedLength' maxLength);                            return TypeUsage.CreateStringTypeUsage(storePrimitiveType' isUnicode' isFixedLength);                      }                    case PrimitiveTypeKind.DateTime: // datetime' date                      {                          byte precision = 4;                          if (facets.TryGetValue("Precision"' false' out f) && !f.IsUnbounded && f.Value != null)                              precision = (byte)f.Value;                            bool useTimestamp = (precision != 0);                            return TypeUsage.CreateDefaultTypeUsage(useTimestamp ? StoreTypeNameToStorePrimitiveType["datetime"] : StoreTypeNameToStorePrimitiveType["date"]);                      }                    case PrimitiveTypeKind.Time:                      return TypeUsage.CreateDefaultTypeUsage(StoreTypeNameToStorePrimitiveType["time"]);                    case PrimitiveTypeKind.Binary: // blob                      {                          bool isFixedLength = true;                          if (facets.TryGetValue("FixedLength"' false' out f) && !f.IsUnbounded && f.Value != null)                              isFixedLength = (bool)f.Value;                          int maxLength = Int32.MinValue;                          if (facets.TryGetValue("MaxLength"' false' out f) && !f.IsUnbounded && f.Value != null)                              maxLength = (int)f.Value;                            PrimitiveType storePrimitiveType = StoreTypeNameToStorePrimitiveType["binary"];                          if (maxLength != Int32.MinValue)                              return TypeUsage.CreateBinaryTypeUsage(storePrimitiveType' isFixedLength' maxLength);                            return TypeUsage.CreateBinaryTypeUsage(storePrimitiveType' isFixedLength);                      }                    case PrimitiveTypeKind.Guid:                      return TypeUsage.CreateDefaultTypeUsage(StoreTypeNameToStorePrimitiveType["guid_char"]);                    default:                      throw new NotSupportedException(string.Format("There is no store type corresponding to the EDM type '{0}' of primitive type '{1}'."' edmType' primitiveType.PrimitiveTypeKind));              }
Magic Number,NuoDb.Data.Client.EntityFramework.SqlGen,SqlGenerator,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EntityFramework\SqlGen\SqlGenerator.cs,WriteSql,The following statement contains a magic number: StringBuilder builder = new StringBuilder(1024);
Magic Number,NuoDb.Data.Client.EntityFramework.SqlGen,SqlGenerator,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EntityFramework\SqlGen\SqlGenerator.cs,Visit,The following statement contains a magic number: if (MetadataHelpers.TryGetPrimitiveTypeKind(e.ResultType' out typeKind))              {                  switch (typeKind)                  {                      case PrimitiveTypeKind.Boolean:                          result.Append(FormatBoolean((bool)e.Value));                          break;                        case PrimitiveTypeKind.Int16:                          result.Append("CAST(");                          result.Append(e.Value.ToString());                          result.Append(" AS ");                          result.Append(GetSqlPrimitiveType(e.ResultType));                          result.Append(")");                          break;                        case PrimitiveTypeKind.Int32:                          // default for integral values.                          result.Append(e.Value.ToString());                          break;                        case PrimitiveTypeKind.Int64:                          result.Append("CAST(");                          result.Append(e.Value.ToString());                          result.Append(" AS ");                          result.Append(GetSqlPrimitiveType(e.ResultType));                          result.Append(")");                          break;                        case PrimitiveTypeKind.Double:                          result.Append("CAST(");                          result.Append(((Double)e.Value).ToString(CultureInfo.InvariantCulture));                          result.Append(" AS ");                          result.Append(GetSqlPrimitiveType(e.ResultType));                          result.Append(")");                          break;                        case PrimitiveTypeKind.Single:                          result.Append("CAST(");                          result.Append(((Single)e.Value).ToString(CultureInfo.InvariantCulture));                          result.Append(" AS ");                          result.Append(GetSqlPrimitiveType(e.ResultType));                          result.Append(")");                          break;                        case PrimitiveTypeKind.Decimal:                          var sqlPrimitiveType = GetSqlPrimitiveType(e.ResultType);                          string strDecimal = ((Decimal)e.Value).ToString(CultureInfo.InvariantCulture);                            int pointPosition = strDecimal.IndexOf('.');                            int precision = 9;                          FacetDescription precisionFacetDescription;                          // there's always the max value in manifest                          if (MetadataHelpers.TryGetTypeFacetDescriptionByName(e.ResultType.EdmType' MetadataHelpers.PrecisionFacetName' out precisionFacetDescription))                          {                              if (precisionFacetDescription.DefaultValue != null)                                  precision = (int)precisionFacetDescription.DefaultValue;                          }                            int maxScale = (pointPosition != -1 ? precision - pointPosition + 1 : 0);                            result.Append("CAST(");                          result.Append(strDecimal);                          result.Append(" AS ");                          result.Append(sqlPrimitiveType.Substring(0' sqlPrimitiveType.IndexOf('(')));                          result.Append("(");                          result.Append(precision.ToString(CultureInfo.InvariantCulture));                          result.Append("'");                          result.Append(maxScale.ToString(CultureInfo.InvariantCulture));                          result.Append("))");                          break;                        case PrimitiveTypeKind.Binary:                          result.Append(FormatBinary((byte[])e.Value));                          break;                        case PrimitiveTypeKind.String:                          result.Append(FormatString((string)e.Value));                          break;                        case PrimitiveTypeKind.DateTime:                          result.Append(FormatDateTime((DateTime)e.Value));                          break;                        case PrimitiveTypeKind.Time:                          result.Append(FormatTime((DateTime)e.Value));                          break;                        case PrimitiveTypeKind.Guid:                          result.Append(FormatGuid((Guid)e.Value));                          break;                        default:                          // all known scalar types should been handled already.                          throw new NotSupportedException();                  }              }              else              {                  throw new NotSupportedException();              }
Magic Number,NuoDb.Data.Client.EntityFramework.SqlGen,SqlGenerator,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EntityFramework\SqlGen\SqlGenerator.cs,Visit,The following statement contains a magic number: List<DbExpressionBinding> inputs = new List<DbExpressionBinding>(2);
Magic Number,NuoDb.Data.Client.EntityFramework.SqlGen,SqlGenerator,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EntityFramework\SqlGen\SqlGenerator.cs,HandleSpecialFunctionToOperator,The following statement contains a magic number: Debug.Assert(e.Arguments.Count > 0 && e.Arguments.Count <= 2' "There should be 1 or 2 arguments for operator");
Magic Number,NuoDb.Data.Client.EntityFramework.SqlGen,SqlGenerator,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EntityFramework\SqlGen\SqlGenerator.cs,HandleCanonicalFunctionAddDays,The following statement contains a magic number: Debug.Assert(e.Arguments.Count == 2' "Canonical AddDays functions should have exactly two arguments");
Magic Number,NuoDb.Data.Client.EntityFramework.SqlGen,SqlGenerator,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EntityFramework\SqlGen\SqlGenerator.cs,HandleCanonicalFunctionDiffDays,The following statement contains a magic number: Debug.Assert(e.Arguments.Count == 2' "Canonical DiffDays functions should have exactly two arguments");
Magic Number,NuoDb.Data.Client.EntityFramework.SqlGen,SqlGenerator,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EntityFramework\SqlGen\SqlGenerator.cs,HandleCanonicalFunctionCreateDateTime,The following statement contains a magic number: result.Append(e.Arguments[2].Accept(sqlgen));
Magic Number,NuoDb.Data.Client.EntityFramework.SqlGen,SqlGenerator,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EntityFramework\SqlGen\SqlGenerator.cs,HandleCanonicalFunctionCreateDateTime,The following statement contains a magic number: result.Append(e.Arguments[3].Accept(sqlgen));
Magic Number,NuoDb.Data.Client.EntityFramework.SqlGen,SqlGenerator,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EntityFramework\SqlGen\SqlGenerator.cs,HandleCanonicalFunctionCreateDateTime,The following statement contains a magic number: result.Append(e.Arguments[4].Accept(sqlgen));
Magic Number,NuoDb.Data.Client.EntityFramework.SqlGen,SqlGenerator,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EntityFramework\SqlGen\SqlGenerator.cs,HandleCanonicalFunctionCreateDateTime,The following statement contains a magic number: result.Append(e.Arguments[5].Accept(sqlgen));
Magic Number,NuoDb.Data.Client.EntityFramework.SqlGen,SqlGenerator,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EntityFramework\SqlGen\SqlGenerator.cs,HandleCanonicalFunctionCreateTime,The following statement contains a magic number: result.Append(e.Arguments[2].Accept(sqlgen));
Magic Number,NuoDb.Data.Client.EntityFramework.SqlGen,SqlGenerator,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EntityFramework\SqlGen\SqlGenerator.cs,GetSqlPrimitiveType,The following statement contains a magic number: switch (primitiveType.PrimitiveTypeKind)              {                  case PrimitiveTypeKind.Boolean:                      typeName = "BOOLEAN";                      break;                    case PrimitiveTypeKind.Int16:                      typeName = "SMALLINT";                      break;                    case PrimitiveTypeKind.Int32:                      typeName = "INT";                      break;                    case PrimitiveTypeKind.Int64:                      typeName = "BIGINT";                      break;                    case PrimitiveTypeKind.Double:                      typeName = "DOUBLE PRECISION";                      break;                    case PrimitiveTypeKind.Single:                      typeName = "FLOAT";                      break;                    case PrimitiveTypeKind.Decimal:                      precision = MetadataHelpers.GetFacetValueOrDefault<byte>(type' MetadataHelpers.PrecisionFacetName' 9);                      Debug.Assert(precision > 0' "decimal precision must be greater than zero");                      scale = MetadataHelpers.GetFacetValueOrDefault<byte>(type' MetadataHelpers.ScaleFacetName' 0);                      Debug.Assert(precision >= scale' "decimalPrecision must be greater or equal to decimalScale");                      Debug.Assert(precision <= 100' "decimalPrecision must be less than or equal to 100");                      typeName = string.Format("DECIMAL({0}'{1})"' precision' scale);                      break;                    case PrimitiveTypeKind.Binary:                      typeName = "BLOB";                      break;                    case PrimitiveTypeKind.String:                      isUnicode = MetadataHelpers.GetFacetValueOrDefault<bool>(type' MetadataHelpers.UnicodeFacetName' true);                      isFixedLength = MetadataHelpers.GetFacetValueOrDefault<bool>(type' MetadataHelpers.FixedLengthFacetName' false);                      maxLength = MetadataHelpers.GetFacetValueOrDefault<int>(type' MetadataHelpers.MaxLengthFacetName' Int32.MinValue);                      if (maxLength == Int32.MinValue)                      {                          // try to get maximum length' if not enough' server will return error                          if (isUnicode)                              length = NuoDbProviderManifest.NVarcharMaxSize.ToString(CultureInfo.InvariantCulture);                          else                              length = NuoDbProviderManifest.VarcharMaxSize.ToString(CultureInfo.InvariantCulture);                      }                      else                      {                          // if the length will be too much' server will return error                          length = maxLength.ToString(CultureInfo.InvariantCulture);                      }                        if (isFixedLength)                      {                          typeName = (isUnicode ? "CHAR(" : "CHAR(") + length + ")";                      }                      else                      {                          if (int.Parse(length) > (isUnicode ? NuoDbProviderManifest.NVarcharMaxSize : NuoDbProviderManifest.VarcharMaxSize))                          {                              typeName = "CLOB";                          }                          else                          {                              typeName = (isUnicode ? "VARCHAR(" : "VARCHAR(") + length + ")";                          }                      }                      break;                    case PrimitiveTypeKind.DateTime:                      precision = MetadataHelpers.GetFacetValueOrDefault<byte>(type' MetadataHelpers.PrecisionFacetName' 4);                      typeName = (precision > 0 ? "TIMESTAMP" : "DATE");                      break;                    case PrimitiveTypeKind.Time:                      typeName = "TIME";                      break;                    case PrimitiveTypeKind.Guid:                      typeName = "CHAR(38)";                      break;                    default:                      throw new NotSupportedException("Unsupported EdmType: " + primitiveType.PrimitiveTypeKind);              }
Magic Number,NuoDb.Data.Client.EntityFramework.SqlGen,SqlGenerator,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EntityFramework\SqlGen\SqlGenerator.cs,GetSqlPrimitiveType,The following statement contains a magic number: switch (primitiveType.PrimitiveTypeKind)              {                  case PrimitiveTypeKind.Boolean:                      typeName = "BOOLEAN";                      break;                    case PrimitiveTypeKind.Int16:                      typeName = "SMALLINT";                      break;                    case PrimitiveTypeKind.Int32:                      typeName = "INT";                      break;                    case PrimitiveTypeKind.Int64:                      typeName = "BIGINT";                      break;                    case PrimitiveTypeKind.Double:                      typeName = "DOUBLE PRECISION";                      break;                    case PrimitiveTypeKind.Single:                      typeName = "FLOAT";                      break;                    case PrimitiveTypeKind.Decimal:                      precision = MetadataHelpers.GetFacetValueOrDefault<byte>(type' MetadataHelpers.PrecisionFacetName' 9);                      Debug.Assert(precision > 0' "decimal precision must be greater than zero");                      scale = MetadataHelpers.GetFacetValueOrDefault<byte>(type' MetadataHelpers.ScaleFacetName' 0);                      Debug.Assert(precision >= scale' "decimalPrecision must be greater or equal to decimalScale");                      Debug.Assert(precision <= 100' "decimalPrecision must be less than or equal to 100");                      typeName = string.Format("DECIMAL({0}'{1})"' precision' scale);                      break;                    case PrimitiveTypeKind.Binary:                      typeName = "BLOB";                      break;                    case PrimitiveTypeKind.String:                      isUnicode = MetadataHelpers.GetFacetValueOrDefault<bool>(type' MetadataHelpers.UnicodeFacetName' true);                      isFixedLength = MetadataHelpers.GetFacetValueOrDefault<bool>(type' MetadataHelpers.FixedLengthFacetName' false);                      maxLength = MetadataHelpers.GetFacetValueOrDefault<int>(type' MetadataHelpers.MaxLengthFacetName' Int32.MinValue);                      if (maxLength == Int32.MinValue)                      {                          // try to get maximum length' if not enough' server will return error                          if (isUnicode)                              length = NuoDbProviderManifest.NVarcharMaxSize.ToString(CultureInfo.InvariantCulture);                          else                              length = NuoDbProviderManifest.VarcharMaxSize.ToString(CultureInfo.InvariantCulture);                      }                      else                      {                          // if the length will be too much' server will return error                          length = maxLength.ToString(CultureInfo.InvariantCulture);                      }                        if (isFixedLength)                      {                          typeName = (isUnicode ? "CHAR(" : "CHAR(") + length + ")";                      }                      else                      {                          if (int.Parse(length) > (isUnicode ? NuoDbProviderManifest.NVarcharMaxSize : NuoDbProviderManifest.VarcharMaxSize))                          {                              typeName = "CLOB";                          }                          else                          {                              typeName = (isUnicode ? "VARCHAR(" : "VARCHAR(") + length + ")";                          }                      }                      break;                    case PrimitiveTypeKind.DateTime:                      precision = MetadataHelpers.GetFacetValueOrDefault<byte>(type' MetadataHelpers.PrecisionFacetName' 4);                      typeName = (precision > 0 ? "TIMESTAMP" : "DATE");                      break;                    case PrimitiveTypeKind.Time:                      typeName = "TIME";                      break;                    case PrimitiveTypeKind.Guid:                      typeName = "CHAR(38)";                      break;                    default:                      throw new NotSupportedException("Unsupported EdmType: " + primitiveType.PrimitiveTypeKind);              }
Magic Number,NuoDb.Data.Client.EntityFramework.SqlGen,SqlGenerator,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EntityFramework\SqlGen\SqlGenerator.cs,GetSqlPrimitiveType,The following statement contains a magic number: switch (primitiveType.PrimitiveTypeKind)              {                  case PrimitiveTypeKind.Boolean:                      typeName = "BOOLEAN";                      break;                    case PrimitiveTypeKind.Int16:                      typeName = "SMALLINT";                      break;                    case PrimitiveTypeKind.Int32:                      typeName = "INT";                      break;                    case PrimitiveTypeKind.Int64:                      typeName = "BIGINT";                      break;                    case PrimitiveTypeKind.Double:                      typeName = "DOUBLE PRECISION";                      break;                    case PrimitiveTypeKind.Single:                      typeName = "FLOAT";                      break;                    case PrimitiveTypeKind.Decimal:                      precision = MetadataHelpers.GetFacetValueOrDefault<byte>(type' MetadataHelpers.PrecisionFacetName' 9);                      Debug.Assert(precision > 0' "decimal precision must be greater than zero");                      scale = MetadataHelpers.GetFacetValueOrDefault<byte>(type' MetadataHelpers.ScaleFacetName' 0);                      Debug.Assert(precision >= scale' "decimalPrecision must be greater or equal to decimalScale");                      Debug.Assert(precision <= 100' "decimalPrecision must be less than or equal to 100");                      typeName = string.Format("DECIMAL({0}'{1})"' precision' scale);                      break;                    case PrimitiveTypeKind.Binary:                      typeName = "BLOB";                      break;                    case PrimitiveTypeKind.String:                      isUnicode = MetadataHelpers.GetFacetValueOrDefault<bool>(type' MetadataHelpers.UnicodeFacetName' true);                      isFixedLength = MetadataHelpers.GetFacetValueOrDefault<bool>(type' MetadataHelpers.FixedLengthFacetName' false);                      maxLength = MetadataHelpers.GetFacetValueOrDefault<int>(type' MetadataHelpers.MaxLengthFacetName' Int32.MinValue);                      if (maxLength == Int32.MinValue)                      {                          // try to get maximum length' if not enough' server will return error                          if (isUnicode)                              length = NuoDbProviderManifest.NVarcharMaxSize.ToString(CultureInfo.InvariantCulture);                          else                              length = NuoDbProviderManifest.VarcharMaxSize.ToString(CultureInfo.InvariantCulture);                      }                      else                      {                          // if the length will be too much' server will return error                          length = maxLength.ToString(CultureInfo.InvariantCulture);                      }                        if (isFixedLength)                      {                          typeName = (isUnicode ? "CHAR(" : "CHAR(") + length + ")";                      }                      else                      {                          if (int.Parse(length) > (isUnicode ? NuoDbProviderManifest.NVarcharMaxSize : NuoDbProviderManifest.VarcharMaxSize))                          {                              typeName = "CLOB";                          }                          else                          {                              typeName = (isUnicode ? "VARCHAR(" : "VARCHAR(") + length + ")";                          }                      }                      break;                    case PrimitiveTypeKind.DateTime:                      precision = MetadataHelpers.GetFacetValueOrDefault<byte>(type' MetadataHelpers.PrecisionFacetName' 4);                      typeName = (precision > 0 ? "TIMESTAMP" : "DATE");                      break;                    case PrimitiveTypeKind.Time:                      typeName = "TIME";                      break;                    case PrimitiveTypeKind.Guid:                      typeName = "CHAR(38)";                      break;                    default:                      throw new NotSupportedException("Unsupported EdmType: " + primitiveType.PrimitiveTypeKind);              }
Magic Number,NuoDb.Data.Client.EntityFramework.SqlGen,SqlGenerator,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EntityFramework\SqlGen\SqlGenerator.cs,ByteArrayToBinaryString,The following statement contains a magic number: StringBuilder sb = new StringBuilder(binaryArray.Length * 2);
Magic Number,NuoDb.Data.Client.EntityFramework.SqlGen,SqlGenerator,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EntityFramework\SqlGen\SqlGenerator.cs,ByteArrayToBinaryString,The following statement contains a magic number: for (int i = 0; i < binaryArray.Length; i++)              {                  sb.Append(hexDigits[(binaryArray[i] & 0xF0) >> 4]).Append(hexDigits[binaryArray[i] & 0x0F]);              }
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,BigInteger,The following statement contains a magic number: while (value != 0 && dataLength < maxLength)              {                  data[dataLength] = (uint)(value & 0xFFFFFFFF);                  value >>= 32;                  dataLength++;              }
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,BigInteger,The following statement contains a magic number: while (value != 0 && dataLength < maxLength)              {                  data[dataLength] = (uint)(value & 0xFFFFFFFF);                  value >>= 32;                  dataLength++;              }
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = value.Length - 1; i >= limit; i--)              {                  int posVal = (int)value[i];                    if (posVal >= '0' && posVal <= '9')                      posVal -= '0';                  else if (posVal >= 'A' && posVal <= 'Z')                      posVal = (posVal - 'A') + 10;                  else                      posVal = 9999999;       // arbitrary large                      if (posVal >= radix)                      throw (new ArithmeticException("Invalid string in constructor."));                  else                  {                      if (value[0] == '-')                          posVal = -posVal;                        result = result + (multiplier * posVal);                        if ((i - 1) >= limit)                          multiplier = multiplier * radix;                  }              }
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = value.Length - 1; i >= limit; i--)              {                  int posVal = (int)value[i];                    if (posVal >= '0' && posVal <= '9')                      posVal -= '0';                  else if (posVal >= 'A' && posVal <= 'Z')                      posVal = (posVal - 'A') + 10;                  else                      posVal = 9999999;       // arbitrary large                      if (posVal >= radix)                      throw (new ArithmeticException("Invalid string in constructor."));                  else                  {                      if (value[0] == '-')                          posVal = -posVal;                        result = result + (multiplier * posVal);                        if ((i - 1) >= limit)                          multiplier = multiplier * radix;                  }              }
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,BigInteger,The following statement contains a magic number: dataLength = inData.Length >> 2;
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inData.Length - 1' j = 0; i >= 3; i -= 4' j++)              {                  data[j] = (uint)((inData[i - 3] << 24) + (inData[i - 2] << 16) +                                   (inData[i - 1] << 8) + inData[i]);              }
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inData.Length - 1' j = 0; i >= 3; i -= 4' j++)              {                  data[j] = (uint)((inData[i - 3] << 24) + (inData[i - 2] << 16) +                                   (inData[i - 1] << 8) + inData[i]);              }
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inData.Length - 1' j = 0; i >= 3; i -= 4' j++)              {                  data[j] = (uint)((inData[i - 3] << 24) + (inData[i - 2] << 16) +                                   (inData[i - 1] << 8) + inData[i]);              }
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inData.Length - 1' j = 0; i >= 3; i -= 4' j++)              {                  data[j] = (uint)((inData[i - 3] << 24) + (inData[i - 2] << 16) +                                   (inData[i - 1] << 8) + inData[i]);              }
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inData.Length - 1' j = 0; i >= 3; i -= 4' j++)              {                  data[j] = (uint)((inData[i - 3] << 24) + (inData[i - 2] << 16) +                                   (inData[i - 1] << 8) + inData[i]);              }
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inData.Length - 1' j = 0; i >= 3; i -= 4' j++)              {                  data[j] = (uint)((inData[i - 3] << 24) + (inData[i - 2] << 16) +                                   (inData[i - 1] << 8) + inData[i]);              }
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inData.Length - 1' j = 0; i >= 3; i -= 4' j++)              {                  data[j] = (uint)((inData[i - 3] << 24) + (inData[i - 2] << 16) +                                   (inData[i - 1] << 8) + inData[i]);              }
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,BigInteger,The following statement contains a magic number: if (leftOver == 1)                  data[dataLength - 1] = (uint)inData[0];              else if (leftOver == 2)                  data[dataLength - 1] = (uint)((inData[0] << 8) + inData[1]);              else if (leftOver == 3)                  data[dataLength - 1] = (uint)((inData[0] << 16) + (inData[1] << 8) + inData[2]);
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,BigInteger,The following statement contains a magic number: if (leftOver == 1)                  data[dataLength - 1] = (uint)inData[0];              else if (leftOver == 2)                  data[dataLength - 1] = (uint)((inData[0] << 8) + inData[1]);              else if (leftOver == 3)                  data[dataLength - 1] = (uint)((inData[0] << 16) + (inData[1] << 8) + inData[2]);
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,BigInteger,The following statement contains a magic number: if (leftOver == 1)                  data[dataLength - 1] = (uint)inData[0];              else if (leftOver == 2)                  data[dataLength - 1] = (uint)((inData[0] << 8) + inData[1]);              else if (leftOver == 3)                  data[dataLength - 1] = (uint)((inData[0] << 16) + (inData[1] << 8) + inData[2]);
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,BigInteger,The following statement contains a magic number: if (leftOver == 1)                  data[dataLength - 1] = (uint)inData[0];              else if (leftOver == 2)                  data[dataLength - 1] = (uint)((inData[0] << 8) + inData[1]);              else if (leftOver == 3)                  data[dataLength - 1] = (uint)((inData[0] << 16) + (inData[1] << 8) + inData[2]);
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,BigInteger,The following statement contains a magic number: if (leftOver == 1)                  data[dataLength - 1] = (uint)inData[0];              else if (leftOver == 2)                  data[dataLength - 1] = (uint)((inData[0] << 8) + inData[1]);              else if (leftOver == 3)                  data[dataLength - 1] = (uint)((inData[0] << 16) + (inData[1] << 8) + inData[2]);
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,BigInteger,The following statement contains a magic number: if (leftOver == 1)                  data[dataLength - 1] = (uint)inData[0];              else if (leftOver == 2)                  data[dataLength - 1] = (uint)((inData[0] << 8) + inData[1]);              else if (leftOver == 3)                  data[dataLength - 1] = (uint)((inData[0] << 16) + (inData[1] << 8) + inData[2]);
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,BigInteger,The following statement contains a magic number: dataLength = inLen >> 2;
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inLen - 1' j = 0; i >= 3; i -= 4' j++)              {                  data[j] = (uint)((inData[i - 3] << 24) + (inData[i - 2] << 16) +                                   (inData[i - 1] << 8) + inData[i]);              }
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inLen - 1' j = 0; i >= 3; i -= 4' j++)              {                  data[j] = (uint)((inData[i - 3] << 24) + (inData[i - 2] << 16) +                                   (inData[i - 1] << 8) + inData[i]);              }
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inLen - 1' j = 0; i >= 3; i -= 4' j++)              {                  data[j] = (uint)((inData[i - 3] << 24) + (inData[i - 2] << 16) +                                   (inData[i - 1] << 8) + inData[i]);              }
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inLen - 1' j = 0; i >= 3; i -= 4' j++)              {                  data[j] = (uint)((inData[i - 3] << 24) + (inData[i - 2] << 16) +                                   (inData[i - 1] << 8) + inData[i]);              }
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inLen - 1' j = 0; i >= 3; i -= 4' j++)              {                  data[j] = (uint)((inData[i - 3] << 24) + (inData[i - 2] << 16) +                                   (inData[i - 1] << 8) + inData[i]);              }
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inLen - 1' j = 0; i >= 3; i -= 4' j++)              {                  data[j] = (uint)((inData[i - 3] << 24) + (inData[i - 2] << 16) +                                   (inData[i - 1] << 8) + inData[i]);              }
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inLen - 1' j = 0; i >= 3; i -= 4' j++)              {                  data[j] = (uint)((inData[i - 3] << 24) + (inData[i - 2] << 16) +                                   (inData[i - 1] << 8) + inData[i]);              }
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,BigInteger,The following statement contains a magic number: if (leftOver == 1)                  data[dataLength - 1] = (uint)inData[0];              else if (leftOver == 2)                  data[dataLength - 1] = (uint)((inData[0] << 8) + inData[1]);              else if (leftOver == 3)                  data[dataLength - 1] = (uint)((inData[0] << 16) + (inData[1] << 8) + inData[2]);
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,BigInteger,The following statement contains a magic number: if (leftOver == 1)                  data[dataLength - 1] = (uint)inData[0];              else if (leftOver == 2)                  data[dataLength - 1] = (uint)((inData[0] << 8) + inData[1]);              else if (leftOver == 3)                  data[dataLength - 1] = (uint)((inData[0] << 16) + (inData[1] << 8) + inData[2]);
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,BigInteger,The following statement contains a magic number: if (leftOver == 1)                  data[dataLength - 1] = (uint)inData[0];              else if (leftOver == 2)                  data[dataLength - 1] = (uint)((inData[0] << 8) + inData[1]);              else if (leftOver == 3)                  data[dataLength - 1] = (uint)((inData[0] << 16) + (inData[1] << 8) + inData[2]);
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,BigInteger,The following statement contains a magic number: if (leftOver == 1)                  data[dataLength - 1] = (uint)inData[0];              else if (leftOver == 2)                  data[dataLength - 1] = (uint)((inData[0] << 8) + inData[1]);              else if (leftOver == 3)                  data[dataLength - 1] = (uint)((inData[0] << 16) + (inData[1] << 8) + inData[2]);
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,BigInteger,The following statement contains a magic number: if (leftOver == 1)                  data[dataLength - 1] = (uint)inData[0];              else if (leftOver == 2)                  data[dataLength - 1] = (uint)((inData[0] << 8) + inData[1]);              else if (leftOver == 3)                  data[dataLength - 1] = (uint)((inData[0] << 16) + (inData[1] << 8) + inData[2]);
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,BigInteger,The following statement contains a magic number: if (leftOver == 1)                  data[dataLength - 1] = (uint)inData[0];              else if (leftOver == 2)                  data[dataLength - 1] = (uint)((inData[0] << 8) + inData[1]);              else if (leftOver == 3)                  data[dataLength - 1] = (uint)((inData[0] << 16) + (inData[1] << 8) + inData[2]);
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,randomBits,The following statement contains a magic number: int numBytes = (int)(((long)numBits + 7) / 8);
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,randomBits,The following statement contains a magic number: int numBytes = (int)(((long)numBits + 7) / 8);
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,randomBits,The following statement contains a magic number: if (numBytes > 0)              {                  for (int i = 0; i < numBytes; )                  {                      for (int r = rnd.Next()' n = Math.Min(numBytes - i' 4); n-- > 0; r >>= 8)                          randomBits[i++] = (byte)r;                  }                  int excessBits = 8 * numBytes - numBits;                  randomBits[0] &= (byte)((1 << (8 - excessBits)) - 1);              }
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,randomBits,The following statement contains a magic number: if (numBytes > 0)              {                  for (int i = 0; i < numBytes; )                  {                      for (int r = rnd.Next()' n = Math.Min(numBytes - i' 4); n-- > 0; r >>= 8)                          randomBits[i++] = (byte)r;                  }                  int excessBits = 8 * numBytes - numBits;                  randomBits[0] &= (byte)((1 << (8 - excessBits)) - 1);              }
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,randomBits,The following statement contains a magic number: if (numBytes > 0)              {                  for (int i = 0; i < numBytes; )                  {                      for (int r = rnd.Next()' n = Math.Min(numBytes - i' 4); n-- > 0; r >>= 8)                          randomBits[i++] = (byte)r;                  }                  int excessBits = 8 * numBytes - numBits;                  randomBits[0] &= (byte)((1 << (8 - excessBits)) - 1);              }
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,randomBits,The following statement contains a magic number: if (numBytes > 0)              {                  for (int i = 0; i < numBytes; )                  {                      for (int r = rnd.Next()' n = Math.Min(numBytes - i' 4); n-- > 0; r >>= 8)                          randomBits[i++] = (byte)r;                  }                  int excessBits = 8 * numBytes - numBits;                  randomBits[0] &= (byte)((1 << (8 - excessBits)) - 1);              }
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,shiftLeft,The following statement contains a magic number: int shiftAmount = 32;
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,shiftLeft,The following statement contains a magic number: for (int count = shiftVal; count > 0; )              {                  if (count < shiftAmount)                      shiftAmount = count;                    //Console.WriteLine("shiftAmount = {0}"' shiftAmount);                    ulong carry = 0;                  for (int i = 0; i < bufLen; i++)                  {                      ulong val = ((ulong)buffer[i]) << shiftAmount;                      val |= carry;                        buffer[i] = (uint)(val & 0xFFFFFFFF);                      carry = val >> 32;                  }                    if (carry != 0)                  {                      if (bufLen + 1 <= buffer.Length)                      {                          buffer[bufLen] = (uint)carry;                          bufLen++;                      }                  }                  count -= shiftAmount;              }
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,shiftRight,The following statement contains a magic number: int shiftAmount = 32;
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,shiftRight,The following statement contains a magic number: for (int count = shiftVal; count > 0; )              {                  if (count < shiftAmount)                  {                      shiftAmount = count;                      invShift = 32 - shiftAmount;                  }                    //Console.WriteLine("shiftAmount = {0}"' shiftAmount);                    ulong carry = 0;                  for (int i = bufLen - 1; i >= 0; i--)                  {                      ulong val = ((ulong)buffer[i]) >> shiftAmount;                      val |= carry;                        carry = ((ulong)buffer[i]) << invShift;                      buffer[i] = (uint)(val);                  }                    count -= shiftAmount;              }
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,multiByteDivide,The following statement contains a magic number: ulong secondDivisorByte = bi2.data[bi2.dataLength - 2];
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,multiByteDivide,The following statement contains a magic number: while (j > 0)              {                  ulong dividend = ((ulong)remainder[pos] << 32) + (ulong)remainder[pos - 1];                  //Console.WriteLine("dividend = {0}"' dividend);                    ulong q_hat = dividend / firstDivisorByte;                  ulong r_hat = dividend % firstDivisorByte;                    //Console.WriteLine("q_hat = {0:X}' r_hat = {1:X}"' q_hat' r_hat);                    bool done = false;                  while (!done)                  {                      done = true;                        if (q_hat == 0x100000000 ||                         (q_hat * secondDivisorByte) > ((r_hat << 32) + remainder[pos - 2]))                      {                          q_hat--;                          r_hat += firstDivisorByte;                            if (r_hat < 0x100000000)                              done = false;                      }                  }                    for (int h = 0; h < divisorLen; h++)                      dividendPart[h] = remainder[pos - h];                    BigInteger kk = new BigInteger(dividendPart);                  BigInteger ss = bi2 * (long)q_hat;                    //Console.WriteLine("ss before = " + ss);                  while (ss > kk)                  {                      q_hat--;                      ss -= bi2;                      //Console.WriteLine(ss);                  }                  BigInteger yy = kk - ss;                    //Console.WriteLine("ss = " + ss);                  //Console.WriteLine("kk = " + kk);                  //Console.WriteLine("yy = " + yy);                    for (int h = 0; h < divisorLen; h++)                      remainder[pos - h] = yy.data[bi2.dataLength - h];                    /*                  Console.WriteLine("dividend = ");                  for(int q = remainderLen - 1; q >= 0; q--)                          Console.Write("{0:x2}"' remainder[q]);                  Console.WriteLine("\n************ q_hat = {0:X}\n"' q_hat);                  */                    result[resultPos++] = (uint)q_hat;                    pos--;                  j--;              }
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,multiByteDivide,The following statement contains a magic number: while (j > 0)              {                  ulong dividend = ((ulong)remainder[pos] << 32) + (ulong)remainder[pos - 1];                  //Console.WriteLine("dividend = {0}"' dividend);                    ulong q_hat = dividend / firstDivisorByte;                  ulong r_hat = dividend % firstDivisorByte;                    //Console.WriteLine("q_hat = {0:X}' r_hat = {1:X}"' q_hat' r_hat);                    bool done = false;                  while (!done)                  {                      done = true;                        if (q_hat == 0x100000000 ||                         (q_hat * secondDivisorByte) > ((r_hat << 32) + remainder[pos - 2]))                      {                          q_hat--;                          r_hat += firstDivisorByte;                            if (r_hat < 0x100000000)                              done = false;                      }                  }                    for (int h = 0; h < divisorLen; h++)                      dividendPart[h] = remainder[pos - h];                    BigInteger kk = new BigInteger(dividendPart);                  BigInteger ss = bi2 * (long)q_hat;                    //Console.WriteLine("ss before = " + ss);                  while (ss > kk)                  {                      q_hat--;                      ss -= bi2;                      //Console.WriteLine(ss);                  }                  BigInteger yy = kk - ss;                    //Console.WriteLine("ss = " + ss);                  //Console.WriteLine("kk = " + kk);                  //Console.WriteLine("yy = " + yy);                    for (int h = 0; h < divisorLen; h++)                      remainder[pos - h] = yy.data[bi2.dataLength - h];                    /*                  Console.WriteLine("dividend = ");                  for(int q = remainderLen - 1; q >= 0; q--)                          Console.Write("{0:x2}"' remainder[q]);                  Console.WriteLine("\n************ q_hat = {0:X}\n"' q_hat);                  */                    result[resultPos++] = (uint)q_hat;                    pos--;                  j--;              }
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,multiByteDivide,The following statement contains a magic number: while (j > 0)              {                  ulong dividend = ((ulong)remainder[pos] << 32) + (ulong)remainder[pos - 1];                  //Console.WriteLine("dividend = {0}"' dividend);                    ulong q_hat = dividend / firstDivisorByte;                  ulong r_hat = dividend % firstDivisorByte;                    //Console.WriteLine("q_hat = {0:X}' r_hat = {1:X}"' q_hat' r_hat);                    bool done = false;                  while (!done)                  {                      done = true;                        if (q_hat == 0x100000000 ||                         (q_hat * secondDivisorByte) > ((r_hat << 32) + remainder[pos - 2]))                      {                          q_hat--;                          r_hat += firstDivisorByte;                            if (r_hat < 0x100000000)                              done = false;                      }                  }                    for (int h = 0; h < divisorLen; h++)                      dividendPart[h] = remainder[pos - h];                    BigInteger kk = new BigInteger(dividendPart);                  BigInteger ss = bi2 * (long)q_hat;                    //Console.WriteLine("ss before = " + ss);                  while (ss > kk)                  {                      q_hat--;                      ss -= bi2;                      //Console.WriteLine(ss);                  }                  BigInteger yy = kk - ss;                    //Console.WriteLine("ss = " + ss);                  //Console.WriteLine("kk = " + kk);                  //Console.WriteLine("yy = " + yy);                    for (int h = 0; h < divisorLen; h++)                      remainder[pos - h] = yy.data[bi2.dataLength - h];                    /*                  Console.WriteLine("dividend = ");                  for(int q = remainderLen - 1; q >= 0; q--)                          Console.Write("{0:x2}"' remainder[q]);                  Console.WriteLine("\n************ q_hat = {0:X}\n"' q_hat);                  */                    result[resultPos++] = (uint)q_hat;                    pos--;                  j--;              }
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,singleByteDivide,The following statement contains a magic number: while (pos >= 0)              {                  //Console.WriteLine(pos);                    dividend = ((ulong)outRemainder.data[pos + 1] << 32) + (ulong)outRemainder.data[pos];                  ulong quotient = dividend / divisor;                  result[resultPos++] = (uint)quotient;                    outRemainder.data[pos + 1] = 0;                  outRemainder.data[pos--] = (uint)(dividend % divisor);                  //Console.WriteLine(">>>> " + bi1);              }
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,ToString,The following statement contains a magic number: return ToString(10);
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,ToString,The following statement contains a magic number: if (radix < 2 || radix > 36)                  throw (new ArgumentException("Radix must be >= 2 and <= 36"));
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,ToString,The following statement contains a magic number: if (radix < 2 || radix > 36)                  throw (new ArgumentException("Radix must be >= 2 and <= 36"));
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,ToString,The following statement contains a magic number: if (a.dataLength == 1 && a.data[0] == 0)                  result = "0";              else              {                  while (a.dataLength > 1 || (a.dataLength == 1 && a.data[0] != 0))                  {                      singleByteDivide(a' biRadix' quotient' remainder);                        if (remainder.data[0] < 10)                          result = remainder.data[0] + result;                      else                          result = charSet[(int)remainder.data[0] - 10] + result;                        a = quotient;                  }                  if (negative)                      result = "-" + result;              }
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,ToString,The following statement contains a magic number: if (a.dataLength == 1 && a.data[0] == 0)                  result = "0";              else              {                  while (a.dataLength > 1 || (a.dataLength == 1 && a.data[0] != 0))                  {                      singleByteDivide(a' biRadix' quotient' remainder);                        if (remainder.data[0] < 10)                          result = remainder.data[0] + result;                      else                          result = charSet[(int)remainder.data[0] - 10] + result;                        a = quotient;                  }                  if (negative)                      result = "-" + result;              }
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,modPow,The following statement contains a magic number: for (int pos = 0; pos < exp.dataLength; pos++)              {                  uint mask = 0x01;                  //Console.WriteLine("pos = " + pos);                    for (int index = 0; index < 32; index++)                  {                      if ((exp.data[pos] & mask) != 0)                          resultNum = BarrettReduction(resultNum * tempNum' n' constant);                        mask <<= 1;                        tempNum = BarrettReduction(tempNum * tempNum' n' constant);                          if (tempNum.dataLength == 1 && tempNum.data[0] == 1)                      {                          // NuoDB CHANGED!!! The original code was returning -resultNum' but the Java BigInteger adds the negative remainder to the modulus instead                          if (thisNegative && (exp.data[0] & 0x1) != 0)    //odd exp                              return n+resultNum;                          return resultNum;                      }                      count++;                      if (count == totalBits)                          break;                  }              }
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,BarrettReduction,The following statement contains a magic number: for (int i = 0; i < q3.dataLength; i++)              {                  if (q3.data[i] == 0) continue;                    ulong mcarry = 0;                  int t = i;                  for (int j = 0; j < n.dataLength && t < kPlusOne; j++' t++)                  {                      // t = i + j                      ulong val = ((ulong)q3.data[i] * (ulong)n.data[j]) +                                   (ulong)r2.data[t] + mcarry;                        r2.data[t] = (uint)(val & 0xFFFFFFFF);                      mcarry = (val >> 32);                  }                    if (t < kPlusOne)                      r2.data[t] = (uint)mcarry;              }
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,bitCount,The following statement contains a magic number: int bits = 32;
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,bitCount,The following statement contains a magic number: bits += ((dataLength - 1) << 5);
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,ToByteArray,The following statement contains a magic number: int numBytes = numBits >> 3;
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,ToByteArray,The following statement contains a magic number: if ((tempVal = (val >> 24)) != 0)                  result[pos++] = (byte)(tempVal & 0xFF);
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,ToByteArray,The following statement contains a magic number: if ((tempVal = (val >> 16)) != 0)                  result[pos++] = (byte)(tempVal & 0xFF);
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,ToByteArray,The following statement contains a magic number: if ((tempVal = (val >> 8)) != 0)                  result[pos++] = (byte)(tempVal & 0xFF);
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,ToByteArray,The following statement contains a magic number: for (int i = dataLength - 2; i >= 0; i--' pos += 4)              {                  val = data[i];                  result[pos + 3] = (byte)(val & 0xFF);                  val >>= 8;                  result[pos + 2] = (byte)(val & 0xFF);                  val >>= 8;                  result[pos + 1] = (byte)(val & 0xFF);                  val >>= 8;                  result[pos] = (byte)(val & 0xFF);              }
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,ToByteArray,The following statement contains a magic number: for (int i = dataLength - 2; i >= 0; i--' pos += 4)              {                  val = data[i];                  result[pos + 3] = (byte)(val & 0xFF);                  val >>= 8;                  result[pos + 2] = (byte)(val & 0xFF);                  val >>= 8;                  result[pos + 1] = (byte)(val & 0xFF);                  val >>= 8;                  result[pos] = (byte)(val & 0xFF);              }
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,ToByteArray,The following statement contains a magic number: for (int i = dataLength - 2; i >= 0; i--' pos += 4)              {                  val = data[i];                  result[pos + 3] = (byte)(val & 0xFF);                  val >>= 8;                  result[pos + 2] = (byte)(val & 0xFF);                  val >>= 8;                  result[pos + 1] = (byte)(val & 0xFF);                  val >>= 8;                  result[pos] = (byte)(val & 0xFF);              }
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,ToByteArray,The following statement contains a magic number: for (int i = dataLength - 2; i >= 0; i--' pos += 4)              {                  val = data[i];                  result[pos + 3] = (byte)(val & 0xFF);                  val >>= 8;                  result[pos + 2] = (byte)(val & 0xFF);                  val >>= 8;                  result[pos + 1] = (byte)(val & 0xFF);                  val >>= 8;                  result[pos] = (byte)(val & 0xFF);              }
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,ToByteArray,The following statement contains a magic number: for (int i = dataLength - 2; i >= 0; i--' pos += 4)              {                  val = data[i];                  result[pos + 3] = (byte)(val & 0xFF);                  val >>= 8;                  result[pos + 2] = (byte)(val & 0xFF);                  val >>= 8;                  result[pos + 1] = (byte)(val & 0xFF);                  val >>= 8;                  result[pos] = (byte)(val & 0xFF);              }
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,ToByteArray,The following statement contains a magic number: for (int i = dataLength - 2; i >= 0; i--' pos += 4)              {                  val = data[i];                  result[pos + 3] = (byte)(val & 0xFF);                  val >>= 8;                  result[pos + 2] = (byte)(val & 0xFF);                  val >>= 8;                  result[pos + 1] = (byte)(val & 0xFF);                  val >>= 8;                  result[pos] = (byte)(val & 0xFF);              }
Magic Number,NuoDb.Data.Client.Security,BigInteger,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\BigInteger.cs,ToByteArray,The following statement contains a magic number: for (int i = dataLength - 2; i >= 0; i--' pos += 4)              {                  val = data[i];                  result[pos + 3] = (byte)(val & 0xFF);                  val >>= 8;                  result[pos + 2] = (byte)(val & 0xFF);                  val >>= 8;                  result[pos + 1] = (byte)(val & 0xFF);                  val >>= 8;                  result[pos] = (byte)(val & 0xFF);              }
Magic Number,NuoDb.Data.Client.Security,RemoteGroup,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\RemoteGroup.cs,RemoteGroup,The following statement contains a magic number: generator = new BigInteger(2);
Magic Number,NuoDb.Data.Client.Security,RemotePassword,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\RemotePassword.cs,RemotePassword,The following statement contains a magic number: hexDigits = new byte[256];
Magic Number,NuoDb.Data.Client.Security,RemotePassword,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\RemotePassword.cs,RemotePassword,The following statement contains a magic number: for (int n = 0; n < 10; ++n)  			{  				hexDigits['0' + n] = (byte) n;  			}
Magic Number,NuoDb.Data.Client.Security,RemotePassword,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\RemotePassword.cs,RemotePassword,The following statement contains a magic number: for (sbyte n = 0; n < 6; ++n)  			{  				hexDigits['a' + n] = (byte)(10 + n);  				hexDigits['A' + n] = (byte)(10 + n);  			}
Magic Number,NuoDb.Data.Client.Security,RemotePassword,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\RemotePassword.cs,RemotePassword,The following statement contains a magic number: for (sbyte n = 0; n < 6; ++n)  			{  				hexDigits['a' + n] = (byte)(10 + n);  				hexDigits['A' + n] = (byte)(10 + n);  			}
Magic Number,NuoDb.Data.Client.Security,RemotePassword,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\RemotePassword.cs,RemotePassword,The following statement contains a magic number: for (sbyte n = 0; n < 6; ++n)  			{  				hexDigits['a' + n] = (byte)(10 + n);  				hexDigits['A' + n] = (byte)(10 + n);  			}
Magic Number,NuoDb.Data.Client.Security,RemotePassword,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\RemotePassword.cs,RemotePassword,The following statement contains a magic number: RemoteGroup group = RemoteGroup.getGroup(1024);
Magic Number,NuoDb.Data.Client.Security,RemotePassword,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\RemotePassword.cs,getBytes,The following statement contains a magic number: int length = hex.Length / 2;
Magic Number,NuoDb.Data.Client.Security,RemotePassword,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\RemotePassword.cs,getBytes,The following statement contains a magic number: for (int n = 0' c = 0; n < length; ++n' c += 2)  			{  				bytes[n] = (byte)((hexDigits[hex[c]] << 4) | hexDigits[hex[c + 1]]);  			}
Magic Number,NuoDb.Data.Client.Security,RemotePassword,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\RemotePassword.cs,getBytes,The following statement contains a magic number: for (int n = 0' c = 0; n < length; ++n' c += 2)  			{  				bytes[n] = (byte)((hexDigits[hex[c]] << 4) | hexDigits[hex[c + 1]]);  			}
Magic Number,NuoDb.Data.Client.Security,RemotePassword,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\RemotePassword.cs,getHex,The following statement contains a magic number: char[] hex = new char[length * 2];
Magic Number,NuoDb.Data.Client.Security,RemotePassword,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\RemotePassword.cs,getHex,The following statement contains a magic number: for (int c = 0; n < rep.Length; ++n)  			{  				int b = rep[n] & 0xff;  				int high = b >> 4;  				int low = b & 0xf;  				hex[c++] = (char)((high < 10) ? '0' + high : 'A' + high - 10);  				hex[c++] = (char)((low < 10) ? '0' + low : 'A' + low - 10);  			}
Magic Number,NuoDb.Data.Client.Security,RemotePassword,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\RemotePassword.cs,getHex,The following statement contains a magic number: for (int c = 0; n < rep.Length; ++n)  			{  				int b = rep[n] & 0xff;  				int high = b >> 4;  				int low = b & 0xf;  				hex[c++] = (char)((high < 10) ? '0' + high : 'A' + high - 10);  				hex[c++] = (char)((low < 10) ? '0' + low : 'A' + low - 10);  			}
Magic Number,NuoDb.Data.Client.Security,RemotePassword,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\RemotePassword.cs,getHex,The following statement contains a magic number: for (int c = 0; n < rep.Length; ++n)  			{  				int b = rep[n] & 0xff;  				int high = b >> 4;  				int low = b & 0xf;  				hex[c++] = (char)((high < 10) ? '0' + high : 'A' + high - 10);  				hex[c++] = (char)((low < 10) ? '0' + low : 'A' + low - 10);  			}
Magic Number,NuoDb.Data.Client.Security,RemotePassword,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\RemotePassword.cs,getHex,The following statement contains a magic number: for (int c = 0; n < rep.Length; ++n)  			{  				int b = rep[n] & 0xff;  				int high = b >> 4;  				int low = b & 0xf;  				hex[c++] = (char)((high < 10) ? '0' + high : 'A' + high - 10);  				hex[c++] = (char)((low < 10) ? '0' + low : 'A' + low - 10);  			}
Magic Number,NuoDb.Data.Client.Security,RemotePassword,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\RemotePassword.cs,getHex,The following statement contains a magic number: for (int c = 0; n < rep.Length; ++n)  			{  				int b = rep[n] & 0xff;  				int high = b >> 4;  				int low = b & 0xf;  				hex[c++] = (char)((high < 10) ? '0' + high : 'A' + high - 10);  				hex[c++] = (char)((low < 10) ? '0' + low : 'A' + low - 10);  			}
Magic Number,NuoDb.Data.Client.Security,RemotePassword,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\RemotePassword.cs,genClientKey,The following statement contains a magic number: clientPrivateKey = new BigInteger(256' random);
Magic Number,NuoDb.Data.Client.Security,RemotePassword,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\RemotePassword.cs,genServerKey,The following statement contains a magic number: return genServerKey(new BigInteger(256' random)' verifier);
Magic Number,NuoDb.Data.Client.Security,RemotePassword,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\RemotePassword.cs,genSalt,The following statement contains a magic number: BigInteger n = new BigInteger(256' random);
Magic Number,NuoDb.Data.Client.Security,CipherRC4,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\CypherRC4.cs,setKey,The following statement contains a magic number: state = new byte[256];
Magic Number,NuoDb.Data.Client.Security,CipherRC4,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\CypherRC4.cs,setKey,The following statement contains a magic number: for (int k1 = 0' k2 = 0; k1 < 256; ++k1)              {                  k2 = (k2 + key[(k1 + offset) % length] + state[k1]) & 0xff;                  byte temp = state[k1];                  state[k1] = state[k2];                  state[k2] = temp;              }
Magic Number,NuoDb.Data.Client.Security,CipherRC4,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Security\CypherRC4.cs,write,The following statement contains a magic number: if (buffer == null || buffer.Length < length)              {                  buffer = new byte[length + 100];              }
Magic Number,NuoDb.Data.Client.Util,Op,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\Op.cs,getInt,The following statement contains a magic number: for (int n = 0; n < length; ++n)  			{  				char c = @string[n];    				if (c >= '0' && c <= '9')  				{  					value = value * 10 + c - '0';  				}  				else if (c == '-')  				{  					negative = true;  				}  			}
Magic Number,NuoDb.Data.Client.Util,Op,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\Op.cs,obfuscate,The following statement contains a magic number: StringBuilder builder = new StringBuilder(512);
Magic Number,NuoDb.Data.Client.Util,Op,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\Op.cs,obfuscate,The following statement contains a magic number: for (int n = 0; n < args.Length; ++n)  			{  				string @string = args [n];  				int l = @string.Length;    				for (int i = 0; i < l; ++i)  				{  					char c = @string[i];  					if (c == '@')  					{  						builder.Append("&#");  						builder.Append((char)('0' + (c / 100) % 10));  						builder.Append((char)('0' + (c / 10) % 10));  						builder.Append((char)('0' + c % 10));  						builder.Append(';');  					}  					else  					{  						builder.Append(c);  					}  				}  			}
Magic Number,NuoDb.Data.Client.Util,Op,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\Op.cs,obfuscate,The following statement contains a magic number: for (int n = 0; n < args.Length; ++n)  			{  				string @string = args [n];  				int l = @string.Length;    				for (int i = 0; i < l; ++i)  				{  					char c = @string[i];  					if (c == '@')  					{  						builder.Append("&#");  						builder.Append((char)('0' + (c / 100) % 10));  						builder.Append((char)('0' + (c / 10) % 10));  						builder.Append((char)('0' + c % 10));  						builder.Append(';');  					}  					else  					{  						builder.Append(c);  					}  				}  			}
Magic Number,NuoDb.Data.Client.Util,Op,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\Op.cs,obfuscate,The following statement contains a magic number: for (int n = 0; n < args.Length; ++n)  			{  				string @string = args [n];  				int l = @string.Length;    				for (int i = 0; i < l; ++i)  				{  					char c = @string[i];  					if (c == '@')  					{  						builder.Append("&#");  						builder.Append((char)('0' + (c / 100) % 10));  						builder.Append((char)('0' + (c / 10) % 10));  						builder.Append((char)('0' + c % 10));  						builder.Append(';');  					}  					else  					{  						builder.Append(c);  					}  				}  			}
Magic Number,NuoDb.Data.Client.Util,Op,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\Op.cs,obfuscate,The following statement contains a magic number: for (int n = 0; n < args.Length; ++n)  			{  				string @string = args [n];  				int l = @string.Length;    				for (int i = 0; i < l; ++i)  				{  					char c = @string[i];  					if (c == '@')  					{  						builder.Append("&#");  						builder.Append((char)('0' + (c / 100) % 10));  						builder.Append((char)('0' + (c / 10) % 10));  						builder.Append((char)('0' + c % 10));  						builder.Append(';');  					}  					else  					{  						builder.Append(c);  					}  				}  			}
Magic Number,NuoDb.Data.Client.Util,Op,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\Op.cs,obfuscate,The following statement contains a magic number: for (int n = 0; n < args.Length; ++n)  			{  				string @string = args [n];  				int l = @string.Length;    				for (int i = 0; i < l; ++i)  				{  					char c = @string[i];  					if (c == '@')  					{  						builder.Append("&#");  						builder.Append((char)('0' + (c / 100) % 10));  						builder.Append((char)('0' + (c / 10) % 10));  						builder.Append((char)('0' + c % 10));  						builder.Append(';');  					}  					else  					{  						builder.Append(c);  					}  				}  			}
Magic Number,NuoDb.Data.Client.Util,Op,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\Op.cs,getLong,The following statement contains a magic number: for (int n = 0; n < length; ++n)  			{  				char c = @string[n];    				if (c >= '0' && c <= '9')  				{  					value = value * 10 + c - '0';  				}  				else if (c == '-')  				{  					negative = true;  				}  			}
Magic Number,NuoDb.Data.Client.Util,Op,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\Op.cs,getTimeNoTZN,The following statement contains a magic number: int[] values = new int[3];
Magic Number,NuoDb.Data.Client.Util,Op,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\Op.cs,getTimeNoTZN,The following statement contains a magic number: for (int length = @string.Length' n = 0; n < length; ++n)  			{  				char c = @string[n];    				if (c >= '0' && c <= '9')  				{  					values[segment] = values[segment] * 10 + c - '0';  				}  				else if (c == ':')  				{  					++segment;  				}  			}
Magic Number,NuoDb.Data.Client.Util,Op,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\Op.cs,getTimeNoTZN,The following statement contains a magic number: return values[0] * 60 * 60 + values[1] * 60 + values[2];
Magic Number,NuoDb.Data.Client.Util,Op,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\Op.cs,getTimeNoTZN,The following statement contains a magic number: return values[0] * 60 * 60 + values[1] * 60 + values[2];
Magic Number,NuoDb.Data.Client.Util,Op,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\Op.cs,getTimeNoTZN,The following statement contains a magic number: return values[0] * 60 * 60 + values[1] * 60 + values[2];
Magic Number,NuoDb.Data.Client.Util,Op,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\Op.cs,getTimeNoTZN,The following statement contains a magic number: return values[0] * 60 * 60 + values[1] * 60 + values[2];
Magic Number,NuoDb.Data.Client.Util,Op,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\Op.cs,timeToStringNoTZN,The following statement contains a magic number: int hh = time / (60 * 60);
Magic Number,NuoDb.Data.Client.Util,Op,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\Op.cs,timeToStringNoTZN,The following statement contains a magic number: int hh = time / (60 * 60);
Magic Number,NuoDb.Data.Client.Util,Op,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\Op.cs,timeToStringNoTZN,The following statement contains a magic number: int mm = (time % (60 * 60)) / 60;
Magic Number,NuoDb.Data.Client.Util,Op,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\Op.cs,timeToStringNoTZN,The following statement contains a magic number: int mm = (time % (60 * 60)) / 60;
Magic Number,NuoDb.Data.Client.Util,Op,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\Op.cs,timeToStringNoTZN,The following statement contains a magic number: int mm = (time % (60 * 60)) / 60;
Magic Number,NuoDb.Data.Client.Util,Op,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\Op.cs,timeToStringNoTZN,The following statement contains a magic number: int ss = (time % (60 * 60)) % 60;
Magic Number,NuoDb.Data.Client.Util,Op,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\Op.cs,timeToStringNoTZN,The following statement contains a magic number: int ss = (time % (60 * 60)) % 60;
Magic Number,NuoDb.Data.Client.Util,Op,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\Op.cs,timeToStringNoTZN,The following statement contains a magic number: int ss = (time % (60 * 60)) % 60;
Magic Number,NuoDb.Data.Client.Util,Op,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\Op.cs,timeToStringNoTZN,The following statement contains a magic number: char[] packed = new char[8];
Magic Number,NuoDb.Data.Client.Util,Op,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\Op.cs,timeToStringNoTZN,The following statement contains a magic number: packed[0] = (char)('0' + (hh - (hh % 10)) / 10);
Magic Number,NuoDb.Data.Client.Util,Op,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\Op.cs,timeToStringNoTZN,The following statement contains a magic number: packed[0] = (char)('0' + (hh - (hh % 10)) / 10);
Magic Number,NuoDb.Data.Client.Util,Op,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\Op.cs,timeToStringNoTZN,The following statement contains a magic number: packed[1] = (char)('0' + (hh % 10));
Magic Number,NuoDb.Data.Client.Util,Op,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\Op.cs,timeToStringNoTZN,The following statement contains a magic number: packed[2] = ':';
Magic Number,NuoDb.Data.Client.Util,Op,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\Op.cs,timeToStringNoTZN,The following statement contains a magic number: packed[3] = (char)('0' + (mm - (mm % 10)) / 10);
Magic Number,NuoDb.Data.Client.Util,Op,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\Op.cs,timeToStringNoTZN,The following statement contains a magic number: packed[3] = (char)('0' + (mm - (mm % 10)) / 10);
Magic Number,NuoDb.Data.Client.Util,Op,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\Op.cs,timeToStringNoTZN,The following statement contains a magic number: packed[3] = (char)('0' + (mm - (mm % 10)) / 10);
Magic Number,NuoDb.Data.Client.Util,Op,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\Op.cs,timeToStringNoTZN,The following statement contains a magic number: packed[4] = (char)('0' + (mm % 10));
Magic Number,NuoDb.Data.Client.Util,Op,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\Op.cs,timeToStringNoTZN,The following statement contains a magic number: packed[4] = (char)('0' + (mm % 10));
Magic Number,NuoDb.Data.Client.Util,Op,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\Op.cs,timeToStringNoTZN,The following statement contains a magic number: packed[5] = ':';
Magic Number,NuoDb.Data.Client.Util,Op,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\Op.cs,timeToStringNoTZN,The following statement contains a magic number: packed[6] = (char)('0' + (ss - (ss % 10)) / 10);
Magic Number,NuoDb.Data.Client.Util,Op,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\Op.cs,timeToStringNoTZN,The following statement contains a magic number: packed[6] = (char)('0' + (ss - (ss % 10)) / 10);
Magic Number,NuoDb.Data.Client.Util,Op,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\Op.cs,timeToStringNoTZN,The following statement contains a magic number: packed[6] = (char)('0' + (ss - (ss % 10)) / 10);
Magic Number,NuoDb.Data.Client.Util,Op,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\Op.cs,timeToStringNoTZN,The following statement contains a magic number: packed[7] = (char)('0' + (ss % 10));
Magic Number,NuoDb.Data.Client.Util,Op,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\Op.cs,timeToStringNoTZN,The following statement contains a magic number: packed[7] = (char)('0' + (ss % 10));
Magic Number,NuoDb.Data.Client.Util,StringUtils,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Util\StringUtils.cs,randomString,The following statement contains a magic number: for (int i = 0; i < maxLength; i++)  			{  				char c = (char)('a' + r.Next(26));  				builder.Append(c);  			}
Magic Number,NuoDb.Data.Client.Xml,Doc,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Xml\Doc.cs,processEscapes,The following statement contains a magic number: for (int n = from; n < to; ++n)  			{  				char c = document[n];    				if (c == '&')  				{  					if (checkString(n' "&lt;"))  					{  						builder.Append('<');  					}  					else if (checkString(n' "&gt;"))  					{  						builder.Append('>');  					}  					else if (checkString(n' "&quote;"))  					{  						builder.Append('"');  					}  					else if (checkString(n' "&quot;"))  					{  						builder.Append('"');  					}  					else if (checkString(n' "&apos;"))  					{  						builder.Append('\'');  					}  					else if (checkString(n' "&amp;"))  					{  						builder.Append('&');  					}  					else if (checkString(n' "&nbsp;"))  					{  						builder.Append(' ');  					}  					else  					{  						print("Bad excape: "' n' 50);  						throw new XmlException("invalid escape seqeuence");  					}  					while (document[n] != ';')  					{  						++n;  					}  				}  				else if (c == '<')  				{  					if (checkString(n' CDATA))  					{  						n += CDATA.Length;  						//int start = n;  						for (; !((c = document[n]) == ']' && checkString(n' endCDATA)); ++n)  						{  							builder.Append(c);  						}  						//System.out.println ("CDATA: " + document.substring(start' n));  						n += endCDATA.Length - 1;  					}  					else if (checkString(n' COMMENT))  					{  						n += commentEnd(n + COMMENT.Length) - 1;  					}  				}  				else  				{  					builder.Append(c);  				}  			}
Magic Number,NuoDb.Data.Client.Xml,Doc,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Xml\Doc.cs,skipWhite,The following statement contains a magic number: for (bool comment = false; offset < length; ++offset)  			{  				char c = document[offset];    				if (comment)  				{  					if (c == '-' && checkString(offset' "-->"))  					{  						comment = false;  						offset += 2;  					}  				}  				else  				{  					if (c == '<' && checkString(offset' "<!--"))  					{  						//Debug.println ("skipWhite: found comment");  						comment = true;  						offset += 3;  					}    					if (c != ' ' && c != '\t' && c != '\n' && c != '\r')  					{  						break;  					}  				}  			}
Magic Number,NuoDb.Data.Client.Xml,Doc,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Xml\Doc.cs,skipWhite,The following statement contains a magic number: for (bool comment = false; offset < length; ++offset)  			{  				char c = document[offset];    				if (comment)  				{  					if (c == '-' && checkString(offset' "-->"))  					{  						comment = false;  						offset += 2;  					}  				}  				else  				{  					if (c == '<' && checkString(offset' "<!--"))  					{  						//Debug.println ("skipWhite: found comment");  						comment = true;  						offset += 3;  					}    					if (c != ' ' && c != '\t' && c != '\n' && c != '\r')  					{  						break;  					}  				}  			}
Magic Number,NuoDb.Data.Client.Xml,Doc,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Xml\Doc.cs,checkComment,The following statement contains a magic number: offset += 4;
Magic Number,NuoDb.Data.Client.Xml,Doc,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Xml\Doc.cs,skipComment,The following statement contains a magic number: for (; offset < length; ++offset)  			{  				char c = document[offset];  				if (c == '-' && checkString(offset' "-->"))  				{  					offset += 2;  					break;  				}  			}
Magic Number,NuoDb.Data.Client.Xml,Tag,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Xml\Tag.cs,insert,The following statement contains a magic number: for (Tag child = children_Renamed; child != null; prior = child' child = child.sibling)  			{  				if (sequence < child.getIntAttribute(attribute' 1000000))  				{  					break;  				}  			}
Magic Number,NuoDb.Data.Client.Xml,Tag,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Xml\Tag.cs,parseChildren,The following statement contains a magic number: for (;;)  			{  				Tag item;    				/// <summary>  				///*  				/// if (doc.checkComment())  				/// continue;  				/// **  				/// </summary>    				if (!doc.match('<'))  				{  					doc.print("Tag.parseChildren: "' 30);  					throw new XmlException("invalid xml document -- malformed");  				}    				string @string = doc.Token;    				if (@string.Length == 0)  				{  					//TODO Line numbers in the exception would be good here!  					throw new XmlException("invalid xml document - malformed \"<" + doc.parseText() + "\"");  				}    				if (@string[0] == '/')  				{  					if (!doc.match('>'))  					{  						throw new XmlException("invalid xml ending tag");  					}    					int l = name.Length;    					if (@string.Length != l + 1)  					{  						throw new XmlException("invalid xml document -- unmatched tag \"" + name + "\"");  					}    					for (int n = 0; n < l; ++n)  					{  						if (name[n] != @string[n + 1])  						{  							throw new XmlException("invalid xml document -- unmatched tag \"" + name + "\"");  						}  					}    					return;  				}    				item = new Tag(@string' doc);    				if (child == null)  				{  					children_Renamed = item;  				}  				else  				{  					child.sibling = item;  				}    				child = item;  			}
Magic Number,NuoDb.Data.Client.Xml,Tag,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Xml\Tag.cs,gen,The following statement contains a magic number: int attrIndent = level * 2 + 1 + buffer.Length - start;
Magic Number,NuoDb.Data.Client.Xml,Tag,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Xml\Tag.cs,gen,The following statement contains a magic number: int attrLimit = buffer.Length + 60;
Magic Number,NuoDb.Data.Client.Xml,Tag,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Xml\Tag.cs,gen,The following statement contains a magic number: for (Attribute attribute = attributes; attribute != null; attribute = attribute.sibling)  			{  				int len = buffer.Length;    				if (len < attrLimit)  				{  					buffer.Append(" ");  				}  				else  				{  					buffer.AppendLine();  					indent(attrIndent' buffer);  					attrLimit = len + 60;  				}    				buffer.Append(attribute.Name);  				buffer.Append("=\"");  				putQuotedText(attribute.Value' buffer);  				buffer.Append("\"");  			}
Magic Number,NuoDb.Data.Client.Net,CryptoInputStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Net\CryptoInputStream.cs,CryptoInputStream,The following statement contains a magic number: stream = new BufferedStream(inputStream' 8192);
Magic Number,NuoDb.Data.Client.Net,CryptoInputStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Net\CryptoInputStream.cs,CryptoInputStream,The following statement contains a magic number: lengthBuffer = new byte[4];
Magic Number,NuoDb.Data.Client.Net,CryptoInputStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Net\CryptoInputStream.cs,CryptoInputStream,The following statement contains a magic number: stream = new BufferedStream(inputStream' 8192);
Magic Number,NuoDb.Data.Client.Net,CryptoInputStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Net\CryptoInputStream.cs,CryptoInputStream,The following statement contains a magic number: lengthBuffer = new byte[4];
Magic Number,NuoDb.Data.Client.Net,CryptoInputStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Net\CryptoInputStream.cs,readLength,The following statement contains a magic number: int remaining = 4;
Magic Number,NuoDb.Data.Client.Net,CryptoInputStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Net\CryptoInputStream.cs,readLength,The following statement contains a magic number: while (remaining > 0)              {                  int lengthRead = stream.Read(lengthBuffer' 4 - remaining' remaining);                    if (lengthRead == 0)                  {                      throw new IOException("End of stream reached");                  }                    remaining -= lengthRead;              }
Magic Number,NuoDb.Data.Client.Net,CryptoInputStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Net\CryptoInputStream.cs,readLength,The following statement contains a magic number: for (int n = 0; n < 4; ++n)              {                  length = (length << 8) | (lengthBuffer[n] & 0xff);              }
Magic Number,NuoDb.Data.Client.Net,CryptoInputStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Net\CryptoInputStream.cs,readLength,The following statement contains a magic number: for (int n = 0; n < 4; ++n)              {                  length = (length << 8) | (lengthBuffer[n] & 0xff);              }
Magic Number,NuoDb.Data.Client.Net,CryptoOutputStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Net\CryptoOutputStream.cs,CryptoOutputStream,The following statement contains a magic number: stream = new BufferedStream(outputStream' 8192);
Magic Number,NuoDb.Data.Client.Net,CryptoOutputStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Net\CryptoOutputStream.cs,CryptoOutputStream,The following statement contains a magic number: stream = new BufferedStream(outputStream' 8192);
Magic Number,NuoDb.Data.Client.Net,CryptoOutputStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Net\CryptoOutputStream.cs,writeLength,The following statement contains a magic number: if (lengthBuffer == null)  			{  				lengthBuffer = new byte[4];  			}
Magic Number,NuoDb.Data.Client.Net,CryptoOutputStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Net\CryptoOutputStream.cs,writeLength,The following statement contains a magic number: for (int n = 3' length = messageLength; n >= 0; --n' length >>= 8)  			{  				lengthBuffer[n] = (byte) length;  			}
Magic Number,NuoDb.Data.Client.Net,CryptoOutputStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Net\CryptoOutputStream.cs,writeLength,The following statement contains a magic number: for (int n = 3' length = messageLength; n >= 0; --n' length >>= 8)  			{  				lengthBuffer[n] = (byte) length;  			}
Magic Number,NuoDb.Data.Client.Net,CryptoOutputStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\Net\CryptoOutputStream.cs,writeLength,The following statement contains a magic number: stream.Write(lengthBuffer' 0' 4);
Duplicate Code,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The method contains a code clone-set at the following line numbers (starting from the method definition): ((409' 442)' (503' 536))
Duplicate Code,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The method contains a code clone-set at the following line numbers (starting from the method definition): ((563' 591)' (614' 642))
Missing Default,NuoDb.Data.Client,NuoDbCommand,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbCommand.cs,Prepare,The following switch statement is missing a default case: switch (direction)                      {                          case 0: newParams[i].Direction = ParameterDirection.Input; break;                          case 1: newParams[i].Direction = ParameterDirection.InputOutput; break;                          case 2: newParams[i].Direction = ParameterDirection.Output; break;                      }
Missing Default,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,GetSchemaHelper,The following switch statement is missing a default case: switch (reader.GetFieldValue<int>("TYPE"))                                  {                                      case 0:                                          row["INDEX_TYPE"] = "Primary";                                          break;                                      case 1:                                          row["INDEX_TYPE"] = "Unique";                                          break;                                      case 2:                                          row["INDEX_TYPE"] = "Secondary";                                          break;                                      case 3:                                          row["INDEX_TYPE"] = "Foreign Key";                                          break;                                  }
Missing Default,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapDbTypeToNetType,The following switch statement is missing a default case: switch ((DbType)dbType)              {                  case DbType.Boolean: return "System.Boolean";                  case DbType.Int16: return "System.Int16";                  case DbType.Int32: return "System.Int32";                  case DbType.Int64: return "System.Int64";                  case DbType.Single: return "System.Single";                  case DbType.Double: return "System.Double";                  case DbType.Decimal: return "System.Decimal";                  case DbType.Byte: return "System.Byte";                  case DbType.String: return "System.String";                  case DbType.Date:                  case DbType.Time:                  case DbType.DateTime: return "System.DateTime";                  case DbType.Binary:                  case DbType.Object: return "System.Object";              }
Missing Default,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapJavaSqlToDbType,The following switch statement is missing a default case: switch (jSQL)              {                  case -7: //BIT                      return DbType.Boolean;                  case -6: //TINYINT                  case 5: //SMALLINT                  case 4: //INTEGER                      return DbType.Int32;                  case -5: //BIGINT                      return DbType.Int64;                  case 6: //FLOAT                  case 7: //REAL                      return DbType.Single;                  case 8: //DOUBLE                      return DbType.Double;                  case 2: //NUMERIC                  case 3: //DECIMAL                      return DbType.Decimal;                  case 1: //CHAR                  case 12: //VARCHAR                  case -1: //LONGVARCHAR                      return DbType.String;                  case 91: //DATE                      return DbType.Date;                  case 92: //TIME                      return DbType.Time;                  case 93: //TIMESTAMP                      return DbType.DateTime;                  case -2: //BINARY                  case -3: //VARBINARY                  case -4: //LONGVARBINARY                      return DbType.Binary;                  case 0: //NULL                  case 1111: //OTHER                  case 2000: //JAVA_OBJECT                  case 2001: //DISTINCT                  case 2002: //STRUCT                  case 2003: //ARRAY                  case 2004: //BLOB                  case 2005: //CLOB                  case 2006: //REF                  case 70: //DATALINK                      return DbType.Object;                  case 16: //BOOLEAN                      return DbType.Boolean;                  //------------------------- JDBC 4.0 -----------------------------------                  case -15: //NCHAR                  case -9: //NVARCHAR                   case -16: //LONGNVARCHAR                  case 2011: //NCLOB                      return DbType.String;                  case 2009: //SQLXML                       return DbType.Xml;                  case -8: //ROWID                      return DbType.Object;              }
Missing Default,NuoDb.Data.Client,NuoDbConnectionInternal,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\NuoDbConnectionInternal.cs,mapDbTypeToJavaSql,The following switch statement is missing a default case: switch (dbType)              {                  case DbType.Boolean:                      return 16; //BOOLEAN                  case DbType.Int32:                      return 4; //INTEGER                  case DbType.Int64:                      return -5; //BIGINT                  case DbType.Single:                      return 7; //REAL                  case DbType.Double:                      return 8; //DOUBLE                  case DbType.Decimal:                      return 3; //DECIMAL                  case DbType.Xml:                  case DbType.String:                      return 12; //VARCHAR                  case DbType.Date:                      return 91; //DATE                  case DbType.Time:                      return 92; //TIME                  case DbType.DateTime:                      return 93; //TIMESTAMP                  case DbType.Binary:                      return -3; //VARBINARY                  case DbType.Object:                      return 2004; //BLOB              }
Missing Default,NuoDb.Data.Client,EncodedDataStream,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EncodedDataStream.cs,getValue,The following switch statement is missing a default case: switch (type)              {                  case edsTypeNull:                      return new ValueNull();                    case edsTypeUtf8:                      return new ValueString(@string);                    case edsTypeOpaque:                      return new ValueBytes(bytes);                    case edsTypeScaled:                      return new ValueNumber(ScaleDecimal(integer64' scale));                    case edsTypeInt32:                      return new ValueInt(integer32' 0);                    case edsTypeInt64:                      return new ValueLong(integer64' 0);                    case edsTypeBoolean:                      return new ValueBoolean(@bool);                    case edsTypeDouble:                      return new ValueDouble(dbl);                    case edsTypeScaledTime:                      {                          long inNanos = Value.reScale(integer64' scale' NANOSECONDS_SCALE);                          DateTime utcTime = new DateTime(baseDate.Ticks + inNanos / NANOSECONDS_PER_TICK' DateTimeKind.Utc);                          DateTime localTime = TimeZoneInfo.ConvertTimeFromUtc(utcTime' sqlContext.TimeZone);                          return new ValueTime(localTime);                      }                    case edsTypeTime:                      {                          DateTime utcTime = new DateTime(baseDate.Ticks + integer64 * TimeSpan.TicksPerMillisecond' DateTimeKind.Utc);                          DateTime localTime = TimeZoneInfo.ConvertTimeFromUtc(utcTime' sqlContext.TimeZone);                          return new ValueTime(localTime);                      }                    case edsTypeScaledDate:                      {                          long inSeconds = Value.reScale(integer64' scale' SECONDS_SCALE);                          DateTime utcTime = new DateTime(baseDate.Ticks + inSeconds * TimeSpan.TicksPerSecond' DateTimeKind.Utc);                          DateTime localTime = TimeZoneInfo.ConvertTimeFromUtc(utcTime' sqlContext.TimeZone);                          return new ValueDate(localTime);                      }                    case edsTypeMilliseconds:                      {                          DateTime utcTime = new DateTime(baseDate.Ticks + integer64 * TimeSpan.TicksPerMillisecond' DateTimeKind.Utc);                          DateTime localTime = TimeZoneInfo.ConvertTimeFromUtc(utcTime' sqlContext.TimeZone);                          return new ValueDate(localTime);                      }                    case edsTypeScaledTimestamp:                      {                          long inNanos = Value.reScale(integer64' scale' NANOSECONDS_SCALE);                          DateTime utcTime = new DateTime(baseDate.Ticks + inNanos / NANOSECONDS_PER_TICK' DateTimeKind.Utc);                          DateTime localTime = TimeZoneInfo.ConvertTimeFromUtc(utcTime' sqlContext.TimeZone);                          return new ValueTimestamp(localTime);                      }                    case edsTypeNanoseconds:                      {                          DateTime utcTime = new DateTime(baseDate.Ticks + integer64 / NANOSECONDS_PER_TICK' DateTimeKind.Utc);                          DateTime localTime = TimeZoneInfo.ConvertTimeFromUtc(utcTime' sqlContext.TimeZone);                          return new ValueTimestamp(localTime);                      }                    case edsTypeBigInt:                      return new ValueNumber(bigDecimal);                }
Missing Default,NuoDb.Data.Client.EntityFramework.SqlGen,SqlGenerator,C:\repos\nuodb_nuodb-dotnet\NuoDb.Data.Client\EntityFramework\SqlGen\SqlGenerator.cs,VisitJoinExpression,The following switch statement is missing a default case: switch (joinKind)              {                  case DbExpressionKind.FullOuterJoin:                  case DbExpressionKind.InnerJoin:                  case DbExpressionKind.LeftOuterJoin:                      result.From.Append(" ON ");                      isParentAJoinStack.Push(false);                      result.From.Append(joinCondition.Accept(this));                      isParentAJoinStack.Pop();                      break;              }
