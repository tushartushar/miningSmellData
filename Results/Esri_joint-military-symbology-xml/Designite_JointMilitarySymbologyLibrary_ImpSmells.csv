Implementation smell,Namespace,Class,File,Method,Description
Long Method,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportEntities,The method has 109 lines of code.
Long Method,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The method has 118 lines of code.
Long Method,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The method has 110 lines of code.
Long Method,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_BuildGraphics,The method has 124 lines of code.
Complex Method,JointMilitarySymbologyLibrary,AmplifierExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\AmplifierExport.cs,BuildAmplifierItemName,Cyclomatic complexity of the method is 13
Complex Method,JointMilitarySymbologyLibrary,AmplifierExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\AmplifierExport.cs,BuildAmplifierItemTags,Cyclomatic complexity of the method is 20
Complex Method,JointMilitarySymbologyLibrary,AmplifierExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\AmplifierExport.cs,BuildSIDCKey,Cyclomatic complexity of the method is 12
Complex Method,JointMilitarySymbologyLibrary,ConfigHelper,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ConfigHelper.cs,_findIt,Cyclomatic complexity of the method is 45
Complex Method,JointMilitarySymbologyLibrary,ConfigHelper,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ConfigHelper.cs,GetPath,Cyclomatic complexity of the method is 37
Complex Method,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportSymbolSetCodes,Cyclomatic complexity of the method is 10
Complex Method,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportEntities,Cyclomatic complexity of the method is 27
Complex Method,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportModifier2,Cyclomatic complexity of the method is 9
Complex Method,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportModifier1,Cyclomatic complexity of the method is 9
Complex Method,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportContextDetails,Cyclomatic complexity of the method is 9
Complex Method,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportStandardIdentity,Cyclomatic complexity of the method is 10
Complex Method,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportSymbolSet,Cyclomatic complexity of the method is 9
Complex Method,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportStatus,Cyclomatic complexity of the method is 10
Complex Method,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportHQTFDummy,Cyclomatic complexity of the method is 10
Complex Method,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportAmplifier,Cyclomatic complexity of the method is 12
Complex Method,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_writeEntity,Cyclomatic complexity of the method is 14
Complex Method,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_writeEntityType,Cyclomatic complexity of the method is 10
Complex Method,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importCSV,Cyclomatic complexity of the method is 14
Complex Method,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,Cyclomatic complexity of the method is 27
Complex Method,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,Cyclomatic complexity of the method is 20
Complex Method,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,Export,Cyclomatic complexity of the method is 14
Complex Method,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,ExportAmplifiers,Cyclomatic complexity of the method is 20
Complex Method,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,ExportFrames,Cyclomatic complexity of the method is 25
Complex Method,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,ExportHQTFFD,Cyclomatic complexity of the method is 17
Complex Method,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,ExportOCA,Cyclomatic complexity of the method is 21
Complex Method,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildEntityItemName,Cyclomatic complexity of the method is 15
Complex Method,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,GrabGraphic,Cyclomatic complexity of the method is 12
Complex Method,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildEntityItemTags,Cyclomatic complexity of the method is 21
Complex Method,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,Cyclomatic complexity of the method is 12
Complex Method,JointMilitarySymbologyLibrary,FrameExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\FrameExport.cs,BuildFrameItemTags,Cyclomatic complexity of the method is 9
Complex Method,JointMilitarySymbologyLibrary,HQTFFDExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\HQTFFDExport.cs,BuildHQTFFDItemTags,Cyclomatic complexity of the method is 9
Complex Method,JointMilitarySymbologyLibrary,ImageAmplifierExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ImageAmplifierExport.cs,Line,Cyclomatic complexity of the method is 16
Complex Method,JointMilitarySymbologyLibrary,ImageEntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ImageEntityExport.cs,Line,Cyclomatic complexity of the method is 11
Complex Method,JointMilitarySymbologyLibrary,ImageFrameExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ImageFrameExport.cs,Line,Cyclomatic complexity of the method is 8
Complex Method,JointMilitarySymbologyLibrary,LegacyEntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\LegacyEntityExport.cs,Line,Cyclomatic complexity of the method is 13
Complex Method,JointMilitarySymbologyLibrary,LegacySymbolExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\LegacySymbolExport.cs,_buildName,Cyclomatic complexity of the method is 8
Complex Method,JointMilitarySymbologyLibrary,LegacySymbolExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\LegacySymbolExport.cs,Line,Cyclomatic complexity of the method is 14
Complex Method,JointMilitarySymbologyLibrary,LegacySymbolExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\LegacySymbolExport.cs,Line,Cyclomatic complexity of the method is 10
Complex Method,JointMilitarySymbologyLibrary,LegacyETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\LegacyETL.cs,_exportAmplifiers,Cyclomatic complexity of the method is 8
Complex Method,JointMilitarySymbologyLibrary,LegacyETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\LegacyETL.cs,_exportSymbols,Cyclomatic complexity of the method is 13
Complex Method,JointMilitarySymbologyLibrary,LegacyETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\LegacyETL.cs,_exportFrames,Cyclomatic complexity of the method is 9
Complex Method,JointMilitarySymbologyLibrary,LegacyETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\LegacyETL.cs,_exportLegacyEntities,Cyclomatic complexity of the method is 12
Complex Method,JointMilitarySymbologyLibrary,LegacyETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\LegacyETL.cs,_exportLegacyFrames,Cyclomatic complexity of the method is 10
Complex Method,JointMilitarySymbologyLibrary,LegacyFrameExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\LegacyFrameExport.cs,Line,Cyclomatic complexity of the method is 11
Complex Method,JointMilitarySymbologyLibrary,ModifierExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ModifierExport.cs,BuildModifierItemTags,Cyclomatic complexity of the method is 10
Complex Method,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_BuildEntityTypeGraphics,Cyclomatic complexity of the method is 30
Complex Method,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_BuildGraphics,Cyclomatic complexity of the method is 50
Complex Method,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_BuildTags,Cyclomatic complexity of the method is 21
Complex Method,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_BuildLegacySIDC,Cyclomatic complexity of the method is 10
Complex Method,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_UpdateFromCurrent,Cyclomatic complexity of the method is 8
Complex Method,JointMilitarySymbologyLibrary,Librarian,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Librarian.cs,Librarian,Cyclomatic complexity of the method is 19
Complex Method,JointMilitarySymbologyLibrary,Librarian,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Librarian.cs,EntitySubType,Cyclomatic complexity of the method is 9
Complex Method,JointMilitarySymbologyLibrary,Librarian,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Librarian.cs,LegacySymbol,Cyclomatic complexity of the method is 10
Complex Method,JointMilitarySymbologyLibrary,Librarian,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Librarian.cs,LegacySymbol,Cyclomatic complexity of the method is 29
Long Parameter List,JointMilitarySymbologyLibrary,AmplifierExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\AmplifierExport.cs,BuildAmplifierItemTags,The method has 6 parameters.
Long Parameter List,JointMilitarySymbologyLibrary,ConfigHelper,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ConfigHelper.cs,_findIt,The method has 5 parameters.
Long Parameter List,JointMilitarySymbologyLibrary,DomainEntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\DomainEntityExport.cs,Line,The method has 5 parameters.
Long Parameter List,JointMilitarySymbologyLibrary,DomainFrameExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\DomainFrameExport.cs,Line,The method has 7 parameters.
Long Parameter List,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportSpecialEntities,The method has 5 parameters.
Long Parameter List,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportEntities,The method has 10 parameters.
Long Parameter List,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportMod,The method has 6 parameters.
Long Parameter List,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportModifier2,The method has 5 parameters.
Long Parameter List,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportModifier1,The method has 5 parameters.
Long Parameter List,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportModifiers,The method has 6 parameters.
Long Parameter List,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportContextDetails,The method has 5 parameters.
Long Parameter List,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportContext,The method has 5 parameters.
Long Parameter List,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_writeEntity,The method has 7 parameters.
Long Parameter List,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_writeEntityType,The method has 7 parameters.
Long Parameter List,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_writeEntitySubType,The method has 7 parameters.
Long Parameter List,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_writeModifier,The method has 6 parameters.
Long Parameter List,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,Export,The method has 11 parameters.
Long Parameter List,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,ExportAmplifiers,The method has 7 parameters.
Long Parameter List,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,ExportFrames,The method has 9 parameters.
Long Parameter List,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,ExportHQTFFD,The method has 6 parameters.
Long Parameter List,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,ExportOCA,The method has 7 parameters.
Long Parameter List,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,ExportLegacyLookup,The method has 5 parameters.
Long Parameter List,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildEntityCode,The method has 5 parameters.
Long Parameter List,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildQuotedEntityCode,The method has 5 parameters.
Long Parameter List,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildEntityItemName,The method has 5 parameters.
Long Parameter List,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildEntityItemName,The method has 5 parameters.
Long Parameter List,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,GrabGraphic,The method has 5 parameters.
Long Parameter List,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildEntityItemTags,The method has 7 parameters.
Long Parameter List,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildEntityItemTags,The method has 5 parameters.
Long Parameter List,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,The method has 5 parameters.
Long Parameter List,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,NameIt,The method has 5 parameters.
Long Parameter List,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,NameIt,The method has 5 parameters.
Long Parameter List,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,CodeIt,The method has 5 parameters.
Long Parameter List,JointMilitarySymbologyLibrary,FrameExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\FrameExport.cs,BuildFrameCode,The method has 5 parameters.
Long Parameter List,JointMilitarySymbologyLibrary,FrameExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\FrameExport.cs,BuildQuotedFrameCode,The method has 5 parameters.
Long Parameter List,JointMilitarySymbologyLibrary,FrameExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\FrameExport.cs,BuildFrameItemName,The method has 5 parameters.
Long Parameter List,JointMilitarySymbologyLibrary,FrameExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\FrameExport.cs,BuildFrameItemTags,The method has 8 parameters.
Long Parameter List,JointMilitarySymbologyLibrary,FrameExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\FrameExport.cs,NameIt,The method has 5 parameters.
Long Parameter List,JointMilitarySymbologyLibrary,HQTFFDExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\HQTFFDExport.cs,BuildHQTFFDItemTags,The method has 6 parameters.
Long Parameter List,JointMilitarySymbologyLibrary,IEntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\IEntityExport.cs,Line,The method has 5 parameters.
Long Parameter List,JointMilitarySymbologyLibrary,IFrameExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\IFrameExport.cs,Line,The method has 7 parameters.
Long Parameter List,JointMilitarySymbologyLibrary,ImageEntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ImageEntityExport.cs,Line,The method has 5 parameters.
Long Parameter List,JointMilitarySymbologyLibrary,ImageFrameExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ImageFrameExport.cs,Line,The method has 7 parameters.
Long Parameter List,JointMilitarySymbologyLibrary,LegacyEntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\LegacyEntityExport.cs,Line,The method has 5 parameters.
Long Parameter List,JointMilitarySymbologyLibrary,LegacyFrameGraphicExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\LegacyFrameGraphicExport.cs,Line,The method has 7 parameters.
Long Parameter List,JointMilitarySymbologyLibrary,LegacyETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\LegacyETL.cs,_exportSymbols,The method has 5 parameters.
Long Parameter List,JointMilitarySymbologyLibrary,LegacyETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\LegacyETL.cs,_exportFrames,The method has 5 parameters.
Long Parameter List,JointMilitarySymbologyLibrary,LegacyETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\LegacyETL.cs,ExportLegacyLookup,The method has 5 parameters.
Long Parameter List,JointMilitarySymbologyLibrary,LegacyFrameExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\LegacyFrameExport.cs,Line,The method has 7 parameters.
Long Parameter List,JointMilitarySymbologyLibrary,ModifierExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ModifierExport.cs,BuildModifierItemTags,The method has 5 parameters.
Long Parameter List,JointMilitarySymbologyLibrary,OCAExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\OCAExport.cs,BuildOCAItemTags,The method has 6 parameters.
Long Parameter List,JointMilitarySymbologyLibrary,SimpleEntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\SimpleEntityExport.cs,Line,The method has 5 parameters.
Long Parameter List,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,Symbol,The method has 5 parameters.
Long Parameter List,JointMilitarySymbologyLibrary,Librarian,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Librarian.cs,LegacySymbol,The method has 6 parameters.
Long Statement,JointMilitarySymbologyLibrary,AmplifierExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\AmplifierExport.cs,BuildAmplifierItemTags,The length of the statement  "	// The information concatenated together for this comes from a given AmplifierGroup' Amplifier' and StandardIdentityGroup. " is 122.
Long Statement,JointMilitarySymbologyLibrary,DomainAmplifierExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\DomainAmplifierExport.cs,Line,The length of the statement  "	//LibraryStandardIdentityGroup identityGroup = _configHelper.Librarian.StandardIdentityGroup(graphic.StandardIdentityGroup); " is 124.
Long Statement,JointMilitarySymbologyLibrary,DomainAmplifierExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\DomainAmplifierExport.cs,Line,The length of the statement  "	string result = BuildAmplifierItemName (amplifierGroup' amplifier' null) + "'" + BuildAmplifierCode (amplifierGroup' amplifier' null); " is 134.
Long Statement,JointMilitarySymbologyLibrary,DomainEntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\DomainEntityExport.cs,Line,The length of the statement  "	string code = Convert.ToString (eSubType.EntitySubTypeCode.DigitOne) + Convert.ToString (eSubType.EntitySubTypeCode.DigitTwo); " is 126.
Long Statement,JointMilitarySymbologyLibrary,DomainFrameExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\DomainFrameExport.cs,Line,The length of the statement  "	result = BuildFrameItemName (null' null' identity' null' false) + "'" + BuildFrameCode (null' identity' null' null' false); " is 123.
Long Statement,JointMilitarySymbologyLibrary,DomainHQTFFDExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\DomainHQTFFDExport.cs,Line,The length of the statement  "	//LibraryStandardIdentityGroup identityGroup = _configHelper.Librarian.StandardIdentityGroup(graphic.StandardIdentityGroup); " is 124.
Long Statement,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportSymbolSetCodes,The length of the statement  "								line = symbolSet.Label + "'" + Convert.ToString (symbolSet.SymbolSetCode.DigitOne) + Convert.ToString (symbolSet.SymbolSetCode.DigitTwo); " is 137.
Long Statement,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportEntities,The length of the statement  "			if (symbolSetExpression != "" && !System.Text.RegularExpressions.Regex.IsMatch (s.Label' symbolSetExpression' System.Text.RegularExpressions.RegexOptions.IgnoreCase)) " is 166.
Long Statement,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportEntities,The length of the statement  "					if (expression == "" || System.Text.RegularExpressions.Regex.IsMatch (e.Label' expression' System.Text.RegularExpressions.RegexOptions.IgnoreCase)) { " is 149.
Long Statement,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportEntities,The length of the statement  "						if (exportPoints && e.GeometryType == GeometryType.POINT || exportLines && e.GeometryType == GeometryType.LINE || exportAreas && e.GeometryType == GeometryType.AREA || (e.EntityCode.DigitOne == 0 && e.EntityCode.DigitTwo == 0)) { " is 229.
Long Statement,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportEntities,The length of the statement  "							if (expression == "" || System.Text.RegularExpressions.Regex.IsMatch (eType.Label' expression' System.Text.RegularExpressions.RegexOptions.IgnoreCase)) { " is 153.
Long Statement,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportEntities,The length of the statement  "								if (exportPoints && eType.GeometryType == GeometryType.POINT || exportLines && eType.GeometryType == GeometryType.LINE || exportAreas && eType.GeometryType == GeometryType.AREA) { " is 179.
Long Statement,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportEntities,The length of the statement  "									if (expression == "" || System.Text.RegularExpressions.Regex.IsMatch (eSubType.Label' expression' System.Text.RegularExpressions.RegexOptions.IgnoreCase)) { " is 156.
Long Statement,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportEntities,The length of the statement  "										if (exportPoints && eSubType.GeometryType == GeometryType.POINT || exportLines && eSubType.GeometryType == GeometryType.LINE || exportAreas && eSubType.GeometryType == GeometryType.AREA) { " is 188.
Long Statement,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportMod,The length of the statement  "		if (expression == "" || System.Text.RegularExpressions.Regex.IsMatch (mod.Label' expression' System.Text.RegularExpressions.RegexOptions.IgnoreCase)) { " is 151.
Long Statement,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportMod,The length of the statement  "			if (System.Text.RegularExpressions.Regex.IsMatch (mod.Category' expression' System.Text.RegularExpressions.RegexOptions.IgnoreCase)) { " is 134.
Long Statement,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportModifier2,The length of the statement  "			if (symbolSetExpression != "" && !System.Text.RegularExpressions.Regex.IsMatch (s.Label' symbolSetExpression' System.Text.RegularExpressions.RegexOptions.IgnoreCase)) " is 166.
Long Statement,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportModifier1,The length of the statement  "			if (symbolSetExpression != "" && !System.Text.RegularExpressions.Regex.IsMatch (s.Label' symbolSetExpression' System.Text.RegularExpressions.RegexOptions.IgnoreCase)) " is 166.
Long Statement,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportSymbolSet,The length of the statement  "				w.WriteLine ("SymbolSet'" + Convert.ToString (obj.SymbolSetCode.DigitOne) + Convert.ToString (obj.SymbolSetCode.DigitTwo) + ''' + obj.Label.Replace ('''' '-')); " is 160.
Long Statement,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportSymbolSet,The length of the statement  "				w.WriteLine (Convert.ToString (obj.SymbolSetCode.DigitOne) + Convert.ToString (obj.SymbolSetCode.DigitTwo) + ''' + obj.Label.Replace ('''' '-')); " is 145.
Long Statement,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportAmplifier,The length of the statement  "							w.WriteLine ("Amplifier'" + Convert.ToString (descript.AmplifierGroupCode) + Convert.ToString (obj.AmplifierCode) + ''' + obj.Label.Replace ('''' '-')); " is 152.
Long Statement,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportAmplifier,The length of the statement  "							w.WriteLine (Convert.ToString (descript.AmplifierGroupCode) + Convert.ToString (obj.AmplifierCode) + ''' + obj.Label.Replace ('''' '-')); " is 137.
Long Statement,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importCSV,The length of the statement  "	w.WriteLine ("<SymbolSet xmlns=\"http://disa.mil/JointMilSyML.xsd\" ID=\"AN_ID\" Label=\"A Label\" DimensionID=\"A_DIMENSION\">"); " is 130.
Long Statement,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The length of the statement  "									SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1))); " is 134.
Long Statement,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The length of the statement  "											SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1))); " is 153.
Long Statement,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The length of the statement  "													EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1))); " is 152.
Long Statement,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The length of the statement  "											ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1))); " is 148.
Long Statement,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The length of the statement  "											ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1))); " is 148.
Long Statement,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The length of the statement  "		stream.WriteLine ("2525Charlie1stTen'2525Charlie'2525DeltaSymbolSet'2525DeltaEntity'2525DeltaMod1'2525DeltaMod2'2525DeltaName'2525DeltaMod1Name'2525DeltaMod2Name'DeltaToCharlie'Remarks"); " is 187.
Long Statement,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The length of the statement  "							stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status); " is 287.
Long Statement,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,Export,The length of the statement  "		_exportEntities (exportType' entityExporter' entityPath' specialPath' symbolSetExpression' expression' exportPoints' exportLines' exportAreas' append); " is 151.
Long Statement,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,ExportAmplifiers,The length of the statement  "				if (amplifierExpression != "" && !System.Text.RegularExpressions.Regex.IsMatch (lag.Label' amplifierExpression' System.Text.RegularExpressions.RegexOptions.IgnoreCase)) " is 168.
Long Statement,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,ExportFrames,The length of the statement  "					if (contextExpression != "" && !System.Text.RegularExpressions.Regex.IsMatch (context.Label' contextExpression' System.Text.RegularExpressions.RegexOptions.IgnoreCase)) " is 168.
Long Statement,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,ExportFrames,The length of the statement  "						if (standardIdentityExpression != "" && !System.Text.RegularExpressions.Regex.IsMatch (identity.Label' standardIdentityExpression' System.Text.RegularExpressions.RegexOptions.IgnoreCase)) " is 187.
Long Statement,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,ExportFrames,The length of the statement  "							if (dimensionExpression != "" && !System.Text.RegularExpressions.Regex.IsMatch (dimension.Label' dimensionExpression' System.Text.RegularExpressions.RegexOptions.IgnoreCase)) " is 174.
Long Statement,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,ExportFrames,The length of the statement  "					if (standardIdentityExpression != "" && !System.Text.RegularExpressions.Regex.IsMatch (identity.Label' standardIdentityExpression' System.Text.RegularExpressions.RegexOptions.IgnoreCase)) " is 187.
Long Statement,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildEntityCode,The length of the statement  "		code = code + eSubType.EntityCode + eSubType.EntityTypeCode + Convert.ToString (eSubType.EntitySubTypeCode.DigitOne) + Convert.ToString (eSubType.EntitySubTypeCode.DigitTwo); " is 174.
Long Statement,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildEntityCode,The length of the statement  "			code = code + Convert.ToString (eSubType.EntitySubTypeCode.DigitOne) + Convert.ToString (eSubType.EntitySubTypeCode.DigitTwo); " is 126.
Long Statement,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildEntityItemTags,The length of the statement  "				graphic = GrabGraphic (eSubType.CloverGraphic' eSubType.RectangleGraphic' eSubType.SquareGraphic' eSubType.DiamondGraphic' sig.GraphicSuffix); " is 142.
Long Statement,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildEntityItemTags,The length of the statement  "				graphic = GrabGraphic (eType.CloverGraphic' eType.RectangleGraphic' eType.SquareGraphic' eType.DiamondGraphic' sig.GraphicSuffix); " is 130.
Long Statement,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildEntityItemTags,The length of the statement  "			graphic = GrabGraphic (entity.CloverGraphic' entity.RectangleGraphic' entity.SquareGraphic' entity.DiamondGraphic' sig.GraphicSuffix); " is 134.
Long Statement,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,The length of the statement  "			partB = partB + (eSubType.EntitySubTypeCode.DigitOne * (uint)100000) + (eSubType.EntitySubTypeCode.DigitTwo * (uint)10000); " is 123.
Long Statement,JointMilitarySymbologyLibrary,FrameExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\FrameExport.cs,BuildFrameCode,The length of the statement  "		code = Convert.ToString (context.ContextCode) + "_" + Convert.ToString (identity.StandardIdentityCode) + Convert.ToString (dimension.DimensionCode.DigitOne) + Convert.ToString (dimension.DimensionCode.DigitTwo) + "_" + Convert.ToString ((status.StatusCode == 1) ? 1 : 0); " is 271.
Long Statement,JointMilitarySymbologyLibrary,FrameExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\FrameExport.cs,BuildFrameItemTags,The length of the statement  "		result = result + ((status.LabelAlias == "") ? status.Label.Replace ('''' '-') : status.LabelAlias.Replace ('''' '-')) + ";"; " is 125.
Long Statement,JointMilitarySymbologyLibrary,HQTFFDExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\HQTFFDExport.cs,BuildHQTFFDCode,The length of the statement  "		code = code + Convert.ToString (dimension.DimensionCode.DigitOne) + Convert.ToString (dimension.DimensionCode.DigitTwo); " is 120.
Long Statement,JointMilitarySymbologyLibrary,HQTFFDExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\HQTFFDExport.cs,BuildSIDCKey,The length of the statement  "	key = key + (dimension.LegacyDimensionCode [0].FirstFunctionLetter == "" ? "-" : dimension.LegacyDimensionCode [0].FirstFunctionLetter); " is 136.
Long Statement,JointMilitarySymbologyLibrary,ImageAmplifierExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ImageAmplifierExport.cs,Line,The length of the statement  "	LibraryStandardIdentityGroup identityGroup = _configHelper.Librarian.StandardIdentityGroup (graphic.StandardIdentityGroup); " is 123.
Long Statement,JointMilitarySymbologyLibrary,ImageAmplifierExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ImageAmplifierExport.cs,Line,The length of the statement  "	string itemTags = BuildAmplifierItemTags (amplifierGroup' amplifier' identityGroup' graphicPath + "\\" + graphic.Graphic' _omitSource' _omitLegacy); " is 148.
Long Statement,JointMilitarySymbologyLibrary,ImageAmplifierExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ImageAmplifierExport.cs,Line,The length of the statement  "	result = itemRootedPath + "'" + Convert.ToString (_configHelper.PointSize) + "'" + itemName + "'" + itemCategory + "'" + itemTags + "'" + itemID + "'" + "Point" + "'" + _notes; " is 176.
Long Statement,JointMilitarySymbologyLibrary,ImageEntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ImageEntityExport.cs,Line,The length of the statement  "			graphic = GrabGraphic (eSubType.CloverGraphic' eSubType.RectangleGraphic' eSubType.SquareGraphic' eSubType.DiamondGraphic' sig.GraphicSuffix); " is 142.
Long Statement,JointMilitarySymbologyLibrary,ImageEntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ImageEntityExport.cs,Line,The length of the statement  "			graphic = GrabGraphic (eType.CloverGraphic' eType.RectangleGraphic' eType.SquareGraphic' eType.DiamondGraphic' sig.GraphicSuffix); " is 130.
Long Statement,JointMilitarySymbologyLibrary,ImageEntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ImageEntityExport.cs,Line,The length of the statement  "	result = itemRootedPath + "'" + Convert.ToString (_configHelper.PointSize) + "'" + itemName + "'" + itemCategory + "'" + itemTags + "'" + itemID + "'" + itemGeometry + "'" + _notes; " is 181.
Long Statement,JointMilitarySymbologyLibrary,ImageFrameExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ImageFrameExport.cs,Line,The length of the statement  "			string itemTags = BuildFrameItemTags (context' identity' dimension' status' graphicPath + "\\" + graphic' _omitSource' _omitLegacy' asCivilian || asPlannedCivilian); " is 165.
Long Statement,JointMilitarySymbologyLibrary,ImageFrameExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ImageFrameExport.cs,Line,The length of the statement  "			result = itemRootedPath + "'" + Convert.ToString (_configHelper.PointSize) + "'" + itemName + "'" + itemCategory + "'" + itemTags + "'" + itemID + "'" + "Point" + "'" + _notes; " is 176.
Long Statement,JointMilitarySymbologyLibrary,ImageHQTFFDExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ImageHQTFFDExport.cs,Line,The length of the statement  "	LibraryStandardIdentityGroup identityGroup = _configHelper.Librarian.StandardIdentityGroup (graphic.StandardIdentityGroup); " is 123.
Long Statement,JointMilitarySymbologyLibrary,ImageHQTFFDExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ImageHQTFFDExport.cs,Line,The length of the statement  "	string itemTags = BuildHQTFFDItemTags (identityGroup' dimension' hqTFFD' graphicPath + "\\" + graphic.Graphic' _omitSource' _omitLegacy); " is 137.
Long Statement,JointMilitarySymbologyLibrary,ImageHQTFFDExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ImageHQTFFDExport.cs,Line,The length of the statement  "	result = itemRootedPath + "'" + Convert.ToString (_configHelper.PointSize) + "'" + itemName + "'" + itemCategory + "'" + itemTags + "'" + itemID + "'" + "Point" + "'" + _notes; " is 176.
Long Statement,JointMilitarySymbologyLibrary,ImageModifierExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ImageModifierExport.cs,Line,The length of the statement  "	result = itemRootedPath + "'" + Convert.ToString (_configHelper.PointSize) + "'" + itemName + "'" + itemCategory + "'" + itemTags + "'" + itemID + "'" + "Point" + "'" + _notes; " is 176.
Long Statement,JointMilitarySymbologyLibrary,ImageOCAExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ImageOCAExport.cs,Line,The length of the statement  "	LibraryStandardIdentityGroup identity = _configHelper.Librarian.StandardIdentityGroup (statusGraphic.StandardIdentityGroup); " is 124.
Long Statement,JointMilitarySymbologyLibrary,ImageOCAExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ImageOCAExport.cs,Line,The length of the statement  "	string itemTags = BuildOCAItemTags (identity' dimension' status' graphicPath + "\\" + statusGraphic.Graphic' _omitSource' _omitLegacy); " is 135.
Long Statement,JointMilitarySymbologyLibrary,ImageOCAExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ImageOCAExport.cs,Line,The length of the statement  "	result = itemRootedPath + "'" + Convert.ToString (_configHelper.PointSize) + "'" + itemName + "'" + itemCategory + "'" + itemTags + "'" + itemID + "'" + "Point" + "'" + _notes; " is 176.
Long Statement,JointMilitarySymbologyLibrary,ImageOCAExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ImageOCAExport.cs,Line,The length of the statement  "	result = itemRootedPath + "'" + Convert.ToString (_configHelper.PointSize) + "'" + itemName + "'" + itemCategory + "'" + itemTags + "'" + itemID + "'" + "Point" + "'" + _notes; " is 176.
Long Statement,JointMilitarySymbologyLibrary,LegacyEntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\LegacyEntityExport.cs,Line,The length of the statement  "		graphic = GrabGraphic (entity.CloverGraphic' entity.RectangleGraphic' entity.SquareGraphic' entity.DiamondGraphic' sig.GraphicSuffix); " is 134.
Long Statement,JointMilitarySymbologyLibrary,LegacyOCAExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\LegacyOCAExport.cs,Line,The length of the statement  "	LibraryStandardIdentityGroup siGroup = _configHelper.Librarian.StandardIdentityGroup (statusGraphic.StandardIdentityGroup); " is 123.
Long Statement,JointMilitarySymbologyLibrary,LegacyETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\LegacyETL.cs,_exportAmplifiers,The length of the statement  "							string line = id.ToString () + "'" + legacyAmplifierExport.Line (legacyModifier.CodingSchemeLetter' group' amplifier' graphic); " is 127.
Long Statement,JointMilitarySymbologyLibrary,LegacyETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\LegacyETL.cs,_exportSymbols,The length of the statement  "						if (legacySymbol.EntityID != "NA" && legacySymbol.EntityID != "UNSPECIFIED" && (asOriginal == false || legacySymbol.LegacyEntity == null)) { " is 140.
Long Statement,JointMilitarySymbologyLibrary,LegacyETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\LegacyETL.cs,_exportSymbols,The length of the statement  "						} // This second part handles those legacy symbols being mapped to Original symbols or that are Retired and no longer have a " is 124.
Long Statement,JointMilitarySymbologyLibrary,ModifierExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ModifierExport.cs,BuildModifierItemName,The length of the statement  "	//result = result + _configHelper.DomainSeparator + m.Category.Replace('''' '-') + _configHelper.DomainSeparator + m.Label.Replace('''' '-'); " is 141.
Long Statement,JointMilitarySymbologyLibrary,ModifierExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ModifierExport.cs,BuildModifierItemName,The length of the statement  "		result = ((m.CategoryAlias == "") ? m.Category : m.CategoryAlias) + _configHelper.DomainSeparator + ((m.LabelAlias == "") ? m.Label : m.LabelAlias); " is 148.
Long Statement,JointMilitarySymbologyLibrary,OCAExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\OCAExport.cs,BuildOCACode,The length of the statement  "		code = "0" + Convert.ToString (identity.StandardIdentityGroupCode) + Convert.ToString (dimension.DimensionCode.DigitOne) + Convert.ToString (dimension.DimensionCode.DigitTwo) + Convert.ToString (status.StatusCode) + "2"; " is 220.
Long Statement,JointMilitarySymbologyLibrary,OCAExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\OCAExport.cs,BuildOCAItemName,The length of the statement  "		result = result + ((status.LabelAlias != "") ? status.LabelAlias.Replace ('''' '-') : status.Label.Replace ('''' '-')) + _configHelper.DomainSeparator; " is 151.
Long Statement,JointMilitarySymbologyLibrary,OCAExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\OCAExport.cs,BuildOCAItemTags,The length of the statement  "		result = result + ((status.LabelAlias != "") ? status.LabelAlias.Replace ('''' '-') : status.Label.Replace ('''' '-')) + ";"; " is 125.
Long Statement,JointMilitarySymbologyLibrary,OCAExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\OCAExport.cs,BuildOCAItemTags,The length of the statement  "		result = result + ((status.LabelAlias != "") ? status.LabelAlias.Replace ('''' '-') : status.Label.Replace ('''' '-')) + ";"; " is 125.
Long Statement,JointMilitarySymbologyLibrary,SchemaETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\SchemaETL.cs,_writeField,The length of the statement  "	string line = string.Format ("{0}"' field.Name + "'" + field.Type + "'" + field.Length + "'" + field.Alias + "'" + (field.IsNullable ? _nullable : _nonnullable) + "'" + field.Domain + "'" + field.Default + "'" + field.SetsSubtype + "'" + "'" + field.Notes); " is 257.
Long Statement,JointMilitarySymbologyLibrary,SchemaETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\SchemaETL.cs,_writeSubtypedField,The length of the statement  "	string line = string.Format ("{0}"' field.Name + "'" + field.Type + "'" + field.Length + "'" + field.Alias + "'" + (field.IsNullable ? _nullable : _nonnullable) + "'" + subtype.Domain + "'" + subtype.Default + "'" + field.SetsSubtype + "'" + subtype.Code + "'" + field.Notes); " is 276.
Long Statement,JointMilitarySymbologyLibrary,SchemaETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\SchemaETL.cs,_exportFieldSchema,The length of the statement  "				// If this schema is subtyped we need to check to see if this is one of the fields that is subtyped and treat it special if it is. " is 130.
Long Statement,JointMilitarySymbologyLibrary,SchemaETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\SchemaETL.cs,_exportSchemaContainer,The length of the statement  "		string line = string.Format ("{0}"' "SchemaContainer'" + container.Label + "'" + "Mixed" + "'" + container.LabelAlias + "'" + container.Metadata.Label + "'" + container.Metadata.Thumbnail + "'" + container.Metadata.Tags + "'" + container.Metadata.Summary + "'" + container.Metadata.Description + "'" + (container.Metadata.Credits != null ? container.Metadata.Credits : "") + "'" + container.Metadata.Use + "'" + (container.Metadata.Extent != null ? Convert.ToString (container.Metadata.Extent.East) : "") + "'" + (container.Metadata.Extent != null ? Convert.ToString (container.Metadata.Extent.West) : "") + "'" + (container.Metadata.Extent != null ? Convert.ToString (container.Metadata.Extent.North) : "") + "'" + (container.Metadata.Extent != null ? Convert.ToString (container.Metadata.Extent.South) : "") + "'" + container.Metadata.MaximumScale + "'" + container.Metadata.MinimumScale + "'" + ""); " is 902.
Long Statement,JointMilitarySymbologyLibrary,SchemaETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\SchemaETL.cs,_exportSchemaSet,The length of the statement  "		string line = string.Format ("{0}"' "SchemaSet'" + schemas.Label + "'" + "Mixed" + "'" + schemas.LabelAlias + "'" + schemas.Metadata.Label + "'" + schemas.Metadata.Thumbnail + "'" + schemas.Metadata.Tags + "'" + schemas.Metadata.Summary + "'" + schemas.Metadata.Description + "'" + (schemas.Metadata.Credits != null ? schemas.Metadata.Credits : "") + "'" + schemas.Metadata.Use + "'" + (schemas.Metadata.Extent != null ? Convert.ToString (schemas.Metadata.Extent.East) : "") + "'" + (schemas.Metadata.Extent != null ? Convert.ToString (schemas.Metadata.Extent.West) : "") + "'" + (schemas.Metadata.Extent != null ? Convert.ToString (schemas.Metadata.Extent.North) : "") + "'" + (schemas.Metadata.Extent != null ? Convert.ToString (schemas.Metadata.Extent.South) : "") + "'" + schemas.Metadata.MaximumScale + "'" + schemas.Metadata.MinimumScale + "'" + schemas.SpatialReference); " is 878.
Long Statement,JointMilitarySymbologyLibrary,SchemaETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\SchemaETL.cs,_exportSchema,The length of the statement  "		string line = string.Format ("{0}"' "Schema'" + schema.Label + "'" + schema.GeometryType + "'" + schema.LabelAlias + "'" + schema.Metadata.Label + "'" + schema.Metadata.Thumbnail + "'" + schema.Metadata.Tags + "'" + schema.Metadata.Summary + "'" + schema.Metadata.Description + "'" + (schema.Metadata.Credits != null ? schema.Metadata.Credits : "") + "'" + schema.Metadata.Use + "'" + (schema.Metadata.Extent != null ? Convert.ToString (schema.Metadata.Extent.East) : "") + "'" + (schema.Metadata.Extent != null ? Convert.ToString (schema.Metadata.Extent.West) : "") + "'" + (schema.Metadata.Extent != null ? Convert.ToString (schema.Metadata.Extent.North) : "") + "'" + (schema.Metadata.Extent != null ? Convert.ToString (schema.Metadata.Extent.South) : "") + "'" + schema.Metadata.MaximumScale + "'" + schema.Metadata.MinimumScale + "'" + schema.SpatialReference); " is 866.
Long Statement,JointMilitarySymbologyLibrary,SimpleEntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\SimpleEntityExport.cs,Line,The length of the statement  "	// Remove the first two characters as this output does not require the symbol set code' and exclude any trailing underbar digit " is 127.
Long Statement,JointMilitarySymbologyLibrary,SimpleEntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\SimpleEntityExport.cs,Line,The length of the statement  "	// Remove the first two characters as this output does not require the symbol set code' and exclude any trailing underbar digit " is 127.
Long Statement,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_BuildGraphics,The length of the statement  "			path = _configHelper.BuildOriginalPath (path' (_status.StatusCode == 1 && _affiliation.PlannedCivilianGraphic != "") ? _affiliation.PlannedCivilianGraphic : _affiliation.CivilianGraphic); " is 187.
Long Statement,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_BuildGraphics,The length of the statement  "			path = _configHelper.BuildOriginalPath (path' (_status.StatusCode == 1 && _affiliation.PlannedGraphic != "") ? _affiliation.PlannedGraphic : _affiliation.Graphic); " is 163.
Long Statement,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_BuildNames,The length of the statement  "	_names.Add ("Entity"' ee.NameIt (this.IconType == JointMilitarySymbologyLibrary.IconType.FULL_FRAME ? _sig : null' _symbolSet' _entity' _entityType' _entitySubType)); " is 166.
Long Statement,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_BuildNames,The length of the statement  "		_names.Add ("Frame"' fe.NameIt (_context' _dimension' _standardIdentity' _status' _affiliation.CivilianGraphic != "" || _affiliation.PlannedCivilianGraphic != "")); " is 164.
Long Statement,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_BuildSIDC,The length of the statement  "	if (_version != null && _context != null && _standardIdentity != null && _symbolSet != null && _status != null && _hqTFDummy != null && _amplifierGroup != null && _amplifier != null) { " is 184.
Long Statement,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_BuildSIDC,The length of the statement  "		_sidc.PartAUInt = (uint)_version.VersionCode.DigitOne * 1000000000 + (uint)_version.VersionCode.DigitTwo * 100000000 + (uint)_context.ContextCode * 10000000 + (uint)_standardIdentity.StandardIdentityCode * 1000000 + (uint)_symbolSet.SymbolSetCode.DigitOne * 100000 + (uint)_symbolSet.SymbolSetCode.DigitTwo * 10000 + (uint)_status.StatusCode * 1000 + (uint)_hqTFDummy.HQTFDummyCode * 100 + (uint)_amplifierGroup.AmplifierGroupCode * 10 + (uint)_amplifier.AmplifierCode; " is 469.
Long Statement,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_BuildSIDC,The length of the statement  "		_sidc.PartBUInt = _sidc.PartBUInt + (uint)_entityType.EntityTypeCode.DigitOne * 10000000 + (uint)_entityType.EntityTypeCode.DigitTwo * 1000000; " is 143.
Long Statement,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_BuildSIDC,The length of the statement  "		_sidc.PartBUInt = _sidc.PartBUInt + (uint)_entitySubType.EntitySubTypeCode.DigitOne * 100000 + (uint)_entitySubType.EntitySubTypeCode.DigitTwo * 10000; " is 151.
Long Statement,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_BuildSIDC,The length of the statement  "		_sidc.PartBUInt = _sidc.PartBUInt + (uint)_modifierOne.ModifierCode.DigitOne * 1000 + (uint)_modifierOne.ModifierCode.DigitTwo * 100; " is 133.
Long Statement,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_BuildSIDC,The length of the statement  "		_sidc.PartBUInt = _sidc.PartBUInt + (uint)_modifierTwo.ModifierCode.DigitOne * 10 + (uint)_modifierTwo.ModifierCode.DigitTwo; " is 125.
Long Statement,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_BuildLegacySIDC,The length of the statement  "	if (_symbolSet != null && _affiliation != null && _dimension != null && _status != null && _amplifierGroup != null && _amplifier != null && _context.ContextCode != 2) { " is 168.
Long Statement,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_BuildLegacySIDC,The length of the statement  "			result = _symbolSet.LegacyCodingSchemeCode [0].Value + _affiliation.LegacyStandardIdentityCode [0].Value + _dimension.LegacyDimensionCode [0].Value + _status.LegacyStatusCode [0].Value + _blankLegacyFunction; " is 208.
Long Statement,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_UpdateFromCurrent,The length of the statement  "	_version = _librarian.Version (Convert.ToUInt16 (first10.Substring (0' 1))' Convert.ToUInt16 (first10.Substring (1' 1))); " is 121.
Long Statement,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_UpdateFromCurrent,The length of the statement  "	_symbolSet = _librarian.SymbolSet (Convert.ToUInt16 (first10.Substring (4' 1))' Convert.ToUInt16 (first10.Substring (5' 1))); " is 125.
Long Statement,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_UpdateFromCurrent,The length of the statement  "		_entity = _librarian.Entity (_symbolSet' Convert.ToUInt16 (second10.Substring (0' 1))' Convert.ToUInt16 (second10.Substring (1' 1))); " is 133.
Long Statement,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_UpdateFromCurrent,The length of the statement  "			_entityType = _librarian.EntityType (_entity' Convert.ToUInt16 (second10.Substring (2' 1))' Convert.ToUInt16 (second10.Substring (3' 1))); " is 138.
Long Statement,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_UpdateFromCurrent,The length of the statement  "			_entitySubType = _librarian.EntitySubType (_entityType' Convert.ToUInt16 (second10.Substring (4' 1))' Convert.ToUInt16 (second10.Substring (5' 1))); " is 148.
Long Statement,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_UpdateFromCurrent,The length of the statement  "				_entitySubType = _librarian.EntitySubType (_symbolSet' Convert.ToUInt16 (second10.Substring (4' 1))' Convert.ToUInt16 (second10.Substring (5' 1))); " is 147.
Long Statement,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_UpdateFromCurrent,The length of the statement  "		_modifierOne = _librarian.ModifierOne (_symbolSet' Convert.ToUInt16 (second10.Substring (6' 1))' Convert.ToUInt16 (second10.Substring (7' 1))); " is 143.
Long Statement,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_UpdateFromCurrent,The length of the statement  "		_modifierTwo = _librarian.ModifierTwo (_symbolSet' Convert.ToUInt16 (second10.Substring (8' 1))' Convert.ToUInt16 (second10.Substring (9' 1))); " is 143.
Long Statement,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_ValidateStatus,The length of the statement  "	if (bits [(int)StatusCodeEnum.statusCodeNoLegacySymbol] == '0' && bits [(int)StatusCodeEnum.statusCodeNoEntity] == '1') { " is 121.
Long Statement,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_ValidateStatus,The length of the statement  "		if (bits [(int)StatusCodeEnum.statusCodeNoVersion] == '1' || bits [(int)StatusCodeEnum.statusCodeNoContext] == '1' || bits [(int)StatusCodeEnum.statusCodeNoDimension] == '1' || bits [(int)StatusCodeEnum.statusCodeNoStandardIdentity] == '1' || bits [(int)StatusCodeEnum.statusCodeNoSymbolSet] == '1' || bits [(int)StatusCodeEnum.statusCodeNoStatus] == '1' || bits [(int)StatusCodeEnum.statusCodeNoHQTFDummy] == '1' || bits [(int)StatusCodeEnum.statusCodeNoAmplifierGroup] == '1' || bits [(int)StatusCodeEnum.statusCodeNoAmplifier] == '1' || bits [(int)StatusCodeEnum.statusCodeNoAffiliation] == '1' || bits [(int)StatusCodeEnum.statusCodeNoContextAmplifier] == '1' || bits [(int)StatusCodeEnum.statusCodeNoEntity] == '1') { " is 722.
Long Statement,JointMilitarySymbologyLibrary,Librarian,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Librarian.cs,InitializeNLog,The length of the statement  "	((FileTarget)logTarget).Layout = new SimpleLayout ("${longdate} | ${level} | ${callsite} | ${message} | ${exception:format=ToString}"); " is 135.
Long Statement,JointMilitarySymbologyLibrary,Librarian,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Librarian.cs,DimensionByLegacyCode,The length of the statement  "				if ((lObj2.Value == code && lObj2.FirstFunctionLetter == "" && lObj2.CodingSchemeLetter == "") || (lObj2.Value == code && lObj2.FirstFunctionLetter == firstLetterInFunction && lObj2.CodingSchemeLetter == "") || (lObj2.Value == code && lObj2.FirstFunctionLetter == "" && lObj2.CodingSchemeLetter == codingSchemeLetter) || (lObj2.Value == code && lObj2.FirstFunctionLetter == firstLetterInFunction && lObj2.CodingSchemeLetter == codingSchemeLetter)) { " is 449.
Long Statement,JointMilitarySymbologyLibrary,Librarian,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Librarian.cs,SymbolSet,The length of the statement  "						if ((lObj3.Value == code && lObj3.SchemaOverride == "" && lObj3.DimensionOverride == "") || (lObj3.Value == code && lObj3.SchemaOverride == "" && lObj3.DimensionOverride == dimensionCode) || (lObj3.Value == code && lObj3.SchemaOverride == schemaCode && lObj3.DimensionOverride == "") || (lObj3.Value == code && lObj3.SchemaOverride == schemaCode && lObj3.DimensionOverride == dimensionCode)) { " is 393.
Long Statement,JointMilitarySymbologyLibrary,Librarian,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Librarian.cs,Status,The length of the statement  "				if ((lObj2.Value == code && lObj2.CodingSchemeLetter == "") || (lObj2.Value == code && lObj2.CodingSchemeLetter == codingScheme)) { " is 131.
Long Statement,JointMilitarySymbologyLibrary,Librarian,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Librarian.cs,Amplifier,The length of the statement  "						if ((lObj3.Value == code && lObj3.CodingSchemeLetter == "") || (lObj3.Value == code && lObj3.CodingSchemeLetter == codingScheme)) { " is 131.
Long Statement,JointMilitarySymbologyLibrary,Librarian,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Librarian.cs,EntitySubType,The length of the statement  "				if (lObj.EntitySubTypeCode.DigitOne == entitySubTypeCodeOne && lObj.EntitySubTypeCode.DigitTwo == entitySubTypeCodeTwo) { " is 121.
Long Statement,JointMilitarySymbologyLibrary,Librarian,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Librarian.cs,EntitySubType,The length of the statement  "				if (lObj.EntitySubTypeCode.DigitOne == entitySubTypeCodeOne && lObj.EntitySubTypeCode.DigitTwo == entitySubTypeCodeTwo) { " is 121.
Long Statement,JointMilitarySymbologyLibrary,Librarian,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Librarian.cs,ModifierOne,The length of the statement  "				if (lObj.ID == modifierID || modifierID == "NA" && lObj.ModifierCode.DigitOne == 0 && lObj.ModifierCode.DigitTwo == 0) { " is 120.
Long Statement,JointMilitarySymbologyLibrary,Librarian,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Librarian.cs,ModifierTwo,The length of the statement  "				if (lObj.ID == modifierID || modifierID == "NA" && lObj.ModifierCode.DigitOne == 0 && lObj.ModifierCode.DigitTwo == 0) { " is 120.
Long Statement,JointMilitarySymbologyLibrary,Librarian,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Librarian.cs,LegacySymbol,The length of the statement  "				if ((lObj2.Value == code && lObj2.FirstFunctionLetter == "" && lObj2.CodingSchemeLetter == "") || (lObj2.Value == code && lObj2.FirstFunctionLetter == firstLetterInFunction && lObj2.CodingSchemeLetter == "") || (lObj2.Value == code && lObj2.FirstFunctionLetter == "" && lObj2.CodingSchemeLetter == codingSchemeLetter) || (lObj2.Value == code && lObj2.FirstFunctionLetter == firstLetterInFunction && lObj2.CodingSchemeLetter == codingSchemeLetter)) { " is 449.
Long Statement,JointMilitarySymbologyLibrary,Librarian,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Librarian.cs,LegacySymbol,The length of the statement  "						// Thanks to many exceptions in 2525C' given also that function codes are not unique' we need to check other legacy code values " is 127.
Long Statement,JointMilitarySymbologyLibrary,Librarian,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Librarian.cs,LegacySymbol,The length of the statement  "						if ((lObj2.SchemaOverride == "" || (lObj2.SchemaOverride != "" && lObj2.SchemaOverride == schema)) && (lObj2.DimensionOverride == "" || (lObj2.DimensionOverride != "" && lObj2.DimensionOverride == dimension)) && (lObj2.HQTFFDOverride == "" || (lObj2.HQTFFDOverride != "" && lObj2.HQTFFDOverride == hqtffd)) && (lObj2.AmplifierOverride == "" || (lObj2.AmplifierOverride != "" && lObj2.AmplifierOverride == amplifier)) && (lObj2.TailOverride == "" || (lObj2.TailOverride != "" && lObj2.TailOverride == tail))) { " is 509.
Complex Conditional,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportEntities,The conditional expression  "exportPoints && e.GeometryType == GeometryType.POINT || exportLines && e.GeometryType == GeometryType.LINE || exportAreas && e.GeometryType == GeometryType.AREA || (e.EntityCode.DigitOne == 0 && e.EntityCode.DigitTwo == 0)"  is complex.
Complex Conditional,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportEntities,The conditional expression  "exportPoints && eType.GeometryType == GeometryType.POINT || exportLines && eType.GeometryType == GeometryType.LINE || exportAreas && eType.GeometryType == GeometryType.AREA"  is complex.
Complex Conditional,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportEntities,The conditional expression  "exportPoints && eSubType.GeometryType == GeometryType.POINT || exportLines && eSubType.GeometryType == GeometryType.LINE || exportAreas && eSubType.GeometryType == GeometryType.AREA"  is complex.
Complex Conditional,JointMilitarySymbologyLibrary,LegacyETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\LegacyETL.cs,_exportSymbols,The conditional expression  "legacySymbol.EntityID != "NA" && legacySymbol.EntityID != "UNSPECIFIED" && (asOriginal == false || legacySymbol.LegacyEntity == null)"  is complex.
Complex Conditional,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_BuildSIDC,The conditional expression  "_version != null && _context != null && _standardIdentity != null && _symbolSet != null && _status != null && _hqTFDummy != null && _amplifierGroup != null && _amplifier != null"  is complex.
Complex Conditional,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_BuildLegacySIDC,The conditional expression  "_symbolSet != null && _affiliation != null && _dimension != null && _status != null && _amplifierGroup != null && _amplifier != null && _context.ContextCode != 2"  is complex.
Complex Conditional,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_ValidateStatus,The conditional expression  "bits [(int)StatusCodeEnum.statusCodeNoVersion] == '1' || bits [(int)StatusCodeEnum.statusCodeNoContext] == '1' || bits [(int)StatusCodeEnum.statusCodeNoDimension] == '1' || bits [(int)StatusCodeEnum.statusCodeNoStandardIdentity] == '1' || bits [(int)StatusCodeEnum.statusCodeNoSymbolSet] == '1' || bits [(int)StatusCodeEnum.statusCodeNoStatus] == '1' || bits [(int)StatusCodeEnum.statusCodeNoHQTFDummy] == '1' || bits [(int)StatusCodeEnum.statusCodeNoAmplifierGroup] == '1' || bits [(int)StatusCodeEnum.statusCodeNoAmplifier] == '1' || bits [(int)StatusCodeEnum.statusCodeNoAffiliation] == '1' || bits [(int)StatusCodeEnum.statusCodeNoContextAmplifier] == '1' || bits [(int)StatusCodeEnum.statusCodeNoEntity] == '1'"  is complex.
Complex Conditional,JointMilitarySymbologyLibrary,Librarian,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Librarian.cs,DimensionByLegacyCode,The conditional expression  "(lObj2.Value == code && lObj2.FirstFunctionLetter == "" && lObj2.CodingSchemeLetter == "") || (lObj2.Value == code && lObj2.FirstFunctionLetter == firstLetterInFunction && lObj2.CodingSchemeLetter == "") || (lObj2.Value == code && lObj2.FirstFunctionLetter == "" && lObj2.CodingSchemeLetter == codingSchemeLetter) || (lObj2.Value == code && lObj2.FirstFunctionLetter == firstLetterInFunction && lObj2.CodingSchemeLetter == codingSchemeLetter)"  is complex.
Complex Conditional,JointMilitarySymbologyLibrary,Librarian,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Librarian.cs,SymbolSet,The conditional expression  "(lObj3.Value == code && lObj3.SchemaOverride == "" && lObj3.DimensionOverride == "") || (lObj3.Value == code && lObj3.SchemaOverride == "" && lObj3.DimensionOverride == dimensionCode) || (lObj3.Value == code && lObj3.SchemaOverride == schemaCode && lObj3.DimensionOverride == "") || (lObj3.Value == code && lObj3.SchemaOverride == schemaCode && lObj3.DimensionOverride == dimensionCode)"  is complex.
Complex Conditional,JointMilitarySymbologyLibrary,Librarian,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Librarian.cs,Status,The conditional expression  "(lObj2.Value == code && lObj2.CodingSchemeLetter == "") || (lObj2.Value == code && lObj2.CodingSchemeLetter == codingScheme)"  is complex.
Complex Conditional,JointMilitarySymbologyLibrary,Librarian,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Librarian.cs,Amplifier,The conditional expression  "(lObj3.Value == code && lObj3.CodingSchemeLetter == "") || (lObj3.Value == code && lObj3.CodingSchemeLetter == codingScheme)"  is complex.
Complex Conditional,JointMilitarySymbologyLibrary,Librarian,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Librarian.cs,ModifierOne,The conditional expression  "lObj.ID == modifierID || modifierID == "NA" && lObj.ModifierCode.DigitOne == 0 && lObj.ModifierCode.DigitTwo == 0"  is complex.
Complex Conditional,JointMilitarySymbologyLibrary,Librarian,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Librarian.cs,ModifierTwo,The conditional expression  "lObj.ID == modifierID || modifierID == "NA" && lObj.ModifierCode.DigitOne == 0 && lObj.ModifierCode.DigitTwo == 0"  is complex.
Complex Conditional,JointMilitarySymbologyLibrary,Librarian,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Librarian.cs,LegacySymbol,The conditional expression  "(lObj2.Value == code && lObj2.FirstFunctionLetter == "" && lObj2.CodingSchemeLetter == "") || (lObj2.Value == code && lObj2.FirstFunctionLetter == firstLetterInFunction && lObj2.CodingSchemeLetter == "") || (lObj2.Value == code && lObj2.FirstFunctionLetter == "" && lObj2.CodingSchemeLetter == codingSchemeLetter) || (lObj2.Value == code && lObj2.FirstFunctionLetter == firstLetterInFunction && lObj2.CodingSchemeLetter == codingSchemeLetter)"  is complex.
Complex Conditional,JointMilitarySymbologyLibrary,Librarian,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Librarian.cs,LegacySymbol,The conditional expression  "(lObj2.SchemaOverride == "" || (lObj2.SchemaOverride != "" && lObj2.SchemaOverride == schema)) && (lObj2.DimensionOverride == "" || (lObj2.DimensionOverride != "" && lObj2.DimensionOverride == dimension)) && (lObj2.HQTFFDOverride == "" || (lObj2.HQTFFDOverride != "" && lObj2.HQTFFDOverride == hqtffd)) && (lObj2.AmplifierOverride == "" || (lObj2.AmplifierOverride != "" && lObj2.AmplifierOverride == amplifier)) && (lObj2.TailOverride == "" || (lObj2.TailOverride != "" && lObj2.TailOverride == tail))"  is complex.
Magic Number,JointMilitarySymbologyLibrary,AmplifierExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\AmplifierExport.cs,BuildAmplifierItemName,The following statement contains a magic number: switch (amplifierGroup.AmplifierGroupCode) {  case 1:  case 2:  	category = "Echelon";  	break;  case 3:  case 4:  case 5:  	category = "Mobility";  	break;  case 6:  	category = "Auxiliary Equipment";  	break;  }  
Magic Number,JointMilitarySymbologyLibrary,AmplifierExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\AmplifierExport.cs,BuildAmplifierItemName,The following statement contains a magic number: switch (amplifierGroup.AmplifierGroupCode) {  case 1:  case 2:  	category = "Echelon";  	break;  case 3:  case 4:  case 5:  	category = "Mobility";  	break;  case 6:  	category = "Auxiliary Equipment";  	break;  }  
Magic Number,JointMilitarySymbologyLibrary,AmplifierExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\AmplifierExport.cs,BuildAmplifierItemName,The following statement contains a magic number: switch (amplifierGroup.AmplifierGroupCode) {  case 1:  case 2:  	category = "Echelon";  	break;  case 3:  case 4:  case 5:  	category = "Mobility";  	break;  case 6:  	category = "Auxiliary Equipment";  	break;  }  
Magic Number,JointMilitarySymbologyLibrary,AmplifierExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\AmplifierExport.cs,BuildAmplifierItemName,The following statement contains a magic number: switch (amplifierGroup.AmplifierGroupCode) {  case 1:  case 2:  	category = "Echelon";  	break;  case 3:  case 4:  case 5:  	category = "Mobility";  	break;  case 6:  	category = "Auxiliary Equipment";  	break;  }  
Magic Number,JointMilitarySymbologyLibrary,AmplifierExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\AmplifierExport.cs,BuildAmplifierItemName,The following statement contains a magic number: switch (amplifierGroup.AmplifierGroupCode) {  case 1:  case 2:  	category = "Echelon";  	break;  case 3:  case 4:  case 5:  	category = "Mobility";  	break;  case 6:  	category = "Auxiliary Equipment";  	break;  }  
Magic Number,JointMilitarySymbologyLibrary,AmplifierExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\AmplifierExport.cs,BuildAmplifierItemTags,The following statement contains a magic number: switch (amplifierGroup.AmplifierGroupCode) {  case 1:  case 2:  	category = "Echelon;";  	iType = "ECHELON";  	break;  case 3:  case 4:  case 5:  	category = "Mobility;";  	iType = "MOBILITY";  	break;  case 6:  	category = "Auxiliary Equipment;";  	iType = "AUXILIARY";  	break;  }  
Magic Number,JointMilitarySymbologyLibrary,AmplifierExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\AmplifierExport.cs,BuildAmplifierItemTags,The following statement contains a magic number: switch (amplifierGroup.AmplifierGroupCode) {  case 1:  case 2:  	category = "Echelon;";  	iType = "ECHELON";  	break;  case 3:  case 4:  case 5:  	category = "Mobility;";  	iType = "MOBILITY";  	break;  case 6:  	category = "Auxiliary Equipment;";  	iType = "AUXILIARY";  	break;  }  
Magic Number,JointMilitarySymbologyLibrary,AmplifierExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\AmplifierExport.cs,BuildAmplifierItemTags,The following statement contains a magic number: switch (amplifierGroup.AmplifierGroupCode) {  case 1:  case 2:  	category = "Echelon;";  	iType = "ECHELON";  	break;  case 3:  case 4:  case 5:  	category = "Mobility;";  	iType = "MOBILITY";  	break;  case 6:  	category = "Auxiliary Equipment;";  	iType = "AUXILIARY";  	break;  }  
Magic Number,JointMilitarySymbologyLibrary,AmplifierExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\AmplifierExport.cs,BuildAmplifierItemTags,The following statement contains a magic number: switch (amplifierGroup.AmplifierGroupCode) {  case 1:  case 2:  	category = "Echelon;";  	iType = "ECHELON";  	break;  case 3:  case 4:  case 5:  	category = "Mobility;";  	iType = "MOBILITY";  	break;  case 6:  	category = "Auxiliary Equipment;";  	iType = "AUXILIARY";  	break;  }  
Magic Number,JointMilitarySymbologyLibrary,AmplifierExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\AmplifierExport.cs,BuildAmplifierItemTags,The following statement contains a magic number: switch (amplifierGroup.AmplifierGroupCode) {  case 1:  case 2:  	category = "Echelon;";  	iType = "ECHELON";  	break;  case 3:  case 4:  case 5:  	category = "Mobility;";  	iType = "MOBILITY";  	break;  case 6:  	category = "Auxiliary Equipment;";  	iType = "AUXILIARY";  	break;  }  
Magic Number,JointMilitarySymbologyLibrary,AmplifierExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\AmplifierExport.cs,BuildSIDCKey,The following statement contains a magic number: switch (amplifierGroup.AmplifierGroupCode) {  case 1:  case 2:  	key = key + amplifier.LegacyModifierCode [0].Value;  	break;  case 3:  case 4:  case 5:  	key = key + "M" + amplifier.LegacyModifierCode [0].Value;  	break;  case 6:  	key = key + "N" + amplifier.LegacyModifierCode [0].Value;  	break;  }  
Magic Number,JointMilitarySymbologyLibrary,AmplifierExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\AmplifierExport.cs,BuildSIDCKey,The following statement contains a magic number: switch (amplifierGroup.AmplifierGroupCode) {  case 1:  case 2:  	key = key + amplifier.LegacyModifierCode [0].Value;  	break;  case 3:  case 4:  case 5:  	key = key + "M" + amplifier.LegacyModifierCode [0].Value;  	break;  case 6:  	key = key + "N" + amplifier.LegacyModifierCode [0].Value;  	break;  }  
Magic Number,JointMilitarySymbologyLibrary,AmplifierExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\AmplifierExport.cs,BuildSIDCKey,The following statement contains a magic number: switch (amplifierGroup.AmplifierGroupCode) {  case 1:  case 2:  	key = key + amplifier.LegacyModifierCode [0].Value;  	break;  case 3:  case 4:  case 5:  	key = key + "M" + amplifier.LegacyModifierCode [0].Value;  	break;  case 6:  	key = key + "N" + amplifier.LegacyModifierCode [0].Value;  	break;  }  
Magic Number,JointMilitarySymbologyLibrary,AmplifierExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\AmplifierExport.cs,BuildSIDCKey,The following statement contains a magic number: switch (amplifierGroup.AmplifierGroupCode) {  case 1:  case 2:  	key = key + amplifier.LegacyModifierCode [0].Value;  	break;  case 3:  case 4:  case 5:  	key = key + "M" + amplifier.LegacyModifierCode [0].Value;  	break;  case 6:  	key = key + "N" + amplifier.LegacyModifierCode [0].Value;  	break;  }  
Magic Number,JointMilitarySymbologyLibrary,AmplifierExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\AmplifierExport.cs,BuildSIDCKey,The following statement contains a magic number: switch (amplifierGroup.AmplifierGroupCode) {  case 1:  case 2:  	key = key + amplifier.LegacyModifierCode [0].Value;  	break;  case 3:  case 4:  case 5:  	key = key + "M" + amplifier.LegacyModifierCode [0].Value;  	break;  case 6:  	key = key + "N" + amplifier.LegacyModifierCode [0].Value;  	break;  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_writeEntity,The following statement contains a magic number: switch (mode) {  case 0:  	w.WriteLine ("</Entity>");  	break;  case 1:  	w.WriteLine ("</EntityType>");  	w.WriteLine ("</EntityTypes>");  	w.WriteLine ("</Entity>");  	break;  case 2:  	w.WriteLine ("</EntitySubTypes>");  	w.WriteLine ("</EntityType>");  	w.WriteLine ("</EntityTypes>");  	w.WriteLine ("</Entity>");  	break;  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_writeEntityType,The following statement contains a magic number: switch (mode) {  case 0:  	w.WriteLine ("<EntityTypes>");  	break;  case 1:  	w.WriteLine ("</EntityType>");  	break;  case 2:  	w.WriteLine ("</EntitySubTypes>");  	w.WriteLine ("</EntityType>");  	break;  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_writeEntitySubType,The following statement contains a magic number: mode = 2;  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_writeModifiers,The following statement contains a magic number: while (!rm1.EndOfStream) {  	string line = rm1.ReadLine ();  	string[] tokens = line.Split (''');  	string modSet = tokens [1].PadLeft (2' '0');  	string modNo = tokens [2];  	if (setToDo == modSet && modToDo == modNo) {  		string mod = tokens [0];  		string id = _cleanString (mod);  		id = id + "_MOD";  		string modCode = tokens [3].PadLeft (2' '0');  		_writeModifier (w' id' mod' modCode.Substring (0' 1)' modCode.Substring (1' 1)' setToDo + modCode + modToDo + ".svg");  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_writeModifiers,The following statement contains a magic number: while (!rm1.EndOfStream) {  	string line = rm1.ReadLine ();  	string[] tokens = line.Split (''');  	string modSet = tokens [1].PadLeft (2' '0');  	string modNo = tokens [2];  	if (setToDo == modSet && modToDo == modNo) {  		string mod = tokens [0];  		string id = _cleanString (mod);  		id = id + "_MOD";  		string modCode = tokens [3].PadLeft (2' '0');  		_writeModifier (w' id' mod' modCode.Substring (0' 1)' modCode.Substring (1' 1)' setToDo + modCode + modToDo + ".svg");  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_writeModifiers,The following statement contains a magic number: while (!rm1.EndOfStream) {  	string line = rm1.ReadLine ();  	string[] tokens = line.Split (''');  	string modSet = tokens [1].PadLeft (2' '0');  	string modNo = tokens [2];  	if (setToDo == modSet && modToDo == modNo) {  		string mod = tokens [0];  		string id = _cleanString (mod);  		id = id + "_MOD";  		string modCode = tokens [3].PadLeft (2' '0');  		_writeModifier (w' id' mod' modCode.Substring (0' 1)' modCode.Substring (1' 1)' setToDo + modCode + modToDo + ".svg");  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_writeModifiers,The following statement contains a magic number: while (!rm1.EndOfStream) {  	string line = rm1.ReadLine ();  	string[] tokens = line.Split (''');  	string modSet = tokens [1].PadLeft (2' '0');  	string modNo = tokens [2];  	if (setToDo == modSet && modToDo == modNo) {  		string mod = tokens [0];  		string id = _cleanString (mod);  		id = id + "_MOD";  		string modCode = tokens [3].PadLeft (2' '0');  		_writeModifier (w' id' mod' modCode.Substring (0' 1)' modCode.Substring (1' 1)' setToDo + modCode + modToDo + ".svg");  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_writeModifiers,The following statement contains a magic number: if (setToDo == modSet && modToDo == modNo) {  	string mod = tokens [0];  	string id = _cleanString (mod);  	id = id + "_MOD";  	string modCode = tokens [3].PadLeft (2' '0');  	_writeModifier (w' id' mod' modCode.Substring (0' 1)' modCode.Substring (1' 1)' setToDo + modCode + modToDo + ".svg");  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_writeModifiers,The following statement contains a magic number: if (setToDo == modSet && modToDo == modNo) {  	string mod = tokens [0];  	string id = _cleanString (mod);  	id = id + "_MOD";  	string modCode = tokens [3].PadLeft (2' '0');  	_writeModifier (w' id' mod' modCode.Substring (0' 1)' modCode.Substring (1' 1)' setToDo + modCode + modToDo + ".svg");  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importCSV,The following statement contains a magic number: while (!r.EndOfStream) {  	line = r.ReadLine ();  	string[] tokens = line.Split (''');  	ss = tokens [0];  	entity = tokens [1].Trim ();  	entityType = tokens [2].Trim ();  	entitySubType = tokens [3].Trim ();  	if (ss == ssCode) {  		codeE = tokens [4].Substring (0' 2);  		codeET = tokens [4].Substring (2' 2);  		codeEST = tokens [4].Substring (4' 2);  		graphic = ss + tokens [4] + ".svg";  		if (entityType == "") {  			id = _cleanString (entity);  			_writeEntity (ref mode' w' id' entity' codeE.Substring (0' 1)' codeE.Substring (1' 1)' graphic);  			w.WriteLine ("");  		} else {  			if (entitySubType == "") {  				id = _cleanString (entityType);  				_writeEntityType (ref mode' w' id' entityType' codeET.Substring (0' 1)' codeET.Substring (1' 1)' graphic);  				w.WriteLine ("");  			} else {  				id = _cleanString (entitySubType);  				_writeEntitySubType (ref mode' w' id' entitySubType' codeEST.Substring (0' 1)' codeEST.Substring (1' 1)' graphic);  				w.WriteLine ("");  			}  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importCSV,The following statement contains a magic number: while (!r.EndOfStream) {  	line = r.ReadLine ();  	string[] tokens = line.Split (''');  	ss = tokens [0];  	entity = tokens [1].Trim ();  	entityType = tokens [2].Trim ();  	entitySubType = tokens [3].Trim ();  	if (ss == ssCode) {  		codeE = tokens [4].Substring (0' 2);  		codeET = tokens [4].Substring (2' 2);  		codeEST = tokens [4].Substring (4' 2);  		graphic = ss + tokens [4] + ".svg";  		if (entityType == "") {  			id = _cleanString (entity);  			_writeEntity (ref mode' w' id' entity' codeE.Substring (0' 1)' codeE.Substring (1' 1)' graphic);  			w.WriteLine ("");  		} else {  			if (entitySubType == "") {  				id = _cleanString (entityType);  				_writeEntityType (ref mode' w' id' entityType' codeET.Substring (0' 1)' codeET.Substring (1' 1)' graphic);  				w.WriteLine ("");  			} else {  				id = _cleanString (entitySubType);  				_writeEntitySubType (ref mode' w' id' entitySubType' codeEST.Substring (0' 1)' codeEST.Substring (1' 1)' graphic);  				w.WriteLine ("");  			}  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importCSV,The following statement contains a magic number: while (!r.EndOfStream) {  	line = r.ReadLine ();  	string[] tokens = line.Split (''');  	ss = tokens [0];  	entity = tokens [1].Trim ();  	entityType = tokens [2].Trim ();  	entitySubType = tokens [3].Trim ();  	if (ss == ssCode) {  		codeE = tokens [4].Substring (0' 2);  		codeET = tokens [4].Substring (2' 2);  		codeEST = tokens [4].Substring (4' 2);  		graphic = ss + tokens [4] + ".svg";  		if (entityType == "") {  			id = _cleanString (entity);  			_writeEntity (ref mode' w' id' entity' codeE.Substring (0' 1)' codeE.Substring (1' 1)' graphic);  			w.WriteLine ("");  		} else {  			if (entitySubType == "") {  				id = _cleanString (entityType);  				_writeEntityType (ref mode' w' id' entityType' codeET.Substring (0' 1)' codeET.Substring (1' 1)' graphic);  				w.WriteLine ("");  			} else {  				id = _cleanString (entitySubType);  				_writeEntitySubType (ref mode' w' id' entitySubType' codeEST.Substring (0' 1)' codeEST.Substring (1' 1)' graphic);  				w.WriteLine ("");  			}  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importCSV,The following statement contains a magic number: while (!r.EndOfStream) {  	line = r.ReadLine ();  	string[] tokens = line.Split (''');  	ss = tokens [0];  	entity = tokens [1].Trim ();  	entityType = tokens [2].Trim ();  	entitySubType = tokens [3].Trim ();  	if (ss == ssCode) {  		codeE = tokens [4].Substring (0' 2);  		codeET = tokens [4].Substring (2' 2);  		codeEST = tokens [4].Substring (4' 2);  		graphic = ss + tokens [4] + ".svg";  		if (entityType == "") {  			id = _cleanString (entity);  			_writeEntity (ref mode' w' id' entity' codeE.Substring (0' 1)' codeE.Substring (1' 1)' graphic);  			w.WriteLine ("");  		} else {  			if (entitySubType == "") {  				id = _cleanString (entityType);  				_writeEntityType (ref mode' w' id' entityType' codeET.Substring (0' 1)' codeET.Substring (1' 1)' graphic);  				w.WriteLine ("");  			} else {  				id = _cleanString (entitySubType);  				_writeEntitySubType (ref mode' w' id' entitySubType' codeEST.Substring (0' 1)' codeEST.Substring (1' 1)' graphic);  				w.WriteLine ("");  			}  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importCSV,The following statement contains a magic number: while (!r.EndOfStream) {  	line = r.ReadLine ();  	string[] tokens = line.Split (''');  	ss = tokens [0];  	entity = tokens [1].Trim ();  	entityType = tokens [2].Trim ();  	entitySubType = tokens [3].Trim ();  	if (ss == ssCode) {  		codeE = tokens [4].Substring (0' 2);  		codeET = tokens [4].Substring (2' 2);  		codeEST = tokens [4].Substring (4' 2);  		graphic = ss + tokens [4] + ".svg";  		if (entityType == "") {  			id = _cleanString (entity);  			_writeEntity (ref mode' w' id' entity' codeE.Substring (0' 1)' codeE.Substring (1' 1)' graphic);  			w.WriteLine ("");  		} else {  			if (entitySubType == "") {  				id = _cleanString (entityType);  				_writeEntityType (ref mode' w' id' entityType' codeET.Substring (0' 1)' codeET.Substring (1' 1)' graphic);  				w.WriteLine ("");  			} else {  				id = _cleanString (entitySubType);  				_writeEntitySubType (ref mode' w' id' entitySubType' codeEST.Substring (0' 1)' codeEST.Substring (1' 1)' graphic);  				w.WriteLine ("");  			}  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importCSV,The following statement contains a magic number: while (!r.EndOfStream) {  	line = r.ReadLine ();  	string[] tokens = line.Split (''');  	ss = tokens [0];  	entity = tokens [1].Trim ();  	entityType = tokens [2].Trim ();  	entitySubType = tokens [3].Trim ();  	if (ss == ssCode) {  		codeE = tokens [4].Substring (0' 2);  		codeET = tokens [4].Substring (2' 2);  		codeEST = tokens [4].Substring (4' 2);  		graphic = ss + tokens [4] + ".svg";  		if (entityType == "") {  			id = _cleanString (entity);  			_writeEntity (ref mode' w' id' entity' codeE.Substring (0' 1)' codeE.Substring (1' 1)' graphic);  			w.WriteLine ("");  		} else {  			if (entitySubType == "") {  				id = _cleanString (entityType);  				_writeEntityType (ref mode' w' id' entityType' codeET.Substring (0' 1)' codeET.Substring (1' 1)' graphic);  				w.WriteLine ("");  			} else {  				id = _cleanString (entitySubType);  				_writeEntitySubType (ref mode' w' id' entitySubType' codeEST.Substring (0' 1)' codeEST.Substring (1' 1)' graphic);  				w.WriteLine ("");  			}  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importCSV,The following statement contains a magic number: while (!r.EndOfStream) {  	line = r.ReadLine ();  	string[] tokens = line.Split (''');  	ss = tokens [0];  	entity = tokens [1].Trim ();  	entityType = tokens [2].Trim ();  	entitySubType = tokens [3].Trim ();  	if (ss == ssCode) {  		codeE = tokens [4].Substring (0' 2);  		codeET = tokens [4].Substring (2' 2);  		codeEST = tokens [4].Substring (4' 2);  		graphic = ss + tokens [4] + ".svg";  		if (entityType == "") {  			id = _cleanString (entity);  			_writeEntity (ref mode' w' id' entity' codeE.Substring (0' 1)' codeE.Substring (1' 1)' graphic);  			w.WriteLine ("");  		} else {  			if (entitySubType == "") {  				id = _cleanString (entityType);  				_writeEntityType (ref mode' w' id' entityType' codeET.Substring (0' 1)' codeET.Substring (1' 1)' graphic);  				w.WriteLine ("");  			} else {  				id = _cleanString (entitySubType);  				_writeEntitySubType (ref mode' w' id' entitySubType' codeEST.Substring (0' 1)' codeEST.Substring (1' 1)' graphic);  				w.WriteLine ("");  			}  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importCSV,The following statement contains a magic number: while (!r.EndOfStream) {  	line = r.ReadLine ();  	string[] tokens = line.Split (''');  	ss = tokens [0];  	entity = tokens [1].Trim ();  	entityType = tokens [2].Trim ();  	entitySubType = tokens [3].Trim ();  	if (ss == ssCode) {  		codeE = tokens [4].Substring (0' 2);  		codeET = tokens [4].Substring (2' 2);  		codeEST = tokens [4].Substring (4' 2);  		graphic = ss + tokens [4] + ".svg";  		if (entityType == "") {  			id = _cleanString (entity);  			_writeEntity (ref mode' w' id' entity' codeE.Substring (0' 1)' codeE.Substring (1' 1)' graphic);  			w.WriteLine ("");  		} else {  			if (entitySubType == "") {  				id = _cleanString (entityType);  				_writeEntityType (ref mode' w' id' entityType' codeET.Substring (0' 1)' codeET.Substring (1' 1)' graphic);  				w.WriteLine ("");  			} else {  				id = _cleanString (entitySubType);  				_writeEntitySubType (ref mode' w' id' entitySubType' codeEST.Substring (0' 1)' codeEST.Substring (1' 1)' graphic);  				w.WriteLine ("");  			}  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importCSV,The following statement contains a magic number: while (!r.EndOfStream) {  	line = r.ReadLine ();  	string[] tokens = line.Split (''');  	ss = tokens [0];  	entity = tokens [1].Trim ();  	entityType = tokens [2].Trim ();  	entitySubType = tokens [3].Trim ();  	if (ss == ssCode) {  		codeE = tokens [4].Substring (0' 2);  		codeET = tokens [4].Substring (2' 2);  		codeEST = tokens [4].Substring (4' 2);  		graphic = ss + tokens [4] + ".svg";  		if (entityType == "") {  			id = _cleanString (entity);  			_writeEntity (ref mode' w' id' entity' codeE.Substring (0' 1)' codeE.Substring (1' 1)' graphic);  			w.WriteLine ("");  		} else {  			if (entitySubType == "") {  				id = _cleanString (entityType);  				_writeEntityType (ref mode' w' id' entityType' codeET.Substring (0' 1)' codeET.Substring (1' 1)' graphic);  				w.WriteLine ("");  			} else {  				id = _cleanString (entitySubType);  				_writeEntitySubType (ref mode' w' id' entitySubType' codeEST.Substring (0' 1)' codeEST.Substring (1' 1)' graphic);  				w.WriteLine ("");  			}  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importCSV,The following statement contains a magic number: while (!r.EndOfStream) {  	line = r.ReadLine ();  	string[] tokens = line.Split (''');  	ss = tokens [0];  	entity = tokens [1].Trim ();  	entityType = tokens [2].Trim ();  	entitySubType = tokens [3].Trim ();  	if (ss == ssCode) {  		codeE = tokens [4].Substring (0' 2);  		codeET = tokens [4].Substring (2' 2);  		codeEST = tokens [4].Substring (4' 2);  		graphic = ss + tokens [4] + ".svg";  		if (entityType == "") {  			id = _cleanString (entity);  			_writeEntity (ref mode' w' id' entity' codeE.Substring (0' 1)' codeE.Substring (1' 1)' graphic);  			w.WriteLine ("");  		} else {  			if (entitySubType == "") {  				id = _cleanString (entityType);  				_writeEntityType (ref mode' w' id' entityType' codeET.Substring (0' 1)' codeET.Substring (1' 1)' graphic);  				w.WriteLine ("");  			} else {  				id = _cleanString (entitySubType);  				_writeEntitySubType (ref mode' w' id' entitySubType' codeEST.Substring (0' 1)' codeEST.Substring (1' 1)' graphic);  				w.WriteLine ("");  			}  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importCSV,The following statement contains a magic number: while (!r.EndOfStream) {  	line = r.ReadLine ();  	string[] tokens = line.Split (''');  	ss = tokens [0];  	entity = tokens [1].Trim ();  	entityType = tokens [2].Trim ();  	entitySubType = tokens [3].Trim ();  	if (ss == ssCode) {  		codeE = tokens [4].Substring (0' 2);  		codeET = tokens [4].Substring (2' 2);  		codeEST = tokens [4].Substring (4' 2);  		graphic = ss + tokens [4] + ".svg";  		if (entityType == "") {  			id = _cleanString (entity);  			_writeEntity (ref mode' w' id' entity' codeE.Substring (0' 1)' codeE.Substring (1' 1)' graphic);  			w.WriteLine ("");  		} else {  			if (entitySubType == "") {  				id = _cleanString (entityType);  				_writeEntityType (ref mode' w' id' entityType' codeET.Substring (0' 1)' codeET.Substring (1' 1)' graphic);  				w.WriteLine ("");  			} else {  				id = _cleanString (entitySubType);  				_writeEntitySubType (ref mode' w' id' entitySubType' codeEST.Substring (0' 1)' codeEST.Substring (1' 1)' graphic);  				w.WriteLine ("");  			}  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importCSV,The following statement contains a magic number: entityType = tokens [2].Trim ();  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importCSV,The following statement contains a magic number: entitySubType = tokens [3].Trim ();  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importCSV,The following statement contains a magic number: if (ss == ssCode) {  	codeE = tokens [4].Substring (0' 2);  	codeET = tokens [4].Substring (2' 2);  	codeEST = tokens [4].Substring (4' 2);  	graphic = ss + tokens [4] + ".svg";  	if (entityType == "") {  		id = _cleanString (entity);  		_writeEntity (ref mode' w' id' entity' codeE.Substring (0' 1)' codeE.Substring (1' 1)' graphic);  		w.WriteLine ("");  	} else {  		if (entitySubType == "") {  			id = _cleanString (entityType);  			_writeEntityType (ref mode' w' id' entityType' codeET.Substring (0' 1)' codeET.Substring (1' 1)' graphic);  			w.WriteLine ("");  		} else {  			id = _cleanString (entitySubType);  			_writeEntitySubType (ref mode' w' id' entitySubType' codeEST.Substring (0' 1)' codeEST.Substring (1' 1)' graphic);  			w.WriteLine ("");  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importCSV,The following statement contains a magic number: if (ss == ssCode) {  	codeE = tokens [4].Substring (0' 2);  	codeET = tokens [4].Substring (2' 2);  	codeEST = tokens [4].Substring (4' 2);  	graphic = ss + tokens [4] + ".svg";  	if (entityType == "") {  		id = _cleanString (entity);  		_writeEntity (ref mode' w' id' entity' codeE.Substring (0' 1)' codeE.Substring (1' 1)' graphic);  		w.WriteLine ("");  	} else {  		if (entitySubType == "") {  			id = _cleanString (entityType);  			_writeEntityType (ref mode' w' id' entityType' codeET.Substring (0' 1)' codeET.Substring (1' 1)' graphic);  			w.WriteLine ("");  		} else {  			id = _cleanString (entitySubType);  			_writeEntitySubType (ref mode' w' id' entitySubType' codeEST.Substring (0' 1)' codeEST.Substring (1' 1)' graphic);  			w.WriteLine ("");  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importCSV,The following statement contains a magic number: if (ss == ssCode) {  	codeE = tokens [4].Substring (0' 2);  	codeET = tokens [4].Substring (2' 2);  	codeEST = tokens [4].Substring (4' 2);  	graphic = ss + tokens [4] + ".svg";  	if (entityType == "") {  		id = _cleanString (entity);  		_writeEntity (ref mode' w' id' entity' codeE.Substring (0' 1)' codeE.Substring (1' 1)' graphic);  		w.WriteLine ("");  	} else {  		if (entitySubType == "") {  			id = _cleanString (entityType);  			_writeEntityType (ref mode' w' id' entityType' codeET.Substring (0' 1)' codeET.Substring (1' 1)' graphic);  			w.WriteLine ("");  		} else {  			id = _cleanString (entitySubType);  			_writeEntitySubType (ref mode' w' id' entitySubType' codeEST.Substring (0' 1)' codeEST.Substring (1' 1)' graphic);  			w.WriteLine ("");  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importCSV,The following statement contains a magic number: if (ss == ssCode) {  	codeE = tokens [4].Substring (0' 2);  	codeET = tokens [4].Substring (2' 2);  	codeEST = tokens [4].Substring (4' 2);  	graphic = ss + tokens [4] + ".svg";  	if (entityType == "") {  		id = _cleanString (entity);  		_writeEntity (ref mode' w' id' entity' codeE.Substring (0' 1)' codeE.Substring (1' 1)' graphic);  		w.WriteLine ("");  	} else {  		if (entitySubType == "") {  			id = _cleanString (entityType);  			_writeEntityType (ref mode' w' id' entityType' codeET.Substring (0' 1)' codeET.Substring (1' 1)' graphic);  			w.WriteLine ("");  		} else {  			id = _cleanString (entitySubType);  			_writeEntitySubType (ref mode' w' id' entitySubType' codeEST.Substring (0' 1)' codeEST.Substring (1' 1)' graphic);  			w.WriteLine ("");  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importCSV,The following statement contains a magic number: if (ss == ssCode) {  	codeE = tokens [4].Substring (0' 2);  	codeET = tokens [4].Substring (2' 2);  	codeEST = tokens [4].Substring (4' 2);  	graphic = ss + tokens [4] + ".svg";  	if (entityType == "") {  		id = _cleanString (entity);  		_writeEntity (ref mode' w' id' entity' codeE.Substring (0' 1)' codeE.Substring (1' 1)' graphic);  		w.WriteLine ("");  	} else {  		if (entitySubType == "") {  			id = _cleanString (entityType);  			_writeEntityType (ref mode' w' id' entityType' codeET.Substring (0' 1)' codeET.Substring (1' 1)' graphic);  			w.WriteLine ("");  		} else {  			id = _cleanString (entitySubType);  			_writeEntitySubType (ref mode' w' id' entitySubType' codeEST.Substring (0' 1)' codeEST.Substring (1' 1)' graphic);  			w.WriteLine ("");  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importCSV,The following statement contains a magic number: if (ss == ssCode) {  	codeE = tokens [4].Substring (0' 2);  	codeET = tokens [4].Substring (2' 2);  	codeEST = tokens [4].Substring (4' 2);  	graphic = ss + tokens [4] + ".svg";  	if (entityType == "") {  		id = _cleanString (entity);  		_writeEntity (ref mode' w' id' entity' codeE.Substring (0' 1)' codeE.Substring (1' 1)' graphic);  		w.WriteLine ("");  	} else {  		if (entitySubType == "") {  			id = _cleanString (entityType);  			_writeEntityType (ref mode' w' id' entityType' codeET.Substring (0' 1)' codeET.Substring (1' 1)' graphic);  			w.WriteLine ("");  		} else {  			id = _cleanString (entitySubType);  			_writeEntitySubType (ref mode' w' id' entitySubType' codeEST.Substring (0' 1)' codeEST.Substring (1' 1)' graphic);  			w.WriteLine ("");  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importCSV,The following statement contains a magic number: if (ss == ssCode) {  	codeE = tokens [4].Substring (0' 2);  	codeET = tokens [4].Substring (2' 2);  	codeEST = tokens [4].Substring (4' 2);  	graphic = ss + tokens [4] + ".svg";  	if (entityType == "") {  		id = _cleanString (entity);  		_writeEntity (ref mode' w' id' entity' codeE.Substring (0' 1)' codeE.Substring (1' 1)' graphic);  		w.WriteLine ("");  	} else {  		if (entitySubType == "") {  			id = _cleanString (entityType);  			_writeEntityType (ref mode' w' id' entityType' codeET.Substring (0' 1)' codeET.Substring (1' 1)' graphic);  			w.WriteLine ("");  		} else {  			id = _cleanString (entitySubType);  			_writeEntitySubType (ref mode' w' id' entitySubType' codeEST.Substring (0' 1)' codeEST.Substring (1' 1)' graphic);  			w.WriteLine ("");  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importCSV,The following statement contains a magic number: if (ss == ssCode) {  	codeE = tokens [4].Substring (0' 2);  	codeET = tokens [4].Substring (2' 2);  	codeEST = tokens [4].Substring (4' 2);  	graphic = ss + tokens [4] + ".svg";  	if (entityType == "") {  		id = _cleanString (entity);  		_writeEntity (ref mode' w' id' entity' codeE.Substring (0' 1)' codeE.Substring (1' 1)' graphic);  		w.WriteLine ("");  	} else {  		if (entitySubType == "") {  			id = _cleanString (entityType);  			_writeEntityType (ref mode' w' id' entityType' codeET.Substring (0' 1)' codeET.Substring (1' 1)' graphic);  			w.WriteLine ("");  		} else {  			id = _cleanString (entitySubType);  			_writeEntitySubType (ref mode' w' id' entitySubType' codeEST.Substring (0' 1)' codeEST.Substring (1' 1)' graphic);  			w.WriteLine ("");  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importCSV,The following statement contains a magic number: if (ss == ssCode) {  	codeE = tokens [4].Substring (0' 2);  	codeET = tokens [4].Substring (2' 2);  	codeEST = tokens [4].Substring (4' 2);  	graphic = ss + tokens [4] + ".svg";  	if (entityType == "") {  		id = _cleanString (entity);  		_writeEntity (ref mode' w' id' entity' codeE.Substring (0' 1)' codeE.Substring (1' 1)' graphic);  		w.WriteLine ("");  	} else {  		if (entitySubType == "") {  			id = _cleanString (entityType);  			_writeEntityType (ref mode' w' id' entityType' codeET.Substring (0' 1)' codeET.Substring (1' 1)' graphic);  			w.WriteLine ("");  		} else {  			id = _cleanString (entitySubType);  			_writeEntitySubType (ref mode' w' id' entitySubType' codeEST.Substring (0' 1)' codeEST.Substring (1' 1)' graphic);  			w.WriteLine ("");  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importCSV,The following statement contains a magic number: codeE = tokens [4].Substring (0' 2);  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importCSV,The following statement contains a magic number: codeE = tokens [4].Substring (0' 2);  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importCSV,The following statement contains a magic number: codeET = tokens [4].Substring (2' 2);  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importCSV,The following statement contains a magic number: codeET = tokens [4].Substring (2' 2);  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importCSV,The following statement contains a magic number: codeET = tokens [4].Substring (2' 2);  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importCSV,The following statement contains a magic number: codeEST = tokens [4].Substring (4' 2);  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importCSV,The following statement contains a magic number: codeEST = tokens [4].Substring (4' 2);  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importCSV,The following statement contains a magic number: codeEST = tokens [4].Substring (4' 2);  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importCSV,The following statement contains a magic number: graphic = ss + tokens [4] + ".svg";  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importCSV,The following statement contains a magic number: switch (mode) {  case 1:  	w.WriteLine ("</EntityType>");  	w.WriteLine ("</EntityTypes>");  	break;  case 2:  	w.WriteLine ("</EntitySubTypes>");  	w.WriteLine ("</EntityType>");  	w.WriteLine ("</EntityTypes>");  	break;  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (File.Exists (destination)) {  	SymbolSet ss = _deserializeSymbolSet (destination);  	LibraryDimension dimension = _librarian.Dimension (ss.DimensionID);  	if (ss != null) {  		string code = Convert.ToString (ss.SymbolSetCode.DigitOne) + Convert.ToString (ss.SymbolSetCode.DigitTwo);  		if (code != "") {  			// Open the source file for read.  			if (File.Exists (source)) {  				// Lets build a list of legacy symbols to hold the results  				List<SymbolSetLegacySymbol> legacySymbols = new List<SymbolSetLegacySymbol> ();  				// Now process the input  				string line = "";  				using (StreamReader r = new StreamReader (source)) {  					while (!r.EndOfStream) {  						line = r.ReadLine ();  						string[] tokens = line.Split (''');  						string ssCode = tokens [2];  						string legacyCode = tokens [0];  						string fullLegacyCode = tokens [1];  						string mod1Code = tokens [4];  						string mod2Code = tokens [5];  						string status = tokens [6];  						string remarks = tokens [7];  						// Skip over all rows in the source file that don't match the symbol set code  						// or where the 2525C SIDC field is blank.  						if (ssCode == code && legacyCode != "") {  							// Extract the six character function code from the current 2525C SIDC.  							string functionCode = legacyCode.Substring (legacyCode.Length - 6);  							//string schemaCode = legacyCode.Substring(0' 1);  							//string dimensionCode = legacyCode.Substring(2' 1);  							string entityCode = tokens [3];  							if (entityCode.Length == 6) {  								string eCode = entityCode.Substring (0' 2);  								string etCode = entityCode.Substring (2' 2);  								string estCode = entityCode.Substring (4' 2);  								// Now that we have everything' let's find the pieces in the open symbol set  								SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  								// Find the entity' entity type' and entity subtype for the specified SIDC.  								SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  								if (entity != null) {  									ls.EntityID = entity.ID;  									ls.ID = entity.ID;  									if (etCode != "00") {  										SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  										if (eType != null) {  											ls.EntityTypeID = eType.ID;  											ls.ID = ls.ID + "_" + eType.ID;  											if (estCode != "00") {  												EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  												if (eSubType != null) {  													ls.EntitySubTypeID = eSubType.ID;  													ls.ID = ls.ID + "_" + eSubType.ID;  												}  											}  										}  									}  								}  								// No entities were found' so mark it as retired.  								if (ls.ID == null) {  									ls.ID = "RETIRED";  									ls.Remarks = "Retired";  								}  								// Find the modifier 1 and modifier 2 for the specified SIDC.  								if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  									if (mod1Code.Length == 2) {  										ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  										if (mod != null) {  											ls.ModifierOneID = mod.ID;  											ls.ID = ls.ID + "_" + mod.ID;  										}  									}  								}  								if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  									if (mod2Code.Length == 2) {  										ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  										if (mod != null) {  											ls.ModifierTwoID = mod.ID;  											ls.ID = ls.ID + "_" + mod.ID;  										}  									}  								}  								ls.ID = ls.ID + "_SYM";  								ls.Label = fullLegacyCode;  								// Add the legacy function code  								LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  								lfCode.Name = "2525C";  								if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  									lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  								if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  									lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  								lfCode.Value = functionCode;  								if (status != "")  									lfCode.Description = status;  								if (remarks != "")  									lfCode.Remarks = remarks;  								ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  									lfCode  								};  								// Add it to the current legacy symbol set  								legacySymbols.Add (ls);  							}  						}  					}  					r.Close ();  				}  				// Done processing the input.  If there is anything in our list then add it to the  				// symbol set and re-serialize it.  Remove the existing values if they exist.  				if (legacySymbols.Count > 0) {  					ss.LegacySymbols = legacySymbols.ToArray ();  					// Serialize the symbol set  					_serializeSymbolSet (ss' destination);  				}  			}  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (File.Exists (destination)) {  	SymbolSet ss = _deserializeSymbolSet (destination);  	LibraryDimension dimension = _librarian.Dimension (ss.DimensionID);  	if (ss != null) {  		string code = Convert.ToString (ss.SymbolSetCode.DigitOne) + Convert.ToString (ss.SymbolSetCode.DigitTwo);  		if (code != "") {  			// Open the source file for read.  			if (File.Exists (source)) {  				// Lets build a list of legacy symbols to hold the results  				List<SymbolSetLegacySymbol> legacySymbols = new List<SymbolSetLegacySymbol> ();  				// Now process the input  				string line = "";  				using (StreamReader r = new StreamReader (source)) {  					while (!r.EndOfStream) {  						line = r.ReadLine ();  						string[] tokens = line.Split (''');  						string ssCode = tokens [2];  						string legacyCode = tokens [0];  						string fullLegacyCode = tokens [1];  						string mod1Code = tokens [4];  						string mod2Code = tokens [5];  						string status = tokens [6];  						string remarks = tokens [7];  						// Skip over all rows in the source file that don't match the symbol set code  						// or where the 2525C SIDC field is blank.  						if (ssCode == code && legacyCode != "") {  							// Extract the six character function code from the current 2525C SIDC.  							string functionCode = legacyCode.Substring (legacyCode.Length - 6);  							//string schemaCode = legacyCode.Substring(0' 1);  							//string dimensionCode = legacyCode.Substring(2' 1);  							string entityCode = tokens [3];  							if (entityCode.Length == 6) {  								string eCode = entityCode.Substring (0' 2);  								string etCode = entityCode.Substring (2' 2);  								string estCode = entityCode.Substring (4' 2);  								// Now that we have everything' let's find the pieces in the open symbol set  								SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  								// Find the entity' entity type' and entity subtype for the specified SIDC.  								SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  								if (entity != null) {  									ls.EntityID = entity.ID;  									ls.ID = entity.ID;  									if (etCode != "00") {  										SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  										if (eType != null) {  											ls.EntityTypeID = eType.ID;  											ls.ID = ls.ID + "_" + eType.ID;  											if (estCode != "00") {  												EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  												if (eSubType != null) {  													ls.EntitySubTypeID = eSubType.ID;  													ls.ID = ls.ID + "_" + eSubType.ID;  												}  											}  										}  									}  								}  								// No entities were found' so mark it as retired.  								if (ls.ID == null) {  									ls.ID = "RETIRED";  									ls.Remarks = "Retired";  								}  								// Find the modifier 1 and modifier 2 for the specified SIDC.  								if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  									if (mod1Code.Length == 2) {  										ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  										if (mod != null) {  											ls.ModifierOneID = mod.ID;  											ls.ID = ls.ID + "_" + mod.ID;  										}  									}  								}  								if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  									if (mod2Code.Length == 2) {  										ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  										if (mod != null) {  											ls.ModifierTwoID = mod.ID;  											ls.ID = ls.ID + "_" + mod.ID;  										}  									}  								}  								ls.ID = ls.ID + "_SYM";  								ls.Label = fullLegacyCode;  								// Add the legacy function code  								LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  								lfCode.Name = "2525C";  								if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  									lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  								if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  									lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  								lfCode.Value = functionCode;  								if (status != "")  									lfCode.Description = status;  								if (remarks != "")  									lfCode.Remarks = remarks;  								ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  									lfCode  								};  								// Add it to the current legacy symbol set  								legacySymbols.Add (ls);  							}  						}  					}  					r.Close ();  				}  				// Done processing the input.  If there is anything in our list then add it to the  				// symbol set and re-serialize it.  Remove the existing values if they exist.  				if (legacySymbols.Count > 0) {  					ss.LegacySymbols = legacySymbols.ToArray ();  					// Serialize the symbol set  					_serializeSymbolSet (ss' destination);  				}  			}  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (File.Exists (destination)) {  	SymbolSet ss = _deserializeSymbolSet (destination);  	LibraryDimension dimension = _librarian.Dimension (ss.DimensionID);  	if (ss != null) {  		string code = Convert.ToString (ss.SymbolSetCode.DigitOne) + Convert.ToString (ss.SymbolSetCode.DigitTwo);  		if (code != "") {  			// Open the source file for read.  			if (File.Exists (source)) {  				// Lets build a list of legacy symbols to hold the results  				List<SymbolSetLegacySymbol> legacySymbols = new List<SymbolSetLegacySymbol> ();  				// Now process the input  				string line = "";  				using (StreamReader r = new StreamReader (source)) {  					while (!r.EndOfStream) {  						line = r.ReadLine ();  						string[] tokens = line.Split (''');  						string ssCode = tokens [2];  						string legacyCode = tokens [0];  						string fullLegacyCode = tokens [1];  						string mod1Code = tokens [4];  						string mod2Code = tokens [5];  						string status = tokens [6];  						string remarks = tokens [7];  						// Skip over all rows in the source file that don't match the symbol set code  						// or where the 2525C SIDC field is blank.  						if (ssCode == code && legacyCode != "") {  							// Extract the six character function code from the current 2525C SIDC.  							string functionCode = legacyCode.Substring (legacyCode.Length - 6);  							//string schemaCode = legacyCode.Substring(0' 1);  							//string dimensionCode = legacyCode.Substring(2' 1);  							string entityCode = tokens [3];  							if (entityCode.Length == 6) {  								string eCode = entityCode.Substring (0' 2);  								string etCode = entityCode.Substring (2' 2);  								string estCode = entityCode.Substring (4' 2);  								// Now that we have everything' let's find the pieces in the open symbol set  								SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  								// Find the entity' entity type' and entity subtype for the specified SIDC.  								SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  								if (entity != null) {  									ls.EntityID = entity.ID;  									ls.ID = entity.ID;  									if (etCode != "00") {  										SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  										if (eType != null) {  											ls.EntityTypeID = eType.ID;  											ls.ID = ls.ID + "_" + eType.ID;  											if (estCode != "00") {  												EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  												if (eSubType != null) {  													ls.EntitySubTypeID = eSubType.ID;  													ls.ID = ls.ID + "_" + eSubType.ID;  												}  											}  										}  									}  								}  								// No entities were found' so mark it as retired.  								if (ls.ID == null) {  									ls.ID = "RETIRED";  									ls.Remarks = "Retired";  								}  								// Find the modifier 1 and modifier 2 for the specified SIDC.  								if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  									if (mod1Code.Length == 2) {  										ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  										if (mod != null) {  											ls.ModifierOneID = mod.ID;  											ls.ID = ls.ID + "_" + mod.ID;  										}  									}  								}  								if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  									if (mod2Code.Length == 2) {  										ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  										if (mod != null) {  											ls.ModifierTwoID = mod.ID;  											ls.ID = ls.ID + "_" + mod.ID;  										}  									}  								}  								ls.ID = ls.ID + "_SYM";  								ls.Label = fullLegacyCode;  								// Add the legacy function code  								LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  								lfCode.Name = "2525C";  								if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  									lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  								if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  									lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  								lfCode.Value = functionCode;  								if (status != "")  									lfCode.Description = status;  								if (remarks != "")  									lfCode.Remarks = remarks;  								ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  									lfCode  								};  								// Add it to the current legacy symbol set  								legacySymbols.Add (ls);  							}  						}  					}  					r.Close ();  				}  				// Done processing the input.  If there is anything in our list then add it to the  				// symbol set and re-serialize it.  Remove the existing values if they exist.  				if (legacySymbols.Count > 0) {  					ss.LegacySymbols = legacySymbols.ToArray ();  					// Serialize the symbol set  					_serializeSymbolSet (ss' destination);  				}  			}  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (File.Exists (destination)) {  	SymbolSet ss = _deserializeSymbolSet (destination);  	LibraryDimension dimension = _librarian.Dimension (ss.DimensionID);  	if (ss != null) {  		string code = Convert.ToString (ss.SymbolSetCode.DigitOne) + Convert.ToString (ss.SymbolSetCode.DigitTwo);  		if (code != "") {  			// Open the source file for read.  			if (File.Exists (source)) {  				// Lets build a list of legacy symbols to hold the results  				List<SymbolSetLegacySymbol> legacySymbols = new List<SymbolSetLegacySymbol> ();  				// Now process the input  				string line = "";  				using (StreamReader r = new StreamReader (source)) {  					while (!r.EndOfStream) {  						line = r.ReadLine ();  						string[] tokens = line.Split (''');  						string ssCode = tokens [2];  						string legacyCode = tokens [0];  						string fullLegacyCode = tokens [1];  						string mod1Code = tokens [4];  						string mod2Code = tokens [5];  						string status = tokens [6];  						string remarks = tokens [7];  						// Skip over all rows in the source file that don't match the symbol set code  						// or where the 2525C SIDC field is blank.  						if (ssCode == code && legacyCode != "") {  							// Extract the six character function code from the current 2525C SIDC.  							string functionCode = legacyCode.Substring (legacyCode.Length - 6);  							//string schemaCode = legacyCode.Substring(0' 1);  							//string dimensionCode = legacyCode.Substring(2' 1);  							string entityCode = tokens [3];  							if (entityCode.Length == 6) {  								string eCode = entityCode.Substring (0' 2);  								string etCode = entityCode.Substring (2' 2);  								string estCode = entityCode.Substring (4' 2);  								// Now that we have everything' let's find the pieces in the open symbol set  								SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  								// Find the entity' entity type' and entity subtype for the specified SIDC.  								SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  								if (entity != null) {  									ls.EntityID = entity.ID;  									ls.ID = entity.ID;  									if (etCode != "00") {  										SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  										if (eType != null) {  											ls.EntityTypeID = eType.ID;  											ls.ID = ls.ID + "_" + eType.ID;  											if (estCode != "00") {  												EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  												if (eSubType != null) {  													ls.EntitySubTypeID = eSubType.ID;  													ls.ID = ls.ID + "_" + eSubType.ID;  												}  											}  										}  									}  								}  								// No entities were found' so mark it as retired.  								if (ls.ID == null) {  									ls.ID = "RETIRED";  									ls.Remarks = "Retired";  								}  								// Find the modifier 1 and modifier 2 for the specified SIDC.  								if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  									if (mod1Code.Length == 2) {  										ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  										if (mod != null) {  											ls.ModifierOneID = mod.ID;  											ls.ID = ls.ID + "_" + mod.ID;  										}  									}  								}  								if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  									if (mod2Code.Length == 2) {  										ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  										if (mod != null) {  											ls.ModifierTwoID = mod.ID;  											ls.ID = ls.ID + "_" + mod.ID;  										}  									}  								}  								ls.ID = ls.ID + "_SYM";  								ls.Label = fullLegacyCode;  								// Add the legacy function code  								LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  								lfCode.Name = "2525C";  								if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  									lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  								if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  									lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  								lfCode.Value = functionCode;  								if (status != "")  									lfCode.Description = status;  								if (remarks != "")  									lfCode.Remarks = remarks;  								ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  									lfCode  								};  								// Add it to the current legacy symbol set  								legacySymbols.Add (ls);  							}  						}  					}  					r.Close ();  				}  				// Done processing the input.  If there is anything in our list then add it to the  				// symbol set and re-serialize it.  Remove the existing values if they exist.  				if (legacySymbols.Count > 0) {  					ss.LegacySymbols = legacySymbols.ToArray ();  					// Serialize the symbol set  					_serializeSymbolSet (ss' destination);  				}  			}  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (File.Exists (destination)) {  	SymbolSet ss = _deserializeSymbolSet (destination);  	LibraryDimension dimension = _librarian.Dimension (ss.DimensionID);  	if (ss != null) {  		string code = Convert.ToString (ss.SymbolSetCode.DigitOne) + Convert.ToString (ss.SymbolSetCode.DigitTwo);  		if (code != "") {  			// Open the source file for read.  			if (File.Exists (source)) {  				// Lets build a list of legacy symbols to hold the results  				List<SymbolSetLegacySymbol> legacySymbols = new List<SymbolSetLegacySymbol> ();  				// Now process the input  				string line = "";  				using (StreamReader r = new StreamReader (source)) {  					while (!r.EndOfStream) {  						line = r.ReadLine ();  						string[] tokens = line.Split (''');  						string ssCode = tokens [2];  						string legacyCode = tokens [0];  						string fullLegacyCode = tokens [1];  						string mod1Code = tokens [4];  						string mod2Code = tokens [5];  						string status = tokens [6];  						string remarks = tokens [7];  						// Skip over all rows in the source file that don't match the symbol set code  						// or where the 2525C SIDC field is blank.  						if (ssCode == code && legacyCode != "") {  							// Extract the six character function code from the current 2525C SIDC.  							string functionCode = legacyCode.Substring (legacyCode.Length - 6);  							//string schemaCode = legacyCode.Substring(0' 1);  							//string dimensionCode = legacyCode.Substring(2' 1);  							string entityCode = tokens [3];  							if (entityCode.Length == 6) {  								string eCode = entityCode.Substring (0' 2);  								string etCode = entityCode.Substring (2' 2);  								string estCode = entityCode.Substring (4' 2);  								// Now that we have everything' let's find the pieces in the open symbol set  								SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  								// Find the entity' entity type' and entity subtype for the specified SIDC.  								SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  								if (entity != null) {  									ls.EntityID = entity.ID;  									ls.ID = entity.ID;  									if (etCode != "00") {  										SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  										if (eType != null) {  											ls.EntityTypeID = eType.ID;  											ls.ID = ls.ID + "_" + eType.ID;  											if (estCode != "00") {  												EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  												if (eSubType != null) {  													ls.EntitySubTypeID = eSubType.ID;  													ls.ID = ls.ID + "_" + eSubType.ID;  												}  											}  										}  									}  								}  								// No entities were found' so mark it as retired.  								if (ls.ID == null) {  									ls.ID = "RETIRED";  									ls.Remarks = "Retired";  								}  								// Find the modifier 1 and modifier 2 for the specified SIDC.  								if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  									if (mod1Code.Length == 2) {  										ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  										if (mod != null) {  											ls.ModifierOneID = mod.ID;  											ls.ID = ls.ID + "_" + mod.ID;  										}  									}  								}  								if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  									if (mod2Code.Length == 2) {  										ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  										if (mod != null) {  											ls.ModifierTwoID = mod.ID;  											ls.ID = ls.ID + "_" + mod.ID;  										}  									}  								}  								ls.ID = ls.ID + "_SYM";  								ls.Label = fullLegacyCode;  								// Add the legacy function code  								LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  								lfCode.Name = "2525C";  								if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  									lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  								if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  									lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  								lfCode.Value = functionCode;  								if (status != "")  									lfCode.Description = status;  								if (remarks != "")  									lfCode.Remarks = remarks;  								ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  									lfCode  								};  								// Add it to the current legacy symbol set  								legacySymbols.Add (ls);  							}  						}  					}  					r.Close ();  				}  				// Done processing the input.  If there is anything in our list then add it to the  				// symbol set and re-serialize it.  Remove the existing values if they exist.  				if (legacySymbols.Count > 0) {  					ss.LegacySymbols = legacySymbols.ToArray ();  					// Serialize the symbol set  					_serializeSymbolSet (ss' destination);  				}  			}  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (File.Exists (destination)) {  	SymbolSet ss = _deserializeSymbolSet (destination);  	LibraryDimension dimension = _librarian.Dimension (ss.DimensionID);  	if (ss != null) {  		string code = Convert.ToString (ss.SymbolSetCode.DigitOne) + Convert.ToString (ss.SymbolSetCode.DigitTwo);  		if (code != "") {  			// Open the source file for read.  			if (File.Exists (source)) {  				// Lets build a list of legacy symbols to hold the results  				List<SymbolSetLegacySymbol> legacySymbols = new List<SymbolSetLegacySymbol> ();  				// Now process the input  				string line = "";  				using (StreamReader r = new StreamReader (source)) {  					while (!r.EndOfStream) {  						line = r.ReadLine ();  						string[] tokens = line.Split (''');  						string ssCode = tokens [2];  						string legacyCode = tokens [0];  						string fullLegacyCode = tokens [1];  						string mod1Code = tokens [4];  						string mod2Code = tokens [5];  						string status = tokens [6];  						string remarks = tokens [7];  						// Skip over all rows in the source file that don't match the symbol set code  						// or where the 2525C SIDC field is blank.  						if (ssCode == code && legacyCode != "") {  							// Extract the six character function code from the current 2525C SIDC.  							string functionCode = legacyCode.Substring (legacyCode.Length - 6);  							//string schemaCode = legacyCode.Substring(0' 1);  							//string dimensionCode = legacyCode.Substring(2' 1);  							string entityCode = tokens [3];  							if (entityCode.Length == 6) {  								string eCode = entityCode.Substring (0' 2);  								string etCode = entityCode.Substring (2' 2);  								string estCode = entityCode.Substring (4' 2);  								// Now that we have everything' let's find the pieces in the open symbol set  								SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  								// Find the entity' entity type' and entity subtype for the specified SIDC.  								SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  								if (entity != null) {  									ls.EntityID = entity.ID;  									ls.ID = entity.ID;  									if (etCode != "00") {  										SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  										if (eType != null) {  											ls.EntityTypeID = eType.ID;  											ls.ID = ls.ID + "_" + eType.ID;  											if (estCode != "00") {  												EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  												if (eSubType != null) {  													ls.EntitySubTypeID = eSubType.ID;  													ls.ID = ls.ID + "_" + eSubType.ID;  												}  											}  										}  									}  								}  								// No entities were found' so mark it as retired.  								if (ls.ID == null) {  									ls.ID = "RETIRED";  									ls.Remarks = "Retired";  								}  								// Find the modifier 1 and modifier 2 for the specified SIDC.  								if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  									if (mod1Code.Length == 2) {  										ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  										if (mod != null) {  											ls.ModifierOneID = mod.ID;  											ls.ID = ls.ID + "_" + mod.ID;  										}  									}  								}  								if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  									if (mod2Code.Length == 2) {  										ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  										if (mod != null) {  											ls.ModifierTwoID = mod.ID;  											ls.ID = ls.ID + "_" + mod.ID;  										}  									}  								}  								ls.ID = ls.ID + "_SYM";  								ls.Label = fullLegacyCode;  								// Add the legacy function code  								LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  								lfCode.Name = "2525C";  								if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  									lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  								if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  									lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  								lfCode.Value = functionCode;  								if (status != "")  									lfCode.Description = status;  								if (remarks != "")  									lfCode.Remarks = remarks;  								ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  									lfCode  								};  								// Add it to the current legacy symbol set  								legacySymbols.Add (ls);  							}  						}  					}  					r.Close ();  				}  				// Done processing the input.  If there is anything in our list then add it to the  				// symbol set and re-serialize it.  Remove the existing values if they exist.  				if (legacySymbols.Count > 0) {  					ss.LegacySymbols = legacySymbols.ToArray ();  					// Serialize the symbol set  					_serializeSymbolSet (ss' destination);  				}  			}  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (File.Exists (destination)) {  	SymbolSet ss = _deserializeSymbolSet (destination);  	LibraryDimension dimension = _librarian.Dimension (ss.DimensionID);  	if (ss != null) {  		string code = Convert.ToString (ss.SymbolSetCode.DigitOne) + Convert.ToString (ss.SymbolSetCode.DigitTwo);  		if (code != "") {  			// Open the source file for read.  			if (File.Exists (source)) {  				// Lets build a list of legacy symbols to hold the results  				List<SymbolSetLegacySymbol> legacySymbols = new List<SymbolSetLegacySymbol> ();  				// Now process the input  				string line = "";  				using (StreamReader r = new StreamReader (source)) {  					while (!r.EndOfStream) {  						line = r.ReadLine ();  						string[] tokens = line.Split (''');  						string ssCode = tokens [2];  						string legacyCode = tokens [0];  						string fullLegacyCode = tokens [1];  						string mod1Code = tokens [4];  						string mod2Code = tokens [5];  						string status = tokens [6];  						string remarks = tokens [7];  						// Skip over all rows in the source file that don't match the symbol set code  						// or where the 2525C SIDC field is blank.  						if (ssCode == code && legacyCode != "") {  							// Extract the six character function code from the current 2525C SIDC.  							string functionCode = legacyCode.Substring (legacyCode.Length - 6);  							//string schemaCode = legacyCode.Substring(0' 1);  							//string dimensionCode = legacyCode.Substring(2' 1);  							string entityCode = tokens [3];  							if (entityCode.Length == 6) {  								string eCode = entityCode.Substring (0' 2);  								string etCode = entityCode.Substring (2' 2);  								string estCode = entityCode.Substring (4' 2);  								// Now that we have everything' let's find the pieces in the open symbol set  								SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  								// Find the entity' entity type' and entity subtype for the specified SIDC.  								SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  								if (entity != null) {  									ls.EntityID = entity.ID;  									ls.ID = entity.ID;  									if (etCode != "00") {  										SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  										if (eType != null) {  											ls.EntityTypeID = eType.ID;  											ls.ID = ls.ID + "_" + eType.ID;  											if (estCode != "00") {  												EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  												if (eSubType != null) {  													ls.EntitySubTypeID = eSubType.ID;  													ls.ID = ls.ID + "_" + eSubType.ID;  												}  											}  										}  									}  								}  								// No entities were found' so mark it as retired.  								if (ls.ID == null) {  									ls.ID = "RETIRED";  									ls.Remarks = "Retired";  								}  								// Find the modifier 1 and modifier 2 for the specified SIDC.  								if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  									if (mod1Code.Length == 2) {  										ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  										if (mod != null) {  											ls.ModifierOneID = mod.ID;  											ls.ID = ls.ID + "_" + mod.ID;  										}  									}  								}  								if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  									if (mod2Code.Length == 2) {  										ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  										if (mod != null) {  											ls.ModifierTwoID = mod.ID;  											ls.ID = ls.ID + "_" + mod.ID;  										}  									}  								}  								ls.ID = ls.ID + "_SYM";  								ls.Label = fullLegacyCode;  								// Add the legacy function code  								LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  								lfCode.Name = "2525C";  								if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  									lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  								if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  									lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  								lfCode.Value = functionCode;  								if (status != "")  									lfCode.Description = status;  								if (remarks != "")  									lfCode.Remarks = remarks;  								ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  									lfCode  								};  								// Add it to the current legacy symbol set  								legacySymbols.Add (ls);  							}  						}  					}  					r.Close ();  				}  				// Done processing the input.  If there is anything in our list then add it to the  				// symbol set and re-serialize it.  Remove the existing values if they exist.  				if (legacySymbols.Count > 0) {  					ss.LegacySymbols = legacySymbols.ToArray ();  					// Serialize the symbol set  					_serializeSymbolSet (ss' destination);  				}  			}  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (File.Exists (destination)) {  	SymbolSet ss = _deserializeSymbolSet (destination);  	LibraryDimension dimension = _librarian.Dimension (ss.DimensionID);  	if (ss != null) {  		string code = Convert.ToString (ss.SymbolSetCode.DigitOne) + Convert.ToString (ss.SymbolSetCode.DigitTwo);  		if (code != "") {  			// Open the source file for read.  			if (File.Exists (source)) {  				// Lets build a list of legacy symbols to hold the results  				List<SymbolSetLegacySymbol> legacySymbols = new List<SymbolSetLegacySymbol> ();  				// Now process the input  				string line = "";  				using (StreamReader r = new StreamReader (source)) {  					while (!r.EndOfStream) {  						line = r.ReadLine ();  						string[] tokens = line.Split (''');  						string ssCode = tokens [2];  						string legacyCode = tokens [0];  						string fullLegacyCode = tokens [1];  						string mod1Code = tokens [4];  						string mod2Code = tokens [5];  						string status = tokens [6];  						string remarks = tokens [7];  						// Skip over all rows in the source file that don't match the symbol set code  						// or where the 2525C SIDC field is blank.  						if (ssCode == code && legacyCode != "") {  							// Extract the six character function code from the current 2525C SIDC.  							string functionCode = legacyCode.Substring (legacyCode.Length - 6);  							//string schemaCode = legacyCode.Substring(0' 1);  							//string dimensionCode = legacyCode.Substring(2' 1);  							string entityCode = tokens [3];  							if (entityCode.Length == 6) {  								string eCode = entityCode.Substring (0' 2);  								string etCode = entityCode.Substring (2' 2);  								string estCode = entityCode.Substring (4' 2);  								// Now that we have everything' let's find the pieces in the open symbol set  								SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  								// Find the entity' entity type' and entity subtype for the specified SIDC.  								SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  								if (entity != null) {  									ls.EntityID = entity.ID;  									ls.ID = entity.ID;  									if (etCode != "00") {  										SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  										if (eType != null) {  											ls.EntityTypeID = eType.ID;  											ls.ID = ls.ID + "_" + eType.ID;  											if (estCode != "00") {  												EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  												if (eSubType != null) {  													ls.EntitySubTypeID = eSubType.ID;  													ls.ID = ls.ID + "_" + eSubType.ID;  												}  											}  										}  									}  								}  								// No entities were found' so mark it as retired.  								if (ls.ID == null) {  									ls.ID = "RETIRED";  									ls.Remarks = "Retired";  								}  								// Find the modifier 1 and modifier 2 for the specified SIDC.  								if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  									if (mod1Code.Length == 2) {  										ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  										if (mod != null) {  											ls.ModifierOneID = mod.ID;  											ls.ID = ls.ID + "_" + mod.ID;  										}  									}  								}  								if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  									if (mod2Code.Length == 2) {  										ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  										if (mod != null) {  											ls.ModifierTwoID = mod.ID;  											ls.ID = ls.ID + "_" + mod.ID;  										}  									}  								}  								ls.ID = ls.ID + "_SYM";  								ls.Label = fullLegacyCode;  								// Add the legacy function code  								LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  								lfCode.Name = "2525C";  								if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  									lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  								if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  									lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  								lfCode.Value = functionCode;  								if (status != "")  									lfCode.Description = status;  								if (remarks != "")  									lfCode.Remarks = remarks;  								ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  									lfCode  								};  								// Add it to the current legacy symbol set  								legacySymbols.Add (ls);  							}  						}  					}  					r.Close ();  				}  				// Done processing the input.  If there is anything in our list then add it to the  				// symbol set and re-serialize it.  Remove the existing values if they exist.  				if (legacySymbols.Count > 0) {  					ss.LegacySymbols = legacySymbols.ToArray ();  					// Serialize the symbol set  					_serializeSymbolSet (ss' destination);  				}  			}  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (File.Exists (destination)) {  	SymbolSet ss = _deserializeSymbolSet (destination);  	LibraryDimension dimension = _librarian.Dimension (ss.DimensionID);  	if (ss != null) {  		string code = Convert.ToString (ss.SymbolSetCode.DigitOne) + Convert.ToString (ss.SymbolSetCode.DigitTwo);  		if (code != "") {  			// Open the source file for read.  			if (File.Exists (source)) {  				// Lets build a list of legacy symbols to hold the results  				List<SymbolSetLegacySymbol> legacySymbols = new List<SymbolSetLegacySymbol> ();  				// Now process the input  				string line = "";  				using (StreamReader r = new StreamReader (source)) {  					while (!r.EndOfStream) {  						line = r.ReadLine ();  						string[] tokens = line.Split (''');  						string ssCode = tokens [2];  						string legacyCode = tokens [0];  						string fullLegacyCode = tokens [1];  						string mod1Code = tokens [4];  						string mod2Code = tokens [5];  						string status = tokens [6];  						string remarks = tokens [7];  						// Skip over all rows in the source file that don't match the symbol set code  						// or where the 2525C SIDC field is blank.  						if (ssCode == code && legacyCode != "") {  							// Extract the six character function code from the current 2525C SIDC.  							string functionCode = legacyCode.Substring (legacyCode.Length - 6);  							//string schemaCode = legacyCode.Substring(0' 1);  							//string dimensionCode = legacyCode.Substring(2' 1);  							string entityCode = tokens [3];  							if (entityCode.Length == 6) {  								string eCode = entityCode.Substring (0' 2);  								string etCode = entityCode.Substring (2' 2);  								string estCode = entityCode.Substring (4' 2);  								// Now that we have everything' let's find the pieces in the open symbol set  								SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  								// Find the entity' entity type' and entity subtype for the specified SIDC.  								SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  								if (entity != null) {  									ls.EntityID = entity.ID;  									ls.ID = entity.ID;  									if (etCode != "00") {  										SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  										if (eType != null) {  											ls.EntityTypeID = eType.ID;  											ls.ID = ls.ID + "_" + eType.ID;  											if (estCode != "00") {  												EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  												if (eSubType != null) {  													ls.EntitySubTypeID = eSubType.ID;  													ls.ID = ls.ID + "_" + eSubType.ID;  												}  											}  										}  									}  								}  								// No entities were found' so mark it as retired.  								if (ls.ID == null) {  									ls.ID = "RETIRED";  									ls.Remarks = "Retired";  								}  								// Find the modifier 1 and modifier 2 for the specified SIDC.  								if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  									if (mod1Code.Length == 2) {  										ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  										if (mod != null) {  											ls.ModifierOneID = mod.ID;  											ls.ID = ls.ID + "_" + mod.ID;  										}  									}  								}  								if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  									if (mod2Code.Length == 2) {  										ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  										if (mod != null) {  											ls.ModifierTwoID = mod.ID;  											ls.ID = ls.ID + "_" + mod.ID;  										}  									}  								}  								ls.ID = ls.ID + "_SYM";  								ls.Label = fullLegacyCode;  								// Add the legacy function code  								LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  								lfCode.Name = "2525C";  								if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  									lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  								if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  									lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  								lfCode.Value = functionCode;  								if (status != "")  									lfCode.Description = status;  								if (remarks != "")  									lfCode.Remarks = remarks;  								ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  									lfCode  								};  								// Add it to the current legacy symbol set  								legacySymbols.Add (ls);  							}  						}  					}  					r.Close ();  				}  				// Done processing the input.  If there is anything in our list then add it to the  				// symbol set and re-serialize it.  Remove the existing values if they exist.  				if (legacySymbols.Count > 0) {  					ss.LegacySymbols = legacySymbols.ToArray ();  					// Serialize the symbol set  					_serializeSymbolSet (ss' destination);  				}  			}  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (File.Exists (destination)) {  	SymbolSet ss = _deserializeSymbolSet (destination);  	LibraryDimension dimension = _librarian.Dimension (ss.DimensionID);  	if (ss != null) {  		string code = Convert.ToString (ss.SymbolSetCode.DigitOne) + Convert.ToString (ss.SymbolSetCode.DigitTwo);  		if (code != "") {  			// Open the source file for read.  			if (File.Exists (source)) {  				// Lets build a list of legacy symbols to hold the results  				List<SymbolSetLegacySymbol> legacySymbols = new List<SymbolSetLegacySymbol> ();  				// Now process the input  				string line = "";  				using (StreamReader r = new StreamReader (source)) {  					while (!r.EndOfStream) {  						line = r.ReadLine ();  						string[] tokens = line.Split (''');  						string ssCode = tokens [2];  						string legacyCode = tokens [0];  						string fullLegacyCode = tokens [1];  						string mod1Code = tokens [4];  						string mod2Code = tokens [5];  						string status = tokens [6];  						string remarks = tokens [7];  						// Skip over all rows in the source file that don't match the symbol set code  						// or where the 2525C SIDC field is blank.  						if (ssCode == code && legacyCode != "") {  							// Extract the six character function code from the current 2525C SIDC.  							string functionCode = legacyCode.Substring (legacyCode.Length - 6);  							//string schemaCode = legacyCode.Substring(0' 1);  							//string dimensionCode = legacyCode.Substring(2' 1);  							string entityCode = tokens [3];  							if (entityCode.Length == 6) {  								string eCode = entityCode.Substring (0' 2);  								string etCode = entityCode.Substring (2' 2);  								string estCode = entityCode.Substring (4' 2);  								// Now that we have everything' let's find the pieces in the open symbol set  								SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  								// Find the entity' entity type' and entity subtype for the specified SIDC.  								SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  								if (entity != null) {  									ls.EntityID = entity.ID;  									ls.ID = entity.ID;  									if (etCode != "00") {  										SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  										if (eType != null) {  											ls.EntityTypeID = eType.ID;  											ls.ID = ls.ID + "_" + eType.ID;  											if (estCode != "00") {  												EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  												if (eSubType != null) {  													ls.EntitySubTypeID = eSubType.ID;  													ls.ID = ls.ID + "_" + eSubType.ID;  												}  											}  										}  									}  								}  								// No entities were found' so mark it as retired.  								if (ls.ID == null) {  									ls.ID = "RETIRED";  									ls.Remarks = "Retired";  								}  								// Find the modifier 1 and modifier 2 for the specified SIDC.  								if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  									if (mod1Code.Length == 2) {  										ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  										if (mod != null) {  											ls.ModifierOneID = mod.ID;  											ls.ID = ls.ID + "_" + mod.ID;  										}  									}  								}  								if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  									if (mod2Code.Length == 2) {  										ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  										if (mod != null) {  											ls.ModifierTwoID = mod.ID;  											ls.ID = ls.ID + "_" + mod.ID;  										}  									}  								}  								ls.ID = ls.ID + "_SYM";  								ls.Label = fullLegacyCode;  								// Add the legacy function code  								LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  								lfCode.Name = "2525C";  								if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  									lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  								if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  									lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  								lfCode.Value = functionCode;  								if (status != "")  									lfCode.Description = status;  								if (remarks != "")  									lfCode.Remarks = remarks;  								ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  									lfCode  								};  								// Add it to the current legacy symbol set  								legacySymbols.Add (ls);  							}  						}  					}  					r.Close ();  				}  				// Done processing the input.  If there is anything in our list then add it to the  				// symbol set and re-serialize it.  Remove the existing values if they exist.  				if (legacySymbols.Count > 0) {  					ss.LegacySymbols = legacySymbols.ToArray ();  					// Serialize the symbol set  					_serializeSymbolSet (ss' destination);  				}  			}  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (File.Exists (destination)) {  	SymbolSet ss = _deserializeSymbolSet (destination);  	LibraryDimension dimension = _librarian.Dimension (ss.DimensionID);  	if (ss != null) {  		string code = Convert.ToString (ss.SymbolSetCode.DigitOne) + Convert.ToString (ss.SymbolSetCode.DigitTwo);  		if (code != "") {  			// Open the source file for read.  			if (File.Exists (source)) {  				// Lets build a list of legacy symbols to hold the results  				List<SymbolSetLegacySymbol> legacySymbols = new List<SymbolSetLegacySymbol> ();  				// Now process the input  				string line = "";  				using (StreamReader r = new StreamReader (source)) {  					while (!r.EndOfStream) {  						line = r.ReadLine ();  						string[] tokens = line.Split (''');  						string ssCode = tokens [2];  						string legacyCode = tokens [0];  						string fullLegacyCode = tokens [1];  						string mod1Code = tokens [4];  						string mod2Code = tokens [5];  						string status = tokens [6];  						string remarks = tokens [7];  						// Skip over all rows in the source file that don't match the symbol set code  						// or where the 2525C SIDC field is blank.  						if (ssCode == code && legacyCode != "") {  							// Extract the six character function code from the current 2525C SIDC.  							string functionCode = legacyCode.Substring (legacyCode.Length - 6);  							//string schemaCode = legacyCode.Substring(0' 1);  							//string dimensionCode = legacyCode.Substring(2' 1);  							string entityCode = tokens [3];  							if (entityCode.Length == 6) {  								string eCode = entityCode.Substring (0' 2);  								string etCode = entityCode.Substring (2' 2);  								string estCode = entityCode.Substring (4' 2);  								// Now that we have everything' let's find the pieces in the open symbol set  								SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  								// Find the entity' entity type' and entity subtype for the specified SIDC.  								SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  								if (entity != null) {  									ls.EntityID = entity.ID;  									ls.ID = entity.ID;  									if (etCode != "00") {  										SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  										if (eType != null) {  											ls.EntityTypeID = eType.ID;  											ls.ID = ls.ID + "_" + eType.ID;  											if (estCode != "00") {  												EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  												if (eSubType != null) {  													ls.EntitySubTypeID = eSubType.ID;  													ls.ID = ls.ID + "_" + eSubType.ID;  												}  											}  										}  									}  								}  								// No entities were found' so mark it as retired.  								if (ls.ID == null) {  									ls.ID = "RETIRED";  									ls.Remarks = "Retired";  								}  								// Find the modifier 1 and modifier 2 for the specified SIDC.  								if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  									if (mod1Code.Length == 2) {  										ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  										if (mod != null) {  											ls.ModifierOneID = mod.ID;  											ls.ID = ls.ID + "_" + mod.ID;  										}  									}  								}  								if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  									if (mod2Code.Length == 2) {  										ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  										if (mod != null) {  											ls.ModifierTwoID = mod.ID;  											ls.ID = ls.ID + "_" + mod.ID;  										}  									}  								}  								ls.ID = ls.ID + "_SYM";  								ls.Label = fullLegacyCode;  								// Add the legacy function code  								LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  								lfCode.Name = "2525C";  								if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  									lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  								if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  									lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  								lfCode.Value = functionCode;  								if (status != "")  									lfCode.Description = status;  								if (remarks != "")  									lfCode.Remarks = remarks;  								ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  									lfCode  								};  								// Add it to the current legacy symbol set  								legacySymbols.Add (ls);  							}  						}  					}  					r.Close ();  				}  				// Done processing the input.  If there is anything in our list then add it to the  				// symbol set and re-serialize it.  Remove the existing values if they exist.  				if (legacySymbols.Count > 0) {  					ss.LegacySymbols = legacySymbols.ToArray ();  					// Serialize the symbol set  					_serializeSymbolSet (ss' destination);  				}  			}  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (File.Exists (destination)) {  	SymbolSet ss = _deserializeSymbolSet (destination);  	LibraryDimension dimension = _librarian.Dimension (ss.DimensionID);  	if (ss != null) {  		string code = Convert.ToString (ss.SymbolSetCode.DigitOne) + Convert.ToString (ss.SymbolSetCode.DigitTwo);  		if (code != "") {  			// Open the source file for read.  			if (File.Exists (source)) {  				// Lets build a list of legacy symbols to hold the results  				List<SymbolSetLegacySymbol> legacySymbols = new List<SymbolSetLegacySymbol> ();  				// Now process the input  				string line = "";  				using (StreamReader r = new StreamReader (source)) {  					while (!r.EndOfStream) {  						line = r.ReadLine ();  						string[] tokens = line.Split (''');  						string ssCode = tokens [2];  						string legacyCode = tokens [0];  						string fullLegacyCode = tokens [1];  						string mod1Code = tokens [4];  						string mod2Code = tokens [5];  						string status = tokens [6];  						string remarks = tokens [7];  						// Skip over all rows in the source file that don't match the symbol set code  						// or where the 2525C SIDC field is blank.  						if (ssCode == code && legacyCode != "") {  							// Extract the six character function code from the current 2525C SIDC.  							string functionCode = legacyCode.Substring (legacyCode.Length - 6);  							//string schemaCode = legacyCode.Substring(0' 1);  							//string dimensionCode = legacyCode.Substring(2' 1);  							string entityCode = tokens [3];  							if (entityCode.Length == 6) {  								string eCode = entityCode.Substring (0' 2);  								string etCode = entityCode.Substring (2' 2);  								string estCode = entityCode.Substring (4' 2);  								// Now that we have everything' let's find the pieces in the open symbol set  								SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  								// Find the entity' entity type' and entity subtype for the specified SIDC.  								SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  								if (entity != null) {  									ls.EntityID = entity.ID;  									ls.ID = entity.ID;  									if (etCode != "00") {  										SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  										if (eType != null) {  											ls.EntityTypeID = eType.ID;  											ls.ID = ls.ID + "_" + eType.ID;  											if (estCode != "00") {  												EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  												if (eSubType != null) {  													ls.EntitySubTypeID = eSubType.ID;  													ls.ID = ls.ID + "_" + eSubType.ID;  												}  											}  										}  									}  								}  								// No entities were found' so mark it as retired.  								if (ls.ID == null) {  									ls.ID = "RETIRED";  									ls.Remarks = "Retired";  								}  								// Find the modifier 1 and modifier 2 for the specified SIDC.  								if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  									if (mod1Code.Length == 2) {  										ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  										if (mod != null) {  											ls.ModifierOneID = mod.ID;  											ls.ID = ls.ID + "_" + mod.ID;  										}  									}  								}  								if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  									if (mod2Code.Length == 2) {  										ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  										if (mod != null) {  											ls.ModifierTwoID = mod.ID;  											ls.ID = ls.ID + "_" + mod.ID;  										}  									}  								}  								ls.ID = ls.ID + "_SYM";  								ls.Label = fullLegacyCode;  								// Add the legacy function code  								LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  								lfCode.Name = "2525C";  								if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  									lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  								if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  									lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  								lfCode.Value = functionCode;  								if (status != "")  									lfCode.Description = status;  								if (remarks != "")  									lfCode.Remarks = remarks;  								ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  									lfCode  								};  								// Add it to the current legacy symbol set  								legacySymbols.Add (ls);  							}  						}  					}  					r.Close ();  				}  				// Done processing the input.  If there is anything in our list then add it to the  				// symbol set and re-serialize it.  Remove the existing values if they exist.  				if (legacySymbols.Count > 0) {  					ss.LegacySymbols = legacySymbols.ToArray ();  					// Serialize the symbol set  					_serializeSymbolSet (ss' destination);  				}  			}  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (File.Exists (destination)) {  	SymbolSet ss = _deserializeSymbolSet (destination);  	LibraryDimension dimension = _librarian.Dimension (ss.DimensionID);  	if (ss != null) {  		string code = Convert.ToString (ss.SymbolSetCode.DigitOne) + Convert.ToString (ss.SymbolSetCode.DigitTwo);  		if (code != "") {  			// Open the source file for read.  			if (File.Exists (source)) {  				// Lets build a list of legacy symbols to hold the results  				List<SymbolSetLegacySymbol> legacySymbols = new List<SymbolSetLegacySymbol> ();  				// Now process the input  				string line = "";  				using (StreamReader r = new StreamReader (source)) {  					while (!r.EndOfStream) {  						line = r.ReadLine ();  						string[] tokens = line.Split (''');  						string ssCode = tokens [2];  						string legacyCode = tokens [0];  						string fullLegacyCode = tokens [1];  						string mod1Code = tokens [4];  						string mod2Code = tokens [5];  						string status = tokens [6];  						string remarks = tokens [7];  						// Skip over all rows in the source file that don't match the symbol set code  						// or where the 2525C SIDC field is blank.  						if (ssCode == code && legacyCode != "") {  							// Extract the six character function code from the current 2525C SIDC.  							string functionCode = legacyCode.Substring (legacyCode.Length - 6);  							//string schemaCode = legacyCode.Substring(0' 1);  							//string dimensionCode = legacyCode.Substring(2' 1);  							string entityCode = tokens [3];  							if (entityCode.Length == 6) {  								string eCode = entityCode.Substring (0' 2);  								string etCode = entityCode.Substring (2' 2);  								string estCode = entityCode.Substring (4' 2);  								// Now that we have everything' let's find the pieces in the open symbol set  								SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  								// Find the entity' entity type' and entity subtype for the specified SIDC.  								SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  								if (entity != null) {  									ls.EntityID = entity.ID;  									ls.ID = entity.ID;  									if (etCode != "00") {  										SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  										if (eType != null) {  											ls.EntityTypeID = eType.ID;  											ls.ID = ls.ID + "_" + eType.ID;  											if (estCode != "00") {  												EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  												if (eSubType != null) {  													ls.EntitySubTypeID = eSubType.ID;  													ls.ID = ls.ID + "_" + eSubType.ID;  												}  											}  										}  									}  								}  								// No entities were found' so mark it as retired.  								if (ls.ID == null) {  									ls.ID = "RETIRED";  									ls.Remarks = "Retired";  								}  								// Find the modifier 1 and modifier 2 for the specified SIDC.  								if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  									if (mod1Code.Length == 2) {  										ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  										if (mod != null) {  											ls.ModifierOneID = mod.ID;  											ls.ID = ls.ID + "_" + mod.ID;  										}  									}  								}  								if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  									if (mod2Code.Length == 2) {  										ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  										if (mod != null) {  											ls.ModifierTwoID = mod.ID;  											ls.ID = ls.ID + "_" + mod.ID;  										}  									}  								}  								ls.ID = ls.ID + "_SYM";  								ls.Label = fullLegacyCode;  								// Add the legacy function code  								LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  								lfCode.Name = "2525C";  								if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  									lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  								if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  									lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  								lfCode.Value = functionCode;  								if (status != "")  									lfCode.Description = status;  								if (remarks != "")  									lfCode.Remarks = remarks;  								ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  									lfCode  								};  								// Add it to the current legacy symbol set  								legacySymbols.Add (ls);  							}  						}  					}  					r.Close ();  				}  				// Done processing the input.  If there is anything in our list then add it to the  				// symbol set and re-serialize it.  Remove the existing values if they exist.  				if (legacySymbols.Count > 0) {  					ss.LegacySymbols = legacySymbols.ToArray ();  					// Serialize the symbol set  					_serializeSymbolSet (ss' destination);  				}  			}  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (File.Exists (destination)) {  	SymbolSet ss = _deserializeSymbolSet (destination);  	LibraryDimension dimension = _librarian.Dimension (ss.DimensionID);  	if (ss != null) {  		string code = Convert.ToString (ss.SymbolSetCode.DigitOne) + Convert.ToString (ss.SymbolSetCode.DigitTwo);  		if (code != "") {  			// Open the source file for read.  			if (File.Exists (source)) {  				// Lets build a list of legacy symbols to hold the results  				List<SymbolSetLegacySymbol> legacySymbols = new List<SymbolSetLegacySymbol> ();  				// Now process the input  				string line = "";  				using (StreamReader r = new StreamReader (source)) {  					while (!r.EndOfStream) {  						line = r.ReadLine ();  						string[] tokens = line.Split (''');  						string ssCode = tokens [2];  						string legacyCode = tokens [0];  						string fullLegacyCode = tokens [1];  						string mod1Code = tokens [4];  						string mod2Code = tokens [5];  						string status = tokens [6];  						string remarks = tokens [7];  						// Skip over all rows in the source file that don't match the symbol set code  						// or where the 2525C SIDC field is blank.  						if (ssCode == code && legacyCode != "") {  							// Extract the six character function code from the current 2525C SIDC.  							string functionCode = legacyCode.Substring (legacyCode.Length - 6);  							//string schemaCode = legacyCode.Substring(0' 1);  							//string dimensionCode = legacyCode.Substring(2' 1);  							string entityCode = tokens [3];  							if (entityCode.Length == 6) {  								string eCode = entityCode.Substring (0' 2);  								string etCode = entityCode.Substring (2' 2);  								string estCode = entityCode.Substring (4' 2);  								// Now that we have everything' let's find the pieces in the open symbol set  								SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  								// Find the entity' entity type' and entity subtype for the specified SIDC.  								SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  								if (entity != null) {  									ls.EntityID = entity.ID;  									ls.ID = entity.ID;  									if (etCode != "00") {  										SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  										if (eType != null) {  											ls.EntityTypeID = eType.ID;  											ls.ID = ls.ID + "_" + eType.ID;  											if (estCode != "00") {  												EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  												if (eSubType != null) {  													ls.EntitySubTypeID = eSubType.ID;  													ls.ID = ls.ID + "_" + eSubType.ID;  												}  											}  										}  									}  								}  								// No entities were found' so mark it as retired.  								if (ls.ID == null) {  									ls.ID = "RETIRED";  									ls.Remarks = "Retired";  								}  								// Find the modifier 1 and modifier 2 for the specified SIDC.  								if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  									if (mod1Code.Length == 2) {  										ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  										if (mod != null) {  											ls.ModifierOneID = mod.ID;  											ls.ID = ls.ID + "_" + mod.ID;  										}  									}  								}  								if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  									if (mod2Code.Length == 2) {  										ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  										if (mod != null) {  											ls.ModifierTwoID = mod.ID;  											ls.ID = ls.ID + "_" + mod.ID;  										}  									}  								}  								ls.ID = ls.ID + "_SYM";  								ls.Label = fullLegacyCode;  								// Add the legacy function code  								LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  								lfCode.Name = "2525C";  								if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  									lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  								if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  									lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  								lfCode.Value = functionCode;  								if (status != "")  									lfCode.Description = status;  								if (remarks != "")  									lfCode.Remarks = remarks;  								ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  									lfCode  								};  								// Add it to the current legacy symbol set  								legacySymbols.Add (ls);  							}  						}  					}  					r.Close ();  				}  				// Done processing the input.  If there is anything in our list then add it to the  				// symbol set and re-serialize it.  Remove the existing values if they exist.  				if (legacySymbols.Count > 0) {  					ss.LegacySymbols = legacySymbols.ToArray ();  					// Serialize the symbol set  					_serializeSymbolSet (ss' destination);  				}  			}  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (File.Exists (destination)) {  	SymbolSet ss = _deserializeSymbolSet (destination);  	LibraryDimension dimension = _librarian.Dimension (ss.DimensionID);  	if (ss != null) {  		string code = Convert.ToString (ss.SymbolSetCode.DigitOne) + Convert.ToString (ss.SymbolSetCode.DigitTwo);  		if (code != "") {  			// Open the source file for read.  			if (File.Exists (source)) {  				// Lets build a list of legacy symbols to hold the results  				List<SymbolSetLegacySymbol> legacySymbols = new List<SymbolSetLegacySymbol> ();  				// Now process the input  				string line = "";  				using (StreamReader r = new StreamReader (source)) {  					while (!r.EndOfStream) {  						line = r.ReadLine ();  						string[] tokens = line.Split (''');  						string ssCode = tokens [2];  						string legacyCode = tokens [0];  						string fullLegacyCode = tokens [1];  						string mod1Code = tokens [4];  						string mod2Code = tokens [5];  						string status = tokens [6];  						string remarks = tokens [7];  						// Skip over all rows in the source file that don't match the symbol set code  						// or where the 2525C SIDC field is blank.  						if (ssCode == code && legacyCode != "") {  							// Extract the six character function code from the current 2525C SIDC.  							string functionCode = legacyCode.Substring (legacyCode.Length - 6);  							//string schemaCode = legacyCode.Substring(0' 1);  							//string dimensionCode = legacyCode.Substring(2' 1);  							string entityCode = tokens [3];  							if (entityCode.Length == 6) {  								string eCode = entityCode.Substring (0' 2);  								string etCode = entityCode.Substring (2' 2);  								string estCode = entityCode.Substring (4' 2);  								// Now that we have everything' let's find the pieces in the open symbol set  								SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  								// Find the entity' entity type' and entity subtype for the specified SIDC.  								SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  								if (entity != null) {  									ls.EntityID = entity.ID;  									ls.ID = entity.ID;  									if (etCode != "00") {  										SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  										if (eType != null) {  											ls.EntityTypeID = eType.ID;  											ls.ID = ls.ID + "_" + eType.ID;  											if (estCode != "00") {  												EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  												if (eSubType != null) {  													ls.EntitySubTypeID = eSubType.ID;  													ls.ID = ls.ID + "_" + eSubType.ID;  												}  											}  										}  									}  								}  								// No entities were found' so mark it as retired.  								if (ls.ID == null) {  									ls.ID = "RETIRED";  									ls.Remarks = "Retired";  								}  								// Find the modifier 1 and modifier 2 for the specified SIDC.  								if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  									if (mod1Code.Length == 2) {  										ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  										if (mod != null) {  											ls.ModifierOneID = mod.ID;  											ls.ID = ls.ID + "_" + mod.ID;  										}  									}  								}  								if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  									if (mod2Code.Length == 2) {  										ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  										if (mod != null) {  											ls.ModifierTwoID = mod.ID;  											ls.ID = ls.ID + "_" + mod.ID;  										}  									}  								}  								ls.ID = ls.ID + "_SYM";  								ls.Label = fullLegacyCode;  								// Add the legacy function code  								LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  								lfCode.Name = "2525C";  								if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  									lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  								if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  									lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  								lfCode.Value = functionCode;  								if (status != "")  									lfCode.Description = status;  								if (remarks != "")  									lfCode.Remarks = remarks;  								ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  									lfCode  								};  								// Add it to the current legacy symbol set  								legacySymbols.Add (ls);  							}  						}  					}  					r.Close ();  				}  				// Done processing the input.  If there is anything in our list then add it to the  				// symbol set and re-serialize it.  Remove the existing values if they exist.  				if (legacySymbols.Count > 0) {  					ss.LegacySymbols = legacySymbols.ToArray ();  					// Serialize the symbol set  					_serializeSymbolSet (ss' destination);  				}  			}  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (File.Exists (destination)) {  	SymbolSet ss = _deserializeSymbolSet (destination);  	LibraryDimension dimension = _librarian.Dimension (ss.DimensionID);  	if (ss != null) {  		string code = Convert.ToString (ss.SymbolSetCode.DigitOne) + Convert.ToString (ss.SymbolSetCode.DigitTwo);  		if (code != "") {  			// Open the source file for read.  			if (File.Exists (source)) {  				// Lets build a list of legacy symbols to hold the results  				List<SymbolSetLegacySymbol> legacySymbols = new List<SymbolSetLegacySymbol> ();  				// Now process the input  				string line = "";  				using (StreamReader r = new StreamReader (source)) {  					while (!r.EndOfStream) {  						line = r.ReadLine ();  						string[] tokens = line.Split (''');  						string ssCode = tokens [2];  						string legacyCode = tokens [0];  						string fullLegacyCode = tokens [1];  						string mod1Code = tokens [4];  						string mod2Code = tokens [5];  						string status = tokens [6];  						string remarks = tokens [7];  						// Skip over all rows in the source file that don't match the symbol set code  						// or where the 2525C SIDC field is blank.  						if (ssCode == code && legacyCode != "") {  							// Extract the six character function code from the current 2525C SIDC.  							string functionCode = legacyCode.Substring (legacyCode.Length - 6);  							//string schemaCode = legacyCode.Substring(0' 1);  							//string dimensionCode = legacyCode.Substring(2' 1);  							string entityCode = tokens [3];  							if (entityCode.Length == 6) {  								string eCode = entityCode.Substring (0' 2);  								string etCode = entityCode.Substring (2' 2);  								string estCode = entityCode.Substring (4' 2);  								// Now that we have everything' let's find the pieces in the open symbol set  								SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  								// Find the entity' entity type' and entity subtype for the specified SIDC.  								SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  								if (entity != null) {  									ls.EntityID = entity.ID;  									ls.ID = entity.ID;  									if (etCode != "00") {  										SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  										if (eType != null) {  											ls.EntityTypeID = eType.ID;  											ls.ID = ls.ID + "_" + eType.ID;  											if (estCode != "00") {  												EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  												if (eSubType != null) {  													ls.EntitySubTypeID = eSubType.ID;  													ls.ID = ls.ID + "_" + eSubType.ID;  												}  											}  										}  									}  								}  								// No entities were found' so mark it as retired.  								if (ls.ID == null) {  									ls.ID = "RETIRED";  									ls.Remarks = "Retired";  								}  								// Find the modifier 1 and modifier 2 for the specified SIDC.  								if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  									if (mod1Code.Length == 2) {  										ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  										if (mod != null) {  											ls.ModifierOneID = mod.ID;  											ls.ID = ls.ID + "_" + mod.ID;  										}  									}  								}  								if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  									if (mod2Code.Length == 2) {  										ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  										if (mod != null) {  											ls.ModifierTwoID = mod.ID;  											ls.ID = ls.ID + "_" + mod.ID;  										}  									}  								}  								ls.ID = ls.ID + "_SYM";  								ls.Label = fullLegacyCode;  								// Add the legacy function code  								LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  								lfCode.Name = "2525C";  								if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  									lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  								if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  									lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  								lfCode.Value = functionCode;  								if (status != "")  									lfCode.Description = status;  								if (remarks != "")  									lfCode.Remarks = remarks;  								ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  									lfCode  								};  								// Add it to the current legacy symbol set  								legacySymbols.Add (ls);  							}  						}  					}  					r.Close ();  				}  				// Done processing the input.  If there is anything in our list then add it to the  				// symbol set and re-serialize it.  Remove the existing values if they exist.  				if (legacySymbols.Count > 0) {  					ss.LegacySymbols = legacySymbols.ToArray ();  					// Serialize the symbol set  					_serializeSymbolSet (ss' destination);  				}  			}  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (File.Exists (destination)) {  	SymbolSet ss = _deserializeSymbolSet (destination);  	LibraryDimension dimension = _librarian.Dimension (ss.DimensionID);  	if (ss != null) {  		string code = Convert.ToString (ss.SymbolSetCode.DigitOne) + Convert.ToString (ss.SymbolSetCode.DigitTwo);  		if (code != "") {  			// Open the source file for read.  			if (File.Exists (source)) {  				// Lets build a list of legacy symbols to hold the results  				List<SymbolSetLegacySymbol> legacySymbols = new List<SymbolSetLegacySymbol> ();  				// Now process the input  				string line = "";  				using (StreamReader r = new StreamReader (source)) {  					while (!r.EndOfStream) {  						line = r.ReadLine ();  						string[] tokens = line.Split (''');  						string ssCode = tokens [2];  						string legacyCode = tokens [0];  						string fullLegacyCode = tokens [1];  						string mod1Code = tokens [4];  						string mod2Code = tokens [5];  						string status = tokens [6];  						string remarks = tokens [7];  						// Skip over all rows in the source file that don't match the symbol set code  						// or where the 2525C SIDC field is blank.  						if (ssCode == code && legacyCode != "") {  							// Extract the six character function code from the current 2525C SIDC.  							string functionCode = legacyCode.Substring (legacyCode.Length - 6);  							//string schemaCode = legacyCode.Substring(0' 1);  							//string dimensionCode = legacyCode.Substring(2' 1);  							string entityCode = tokens [3];  							if (entityCode.Length == 6) {  								string eCode = entityCode.Substring (0' 2);  								string etCode = entityCode.Substring (2' 2);  								string estCode = entityCode.Substring (4' 2);  								// Now that we have everything' let's find the pieces in the open symbol set  								SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  								// Find the entity' entity type' and entity subtype for the specified SIDC.  								SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  								if (entity != null) {  									ls.EntityID = entity.ID;  									ls.ID = entity.ID;  									if (etCode != "00") {  										SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  										if (eType != null) {  											ls.EntityTypeID = eType.ID;  											ls.ID = ls.ID + "_" + eType.ID;  											if (estCode != "00") {  												EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  												if (eSubType != null) {  													ls.EntitySubTypeID = eSubType.ID;  													ls.ID = ls.ID + "_" + eSubType.ID;  												}  											}  										}  									}  								}  								// No entities were found' so mark it as retired.  								if (ls.ID == null) {  									ls.ID = "RETIRED";  									ls.Remarks = "Retired";  								}  								// Find the modifier 1 and modifier 2 for the specified SIDC.  								if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  									if (mod1Code.Length == 2) {  										ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  										if (mod != null) {  											ls.ModifierOneID = mod.ID;  											ls.ID = ls.ID + "_" + mod.ID;  										}  									}  								}  								if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  									if (mod2Code.Length == 2) {  										ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  										if (mod != null) {  											ls.ModifierTwoID = mod.ID;  											ls.ID = ls.ID + "_" + mod.ID;  										}  									}  								}  								ls.ID = ls.ID + "_SYM";  								ls.Label = fullLegacyCode;  								// Add the legacy function code  								LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  								lfCode.Name = "2525C";  								if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  									lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  								if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  									lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  								lfCode.Value = functionCode;  								if (status != "")  									lfCode.Description = status;  								if (remarks != "")  									lfCode.Remarks = remarks;  								ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  									lfCode  								};  								// Add it to the current legacy symbol set  								legacySymbols.Add (ls);  							}  						}  					}  					r.Close ();  				}  				// Done processing the input.  If there is anything in our list then add it to the  				// symbol set and re-serialize it.  Remove the existing values if they exist.  				if (legacySymbols.Count > 0) {  					ss.LegacySymbols = legacySymbols.ToArray ();  					// Serialize the symbol set  					_serializeSymbolSet (ss' destination);  				}  			}  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (ss != null) {  	string code = Convert.ToString (ss.SymbolSetCode.DigitOne) + Convert.ToString (ss.SymbolSetCode.DigitTwo);  	if (code != "") {  		// Open the source file for read.  		if (File.Exists (source)) {  			// Lets build a list of legacy symbols to hold the results  			List<SymbolSetLegacySymbol> legacySymbols = new List<SymbolSetLegacySymbol> ();  			// Now process the input  			string line = "";  			using (StreamReader r = new StreamReader (source)) {  				while (!r.EndOfStream) {  					line = r.ReadLine ();  					string[] tokens = line.Split (''');  					string ssCode = tokens [2];  					string legacyCode = tokens [0];  					string fullLegacyCode = tokens [1];  					string mod1Code = tokens [4];  					string mod2Code = tokens [5];  					string status = tokens [6];  					string remarks = tokens [7];  					// Skip over all rows in the source file that don't match the symbol set code  					// or where the 2525C SIDC field is blank.  					if (ssCode == code && legacyCode != "") {  						// Extract the six character function code from the current 2525C SIDC.  						string functionCode = legacyCode.Substring (legacyCode.Length - 6);  						//string schemaCode = legacyCode.Substring(0' 1);  						//string dimensionCode = legacyCode.Substring(2' 1);  						string entityCode = tokens [3];  						if (entityCode.Length == 6) {  							string eCode = entityCode.Substring (0' 2);  							string etCode = entityCode.Substring (2' 2);  							string estCode = entityCode.Substring (4' 2);  							// Now that we have everything' let's find the pieces in the open symbol set  							SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  							// Find the entity' entity type' and entity subtype for the specified SIDC.  							SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  							if (entity != null) {  								ls.EntityID = entity.ID;  								ls.ID = entity.ID;  								if (etCode != "00") {  									SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  									if (eType != null) {  										ls.EntityTypeID = eType.ID;  										ls.ID = ls.ID + "_" + eType.ID;  										if (estCode != "00") {  											EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  											if (eSubType != null) {  												ls.EntitySubTypeID = eSubType.ID;  												ls.ID = ls.ID + "_" + eSubType.ID;  											}  										}  									}  								}  							}  							// No entities were found' so mark it as retired.  							if (ls.ID == null) {  								ls.ID = "RETIRED";  								ls.Remarks = "Retired";  							}  							// Find the modifier 1 and modifier 2 for the specified SIDC.  							if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  								if (mod1Code.Length == 2) {  									ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  									if (mod != null) {  										ls.ModifierOneID = mod.ID;  										ls.ID = ls.ID + "_" + mod.ID;  									}  								}  							}  							if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  								if (mod2Code.Length == 2) {  									ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  									if (mod != null) {  										ls.ModifierTwoID = mod.ID;  										ls.ID = ls.ID + "_" + mod.ID;  									}  								}  							}  							ls.ID = ls.ID + "_SYM";  							ls.Label = fullLegacyCode;  							// Add the legacy function code  							LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  							lfCode.Name = "2525C";  							if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  								lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  							if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  								lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  							lfCode.Value = functionCode;  							if (status != "")  								lfCode.Description = status;  							if (remarks != "")  								lfCode.Remarks = remarks;  							ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  								lfCode  							};  							// Add it to the current legacy symbol set  							legacySymbols.Add (ls);  						}  					}  				}  				r.Close ();  			}  			// Done processing the input.  If there is anything in our list then add it to the  			// symbol set and re-serialize it.  Remove the existing values if they exist.  			if (legacySymbols.Count > 0) {  				ss.LegacySymbols = legacySymbols.ToArray ();  				// Serialize the symbol set  				_serializeSymbolSet (ss' destination);  			}  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (ss != null) {  	string code = Convert.ToString (ss.SymbolSetCode.DigitOne) + Convert.ToString (ss.SymbolSetCode.DigitTwo);  	if (code != "") {  		// Open the source file for read.  		if (File.Exists (source)) {  			// Lets build a list of legacy symbols to hold the results  			List<SymbolSetLegacySymbol> legacySymbols = new List<SymbolSetLegacySymbol> ();  			// Now process the input  			string line = "";  			using (StreamReader r = new StreamReader (source)) {  				while (!r.EndOfStream) {  					line = r.ReadLine ();  					string[] tokens = line.Split (''');  					string ssCode = tokens [2];  					string legacyCode = tokens [0];  					string fullLegacyCode = tokens [1];  					string mod1Code = tokens [4];  					string mod2Code = tokens [5];  					string status = tokens [6];  					string remarks = tokens [7];  					// Skip over all rows in the source file that don't match the symbol set code  					// or where the 2525C SIDC field is blank.  					if (ssCode == code && legacyCode != "") {  						// Extract the six character function code from the current 2525C SIDC.  						string functionCode = legacyCode.Substring (legacyCode.Length - 6);  						//string schemaCode = legacyCode.Substring(0' 1);  						//string dimensionCode = legacyCode.Substring(2' 1);  						string entityCode = tokens [3];  						if (entityCode.Length == 6) {  							string eCode = entityCode.Substring (0' 2);  							string etCode = entityCode.Substring (2' 2);  							string estCode = entityCode.Substring (4' 2);  							// Now that we have everything' let's find the pieces in the open symbol set  							SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  							// Find the entity' entity type' and entity subtype for the specified SIDC.  							SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  							if (entity != null) {  								ls.EntityID = entity.ID;  								ls.ID = entity.ID;  								if (etCode != "00") {  									SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  									if (eType != null) {  										ls.EntityTypeID = eType.ID;  										ls.ID = ls.ID + "_" + eType.ID;  										if (estCode != "00") {  											EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  											if (eSubType != null) {  												ls.EntitySubTypeID = eSubType.ID;  												ls.ID = ls.ID + "_" + eSubType.ID;  											}  										}  									}  								}  							}  							// No entities were found' so mark it as retired.  							if (ls.ID == null) {  								ls.ID = "RETIRED";  								ls.Remarks = "Retired";  							}  							// Find the modifier 1 and modifier 2 for the specified SIDC.  							if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  								if (mod1Code.Length == 2) {  									ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  									if (mod != null) {  										ls.ModifierOneID = mod.ID;  										ls.ID = ls.ID + "_" + mod.ID;  									}  								}  							}  							if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  								if (mod2Code.Length == 2) {  									ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  									if (mod != null) {  										ls.ModifierTwoID = mod.ID;  										ls.ID = ls.ID + "_" + mod.ID;  									}  								}  							}  							ls.ID = ls.ID + "_SYM";  							ls.Label = fullLegacyCode;  							// Add the legacy function code  							LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  							lfCode.Name = "2525C";  							if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  								lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  							if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  								lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  							lfCode.Value = functionCode;  							if (status != "")  								lfCode.Description = status;  							if (remarks != "")  								lfCode.Remarks = remarks;  							ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  								lfCode  							};  							// Add it to the current legacy symbol set  							legacySymbols.Add (ls);  						}  					}  				}  				r.Close ();  			}  			// Done processing the input.  If there is anything in our list then add it to the  			// symbol set and re-serialize it.  Remove the existing values if they exist.  			if (legacySymbols.Count > 0) {  				ss.LegacySymbols = legacySymbols.ToArray ();  				// Serialize the symbol set  				_serializeSymbolSet (ss' destination);  			}  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (ss != null) {  	string code = Convert.ToString (ss.SymbolSetCode.DigitOne) + Convert.ToString (ss.SymbolSetCode.DigitTwo);  	if (code != "") {  		// Open the source file for read.  		if (File.Exists (source)) {  			// Lets build a list of legacy symbols to hold the results  			List<SymbolSetLegacySymbol> legacySymbols = new List<SymbolSetLegacySymbol> ();  			// Now process the input  			string line = "";  			using (StreamReader r = new StreamReader (source)) {  				while (!r.EndOfStream) {  					line = r.ReadLine ();  					string[] tokens = line.Split (''');  					string ssCode = tokens [2];  					string legacyCode = tokens [0];  					string fullLegacyCode = tokens [1];  					string mod1Code = tokens [4];  					string mod2Code = tokens [5];  					string status = tokens [6];  					string remarks = tokens [7];  					// Skip over all rows in the source file that don't match the symbol set code  					// or where the 2525C SIDC field is blank.  					if (ssCode == code && legacyCode != "") {  						// Extract the six character function code from the current 2525C SIDC.  						string functionCode = legacyCode.Substring (legacyCode.Length - 6);  						//string schemaCode = legacyCode.Substring(0' 1);  						//string dimensionCode = legacyCode.Substring(2' 1);  						string entityCode = tokens [3];  						if (entityCode.Length == 6) {  							string eCode = entityCode.Substring (0' 2);  							string etCode = entityCode.Substring (2' 2);  							string estCode = entityCode.Substring (4' 2);  							// Now that we have everything' let's find the pieces in the open symbol set  							SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  							// Find the entity' entity type' and entity subtype for the specified SIDC.  							SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  							if (entity != null) {  								ls.EntityID = entity.ID;  								ls.ID = entity.ID;  								if (etCode != "00") {  									SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  									if (eType != null) {  										ls.EntityTypeID = eType.ID;  										ls.ID = ls.ID + "_" + eType.ID;  										if (estCode != "00") {  											EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  											if (eSubType != null) {  												ls.EntitySubTypeID = eSubType.ID;  												ls.ID = ls.ID + "_" + eSubType.ID;  											}  										}  									}  								}  							}  							// No entities were found' so mark it as retired.  							if (ls.ID == null) {  								ls.ID = "RETIRED";  								ls.Remarks = "Retired";  							}  							// Find the modifier 1 and modifier 2 for the specified SIDC.  							if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  								if (mod1Code.Length == 2) {  									ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  									if (mod != null) {  										ls.ModifierOneID = mod.ID;  										ls.ID = ls.ID + "_" + mod.ID;  									}  								}  							}  							if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  								if (mod2Code.Length == 2) {  									ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  									if (mod != null) {  										ls.ModifierTwoID = mod.ID;  										ls.ID = ls.ID + "_" + mod.ID;  									}  								}  							}  							ls.ID = ls.ID + "_SYM";  							ls.Label = fullLegacyCode;  							// Add the legacy function code  							LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  							lfCode.Name = "2525C";  							if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  								lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  							if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  								lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  							lfCode.Value = functionCode;  							if (status != "")  								lfCode.Description = status;  							if (remarks != "")  								lfCode.Remarks = remarks;  							ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  								lfCode  							};  							// Add it to the current legacy symbol set  							legacySymbols.Add (ls);  						}  					}  				}  				r.Close ();  			}  			// Done processing the input.  If there is anything in our list then add it to the  			// symbol set and re-serialize it.  Remove the existing values if they exist.  			if (legacySymbols.Count > 0) {  				ss.LegacySymbols = legacySymbols.ToArray ();  				// Serialize the symbol set  				_serializeSymbolSet (ss' destination);  			}  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (ss != null) {  	string code = Convert.ToString (ss.SymbolSetCode.DigitOne) + Convert.ToString (ss.SymbolSetCode.DigitTwo);  	if (code != "") {  		// Open the source file for read.  		if (File.Exists (source)) {  			// Lets build a list of legacy symbols to hold the results  			List<SymbolSetLegacySymbol> legacySymbols = new List<SymbolSetLegacySymbol> ();  			// Now process the input  			string line = "";  			using (StreamReader r = new StreamReader (source)) {  				while (!r.EndOfStream) {  					line = r.ReadLine ();  					string[] tokens = line.Split (''');  					string ssCode = tokens [2];  					string legacyCode = tokens [0];  					string fullLegacyCode = tokens [1];  					string mod1Code = tokens [4];  					string mod2Code = tokens [5];  					string status = tokens [6];  					string remarks = tokens [7];  					// Skip over all rows in the source file that don't match the symbol set code  					// or where the 2525C SIDC field is blank.  					if (ssCode == code && legacyCode != "") {  						// Extract the six character function code from the current 2525C SIDC.  						string functionCode = legacyCode.Substring (legacyCode.Length - 6);  						//string schemaCode = legacyCode.Substring(0' 1);  						//string dimensionCode = legacyCode.Substring(2' 1);  						string entityCode = tokens [3];  						if (entityCode.Length == 6) {  							string eCode = entityCode.Substring (0' 2);  							string etCode = entityCode.Substring (2' 2);  							string estCode = entityCode.Substring (4' 2);  							// Now that we have everything' let's find the pieces in the open symbol set  							SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  							// Find the entity' entity type' and entity subtype for the specified SIDC.  							SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  							if (entity != null) {  								ls.EntityID = entity.ID;  								ls.ID = entity.ID;  								if (etCode != "00") {  									SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  									if (eType != null) {  										ls.EntityTypeID = eType.ID;  										ls.ID = ls.ID + "_" + eType.ID;  										if (estCode != "00") {  											EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  											if (eSubType != null) {  												ls.EntitySubTypeID = eSubType.ID;  												ls.ID = ls.ID + "_" + eSubType.ID;  											}  										}  									}  								}  							}  							// No entities were found' so mark it as retired.  							if (ls.ID == null) {  								ls.ID = "RETIRED";  								ls.Remarks = "Retired";  							}  							// Find the modifier 1 and modifier 2 for the specified SIDC.  							if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  								if (mod1Code.Length == 2) {  									ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  									if (mod != null) {  										ls.ModifierOneID = mod.ID;  										ls.ID = ls.ID + "_" + mod.ID;  									}  								}  							}  							if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  								if (mod2Code.Length == 2) {  									ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  									if (mod != null) {  										ls.ModifierTwoID = mod.ID;  										ls.ID = ls.ID + "_" + mod.ID;  									}  								}  							}  							ls.ID = ls.ID + "_SYM";  							ls.Label = fullLegacyCode;  							// Add the legacy function code  							LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  							lfCode.Name = "2525C";  							if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  								lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  							if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  								lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  							lfCode.Value = functionCode;  							if (status != "")  								lfCode.Description = status;  							if (remarks != "")  								lfCode.Remarks = remarks;  							ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  								lfCode  							};  							// Add it to the current legacy symbol set  							legacySymbols.Add (ls);  						}  					}  				}  				r.Close ();  			}  			// Done processing the input.  If there is anything in our list then add it to the  			// symbol set and re-serialize it.  Remove the existing values if they exist.  			if (legacySymbols.Count > 0) {  				ss.LegacySymbols = legacySymbols.ToArray ();  				// Serialize the symbol set  				_serializeSymbolSet (ss' destination);  			}  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (ss != null) {  	string code = Convert.ToString (ss.SymbolSetCode.DigitOne) + Convert.ToString (ss.SymbolSetCode.DigitTwo);  	if (code != "") {  		// Open the source file for read.  		if (File.Exists (source)) {  			// Lets build a list of legacy symbols to hold the results  			List<SymbolSetLegacySymbol> legacySymbols = new List<SymbolSetLegacySymbol> ();  			// Now process the input  			string line = "";  			using (StreamReader r = new StreamReader (source)) {  				while (!r.EndOfStream) {  					line = r.ReadLine ();  					string[] tokens = line.Split (''');  					string ssCode = tokens [2];  					string legacyCode = tokens [0];  					string fullLegacyCode = tokens [1];  					string mod1Code = tokens [4];  					string mod2Code = tokens [5];  					string status = tokens [6];  					string remarks = tokens [7];  					// Skip over all rows in the source file that don't match the symbol set code  					// or where the 2525C SIDC field is blank.  					if (ssCode == code && legacyCode != "") {  						// Extract the six character function code from the current 2525C SIDC.  						string functionCode = legacyCode.Substring (legacyCode.Length - 6);  						//string schemaCode = legacyCode.Substring(0' 1);  						//string dimensionCode = legacyCode.Substring(2' 1);  						string entityCode = tokens [3];  						if (entityCode.Length == 6) {  							string eCode = entityCode.Substring (0' 2);  							string etCode = entityCode.Substring (2' 2);  							string estCode = entityCode.Substring (4' 2);  							// Now that we have everything' let's find the pieces in the open symbol set  							SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  							// Find the entity' entity type' and entity subtype for the specified SIDC.  							SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  							if (entity != null) {  								ls.EntityID = entity.ID;  								ls.ID = entity.ID;  								if (etCode != "00") {  									SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  									if (eType != null) {  										ls.EntityTypeID = eType.ID;  										ls.ID = ls.ID + "_" + eType.ID;  										if (estCode != "00") {  											EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  											if (eSubType != null) {  												ls.EntitySubTypeID = eSubType.ID;  												ls.ID = ls.ID + "_" + eSubType.ID;  											}  										}  									}  								}  							}  							// No entities were found' so mark it as retired.  							if (ls.ID == null) {  								ls.ID = "RETIRED";  								ls.Remarks = "Retired";  							}  							// Find the modifier 1 and modifier 2 for the specified SIDC.  							if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  								if (mod1Code.Length == 2) {  									ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  									if (mod != null) {  										ls.ModifierOneID = mod.ID;  										ls.ID = ls.ID + "_" + mod.ID;  									}  								}  							}  							if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  								if (mod2Code.Length == 2) {  									ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  									if (mod != null) {  										ls.ModifierTwoID = mod.ID;  										ls.ID = ls.ID + "_" + mod.ID;  									}  								}  							}  							ls.ID = ls.ID + "_SYM";  							ls.Label = fullLegacyCode;  							// Add the legacy function code  							LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  							lfCode.Name = "2525C";  							if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  								lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  							if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  								lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  							lfCode.Value = functionCode;  							if (status != "")  								lfCode.Description = status;  							if (remarks != "")  								lfCode.Remarks = remarks;  							ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  								lfCode  							};  							// Add it to the current legacy symbol set  							legacySymbols.Add (ls);  						}  					}  				}  				r.Close ();  			}  			// Done processing the input.  If there is anything in our list then add it to the  			// symbol set and re-serialize it.  Remove the existing values if they exist.  			if (legacySymbols.Count > 0) {  				ss.LegacySymbols = legacySymbols.ToArray ();  				// Serialize the symbol set  				_serializeSymbolSet (ss' destination);  			}  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (ss != null) {  	string code = Convert.ToString (ss.SymbolSetCode.DigitOne) + Convert.ToString (ss.SymbolSetCode.DigitTwo);  	if (code != "") {  		// Open the source file for read.  		if (File.Exists (source)) {  			// Lets build a list of legacy symbols to hold the results  			List<SymbolSetLegacySymbol> legacySymbols = new List<SymbolSetLegacySymbol> ();  			// Now process the input  			string line = "";  			using (StreamReader r = new StreamReader (source)) {  				while (!r.EndOfStream) {  					line = r.ReadLine ();  					string[] tokens = line.Split (''');  					string ssCode = tokens [2];  					string legacyCode = tokens [0];  					string fullLegacyCode = tokens [1];  					string mod1Code = tokens [4];  					string mod2Code = tokens [5];  					string status = tokens [6];  					string remarks = tokens [7];  					// Skip over all rows in the source file that don't match the symbol set code  					// or where the 2525C SIDC field is blank.  					if (ssCode == code && legacyCode != "") {  						// Extract the six character function code from the current 2525C SIDC.  						string functionCode = legacyCode.Substring (legacyCode.Length - 6);  						//string schemaCode = legacyCode.Substring(0' 1);  						//string dimensionCode = legacyCode.Substring(2' 1);  						string entityCode = tokens [3];  						if (entityCode.Length == 6) {  							string eCode = entityCode.Substring (0' 2);  							string etCode = entityCode.Substring (2' 2);  							string estCode = entityCode.Substring (4' 2);  							// Now that we have everything' let's find the pieces in the open symbol set  							SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  							// Find the entity' entity type' and entity subtype for the specified SIDC.  							SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  							if (entity != null) {  								ls.EntityID = entity.ID;  								ls.ID = entity.ID;  								if (etCode != "00") {  									SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  									if (eType != null) {  										ls.EntityTypeID = eType.ID;  										ls.ID = ls.ID + "_" + eType.ID;  										if (estCode != "00") {  											EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  											if (eSubType != null) {  												ls.EntitySubTypeID = eSubType.ID;  												ls.ID = ls.ID + "_" + eSubType.ID;  											}  										}  									}  								}  							}  							// No entities were found' so mark it as retired.  							if (ls.ID == null) {  								ls.ID = "RETIRED";  								ls.Remarks = "Retired";  							}  							// Find the modifier 1 and modifier 2 for the specified SIDC.  							if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  								if (mod1Code.Length == 2) {  									ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  									if (mod != null) {  										ls.ModifierOneID = mod.ID;  										ls.ID = ls.ID + "_" + mod.ID;  									}  								}  							}  							if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  								if (mod2Code.Length == 2) {  									ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  									if (mod != null) {  										ls.ModifierTwoID = mod.ID;  										ls.ID = ls.ID + "_" + mod.ID;  									}  								}  							}  							ls.ID = ls.ID + "_SYM";  							ls.Label = fullLegacyCode;  							// Add the legacy function code  							LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  							lfCode.Name = "2525C";  							if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  								lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  							if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  								lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  							lfCode.Value = functionCode;  							if (status != "")  								lfCode.Description = status;  							if (remarks != "")  								lfCode.Remarks = remarks;  							ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  								lfCode  							};  							// Add it to the current legacy symbol set  							legacySymbols.Add (ls);  						}  					}  				}  				r.Close ();  			}  			// Done processing the input.  If there is anything in our list then add it to the  			// symbol set and re-serialize it.  Remove the existing values if they exist.  			if (legacySymbols.Count > 0) {  				ss.LegacySymbols = legacySymbols.ToArray ();  				// Serialize the symbol set  				_serializeSymbolSet (ss' destination);  			}  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (ss != null) {  	string code = Convert.ToString (ss.SymbolSetCode.DigitOne) + Convert.ToString (ss.SymbolSetCode.DigitTwo);  	if (code != "") {  		// Open the source file for read.  		if (File.Exists (source)) {  			// Lets build a list of legacy symbols to hold the results  			List<SymbolSetLegacySymbol> legacySymbols = new List<SymbolSetLegacySymbol> ();  			// Now process the input  			string line = "";  			using (StreamReader r = new StreamReader (source)) {  				while (!r.EndOfStream) {  					line = r.ReadLine ();  					string[] tokens = line.Split (''');  					string ssCode = tokens [2];  					string legacyCode = tokens [0];  					string fullLegacyCode = tokens [1];  					string mod1Code = tokens [4];  					string mod2Code = tokens [5];  					string status = tokens [6];  					string remarks = tokens [7];  					// Skip over all rows in the source file that don't match the symbol set code  					// or where the 2525C SIDC field is blank.  					if (ssCode == code && legacyCode != "") {  						// Extract the six character function code from the current 2525C SIDC.  						string functionCode = legacyCode.Substring (legacyCode.Length - 6);  						//string schemaCode = legacyCode.Substring(0' 1);  						//string dimensionCode = legacyCode.Substring(2' 1);  						string entityCode = tokens [3];  						if (entityCode.Length == 6) {  							string eCode = entityCode.Substring (0' 2);  							string etCode = entityCode.Substring (2' 2);  							string estCode = entityCode.Substring (4' 2);  							// Now that we have everything' let's find the pieces in the open symbol set  							SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  							// Find the entity' entity type' and entity subtype for the specified SIDC.  							SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  							if (entity != null) {  								ls.EntityID = entity.ID;  								ls.ID = entity.ID;  								if (etCode != "00") {  									SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  									if (eType != null) {  										ls.EntityTypeID = eType.ID;  										ls.ID = ls.ID + "_" + eType.ID;  										if (estCode != "00") {  											EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  											if (eSubType != null) {  												ls.EntitySubTypeID = eSubType.ID;  												ls.ID = ls.ID + "_" + eSubType.ID;  											}  										}  									}  								}  							}  							// No entities were found' so mark it as retired.  							if (ls.ID == null) {  								ls.ID = "RETIRED";  								ls.Remarks = "Retired";  							}  							// Find the modifier 1 and modifier 2 for the specified SIDC.  							if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  								if (mod1Code.Length == 2) {  									ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  									if (mod != null) {  										ls.ModifierOneID = mod.ID;  										ls.ID = ls.ID + "_" + mod.ID;  									}  								}  							}  							if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  								if (mod2Code.Length == 2) {  									ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  									if (mod != null) {  										ls.ModifierTwoID = mod.ID;  										ls.ID = ls.ID + "_" + mod.ID;  									}  								}  							}  							ls.ID = ls.ID + "_SYM";  							ls.Label = fullLegacyCode;  							// Add the legacy function code  							LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  							lfCode.Name = "2525C";  							if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  								lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  							if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  								lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  							lfCode.Value = functionCode;  							if (status != "")  								lfCode.Description = status;  							if (remarks != "")  								lfCode.Remarks = remarks;  							ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  								lfCode  							};  							// Add it to the current legacy symbol set  							legacySymbols.Add (ls);  						}  					}  				}  				r.Close ();  			}  			// Done processing the input.  If there is anything in our list then add it to the  			// symbol set and re-serialize it.  Remove the existing values if they exist.  			if (legacySymbols.Count > 0) {  				ss.LegacySymbols = legacySymbols.ToArray ();  				// Serialize the symbol set  				_serializeSymbolSet (ss' destination);  			}  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (ss != null) {  	string code = Convert.ToString (ss.SymbolSetCode.DigitOne) + Convert.ToString (ss.SymbolSetCode.DigitTwo);  	if (code != "") {  		// Open the source file for read.  		if (File.Exists (source)) {  			// Lets build a list of legacy symbols to hold the results  			List<SymbolSetLegacySymbol> legacySymbols = new List<SymbolSetLegacySymbol> ();  			// Now process the input  			string line = "";  			using (StreamReader r = new StreamReader (source)) {  				while (!r.EndOfStream) {  					line = r.ReadLine ();  					string[] tokens = line.Split (''');  					string ssCode = tokens [2];  					string legacyCode = tokens [0];  					string fullLegacyCode = tokens [1];  					string mod1Code = tokens [4];  					string mod2Code = tokens [5];  					string status = tokens [6];  					string remarks = tokens [7];  					// Skip over all rows in the source file that don't match the symbol set code  					// or where the 2525C SIDC field is blank.  					if (ssCode == code && legacyCode != "") {  						// Extract the six character function code from the current 2525C SIDC.  						string functionCode = legacyCode.Substring (legacyCode.Length - 6);  						//string schemaCode = legacyCode.Substring(0' 1);  						//string dimensionCode = legacyCode.Substring(2' 1);  						string entityCode = tokens [3];  						if (entityCode.Length == 6) {  							string eCode = entityCode.Substring (0' 2);  							string etCode = entityCode.Substring (2' 2);  							string estCode = entityCode.Substring (4' 2);  							// Now that we have everything' let's find the pieces in the open symbol set  							SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  							// Find the entity' entity type' and entity subtype for the specified SIDC.  							SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  							if (entity != null) {  								ls.EntityID = entity.ID;  								ls.ID = entity.ID;  								if (etCode != "00") {  									SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  									if (eType != null) {  										ls.EntityTypeID = eType.ID;  										ls.ID = ls.ID + "_" + eType.ID;  										if (estCode != "00") {  											EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  											if (eSubType != null) {  												ls.EntitySubTypeID = eSubType.ID;  												ls.ID = ls.ID + "_" + eSubType.ID;  											}  										}  									}  								}  							}  							// No entities were found' so mark it as retired.  							if (ls.ID == null) {  								ls.ID = "RETIRED";  								ls.Remarks = "Retired";  							}  							// Find the modifier 1 and modifier 2 for the specified SIDC.  							if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  								if (mod1Code.Length == 2) {  									ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  									if (mod != null) {  										ls.ModifierOneID = mod.ID;  										ls.ID = ls.ID + "_" + mod.ID;  									}  								}  							}  							if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  								if (mod2Code.Length == 2) {  									ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  									if (mod != null) {  										ls.ModifierTwoID = mod.ID;  										ls.ID = ls.ID + "_" + mod.ID;  									}  								}  							}  							ls.ID = ls.ID + "_SYM";  							ls.Label = fullLegacyCode;  							// Add the legacy function code  							LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  							lfCode.Name = "2525C";  							if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  								lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  							if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  								lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  							lfCode.Value = functionCode;  							if (status != "")  								lfCode.Description = status;  							if (remarks != "")  								lfCode.Remarks = remarks;  							ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  								lfCode  							};  							// Add it to the current legacy symbol set  							legacySymbols.Add (ls);  						}  					}  				}  				r.Close ();  			}  			// Done processing the input.  If there is anything in our list then add it to the  			// symbol set and re-serialize it.  Remove the existing values if they exist.  			if (legacySymbols.Count > 0) {  				ss.LegacySymbols = legacySymbols.ToArray ();  				// Serialize the symbol set  				_serializeSymbolSet (ss' destination);  			}  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (ss != null) {  	string code = Convert.ToString (ss.SymbolSetCode.DigitOne) + Convert.ToString (ss.SymbolSetCode.DigitTwo);  	if (code != "") {  		// Open the source file for read.  		if (File.Exists (source)) {  			// Lets build a list of legacy symbols to hold the results  			List<SymbolSetLegacySymbol> legacySymbols = new List<SymbolSetLegacySymbol> ();  			// Now process the input  			string line = "";  			using (StreamReader r = new StreamReader (source)) {  				while (!r.EndOfStream) {  					line = r.ReadLine ();  					string[] tokens = line.Split (''');  					string ssCode = tokens [2];  					string legacyCode = tokens [0];  					string fullLegacyCode = tokens [1];  					string mod1Code = tokens [4];  					string mod2Code = tokens [5];  					string status = tokens [6];  					string remarks = tokens [7];  					// Skip over all rows in the source file that don't match the symbol set code  					// or where the 2525C SIDC field is blank.  					if (ssCode == code && legacyCode != "") {  						// Extract the six character function code from the current 2525C SIDC.  						string functionCode = legacyCode.Substring (legacyCode.Length - 6);  						//string schemaCode = legacyCode.Substring(0' 1);  						//string dimensionCode = legacyCode.Substring(2' 1);  						string entityCode = tokens [3];  						if (entityCode.Length == 6) {  							string eCode = entityCode.Substring (0' 2);  							string etCode = entityCode.Substring (2' 2);  							string estCode = entityCode.Substring (4' 2);  							// Now that we have everything' let's find the pieces in the open symbol set  							SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  							// Find the entity' entity type' and entity subtype for the specified SIDC.  							SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  							if (entity != null) {  								ls.EntityID = entity.ID;  								ls.ID = entity.ID;  								if (etCode != "00") {  									SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  									if (eType != null) {  										ls.EntityTypeID = eType.ID;  										ls.ID = ls.ID + "_" + eType.ID;  										if (estCode != "00") {  											EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  											if (eSubType != null) {  												ls.EntitySubTypeID = eSubType.ID;  												ls.ID = ls.ID + "_" + eSubType.ID;  											}  										}  									}  								}  							}  							// No entities were found' so mark it as retired.  							if (ls.ID == null) {  								ls.ID = "RETIRED";  								ls.Remarks = "Retired";  							}  							// Find the modifier 1 and modifier 2 for the specified SIDC.  							if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  								if (mod1Code.Length == 2) {  									ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  									if (mod != null) {  										ls.ModifierOneID = mod.ID;  										ls.ID = ls.ID + "_" + mod.ID;  									}  								}  							}  							if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  								if (mod2Code.Length == 2) {  									ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  									if (mod != null) {  										ls.ModifierTwoID = mod.ID;  										ls.ID = ls.ID + "_" + mod.ID;  									}  								}  							}  							ls.ID = ls.ID + "_SYM";  							ls.Label = fullLegacyCode;  							// Add the legacy function code  							LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  							lfCode.Name = "2525C";  							if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  								lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  							if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  								lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  							lfCode.Value = functionCode;  							if (status != "")  								lfCode.Description = status;  							if (remarks != "")  								lfCode.Remarks = remarks;  							ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  								lfCode  							};  							// Add it to the current legacy symbol set  							legacySymbols.Add (ls);  						}  					}  				}  				r.Close ();  			}  			// Done processing the input.  If there is anything in our list then add it to the  			// symbol set and re-serialize it.  Remove the existing values if they exist.  			if (legacySymbols.Count > 0) {  				ss.LegacySymbols = legacySymbols.ToArray ();  				// Serialize the symbol set  				_serializeSymbolSet (ss' destination);  			}  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (ss != null) {  	string code = Convert.ToString (ss.SymbolSetCode.DigitOne) + Convert.ToString (ss.SymbolSetCode.DigitTwo);  	if (code != "") {  		// Open the source file for read.  		if (File.Exists (source)) {  			// Lets build a list of legacy symbols to hold the results  			List<SymbolSetLegacySymbol> legacySymbols = new List<SymbolSetLegacySymbol> ();  			// Now process the input  			string line = "";  			using (StreamReader r = new StreamReader (source)) {  				while (!r.EndOfStream) {  					line = r.ReadLine ();  					string[] tokens = line.Split (''');  					string ssCode = tokens [2];  					string legacyCode = tokens [0];  					string fullLegacyCode = tokens [1];  					string mod1Code = tokens [4];  					string mod2Code = tokens [5];  					string status = tokens [6];  					string remarks = tokens [7];  					// Skip over all rows in the source file that don't match the symbol set code  					// or where the 2525C SIDC field is blank.  					if (ssCode == code && legacyCode != "") {  						// Extract the six character function code from the current 2525C SIDC.  						string functionCode = legacyCode.Substring (legacyCode.Length - 6);  						//string schemaCode = legacyCode.Substring(0' 1);  						//string dimensionCode = legacyCode.Substring(2' 1);  						string entityCode = tokens [3];  						if (entityCode.Length == 6) {  							string eCode = entityCode.Substring (0' 2);  							string etCode = entityCode.Substring (2' 2);  							string estCode = entityCode.Substring (4' 2);  							// Now that we have everything' let's find the pieces in the open symbol set  							SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  							// Find the entity' entity type' and entity subtype for the specified SIDC.  							SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  							if (entity != null) {  								ls.EntityID = entity.ID;  								ls.ID = entity.ID;  								if (etCode != "00") {  									SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  									if (eType != null) {  										ls.EntityTypeID = eType.ID;  										ls.ID = ls.ID + "_" + eType.ID;  										if (estCode != "00") {  											EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  											if (eSubType != null) {  												ls.EntitySubTypeID = eSubType.ID;  												ls.ID = ls.ID + "_" + eSubType.ID;  											}  										}  									}  								}  							}  							// No entities were found' so mark it as retired.  							if (ls.ID == null) {  								ls.ID = "RETIRED";  								ls.Remarks = "Retired";  							}  							// Find the modifier 1 and modifier 2 for the specified SIDC.  							if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  								if (mod1Code.Length == 2) {  									ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  									if (mod != null) {  										ls.ModifierOneID = mod.ID;  										ls.ID = ls.ID + "_" + mod.ID;  									}  								}  							}  							if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  								if (mod2Code.Length == 2) {  									ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  									if (mod != null) {  										ls.ModifierTwoID = mod.ID;  										ls.ID = ls.ID + "_" + mod.ID;  									}  								}  							}  							ls.ID = ls.ID + "_SYM";  							ls.Label = fullLegacyCode;  							// Add the legacy function code  							LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  							lfCode.Name = "2525C";  							if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  								lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  							if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  								lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  							lfCode.Value = functionCode;  							if (status != "")  								lfCode.Description = status;  							if (remarks != "")  								lfCode.Remarks = remarks;  							ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  								lfCode  							};  							// Add it to the current legacy symbol set  							legacySymbols.Add (ls);  						}  					}  				}  				r.Close ();  			}  			// Done processing the input.  If there is anything in our list then add it to the  			// symbol set and re-serialize it.  Remove the existing values if they exist.  			if (legacySymbols.Count > 0) {  				ss.LegacySymbols = legacySymbols.ToArray ();  				// Serialize the symbol set  				_serializeSymbolSet (ss' destination);  			}  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (ss != null) {  	string code = Convert.ToString (ss.SymbolSetCode.DigitOne) + Convert.ToString (ss.SymbolSetCode.DigitTwo);  	if (code != "") {  		// Open the source file for read.  		if (File.Exists (source)) {  			// Lets build a list of legacy symbols to hold the results  			List<SymbolSetLegacySymbol> legacySymbols = new List<SymbolSetLegacySymbol> ();  			// Now process the input  			string line = "";  			using (StreamReader r = new StreamReader (source)) {  				while (!r.EndOfStream) {  					line = r.ReadLine ();  					string[] tokens = line.Split (''');  					string ssCode = tokens [2];  					string legacyCode = tokens [0];  					string fullLegacyCode = tokens [1];  					string mod1Code = tokens [4];  					string mod2Code = tokens [5];  					string status = tokens [6];  					string remarks = tokens [7];  					// Skip over all rows in the source file that don't match the symbol set code  					// or where the 2525C SIDC field is blank.  					if (ssCode == code && legacyCode != "") {  						// Extract the six character function code from the current 2525C SIDC.  						string functionCode = legacyCode.Substring (legacyCode.Length - 6);  						//string schemaCode = legacyCode.Substring(0' 1);  						//string dimensionCode = legacyCode.Substring(2' 1);  						string entityCode = tokens [3];  						if (entityCode.Length == 6) {  							string eCode = entityCode.Substring (0' 2);  							string etCode = entityCode.Substring (2' 2);  							string estCode = entityCode.Substring (4' 2);  							// Now that we have everything' let's find the pieces in the open symbol set  							SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  							// Find the entity' entity type' and entity subtype for the specified SIDC.  							SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  							if (entity != null) {  								ls.EntityID = entity.ID;  								ls.ID = entity.ID;  								if (etCode != "00") {  									SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  									if (eType != null) {  										ls.EntityTypeID = eType.ID;  										ls.ID = ls.ID + "_" + eType.ID;  										if (estCode != "00") {  											EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  											if (eSubType != null) {  												ls.EntitySubTypeID = eSubType.ID;  												ls.ID = ls.ID + "_" + eSubType.ID;  											}  										}  									}  								}  							}  							// No entities were found' so mark it as retired.  							if (ls.ID == null) {  								ls.ID = "RETIRED";  								ls.Remarks = "Retired";  							}  							// Find the modifier 1 and modifier 2 for the specified SIDC.  							if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  								if (mod1Code.Length == 2) {  									ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  									if (mod != null) {  										ls.ModifierOneID = mod.ID;  										ls.ID = ls.ID + "_" + mod.ID;  									}  								}  							}  							if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  								if (mod2Code.Length == 2) {  									ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  									if (mod != null) {  										ls.ModifierTwoID = mod.ID;  										ls.ID = ls.ID + "_" + mod.ID;  									}  								}  							}  							ls.ID = ls.ID + "_SYM";  							ls.Label = fullLegacyCode;  							// Add the legacy function code  							LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  							lfCode.Name = "2525C";  							if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  								lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  							if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  								lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  							lfCode.Value = functionCode;  							if (status != "")  								lfCode.Description = status;  							if (remarks != "")  								lfCode.Remarks = remarks;  							ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  								lfCode  							};  							// Add it to the current legacy symbol set  							legacySymbols.Add (ls);  						}  					}  				}  				r.Close ();  			}  			// Done processing the input.  If there is anything in our list then add it to the  			// symbol set and re-serialize it.  Remove the existing values if they exist.  			if (legacySymbols.Count > 0) {  				ss.LegacySymbols = legacySymbols.ToArray ();  				// Serialize the symbol set  				_serializeSymbolSet (ss' destination);  			}  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (ss != null) {  	string code = Convert.ToString (ss.SymbolSetCode.DigitOne) + Convert.ToString (ss.SymbolSetCode.DigitTwo);  	if (code != "") {  		// Open the source file for read.  		if (File.Exists (source)) {  			// Lets build a list of legacy symbols to hold the results  			List<SymbolSetLegacySymbol> legacySymbols = new List<SymbolSetLegacySymbol> ();  			// Now process the input  			string line = "";  			using (StreamReader r = new StreamReader (source)) {  				while (!r.EndOfStream) {  					line = r.ReadLine ();  					string[] tokens = line.Split (''');  					string ssCode = tokens [2];  					string legacyCode = tokens [0];  					string fullLegacyCode = tokens [1];  					string mod1Code = tokens [4];  					string mod2Code = tokens [5];  					string status = tokens [6];  					string remarks = tokens [7];  					// Skip over all rows in the source file that don't match the symbol set code  					// or where the 2525C SIDC field is blank.  					if (ssCode == code && legacyCode != "") {  						// Extract the six character function code from the current 2525C SIDC.  						string functionCode = legacyCode.Substring (legacyCode.Length - 6);  						//string schemaCode = legacyCode.Substring(0' 1);  						//string dimensionCode = legacyCode.Substring(2' 1);  						string entityCode = tokens [3];  						if (entityCode.Length == 6) {  							string eCode = entityCode.Substring (0' 2);  							string etCode = entityCode.Substring (2' 2);  							string estCode = entityCode.Substring (4' 2);  							// Now that we have everything' let's find the pieces in the open symbol set  							SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  							// Find the entity' entity type' and entity subtype for the specified SIDC.  							SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  							if (entity != null) {  								ls.EntityID = entity.ID;  								ls.ID = entity.ID;  								if (etCode != "00") {  									SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  									if (eType != null) {  										ls.EntityTypeID = eType.ID;  										ls.ID = ls.ID + "_" + eType.ID;  										if (estCode != "00") {  											EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  											if (eSubType != null) {  												ls.EntitySubTypeID = eSubType.ID;  												ls.ID = ls.ID + "_" + eSubType.ID;  											}  										}  									}  								}  							}  							// No entities were found' so mark it as retired.  							if (ls.ID == null) {  								ls.ID = "RETIRED";  								ls.Remarks = "Retired";  							}  							// Find the modifier 1 and modifier 2 for the specified SIDC.  							if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  								if (mod1Code.Length == 2) {  									ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  									if (mod != null) {  										ls.ModifierOneID = mod.ID;  										ls.ID = ls.ID + "_" + mod.ID;  									}  								}  							}  							if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  								if (mod2Code.Length == 2) {  									ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  									if (mod != null) {  										ls.ModifierTwoID = mod.ID;  										ls.ID = ls.ID + "_" + mod.ID;  									}  								}  							}  							ls.ID = ls.ID + "_SYM";  							ls.Label = fullLegacyCode;  							// Add the legacy function code  							LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  							lfCode.Name = "2525C";  							if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  								lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  							if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  								lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  							lfCode.Value = functionCode;  							if (status != "")  								lfCode.Description = status;  							if (remarks != "")  								lfCode.Remarks = remarks;  							ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  								lfCode  							};  							// Add it to the current legacy symbol set  							legacySymbols.Add (ls);  						}  					}  				}  				r.Close ();  			}  			// Done processing the input.  If there is anything in our list then add it to the  			// symbol set and re-serialize it.  Remove the existing values if they exist.  			if (legacySymbols.Count > 0) {  				ss.LegacySymbols = legacySymbols.ToArray ();  				// Serialize the symbol set  				_serializeSymbolSet (ss' destination);  			}  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (ss != null) {  	string code = Convert.ToString (ss.SymbolSetCode.DigitOne) + Convert.ToString (ss.SymbolSetCode.DigitTwo);  	if (code != "") {  		// Open the source file for read.  		if (File.Exists (source)) {  			// Lets build a list of legacy symbols to hold the results  			List<SymbolSetLegacySymbol> legacySymbols = new List<SymbolSetLegacySymbol> ();  			// Now process the input  			string line = "";  			using (StreamReader r = new StreamReader (source)) {  				while (!r.EndOfStream) {  					line = r.ReadLine ();  					string[] tokens = line.Split (''');  					string ssCode = tokens [2];  					string legacyCode = tokens [0];  					string fullLegacyCode = tokens [1];  					string mod1Code = tokens [4];  					string mod2Code = tokens [5];  					string status = tokens [6];  					string remarks = tokens [7];  					// Skip over all rows in the source file that don't match the symbol set code  					// or where the 2525C SIDC field is blank.  					if (ssCode == code && legacyCode != "") {  						// Extract the six character function code from the current 2525C SIDC.  						string functionCode = legacyCode.Substring (legacyCode.Length - 6);  						//string schemaCode = legacyCode.Substring(0' 1);  						//string dimensionCode = legacyCode.Substring(2' 1);  						string entityCode = tokens [3];  						if (entityCode.Length == 6) {  							string eCode = entityCode.Substring (0' 2);  							string etCode = entityCode.Substring (2' 2);  							string estCode = entityCode.Substring (4' 2);  							// Now that we have everything' let's find the pieces in the open symbol set  							SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  							// Find the entity' entity type' and entity subtype for the specified SIDC.  							SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  							if (entity != null) {  								ls.EntityID = entity.ID;  								ls.ID = entity.ID;  								if (etCode != "00") {  									SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  									if (eType != null) {  										ls.EntityTypeID = eType.ID;  										ls.ID = ls.ID + "_" + eType.ID;  										if (estCode != "00") {  											EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  											if (eSubType != null) {  												ls.EntitySubTypeID = eSubType.ID;  												ls.ID = ls.ID + "_" + eSubType.ID;  											}  										}  									}  								}  							}  							// No entities were found' so mark it as retired.  							if (ls.ID == null) {  								ls.ID = "RETIRED";  								ls.Remarks = "Retired";  							}  							// Find the modifier 1 and modifier 2 for the specified SIDC.  							if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  								if (mod1Code.Length == 2) {  									ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  									if (mod != null) {  										ls.ModifierOneID = mod.ID;  										ls.ID = ls.ID + "_" + mod.ID;  									}  								}  							}  							if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  								if (mod2Code.Length == 2) {  									ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  									if (mod != null) {  										ls.ModifierTwoID = mod.ID;  										ls.ID = ls.ID + "_" + mod.ID;  									}  								}  							}  							ls.ID = ls.ID + "_SYM";  							ls.Label = fullLegacyCode;  							// Add the legacy function code  							LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  							lfCode.Name = "2525C";  							if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  								lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  							if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  								lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  							lfCode.Value = functionCode;  							if (status != "")  								lfCode.Description = status;  							if (remarks != "")  								lfCode.Remarks = remarks;  							ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  								lfCode  							};  							// Add it to the current legacy symbol set  							legacySymbols.Add (ls);  						}  					}  				}  				r.Close ();  			}  			// Done processing the input.  If there is anything in our list then add it to the  			// symbol set and re-serialize it.  Remove the existing values if they exist.  			if (legacySymbols.Count > 0) {  				ss.LegacySymbols = legacySymbols.ToArray ();  				// Serialize the symbol set  				_serializeSymbolSet (ss' destination);  			}  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (ss != null) {  	string code = Convert.ToString (ss.SymbolSetCode.DigitOne) + Convert.ToString (ss.SymbolSetCode.DigitTwo);  	if (code != "") {  		// Open the source file for read.  		if (File.Exists (source)) {  			// Lets build a list of legacy symbols to hold the results  			List<SymbolSetLegacySymbol> legacySymbols = new List<SymbolSetLegacySymbol> ();  			// Now process the input  			string line = "";  			using (StreamReader r = new StreamReader (source)) {  				while (!r.EndOfStream) {  					line = r.ReadLine ();  					string[] tokens = line.Split (''');  					string ssCode = tokens [2];  					string legacyCode = tokens [0];  					string fullLegacyCode = tokens [1];  					string mod1Code = tokens [4];  					string mod2Code = tokens [5];  					string status = tokens [6];  					string remarks = tokens [7];  					// Skip over all rows in the source file that don't match the symbol set code  					// or where the 2525C SIDC field is blank.  					if (ssCode == code && legacyCode != "") {  						// Extract the six character function code from the current 2525C SIDC.  						string functionCode = legacyCode.Substring (legacyCode.Length - 6);  						//string schemaCode = legacyCode.Substring(0' 1);  						//string dimensionCode = legacyCode.Substring(2' 1);  						string entityCode = tokens [3];  						if (entityCode.Length == 6) {  							string eCode = entityCode.Substring (0' 2);  							string etCode = entityCode.Substring (2' 2);  							string estCode = entityCode.Substring (4' 2);  							// Now that we have everything' let's find the pieces in the open symbol set  							SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  							// Find the entity' entity type' and entity subtype for the specified SIDC.  							SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  							if (entity != null) {  								ls.EntityID = entity.ID;  								ls.ID = entity.ID;  								if (etCode != "00") {  									SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  									if (eType != null) {  										ls.EntityTypeID = eType.ID;  										ls.ID = ls.ID + "_" + eType.ID;  										if (estCode != "00") {  											EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  											if (eSubType != null) {  												ls.EntitySubTypeID = eSubType.ID;  												ls.ID = ls.ID + "_" + eSubType.ID;  											}  										}  									}  								}  							}  							// No entities were found' so mark it as retired.  							if (ls.ID == null) {  								ls.ID = "RETIRED";  								ls.Remarks = "Retired";  							}  							// Find the modifier 1 and modifier 2 for the specified SIDC.  							if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  								if (mod1Code.Length == 2) {  									ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  									if (mod != null) {  										ls.ModifierOneID = mod.ID;  										ls.ID = ls.ID + "_" + mod.ID;  									}  								}  							}  							if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  								if (mod2Code.Length == 2) {  									ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  									if (mod != null) {  										ls.ModifierTwoID = mod.ID;  										ls.ID = ls.ID + "_" + mod.ID;  									}  								}  							}  							ls.ID = ls.ID + "_SYM";  							ls.Label = fullLegacyCode;  							// Add the legacy function code  							LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  							lfCode.Name = "2525C";  							if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  								lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  							if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  								lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  							lfCode.Value = functionCode;  							if (status != "")  								lfCode.Description = status;  							if (remarks != "")  								lfCode.Remarks = remarks;  							ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  								lfCode  							};  							// Add it to the current legacy symbol set  							legacySymbols.Add (ls);  						}  					}  				}  				r.Close ();  			}  			// Done processing the input.  If there is anything in our list then add it to the  			// symbol set and re-serialize it.  Remove the existing values if they exist.  			if (legacySymbols.Count > 0) {  				ss.LegacySymbols = legacySymbols.ToArray ();  				// Serialize the symbol set  				_serializeSymbolSet (ss' destination);  			}  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (ss != null) {  	string code = Convert.ToString (ss.SymbolSetCode.DigitOne) + Convert.ToString (ss.SymbolSetCode.DigitTwo);  	if (code != "") {  		// Open the source file for read.  		if (File.Exists (source)) {  			// Lets build a list of legacy symbols to hold the results  			List<SymbolSetLegacySymbol> legacySymbols = new List<SymbolSetLegacySymbol> ();  			// Now process the input  			string line = "";  			using (StreamReader r = new StreamReader (source)) {  				while (!r.EndOfStream) {  					line = r.ReadLine ();  					string[] tokens = line.Split (''');  					string ssCode = tokens [2];  					string legacyCode = tokens [0];  					string fullLegacyCode = tokens [1];  					string mod1Code = tokens [4];  					string mod2Code = tokens [5];  					string status = tokens [6];  					string remarks = tokens [7];  					// Skip over all rows in the source file that don't match the symbol set code  					// or where the 2525C SIDC field is blank.  					if (ssCode == code && legacyCode != "") {  						// Extract the six character function code from the current 2525C SIDC.  						string functionCode = legacyCode.Substring (legacyCode.Length - 6);  						//string schemaCode = legacyCode.Substring(0' 1);  						//string dimensionCode = legacyCode.Substring(2' 1);  						string entityCode = tokens [3];  						if (entityCode.Length == 6) {  							string eCode = entityCode.Substring (0' 2);  							string etCode = entityCode.Substring (2' 2);  							string estCode = entityCode.Substring (4' 2);  							// Now that we have everything' let's find the pieces in the open symbol set  							SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  							// Find the entity' entity type' and entity subtype for the specified SIDC.  							SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  							if (entity != null) {  								ls.EntityID = entity.ID;  								ls.ID = entity.ID;  								if (etCode != "00") {  									SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  									if (eType != null) {  										ls.EntityTypeID = eType.ID;  										ls.ID = ls.ID + "_" + eType.ID;  										if (estCode != "00") {  											EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  											if (eSubType != null) {  												ls.EntitySubTypeID = eSubType.ID;  												ls.ID = ls.ID + "_" + eSubType.ID;  											}  										}  									}  								}  							}  							// No entities were found' so mark it as retired.  							if (ls.ID == null) {  								ls.ID = "RETIRED";  								ls.Remarks = "Retired";  							}  							// Find the modifier 1 and modifier 2 for the specified SIDC.  							if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  								if (mod1Code.Length == 2) {  									ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  									if (mod != null) {  										ls.ModifierOneID = mod.ID;  										ls.ID = ls.ID + "_" + mod.ID;  									}  								}  							}  							if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  								if (mod2Code.Length == 2) {  									ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  									if (mod != null) {  										ls.ModifierTwoID = mod.ID;  										ls.ID = ls.ID + "_" + mod.ID;  									}  								}  							}  							ls.ID = ls.ID + "_SYM";  							ls.Label = fullLegacyCode;  							// Add the legacy function code  							LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  							lfCode.Name = "2525C";  							if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  								lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  							if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  								lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  							lfCode.Value = functionCode;  							if (status != "")  								lfCode.Description = status;  							if (remarks != "")  								lfCode.Remarks = remarks;  							ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  								lfCode  							};  							// Add it to the current legacy symbol set  							legacySymbols.Add (ls);  						}  					}  				}  				r.Close ();  			}  			// Done processing the input.  If there is anything in our list then add it to the  			// symbol set and re-serialize it.  Remove the existing values if they exist.  			if (legacySymbols.Count > 0) {  				ss.LegacySymbols = legacySymbols.ToArray ();  				// Serialize the symbol set  				_serializeSymbolSet (ss' destination);  			}  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (ss != null) {  	string code = Convert.ToString (ss.SymbolSetCode.DigitOne) + Convert.ToString (ss.SymbolSetCode.DigitTwo);  	if (code != "") {  		// Open the source file for read.  		if (File.Exists (source)) {  			// Lets build a list of legacy symbols to hold the results  			List<SymbolSetLegacySymbol> legacySymbols = new List<SymbolSetLegacySymbol> ();  			// Now process the input  			string line = "";  			using (StreamReader r = new StreamReader (source)) {  				while (!r.EndOfStream) {  					line = r.ReadLine ();  					string[] tokens = line.Split (''');  					string ssCode = tokens [2];  					string legacyCode = tokens [0];  					string fullLegacyCode = tokens [1];  					string mod1Code = tokens [4];  					string mod2Code = tokens [5];  					string status = tokens [6];  					string remarks = tokens [7];  					// Skip over all rows in the source file that don't match the symbol set code  					// or where the 2525C SIDC field is blank.  					if (ssCode == code && legacyCode != "") {  						// Extract the six character function code from the current 2525C SIDC.  						string functionCode = legacyCode.Substring (legacyCode.Length - 6);  						//string schemaCode = legacyCode.Substring(0' 1);  						//string dimensionCode = legacyCode.Substring(2' 1);  						string entityCode = tokens [3];  						if (entityCode.Length == 6) {  							string eCode = entityCode.Substring (0' 2);  							string etCode = entityCode.Substring (2' 2);  							string estCode = entityCode.Substring (4' 2);  							// Now that we have everything' let's find the pieces in the open symbol set  							SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  							// Find the entity' entity type' and entity subtype for the specified SIDC.  							SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  							if (entity != null) {  								ls.EntityID = entity.ID;  								ls.ID = entity.ID;  								if (etCode != "00") {  									SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  									if (eType != null) {  										ls.EntityTypeID = eType.ID;  										ls.ID = ls.ID + "_" + eType.ID;  										if (estCode != "00") {  											EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  											if (eSubType != null) {  												ls.EntitySubTypeID = eSubType.ID;  												ls.ID = ls.ID + "_" + eSubType.ID;  											}  										}  									}  								}  							}  							// No entities were found' so mark it as retired.  							if (ls.ID == null) {  								ls.ID = "RETIRED";  								ls.Remarks = "Retired";  							}  							// Find the modifier 1 and modifier 2 for the specified SIDC.  							if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  								if (mod1Code.Length == 2) {  									ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  									if (mod != null) {  										ls.ModifierOneID = mod.ID;  										ls.ID = ls.ID + "_" + mod.ID;  									}  								}  							}  							if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  								if (mod2Code.Length == 2) {  									ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  									if (mod != null) {  										ls.ModifierTwoID = mod.ID;  										ls.ID = ls.ID + "_" + mod.ID;  									}  								}  							}  							ls.ID = ls.ID + "_SYM";  							ls.Label = fullLegacyCode;  							// Add the legacy function code  							LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  							lfCode.Name = "2525C";  							if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  								lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  							if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  								lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  							lfCode.Value = functionCode;  							if (status != "")  								lfCode.Description = status;  							if (remarks != "")  								lfCode.Remarks = remarks;  							ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  								lfCode  							};  							// Add it to the current legacy symbol set  							legacySymbols.Add (ls);  						}  					}  				}  				r.Close ();  			}  			// Done processing the input.  If there is anything in our list then add it to the  			// symbol set and re-serialize it.  Remove the existing values if they exist.  			if (legacySymbols.Count > 0) {  				ss.LegacySymbols = legacySymbols.ToArray ();  				// Serialize the symbol set  				_serializeSymbolSet (ss' destination);  			}  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (ss != null) {  	string code = Convert.ToString (ss.SymbolSetCode.DigitOne) + Convert.ToString (ss.SymbolSetCode.DigitTwo);  	if (code != "") {  		// Open the source file for read.  		if (File.Exists (source)) {  			// Lets build a list of legacy symbols to hold the results  			List<SymbolSetLegacySymbol> legacySymbols = new List<SymbolSetLegacySymbol> ();  			// Now process the input  			string line = "";  			using (StreamReader r = new StreamReader (source)) {  				while (!r.EndOfStream) {  					line = r.ReadLine ();  					string[] tokens = line.Split (''');  					string ssCode = tokens [2];  					string legacyCode = tokens [0];  					string fullLegacyCode = tokens [1];  					string mod1Code = tokens [4];  					string mod2Code = tokens [5];  					string status = tokens [6];  					string remarks = tokens [7];  					// Skip over all rows in the source file that don't match the symbol set code  					// or where the 2525C SIDC field is blank.  					if (ssCode == code && legacyCode != "") {  						// Extract the six character function code from the current 2525C SIDC.  						string functionCode = legacyCode.Substring (legacyCode.Length - 6);  						//string schemaCode = legacyCode.Substring(0' 1);  						//string dimensionCode = legacyCode.Substring(2' 1);  						string entityCode = tokens [3];  						if (entityCode.Length == 6) {  							string eCode = entityCode.Substring (0' 2);  							string etCode = entityCode.Substring (2' 2);  							string estCode = entityCode.Substring (4' 2);  							// Now that we have everything' let's find the pieces in the open symbol set  							SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  							// Find the entity' entity type' and entity subtype for the specified SIDC.  							SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  							if (entity != null) {  								ls.EntityID = entity.ID;  								ls.ID = entity.ID;  								if (etCode != "00") {  									SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  									if (eType != null) {  										ls.EntityTypeID = eType.ID;  										ls.ID = ls.ID + "_" + eType.ID;  										if (estCode != "00") {  											EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  											if (eSubType != null) {  												ls.EntitySubTypeID = eSubType.ID;  												ls.ID = ls.ID + "_" + eSubType.ID;  											}  										}  									}  								}  							}  							// No entities were found' so mark it as retired.  							if (ls.ID == null) {  								ls.ID = "RETIRED";  								ls.Remarks = "Retired";  							}  							// Find the modifier 1 and modifier 2 for the specified SIDC.  							if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  								if (mod1Code.Length == 2) {  									ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  									if (mod != null) {  										ls.ModifierOneID = mod.ID;  										ls.ID = ls.ID + "_" + mod.ID;  									}  								}  							}  							if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  								if (mod2Code.Length == 2) {  									ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  									if (mod != null) {  										ls.ModifierTwoID = mod.ID;  										ls.ID = ls.ID + "_" + mod.ID;  									}  								}  							}  							ls.ID = ls.ID + "_SYM";  							ls.Label = fullLegacyCode;  							// Add the legacy function code  							LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  							lfCode.Name = "2525C";  							if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  								lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  							if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  								lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  							lfCode.Value = functionCode;  							if (status != "")  								lfCode.Description = status;  							if (remarks != "")  								lfCode.Remarks = remarks;  							ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  								lfCode  							};  							// Add it to the current legacy symbol set  							legacySymbols.Add (ls);  						}  					}  				}  				r.Close ();  			}  			// Done processing the input.  If there is anything in our list then add it to the  			// symbol set and re-serialize it.  Remove the existing values if they exist.  			if (legacySymbols.Count > 0) {  				ss.LegacySymbols = legacySymbols.ToArray ();  				// Serialize the symbol set  				_serializeSymbolSet (ss' destination);  			}  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (code != "") {  	// Open the source file for read.  	if (File.Exists (source)) {  		// Lets build a list of legacy symbols to hold the results  		List<SymbolSetLegacySymbol> legacySymbols = new List<SymbolSetLegacySymbol> ();  		// Now process the input  		string line = "";  		using (StreamReader r = new StreamReader (source)) {  			while (!r.EndOfStream) {  				line = r.ReadLine ();  				string[] tokens = line.Split (''');  				string ssCode = tokens [2];  				string legacyCode = tokens [0];  				string fullLegacyCode = tokens [1];  				string mod1Code = tokens [4];  				string mod2Code = tokens [5];  				string status = tokens [6];  				string remarks = tokens [7];  				// Skip over all rows in the source file that don't match the symbol set code  				// or where the 2525C SIDC field is blank.  				if (ssCode == code && legacyCode != "") {  					// Extract the six character function code from the current 2525C SIDC.  					string functionCode = legacyCode.Substring (legacyCode.Length - 6);  					//string schemaCode = legacyCode.Substring(0' 1);  					//string dimensionCode = legacyCode.Substring(2' 1);  					string entityCode = tokens [3];  					if (entityCode.Length == 6) {  						string eCode = entityCode.Substring (0' 2);  						string etCode = entityCode.Substring (2' 2);  						string estCode = entityCode.Substring (4' 2);  						// Now that we have everything' let's find the pieces in the open symbol set  						SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  						// Find the entity' entity type' and entity subtype for the specified SIDC.  						SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  						if (entity != null) {  							ls.EntityID = entity.ID;  							ls.ID = entity.ID;  							if (etCode != "00") {  								SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  								if (eType != null) {  									ls.EntityTypeID = eType.ID;  									ls.ID = ls.ID + "_" + eType.ID;  									if (estCode != "00") {  										EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  										if (eSubType != null) {  											ls.EntitySubTypeID = eSubType.ID;  											ls.ID = ls.ID + "_" + eSubType.ID;  										}  									}  								}  							}  						}  						// No entities were found' so mark it as retired.  						if (ls.ID == null) {  							ls.ID = "RETIRED";  							ls.Remarks = "Retired";  						}  						// Find the modifier 1 and modifier 2 for the specified SIDC.  						if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  							if (mod1Code.Length == 2) {  								ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  								if (mod != null) {  									ls.ModifierOneID = mod.ID;  									ls.ID = ls.ID + "_" + mod.ID;  								}  							}  						}  						if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  							if (mod2Code.Length == 2) {  								ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  								if (mod != null) {  									ls.ModifierTwoID = mod.ID;  									ls.ID = ls.ID + "_" + mod.ID;  								}  							}  						}  						ls.ID = ls.ID + "_SYM";  						ls.Label = fullLegacyCode;  						// Add the legacy function code  						LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  						lfCode.Name = "2525C";  						if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  							lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  						if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  							lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  						lfCode.Value = functionCode;  						if (status != "")  							lfCode.Description = status;  						if (remarks != "")  							lfCode.Remarks = remarks;  						ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  							lfCode  						};  						// Add it to the current legacy symbol set  						legacySymbols.Add (ls);  					}  				}  			}  			r.Close ();  		}  		// Done processing the input.  If there is anything in our list then add it to the  		// symbol set and re-serialize it.  Remove the existing values if they exist.  		if (legacySymbols.Count > 0) {  			ss.LegacySymbols = legacySymbols.ToArray ();  			// Serialize the symbol set  			_serializeSymbolSet (ss' destination);  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (code != "") {  	// Open the source file for read.  	if (File.Exists (source)) {  		// Lets build a list of legacy symbols to hold the results  		List<SymbolSetLegacySymbol> legacySymbols = new List<SymbolSetLegacySymbol> ();  		// Now process the input  		string line = "";  		using (StreamReader r = new StreamReader (source)) {  			while (!r.EndOfStream) {  				line = r.ReadLine ();  				string[] tokens = line.Split (''');  				string ssCode = tokens [2];  				string legacyCode = tokens [0];  				string fullLegacyCode = tokens [1];  				string mod1Code = tokens [4];  				string mod2Code = tokens [5];  				string status = tokens [6];  				string remarks = tokens [7];  				// Skip over all rows in the source file that don't match the symbol set code  				// or where the 2525C SIDC field is blank.  				if (ssCode == code && legacyCode != "") {  					// Extract the six character function code from the current 2525C SIDC.  					string functionCode = legacyCode.Substring (legacyCode.Length - 6);  					//string schemaCode = legacyCode.Substring(0' 1);  					//string dimensionCode = legacyCode.Substring(2' 1);  					string entityCode = tokens [3];  					if (entityCode.Length == 6) {  						string eCode = entityCode.Substring (0' 2);  						string etCode = entityCode.Substring (2' 2);  						string estCode = entityCode.Substring (4' 2);  						// Now that we have everything' let's find the pieces in the open symbol set  						SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  						// Find the entity' entity type' and entity subtype for the specified SIDC.  						SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  						if (entity != null) {  							ls.EntityID = entity.ID;  							ls.ID = entity.ID;  							if (etCode != "00") {  								SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  								if (eType != null) {  									ls.EntityTypeID = eType.ID;  									ls.ID = ls.ID + "_" + eType.ID;  									if (estCode != "00") {  										EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  										if (eSubType != null) {  											ls.EntitySubTypeID = eSubType.ID;  											ls.ID = ls.ID + "_" + eSubType.ID;  										}  									}  								}  							}  						}  						// No entities were found' so mark it as retired.  						if (ls.ID == null) {  							ls.ID = "RETIRED";  							ls.Remarks = "Retired";  						}  						// Find the modifier 1 and modifier 2 for the specified SIDC.  						if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  							if (mod1Code.Length == 2) {  								ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  								if (mod != null) {  									ls.ModifierOneID = mod.ID;  									ls.ID = ls.ID + "_" + mod.ID;  								}  							}  						}  						if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  							if (mod2Code.Length == 2) {  								ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  								if (mod != null) {  									ls.ModifierTwoID = mod.ID;  									ls.ID = ls.ID + "_" + mod.ID;  								}  							}  						}  						ls.ID = ls.ID + "_SYM";  						ls.Label = fullLegacyCode;  						// Add the legacy function code  						LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  						lfCode.Name = "2525C";  						if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  							lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  						if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  							lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  						lfCode.Value = functionCode;  						if (status != "")  							lfCode.Description = status;  						if (remarks != "")  							lfCode.Remarks = remarks;  						ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  							lfCode  						};  						// Add it to the current legacy symbol set  						legacySymbols.Add (ls);  					}  				}  			}  			r.Close ();  		}  		// Done processing the input.  If there is anything in our list then add it to the  		// symbol set and re-serialize it.  Remove the existing values if they exist.  		if (legacySymbols.Count > 0) {  			ss.LegacySymbols = legacySymbols.ToArray ();  			// Serialize the symbol set  			_serializeSymbolSet (ss' destination);  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (code != "") {  	// Open the source file for read.  	if (File.Exists (source)) {  		// Lets build a list of legacy symbols to hold the results  		List<SymbolSetLegacySymbol> legacySymbols = new List<SymbolSetLegacySymbol> ();  		// Now process the input  		string line = "";  		using (StreamReader r = new StreamReader (source)) {  			while (!r.EndOfStream) {  				line = r.ReadLine ();  				string[] tokens = line.Split (''');  				string ssCode = tokens [2];  				string legacyCode = tokens [0];  				string fullLegacyCode = tokens [1];  				string mod1Code = tokens [4];  				string mod2Code = tokens [5];  				string status = tokens [6];  				string remarks = tokens [7];  				// Skip over all rows in the source file that don't match the symbol set code  				// or where the 2525C SIDC field is blank.  				if (ssCode == code && legacyCode != "") {  					// Extract the six character function code from the current 2525C SIDC.  					string functionCode = legacyCode.Substring (legacyCode.Length - 6);  					//string schemaCode = legacyCode.Substring(0' 1);  					//string dimensionCode = legacyCode.Substring(2' 1);  					string entityCode = tokens [3];  					if (entityCode.Length == 6) {  						string eCode = entityCode.Substring (0' 2);  						string etCode = entityCode.Substring (2' 2);  						string estCode = entityCode.Substring (4' 2);  						// Now that we have everything' let's find the pieces in the open symbol set  						SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  						// Find the entity' entity type' and entity subtype for the specified SIDC.  						SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  						if (entity != null) {  							ls.EntityID = entity.ID;  							ls.ID = entity.ID;  							if (etCode != "00") {  								SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  								if (eType != null) {  									ls.EntityTypeID = eType.ID;  									ls.ID = ls.ID + "_" + eType.ID;  									if (estCode != "00") {  										EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  										if (eSubType != null) {  											ls.EntitySubTypeID = eSubType.ID;  											ls.ID = ls.ID + "_" + eSubType.ID;  										}  									}  								}  							}  						}  						// No entities were found' so mark it as retired.  						if (ls.ID == null) {  							ls.ID = "RETIRED";  							ls.Remarks = "Retired";  						}  						// Find the modifier 1 and modifier 2 for the specified SIDC.  						if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  							if (mod1Code.Length == 2) {  								ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  								if (mod != null) {  									ls.ModifierOneID = mod.ID;  									ls.ID = ls.ID + "_" + mod.ID;  								}  							}  						}  						if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  							if (mod2Code.Length == 2) {  								ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  								if (mod != null) {  									ls.ModifierTwoID = mod.ID;  									ls.ID = ls.ID + "_" + mod.ID;  								}  							}  						}  						ls.ID = ls.ID + "_SYM";  						ls.Label = fullLegacyCode;  						// Add the legacy function code  						LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  						lfCode.Name = "2525C";  						if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  							lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  						if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  							lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  						lfCode.Value = functionCode;  						if (status != "")  							lfCode.Description = status;  						if (remarks != "")  							lfCode.Remarks = remarks;  						ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  							lfCode  						};  						// Add it to the current legacy symbol set  						legacySymbols.Add (ls);  					}  				}  			}  			r.Close ();  		}  		// Done processing the input.  If there is anything in our list then add it to the  		// symbol set and re-serialize it.  Remove the existing values if they exist.  		if (legacySymbols.Count > 0) {  			ss.LegacySymbols = legacySymbols.ToArray ();  			// Serialize the symbol set  			_serializeSymbolSet (ss' destination);  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (code != "") {  	// Open the source file for read.  	if (File.Exists (source)) {  		// Lets build a list of legacy symbols to hold the results  		List<SymbolSetLegacySymbol> legacySymbols = new List<SymbolSetLegacySymbol> ();  		// Now process the input  		string line = "";  		using (StreamReader r = new StreamReader (source)) {  			while (!r.EndOfStream) {  				line = r.ReadLine ();  				string[] tokens = line.Split (''');  				string ssCode = tokens [2];  				string legacyCode = tokens [0];  				string fullLegacyCode = tokens [1];  				string mod1Code = tokens [4];  				string mod2Code = tokens [5];  				string status = tokens [6];  				string remarks = tokens [7];  				// Skip over all rows in the source file that don't match the symbol set code  				// or where the 2525C SIDC field is blank.  				if (ssCode == code && legacyCode != "") {  					// Extract the six character function code from the current 2525C SIDC.  					string functionCode = legacyCode.Substring (legacyCode.Length - 6);  					//string schemaCode = legacyCode.Substring(0' 1);  					//string dimensionCode = legacyCode.Substring(2' 1);  					string entityCode = tokens [3];  					if (entityCode.Length == 6) {  						string eCode = entityCode.Substring (0' 2);  						string etCode = entityCode.Substring (2' 2);  						string estCode = entityCode.Substring (4' 2);  						// Now that we have everything' let's find the pieces in the open symbol set  						SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  						// Find the entity' entity type' and entity subtype for the specified SIDC.  						SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  						if (entity != null) {  							ls.EntityID = entity.ID;  							ls.ID = entity.ID;  							if (etCode != "00") {  								SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  								if (eType != null) {  									ls.EntityTypeID = eType.ID;  									ls.ID = ls.ID + "_" + eType.ID;  									if (estCode != "00") {  										EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  										if (eSubType != null) {  											ls.EntitySubTypeID = eSubType.ID;  											ls.ID = ls.ID + "_" + eSubType.ID;  										}  									}  								}  							}  						}  						// No entities were found' so mark it as retired.  						if (ls.ID == null) {  							ls.ID = "RETIRED";  							ls.Remarks = "Retired";  						}  						// Find the modifier 1 and modifier 2 for the specified SIDC.  						if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  							if (mod1Code.Length == 2) {  								ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  								if (mod != null) {  									ls.ModifierOneID = mod.ID;  									ls.ID = ls.ID + "_" + mod.ID;  								}  							}  						}  						if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  							if (mod2Code.Length == 2) {  								ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  								if (mod != null) {  									ls.ModifierTwoID = mod.ID;  									ls.ID = ls.ID + "_" + mod.ID;  								}  							}  						}  						ls.ID = ls.ID + "_SYM";  						ls.Label = fullLegacyCode;  						// Add the legacy function code  						LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  						lfCode.Name = "2525C";  						if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  							lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  						if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  							lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  						lfCode.Value = functionCode;  						if (status != "")  							lfCode.Description = status;  						if (remarks != "")  							lfCode.Remarks = remarks;  						ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  							lfCode  						};  						// Add it to the current legacy symbol set  						legacySymbols.Add (ls);  					}  				}  			}  			r.Close ();  		}  		// Done processing the input.  If there is anything in our list then add it to the  		// symbol set and re-serialize it.  Remove the existing values if they exist.  		if (legacySymbols.Count > 0) {  			ss.LegacySymbols = legacySymbols.ToArray ();  			// Serialize the symbol set  			_serializeSymbolSet (ss' destination);  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (code != "") {  	// Open the source file for read.  	if (File.Exists (source)) {  		// Lets build a list of legacy symbols to hold the results  		List<SymbolSetLegacySymbol> legacySymbols = new List<SymbolSetLegacySymbol> ();  		// Now process the input  		string line = "";  		using (StreamReader r = new StreamReader (source)) {  			while (!r.EndOfStream) {  				line = r.ReadLine ();  				string[] tokens = line.Split (''');  				string ssCode = tokens [2];  				string legacyCode = tokens [0];  				string fullLegacyCode = tokens [1];  				string mod1Code = tokens [4];  				string mod2Code = tokens [5];  				string status = tokens [6];  				string remarks = tokens [7];  				// Skip over all rows in the source file that don't match the symbol set code  				// or where the 2525C SIDC field is blank.  				if (ssCode == code && legacyCode != "") {  					// Extract the six character function code from the current 2525C SIDC.  					string functionCode = legacyCode.Substring (legacyCode.Length - 6);  					//string schemaCode = legacyCode.Substring(0' 1);  					//string dimensionCode = legacyCode.Substring(2' 1);  					string entityCode = tokens [3];  					if (entityCode.Length == 6) {  						string eCode = entityCode.Substring (0' 2);  						string etCode = entityCode.Substring (2' 2);  						string estCode = entityCode.Substring (4' 2);  						// Now that we have everything' let's find the pieces in the open symbol set  						SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  						// Find the entity' entity type' and entity subtype for the specified SIDC.  						SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  						if (entity != null) {  							ls.EntityID = entity.ID;  							ls.ID = entity.ID;  							if (etCode != "00") {  								SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  								if (eType != null) {  									ls.EntityTypeID = eType.ID;  									ls.ID = ls.ID + "_" + eType.ID;  									if (estCode != "00") {  										EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  										if (eSubType != null) {  											ls.EntitySubTypeID = eSubType.ID;  											ls.ID = ls.ID + "_" + eSubType.ID;  										}  									}  								}  							}  						}  						// No entities were found' so mark it as retired.  						if (ls.ID == null) {  							ls.ID = "RETIRED";  							ls.Remarks = "Retired";  						}  						// Find the modifier 1 and modifier 2 for the specified SIDC.  						if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  							if (mod1Code.Length == 2) {  								ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  								if (mod != null) {  									ls.ModifierOneID = mod.ID;  									ls.ID = ls.ID + "_" + mod.ID;  								}  							}  						}  						if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  							if (mod2Code.Length == 2) {  								ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  								if (mod != null) {  									ls.ModifierTwoID = mod.ID;  									ls.ID = ls.ID + "_" + mod.ID;  								}  							}  						}  						ls.ID = ls.ID + "_SYM";  						ls.Label = fullLegacyCode;  						// Add the legacy function code  						LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  						lfCode.Name = "2525C";  						if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  							lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  						if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  							lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  						lfCode.Value = functionCode;  						if (status != "")  							lfCode.Description = status;  						if (remarks != "")  							lfCode.Remarks = remarks;  						ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  							lfCode  						};  						// Add it to the current legacy symbol set  						legacySymbols.Add (ls);  					}  				}  			}  			r.Close ();  		}  		// Done processing the input.  If there is anything in our list then add it to the  		// symbol set and re-serialize it.  Remove the existing values if they exist.  		if (legacySymbols.Count > 0) {  			ss.LegacySymbols = legacySymbols.ToArray ();  			// Serialize the symbol set  			_serializeSymbolSet (ss' destination);  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (code != "") {  	// Open the source file for read.  	if (File.Exists (source)) {  		// Lets build a list of legacy symbols to hold the results  		List<SymbolSetLegacySymbol> legacySymbols = new List<SymbolSetLegacySymbol> ();  		// Now process the input  		string line = "";  		using (StreamReader r = new StreamReader (source)) {  			while (!r.EndOfStream) {  				line = r.ReadLine ();  				string[] tokens = line.Split (''');  				string ssCode = tokens [2];  				string legacyCode = tokens [0];  				string fullLegacyCode = tokens [1];  				string mod1Code = tokens [4];  				string mod2Code = tokens [5];  				string status = tokens [6];  				string remarks = tokens [7];  				// Skip over all rows in the source file that don't match the symbol set code  				// or where the 2525C SIDC field is blank.  				if (ssCode == code && legacyCode != "") {  					// Extract the six character function code from the current 2525C SIDC.  					string functionCode = legacyCode.Substring (legacyCode.Length - 6);  					//string schemaCode = legacyCode.Substring(0' 1);  					//string dimensionCode = legacyCode.Substring(2' 1);  					string entityCode = tokens [3];  					if (entityCode.Length == 6) {  						string eCode = entityCode.Substring (0' 2);  						string etCode = entityCode.Substring (2' 2);  						string estCode = entityCode.Substring (4' 2);  						// Now that we have everything' let's find the pieces in the open symbol set  						SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  						// Find the entity' entity type' and entity subtype for the specified SIDC.  						SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  						if (entity != null) {  							ls.EntityID = entity.ID;  							ls.ID = entity.ID;  							if (etCode != "00") {  								SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  								if (eType != null) {  									ls.EntityTypeID = eType.ID;  									ls.ID = ls.ID + "_" + eType.ID;  									if (estCode != "00") {  										EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  										if (eSubType != null) {  											ls.EntitySubTypeID = eSubType.ID;  											ls.ID = ls.ID + "_" + eSubType.ID;  										}  									}  								}  							}  						}  						// No entities were found' so mark it as retired.  						if (ls.ID == null) {  							ls.ID = "RETIRED";  							ls.Remarks = "Retired";  						}  						// Find the modifier 1 and modifier 2 for the specified SIDC.  						if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  							if (mod1Code.Length == 2) {  								ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  								if (mod != null) {  									ls.ModifierOneID = mod.ID;  									ls.ID = ls.ID + "_" + mod.ID;  								}  							}  						}  						if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  							if (mod2Code.Length == 2) {  								ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  								if (mod != null) {  									ls.ModifierTwoID = mod.ID;  									ls.ID = ls.ID + "_" + mod.ID;  								}  							}  						}  						ls.ID = ls.ID + "_SYM";  						ls.Label = fullLegacyCode;  						// Add the legacy function code  						LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  						lfCode.Name = "2525C";  						if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  							lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  						if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  							lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  						lfCode.Value = functionCode;  						if (status != "")  							lfCode.Description = status;  						if (remarks != "")  							lfCode.Remarks = remarks;  						ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  							lfCode  						};  						// Add it to the current legacy symbol set  						legacySymbols.Add (ls);  					}  				}  			}  			r.Close ();  		}  		// Done processing the input.  If there is anything in our list then add it to the  		// symbol set and re-serialize it.  Remove the existing values if they exist.  		if (legacySymbols.Count > 0) {  			ss.LegacySymbols = legacySymbols.ToArray ();  			// Serialize the symbol set  			_serializeSymbolSet (ss' destination);  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (code != "") {  	// Open the source file for read.  	if (File.Exists (source)) {  		// Lets build a list of legacy symbols to hold the results  		List<SymbolSetLegacySymbol> legacySymbols = new List<SymbolSetLegacySymbol> ();  		// Now process the input  		string line = "";  		using (StreamReader r = new StreamReader (source)) {  			while (!r.EndOfStream) {  				line = r.ReadLine ();  				string[] tokens = line.Split (''');  				string ssCode = tokens [2];  				string legacyCode = tokens [0];  				string fullLegacyCode = tokens [1];  				string mod1Code = tokens [4];  				string mod2Code = tokens [5];  				string status = tokens [6];  				string remarks = tokens [7];  				// Skip over all rows in the source file that don't match the symbol set code  				// or where the 2525C SIDC field is blank.  				if (ssCode == code && legacyCode != "") {  					// Extract the six character function code from the current 2525C SIDC.  					string functionCode = legacyCode.Substring (legacyCode.Length - 6);  					//string schemaCode = legacyCode.Substring(0' 1);  					//string dimensionCode = legacyCode.Substring(2' 1);  					string entityCode = tokens [3];  					if (entityCode.Length == 6) {  						string eCode = entityCode.Substring (0' 2);  						string etCode = entityCode.Substring (2' 2);  						string estCode = entityCode.Substring (4' 2);  						// Now that we have everything' let's find the pieces in the open symbol set  						SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  						// Find the entity' entity type' and entity subtype for the specified SIDC.  						SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  						if (entity != null) {  							ls.EntityID = entity.ID;  							ls.ID = entity.ID;  							if (etCode != "00") {  								SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  								if (eType != null) {  									ls.EntityTypeID = eType.ID;  									ls.ID = ls.ID + "_" + eType.ID;  									if (estCode != "00") {  										EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  										if (eSubType != null) {  											ls.EntitySubTypeID = eSubType.ID;  											ls.ID = ls.ID + "_" + eSubType.ID;  										}  									}  								}  							}  						}  						// No entities were found' so mark it as retired.  						if (ls.ID == null) {  							ls.ID = "RETIRED";  							ls.Remarks = "Retired";  						}  						// Find the modifier 1 and modifier 2 for the specified SIDC.  						if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  							if (mod1Code.Length == 2) {  								ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  								if (mod != null) {  									ls.ModifierOneID = mod.ID;  									ls.ID = ls.ID + "_" + mod.ID;  								}  							}  						}  						if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  							if (mod2Code.Length == 2) {  								ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  								if (mod != null) {  									ls.ModifierTwoID = mod.ID;  									ls.ID = ls.ID + "_" + mod.ID;  								}  							}  						}  						ls.ID = ls.ID + "_SYM";  						ls.Label = fullLegacyCode;  						// Add the legacy function code  						LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  						lfCode.Name = "2525C";  						if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  							lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  						if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  							lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  						lfCode.Value = functionCode;  						if (status != "")  							lfCode.Description = status;  						if (remarks != "")  							lfCode.Remarks = remarks;  						ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  							lfCode  						};  						// Add it to the current legacy symbol set  						legacySymbols.Add (ls);  					}  				}  			}  			r.Close ();  		}  		// Done processing the input.  If there is anything in our list then add it to the  		// symbol set and re-serialize it.  Remove the existing values if they exist.  		if (legacySymbols.Count > 0) {  			ss.LegacySymbols = legacySymbols.ToArray ();  			// Serialize the symbol set  			_serializeSymbolSet (ss' destination);  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (code != "") {  	// Open the source file for read.  	if (File.Exists (source)) {  		// Lets build a list of legacy symbols to hold the results  		List<SymbolSetLegacySymbol> legacySymbols = new List<SymbolSetLegacySymbol> ();  		// Now process the input  		string line = "";  		using (StreamReader r = new StreamReader (source)) {  			while (!r.EndOfStream) {  				line = r.ReadLine ();  				string[] tokens = line.Split (''');  				string ssCode = tokens [2];  				string legacyCode = tokens [0];  				string fullLegacyCode = tokens [1];  				string mod1Code = tokens [4];  				string mod2Code = tokens [5];  				string status = tokens [6];  				string remarks = tokens [7];  				// Skip over all rows in the source file that don't match the symbol set code  				// or where the 2525C SIDC field is blank.  				if (ssCode == code && legacyCode != "") {  					// Extract the six character function code from the current 2525C SIDC.  					string functionCode = legacyCode.Substring (legacyCode.Length - 6);  					//string schemaCode = legacyCode.Substring(0' 1);  					//string dimensionCode = legacyCode.Substring(2' 1);  					string entityCode = tokens [3];  					if (entityCode.Length == 6) {  						string eCode = entityCode.Substring (0' 2);  						string etCode = entityCode.Substring (2' 2);  						string estCode = entityCode.Substring (4' 2);  						// Now that we have everything' let's find the pieces in the open symbol set  						SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  						// Find the entity' entity type' and entity subtype for the specified SIDC.  						SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  						if (entity != null) {  							ls.EntityID = entity.ID;  							ls.ID = entity.ID;  							if (etCode != "00") {  								SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  								if (eType != null) {  									ls.EntityTypeID = eType.ID;  									ls.ID = ls.ID + "_" + eType.ID;  									if (estCode != "00") {  										EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  										if (eSubType != null) {  											ls.EntitySubTypeID = eSubType.ID;  											ls.ID = ls.ID + "_" + eSubType.ID;  										}  									}  								}  							}  						}  						// No entities were found' so mark it as retired.  						if (ls.ID == null) {  							ls.ID = "RETIRED";  							ls.Remarks = "Retired";  						}  						// Find the modifier 1 and modifier 2 for the specified SIDC.  						if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  							if (mod1Code.Length == 2) {  								ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  								if (mod != null) {  									ls.ModifierOneID = mod.ID;  									ls.ID = ls.ID + "_" + mod.ID;  								}  							}  						}  						if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  							if (mod2Code.Length == 2) {  								ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  								if (mod != null) {  									ls.ModifierTwoID = mod.ID;  									ls.ID = ls.ID + "_" + mod.ID;  								}  							}  						}  						ls.ID = ls.ID + "_SYM";  						ls.Label = fullLegacyCode;  						// Add the legacy function code  						LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  						lfCode.Name = "2525C";  						if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  							lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  						if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  							lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  						lfCode.Value = functionCode;  						if (status != "")  							lfCode.Description = status;  						if (remarks != "")  							lfCode.Remarks = remarks;  						ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  							lfCode  						};  						// Add it to the current legacy symbol set  						legacySymbols.Add (ls);  					}  				}  			}  			r.Close ();  		}  		// Done processing the input.  If there is anything in our list then add it to the  		// symbol set and re-serialize it.  Remove the existing values if they exist.  		if (legacySymbols.Count > 0) {  			ss.LegacySymbols = legacySymbols.ToArray ();  			// Serialize the symbol set  			_serializeSymbolSet (ss' destination);  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (code != "") {  	// Open the source file for read.  	if (File.Exists (source)) {  		// Lets build a list of legacy symbols to hold the results  		List<SymbolSetLegacySymbol> legacySymbols = new List<SymbolSetLegacySymbol> ();  		// Now process the input  		string line = "";  		using (StreamReader r = new StreamReader (source)) {  			while (!r.EndOfStream) {  				line = r.ReadLine ();  				string[] tokens = line.Split (''');  				string ssCode = tokens [2];  				string legacyCode = tokens [0];  				string fullLegacyCode = tokens [1];  				string mod1Code = tokens [4];  				string mod2Code = tokens [5];  				string status = tokens [6];  				string remarks = tokens [7];  				// Skip over all rows in the source file that don't match the symbol set code  				// or where the 2525C SIDC field is blank.  				if (ssCode == code && legacyCode != "") {  					// Extract the six character function code from the current 2525C SIDC.  					string functionCode = legacyCode.Substring (legacyCode.Length - 6);  					//string schemaCode = legacyCode.Substring(0' 1);  					//string dimensionCode = legacyCode.Substring(2' 1);  					string entityCode = tokens [3];  					if (entityCode.Length == 6) {  						string eCode = entityCode.Substring (0' 2);  						string etCode = entityCode.Substring (2' 2);  						string estCode = entityCode.Substring (4' 2);  						// Now that we have everything' let's find the pieces in the open symbol set  						SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  						// Find the entity' entity type' and entity subtype for the specified SIDC.  						SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  						if (entity != null) {  							ls.EntityID = entity.ID;  							ls.ID = entity.ID;  							if (etCode != "00") {  								SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  								if (eType != null) {  									ls.EntityTypeID = eType.ID;  									ls.ID = ls.ID + "_" + eType.ID;  									if (estCode != "00") {  										EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  										if (eSubType != null) {  											ls.EntitySubTypeID = eSubType.ID;  											ls.ID = ls.ID + "_" + eSubType.ID;  										}  									}  								}  							}  						}  						// No entities were found' so mark it as retired.  						if (ls.ID == null) {  							ls.ID = "RETIRED";  							ls.Remarks = "Retired";  						}  						// Find the modifier 1 and modifier 2 for the specified SIDC.  						if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  							if (mod1Code.Length == 2) {  								ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  								if (mod != null) {  									ls.ModifierOneID = mod.ID;  									ls.ID = ls.ID + "_" + mod.ID;  								}  							}  						}  						if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  							if (mod2Code.Length == 2) {  								ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  								if (mod != null) {  									ls.ModifierTwoID = mod.ID;  									ls.ID = ls.ID + "_" + mod.ID;  								}  							}  						}  						ls.ID = ls.ID + "_SYM";  						ls.Label = fullLegacyCode;  						// Add the legacy function code  						LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  						lfCode.Name = "2525C";  						if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  							lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  						if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  							lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  						lfCode.Value = functionCode;  						if (status != "")  							lfCode.Description = status;  						if (remarks != "")  							lfCode.Remarks = remarks;  						ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  							lfCode  						};  						// Add it to the current legacy symbol set  						legacySymbols.Add (ls);  					}  				}  			}  			r.Close ();  		}  		// Done processing the input.  If there is anything in our list then add it to the  		// symbol set and re-serialize it.  Remove the existing values if they exist.  		if (legacySymbols.Count > 0) {  			ss.LegacySymbols = legacySymbols.ToArray ();  			// Serialize the symbol set  			_serializeSymbolSet (ss' destination);  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (code != "") {  	// Open the source file for read.  	if (File.Exists (source)) {  		// Lets build a list of legacy symbols to hold the results  		List<SymbolSetLegacySymbol> legacySymbols = new List<SymbolSetLegacySymbol> ();  		// Now process the input  		string line = "";  		using (StreamReader r = new StreamReader (source)) {  			while (!r.EndOfStream) {  				line = r.ReadLine ();  				string[] tokens = line.Split (''');  				string ssCode = tokens [2];  				string legacyCode = tokens [0];  				string fullLegacyCode = tokens [1];  				string mod1Code = tokens [4];  				string mod2Code = tokens [5];  				string status = tokens [6];  				string remarks = tokens [7];  				// Skip over all rows in the source file that don't match the symbol set code  				// or where the 2525C SIDC field is blank.  				if (ssCode == code && legacyCode != "") {  					// Extract the six character function code from the current 2525C SIDC.  					string functionCode = legacyCode.Substring (legacyCode.Length - 6);  					//string schemaCode = legacyCode.Substring(0' 1);  					//string dimensionCode = legacyCode.Substring(2' 1);  					string entityCode = tokens [3];  					if (entityCode.Length == 6) {  						string eCode = entityCode.Substring (0' 2);  						string etCode = entityCode.Substring (2' 2);  						string estCode = entityCode.Substring (4' 2);  						// Now that we have everything' let's find the pieces in the open symbol set  						SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  						// Find the entity' entity type' and entity subtype for the specified SIDC.  						SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  						if (entity != null) {  							ls.EntityID = entity.ID;  							ls.ID = entity.ID;  							if (etCode != "00") {  								SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  								if (eType != null) {  									ls.EntityTypeID = eType.ID;  									ls.ID = ls.ID + "_" + eType.ID;  									if (estCode != "00") {  										EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  										if (eSubType != null) {  											ls.EntitySubTypeID = eSubType.ID;  											ls.ID = ls.ID + "_" + eSubType.ID;  										}  									}  								}  							}  						}  						// No entities were found' so mark it as retired.  						if (ls.ID == null) {  							ls.ID = "RETIRED";  							ls.Remarks = "Retired";  						}  						// Find the modifier 1 and modifier 2 for the specified SIDC.  						if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  							if (mod1Code.Length == 2) {  								ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  								if (mod != null) {  									ls.ModifierOneID = mod.ID;  									ls.ID = ls.ID + "_" + mod.ID;  								}  							}  						}  						if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  							if (mod2Code.Length == 2) {  								ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  								if (mod != null) {  									ls.ModifierTwoID = mod.ID;  									ls.ID = ls.ID + "_" + mod.ID;  								}  							}  						}  						ls.ID = ls.ID + "_SYM";  						ls.Label = fullLegacyCode;  						// Add the legacy function code  						LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  						lfCode.Name = "2525C";  						if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  							lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  						if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  							lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  						lfCode.Value = functionCode;  						if (status != "")  							lfCode.Description = status;  						if (remarks != "")  							lfCode.Remarks = remarks;  						ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  							lfCode  						};  						// Add it to the current legacy symbol set  						legacySymbols.Add (ls);  					}  				}  			}  			r.Close ();  		}  		// Done processing the input.  If there is anything in our list then add it to the  		// symbol set and re-serialize it.  Remove the existing values if they exist.  		if (legacySymbols.Count > 0) {  			ss.LegacySymbols = legacySymbols.ToArray ();  			// Serialize the symbol set  			_serializeSymbolSet (ss' destination);  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (code != "") {  	// Open the source file for read.  	if (File.Exists (source)) {  		// Lets build a list of legacy symbols to hold the results  		List<SymbolSetLegacySymbol> legacySymbols = new List<SymbolSetLegacySymbol> ();  		// Now process the input  		string line = "";  		using (StreamReader r = new StreamReader (source)) {  			while (!r.EndOfStream) {  				line = r.ReadLine ();  				string[] tokens = line.Split (''');  				string ssCode = tokens [2];  				string legacyCode = tokens [0];  				string fullLegacyCode = tokens [1];  				string mod1Code = tokens [4];  				string mod2Code = tokens [5];  				string status = tokens [6];  				string remarks = tokens [7];  				// Skip over all rows in the source file that don't match the symbol set code  				// or where the 2525C SIDC field is blank.  				if (ssCode == code && legacyCode != "") {  					// Extract the six character function code from the current 2525C SIDC.  					string functionCode = legacyCode.Substring (legacyCode.Length - 6);  					//string schemaCode = legacyCode.Substring(0' 1);  					//string dimensionCode = legacyCode.Substring(2' 1);  					string entityCode = tokens [3];  					if (entityCode.Length == 6) {  						string eCode = entityCode.Substring (0' 2);  						string etCode = entityCode.Substring (2' 2);  						string estCode = entityCode.Substring (4' 2);  						// Now that we have everything' let's find the pieces in the open symbol set  						SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  						// Find the entity' entity type' and entity subtype for the specified SIDC.  						SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  						if (entity != null) {  							ls.EntityID = entity.ID;  							ls.ID = entity.ID;  							if (etCode != "00") {  								SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  								if (eType != null) {  									ls.EntityTypeID = eType.ID;  									ls.ID = ls.ID + "_" + eType.ID;  									if (estCode != "00") {  										EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  										if (eSubType != null) {  											ls.EntitySubTypeID = eSubType.ID;  											ls.ID = ls.ID + "_" + eSubType.ID;  										}  									}  								}  							}  						}  						// No entities were found' so mark it as retired.  						if (ls.ID == null) {  							ls.ID = "RETIRED";  							ls.Remarks = "Retired";  						}  						// Find the modifier 1 and modifier 2 for the specified SIDC.  						if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  							if (mod1Code.Length == 2) {  								ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  								if (mod != null) {  									ls.ModifierOneID = mod.ID;  									ls.ID = ls.ID + "_" + mod.ID;  								}  							}  						}  						if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  							if (mod2Code.Length == 2) {  								ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  								if (mod != null) {  									ls.ModifierTwoID = mod.ID;  									ls.ID = ls.ID + "_" + mod.ID;  								}  							}  						}  						ls.ID = ls.ID + "_SYM";  						ls.Label = fullLegacyCode;  						// Add the legacy function code  						LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  						lfCode.Name = "2525C";  						if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  							lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  						if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  							lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  						lfCode.Value = functionCode;  						if (status != "")  							lfCode.Description = status;  						if (remarks != "")  							lfCode.Remarks = remarks;  						ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  							lfCode  						};  						// Add it to the current legacy symbol set  						legacySymbols.Add (ls);  					}  				}  			}  			r.Close ();  		}  		// Done processing the input.  If there is anything in our list then add it to the  		// symbol set and re-serialize it.  Remove the existing values if they exist.  		if (legacySymbols.Count > 0) {  			ss.LegacySymbols = legacySymbols.ToArray ();  			// Serialize the symbol set  			_serializeSymbolSet (ss' destination);  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (code != "") {  	// Open the source file for read.  	if (File.Exists (source)) {  		// Lets build a list of legacy symbols to hold the results  		List<SymbolSetLegacySymbol> legacySymbols = new List<SymbolSetLegacySymbol> ();  		// Now process the input  		string line = "";  		using (StreamReader r = new StreamReader (source)) {  			while (!r.EndOfStream) {  				line = r.ReadLine ();  				string[] tokens = line.Split (''');  				string ssCode = tokens [2];  				string legacyCode = tokens [0];  				string fullLegacyCode = tokens [1];  				string mod1Code = tokens [4];  				string mod2Code = tokens [5];  				string status = tokens [6];  				string remarks = tokens [7];  				// Skip over all rows in the source file that don't match the symbol set code  				// or where the 2525C SIDC field is blank.  				if (ssCode == code && legacyCode != "") {  					// Extract the six character function code from the current 2525C SIDC.  					string functionCode = legacyCode.Substring (legacyCode.Length - 6);  					//string schemaCode = legacyCode.Substring(0' 1);  					//string dimensionCode = legacyCode.Substring(2' 1);  					string entityCode = tokens [3];  					if (entityCode.Length == 6) {  						string eCode = entityCode.Substring (0' 2);  						string etCode = entityCode.Substring (2' 2);  						string estCode = entityCode.Substring (4' 2);  						// Now that we have everything' let's find the pieces in the open symbol set  						SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  						// Find the entity' entity type' and entity subtype for the specified SIDC.  						SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  						if (entity != null) {  							ls.EntityID = entity.ID;  							ls.ID = entity.ID;  							if (etCode != "00") {  								SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  								if (eType != null) {  									ls.EntityTypeID = eType.ID;  									ls.ID = ls.ID + "_" + eType.ID;  									if (estCode != "00") {  										EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  										if (eSubType != null) {  											ls.EntitySubTypeID = eSubType.ID;  											ls.ID = ls.ID + "_" + eSubType.ID;  										}  									}  								}  							}  						}  						// No entities were found' so mark it as retired.  						if (ls.ID == null) {  							ls.ID = "RETIRED";  							ls.Remarks = "Retired";  						}  						// Find the modifier 1 and modifier 2 for the specified SIDC.  						if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  							if (mod1Code.Length == 2) {  								ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  								if (mod != null) {  									ls.ModifierOneID = mod.ID;  									ls.ID = ls.ID + "_" + mod.ID;  								}  							}  						}  						if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  							if (mod2Code.Length == 2) {  								ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  								if (mod != null) {  									ls.ModifierTwoID = mod.ID;  									ls.ID = ls.ID + "_" + mod.ID;  								}  							}  						}  						ls.ID = ls.ID + "_SYM";  						ls.Label = fullLegacyCode;  						// Add the legacy function code  						LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  						lfCode.Name = "2525C";  						if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  							lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  						if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  							lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  						lfCode.Value = functionCode;  						if (status != "")  							lfCode.Description = status;  						if (remarks != "")  							lfCode.Remarks = remarks;  						ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  							lfCode  						};  						// Add it to the current legacy symbol set  						legacySymbols.Add (ls);  					}  				}  			}  			r.Close ();  		}  		// Done processing the input.  If there is anything in our list then add it to the  		// symbol set and re-serialize it.  Remove the existing values if they exist.  		if (legacySymbols.Count > 0) {  			ss.LegacySymbols = legacySymbols.ToArray ();  			// Serialize the symbol set  			_serializeSymbolSet (ss' destination);  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (code != "") {  	// Open the source file for read.  	if (File.Exists (source)) {  		// Lets build a list of legacy symbols to hold the results  		List<SymbolSetLegacySymbol> legacySymbols = new List<SymbolSetLegacySymbol> ();  		// Now process the input  		string line = "";  		using (StreamReader r = new StreamReader (source)) {  			while (!r.EndOfStream) {  				line = r.ReadLine ();  				string[] tokens = line.Split (''');  				string ssCode = tokens [2];  				string legacyCode = tokens [0];  				string fullLegacyCode = tokens [1];  				string mod1Code = tokens [4];  				string mod2Code = tokens [5];  				string status = tokens [6];  				string remarks = tokens [7];  				// Skip over all rows in the source file that don't match the symbol set code  				// or where the 2525C SIDC field is blank.  				if (ssCode == code && legacyCode != "") {  					// Extract the six character function code from the current 2525C SIDC.  					string functionCode = legacyCode.Substring (legacyCode.Length - 6);  					//string schemaCode = legacyCode.Substring(0' 1);  					//string dimensionCode = legacyCode.Substring(2' 1);  					string entityCode = tokens [3];  					if (entityCode.Length == 6) {  						string eCode = entityCode.Substring (0' 2);  						string etCode = entityCode.Substring (2' 2);  						string estCode = entityCode.Substring (4' 2);  						// Now that we have everything' let's find the pieces in the open symbol set  						SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  						// Find the entity' entity type' and entity subtype for the specified SIDC.  						SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  						if (entity != null) {  							ls.EntityID = entity.ID;  							ls.ID = entity.ID;  							if (etCode != "00") {  								SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  								if (eType != null) {  									ls.EntityTypeID = eType.ID;  									ls.ID = ls.ID + "_" + eType.ID;  									if (estCode != "00") {  										EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  										if (eSubType != null) {  											ls.EntitySubTypeID = eSubType.ID;  											ls.ID = ls.ID + "_" + eSubType.ID;  										}  									}  								}  							}  						}  						// No entities were found' so mark it as retired.  						if (ls.ID == null) {  							ls.ID = "RETIRED";  							ls.Remarks = "Retired";  						}  						// Find the modifier 1 and modifier 2 for the specified SIDC.  						if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  							if (mod1Code.Length == 2) {  								ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  								if (mod != null) {  									ls.ModifierOneID = mod.ID;  									ls.ID = ls.ID + "_" + mod.ID;  								}  							}  						}  						if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  							if (mod2Code.Length == 2) {  								ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  								if (mod != null) {  									ls.ModifierTwoID = mod.ID;  									ls.ID = ls.ID + "_" + mod.ID;  								}  							}  						}  						ls.ID = ls.ID + "_SYM";  						ls.Label = fullLegacyCode;  						// Add the legacy function code  						LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  						lfCode.Name = "2525C";  						if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  							lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  						if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  							lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  						lfCode.Value = functionCode;  						if (status != "")  							lfCode.Description = status;  						if (remarks != "")  							lfCode.Remarks = remarks;  						ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  							lfCode  						};  						// Add it to the current legacy symbol set  						legacySymbols.Add (ls);  					}  				}  			}  			r.Close ();  		}  		// Done processing the input.  If there is anything in our list then add it to the  		// symbol set and re-serialize it.  Remove the existing values if they exist.  		if (legacySymbols.Count > 0) {  			ss.LegacySymbols = legacySymbols.ToArray ();  			// Serialize the symbol set  			_serializeSymbolSet (ss' destination);  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (code != "") {  	// Open the source file for read.  	if (File.Exists (source)) {  		// Lets build a list of legacy symbols to hold the results  		List<SymbolSetLegacySymbol> legacySymbols = new List<SymbolSetLegacySymbol> ();  		// Now process the input  		string line = "";  		using (StreamReader r = new StreamReader (source)) {  			while (!r.EndOfStream) {  				line = r.ReadLine ();  				string[] tokens = line.Split (''');  				string ssCode = tokens [2];  				string legacyCode = tokens [0];  				string fullLegacyCode = tokens [1];  				string mod1Code = tokens [4];  				string mod2Code = tokens [5];  				string status = tokens [6];  				string remarks = tokens [7];  				// Skip over all rows in the source file that don't match the symbol set code  				// or where the 2525C SIDC field is blank.  				if (ssCode == code && legacyCode != "") {  					// Extract the six character function code from the current 2525C SIDC.  					string functionCode = legacyCode.Substring (legacyCode.Length - 6);  					//string schemaCode = legacyCode.Substring(0' 1);  					//string dimensionCode = legacyCode.Substring(2' 1);  					string entityCode = tokens [3];  					if (entityCode.Length == 6) {  						string eCode = entityCode.Substring (0' 2);  						string etCode = entityCode.Substring (2' 2);  						string estCode = entityCode.Substring (4' 2);  						// Now that we have everything' let's find the pieces in the open symbol set  						SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  						// Find the entity' entity type' and entity subtype for the specified SIDC.  						SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  						if (entity != null) {  							ls.EntityID = entity.ID;  							ls.ID = entity.ID;  							if (etCode != "00") {  								SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  								if (eType != null) {  									ls.EntityTypeID = eType.ID;  									ls.ID = ls.ID + "_" + eType.ID;  									if (estCode != "00") {  										EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  										if (eSubType != null) {  											ls.EntitySubTypeID = eSubType.ID;  											ls.ID = ls.ID + "_" + eSubType.ID;  										}  									}  								}  							}  						}  						// No entities were found' so mark it as retired.  						if (ls.ID == null) {  							ls.ID = "RETIRED";  							ls.Remarks = "Retired";  						}  						// Find the modifier 1 and modifier 2 for the specified SIDC.  						if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  							if (mod1Code.Length == 2) {  								ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  								if (mod != null) {  									ls.ModifierOneID = mod.ID;  									ls.ID = ls.ID + "_" + mod.ID;  								}  							}  						}  						if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  							if (mod2Code.Length == 2) {  								ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  								if (mod != null) {  									ls.ModifierTwoID = mod.ID;  									ls.ID = ls.ID + "_" + mod.ID;  								}  							}  						}  						ls.ID = ls.ID + "_SYM";  						ls.Label = fullLegacyCode;  						// Add the legacy function code  						LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  						lfCode.Name = "2525C";  						if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  							lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  						if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  							lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  						lfCode.Value = functionCode;  						if (status != "")  							lfCode.Description = status;  						if (remarks != "")  							lfCode.Remarks = remarks;  						ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  							lfCode  						};  						// Add it to the current legacy symbol set  						legacySymbols.Add (ls);  					}  				}  			}  			r.Close ();  		}  		// Done processing the input.  If there is anything in our list then add it to the  		// symbol set and re-serialize it.  Remove the existing values if they exist.  		if (legacySymbols.Count > 0) {  			ss.LegacySymbols = legacySymbols.ToArray ();  			// Serialize the symbol set  			_serializeSymbolSet (ss' destination);  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (code != "") {  	// Open the source file for read.  	if (File.Exists (source)) {  		// Lets build a list of legacy symbols to hold the results  		List<SymbolSetLegacySymbol> legacySymbols = new List<SymbolSetLegacySymbol> ();  		// Now process the input  		string line = "";  		using (StreamReader r = new StreamReader (source)) {  			while (!r.EndOfStream) {  				line = r.ReadLine ();  				string[] tokens = line.Split (''');  				string ssCode = tokens [2];  				string legacyCode = tokens [0];  				string fullLegacyCode = tokens [1];  				string mod1Code = tokens [4];  				string mod2Code = tokens [5];  				string status = tokens [6];  				string remarks = tokens [7];  				// Skip over all rows in the source file that don't match the symbol set code  				// or where the 2525C SIDC field is blank.  				if (ssCode == code && legacyCode != "") {  					// Extract the six character function code from the current 2525C SIDC.  					string functionCode = legacyCode.Substring (legacyCode.Length - 6);  					//string schemaCode = legacyCode.Substring(0' 1);  					//string dimensionCode = legacyCode.Substring(2' 1);  					string entityCode = tokens [3];  					if (entityCode.Length == 6) {  						string eCode = entityCode.Substring (0' 2);  						string etCode = entityCode.Substring (2' 2);  						string estCode = entityCode.Substring (4' 2);  						// Now that we have everything' let's find the pieces in the open symbol set  						SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  						// Find the entity' entity type' and entity subtype for the specified SIDC.  						SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  						if (entity != null) {  							ls.EntityID = entity.ID;  							ls.ID = entity.ID;  							if (etCode != "00") {  								SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  								if (eType != null) {  									ls.EntityTypeID = eType.ID;  									ls.ID = ls.ID + "_" + eType.ID;  									if (estCode != "00") {  										EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  										if (eSubType != null) {  											ls.EntitySubTypeID = eSubType.ID;  											ls.ID = ls.ID + "_" + eSubType.ID;  										}  									}  								}  							}  						}  						// No entities were found' so mark it as retired.  						if (ls.ID == null) {  							ls.ID = "RETIRED";  							ls.Remarks = "Retired";  						}  						// Find the modifier 1 and modifier 2 for the specified SIDC.  						if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  							if (mod1Code.Length == 2) {  								ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  								if (mod != null) {  									ls.ModifierOneID = mod.ID;  									ls.ID = ls.ID + "_" + mod.ID;  								}  							}  						}  						if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  							if (mod2Code.Length == 2) {  								ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  								if (mod != null) {  									ls.ModifierTwoID = mod.ID;  									ls.ID = ls.ID + "_" + mod.ID;  								}  							}  						}  						ls.ID = ls.ID + "_SYM";  						ls.Label = fullLegacyCode;  						// Add the legacy function code  						LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  						lfCode.Name = "2525C";  						if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  							lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  						if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  							lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  						lfCode.Value = functionCode;  						if (status != "")  							lfCode.Description = status;  						if (remarks != "")  							lfCode.Remarks = remarks;  						ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  							lfCode  						};  						// Add it to the current legacy symbol set  						legacySymbols.Add (ls);  					}  				}  			}  			r.Close ();  		}  		// Done processing the input.  If there is anything in our list then add it to the  		// symbol set and re-serialize it.  Remove the existing values if they exist.  		if (legacySymbols.Count > 0) {  			ss.LegacySymbols = legacySymbols.ToArray ();  			// Serialize the symbol set  			_serializeSymbolSet (ss' destination);  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (code != "") {  	// Open the source file for read.  	if (File.Exists (source)) {  		// Lets build a list of legacy symbols to hold the results  		List<SymbolSetLegacySymbol> legacySymbols = new List<SymbolSetLegacySymbol> ();  		// Now process the input  		string line = "";  		using (StreamReader r = new StreamReader (source)) {  			while (!r.EndOfStream) {  				line = r.ReadLine ();  				string[] tokens = line.Split (''');  				string ssCode = tokens [2];  				string legacyCode = tokens [0];  				string fullLegacyCode = tokens [1];  				string mod1Code = tokens [4];  				string mod2Code = tokens [5];  				string status = tokens [6];  				string remarks = tokens [7];  				// Skip over all rows in the source file that don't match the symbol set code  				// or where the 2525C SIDC field is blank.  				if (ssCode == code && legacyCode != "") {  					// Extract the six character function code from the current 2525C SIDC.  					string functionCode = legacyCode.Substring (legacyCode.Length - 6);  					//string schemaCode = legacyCode.Substring(0' 1);  					//string dimensionCode = legacyCode.Substring(2' 1);  					string entityCode = tokens [3];  					if (entityCode.Length == 6) {  						string eCode = entityCode.Substring (0' 2);  						string etCode = entityCode.Substring (2' 2);  						string estCode = entityCode.Substring (4' 2);  						// Now that we have everything' let's find the pieces in the open symbol set  						SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  						// Find the entity' entity type' and entity subtype for the specified SIDC.  						SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  						if (entity != null) {  							ls.EntityID = entity.ID;  							ls.ID = entity.ID;  							if (etCode != "00") {  								SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  								if (eType != null) {  									ls.EntityTypeID = eType.ID;  									ls.ID = ls.ID + "_" + eType.ID;  									if (estCode != "00") {  										EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  										if (eSubType != null) {  											ls.EntitySubTypeID = eSubType.ID;  											ls.ID = ls.ID + "_" + eSubType.ID;  										}  									}  								}  							}  						}  						// No entities were found' so mark it as retired.  						if (ls.ID == null) {  							ls.ID = "RETIRED";  							ls.Remarks = "Retired";  						}  						// Find the modifier 1 and modifier 2 for the specified SIDC.  						if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  							if (mod1Code.Length == 2) {  								ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  								if (mod != null) {  									ls.ModifierOneID = mod.ID;  									ls.ID = ls.ID + "_" + mod.ID;  								}  							}  						}  						if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  							if (mod2Code.Length == 2) {  								ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  								if (mod != null) {  									ls.ModifierTwoID = mod.ID;  									ls.ID = ls.ID + "_" + mod.ID;  								}  							}  						}  						ls.ID = ls.ID + "_SYM";  						ls.Label = fullLegacyCode;  						// Add the legacy function code  						LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  						lfCode.Name = "2525C";  						if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  							lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  						if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  							lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  						lfCode.Value = functionCode;  						if (status != "")  							lfCode.Description = status;  						if (remarks != "")  							lfCode.Remarks = remarks;  						ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  							lfCode  						};  						// Add it to the current legacy symbol set  						legacySymbols.Add (ls);  					}  				}  			}  			r.Close ();  		}  		// Done processing the input.  If there is anything in our list then add it to the  		// symbol set and re-serialize it.  Remove the existing values if they exist.  		if (legacySymbols.Count > 0) {  			ss.LegacySymbols = legacySymbols.ToArray ();  			// Serialize the symbol set  			_serializeSymbolSet (ss' destination);  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (code != "") {  	// Open the source file for read.  	if (File.Exists (source)) {  		// Lets build a list of legacy symbols to hold the results  		List<SymbolSetLegacySymbol> legacySymbols = new List<SymbolSetLegacySymbol> ();  		// Now process the input  		string line = "";  		using (StreamReader r = new StreamReader (source)) {  			while (!r.EndOfStream) {  				line = r.ReadLine ();  				string[] tokens = line.Split (''');  				string ssCode = tokens [2];  				string legacyCode = tokens [0];  				string fullLegacyCode = tokens [1];  				string mod1Code = tokens [4];  				string mod2Code = tokens [5];  				string status = tokens [6];  				string remarks = tokens [7];  				// Skip over all rows in the source file that don't match the symbol set code  				// or where the 2525C SIDC field is blank.  				if (ssCode == code && legacyCode != "") {  					// Extract the six character function code from the current 2525C SIDC.  					string functionCode = legacyCode.Substring (legacyCode.Length - 6);  					//string schemaCode = legacyCode.Substring(0' 1);  					//string dimensionCode = legacyCode.Substring(2' 1);  					string entityCode = tokens [3];  					if (entityCode.Length == 6) {  						string eCode = entityCode.Substring (0' 2);  						string etCode = entityCode.Substring (2' 2);  						string estCode = entityCode.Substring (4' 2);  						// Now that we have everything' let's find the pieces in the open symbol set  						SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  						// Find the entity' entity type' and entity subtype for the specified SIDC.  						SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  						if (entity != null) {  							ls.EntityID = entity.ID;  							ls.ID = entity.ID;  							if (etCode != "00") {  								SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  								if (eType != null) {  									ls.EntityTypeID = eType.ID;  									ls.ID = ls.ID + "_" + eType.ID;  									if (estCode != "00") {  										EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  										if (eSubType != null) {  											ls.EntitySubTypeID = eSubType.ID;  											ls.ID = ls.ID + "_" + eSubType.ID;  										}  									}  								}  							}  						}  						// No entities were found' so mark it as retired.  						if (ls.ID == null) {  							ls.ID = "RETIRED";  							ls.Remarks = "Retired";  						}  						// Find the modifier 1 and modifier 2 for the specified SIDC.  						if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  							if (mod1Code.Length == 2) {  								ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  								if (mod != null) {  									ls.ModifierOneID = mod.ID;  									ls.ID = ls.ID + "_" + mod.ID;  								}  							}  						}  						if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  							if (mod2Code.Length == 2) {  								ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  								if (mod != null) {  									ls.ModifierTwoID = mod.ID;  									ls.ID = ls.ID + "_" + mod.ID;  								}  							}  						}  						ls.ID = ls.ID + "_SYM";  						ls.Label = fullLegacyCode;  						// Add the legacy function code  						LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  						lfCode.Name = "2525C";  						if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  							lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  						if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  							lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  						lfCode.Value = functionCode;  						if (status != "")  							lfCode.Description = status;  						if (remarks != "")  							lfCode.Remarks = remarks;  						ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  							lfCode  						};  						// Add it to the current legacy symbol set  						legacySymbols.Add (ls);  					}  				}  			}  			r.Close ();  		}  		// Done processing the input.  If there is anything in our list then add it to the  		// symbol set and re-serialize it.  Remove the existing values if they exist.  		if (legacySymbols.Count > 0) {  			ss.LegacySymbols = legacySymbols.ToArray ();  			// Serialize the symbol set  			_serializeSymbolSet (ss' destination);  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (File.Exists (source)) {  	// Lets build a list of legacy symbols to hold the results  	List<SymbolSetLegacySymbol> legacySymbols = new List<SymbolSetLegacySymbol> ();  	// Now process the input  	string line = "";  	using (StreamReader r = new StreamReader (source)) {  		while (!r.EndOfStream) {  			line = r.ReadLine ();  			string[] tokens = line.Split (''');  			string ssCode = tokens [2];  			string legacyCode = tokens [0];  			string fullLegacyCode = tokens [1];  			string mod1Code = tokens [4];  			string mod2Code = tokens [5];  			string status = tokens [6];  			string remarks = tokens [7];  			// Skip over all rows in the source file that don't match the symbol set code  			// or where the 2525C SIDC field is blank.  			if (ssCode == code && legacyCode != "") {  				// Extract the six character function code from the current 2525C SIDC.  				string functionCode = legacyCode.Substring (legacyCode.Length - 6);  				//string schemaCode = legacyCode.Substring(0' 1);  				//string dimensionCode = legacyCode.Substring(2' 1);  				string entityCode = tokens [3];  				if (entityCode.Length == 6) {  					string eCode = entityCode.Substring (0' 2);  					string etCode = entityCode.Substring (2' 2);  					string estCode = entityCode.Substring (4' 2);  					// Now that we have everything' let's find the pieces in the open symbol set  					SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  					// Find the entity' entity type' and entity subtype for the specified SIDC.  					SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  					if (entity != null) {  						ls.EntityID = entity.ID;  						ls.ID = entity.ID;  						if (etCode != "00") {  							SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  							if (eType != null) {  								ls.EntityTypeID = eType.ID;  								ls.ID = ls.ID + "_" + eType.ID;  								if (estCode != "00") {  									EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  									if (eSubType != null) {  										ls.EntitySubTypeID = eSubType.ID;  										ls.ID = ls.ID + "_" + eSubType.ID;  									}  								}  							}  						}  					}  					// No entities were found' so mark it as retired.  					if (ls.ID == null) {  						ls.ID = "RETIRED";  						ls.Remarks = "Retired";  					}  					// Find the modifier 1 and modifier 2 for the specified SIDC.  					if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  						if (mod1Code.Length == 2) {  							ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  							if (mod != null) {  								ls.ModifierOneID = mod.ID;  								ls.ID = ls.ID + "_" + mod.ID;  							}  						}  					}  					if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  						if (mod2Code.Length == 2) {  							ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  							if (mod != null) {  								ls.ModifierTwoID = mod.ID;  								ls.ID = ls.ID + "_" + mod.ID;  							}  						}  					}  					ls.ID = ls.ID + "_SYM";  					ls.Label = fullLegacyCode;  					// Add the legacy function code  					LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  					lfCode.Name = "2525C";  					if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  						lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  					if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  						lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  					lfCode.Value = functionCode;  					if (status != "")  						lfCode.Description = status;  					if (remarks != "")  						lfCode.Remarks = remarks;  					ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  						lfCode  					};  					// Add it to the current legacy symbol set  					legacySymbols.Add (ls);  				}  			}  		}  		r.Close ();  	}  	// Done processing the input.  If there is anything in our list then add it to the  	// symbol set and re-serialize it.  Remove the existing values if they exist.  	if (legacySymbols.Count > 0) {  		ss.LegacySymbols = legacySymbols.ToArray ();  		// Serialize the symbol set  		_serializeSymbolSet (ss' destination);  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (File.Exists (source)) {  	// Lets build a list of legacy symbols to hold the results  	List<SymbolSetLegacySymbol> legacySymbols = new List<SymbolSetLegacySymbol> ();  	// Now process the input  	string line = "";  	using (StreamReader r = new StreamReader (source)) {  		while (!r.EndOfStream) {  			line = r.ReadLine ();  			string[] tokens = line.Split (''');  			string ssCode = tokens [2];  			string legacyCode = tokens [0];  			string fullLegacyCode = tokens [1];  			string mod1Code = tokens [4];  			string mod2Code = tokens [5];  			string status = tokens [6];  			string remarks = tokens [7];  			// Skip over all rows in the source file that don't match the symbol set code  			// or where the 2525C SIDC field is blank.  			if (ssCode == code && legacyCode != "") {  				// Extract the six character function code from the current 2525C SIDC.  				string functionCode = legacyCode.Substring (legacyCode.Length - 6);  				//string schemaCode = legacyCode.Substring(0' 1);  				//string dimensionCode = legacyCode.Substring(2' 1);  				string entityCode = tokens [3];  				if (entityCode.Length == 6) {  					string eCode = entityCode.Substring (0' 2);  					string etCode = entityCode.Substring (2' 2);  					string estCode = entityCode.Substring (4' 2);  					// Now that we have everything' let's find the pieces in the open symbol set  					SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  					// Find the entity' entity type' and entity subtype for the specified SIDC.  					SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  					if (entity != null) {  						ls.EntityID = entity.ID;  						ls.ID = entity.ID;  						if (etCode != "00") {  							SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  							if (eType != null) {  								ls.EntityTypeID = eType.ID;  								ls.ID = ls.ID + "_" + eType.ID;  								if (estCode != "00") {  									EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  									if (eSubType != null) {  										ls.EntitySubTypeID = eSubType.ID;  										ls.ID = ls.ID + "_" + eSubType.ID;  									}  								}  							}  						}  					}  					// No entities were found' so mark it as retired.  					if (ls.ID == null) {  						ls.ID = "RETIRED";  						ls.Remarks = "Retired";  					}  					// Find the modifier 1 and modifier 2 for the specified SIDC.  					if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  						if (mod1Code.Length == 2) {  							ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  							if (mod != null) {  								ls.ModifierOneID = mod.ID;  								ls.ID = ls.ID + "_" + mod.ID;  							}  						}  					}  					if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  						if (mod2Code.Length == 2) {  							ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  							if (mod != null) {  								ls.ModifierTwoID = mod.ID;  								ls.ID = ls.ID + "_" + mod.ID;  							}  						}  					}  					ls.ID = ls.ID + "_SYM";  					ls.Label = fullLegacyCode;  					// Add the legacy function code  					LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  					lfCode.Name = "2525C";  					if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  						lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  					if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  						lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  					lfCode.Value = functionCode;  					if (status != "")  						lfCode.Description = status;  					if (remarks != "")  						lfCode.Remarks = remarks;  					ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  						lfCode  					};  					// Add it to the current legacy symbol set  					legacySymbols.Add (ls);  				}  			}  		}  		r.Close ();  	}  	// Done processing the input.  If there is anything in our list then add it to the  	// symbol set and re-serialize it.  Remove the existing values if they exist.  	if (legacySymbols.Count > 0) {  		ss.LegacySymbols = legacySymbols.ToArray ();  		// Serialize the symbol set  		_serializeSymbolSet (ss' destination);  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (File.Exists (source)) {  	// Lets build a list of legacy symbols to hold the results  	List<SymbolSetLegacySymbol> legacySymbols = new List<SymbolSetLegacySymbol> ();  	// Now process the input  	string line = "";  	using (StreamReader r = new StreamReader (source)) {  		while (!r.EndOfStream) {  			line = r.ReadLine ();  			string[] tokens = line.Split (''');  			string ssCode = tokens [2];  			string legacyCode = tokens [0];  			string fullLegacyCode = tokens [1];  			string mod1Code = tokens [4];  			string mod2Code = tokens [5];  			string status = tokens [6];  			string remarks = tokens [7];  			// Skip over all rows in the source file that don't match the symbol set code  			// or where the 2525C SIDC field is blank.  			if (ssCode == code && legacyCode != "") {  				// Extract the six character function code from the current 2525C SIDC.  				string functionCode = legacyCode.Substring (legacyCode.Length - 6);  				//string schemaCode = legacyCode.Substring(0' 1);  				//string dimensionCode = legacyCode.Substring(2' 1);  				string entityCode = tokens [3];  				if (entityCode.Length == 6) {  					string eCode = entityCode.Substring (0' 2);  					string etCode = entityCode.Substring (2' 2);  					string estCode = entityCode.Substring (4' 2);  					// Now that we have everything' let's find the pieces in the open symbol set  					SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  					// Find the entity' entity type' and entity subtype for the specified SIDC.  					SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  					if (entity != null) {  						ls.EntityID = entity.ID;  						ls.ID = entity.ID;  						if (etCode != "00") {  							SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  							if (eType != null) {  								ls.EntityTypeID = eType.ID;  								ls.ID = ls.ID + "_" + eType.ID;  								if (estCode != "00") {  									EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  									if (eSubType != null) {  										ls.EntitySubTypeID = eSubType.ID;  										ls.ID = ls.ID + "_" + eSubType.ID;  									}  								}  							}  						}  					}  					// No entities were found' so mark it as retired.  					if (ls.ID == null) {  						ls.ID = "RETIRED";  						ls.Remarks = "Retired";  					}  					// Find the modifier 1 and modifier 2 for the specified SIDC.  					if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  						if (mod1Code.Length == 2) {  							ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  							if (mod != null) {  								ls.ModifierOneID = mod.ID;  								ls.ID = ls.ID + "_" + mod.ID;  							}  						}  					}  					if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  						if (mod2Code.Length == 2) {  							ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  							if (mod != null) {  								ls.ModifierTwoID = mod.ID;  								ls.ID = ls.ID + "_" + mod.ID;  							}  						}  					}  					ls.ID = ls.ID + "_SYM";  					ls.Label = fullLegacyCode;  					// Add the legacy function code  					LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  					lfCode.Name = "2525C";  					if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  						lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  					if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  						lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  					lfCode.Value = functionCode;  					if (status != "")  						lfCode.Description = status;  					if (remarks != "")  						lfCode.Remarks = remarks;  					ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  						lfCode  					};  					// Add it to the current legacy symbol set  					legacySymbols.Add (ls);  				}  			}  		}  		r.Close ();  	}  	// Done processing the input.  If there is anything in our list then add it to the  	// symbol set and re-serialize it.  Remove the existing values if they exist.  	if (legacySymbols.Count > 0) {  		ss.LegacySymbols = legacySymbols.ToArray ();  		// Serialize the symbol set  		_serializeSymbolSet (ss' destination);  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (File.Exists (source)) {  	// Lets build a list of legacy symbols to hold the results  	List<SymbolSetLegacySymbol> legacySymbols = new List<SymbolSetLegacySymbol> ();  	// Now process the input  	string line = "";  	using (StreamReader r = new StreamReader (source)) {  		while (!r.EndOfStream) {  			line = r.ReadLine ();  			string[] tokens = line.Split (''');  			string ssCode = tokens [2];  			string legacyCode = tokens [0];  			string fullLegacyCode = tokens [1];  			string mod1Code = tokens [4];  			string mod2Code = tokens [5];  			string status = tokens [6];  			string remarks = tokens [7];  			// Skip over all rows in the source file that don't match the symbol set code  			// or where the 2525C SIDC field is blank.  			if (ssCode == code && legacyCode != "") {  				// Extract the six character function code from the current 2525C SIDC.  				string functionCode = legacyCode.Substring (legacyCode.Length - 6);  				//string schemaCode = legacyCode.Substring(0' 1);  				//string dimensionCode = legacyCode.Substring(2' 1);  				string entityCode = tokens [3];  				if (entityCode.Length == 6) {  					string eCode = entityCode.Substring (0' 2);  					string etCode = entityCode.Substring (2' 2);  					string estCode = entityCode.Substring (4' 2);  					// Now that we have everything' let's find the pieces in the open symbol set  					SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  					// Find the entity' entity type' and entity subtype for the specified SIDC.  					SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  					if (entity != null) {  						ls.EntityID = entity.ID;  						ls.ID = entity.ID;  						if (etCode != "00") {  							SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  							if (eType != null) {  								ls.EntityTypeID = eType.ID;  								ls.ID = ls.ID + "_" + eType.ID;  								if (estCode != "00") {  									EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  									if (eSubType != null) {  										ls.EntitySubTypeID = eSubType.ID;  										ls.ID = ls.ID + "_" + eSubType.ID;  									}  								}  							}  						}  					}  					// No entities were found' so mark it as retired.  					if (ls.ID == null) {  						ls.ID = "RETIRED";  						ls.Remarks = "Retired";  					}  					// Find the modifier 1 and modifier 2 for the specified SIDC.  					if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  						if (mod1Code.Length == 2) {  							ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  							if (mod != null) {  								ls.ModifierOneID = mod.ID;  								ls.ID = ls.ID + "_" + mod.ID;  							}  						}  					}  					if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  						if (mod2Code.Length == 2) {  							ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  							if (mod != null) {  								ls.ModifierTwoID = mod.ID;  								ls.ID = ls.ID + "_" + mod.ID;  							}  						}  					}  					ls.ID = ls.ID + "_SYM";  					ls.Label = fullLegacyCode;  					// Add the legacy function code  					LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  					lfCode.Name = "2525C";  					if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  						lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  					if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  						lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  					lfCode.Value = functionCode;  					if (status != "")  						lfCode.Description = status;  					if (remarks != "")  						lfCode.Remarks = remarks;  					ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  						lfCode  					};  					// Add it to the current legacy symbol set  					legacySymbols.Add (ls);  				}  			}  		}  		r.Close ();  	}  	// Done processing the input.  If there is anything in our list then add it to the  	// symbol set and re-serialize it.  Remove the existing values if they exist.  	if (legacySymbols.Count > 0) {  		ss.LegacySymbols = legacySymbols.ToArray ();  		// Serialize the symbol set  		_serializeSymbolSet (ss' destination);  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (File.Exists (source)) {  	// Lets build a list of legacy symbols to hold the results  	List<SymbolSetLegacySymbol> legacySymbols = new List<SymbolSetLegacySymbol> ();  	// Now process the input  	string line = "";  	using (StreamReader r = new StreamReader (source)) {  		while (!r.EndOfStream) {  			line = r.ReadLine ();  			string[] tokens = line.Split (''');  			string ssCode = tokens [2];  			string legacyCode = tokens [0];  			string fullLegacyCode = tokens [1];  			string mod1Code = tokens [4];  			string mod2Code = tokens [5];  			string status = tokens [6];  			string remarks = tokens [7];  			// Skip over all rows in the source file that don't match the symbol set code  			// or where the 2525C SIDC field is blank.  			if (ssCode == code && legacyCode != "") {  				// Extract the six character function code from the current 2525C SIDC.  				string functionCode = legacyCode.Substring (legacyCode.Length - 6);  				//string schemaCode = legacyCode.Substring(0' 1);  				//string dimensionCode = legacyCode.Substring(2' 1);  				string entityCode = tokens [3];  				if (entityCode.Length == 6) {  					string eCode = entityCode.Substring (0' 2);  					string etCode = entityCode.Substring (2' 2);  					string estCode = entityCode.Substring (4' 2);  					// Now that we have everything' let's find the pieces in the open symbol set  					SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  					// Find the entity' entity type' and entity subtype for the specified SIDC.  					SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  					if (entity != null) {  						ls.EntityID = entity.ID;  						ls.ID = entity.ID;  						if (etCode != "00") {  							SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  							if (eType != null) {  								ls.EntityTypeID = eType.ID;  								ls.ID = ls.ID + "_" + eType.ID;  								if (estCode != "00") {  									EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  									if (eSubType != null) {  										ls.EntitySubTypeID = eSubType.ID;  										ls.ID = ls.ID + "_" + eSubType.ID;  									}  								}  							}  						}  					}  					// No entities were found' so mark it as retired.  					if (ls.ID == null) {  						ls.ID = "RETIRED";  						ls.Remarks = "Retired";  					}  					// Find the modifier 1 and modifier 2 for the specified SIDC.  					if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  						if (mod1Code.Length == 2) {  							ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  							if (mod != null) {  								ls.ModifierOneID = mod.ID;  								ls.ID = ls.ID + "_" + mod.ID;  							}  						}  					}  					if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  						if (mod2Code.Length == 2) {  							ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  							if (mod != null) {  								ls.ModifierTwoID = mod.ID;  								ls.ID = ls.ID + "_" + mod.ID;  							}  						}  					}  					ls.ID = ls.ID + "_SYM";  					ls.Label = fullLegacyCode;  					// Add the legacy function code  					LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  					lfCode.Name = "2525C";  					if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  						lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  					if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  						lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  					lfCode.Value = functionCode;  					if (status != "")  						lfCode.Description = status;  					if (remarks != "")  						lfCode.Remarks = remarks;  					ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  						lfCode  					};  					// Add it to the current legacy symbol set  					legacySymbols.Add (ls);  				}  			}  		}  		r.Close ();  	}  	// Done processing the input.  If there is anything in our list then add it to the  	// symbol set and re-serialize it.  Remove the existing values if they exist.  	if (legacySymbols.Count > 0) {  		ss.LegacySymbols = legacySymbols.ToArray ();  		// Serialize the symbol set  		_serializeSymbolSet (ss' destination);  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (File.Exists (source)) {  	// Lets build a list of legacy symbols to hold the results  	List<SymbolSetLegacySymbol> legacySymbols = new List<SymbolSetLegacySymbol> ();  	// Now process the input  	string line = "";  	using (StreamReader r = new StreamReader (source)) {  		while (!r.EndOfStream) {  			line = r.ReadLine ();  			string[] tokens = line.Split (''');  			string ssCode = tokens [2];  			string legacyCode = tokens [0];  			string fullLegacyCode = tokens [1];  			string mod1Code = tokens [4];  			string mod2Code = tokens [5];  			string status = tokens [6];  			string remarks = tokens [7];  			// Skip over all rows in the source file that don't match the symbol set code  			// or where the 2525C SIDC field is blank.  			if (ssCode == code && legacyCode != "") {  				// Extract the six character function code from the current 2525C SIDC.  				string functionCode = legacyCode.Substring (legacyCode.Length - 6);  				//string schemaCode = legacyCode.Substring(0' 1);  				//string dimensionCode = legacyCode.Substring(2' 1);  				string entityCode = tokens [3];  				if (entityCode.Length == 6) {  					string eCode = entityCode.Substring (0' 2);  					string etCode = entityCode.Substring (2' 2);  					string estCode = entityCode.Substring (4' 2);  					// Now that we have everything' let's find the pieces in the open symbol set  					SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  					// Find the entity' entity type' and entity subtype for the specified SIDC.  					SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  					if (entity != null) {  						ls.EntityID = entity.ID;  						ls.ID = entity.ID;  						if (etCode != "00") {  							SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  							if (eType != null) {  								ls.EntityTypeID = eType.ID;  								ls.ID = ls.ID + "_" + eType.ID;  								if (estCode != "00") {  									EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  									if (eSubType != null) {  										ls.EntitySubTypeID = eSubType.ID;  										ls.ID = ls.ID + "_" + eSubType.ID;  									}  								}  							}  						}  					}  					// No entities were found' so mark it as retired.  					if (ls.ID == null) {  						ls.ID = "RETIRED";  						ls.Remarks = "Retired";  					}  					// Find the modifier 1 and modifier 2 for the specified SIDC.  					if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  						if (mod1Code.Length == 2) {  							ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  							if (mod != null) {  								ls.ModifierOneID = mod.ID;  								ls.ID = ls.ID + "_" + mod.ID;  							}  						}  					}  					if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  						if (mod2Code.Length == 2) {  							ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  							if (mod != null) {  								ls.ModifierTwoID = mod.ID;  								ls.ID = ls.ID + "_" + mod.ID;  							}  						}  					}  					ls.ID = ls.ID + "_SYM";  					ls.Label = fullLegacyCode;  					// Add the legacy function code  					LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  					lfCode.Name = "2525C";  					if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  						lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  					if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  						lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  					lfCode.Value = functionCode;  					if (status != "")  						lfCode.Description = status;  					if (remarks != "")  						lfCode.Remarks = remarks;  					ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  						lfCode  					};  					// Add it to the current legacy symbol set  					legacySymbols.Add (ls);  				}  			}  		}  		r.Close ();  	}  	// Done processing the input.  If there is anything in our list then add it to the  	// symbol set and re-serialize it.  Remove the existing values if they exist.  	if (legacySymbols.Count > 0) {  		ss.LegacySymbols = legacySymbols.ToArray ();  		// Serialize the symbol set  		_serializeSymbolSet (ss' destination);  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (File.Exists (source)) {  	// Lets build a list of legacy symbols to hold the results  	List<SymbolSetLegacySymbol> legacySymbols = new List<SymbolSetLegacySymbol> ();  	// Now process the input  	string line = "";  	using (StreamReader r = new StreamReader (source)) {  		while (!r.EndOfStream) {  			line = r.ReadLine ();  			string[] tokens = line.Split (''');  			string ssCode = tokens [2];  			string legacyCode = tokens [0];  			string fullLegacyCode = tokens [1];  			string mod1Code = tokens [4];  			string mod2Code = tokens [5];  			string status = tokens [6];  			string remarks = tokens [7];  			// Skip over all rows in the source file that don't match the symbol set code  			// or where the 2525C SIDC field is blank.  			if (ssCode == code && legacyCode != "") {  				// Extract the six character function code from the current 2525C SIDC.  				string functionCode = legacyCode.Substring (legacyCode.Length - 6);  				//string schemaCode = legacyCode.Substring(0' 1);  				//string dimensionCode = legacyCode.Substring(2' 1);  				string entityCode = tokens [3];  				if (entityCode.Length == 6) {  					string eCode = entityCode.Substring (0' 2);  					string etCode = entityCode.Substring (2' 2);  					string estCode = entityCode.Substring (4' 2);  					// Now that we have everything' let's find the pieces in the open symbol set  					SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  					// Find the entity' entity type' and entity subtype for the specified SIDC.  					SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  					if (entity != null) {  						ls.EntityID = entity.ID;  						ls.ID = entity.ID;  						if (etCode != "00") {  							SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  							if (eType != null) {  								ls.EntityTypeID = eType.ID;  								ls.ID = ls.ID + "_" + eType.ID;  								if (estCode != "00") {  									EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  									if (eSubType != null) {  										ls.EntitySubTypeID = eSubType.ID;  										ls.ID = ls.ID + "_" + eSubType.ID;  									}  								}  							}  						}  					}  					// No entities were found' so mark it as retired.  					if (ls.ID == null) {  						ls.ID = "RETIRED";  						ls.Remarks = "Retired";  					}  					// Find the modifier 1 and modifier 2 for the specified SIDC.  					if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  						if (mod1Code.Length == 2) {  							ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  							if (mod != null) {  								ls.ModifierOneID = mod.ID;  								ls.ID = ls.ID + "_" + mod.ID;  							}  						}  					}  					if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  						if (mod2Code.Length == 2) {  							ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  							if (mod != null) {  								ls.ModifierTwoID = mod.ID;  								ls.ID = ls.ID + "_" + mod.ID;  							}  						}  					}  					ls.ID = ls.ID + "_SYM";  					ls.Label = fullLegacyCode;  					// Add the legacy function code  					LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  					lfCode.Name = "2525C";  					if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  						lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  					if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  						lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  					lfCode.Value = functionCode;  					if (status != "")  						lfCode.Description = status;  					if (remarks != "")  						lfCode.Remarks = remarks;  					ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  						lfCode  					};  					// Add it to the current legacy symbol set  					legacySymbols.Add (ls);  				}  			}  		}  		r.Close ();  	}  	// Done processing the input.  If there is anything in our list then add it to the  	// symbol set and re-serialize it.  Remove the existing values if they exist.  	if (legacySymbols.Count > 0) {  		ss.LegacySymbols = legacySymbols.ToArray ();  		// Serialize the symbol set  		_serializeSymbolSet (ss' destination);  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (File.Exists (source)) {  	// Lets build a list of legacy symbols to hold the results  	List<SymbolSetLegacySymbol> legacySymbols = new List<SymbolSetLegacySymbol> ();  	// Now process the input  	string line = "";  	using (StreamReader r = new StreamReader (source)) {  		while (!r.EndOfStream) {  			line = r.ReadLine ();  			string[] tokens = line.Split (''');  			string ssCode = tokens [2];  			string legacyCode = tokens [0];  			string fullLegacyCode = tokens [1];  			string mod1Code = tokens [4];  			string mod2Code = tokens [5];  			string status = tokens [6];  			string remarks = tokens [7];  			// Skip over all rows in the source file that don't match the symbol set code  			// or where the 2525C SIDC field is blank.  			if (ssCode == code && legacyCode != "") {  				// Extract the six character function code from the current 2525C SIDC.  				string functionCode = legacyCode.Substring (legacyCode.Length - 6);  				//string schemaCode = legacyCode.Substring(0' 1);  				//string dimensionCode = legacyCode.Substring(2' 1);  				string entityCode = tokens [3];  				if (entityCode.Length == 6) {  					string eCode = entityCode.Substring (0' 2);  					string etCode = entityCode.Substring (2' 2);  					string estCode = entityCode.Substring (4' 2);  					// Now that we have everything' let's find the pieces in the open symbol set  					SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  					// Find the entity' entity type' and entity subtype for the specified SIDC.  					SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  					if (entity != null) {  						ls.EntityID = entity.ID;  						ls.ID = entity.ID;  						if (etCode != "00") {  							SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  							if (eType != null) {  								ls.EntityTypeID = eType.ID;  								ls.ID = ls.ID + "_" + eType.ID;  								if (estCode != "00") {  									EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  									if (eSubType != null) {  										ls.EntitySubTypeID = eSubType.ID;  										ls.ID = ls.ID + "_" + eSubType.ID;  									}  								}  							}  						}  					}  					// No entities were found' so mark it as retired.  					if (ls.ID == null) {  						ls.ID = "RETIRED";  						ls.Remarks = "Retired";  					}  					// Find the modifier 1 and modifier 2 for the specified SIDC.  					if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  						if (mod1Code.Length == 2) {  							ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  							if (mod != null) {  								ls.ModifierOneID = mod.ID;  								ls.ID = ls.ID + "_" + mod.ID;  							}  						}  					}  					if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  						if (mod2Code.Length == 2) {  							ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  							if (mod != null) {  								ls.ModifierTwoID = mod.ID;  								ls.ID = ls.ID + "_" + mod.ID;  							}  						}  					}  					ls.ID = ls.ID + "_SYM";  					ls.Label = fullLegacyCode;  					// Add the legacy function code  					LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  					lfCode.Name = "2525C";  					if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  						lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  					if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  						lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  					lfCode.Value = functionCode;  					if (status != "")  						lfCode.Description = status;  					if (remarks != "")  						lfCode.Remarks = remarks;  					ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  						lfCode  					};  					// Add it to the current legacy symbol set  					legacySymbols.Add (ls);  				}  			}  		}  		r.Close ();  	}  	// Done processing the input.  If there is anything in our list then add it to the  	// symbol set and re-serialize it.  Remove the existing values if they exist.  	if (legacySymbols.Count > 0) {  		ss.LegacySymbols = legacySymbols.ToArray ();  		// Serialize the symbol set  		_serializeSymbolSet (ss' destination);  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (File.Exists (source)) {  	// Lets build a list of legacy symbols to hold the results  	List<SymbolSetLegacySymbol> legacySymbols = new List<SymbolSetLegacySymbol> ();  	// Now process the input  	string line = "";  	using (StreamReader r = new StreamReader (source)) {  		while (!r.EndOfStream) {  			line = r.ReadLine ();  			string[] tokens = line.Split (''');  			string ssCode = tokens [2];  			string legacyCode = tokens [0];  			string fullLegacyCode = tokens [1];  			string mod1Code = tokens [4];  			string mod2Code = tokens [5];  			string status = tokens [6];  			string remarks = tokens [7];  			// Skip over all rows in the source file that don't match the symbol set code  			// or where the 2525C SIDC field is blank.  			if (ssCode == code && legacyCode != "") {  				// Extract the six character function code from the current 2525C SIDC.  				string functionCode = legacyCode.Substring (legacyCode.Length - 6);  				//string schemaCode = legacyCode.Substring(0' 1);  				//string dimensionCode = legacyCode.Substring(2' 1);  				string entityCode = tokens [3];  				if (entityCode.Length == 6) {  					string eCode = entityCode.Substring (0' 2);  					string etCode = entityCode.Substring (2' 2);  					string estCode = entityCode.Substring (4' 2);  					// Now that we have everything' let's find the pieces in the open symbol set  					SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  					// Find the entity' entity type' and entity subtype for the specified SIDC.  					SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  					if (entity != null) {  						ls.EntityID = entity.ID;  						ls.ID = entity.ID;  						if (etCode != "00") {  							SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  							if (eType != null) {  								ls.EntityTypeID = eType.ID;  								ls.ID = ls.ID + "_" + eType.ID;  								if (estCode != "00") {  									EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  									if (eSubType != null) {  										ls.EntitySubTypeID = eSubType.ID;  										ls.ID = ls.ID + "_" + eSubType.ID;  									}  								}  							}  						}  					}  					// No entities were found' so mark it as retired.  					if (ls.ID == null) {  						ls.ID = "RETIRED";  						ls.Remarks = "Retired";  					}  					// Find the modifier 1 and modifier 2 for the specified SIDC.  					if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  						if (mod1Code.Length == 2) {  							ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  							if (mod != null) {  								ls.ModifierOneID = mod.ID;  								ls.ID = ls.ID + "_" + mod.ID;  							}  						}  					}  					if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  						if (mod2Code.Length == 2) {  							ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  							if (mod != null) {  								ls.ModifierTwoID = mod.ID;  								ls.ID = ls.ID + "_" + mod.ID;  							}  						}  					}  					ls.ID = ls.ID + "_SYM";  					ls.Label = fullLegacyCode;  					// Add the legacy function code  					LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  					lfCode.Name = "2525C";  					if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  						lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  					if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  						lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  					lfCode.Value = functionCode;  					if (status != "")  						lfCode.Description = status;  					if (remarks != "")  						lfCode.Remarks = remarks;  					ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  						lfCode  					};  					// Add it to the current legacy symbol set  					legacySymbols.Add (ls);  				}  			}  		}  		r.Close ();  	}  	// Done processing the input.  If there is anything in our list then add it to the  	// symbol set and re-serialize it.  Remove the existing values if they exist.  	if (legacySymbols.Count > 0) {  		ss.LegacySymbols = legacySymbols.ToArray ();  		// Serialize the symbol set  		_serializeSymbolSet (ss' destination);  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (File.Exists (source)) {  	// Lets build a list of legacy symbols to hold the results  	List<SymbolSetLegacySymbol> legacySymbols = new List<SymbolSetLegacySymbol> ();  	// Now process the input  	string line = "";  	using (StreamReader r = new StreamReader (source)) {  		while (!r.EndOfStream) {  			line = r.ReadLine ();  			string[] tokens = line.Split (''');  			string ssCode = tokens [2];  			string legacyCode = tokens [0];  			string fullLegacyCode = tokens [1];  			string mod1Code = tokens [4];  			string mod2Code = tokens [5];  			string status = tokens [6];  			string remarks = tokens [7];  			// Skip over all rows in the source file that don't match the symbol set code  			// or where the 2525C SIDC field is blank.  			if (ssCode == code && legacyCode != "") {  				// Extract the six character function code from the current 2525C SIDC.  				string functionCode = legacyCode.Substring (legacyCode.Length - 6);  				//string schemaCode = legacyCode.Substring(0' 1);  				//string dimensionCode = legacyCode.Substring(2' 1);  				string entityCode = tokens [3];  				if (entityCode.Length == 6) {  					string eCode = entityCode.Substring (0' 2);  					string etCode = entityCode.Substring (2' 2);  					string estCode = entityCode.Substring (4' 2);  					// Now that we have everything' let's find the pieces in the open symbol set  					SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  					// Find the entity' entity type' and entity subtype for the specified SIDC.  					SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  					if (entity != null) {  						ls.EntityID = entity.ID;  						ls.ID = entity.ID;  						if (etCode != "00") {  							SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  							if (eType != null) {  								ls.EntityTypeID = eType.ID;  								ls.ID = ls.ID + "_" + eType.ID;  								if (estCode != "00") {  									EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  									if (eSubType != null) {  										ls.EntitySubTypeID = eSubType.ID;  										ls.ID = ls.ID + "_" + eSubType.ID;  									}  								}  							}  						}  					}  					// No entities were found' so mark it as retired.  					if (ls.ID == null) {  						ls.ID = "RETIRED";  						ls.Remarks = "Retired";  					}  					// Find the modifier 1 and modifier 2 for the specified SIDC.  					if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  						if (mod1Code.Length == 2) {  							ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  							if (mod != null) {  								ls.ModifierOneID = mod.ID;  								ls.ID = ls.ID + "_" + mod.ID;  							}  						}  					}  					if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  						if (mod2Code.Length == 2) {  							ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  							if (mod != null) {  								ls.ModifierTwoID = mod.ID;  								ls.ID = ls.ID + "_" + mod.ID;  							}  						}  					}  					ls.ID = ls.ID + "_SYM";  					ls.Label = fullLegacyCode;  					// Add the legacy function code  					LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  					lfCode.Name = "2525C";  					if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  						lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  					if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  						lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  					lfCode.Value = functionCode;  					if (status != "")  						lfCode.Description = status;  					if (remarks != "")  						lfCode.Remarks = remarks;  					ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  						lfCode  					};  					// Add it to the current legacy symbol set  					legacySymbols.Add (ls);  				}  			}  		}  		r.Close ();  	}  	// Done processing the input.  If there is anything in our list then add it to the  	// symbol set and re-serialize it.  Remove the existing values if they exist.  	if (legacySymbols.Count > 0) {  		ss.LegacySymbols = legacySymbols.ToArray ();  		// Serialize the symbol set  		_serializeSymbolSet (ss' destination);  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (File.Exists (source)) {  	// Lets build a list of legacy symbols to hold the results  	List<SymbolSetLegacySymbol> legacySymbols = new List<SymbolSetLegacySymbol> ();  	// Now process the input  	string line = "";  	using (StreamReader r = new StreamReader (source)) {  		while (!r.EndOfStream) {  			line = r.ReadLine ();  			string[] tokens = line.Split (''');  			string ssCode = tokens [2];  			string legacyCode = tokens [0];  			string fullLegacyCode = tokens [1];  			string mod1Code = tokens [4];  			string mod2Code = tokens [5];  			string status = tokens [6];  			string remarks = tokens [7];  			// Skip over all rows in the source file that don't match the symbol set code  			// or where the 2525C SIDC field is blank.  			if (ssCode == code && legacyCode != "") {  				// Extract the six character function code from the current 2525C SIDC.  				string functionCode = legacyCode.Substring (legacyCode.Length - 6);  				//string schemaCode = legacyCode.Substring(0' 1);  				//string dimensionCode = legacyCode.Substring(2' 1);  				string entityCode = tokens [3];  				if (entityCode.Length == 6) {  					string eCode = entityCode.Substring (0' 2);  					string etCode = entityCode.Substring (2' 2);  					string estCode = entityCode.Substring (4' 2);  					// Now that we have everything' let's find the pieces in the open symbol set  					SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  					// Find the entity' entity type' and entity subtype for the specified SIDC.  					SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  					if (entity != null) {  						ls.EntityID = entity.ID;  						ls.ID = entity.ID;  						if (etCode != "00") {  							SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  							if (eType != null) {  								ls.EntityTypeID = eType.ID;  								ls.ID = ls.ID + "_" + eType.ID;  								if (estCode != "00") {  									EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  									if (eSubType != null) {  										ls.EntitySubTypeID = eSubType.ID;  										ls.ID = ls.ID + "_" + eSubType.ID;  									}  								}  							}  						}  					}  					// No entities were found' so mark it as retired.  					if (ls.ID == null) {  						ls.ID = "RETIRED";  						ls.Remarks = "Retired";  					}  					// Find the modifier 1 and modifier 2 for the specified SIDC.  					if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  						if (mod1Code.Length == 2) {  							ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  							if (mod != null) {  								ls.ModifierOneID = mod.ID;  								ls.ID = ls.ID + "_" + mod.ID;  							}  						}  					}  					if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  						if (mod2Code.Length == 2) {  							ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  							if (mod != null) {  								ls.ModifierTwoID = mod.ID;  								ls.ID = ls.ID + "_" + mod.ID;  							}  						}  					}  					ls.ID = ls.ID + "_SYM";  					ls.Label = fullLegacyCode;  					// Add the legacy function code  					LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  					lfCode.Name = "2525C";  					if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  						lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  					if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  						lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  					lfCode.Value = functionCode;  					if (status != "")  						lfCode.Description = status;  					if (remarks != "")  						lfCode.Remarks = remarks;  					ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  						lfCode  					};  					// Add it to the current legacy symbol set  					legacySymbols.Add (ls);  				}  			}  		}  		r.Close ();  	}  	// Done processing the input.  If there is anything in our list then add it to the  	// symbol set and re-serialize it.  Remove the existing values if they exist.  	if (legacySymbols.Count > 0) {  		ss.LegacySymbols = legacySymbols.ToArray ();  		// Serialize the symbol set  		_serializeSymbolSet (ss' destination);  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (File.Exists (source)) {  	// Lets build a list of legacy symbols to hold the results  	List<SymbolSetLegacySymbol> legacySymbols = new List<SymbolSetLegacySymbol> ();  	// Now process the input  	string line = "";  	using (StreamReader r = new StreamReader (source)) {  		while (!r.EndOfStream) {  			line = r.ReadLine ();  			string[] tokens = line.Split (''');  			string ssCode = tokens [2];  			string legacyCode = tokens [0];  			string fullLegacyCode = tokens [1];  			string mod1Code = tokens [4];  			string mod2Code = tokens [5];  			string status = tokens [6];  			string remarks = tokens [7];  			// Skip over all rows in the source file that don't match the symbol set code  			// or where the 2525C SIDC field is blank.  			if (ssCode == code && legacyCode != "") {  				// Extract the six character function code from the current 2525C SIDC.  				string functionCode = legacyCode.Substring (legacyCode.Length - 6);  				//string schemaCode = legacyCode.Substring(0' 1);  				//string dimensionCode = legacyCode.Substring(2' 1);  				string entityCode = tokens [3];  				if (entityCode.Length == 6) {  					string eCode = entityCode.Substring (0' 2);  					string etCode = entityCode.Substring (2' 2);  					string estCode = entityCode.Substring (4' 2);  					// Now that we have everything' let's find the pieces in the open symbol set  					SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  					// Find the entity' entity type' and entity subtype for the specified SIDC.  					SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  					if (entity != null) {  						ls.EntityID = entity.ID;  						ls.ID = entity.ID;  						if (etCode != "00") {  							SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  							if (eType != null) {  								ls.EntityTypeID = eType.ID;  								ls.ID = ls.ID + "_" + eType.ID;  								if (estCode != "00") {  									EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  									if (eSubType != null) {  										ls.EntitySubTypeID = eSubType.ID;  										ls.ID = ls.ID + "_" + eSubType.ID;  									}  								}  							}  						}  					}  					// No entities were found' so mark it as retired.  					if (ls.ID == null) {  						ls.ID = "RETIRED";  						ls.Remarks = "Retired";  					}  					// Find the modifier 1 and modifier 2 for the specified SIDC.  					if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  						if (mod1Code.Length == 2) {  							ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  							if (mod != null) {  								ls.ModifierOneID = mod.ID;  								ls.ID = ls.ID + "_" + mod.ID;  							}  						}  					}  					if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  						if (mod2Code.Length == 2) {  							ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  							if (mod != null) {  								ls.ModifierTwoID = mod.ID;  								ls.ID = ls.ID + "_" + mod.ID;  							}  						}  					}  					ls.ID = ls.ID + "_SYM";  					ls.Label = fullLegacyCode;  					// Add the legacy function code  					LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  					lfCode.Name = "2525C";  					if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  						lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  					if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  						lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  					lfCode.Value = functionCode;  					if (status != "")  						lfCode.Description = status;  					if (remarks != "")  						lfCode.Remarks = remarks;  					ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  						lfCode  					};  					// Add it to the current legacy symbol set  					legacySymbols.Add (ls);  				}  			}  		}  		r.Close ();  	}  	// Done processing the input.  If there is anything in our list then add it to the  	// symbol set and re-serialize it.  Remove the existing values if they exist.  	if (legacySymbols.Count > 0) {  		ss.LegacySymbols = legacySymbols.ToArray ();  		// Serialize the symbol set  		_serializeSymbolSet (ss' destination);  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (File.Exists (source)) {  	// Lets build a list of legacy symbols to hold the results  	List<SymbolSetLegacySymbol> legacySymbols = new List<SymbolSetLegacySymbol> ();  	// Now process the input  	string line = "";  	using (StreamReader r = new StreamReader (source)) {  		while (!r.EndOfStream) {  			line = r.ReadLine ();  			string[] tokens = line.Split (''');  			string ssCode = tokens [2];  			string legacyCode = tokens [0];  			string fullLegacyCode = tokens [1];  			string mod1Code = tokens [4];  			string mod2Code = tokens [5];  			string status = tokens [6];  			string remarks = tokens [7];  			// Skip over all rows in the source file that don't match the symbol set code  			// or where the 2525C SIDC field is blank.  			if (ssCode == code && legacyCode != "") {  				// Extract the six character function code from the current 2525C SIDC.  				string functionCode = legacyCode.Substring (legacyCode.Length - 6);  				//string schemaCode = legacyCode.Substring(0' 1);  				//string dimensionCode = legacyCode.Substring(2' 1);  				string entityCode = tokens [3];  				if (entityCode.Length == 6) {  					string eCode = entityCode.Substring (0' 2);  					string etCode = entityCode.Substring (2' 2);  					string estCode = entityCode.Substring (4' 2);  					// Now that we have everything' let's find the pieces in the open symbol set  					SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  					// Find the entity' entity type' and entity subtype for the specified SIDC.  					SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  					if (entity != null) {  						ls.EntityID = entity.ID;  						ls.ID = entity.ID;  						if (etCode != "00") {  							SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  							if (eType != null) {  								ls.EntityTypeID = eType.ID;  								ls.ID = ls.ID + "_" + eType.ID;  								if (estCode != "00") {  									EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  									if (eSubType != null) {  										ls.EntitySubTypeID = eSubType.ID;  										ls.ID = ls.ID + "_" + eSubType.ID;  									}  								}  							}  						}  					}  					// No entities were found' so mark it as retired.  					if (ls.ID == null) {  						ls.ID = "RETIRED";  						ls.Remarks = "Retired";  					}  					// Find the modifier 1 and modifier 2 for the specified SIDC.  					if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  						if (mod1Code.Length == 2) {  							ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  							if (mod != null) {  								ls.ModifierOneID = mod.ID;  								ls.ID = ls.ID + "_" + mod.ID;  							}  						}  					}  					if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  						if (mod2Code.Length == 2) {  							ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  							if (mod != null) {  								ls.ModifierTwoID = mod.ID;  								ls.ID = ls.ID + "_" + mod.ID;  							}  						}  					}  					ls.ID = ls.ID + "_SYM";  					ls.Label = fullLegacyCode;  					// Add the legacy function code  					LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  					lfCode.Name = "2525C";  					if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  						lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  					if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  						lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  					lfCode.Value = functionCode;  					if (status != "")  						lfCode.Description = status;  					if (remarks != "")  						lfCode.Remarks = remarks;  					ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  						lfCode  					};  					// Add it to the current legacy symbol set  					legacySymbols.Add (ls);  				}  			}  		}  		r.Close ();  	}  	// Done processing the input.  If there is anything in our list then add it to the  	// symbol set and re-serialize it.  Remove the existing values if they exist.  	if (legacySymbols.Count > 0) {  		ss.LegacySymbols = legacySymbols.ToArray ();  		// Serialize the symbol set  		_serializeSymbolSet (ss' destination);  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (File.Exists (source)) {  	// Lets build a list of legacy symbols to hold the results  	List<SymbolSetLegacySymbol> legacySymbols = new List<SymbolSetLegacySymbol> ();  	// Now process the input  	string line = "";  	using (StreamReader r = new StreamReader (source)) {  		while (!r.EndOfStream) {  			line = r.ReadLine ();  			string[] tokens = line.Split (''');  			string ssCode = tokens [2];  			string legacyCode = tokens [0];  			string fullLegacyCode = tokens [1];  			string mod1Code = tokens [4];  			string mod2Code = tokens [5];  			string status = tokens [6];  			string remarks = tokens [7];  			// Skip over all rows in the source file that don't match the symbol set code  			// or where the 2525C SIDC field is blank.  			if (ssCode == code && legacyCode != "") {  				// Extract the six character function code from the current 2525C SIDC.  				string functionCode = legacyCode.Substring (legacyCode.Length - 6);  				//string schemaCode = legacyCode.Substring(0' 1);  				//string dimensionCode = legacyCode.Substring(2' 1);  				string entityCode = tokens [3];  				if (entityCode.Length == 6) {  					string eCode = entityCode.Substring (0' 2);  					string etCode = entityCode.Substring (2' 2);  					string estCode = entityCode.Substring (4' 2);  					// Now that we have everything' let's find the pieces in the open symbol set  					SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  					// Find the entity' entity type' and entity subtype for the specified SIDC.  					SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  					if (entity != null) {  						ls.EntityID = entity.ID;  						ls.ID = entity.ID;  						if (etCode != "00") {  							SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  							if (eType != null) {  								ls.EntityTypeID = eType.ID;  								ls.ID = ls.ID + "_" + eType.ID;  								if (estCode != "00") {  									EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  									if (eSubType != null) {  										ls.EntitySubTypeID = eSubType.ID;  										ls.ID = ls.ID + "_" + eSubType.ID;  									}  								}  							}  						}  					}  					// No entities were found' so mark it as retired.  					if (ls.ID == null) {  						ls.ID = "RETIRED";  						ls.Remarks = "Retired";  					}  					// Find the modifier 1 and modifier 2 for the specified SIDC.  					if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  						if (mod1Code.Length == 2) {  							ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  							if (mod != null) {  								ls.ModifierOneID = mod.ID;  								ls.ID = ls.ID + "_" + mod.ID;  							}  						}  					}  					if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  						if (mod2Code.Length == 2) {  							ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  							if (mod != null) {  								ls.ModifierTwoID = mod.ID;  								ls.ID = ls.ID + "_" + mod.ID;  							}  						}  					}  					ls.ID = ls.ID + "_SYM";  					ls.Label = fullLegacyCode;  					// Add the legacy function code  					LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  					lfCode.Name = "2525C";  					if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  						lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  					if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  						lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  					lfCode.Value = functionCode;  					if (status != "")  						lfCode.Description = status;  					if (remarks != "")  						lfCode.Remarks = remarks;  					ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  						lfCode  					};  					// Add it to the current legacy symbol set  					legacySymbols.Add (ls);  				}  			}  		}  		r.Close ();  	}  	// Done processing the input.  If there is anything in our list then add it to the  	// symbol set and re-serialize it.  Remove the existing values if they exist.  	if (legacySymbols.Count > 0) {  		ss.LegacySymbols = legacySymbols.ToArray ();  		// Serialize the symbol set  		_serializeSymbolSet (ss' destination);  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (File.Exists (source)) {  	// Lets build a list of legacy symbols to hold the results  	List<SymbolSetLegacySymbol> legacySymbols = new List<SymbolSetLegacySymbol> ();  	// Now process the input  	string line = "";  	using (StreamReader r = new StreamReader (source)) {  		while (!r.EndOfStream) {  			line = r.ReadLine ();  			string[] tokens = line.Split (''');  			string ssCode = tokens [2];  			string legacyCode = tokens [0];  			string fullLegacyCode = tokens [1];  			string mod1Code = tokens [4];  			string mod2Code = tokens [5];  			string status = tokens [6];  			string remarks = tokens [7];  			// Skip over all rows in the source file that don't match the symbol set code  			// or where the 2525C SIDC field is blank.  			if (ssCode == code && legacyCode != "") {  				// Extract the six character function code from the current 2525C SIDC.  				string functionCode = legacyCode.Substring (legacyCode.Length - 6);  				//string schemaCode = legacyCode.Substring(0' 1);  				//string dimensionCode = legacyCode.Substring(2' 1);  				string entityCode = tokens [3];  				if (entityCode.Length == 6) {  					string eCode = entityCode.Substring (0' 2);  					string etCode = entityCode.Substring (2' 2);  					string estCode = entityCode.Substring (4' 2);  					// Now that we have everything' let's find the pieces in the open symbol set  					SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  					// Find the entity' entity type' and entity subtype for the specified SIDC.  					SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  					if (entity != null) {  						ls.EntityID = entity.ID;  						ls.ID = entity.ID;  						if (etCode != "00") {  							SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  							if (eType != null) {  								ls.EntityTypeID = eType.ID;  								ls.ID = ls.ID + "_" + eType.ID;  								if (estCode != "00") {  									EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  									if (eSubType != null) {  										ls.EntitySubTypeID = eSubType.ID;  										ls.ID = ls.ID + "_" + eSubType.ID;  									}  								}  							}  						}  					}  					// No entities were found' so mark it as retired.  					if (ls.ID == null) {  						ls.ID = "RETIRED";  						ls.Remarks = "Retired";  					}  					// Find the modifier 1 and modifier 2 for the specified SIDC.  					if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  						if (mod1Code.Length == 2) {  							ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  							if (mod != null) {  								ls.ModifierOneID = mod.ID;  								ls.ID = ls.ID + "_" + mod.ID;  							}  						}  					}  					if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  						if (mod2Code.Length == 2) {  							ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  							if (mod != null) {  								ls.ModifierTwoID = mod.ID;  								ls.ID = ls.ID + "_" + mod.ID;  							}  						}  					}  					ls.ID = ls.ID + "_SYM";  					ls.Label = fullLegacyCode;  					// Add the legacy function code  					LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  					lfCode.Name = "2525C";  					if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  						lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  					if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  						lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  					lfCode.Value = functionCode;  					if (status != "")  						lfCode.Description = status;  					if (remarks != "")  						lfCode.Remarks = remarks;  					ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  						lfCode  					};  					// Add it to the current legacy symbol set  					legacySymbols.Add (ls);  				}  			}  		}  		r.Close ();  	}  	// Done processing the input.  If there is anything in our list then add it to the  	// symbol set and re-serialize it.  Remove the existing values if they exist.  	if (legacySymbols.Count > 0) {  		ss.LegacySymbols = legacySymbols.ToArray ();  		// Serialize the symbol set  		_serializeSymbolSet (ss' destination);  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (File.Exists (source)) {  	// Lets build a list of legacy symbols to hold the results  	List<SymbolSetLegacySymbol> legacySymbols = new List<SymbolSetLegacySymbol> ();  	// Now process the input  	string line = "";  	using (StreamReader r = new StreamReader (source)) {  		while (!r.EndOfStream) {  			line = r.ReadLine ();  			string[] tokens = line.Split (''');  			string ssCode = tokens [2];  			string legacyCode = tokens [0];  			string fullLegacyCode = tokens [1];  			string mod1Code = tokens [4];  			string mod2Code = tokens [5];  			string status = tokens [6];  			string remarks = tokens [7];  			// Skip over all rows in the source file that don't match the symbol set code  			// or where the 2525C SIDC field is blank.  			if (ssCode == code && legacyCode != "") {  				// Extract the six character function code from the current 2525C SIDC.  				string functionCode = legacyCode.Substring (legacyCode.Length - 6);  				//string schemaCode = legacyCode.Substring(0' 1);  				//string dimensionCode = legacyCode.Substring(2' 1);  				string entityCode = tokens [3];  				if (entityCode.Length == 6) {  					string eCode = entityCode.Substring (0' 2);  					string etCode = entityCode.Substring (2' 2);  					string estCode = entityCode.Substring (4' 2);  					// Now that we have everything' let's find the pieces in the open symbol set  					SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  					// Find the entity' entity type' and entity subtype for the specified SIDC.  					SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  					if (entity != null) {  						ls.EntityID = entity.ID;  						ls.ID = entity.ID;  						if (etCode != "00") {  							SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  							if (eType != null) {  								ls.EntityTypeID = eType.ID;  								ls.ID = ls.ID + "_" + eType.ID;  								if (estCode != "00") {  									EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  									if (eSubType != null) {  										ls.EntitySubTypeID = eSubType.ID;  										ls.ID = ls.ID + "_" + eSubType.ID;  									}  								}  							}  						}  					}  					// No entities were found' so mark it as retired.  					if (ls.ID == null) {  						ls.ID = "RETIRED";  						ls.Remarks = "Retired";  					}  					// Find the modifier 1 and modifier 2 for the specified SIDC.  					if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  						if (mod1Code.Length == 2) {  							ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  							if (mod != null) {  								ls.ModifierOneID = mod.ID;  								ls.ID = ls.ID + "_" + mod.ID;  							}  						}  					}  					if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  						if (mod2Code.Length == 2) {  							ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  							if (mod != null) {  								ls.ModifierTwoID = mod.ID;  								ls.ID = ls.ID + "_" + mod.ID;  							}  						}  					}  					ls.ID = ls.ID + "_SYM";  					ls.Label = fullLegacyCode;  					// Add the legacy function code  					LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  					lfCode.Name = "2525C";  					if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  						lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  					if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  						lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  					lfCode.Value = functionCode;  					if (status != "")  						lfCode.Description = status;  					if (remarks != "")  						lfCode.Remarks = remarks;  					ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  						lfCode  					};  					// Add it to the current legacy symbol set  					legacySymbols.Add (ls);  				}  			}  		}  		r.Close ();  	}  	// Done processing the input.  If there is anything in our list then add it to the  	// symbol set and re-serialize it.  Remove the existing values if they exist.  	if (legacySymbols.Count > 0) {  		ss.LegacySymbols = legacySymbols.ToArray ();  		// Serialize the symbol set  		_serializeSymbolSet (ss' destination);  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (File.Exists (source)) {  	// Lets build a list of legacy symbols to hold the results  	List<SymbolSetLegacySymbol> legacySymbols = new List<SymbolSetLegacySymbol> ();  	// Now process the input  	string line = "";  	using (StreamReader r = new StreamReader (source)) {  		while (!r.EndOfStream) {  			line = r.ReadLine ();  			string[] tokens = line.Split (''');  			string ssCode = tokens [2];  			string legacyCode = tokens [0];  			string fullLegacyCode = tokens [1];  			string mod1Code = tokens [4];  			string mod2Code = tokens [5];  			string status = tokens [6];  			string remarks = tokens [7];  			// Skip over all rows in the source file that don't match the symbol set code  			// or where the 2525C SIDC field is blank.  			if (ssCode == code && legacyCode != "") {  				// Extract the six character function code from the current 2525C SIDC.  				string functionCode = legacyCode.Substring (legacyCode.Length - 6);  				//string schemaCode = legacyCode.Substring(0' 1);  				//string dimensionCode = legacyCode.Substring(2' 1);  				string entityCode = tokens [3];  				if (entityCode.Length == 6) {  					string eCode = entityCode.Substring (0' 2);  					string etCode = entityCode.Substring (2' 2);  					string estCode = entityCode.Substring (4' 2);  					// Now that we have everything' let's find the pieces in the open symbol set  					SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  					// Find the entity' entity type' and entity subtype for the specified SIDC.  					SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  					if (entity != null) {  						ls.EntityID = entity.ID;  						ls.ID = entity.ID;  						if (etCode != "00") {  							SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  							if (eType != null) {  								ls.EntityTypeID = eType.ID;  								ls.ID = ls.ID + "_" + eType.ID;  								if (estCode != "00") {  									EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  									if (eSubType != null) {  										ls.EntitySubTypeID = eSubType.ID;  										ls.ID = ls.ID + "_" + eSubType.ID;  									}  								}  							}  						}  					}  					// No entities were found' so mark it as retired.  					if (ls.ID == null) {  						ls.ID = "RETIRED";  						ls.Remarks = "Retired";  					}  					// Find the modifier 1 and modifier 2 for the specified SIDC.  					if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  						if (mod1Code.Length == 2) {  							ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  							if (mod != null) {  								ls.ModifierOneID = mod.ID;  								ls.ID = ls.ID + "_" + mod.ID;  							}  						}  					}  					if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  						if (mod2Code.Length == 2) {  							ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  							if (mod != null) {  								ls.ModifierTwoID = mod.ID;  								ls.ID = ls.ID + "_" + mod.ID;  							}  						}  					}  					ls.ID = ls.ID + "_SYM";  					ls.Label = fullLegacyCode;  					// Add the legacy function code  					LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  					lfCode.Name = "2525C";  					if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  						lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  					if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  						lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  					lfCode.Value = functionCode;  					if (status != "")  						lfCode.Description = status;  					if (remarks != "")  						lfCode.Remarks = remarks;  					ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  						lfCode  					};  					// Add it to the current legacy symbol set  					legacySymbols.Add (ls);  				}  			}  		}  		r.Close ();  	}  	// Done processing the input.  If there is anything in our list then add it to the  	// symbol set and re-serialize it.  Remove the existing values if they exist.  	if (legacySymbols.Count > 0) {  		ss.LegacySymbols = legacySymbols.ToArray ();  		// Serialize the symbol set  		_serializeSymbolSet (ss' destination);  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: using (StreamReader r = new StreamReader (source)) {  	while (!r.EndOfStream) {  		line = r.ReadLine ();  		string[] tokens = line.Split (''');  		string ssCode = tokens [2];  		string legacyCode = tokens [0];  		string fullLegacyCode = tokens [1];  		string mod1Code = tokens [4];  		string mod2Code = tokens [5];  		string status = tokens [6];  		string remarks = tokens [7];  		// Skip over all rows in the source file that don't match the symbol set code  		// or where the 2525C SIDC field is blank.  		if (ssCode == code && legacyCode != "") {  			// Extract the six character function code from the current 2525C SIDC.  			string functionCode = legacyCode.Substring (legacyCode.Length - 6);  			//string schemaCode = legacyCode.Substring(0' 1);  			//string dimensionCode = legacyCode.Substring(2' 1);  			string entityCode = tokens [3];  			if (entityCode.Length == 6) {  				string eCode = entityCode.Substring (0' 2);  				string etCode = entityCode.Substring (2' 2);  				string estCode = entityCode.Substring (4' 2);  				// Now that we have everything' let's find the pieces in the open symbol set  				SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  				// Find the entity' entity type' and entity subtype for the specified SIDC.  				SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  				if (entity != null) {  					ls.EntityID = entity.ID;  					ls.ID = entity.ID;  					if (etCode != "00") {  						SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  						if (eType != null) {  							ls.EntityTypeID = eType.ID;  							ls.ID = ls.ID + "_" + eType.ID;  							if (estCode != "00") {  								EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  								if (eSubType != null) {  									ls.EntitySubTypeID = eSubType.ID;  									ls.ID = ls.ID + "_" + eSubType.ID;  								}  							}  						}  					}  				}  				// No entities were found' so mark it as retired.  				if (ls.ID == null) {  					ls.ID = "RETIRED";  					ls.Remarks = "Retired";  				}  				// Find the modifier 1 and modifier 2 for the specified SIDC.  				if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  					if (mod1Code.Length == 2) {  						ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  						if (mod != null) {  							ls.ModifierOneID = mod.ID;  							ls.ID = ls.ID + "_" + mod.ID;  						}  					}  				}  				if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  					if (mod2Code.Length == 2) {  						ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  						if (mod != null) {  							ls.ModifierTwoID = mod.ID;  							ls.ID = ls.ID + "_" + mod.ID;  						}  					}  				}  				ls.ID = ls.ID + "_SYM";  				ls.Label = fullLegacyCode;  				// Add the legacy function code  				LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  				lfCode.Name = "2525C";  				if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  					lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  				if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  					lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  				lfCode.Value = functionCode;  				if (status != "")  					lfCode.Description = status;  				if (remarks != "")  					lfCode.Remarks = remarks;  				ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  					lfCode  				};  				// Add it to the current legacy symbol set  				legacySymbols.Add (ls);  			}  		}  	}  	r.Close ();  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: using (StreamReader r = new StreamReader (source)) {  	while (!r.EndOfStream) {  		line = r.ReadLine ();  		string[] tokens = line.Split (''');  		string ssCode = tokens [2];  		string legacyCode = tokens [0];  		string fullLegacyCode = tokens [1];  		string mod1Code = tokens [4];  		string mod2Code = tokens [5];  		string status = tokens [6];  		string remarks = tokens [7];  		// Skip over all rows in the source file that don't match the symbol set code  		// or where the 2525C SIDC field is blank.  		if (ssCode == code && legacyCode != "") {  			// Extract the six character function code from the current 2525C SIDC.  			string functionCode = legacyCode.Substring (legacyCode.Length - 6);  			//string schemaCode = legacyCode.Substring(0' 1);  			//string dimensionCode = legacyCode.Substring(2' 1);  			string entityCode = tokens [3];  			if (entityCode.Length == 6) {  				string eCode = entityCode.Substring (0' 2);  				string etCode = entityCode.Substring (2' 2);  				string estCode = entityCode.Substring (4' 2);  				// Now that we have everything' let's find the pieces in the open symbol set  				SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  				// Find the entity' entity type' and entity subtype for the specified SIDC.  				SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  				if (entity != null) {  					ls.EntityID = entity.ID;  					ls.ID = entity.ID;  					if (etCode != "00") {  						SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  						if (eType != null) {  							ls.EntityTypeID = eType.ID;  							ls.ID = ls.ID + "_" + eType.ID;  							if (estCode != "00") {  								EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  								if (eSubType != null) {  									ls.EntitySubTypeID = eSubType.ID;  									ls.ID = ls.ID + "_" + eSubType.ID;  								}  							}  						}  					}  				}  				// No entities were found' so mark it as retired.  				if (ls.ID == null) {  					ls.ID = "RETIRED";  					ls.Remarks = "Retired";  				}  				// Find the modifier 1 and modifier 2 for the specified SIDC.  				if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  					if (mod1Code.Length == 2) {  						ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  						if (mod != null) {  							ls.ModifierOneID = mod.ID;  							ls.ID = ls.ID + "_" + mod.ID;  						}  					}  				}  				if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  					if (mod2Code.Length == 2) {  						ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  						if (mod != null) {  							ls.ModifierTwoID = mod.ID;  							ls.ID = ls.ID + "_" + mod.ID;  						}  					}  				}  				ls.ID = ls.ID + "_SYM";  				ls.Label = fullLegacyCode;  				// Add the legacy function code  				LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  				lfCode.Name = "2525C";  				if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  					lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  				if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  					lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  				lfCode.Value = functionCode;  				if (status != "")  					lfCode.Description = status;  				if (remarks != "")  					lfCode.Remarks = remarks;  				ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  					lfCode  				};  				// Add it to the current legacy symbol set  				legacySymbols.Add (ls);  			}  		}  	}  	r.Close ();  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: using (StreamReader r = new StreamReader (source)) {  	while (!r.EndOfStream) {  		line = r.ReadLine ();  		string[] tokens = line.Split (''');  		string ssCode = tokens [2];  		string legacyCode = tokens [0];  		string fullLegacyCode = tokens [1];  		string mod1Code = tokens [4];  		string mod2Code = tokens [5];  		string status = tokens [6];  		string remarks = tokens [7];  		// Skip over all rows in the source file that don't match the symbol set code  		// or where the 2525C SIDC field is blank.  		if (ssCode == code && legacyCode != "") {  			// Extract the six character function code from the current 2525C SIDC.  			string functionCode = legacyCode.Substring (legacyCode.Length - 6);  			//string schemaCode = legacyCode.Substring(0' 1);  			//string dimensionCode = legacyCode.Substring(2' 1);  			string entityCode = tokens [3];  			if (entityCode.Length == 6) {  				string eCode = entityCode.Substring (0' 2);  				string etCode = entityCode.Substring (2' 2);  				string estCode = entityCode.Substring (4' 2);  				// Now that we have everything' let's find the pieces in the open symbol set  				SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  				// Find the entity' entity type' and entity subtype for the specified SIDC.  				SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  				if (entity != null) {  					ls.EntityID = entity.ID;  					ls.ID = entity.ID;  					if (etCode != "00") {  						SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  						if (eType != null) {  							ls.EntityTypeID = eType.ID;  							ls.ID = ls.ID + "_" + eType.ID;  							if (estCode != "00") {  								EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  								if (eSubType != null) {  									ls.EntitySubTypeID = eSubType.ID;  									ls.ID = ls.ID + "_" + eSubType.ID;  								}  							}  						}  					}  				}  				// No entities were found' so mark it as retired.  				if (ls.ID == null) {  					ls.ID = "RETIRED";  					ls.Remarks = "Retired";  				}  				// Find the modifier 1 and modifier 2 for the specified SIDC.  				if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  					if (mod1Code.Length == 2) {  						ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  						if (mod != null) {  							ls.ModifierOneID = mod.ID;  							ls.ID = ls.ID + "_" + mod.ID;  						}  					}  				}  				if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  					if (mod2Code.Length == 2) {  						ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  						if (mod != null) {  							ls.ModifierTwoID = mod.ID;  							ls.ID = ls.ID + "_" + mod.ID;  						}  					}  				}  				ls.ID = ls.ID + "_SYM";  				ls.Label = fullLegacyCode;  				// Add the legacy function code  				LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  				lfCode.Name = "2525C";  				if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  					lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  				if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  					lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  				lfCode.Value = functionCode;  				if (status != "")  					lfCode.Description = status;  				if (remarks != "")  					lfCode.Remarks = remarks;  				ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  					lfCode  				};  				// Add it to the current legacy symbol set  				legacySymbols.Add (ls);  			}  		}  	}  	r.Close ();  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: using (StreamReader r = new StreamReader (source)) {  	while (!r.EndOfStream) {  		line = r.ReadLine ();  		string[] tokens = line.Split (''');  		string ssCode = tokens [2];  		string legacyCode = tokens [0];  		string fullLegacyCode = tokens [1];  		string mod1Code = tokens [4];  		string mod2Code = tokens [5];  		string status = tokens [6];  		string remarks = tokens [7];  		// Skip over all rows in the source file that don't match the symbol set code  		// or where the 2525C SIDC field is blank.  		if (ssCode == code && legacyCode != "") {  			// Extract the six character function code from the current 2525C SIDC.  			string functionCode = legacyCode.Substring (legacyCode.Length - 6);  			//string schemaCode = legacyCode.Substring(0' 1);  			//string dimensionCode = legacyCode.Substring(2' 1);  			string entityCode = tokens [3];  			if (entityCode.Length == 6) {  				string eCode = entityCode.Substring (0' 2);  				string etCode = entityCode.Substring (2' 2);  				string estCode = entityCode.Substring (4' 2);  				// Now that we have everything' let's find the pieces in the open symbol set  				SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  				// Find the entity' entity type' and entity subtype for the specified SIDC.  				SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  				if (entity != null) {  					ls.EntityID = entity.ID;  					ls.ID = entity.ID;  					if (etCode != "00") {  						SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  						if (eType != null) {  							ls.EntityTypeID = eType.ID;  							ls.ID = ls.ID + "_" + eType.ID;  							if (estCode != "00") {  								EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  								if (eSubType != null) {  									ls.EntitySubTypeID = eSubType.ID;  									ls.ID = ls.ID + "_" + eSubType.ID;  								}  							}  						}  					}  				}  				// No entities were found' so mark it as retired.  				if (ls.ID == null) {  					ls.ID = "RETIRED";  					ls.Remarks = "Retired";  				}  				// Find the modifier 1 and modifier 2 for the specified SIDC.  				if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  					if (mod1Code.Length == 2) {  						ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  						if (mod != null) {  							ls.ModifierOneID = mod.ID;  							ls.ID = ls.ID + "_" + mod.ID;  						}  					}  				}  				if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  					if (mod2Code.Length == 2) {  						ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  						if (mod != null) {  							ls.ModifierTwoID = mod.ID;  							ls.ID = ls.ID + "_" + mod.ID;  						}  					}  				}  				ls.ID = ls.ID + "_SYM";  				ls.Label = fullLegacyCode;  				// Add the legacy function code  				LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  				lfCode.Name = "2525C";  				if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  					lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  				if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  					lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  				lfCode.Value = functionCode;  				if (status != "")  					lfCode.Description = status;  				if (remarks != "")  					lfCode.Remarks = remarks;  				ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  					lfCode  				};  				// Add it to the current legacy symbol set  				legacySymbols.Add (ls);  			}  		}  	}  	r.Close ();  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: using (StreamReader r = new StreamReader (source)) {  	while (!r.EndOfStream) {  		line = r.ReadLine ();  		string[] tokens = line.Split (''');  		string ssCode = tokens [2];  		string legacyCode = tokens [0];  		string fullLegacyCode = tokens [1];  		string mod1Code = tokens [4];  		string mod2Code = tokens [5];  		string status = tokens [6];  		string remarks = tokens [7];  		// Skip over all rows in the source file that don't match the symbol set code  		// or where the 2525C SIDC field is blank.  		if (ssCode == code && legacyCode != "") {  			// Extract the six character function code from the current 2525C SIDC.  			string functionCode = legacyCode.Substring (legacyCode.Length - 6);  			//string schemaCode = legacyCode.Substring(0' 1);  			//string dimensionCode = legacyCode.Substring(2' 1);  			string entityCode = tokens [3];  			if (entityCode.Length == 6) {  				string eCode = entityCode.Substring (0' 2);  				string etCode = entityCode.Substring (2' 2);  				string estCode = entityCode.Substring (4' 2);  				// Now that we have everything' let's find the pieces in the open symbol set  				SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  				// Find the entity' entity type' and entity subtype for the specified SIDC.  				SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  				if (entity != null) {  					ls.EntityID = entity.ID;  					ls.ID = entity.ID;  					if (etCode != "00") {  						SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  						if (eType != null) {  							ls.EntityTypeID = eType.ID;  							ls.ID = ls.ID + "_" + eType.ID;  							if (estCode != "00") {  								EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  								if (eSubType != null) {  									ls.EntitySubTypeID = eSubType.ID;  									ls.ID = ls.ID + "_" + eSubType.ID;  								}  							}  						}  					}  				}  				// No entities were found' so mark it as retired.  				if (ls.ID == null) {  					ls.ID = "RETIRED";  					ls.Remarks = "Retired";  				}  				// Find the modifier 1 and modifier 2 for the specified SIDC.  				if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  					if (mod1Code.Length == 2) {  						ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  						if (mod != null) {  							ls.ModifierOneID = mod.ID;  							ls.ID = ls.ID + "_" + mod.ID;  						}  					}  				}  				if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  					if (mod2Code.Length == 2) {  						ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  						if (mod != null) {  							ls.ModifierTwoID = mod.ID;  							ls.ID = ls.ID + "_" + mod.ID;  						}  					}  				}  				ls.ID = ls.ID + "_SYM";  				ls.Label = fullLegacyCode;  				// Add the legacy function code  				LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  				lfCode.Name = "2525C";  				if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  					lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  				if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  					lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  				lfCode.Value = functionCode;  				if (status != "")  					lfCode.Description = status;  				if (remarks != "")  					lfCode.Remarks = remarks;  				ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  					lfCode  				};  				// Add it to the current legacy symbol set  				legacySymbols.Add (ls);  			}  		}  	}  	r.Close ();  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: using (StreamReader r = new StreamReader (source)) {  	while (!r.EndOfStream) {  		line = r.ReadLine ();  		string[] tokens = line.Split (''');  		string ssCode = tokens [2];  		string legacyCode = tokens [0];  		string fullLegacyCode = tokens [1];  		string mod1Code = tokens [4];  		string mod2Code = tokens [5];  		string status = tokens [6];  		string remarks = tokens [7];  		// Skip over all rows in the source file that don't match the symbol set code  		// or where the 2525C SIDC field is blank.  		if (ssCode == code && legacyCode != "") {  			// Extract the six character function code from the current 2525C SIDC.  			string functionCode = legacyCode.Substring (legacyCode.Length - 6);  			//string schemaCode = legacyCode.Substring(0' 1);  			//string dimensionCode = legacyCode.Substring(2' 1);  			string entityCode = tokens [3];  			if (entityCode.Length == 6) {  				string eCode = entityCode.Substring (0' 2);  				string etCode = entityCode.Substring (2' 2);  				string estCode = entityCode.Substring (4' 2);  				// Now that we have everything' let's find the pieces in the open symbol set  				SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  				// Find the entity' entity type' and entity subtype for the specified SIDC.  				SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  				if (entity != null) {  					ls.EntityID = entity.ID;  					ls.ID = entity.ID;  					if (etCode != "00") {  						SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  						if (eType != null) {  							ls.EntityTypeID = eType.ID;  							ls.ID = ls.ID + "_" + eType.ID;  							if (estCode != "00") {  								EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  								if (eSubType != null) {  									ls.EntitySubTypeID = eSubType.ID;  									ls.ID = ls.ID + "_" + eSubType.ID;  								}  							}  						}  					}  				}  				// No entities were found' so mark it as retired.  				if (ls.ID == null) {  					ls.ID = "RETIRED";  					ls.Remarks = "Retired";  				}  				// Find the modifier 1 and modifier 2 for the specified SIDC.  				if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  					if (mod1Code.Length == 2) {  						ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  						if (mod != null) {  							ls.ModifierOneID = mod.ID;  							ls.ID = ls.ID + "_" + mod.ID;  						}  					}  				}  				if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  					if (mod2Code.Length == 2) {  						ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  						if (mod != null) {  							ls.ModifierTwoID = mod.ID;  							ls.ID = ls.ID + "_" + mod.ID;  						}  					}  				}  				ls.ID = ls.ID + "_SYM";  				ls.Label = fullLegacyCode;  				// Add the legacy function code  				LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  				lfCode.Name = "2525C";  				if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  					lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  				if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  					lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  				lfCode.Value = functionCode;  				if (status != "")  					lfCode.Description = status;  				if (remarks != "")  					lfCode.Remarks = remarks;  				ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  					lfCode  				};  				// Add it to the current legacy symbol set  				legacySymbols.Add (ls);  			}  		}  	}  	r.Close ();  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: using (StreamReader r = new StreamReader (source)) {  	while (!r.EndOfStream) {  		line = r.ReadLine ();  		string[] tokens = line.Split (''');  		string ssCode = tokens [2];  		string legacyCode = tokens [0];  		string fullLegacyCode = tokens [1];  		string mod1Code = tokens [4];  		string mod2Code = tokens [5];  		string status = tokens [6];  		string remarks = tokens [7];  		// Skip over all rows in the source file that don't match the symbol set code  		// or where the 2525C SIDC field is blank.  		if (ssCode == code && legacyCode != "") {  			// Extract the six character function code from the current 2525C SIDC.  			string functionCode = legacyCode.Substring (legacyCode.Length - 6);  			//string schemaCode = legacyCode.Substring(0' 1);  			//string dimensionCode = legacyCode.Substring(2' 1);  			string entityCode = tokens [3];  			if (entityCode.Length == 6) {  				string eCode = entityCode.Substring (0' 2);  				string etCode = entityCode.Substring (2' 2);  				string estCode = entityCode.Substring (4' 2);  				// Now that we have everything' let's find the pieces in the open symbol set  				SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  				// Find the entity' entity type' and entity subtype for the specified SIDC.  				SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  				if (entity != null) {  					ls.EntityID = entity.ID;  					ls.ID = entity.ID;  					if (etCode != "00") {  						SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  						if (eType != null) {  							ls.EntityTypeID = eType.ID;  							ls.ID = ls.ID + "_" + eType.ID;  							if (estCode != "00") {  								EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  								if (eSubType != null) {  									ls.EntitySubTypeID = eSubType.ID;  									ls.ID = ls.ID + "_" + eSubType.ID;  								}  							}  						}  					}  				}  				// No entities were found' so mark it as retired.  				if (ls.ID == null) {  					ls.ID = "RETIRED";  					ls.Remarks = "Retired";  				}  				// Find the modifier 1 and modifier 2 for the specified SIDC.  				if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  					if (mod1Code.Length == 2) {  						ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  						if (mod != null) {  							ls.ModifierOneID = mod.ID;  							ls.ID = ls.ID + "_" + mod.ID;  						}  					}  				}  				if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  					if (mod2Code.Length == 2) {  						ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  						if (mod != null) {  							ls.ModifierTwoID = mod.ID;  							ls.ID = ls.ID + "_" + mod.ID;  						}  					}  				}  				ls.ID = ls.ID + "_SYM";  				ls.Label = fullLegacyCode;  				// Add the legacy function code  				LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  				lfCode.Name = "2525C";  				if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  					lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  				if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  					lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  				lfCode.Value = functionCode;  				if (status != "")  					lfCode.Description = status;  				if (remarks != "")  					lfCode.Remarks = remarks;  				ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  					lfCode  				};  				// Add it to the current legacy symbol set  				legacySymbols.Add (ls);  			}  		}  	}  	r.Close ();  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: using (StreamReader r = new StreamReader (source)) {  	while (!r.EndOfStream) {  		line = r.ReadLine ();  		string[] tokens = line.Split (''');  		string ssCode = tokens [2];  		string legacyCode = tokens [0];  		string fullLegacyCode = tokens [1];  		string mod1Code = tokens [4];  		string mod2Code = tokens [5];  		string status = tokens [6];  		string remarks = tokens [7];  		// Skip over all rows in the source file that don't match the symbol set code  		// or where the 2525C SIDC field is blank.  		if (ssCode == code && legacyCode != "") {  			// Extract the six character function code from the current 2525C SIDC.  			string functionCode = legacyCode.Substring (legacyCode.Length - 6);  			//string schemaCode = legacyCode.Substring(0' 1);  			//string dimensionCode = legacyCode.Substring(2' 1);  			string entityCode = tokens [3];  			if (entityCode.Length == 6) {  				string eCode = entityCode.Substring (0' 2);  				string etCode = entityCode.Substring (2' 2);  				string estCode = entityCode.Substring (4' 2);  				// Now that we have everything' let's find the pieces in the open symbol set  				SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  				// Find the entity' entity type' and entity subtype for the specified SIDC.  				SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  				if (entity != null) {  					ls.EntityID = entity.ID;  					ls.ID = entity.ID;  					if (etCode != "00") {  						SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  						if (eType != null) {  							ls.EntityTypeID = eType.ID;  							ls.ID = ls.ID + "_" + eType.ID;  							if (estCode != "00") {  								EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  								if (eSubType != null) {  									ls.EntitySubTypeID = eSubType.ID;  									ls.ID = ls.ID + "_" + eSubType.ID;  								}  							}  						}  					}  				}  				// No entities were found' so mark it as retired.  				if (ls.ID == null) {  					ls.ID = "RETIRED";  					ls.Remarks = "Retired";  				}  				// Find the modifier 1 and modifier 2 for the specified SIDC.  				if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  					if (mod1Code.Length == 2) {  						ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  						if (mod != null) {  							ls.ModifierOneID = mod.ID;  							ls.ID = ls.ID + "_" + mod.ID;  						}  					}  				}  				if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  					if (mod2Code.Length == 2) {  						ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  						if (mod != null) {  							ls.ModifierTwoID = mod.ID;  							ls.ID = ls.ID + "_" + mod.ID;  						}  					}  				}  				ls.ID = ls.ID + "_SYM";  				ls.Label = fullLegacyCode;  				// Add the legacy function code  				LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  				lfCode.Name = "2525C";  				if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  					lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  				if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  					lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  				lfCode.Value = functionCode;  				if (status != "")  					lfCode.Description = status;  				if (remarks != "")  					lfCode.Remarks = remarks;  				ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  					lfCode  				};  				// Add it to the current legacy symbol set  				legacySymbols.Add (ls);  			}  		}  	}  	r.Close ();  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: using (StreamReader r = new StreamReader (source)) {  	while (!r.EndOfStream) {  		line = r.ReadLine ();  		string[] tokens = line.Split (''');  		string ssCode = tokens [2];  		string legacyCode = tokens [0];  		string fullLegacyCode = tokens [1];  		string mod1Code = tokens [4];  		string mod2Code = tokens [5];  		string status = tokens [6];  		string remarks = tokens [7];  		// Skip over all rows in the source file that don't match the symbol set code  		// or where the 2525C SIDC field is blank.  		if (ssCode == code && legacyCode != "") {  			// Extract the six character function code from the current 2525C SIDC.  			string functionCode = legacyCode.Substring (legacyCode.Length - 6);  			//string schemaCode = legacyCode.Substring(0' 1);  			//string dimensionCode = legacyCode.Substring(2' 1);  			string entityCode = tokens [3];  			if (entityCode.Length == 6) {  				string eCode = entityCode.Substring (0' 2);  				string etCode = entityCode.Substring (2' 2);  				string estCode = entityCode.Substring (4' 2);  				// Now that we have everything' let's find the pieces in the open symbol set  				SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  				// Find the entity' entity type' and entity subtype for the specified SIDC.  				SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  				if (entity != null) {  					ls.EntityID = entity.ID;  					ls.ID = entity.ID;  					if (etCode != "00") {  						SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  						if (eType != null) {  							ls.EntityTypeID = eType.ID;  							ls.ID = ls.ID + "_" + eType.ID;  							if (estCode != "00") {  								EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  								if (eSubType != null) {  									ls.EntitySubTypeID = eSubType.ID;  									ls.ID = ls.ID + "_" + eSubType.ID;  								}  							}  						}  					}  				}  				// No entities were found' so mark it as retired.  				if (ls.ID == null) {  					ls.ID = "RETIRED";  					ls.Remarks = "Retired";  				}  				// Find the modifier 1 and modifier 2 for the specified SIDC.  				if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  					if (mod1Code.Length == 2) {  						ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  						if (mod != null) {  							ls.ModifierOneID = mod.ID;  							ls.ID = ls.ID + "_" + mod.ID;  						}  					}  				}  				if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  					if (mod2Code.Length == 2) {  						ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  						if (mod != null) {  							ls.ModifierTwoID = mod.ID;  							ls.ID = ls.ID + "_" + mod.ID;  						}  					}  				}  				ls.ID = ls.ID + "_SYM";  				ls.Label = fullLegacyCode;  				// Add the legacy function code  				LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  				lfCode.Name = "2525C";  				if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  					lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  				if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  					lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  				lfCode.Value = functionCode;  				if (status != "")  					lfCode.Description = status;  				if (remarks != "")  					lfCode.Remarks = remarks;  				ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  					lfCode  				};  				// Add it to the current legacy symbol set  				legacySymbols.Add (ls);  			}  		}  	}  	r.Close ();  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: using (StreamReader r = new StreamReader (source)) {  	while (!r.EndOfStream) {  		line = r.ReadLine ();  		string[] tokens = line.Split (''');  		string ssCode = tokens [2];  		string legacyCode = tokens [0];  		string fullLegacyCode = tokens [1];  		string mod1Code = tokens [4];  		string mod2Code = tokens [5];  		string status = tokens [6];  		string remarks = tokens [7];  		// Skip over all rows in the source file that don't match the symbol set code  		// or where the 2525C SIDC field is blank.  		if (ssCode == code && legacyCode != "") {  			// Extract the six character function code from the current 2525C SIDC.  			string functionCode = legacyCode.Substring (legacyCode.Length - 6);  			//string schemaCode = legacyCode.Substring(0' 1);  			//string dimensionCode = legacyCode.Substring(2' 1);  			string entityCode = tokens [3];  			if (entityCode.Length == 6) {  				string eCode = entityCode.Substring (0' 2);  				string etCode = entityCode.Substring (2' 2);  				string estCode = entityCode.Substring (4' 2);  				// Now that we have everything' let's find the pieces in the open symbol set  				SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  				// Find the entity' entity type' and entity subtype for the specified SIDC.  				SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  				if (entity != null) {  					ls.EntityID = entity.ID;  					ls.ID = entity.ID;  					if (etCode != "00") {  						SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  						if (eType != null) {  							ls.EntityTypeID = eType.ID;  							ls.ID = ls.ID + "_" + eType.ID;  							if (estCode != "00") {  								EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  								if (eSubType != null) {  									ls.EntitySubTypeID = eSubType.ID;  									ls.ID = ls.ID + "_" + eSubType.ID;  								}  							}  						}  					}  				}  				// No entities were found' so mark it as retired.  				if (ls.ID == null) {  					ls.ID = "RETIRED";  					ls.Remarks = "Retired";  				}  				// Find the modifier 1 and modifier 2 for the specified SIDC.  				if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  					if (mod1Code.Length == 2) {  						ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  						if (mod != null) {  							ls.ModifierOneID = mod.ID;  							ls.ID = ls.ID + "_" + mod.ID;  						}  					}  				}  				if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  					if (mod2Code.Length == 2) {  						ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  						if (mod != null) {  							ls.ModifierTwoID = mod.ID;  							ls.ID = ls.ID + "_" + mod.ID;  						}  					}  				}  				ls.ID = ls.ID + "_SYM";  				ls.Label = fullLegacyCode;  				// Add the legacy function code  				LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  				lfCode.Name = "2525C";  				if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  					lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  				if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  					lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  				lfCode.Value = functionCode;  				if (status != "")  					lfCode.Description = status;  				if (remarks != "")  					lfCode.Remarks = remarks;  				ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  					lfCode  				};  				// Add it to the current legacy symbol set  				legacySymbols.Add (ls);  			}  		}  	}  	r.Close ();  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: using (StreamReader r = new StreamReader (source)) {  	while (!r.EndOfStream) {  		line = r.ReadLine ();  		string[] tokens = line.Split (''');  		string ssCode = tokens [2];  		string legacyCode = tokens [0];  		string fullLegacyCode = tokens [1];  		string mod1Code = tokens [4];  		string mod2Code = tokens [5];  		string status = tokens [6];  		string remarks = tokens [7];  		// Skip over all rows in the source file that don't match the symbol set code  		// or where the 2525C SIDC field is blank.  		if (ssCode == code && legacyCode != "") {  			// Extract the six character function code from the current 2525C SIDC.  			string functionCode = legacyCode.Substring (legacyCode.Length - 6);  			//string schemaCode = legacyCode.Substring(0' 1);  			//string dimensionCode = legacyCode.Substring(2' 1);  			string entityCode = tokens [3];  			if (entityCode.Length == 6) {  				string eCode = entityCode.Substring (0' 2);  				string etCode = entityCode.Substring (2' 2);  				string estCode = entityCode.Substring (4' 2);  				// Now that we have everything' let's find the pieces in the open symbol set  				SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  				// Find the entity' entity type' and entity subtype for the specified SIDC.  				SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  				if (entity != null) {  					ls.EntityID = entity.ID;  					ls.ID = entity.ID;  					if (etCode != "00") {  						SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  						if (eType != null) {  							ls.EntityTypeID = eType.ID;  							ls.ID = ls.ID + "_" + eType.ID;  							if (estCode != "00") {  								EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  								if (eSubType != null) {  									ls.EntitySubTypeID = eSubType.ID;  									ls.ID = ls.ID + "_" + eSubType.ID;  								}  							}  						}  					}  				}  				// No entities were found' so mark it as retired.  				if (ls.ID == null) {  					ls.ID = "RETIRED";  					ls.Remarks = "Retired";  				}  				// Find the modifier 1 and modifier 2 for the specified SIDC.  				if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  					if (mod1Code.Length == 2) {  						ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  						if (mod != null) {  							ls.ModifierOneID = mod.ID;  							ls.ID = ls.ID + "_" + mod.ID;  						}  					}  				}  				if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  					if (mod2Code.Length == 2) {  						ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  						if (mod != null) {  							ls.ModifierTwoID = mod.ID;  							ls.ID = ls.ID + "_" + mod.ID;  						}  					}  				}  				ls.ID = ls.ID + "_SYM";  				ls.Label = fullLegacyCode;  				// Add the legacy function code  				LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  				lfCode.Name = "2525C";  				if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  					lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  				if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  					lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  				lfCode.Value = functionCode;  				if (status != "")  					lfCode.Description = status;  				if (remarks != "")  					lfCode.Remarks = remarks;  				ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  					lfCode  				};  				// Add it to the current legacy symbol set  				legacySymbols.Add (ls);  			}  		}  	}  	r.Close ();  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: using (StreamReader r = new StreamReader (source)) {  	while (!r.EndOfStream) {  		line = r.ReadLine ();  		string[] tokens = line.Split (''');  		string ssCode = tokens [2];  		string legacyCode = tokens [0];  		string fullLegacyCode = tokens [1];  		string mod1Code = tokens [4];  		string mod2Code = tokens [5];  		string status = tokens [6];  		string remarks = tokens [7];  		// Skip over all rows in the source file that don't match the symbol set code  		// or where the 2525C SIDC field is blank.  		if (ssCode == code && legacyCode != "") {  			// Extract the six character function code from the current 2525C SIDC.  			string functionCode = legacyCode.Substring (legacyCode.Length - 6);  			//string schemaCode = legacyCode.Substring(0' 1);  			//string dimensionCode = legacyCode.Substring(2' 1);  			string entityCode = tokens [3];  			if (entityCode.Length == 6) {  				string eCode = entityCode.Substring (0' 2);  				string etCode = entityCode.Substring (2' 2);  				string estCode = entityCode.Substring (4' 2);  				// Now that we have everything' let's find the pieces in the open symbol set  				SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  				// Find the entity' entity type' and entity subtype for the specified SIDC.  				SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  				if (entity != null) {  					ls.EntityID = entity.ID;  					ls.ID = entity.ID;  					if (etCode != "00") {  						SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  						if (eType != null) {  							ls.EntityTypeID = eType.ID;  							ls.ID = ls.ID + "_" + eType.ID;  							if (estCode != "00") {  								EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  								if (eSubType != null) {  									ls.EntitySubTypeID = eSubType.ID;  									ls.ID = ls.ID + "_" + eSubType.ID;  								}  							}  						}  					}  				}  				// No entities were found' so mark it as retired.  				if (ls.ID == null) {  					ls.ID = "RETIRED";  					ls.Remarks = "Retired";  				}  				// Find the modifier 1 and modifier 2 for the specified SIDC.  				if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  					if (mod1Code.Length == 2) {  						ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  						if (mod != null) {  							ls.ModifierOneID = mod.ID;  							ls.ID = ls.ID + "_" + mod.ID;  						}  					}  				}  				if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  					if (mod2Code.Length == 2) {  						ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  						if (mod != null) {  							ls.ModifierTwoID = mod.ID;  							ls.ID = ls.ID + "_" + mod.ID;  						}  					}  				}  				ls.ID = ls.ID + "_SYM";  				ls.Label = fullLegacyCode;  				// Add the legacy function code  				LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  				lfCode.Name = "2525C";  				if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  					lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  				if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  					lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  				lfCode.Value = functionCode;  				if (status != "")  					lfCode.Description = status;  				if (remarks != "")  					lfCode.Remarks = remarks;  				ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  					lfCode  				};  				// Add it to the current legacy symbol set  				legacySymbols.Add (ls);  			}  		}  	}  	r.Close ();  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: using (StreamReader r = new StreamReader (source)) {  	while (!r.EndOfStream) {  		line = r.ReadLine ();  		string[] tokens = line.Split (''');  		string ssCode = tokens [2];  		string legacyCode = tokens [0];  		string fullLegacyCode = tokens [1];  		string mod1Code = tokens [4];  		string mod2Code = tokens [5];  		string status = tokens [6];  		string remarks = tokens [7];  		// Skip over all rows in the source file that don't match the symbol set code  		// or where the 2525C SIDC field is blank.  		if (ssCode == code && legacyCode != "") {  			// Extract the six character function code from the current 2525C SIDC.  			string functionCode = legacyCode.Substring (legacyCode.Length - 6);  			//string schemaCode = legacyCode.Substring(0' 1);  			//string dimensionCode = legacyCode.Substring(2' 1);  			string entityCode = tokens [3];  			if (entityCode.Length == 6) {  				string eCode = entityCode.Substring (0' 2);  				string etCode = entityCode.Substring (2' 2);  				string estCode = entityCode.Substring (4' 2);  				// Now that we have everything' let's find the pieces in the open symbol set  				SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  				// Find the entity' entity type' and entity subtype for the specified SIDC.  				SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  				if (entity != null) {  					ls.EntityID = entity.ID;  					ls.ID = entity.ID;  					if (etCode != "00") {  						SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  						if (eType != null) {  							ls.EntityTypeID = eType.ID;  							ls.ID = ls.ID + "_" + eType.ID;  							if (estCode != "00") {  								EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  								if (eSubType != null) {  									ls.EntitySubTypeID = eSubType.ID;  									ls.ID = ls.ID + "_" + eSubType.ID;  								}  							}  						}  					}  				}  				// No entities were found' so mark it as retired.  				if (ls.ID == null) {  					ls.ID = "RETIRED";  					ls.Remarks = "Retired";  				}  				// Find the modifier 1 and modifier 2 for the specified SIDC.  				if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  					if (mod1Code.Length == 2) {  						ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  						if (mod != null) {  							ls.ModifierOneID = mod.ID;  							ls.ID = ls.ID + "_" + mod.ID;  						}  					}  				}  				if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  					if (mod2Code.Length == 2) {  						ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  						if (mod != null) {  							ls.ModifierTwoID = mod.ID;  							ls.ID = ls.ID + "_" + mod.ID;  						}  					}  				}  				ls.ID = ls.ID + "_SYM";  				ls.Label = fullLegacyCode;  				// Add the legacy function code  				LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  				lfCode.Name = "2525C";  				if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  					lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  				if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  					lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  				lfCode.Value = functionCode;  				if (status != "")  					lfCode.Description = status;  				if (remarks != "")  					lfCode.Remarks = remarks;  				ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  					lfCode  				};  				// Add it to the current legacy symbol set  				legacySymbols.Add (ls);  			}  		}  	}  	r.Close ();  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: using (StreamReader r = new StreamReader (source)) {  	while (!r.EndOfStream) {  		line = r.ReadLine ();  		string[] tokens = line.Split (''');  		string ssCode = tokens [2];  		string legacyCode = tokens [0];  		string fullLegacyCode = tokens [1];  		string mod1Code = tokens [4];  		string mod2Code = tokens [5];  		string status = tokens [6];  		string remarks = tokens [7];  		// Skip over all rows in the source file that don't match the symbol set code  		// or where the 2525C SIDC field is blank.  		if (ssCode == code && legacyCode != "") {  			// Extract the six character function code from the current 2525C SIDC.  			string functionCode = legacyCode.Substring (legacyCode.Length - 6);  			//string schemaCode = legacyCode.Substring(0' 1);  			//string dimensionCode = legacyCode.Substring(2' 1);  			string entityCode = tokens [3];  			if (entityCode.Length == 6) {  				string eCode = entityCode.Substring (0' 2);  				string etCode = entityCode.Substring (2' 2);  				string estCode = entityCode.Substring (4' 2);  				// Now that we have everything' let's find the pieces in the open symbol set  				SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  				// Find the entity' entity type' and entity subtype for the specified SIDC.  				SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  				if (entity != null) {  					ls.EntityID = entity.ID;  					ls.ID = entity.ID;  					if (etCode != "00") {  						SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  						if (eType != null) {  							ls.EntityTypeID = eType.ID;  							ls.ID = ls.ID + "_" + eType.ID;  							if (estCode != "00") {  								EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  								if (eSubType != null) {  									ls.EntitySubTypeID = eSubType.ID;  									ls.ID = ls.ID + "_" + eSubType.ID;  								}  							}  						}  					}  				}  				// No entities were found' so mark it as retired.  				if (ls.ID == null) {  					ls.ID = "RETIRED";  					ls.Remarks = "Retired";  				}  				// Find the modifier 1 and modifier 2 for the specified SIDC.  				if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  					if (mod1Code.Length == 2) {  						ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  						if (mod != null) {  							ls.ModifierOneID = mod.ID;  							ls.ID = ls.ID + "_" + mod.ID;  						}  					}  				}  				if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  					if (mod2Code.Length == 2) {  						ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  						if (mod != null) {  							ls.ModifierTwoID = mod.ID;  							ls.ID = ls.ID + "_" + mod.ID;  						}  					}  				}  				ls.ID = ls.ID + "_SYM";  				ls.Label = fullLegacyCode;  				// Add the legacy function code  				LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  				lfCode.Name = "2525C";  				if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  					lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  				if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  					lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  				lfCode.Value = functionCode;  				if (status != "")  					lfCode.Description = status;  				if (remarks != "")  					lfCode.Remarks = remarks;  				ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  					lfCode  				};  				// Add it to the current legacy symbol set  				legacySymbols.Add (ls);  			}  		}  	}  	r.Close ();  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: using (StreamReader r = new StreamReader (source)) {  	while (!r.EndOfStream) {  		line = r.ReadLine ();  		string[] tokens = line.Split (''');  		string ssCode = tokens [2];  		string legacyCode = tokens [0];  		string fullLegacyCode = tokens [1];  		string mod1Code = tokens [4];  		string mod2Code = tokens [5];  		string status = tokens [6];  		string remarks = tokens [7];  		// Skip over all rows in the source file that don't match the symbol set code  		// or where the 2525C SIDC field is blank.  		if (ssCode == code && legacyCode != "") {  			// Extract the six character function code from the current 2525C SIDC.  			string functionCode = legacyCode.Substring (legacyCode.Length - 6);  			//string schemaCode = legacyCode.Substring(0' 1);  			//string dimensionCode = legacyCode.Substring(2' 1);  			string entityCode = tokens [3];  			if (entityCode.Length == 6) {  				string eCode = entityCode.Substring (0' 2);  				string etCode = entityCode.Substring (2' 2);  				string estCode = entityCode.Substring (4' 2);  				// Now that we have everything' let's find the pieces in the open symbol set  				SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  				// Find the entity' entity type' and entity subtype for the specified SIDC.  				SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  				if (entity != null) {  					ls.EntityID = entity.ID;  					ls.ID = entity.ID;  					if (etCode != "00") {  						SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  						if (eType != null) {  							ls.EntityTypeID = eType.ID;  							ls.ID = ls.ID + "_" + eType.ID;  							if (estCode != "00") {  								EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  								if (eSubType != null) {  									ls.EntitySubTypeID = eSubType.ID;  									ls.ID = ls.ID + "_" + eSubType.ID;  								}  							}  						}  					}  				}  				// No entities were found' so mark it as retired.  				if (ls.ID == null) {  					ls.ID = "RETIRED";  					ls.Remarks = "Retired";  				}  				// Find the modifier 1 and modifier 2 for the specified SIDC.  				if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  					if (mod1Code.Length == 2) {  						ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  						if (mod != null) {  							ls.ModifierOneID = mod.ID;  							ls.ID = ls.ID + "_" + mod.ID;  						}  					}  				}  				if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  					if (mod2Code.Length == 2) {  						ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  						if (mod != null) {  							ls.ModifierTwoID = mod.ID;  							ls.ID = ls.ID + "_" + mod.ID;  						}  					}  				}  				ls.ID = ls.ID + "_SYM";  				ls.Label = fullLegacyCode;  				// Add the legacy function code  				LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  				lfCode.Name = "2525C";  				if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  					lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  				if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  					lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  				lfCode.Value = functionCode;  				if (status != "")  					lfCode.Description = status;  				if (remarks != "")  					lfCode.Remarks = remarks;  				ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  					lfCode  				};  				// Add it to the current legacy symbol set  				legacySymbols.Add (ls);  			}  		}  	}  	r.Close ();  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: using (StreamReader r = new StreamReader (source)) {  	while (!r.EndOfStream) {  		line = r.ReadLine ();  		string[] tokens = line.Split (''');  		string ssCode = tokens [2];  		string legacyCode = tokens [0];  		string fullLegacyCode = tokens [1];  		string mod1Code = tokens [4];  		string mod2Code = tokens [5];  		string status = tokens [6];  		string remarks = tokens [7];  		// Skip over all rows in the source file that don't match the symbol set code  		// or where the 2525C SIDC field is blank.  		if (ssCode == code && legacyCode != "") {  			// Extract the six character function code from the current 2525C SIDC.  			string functionCode = legacyCode.Substring (legacyCode.Length - 6);  			//string schemaCode = legacyCode.Substring(0' 1);  			//string dimensionCode = legacyCode.Substring(2' 1);  			string entityCode = tokens [3];  			if (entityCode.Length == 6) {  				string eCode = entityCode.Substring (0' 2);  				string etCode = entityCode.Substring (2' 2);  				string estCode = entityCode.Substring (4' 2);  				// Now that we have everything' let's find the pieces in the open symbol set  				SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  				// Find the entity' entity type' and entity subtype for the specified SIDC.  				SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  				if (entity != null) {  					ls.EntityID = entity.ID;  					ls.ID = entity.ID;  					if (etCode != "00") {  						SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  						if (eType != null) {  							ls.EntityTypeID = eType.ID;  							ls.ID = ls.ID + "_" + eType.ID;  							if (estCode != "00") {  								EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  								if (eSubType != null) {  									ls.EntitySubTypeID = eSubType.ID;  									ls.ID = ls.ID + "_" + eSubType.ID;  								}  							}  						}  					}  				}  				// No entities were found' so mark it as retired.  				if (ls.ID == null) {  					ls.ID = "RETIRED";  					ls.Remarks = "Retired";  				}  				// Find the modifier 1 and modifier 2 for the specified SIDC.  				if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  					if (mod1Code.Length == 2) {  						ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  						if (mod != null) {  							ls.ModifierOneID = mod.ID;  							ls.ID = ls.ID + "_" + mod.ID;  						}  					}  				}  				if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  					if (mod2Code.Length == 2) {  						ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  						if (mod != null) {  							ls.ModifierTwoID = mod.ID;  							ls.ID = ls.ID + "_" + mod.ID;  						}  					}  				}  				ls.ID = ls.ID + "_SYM";  				ls.Label = fullLegacyCode;  				// Add the legacy function code  				LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  				lfCode.Name = "2525C";  				if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  					lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  				if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  					lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  				lfCode.Value = functionCode;  				if (status != "")  					lfCode.Description = status;  				if (remarks != "")  					lfCode.Remarks = remarks;  				ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  					lfCode  				};  				// Add it to the current legacy symbol set  				legacySymbols.Add (ls);  			}  		}  	}  	r.Close ();  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: using (StreamReader r = new StreamReader (source)) {  	while (!r.EndOfStream) {  		line = r.ReadLine ();  		string[] tokens = line.Split (''');  		string ssCode = tokens [2];  		string legacyCode = tokens [0];  		string fullLegacyCode = tokens [1];  		string mod1Code = tokens [4];  		string mod2Code = tokens [5];  		string status = tokens [6];  		string remarks = tokens [7];  		// Skip over all rows in the source file that don't match the symbol set code  		// or where the 2525C SIDC field is blank.  		if (ssCode == code && legacyCode != "") {  			// Extract the six character function code from the current 2525C SIDC.  			string functionCode = legacyCode.Substring (legacyCode.Length - 6);  			//string schemaCode = legacyCode.Substring(0' 1);  			//string dimensionCode = legacyCode.Substring(2' 1);  			string entityCode = tokens [3];  			if (entityCode.Length == 6) {  				string eCode = entityCode.Substring (0' 2);  				string etCode = entityCode.Substring (2' 2);  				string estCode = entityCode.Substring (4' 2);  				// Now that we have everything' let's find the pieces in the open symbol set  				SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  				// Find the entity' entity type' and entity subtype for the specified SIDC.  				SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  				if (entity != null) {  					ls.EntityID = entity.ID;  					ls.ID = entity.ID;  					if (etCode != "00") {  						SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  						if (eType != null) {  							ls.EntityTypeID = eType.ID;  							ls.ID = ls.ID + "_" + eType.ID;  							if (estCode != "00") {  								EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  								if (eSubType != null) {  									ls.EntitySubTypeID = eSubType.ID;  									ls.ID = ls.ID + "_" + eSubType.ID;  								}  							}  						}  					}  				}  				// No entities were found' so mark it as retired.  				if (ls.ID == null) {  					ls.ID = "RETIRED";  					ls.Remarks = "Retired";  				}  				// Find the modifier 1 and modifier 2 for the specified SIDC.  				if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  					if (mod1Code.Length == 2) {  						ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  						if (mod != null) {  							ls.ModifierOneID = mod.ID;  							ls.ID = ls.ID + "_" + mod.ID;  						}  					}  				}  				if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  					if (mod2Code.Length == 2) {  						ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  						if (mod != null) {  							ls.ModifierTwoID = mod.ID;  							ls.ID = ls.ID + "_" + mod.ID;  						}  					}  				}  				ls.ID = ls.ID + "_SYM";  				ls.Label = fullLegacyCode;  				// Add the legacy function code  				LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  				lfCode.Name = "2525C";  				if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  					lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  				if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  					lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  				lfCode.Value = functionCode;  				if (status != "")  					lfCode.Description = status;  				if (remarks != "")  					lfCode.Remarks = remarks;  				ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  					lfCode  				};  				// Add it to the current legacy symbol set  				legacySymbols.Add (ls);  			}  		}  	}  	r.Close ();  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: while (!r.EndOfStream) {  	line = r.ReadLine ();  	string[] tokens = line.Split (''');  	string ssCode = tokens [2];  	string legacyCode = tokens [0];  	string fullLegacyCode = tokens [1];  	string mod1Code = tokens [4];  	string mod2Code = tokens [5];  	string status = tokens [6];  	string remarks = tokens [7];  	// Skip over all rows in the source file that don't match the symbol set code  	// or where the 2525C SIDC field is blank.  	if (ssCode == code && legacyCode != "") {  		// Extract the six character function code from the current 2525C SIDC.  		string functionCode = legacyCode.Substring (legacyCode.Length - 6);  		//string schemaCode = legacyCode.Substring(0' 1);  		//string dimensionCode = legacyCode.Substring(2' 1);  		string entityCode = tokens [3];  		if (entityCode.Length == 6) {  			string eCode = entityCode.Substring (0' 2);  			string etCode = entityCode.Substring (2' 2);  			string estCode = entityCode.Substring (4' 2);  			// Now that we have everything' let's find the pieces in the open symbol set  			SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  			// Find the entity' entity type' and entity subtype for the specified SIDC.  			SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  			if (entity != null) {  				ls.EntityID = entity.ID;  				ls.ID = entity.ID;  				if (etCode != "00") {  					SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  					if (eType != null) {  						ls.EntityTypeID = eType.ID;  						ls.ID = ls.ID + "_" + eType.ID;  						if (estCode != "00") {  							EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  							if (eSubType != null) {  								ls.EntitySubTypeID = eSubType.ID;  								ls.ID = ls.ID + "_" + eSubType.ID;  							}  						}  					}  				}  			}  			// No entities were found' so mark it as retired.  			if (ls.ID == null) {  				ls.ID = "RETIRED";  				ls.Remarks = "Retired";  			}  			// Find the modifier 1 and modifier 2 for the specified SIDC.  			if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  				if (mod1Code.Length == 2) {  					ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  					if (mod != null) {  						ls.ModifierOneID = mod.ID;  						ls.ID = ls.ID + "_" + mod.ID;  					}  				}  			}  			if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  				if (mod2Code.Length == 2) {  					ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  					if (mod != null) {  						ls.ModifierTwoID = mod.ID;  						ls.ID = ls.ID + "_" + mod.ID;  					}  				}  			}  			ls.ID = ls.ID + "_SYM";  			ls.Label = fullLegacyCode;  			// Add the legacy function code  			LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  			lfCode.Name = "2525C";  			if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  				lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  			if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  				lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  			lfCode.Value = functionCode;  			if (status != "")  				lfCode.Description = status;  			if (remarks != "")  				lfCode.Remarks = remarks;  			ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  				lfCode  			};  			// Add it to the current legacy symbol set  			legacySymbols.Add (ls);  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: while (!r.EndOfStream) {  	line = r.ReadLine ();  	string[] tokens = line.Split (''');  	string ssCode = tokens [2];  	string legacyCode = tokens [0];  	string fullLegacyCode = tokens [1];  	string mod1Code = tokens [4];  	string mod2Code = tokens [5];  	string status = tokens [6];  	string remarks = tokens [7];  	// Skip over all rows in the source file that don't match the symbol set code  	// or where the 2525C SIDC field is blank.  	if (ssCode == code && legacyCode != "") {  		// Extract the six character function code from the current 2525C SIDC.  		string functionCode = legacyCode.Substring (legacyCode.Length - 6);  		//string schemaCode = legacyCode.Substring(0' 1);  		//string dimensionCode = legacyCode.Substring(2' 1);  		string entityCode = tokens [3];  		if (entityCode.Length == 6) {  			string eCode = entityCode.Substring (0' 2);  			string etCode = entityCode.Substring (2' 2);  			string estCode = entityCode.Substring (4' 2);  			// Now that we have everything' let's find the pieces in the open symbol set  			SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  			// Find the entity' entity type' and entity subtype for the specified SIDC.  			SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  			if (entity != null) {  				ls.EntityID = entity.ID;  				ls.ID = entity.ID;  				if (etCode != "00") {  					SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  					if (eType != null) {  						ls.EntityTypeID = eType.ID;  						ls.ID = ls.ID + "_" + eType.ID;  						if (estCode != "00") {  							EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  							if (eSubType != null) {  								ls.EntitySubTypeID = eSubType.ID;  								ls.ID = ls.ID + "_" + eSubType.ID;  							}  						}  					}  				}  			}  			// No entities were found' so mark it as retired.  			if (ls.ID == null) {  				ls.ID = "RETIRED";  				ls.Remarks = "Retired";  			}  			// Find the modifier 1 and modifier 2 for the specified SIDC.  			if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  				if (mod1Code.Length == 2) {  					ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  					if (mod != null) {  						ls.ModifierOneID = mod.ID;  						ls.ID = ls.ID + "_" + mod.ID;  					}  				}  			}  			if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  				if (mod2Code.Length == 2) {  					ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  					if (mod != null) {  						ls.ModifierTwoID = mod.ID;  						ls.ID = ls.ID + "_" + mod.ID;  					}  				}  			}  			ls.ID = ls.ID + "_SYM";  			ls.Label = fullLegacyCode;  			// Add the legacy function code  			LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  			lfCode.Name = "2525C";  			if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  				lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  			if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  				lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  			lfCode.Value = functionCode;  			if (status != "")  				lfCode.Description = status;  			if (remarks != "")  				lfCode.Remarks = remarks;  			ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  				lfCode  			};  			// Add it to the current legacy symbol set  			legacySymbols.Add (ls);  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: while (!r.EndOfStream) {  	line = r.ReadLine ();  	string[] tokens = line.Split (''');  	string ssCode = tokens [2];  	string legacyCode = tokens [0];  	string fullLegacyCode = tokens [1];  	string mod1Code = tokens [4];  	string mod2Code = tokens [5];  	string status = tokens [6];  	string remarks = tokens [7];  	// Skip over all rows in the source file that don't match the symbol set code  	// or where the 2525C SIDC field is blank.  	if (ssCode == code && legacyCode != "") {  		// Extract the six character function code from the current 2525C SIDC.  		string functionCode = legacyCode.Substring (legacyCode.Length - 6);  		//string schemaCode = legacyCode.Substring(0' 1);  		//string dimensionCode = legacyCode.Substring(2' 1);  		string entityCode = tokens [3];  		if (entityCode.Length == 6) {  			string eCode = entityCode.Substring (0' 2);  			string etCode = entityCode.Substring (2' 2);  			string estCode = entityCode.Substring (4' 2);  			// Now that we have everything' let's find the pieces in the open symbol set  			SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  			// Find the entity' entity type' and entity subtype for the specified SIDC.  			SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  			if (entity != null) {  				ls.EntityID = entity.ID;  				ls.ID = entity.ID;  				if (etCode != "00") {  					SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  					if (eType != null) {  						ls.EntityTypeID = eType.ID;  						ls.ID = ls.ID + "_" + eType.ID;  						if (estCode != "00") {  							EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  							if (eSubType != null) {  								ls.EntitySubTypeID = eSubType.ID;  								ls.ID = ls.ID + "_" + eSubType.ID;  							}  						}  					}  				}  			}  			// No entities were found' so mark it as retired.  			if (ls.ID == null) {  				ls.ID = "RETIRED";  				ls.Remarks = "Retired";  			}  			// Find the modifier 1 and modifier 2 for the specified SIDC.  			if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  				if (mod1Code.Length == 2) {  					ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  					if (mod != null) {  						ls.ModifierOneID = mod.ID;  						ls.ID = ls.ID + "_" + mod.ID;  					}  				}  			}  			if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  				if (mod2Code.Length == 2) {  					ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  					if (mod != null) {  						ls.ModifierTwoID = mod.ID;  						ls.ID = ls.ID + "_" + mod.ID;  					}  				}  			}  			ls.ID = ls.ID + "_SYM";  			ls.Label = fullLegacyCode;  			// Add the legacy function code  			LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  			lfCode.Name = "2525C";  			if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  				lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  			if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  				lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  			lfCode.Value = functionCode;  			if (status != "")  				lfCode.Description = status;  			if (remarks != "")  				lfCode.Remarks = remarks;  			ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  				lfCode  			};  			// Add it to the current legacy symbol set  			legacySymbols.Add (ls);  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: while (!r.EndOfStream) {  	line = r.ReadLine ();  	string[] tokens = line.Split (''');  	string ssCode = tokens [2];  	string legacyCode = tokens [0];  	string fullLegacyCode = tokens [1];  	string mod1Code = tokens [4];  	string mod2Code = tokens [5];  	string status = tokens [6];  	string remarks = tokens [7];  	// Skip over all rows in the source file that don't match the symbol set code  	// or where the 2525C SIDC field is blank.  	if (ssCode == code && legacyCode != "") {  		// Extract the six character function code from the current 2525C SIDC.  		string functionCode = legacyCode.Substring (legacyCode.Length - 6);  		//string schemaCode = legacyCode.Substring(0' 1);  		//string dimensionCode = legacyCode.Substring(2' 1);  		string entityCode = tokens [3];  		if (entityCode.Length == 6) {  			string eCode = entityCode.Substring (0' 2);  			string etCode = entityCode.Substring (2' 2);  			string estCode = entityCode.Substring (4' 2);  			// Now that we have everything' let's find the pieces in the open symbol set  			SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  			// Find the entity' entity type' and entity subtype for the specified SIDC.  			SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  			if (entity != null) {  				ls.EntityID = entity.ID;  				ls.ID = entity.ID;  				if (etCode != "00") {  					SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  					if (eType != null) {  						ls.EntityTypeID = eType.ID;  						ls.ID = ls.ID + "_" + eType.ID;  						if (estCode != "00") {  							EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  							if (eSubType != null) {  								ls.EntitySubTypeID = eSubType.ID;  								ls.ID = ls.ID + "_" + eSubType.ID;  							}  						}  					}  				}  			}  			// No entities were found' so mark it as retired.  			if (ls.ID == null) {  				ls.ID = "RETIRED";  				ls.Remarks = "Retired";  			}  			// Find the modifier 1 and modifier 2 for the specified SIDC.  			if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  				if (mod1Code.Length == 2) {  					ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  					if (mod != null) {  						ls.ModifierOneID = mod.ID;  						ls.ID = ls.ID + "_" + mod.ID;  					}  				}  			}  			if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  				if (mod2Code.Length == 2) {  					ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  					if (mod != null) {  						ls.ModifierTwoID = mod.ID;  						ls.ID = ls.ID + "_" + mod.ID;  					}  				}  			}  			ls.ID = ls.ID + "_SYM";  			ls.Label = fullLegacyCode;  			// Add the legacy function code  			LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  			lfCode.Name = "2525C";  			if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  				lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  			if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  				lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  			lfCode.Value = functionCode;  			if (status != "")  				lfCode.Description = status;  			if (remarks != "")  				lfCode.Remarks = remarks;  			ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  				lfCode  			};  			// Add it to the current legacy symbol set  			legacySymbols.Add (ls);  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: while (!r.EndOfStream) {  	line = r.ReadLine ();  	string[] tokens = line.Split (''');  	string ssCode = tokens [2];  	string legacyCode = tokens [0];  	string fullLegacyCode = tokens [1];  	string mod1Code = tokens [4];  	string mod2Code = tokens [5];  	string status = tokens [6];  	string remarks = tokens [7];  	// Skip over all rows in the source file that don't match the symbol set code  	// or where the 2525C SIDC field is blank.  	if (ssCode == code && legacyCode != "") {  		// Extract the six character function code from the current 2525C SIDC.  		string functionCode = legacyCode.Substring (legacyCode.Length - 6);  		//string schemaCode = legacyCode.Substring(0' 1);  		//string dimensionCode = legacyCode.Substring(2' 1);  		string entityCode = tokens [3];  		if (entityCode.Length == 6) {  			string eCode = entityCode.Substring (0' 2);  			string etCode = entityCode.Substring (2' 2);  			string estCode = entityCode.Substring (4' 2);  			// Now that we have everything' let's find the pieces in the open symbol set  			SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  			// Find the entity' entity type' and entity subtype for the specified SIDC.  			SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  			if (entity != null) {  				ls.EntityID = entity.ID;  				ls.ID = entity.ID;  				if (etCode != "00") {  					SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  					if (eType != null) {  						ls.EntityTypeID = eType.ID;  						ls.ID = ls.ID + "_" + eType.ID;  						if (estCode != "00") {  							EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  							if (eSubType != null) {  								ls.EntitySubTypeID = eSubType.ID;  								ls.ID = ls.ID + "_" + eSubType.ID;  							}  						}  					}  				}  			}  			// No entities were found' so mark it as retired.  			if (ls.ID == null) {  				ls.ID = "RETIRED";  				ls.Remarks = "Retired";  			}  			// Find the modifier 1 and modifier 2 for the specified SIDC.  			if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  				if (mod1Code.Length == 2) {  					ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  					if (mod != null) {  						ls.ModifierOneID = mod.ID;  						ls.ID = ls.ID + "_" + mod.ID;  					}  				}  			}  			if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  				if (mod2Code.Length == 2) {  					ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  					if (mod != null) {  						ls.ModifierTwoID = mod.ID;  						ls.ID = ls.ID + "_" + mod.ID;  					}  				}  			}  			ls.ID = ls.ID + "_SYM";  			ls.Label = fullLegacyCode;  			// Add the legacy function code  			LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  			lfCode.Name = "2525C";  			if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  				lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  			if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  				lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  			lfCode.Value = functionCode;  			if (status != "")  				lfCode.Description = status;  			if (remarks != "")  				lfCode.Remarks = remarks;  			ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  				lfCode  			};  			// Add it to the current legacy symbol set  			legacySymbols.Add (ls);  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: while (!r.EndOfStream) {  	line = r.ReadLine ();  	string[] tokens = line.Split (''');  	string ssCode = tokens [2];  	string legacyCode = tokens [0];  	string fullLegacyCode = tokens [1];  	string mod1Code = tokens [4];  	string mod2Code = tokens [5];  	string status = tokens [6];  	string remarks = tokens [7];  	// Skip over all rows in the source file that don't match the symbol set code  	// or where the 2525C SIDC field is blank.  	if (ssCode == code && legacyCode != "") {  		// Extract the six character function code from the current 2525C SIDC.  		string functionCode = legacyCode.Substring (legacyCode.Length - 6);  		//string schemaCode = legacyCode.Substring(0' 1);  		//string dimensionCode = legacyCode.Substring(2' 1);  		string entityCode = tokens [3];  		if (entityCode.Length == 6) {  			string eCode = entityCode.Substring (0' 2);  			string etCode = entityCode.Substring (2' 2);  			string estCode = entityCode.Substring (4' 2);  			// Now that we have everything' let's find the pieces in the open symbol set  			SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  			// Find the entity' entity type' and entity subtype for the specified SIDC.  			SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  			if (entity != null) {  				ls.EntityID = entity.ID;  				ls.ID = entity.ID;  				if (etCode != "00") {  					SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  					if (eType != null) {  						ls.EntityTypeID = eType.ID;  						ls.ID = ls.ID + "_" + eType.ID;  						if (estCode != "00") {  							EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  							if (eSubType != null) {  								ls.EntitySubTypeID = eSubType.ID;  								ls.ID = ls.ID + "_" + eSubType.ID;  							}  						}  					}  				}  			}  			// No entities were found' so mark it as retired.  			if (ls.ID == null) {  				ls.ID = "RETIRED";  				ls.Remarks = "Retired";  			}  			// Find the modifier 1 and modifier 2 for the specified SIDC.  			if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  				if (mod1Code.Length == 2) {  					ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  					if (mod != null) {  						ls.ModifierOneID = mod.ID;  						ls.ID = ls.ID + "_" + mod.ID;  					}  				}  			}  			if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  				if (mod2Code.Length == 2) {  					ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  					if (mod != null) {  						ls.ModifierTwoID = mod.ID;  						ls.ID = ls.ID + "_" + mod.ID;  					}  				}  			}  			ls.ID = ls.ID + "_SYM";  			ls.Label = fullLegacyCode;  			// Add the legacy function code  			LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  			lfCode.Name = "2525C";  			if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  				lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  			if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  				lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  			lfCode.Value = functionCode;  			if (status != "")  				lfCode.Description = status;  			if (remarks != "")  				lfCode.Remarks = remarks;  			ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  				lfCode  			};  			// Add it to the current legacy symbol set  			legacySymbols.Add (ls);  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: while (!r.EndOfStream) {  	line = r.ReadLine ();  	string[] tokens = line.Split (''');  	string ssCode = tokens [2];  	string legacyCode = tokens [0];  	string fullLegacyCode = tokens [1];  	string mod1Code = tokens [4];  	string mod2Code = tokens [5];  	string status = tokens [6];  	string remarks = tokens [7];  	// Skip over all rows in the source file that don't match the symbol set code  	// or where the 2525C SIDC field is blank.  	if (ssCode == code && legacyCode != "") {  		// Extract the six character function code from the current 2525C SIDC.  		string functionCode = legacyCode.Substring (legacyCode.Length - 6);  		//string schemaCode = legacyCode.Substring(0' 1);  		//string dimensionCode = legacyCode.Substring(2' 1);  		string entityCode = tokens [3];  		if (entityCode.Length == 6) {  			string eCode = entityCode.Substring (0' 2);  			string etCode = entityCode.Substring (2' 2);  			string estCode = entityCode.Substring (4' 2);  			// Now that we have everything' let's find the pieces in the open symbol set  			SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  			// Find the entity' entity type' and entity subtype for the specified SIDC.  			SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  			if (entity != null) {  				ls.EntityID = entity.ID;  				ls.ID = entity.ID;  				if (etCode != "00") {  					SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  					if (eType != null) {  						ls.EntityTypeID = eType.ID;  						ls.ID = ls.ID + "_" + eType.ID;  						if (estCode != "00") {  							EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  							if (eSubType != null) {  								ls.EntitySubTypeID = eSubType.ID;  								ls.ID = ls.ID + "_" + eSubType.ID;  							}  						}  					}  				}  			}  			// No entities were found' so mark it as retired.  			if (ls.ID == null) {  				ls.ID = "RETIRED";  				ls.Remarks = "Retired";  			}  			// Find the modifier 1 and modifier 2 for the specified SIDC.  			if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  				if (mod1Code.Length == 2) {  					ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  					if (mod != null) {  						ls.ModifierOneID = mod.ID;  						ls.ID = ls.ID + "_" + mod.ID;  					}  				}  			}  			if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  				if (mod2Code.Length == 2) {  					ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  					if (mod != null) {  						ls.ModifierTwoID = mod.ID;  						ls.ID = ls.ID + "_" + mod.ID;  					}  				}  			}  			ls.ID = ls.ID + "_SYM";  			ls.Label = fullLegacyCode;  			// Add the legacy function code  			LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  			lfCode.Name = "2525C";  			if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  				lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  			if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  				lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  			lfCode.Value = functionCode;  			if (status != "")  				lfCode.Description = status;  			if (remarks != "")  				lfCode.Remarks = remarks;  			ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  				lfCode  			};  			// Add it to the current legacy symbol set  			legacySymbols.Add (ls);  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: while (!r.EndOfStream) {  	line = r.ReadLine ();  	string[] tokens = line.Split (''');  	string ssCode = tokens [2];  	string legacyCode = tokens [0];  	string fullLegacyCode = tokens [1];  	string mod1Code = tokens [4];  	string mod2Code = tokens [5];  	string status = tokens [6];  	string remarks = tokens [7];  	// Skip over all rows in the source file that don't match the symbol set code  	// or where the 2525C SIDC field is blank.  	if (ssCode == code && legacyCode != "") {  		// Extract the six character function code from the current 2525C SIDC.  		string functionCode = legacyCode.Substring (legacyCode.Length - 6);  		//string schemaCode = legacyCode.Substring(0' 1);  		//string dimensionCode = legacyCode.Substring(2' 1);  		string entityCode = tokens [3];  		if (entityCode.Length == 6) {  			string eCode = entityCode.Substring (0' 2);  			string etCode = entityCode.Substring (2' 2);  			string estCode = entityCode.Substring (4' 2);  			// Now that we have everything' let's find the pieces in the open symbol set  			SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  			// Find the entity' entity type' and entity subtype for the specified SIDC.  			SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  			if (entity != null) {  				ls.EntityID = entity.ID;  				ls.ID = entity.ID;  				if (etCode != "00") {  					SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  					if (eType != null) {  						ls.EntityTypeID = eType.ID;  						ls.ID = ls.ID + "_" + eType.ID;  						if (estCode != "00") {  							EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  							if (eSubType != null) {  								ls.EntitySubTypeID = eSubType.ID;  								ls.ID = ls.ID + "_" + eSubType.ID;  							}  						}  					}  				}  			}  			// No entities were found' so mark it as retired.  			if (ls.ID == null) {  				ls.ID = "RETIRED";  				ls.Remarks = "Retired";  			}  			// Find the modifier 1 and modifier 2 for the specified SIDC.  			if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  				if (mod1Code.Length == 2) {  					ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  					if (mod != null) {  						ls.ModifierOneID = mod.ID;  						ls.ID = ls.ID + "_" + mod.ID;  					}  				}  			}  			if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  				if (mod2Code.Length == 2) {  					ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  					if (mod != null) {  						ls.ModifierTwoID = mod.ID;  						ls.ID = ls.ID + "_" + mod.ID;  					}  				}  			}  			ls.ID = ls.ID + "_SYM";  			ls.Label = fullLegacyCode;  			// Add the legacy function code  			LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  			lfCode.Name = "2525C";  			if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  				lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  			if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  				lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  			lfCode.Value = functionCode;  			if (status != "")  				lfCode.Description = status;  			if (remarks != "")  				lfCode.Remarks = remarks;  			ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  				lfCode  			};  			// Add it to the current legacy symbol set  			legacySymbols.Add (ls);  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: while (!r.EndOfStream) {  	line = r.ReadLine ();  	string[] tokens = line.Split (''');  	string ssCode = tokens [2];  	string legacyCode = tokens [0];  	string fullLegacyCode = tokens [1];  	string mod1Code = tokens [4];  	string mod2Code = tokens [5];  	string status = tokens [6];  	string remarks = tokens [7];  	// Skip over all rows in the source file that don't match the symbol set code  	// or where the 2525C SIDC field is blank.  	if (ssCode == code && legacyCode != "") {  		// Extract the six character function code from the current 2525C SIDC.  		string functionCode = legacyCode.Substring (legacyCode.Length - 6);  		//string schemaCode = legacyCode.Substring(0' 1);  		//string dimensionCode = legacyCode.Substring(2' 1);  		string entityCode = tokens [3];  		if (entityCode.Length == 6) {  			string eCode = entityCode.Substring (0' 2);  			string etCode = entityCode.Substring (2' 2);  			string estCode = entityCode.Substring (4' 2);  			// Now that we have everything' let's find the pieces in the open symbol set  			SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  			// Find the entity' entity type' and entity subtype for the specified SIDC.  			SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  			if (entity != null) {  				ls.EntityID = entity.ID;  				ls.ID = entity.ID;  				if (etCode != "00") {  					SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  					if (eType != null) {  						ls.EntityTypeID = eType.ID;  						ls.ID = ls.ID + "_" + eType.ID;  						if (estCode != "00") {  							EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  							if (eSubType != null) {  								ls.EntitySubTypeID = eSubType.ID;  								ls.ID = ls.ID + "_" + eSubType.ID;  							}  						}  					}  				}  			}  			// No entities were found' so mark it as retired.  			if (ls.ID == null) {  				ls.ID = "RETIRED";  				ls.Remarks = "Retired";  			}  			// Find the modifier 1 and modifier 2 for the specified SIDC.  			if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  				if (mod1Code.Length == 2) {  					ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  					if (mod != null) {  						ls.ModifierOneID = mod.ID;  						ls.ID = ls.ID + "_" + mod.ID;  					}  				}  			}  			if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  				if (mod2Code.Length == 2) {  					ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  					if (mod != null) {  						ls.ModifierTwoID = mod.ID;  						ls.ID = ls.ID + "_" + mod.ID;  					}  				}  			}  			ls.ID = ls.ID + "_SYM";  			ls.Label = fullLegacyCode;  			// Add the legacy function code  			LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  			lfCode.Name = "2525C";  			if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  				lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  			if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  				lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  			lfCode.Value = functionCode;  			if (status != "")  				lfCode.Description = status;  			if (remarks != "")  				lfCode.Remarks = remarks;  			ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  				lfCode  			};  			// Add it to the current legacy symbol set  			legacySymbols.Add (ls);  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: while (!r.EndOfStream) {  	line = r.ReadLine ();  	string[] tokens = line.Split (''');  	string ssCode = tokens [2];  	string legacyCode = tokens [0];  	string fullLegacyCode = tokens [1];  	string mod1Code = tokens [4];  	string mod2Code = tokens [5];  	string status = tokens [6];  	string remarks = tokens [7];  	// Skip over all rows in the source file that don't match the symbol set code  	// or where the 2525C SIDC field is blank.  	if (ssCode == code && legacyCode != "") {  		// Extract the six character function code from the current 2525C SIDC.  		string functionCode = legacyCode.Substring (legacyCode.Length - 6);  		//string schemaCode = legacyCode.Substring(0' 1);  		//string dimensionCode = legacyCode.Substring(2' 1);  		string entityCode = tokens [3];  		if (entityCode.Length == 6) {  			string eCode = entityCode.Substring (0' 2);  			string etCode = entityCode.Substring (2' 2);  			string estCode = entityCode.Substring (4' 2);  			// Now that we have everything' let's find the pieces in the open symbol set  			SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  			// Find the entity' entity type' and entity subtype for the specified SIDC.  			SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  			if (entity != null) {  				ls.EntityID = entity.ID;  				ls.ID = entity.ID;  				if (etCode != "00") {  					SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  					if (eType != null) {  						ls.EntityTypeID = eType.ID;  						ls.ID = ls.ID + "_" + eType.ID;  						if (estCode != "00") {  							EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  							if (eSubType != null) {  								ls.EntitySubTypeID = eSubType.ID;  								ls.ID = ls.ID + "_" + eSubType.ID;  							}  						}  					}  				}  			}  			// No entities were found' so mark it as retired.  			if (ls.ID == null) {  				ls.ID = "RETIRED";  				ls.Remarks = "Retired";  			}  			// Find the modifier 1 and modifier 2 for the specified SIDC.  			if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  				if (mod1Code.Length == 2) {  					ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  					if (mod != null) {  						ls.ModifierOneID = mod.ID;  						ls.ID = ls.ID + "_" + mod.ID;  					}  				}  			}  			if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  				if (mod2Code.Length == 2) {  					ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  					if (mod != null) {  						ls.ModifierTwoID = mod.ID;  						ls.ID = ls.ID + "_" + mod.ID;  					}  				}  			}  			ls.ID = ls.ID + "_SYM";  			ls.Label = fullLegacyCode;  			// Add the legacy function code  			LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  			lfCode.Name = "2525C";  			if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  				lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  			if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  				lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  			lfCode.Value = functionCode;  			if (status != "")  				lfCode.Description = status;  			if (remarks != "")  				lfCode.Remarks = remarks;  			ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  				lfCode  			};  			// Add it to the current legacy symbol set  			legacySymbols.Add (ls);  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: while (!r.EndOfStream) {  	line = r.ReadLine ();  	string[] tokens = line.Split (''');  	string ssCode = tokens [2];  	string legacyCode = tokens [0];  	string fullLegacyCode = tokens [1];  	string mod1Code = tokens [4];  	string mod2Code = tokens [5];  	string status = tokens [6];  	string remarks = tokens [7];  	// Skip over all rows in the source file that don't match the symbol set code  	// or where the 2525C SIDC field is blank.  	if (ssCode == code && legacyCode != "") {  		// Extract the six character function code from the current 2525C SIDC.  		string functionCode = legacyCode.Substring (legacyCode.Length - 6);  		//string schemaCode = legacyCode.Substring(0' 1);  		//string dimensionCode = legacyCode.Substring(2' 1);  		string entityCode = tokens [3];  		if (entityCode.Length == 6) {  			string eCode = entityCode.Substring (0' 2);  			string etCode = entityCode.Substring (2' 2);  			string estCode = entityCode.Substring (4' 2);  			// Now that we have everything' let's find the pieces in the open symbol set  			SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  			// Find the entity' entity type' and entity subtype for the specified SIDC.  			SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  			if (entity != null) {  				ls.EntityID = entity.ID;  				ls.ID = entity.ID;  				if (etCode != "00") {  					SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  					if (eType != null) {  						ls.EntityTypeID = eType.ID;  						ls.ID = ls.ID + "_" + eType.ID;  						if (estCode != "00") {  							EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  							if (eSubType != null) {  								ls.EntitySubTypeID = eSubType.ID;  								ls.ID = ls.ID + "_" + eSubType.ID;  							}  						}  					}  				}  			}  			// No entities were found' so mark it as retired.  			if (ls.ID == null) {  				ls.ID = "RETIRED";  				ls.Remarks = "Retired";  			}  			// Find the modifier 1 and modifier 2 for the specified SIDC.  			if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  				if (mod1Code.Length == 2) {  					ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  					if (mod != null) {  						ls.ModifierOneID = mod.ID;  						ls.ID = ls.ID + "_" + mod.ID;  					}  				}  			}  			if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  				if (mod2Code.Length == 2) {  					ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  					if (mod != null) {  						ls.ModifierTwoID = mod.ID;  						ls.ID = ls.ID + "_" + mod.ID;  					}  				}  			}  			ls.ID = ls.ID + "_SYM";  			ls.Label = fullLegacyCode;  			// Add the legacy function code  			LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  			lfCode.Name = "2525C";  			if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  				lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  			if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  				lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  			lfCode.Value = functionCode;  			if (status != "")  				lfCode.Description = status;  			if (remarks != "")  				lfCode.Remarks = remarks;  			ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  				lfCode  			};  			// Add it to the current legacy symbol set  			legacySymbols.Add (ls);  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: while (!r.EndOfStream) {  	line = r.ReadLine ();  	string[] tokens = line.Split (''');  	string ssCode = tokens [2];  	string legacyCode = tokens [0];  	string fullLegacyCode = tokens [1];  	string mod1Code = tokens [4];  	string mod2Code = tokens [5];  	string status = tokens [6];  	string remarks = tokens [7];  	// Skip over all rows in the source file that don't match the symbol set code  	// or where the 2525C SIDC field is blank.  	if (ssCode == code && legacyCode != "") {  		// Extract the six character function code from the current 2525C SIDC.  		string functionCode = legacyCode.Substring (legacyCode.Length - 6);  		//string schemaCode = legacyCode.Substring(0' 1);  		//string dimensionCode = legacyCode.Substring(2' 1);  		string entityCode = tokens [3];  		if (entityCode.Length == 6) {  			string eCode = entityCode.Substring (0' 2);  			string etCode = entityCode.Substring (2' 2);  			string estCode = entityCode.Substring (4' 2);  			// Now that we have everything' let's find the pieces in the open symbol set  			SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  			// Find the entity' entity type' and entity subtype for the specified SIDC.  			SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  			if (entity != null) {  				ls.EntityID = entity.ID;  				ls.ID = entity.ID;  				if (etCode != "00") {  					SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  					if (eType != null) {  						ls.EntityTypeID = eType.ID;  						ls.ID = ls.ID + "_" + eType.ID;  						if (estCode != "00") {  							EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  							if (eSubType != null) {  								ls.EntitySubTypeID = eSubType.ID;  								ls.ID = ls.ID + "_" + eSubType.ID;  							}  						}  					}  				}  			}  			// No entities were found' so mark it as retired.  			if (ls.ID == null) {  				ls.ID = "RETIRED";  				ls.Remarks = "Retired";  			}  			// Find the modifier 1 and modifier 2 for the specified SIDC.  			if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  				if (mod1Code.Length == 2) {  					ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  					if (mod != null) {  						ls.ModifierOneID = mod.ID;  						ls.ID = ls.ID + "_" + mod.ID;  					}  				}  			}  			if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  				if (mod2Code.Length == 2) {  					ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  					if (mod != null) {  						ls.ModifierTwoID = mod.ID;  						ls.ID = ls.ID + "_" + mod.ID;  					}  				}  			}  			ls.ID = ls.ID + "_SYM";  			ls.Label = fullLegacyCode;  			// Add the legacy function code  			LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  			lfCode.Name = "2525C";  			if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  				lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  			if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  				lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  			lfCode.Value = functionCode;  			if (status != "")  				lfCode.Description = status;  			if (remarks != "")  				lfCode.Remarks = remarks;  			ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  				lfCode  			};  			// Add it to the current legacy symbol set  			legacySymbols.Add (ls);  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: while (!r.EndOfStream) {  	line = r.ReadLine ();  	string[] tokens = line.Split (''');  	string ssCode = tokens [2];  	string legacyCode = tokens [0];  	string fullLegacyCode = tokens [1];  	string mod1Code = tokens [4];  	string mod2Code = tokens [5];  	string status = tokens [6];  	string remarks = tokens [7];  	// Skip over all rows in the source file that don't match the symbol set code  	// or where the 2525C SIDC field is blank.  	if (ssCode == code && legacyCode != "") {  		// Extract the six character function code from the current 2525C SIDC.  		string functionCode = legacyCode.Substring (legacyCode.Length - 6);  		//string schemaCode = legacyCode.Substring(0' 1);  		//string dimensionCode = legacyCode.Substring(2' 1);  		string entityCode = tokens [3];  		if (entityCode.Length == 6) {  			string eCode = entityCode.Substring (0' 2);  			string etCode = entityCode.Substring (2' 2);  			string estCode = entityCode.Substring (4' 2);  			// Now that we have everything' let's find the pieces in the open symbol set  			SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  			// Find the entity' entity type' and entity subtype for the specified SIDC.  			SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  			if (entity != null) {  				ls.EntityID = entity.ID;  				ls.ID = entity.ID;  				if (etCode != "00") {  					SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  					if (eType != null) {  						ls.EntityTypeID = eType.ID;  						ls.ID = ls.ID + "_" + eType.ID;  						if (estCode != "00") {  							EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  							if (eSubType != null) {  								ls.EntitySubTypeID = eSubType.ID;  								ls.ID = ls.ID + "_" + eSubType.ID;  							}  						}  					}  				}  			}  			// No entities were found' so mark it as retired.  			if (ls.ID == null) {  				ls.ID = "RETIRED";  				ls.Remarks = "Retired";  			}  			// Find the modifier 1 and modifier 2 for the specified SIDC.  			if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  				if (mod1Code.Length == 2) {  					ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  					if (mod != null) {  						ls.ModifierOneID = mod.ID;  						ls.ID = ls.ID + "_" + mod.ID;  					}  				}  			}  			if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  				if (mod2Code.Length == 2) {  					ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  					if (mod != null) {  						ls.ModifierTwoID = mod.ID;  						ls.ID = ls.ID + "_" + mod.ID;  					}  				}  			}  			ls.ID = ls.ID + "_SYM";  			ls.Label = fullLegacyCode;  			// Add the legacy function code  			LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  			lfCode.Name = "2525C";  			if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  				lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  			if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  				lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  			lfCode.Value = functionCode;  			if (status != "")  				lfCode.Description = status;  			if (remarks != "")  				lfCode.Remarks = remarks;  			ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  				lfCode  			};  			// Add it to the current legacy symbol set  			legacySymbols.Add (ls);  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: while (!r.EndOfStream) {  	line = r.ReadLine ();  	string[] tokens = line.Split (''');  	string ssCode = tokens [2];  	string legacyCode = tokens [0];  	string fullLegacyCode = tokens [1];  	string mod1Code = tokens [4];  	string mod2Code = tokens [5];  	string status = tokens [6];  	string remarks = tokens [7];  	// Skip over all rows in the source file that don't match the symbol set code  	// or where the 2525C SIDC field is blank.  	if (ssCode == code && legacyCode != "") {  		// Extract the six character function code from the current 2525C SIDC.  		string functionCode = legacyCode.Substring (legacyCode.Length - 6);  		//string schemaCode = legacyCode.Substring(0' 1);  		//string dimensionCode = legacyCode.Substring(2' 1);  		string entityCode = tokens [3];  		if (entityCode.Length == 6) {  			string eCode = entityCode.Substring (0' 2);  			string etCode = entityCode.Substring (2' 2);  			string estCode = entityCode.Substring (4' 2);  			// Now that we have everything' let's find the pieces in the open symbol set  			SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  			// Find the entity' entity type' and entity subtype for the specified SIDC.  			SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  			if (entity != null) {  				ls.EntityID = entity.ID;  				ls.ID = entity.ID;  				if (etCode != "00") {  					SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  					if (eType != null) {  						ls.EntityTypeID = eType.ID;  						ls.ID = ls.ID + "_" + eType.ID;  						if (estCode != "00") {  							EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  							if (eSubType != null) {  								ls.EntitySubTypeID = eSubType.ID;  								ls.ID = ls.ID + "_" + eSubType.ID;  							}  						}  					}  				}  			}  			// No entities were found' so mark it as retired.  			if (ls.ID == null) {  				ls.ID = "RETIRED";  				ls.Remarks = "Retired";  			}  			// Find the modifier 1 and modifier 2 for the specified SIDC.  			if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  				if (mod1Code.Length == 2) {  					ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  					if (mod != null) {  						ls.ModifierOneID = mod.ID;  						ls.ID = ls.ID + "_" + mod.ID;  					}  				}  			}  			if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  				if (mod2Code.Length == 2) {  					ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  					if (mod != null) {  						ls.ModifierTwoID = mod.ID;  						ls.ID = ls.ID + "_" + mod.ID;  					}  				}  			}  			ls.ID = ls.ID + "_SYM";  			ls.Label = fullLegacyCode;  			// Add the legacy function code  			LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  			lfCode.Name = "2525C";  			if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  				lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  			if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  				lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  			lfCode.Value = functionCode;  			if (status != "")  				lfCode.Description = status;  			if (remarks != "")  				lfCode.Remarks = remarks;  			ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  				lfCode  			};  			// Add it to the current legacy symbol set  			legacySymbols.Add (ls);  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: while (!r.EndOfStream) {  	line = r.ReadLine ();  	string[] tokens = line.Split (''');  	string ssCode = tokens [2];  	string legacyCode = tokens [0];  	string fullLegacyCode = tokens [1];  	string mod1Code = tokens [4];  	string mod2Code = tokens [5];  	string status = tokens [6];  	string remarks = tokens [7];  	// Skip over all rows in the source file that don't match the symbol set code  	// or where the 2525C SIDC field is blank.  	if (ssCode == code && legacyCode != "") {  		// Extract the six character function code from the current 2525C SIDC.  		string functionCode = legacyCode.Substring (legacyCode.Length - 6);  		//string schemaCode = legacyCode.Substring(0' 1);  		//string dimensionCode = legacyCode.Substring(2' 1);  		string entityCode = tokens [3];  		if (entityCode.Length == 6) {  			string eCode = entityCode.Substring (0' 2);  			string etCode = entityCode.Substring (2' 2);  			string estCode = entityCode.Substring (4' 2);  			// Now that we have everything' let's find the pieces in the open symbol set  			SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  			// Find the entity' entity type' and entity subtype for the specified SIDC.  			SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  			if (entity != null) {  				ls.EntityID = entity.ID;  				ls.ID = entity.ID;  				if (etCode != "00") {  					SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  					if (eType != null) {  						ls.EntityTypeID = eType.ID;  						ls.ID = ls.ID + "_" + eType.ID;  						if (estCode != "00") {  							EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  							if (eSubType != null) {  								ls.EntitySubTypeID = eSubType.ID;  								ls.ID = ls.ID + "_" + eSubType.ID;  							}  						}  					}  				}  			}  			// No entities were found' so mark it as retired.  			if (ls.ID == null) {  				ls.ID = "RETIRED";  				ls.Remarks = "Retired";  			}  			// Find the modifier 1 and modifier 2 for the specified SIDC.  			if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  				if (mod1Code.Length == 2) {  					ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  					if (mod != null) {  						ls.ModifierOneID = mod.ID;  						ls.ID = ls.ID + "_" + mod.ID;  					}  				}  			}  			if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  				if (mod2Code.Length == 2) {  					ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  					if (mod != null) {  						ls.ModifierTwoID = mod.ID;  						ls.ID = ls.ID + "_" + mod.ID;  					}  				}  			}  			ls.ID = ls.ID + "_SYM";  			ls.Label = fullLegacyCode;  			// Add the legacy function code  			LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  			lfCode.Name = "2525C";  			if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  				lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  			if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  				lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  			lfCode.Value = functionCode;  			if (status != "")  				lfCode.Description = status;  			if (remarks != "")  				lfCode.Remarks = remarks;  			ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  				lfCode  			};  			// Add it to the current legacy symbol set  			legacySymbols.Add (ls);  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: while (!r.EndOfStream) {  	line = r.ReadLine ();  	string[] tokens = line.Split (''');  	string ssCode = tokens [2];  	string legacyCode = tokens [0];  	string fullLegacyCode = tokens [1];  	string mod1Code = tokens [4];  	string mod2Code = tokens [5];  	string status = tokens [6];  	string remarks = tokens [7];  	// Skip over all rows in the source file that don't match the symbol set code  	// or where the 2525C SIDC field is blank.  	if (ssCode == code && legacyCode != "") {  		// Extract the six character function code from the current 2525C SIDC.  		string functionCode = legacyCode.Substring (legacyCode.Length - 6);  		//string schemaCode = legacyCode.Substring(0' 1);  		//string dimensionCode = legacyCode.Substring(2' 1);  		string entityCode = tokens [3];  		if (entityCode.Length == 6) {  			string eCode = entityCode.Substring (0' 2);  			string etCode = entityCode.Substring (2' 2);  			string estCode = entityCode.Substring (4' 2);  			// Now that we have everything' let's find the pieces in the open symbol set  			SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  			// Find the entity' entity type' and entity subtype for the specified SIDC.  			SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  			if (entity != null) {  				ls.EntityID = entity.ID;  				ls.ID = entity.ID;  				if (etCode != "00") {  					SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  					if (eType != null) {  						ls.EntityTypeID = eType.ID;  						ls.ID = ls.ID + "_" + eType.ID;  						if (estCode != "00") {  							EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  							if (eSubType != null) {  								ls.EntitySubTypeID = eSubType.ID;  								ls.ID = ls.ID + "_" + eSubType.ID;  							}  						}  					}  				}  			}  			// No entities were found' so mark it as retired.  			if (ls.ID == null) {  				ls.ID = "RETIRED";  				ls.Remarks = "Retired";  			}  			// Find the modifier 1 and modifier 2 for the specified SIDC.  			if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  				if (mod1Code.Length == 2) {  					ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  					if (mod != null) {  						ls.ModifierOneID = mod.ID;  						ls.ID = ls.ID + "_" + mod.ID;  					}  				}  			}  			if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  				if (mod2Code.Length == 2) {  					ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  					if (mod != null) {  						ls.ModifierTwoID = mod.ID;  						ls.ID = ls.ID + "_" + mod.ID;  					}  				}  			}  			ls.ID = ls.ID + "_SYM";  			ls.Label = fullLegacyCode;  			// Add the legacy function code  			LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  			lfCode.Name = "2525C";  			if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  				lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  			if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  				lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  			lfCode.Value = functionCode;  			if (status != "")  				lfCode.Description = status;  			if (remarks != "")  				lfCode.Remarks = remarks;  			ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  				lfCode  			};  			// Add it to the current legacy symbol set  			legacySymbols.Add (ls);  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: while (!r.EndOfStream) {  	line = r.ReadLine ();  	string[] tokens = line.Split (''');  	string ssCode = tokens [2];  	string legacyCode = tokens [0];  	string fullLegacyCode = tokens [1];  	string mod1Code = tokens [4];  	string mod2Code = tokens [5];  	string status = tokens [6];  	string remarks = tokens [7];  	// Skip over all rows in the source file that don't match the symbol set code  	// or where the 2525C SIDC field is blank.  	if (ssCode == code && legacyCode != "") {  		// Extract the six character function code from the current 2525C SIDC.  		string functionCode = legacyCode.Substring (legacyCode.Length - 6);  		//string schemaCode = legacyCode.Substring(0' 1);  		//string dimensionCode = legacyCode.Substring(2' 1);  		string entityCode = tokens [3];  		if (entityCode.Length == 6) {  			string eCode = entityCode.Substring (0' 2);  			string etCode = entityCode.Substring (2' 2);  			string estCode = entityCode.Substring (4' 2);  			// Now that we have everything' let's find the pieces in the open symbol set  			SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  			// Find the entity' entity type' and entity subtype for the specified SIDC.  			SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  			if (entity != null) {  				ls.EntityID = entity.ID;  				ls.ID = entity.ID;  				if (etCode != "00") {  					SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  					if (eType != null) {  						ls.EntityTypeID = eType.ID;  						ls.ID = ls.ID + "_" + eType.ID;  						if (estCode != "00") {  							EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  							if (eSubType != null) {  								ls.EntitySubTypeID = eSubType.ID;  								ls.ID = ls.ID + "_" + eSubType.ID;  							}  						}  					}  				}  			}  			// No entities were found' so mark it as retired.  			if (ls.ID == null) {  				ls.ID = "RETIRED";  				ls.Remarks = "Retired";  			}  			// Find the modifier 1 and modifier 2 for the specified SIDC.  			if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  				if (mod1Code.Length == 2) {  					ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  					if (mod != null) {  						ls.ModifierOneID = mod.ID;  						ls.ID = ls.ID + "_" + mod.ID;  					}  				}  			}  			if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  				if (mod2Code.Length == 2) {  					ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  					if (mod != null) {  						ls.ModifierTwoID = mod.ID;  						ls.ID = ls.ID + "_" + mod.ID;  					}  				}  			}  			ls.ID = ls.ID + "_SYM";  			ls.Label = fullLegacyCode;  			// Add the legacy function code  			LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  			lfCode.Name = "2525C";  			if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  				lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  			if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  				lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  			lfCode.Value = functionCode;  			if (status != "")  				lfCode.Description = status;  			if (remarks != "")  				lfCode.Remarks = remarks;  			ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  				lfCode  			};  			// Add it to the current legacy symbol set  			legacySymbols.Add (ls);  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (ssCode == code && legacyCode != "") {  	// Extract the six character function code from the current 2525C SIDC.  	string functionCode = legacyCode.Substring (legacyCode.Length - 6);  	//string schemaCode = legacyCode.Substring(0' 1);  	//string dimensionCode = legacyCode.Substring(2' 1);  	string entityCode = tokens [3];  	if (entityCode.Length == 6) {  		string eCode = entityCode.Substring (0' 2);  		string etCode = entityCode.Substring (2' 2);  		string estCode = entityCode.Substring (4' 2);  		// Now that we have everything' let's find the pieces in the open symbol set  		SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  		// Find the entity' entity type' and entity subtype for the specified SIDC.  		SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  		if (entity != null) {  			ls.EntityID = entity.ID;  			ls.ID = entity.ID;  			if (etCode != "00") {  				SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  				if (eType != null) {  					ls.EntityTypeID = eType.ID;  					ls.ID = ls.ID + "_" + eType.ID;  					if (estCode != "00") {  						EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  						if (eSubType != null) {  							ls.EntitySubTypeID = eSubType.ID;  							ls.ID = ls.ID + "_" + eSubType.ID;  						}  					}  				}  			}  		}  		// No entities were found' so mark it as retired.  		if (ls.ID == null) {  			ls.ID = "RETIRED";  			ls.Remarks = "Retired";  		}  		// Find the modifier 1 and modifier 2 for the specified SIDC.  		if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  			if (mod1Code.Length == 2) {  				ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  				if (mod != null) {  					ls.ModifierOneID = mod.ID;  					ls.ID = ls.ID + "_" + mod.ID;  				}  			}  		}  		if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  			if (mod2Code.Length == 2) {  				ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  				if (mod != null) {  					ls.ModifierTwoID = mod.ID;  					ls.ID = ls.ID + "_" + mod.ID;  				}  			}  		}  		ls.ID = ls.ID + "_SYM";  		ls.Label = fullLegacyCode;  		// Add the legacy function code  		LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  		lfCode.Name = "2525C";  		if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  			lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  		if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  			lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  		lfCode.Value = functionCode;  		if (status != "")  			lfCode.Description = status;  		if (remarks != "")  			lfCode.Remarks = remarks;  		ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  			lfCode  		};  		// Add it to the current legacy symbol set  		legacySymbols.Add (ls);  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (ssCode == code && legacyCode != "") {  	// Extract the six character function code from the current 2525C SIDC.  	string functionCode = legacyCode.Substring (legacyCode.Length - 6);  	//string schemaCode = legacyCode.Substring(0' 1);  	//string dimensionCode = legacyCode.Substring(2' 1);  	string entityCode = tokens [3];  	if (entityCode.Length == 6) {  		string eCode = entityCode.Substring (0' 2);  		string etCode = entityCode.Substring (2' 2);  		string estCode = entityCode.Substring (4' 2);  		// Now that we have everything' let's find the pieces in the open symbol set  		SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  		// Find the entity' entity type' and entity subtype for the specified SIDC.  		SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  		if (entity != null) {  			ls.EntityID = entity.ID;  			ls.ID = entity.ID;  			if (etCode != "00") {  				SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  				if (eType != null) {  					ls.EntityTypeID = eType.ID;  					ls.ID = ls.ID + "_" + eType.ID;  					if (estCode != "00") {  						EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  						if (eSubType != null) {  							ls.EntitySubTypeID = eSubType.ID;  							ls.ID = ls.ID + "_" + eSubType.ID;  						}  					}  				}  			}  		}  		// No entities were found' so mark it as retired.  		if (ls.ID == null) {  			ls.ID = "RETIRED";  			ls.Remarks = "Retired";  		}  		// Find the modifier 1 and modifier 2 for the specified SIDC.  		if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  			if (mod1Code.Length == 2) {  				ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  				if (mod != null) {  					ls.ModifierOneID = mod.ID;  					ls.ID = ls.ID + "_" + mod.ID;  				}  			}  		}  		if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  			if (mod2Code.Length == 2) {  				ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  				if (mod != null) {  					ls.ModifierTwoID = mod.ID;  					ls.ID = ls.ID + "_" + mod.ID;  				}  			}  		}  		ls.ID = ls.ID + "_SYM";  		ls.Label = fullLegacyCode;  		// Add the legacy function code  		LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  		lfCode.Name = "2525C";  		if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  			lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  		if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  			lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  		lfCode.Value = functionCode;  		if (status != "")  			lfCode.Description = status;  		if (remarks != "")  			lfCode.Remarks = remarks;  		ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  			lfCode  		};  		// Add it to the current legacy symbol set  		legacySymbols.Add (ls);  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (ssCode == code && legacyCode != "") {  	// Extract the six character function code from the current 2525C SIDC.  	string functionCode = legacyCode.Substring (legacyCode.Length - 6);  	//string schemaCode = legacyCode.Substring(0' 1);  	//string dimensionCode = legacyCode.Substring(2' 1);  	string entityCode = tokens [3];  	if (entityCode.Length == 6) {  		string eCode = entityCode.Substring (0' 2);  		string etCode = entityCode.Substring (2' 2);  		string estCode = entityCode.Substring (4' 2);  		// Now that we have everything' let's find the pieces in the open symbol set  		SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  		// Find the entity' entity type' and entity subtype for the specified SIDC.  		SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  		if (entity != null) {  			ls.EntityID = entity.ID;  			ls.ID = entity.ID;  			if (etCode != "00") {  				SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  				if (eType != null) {  					ls.EntityTypeID = eType.ID;  					ls.ID = ls.ID + "_" + eType.ID;  					if (estCode != "00") {  						EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  						if (eSubType != null) {  							ls.EntitySubTypeID = eSubType.ID;  							ls.ID = ls.ID + "_" + eSubType.ID;  						}  					}  				}  			}  		}  		// No entities were found' so mark it as retired.  		if (ls.ID == null) {  			ls.ID = "RETIRED";  			ls.Remarks = "Retired";  		}  		// Find the modifier 1 and modifier 2 for the specified SIDC.  		if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  			if (mod1Code.Length == 2) {  				ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  				if (mod != null) {  					ls.ModifierOneID = mod.ID;  					ls.ID = ls.ID + "_" + mod.ID;  				}  			}  		}  		if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  			if (mod2Code.Length == 2) {  				ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  				if (mod != null) {  					ls.ModifierTwoID = mod.ID;  					ls.ID = ls.ID + "_" + mod.ID;  				}  			}  		}  		ls.ID = ls.ID + "_SYM";  		ls.Label = fullLegacyCode;  		// Add the legacy function code  		LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  		lfCode.Name = "2525C";  		if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  			lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  		if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  			lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  		lfCode.Value = functionCode;  		if (status != "")  			lfCode.Description = status;  		if (remarks != "")  			lfCode.Remarks = remarks;  		ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  			lfCode  		};  		// Add it to the current legacy symbol set  		legacySymbols.Add (ls);  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (ssCode == code && legacyCode != "") {  	// Extract the six character function code from the current 2525C SIDC.  	string functionCode = legacyCode.Substring (legacyCode.Length - 6);  	//string schemaCode = legacyCode.Substring(0' 1);  	//string dimensionCode = legacyCode.Substring(2' 1);  	string entityCode = tokens [3];  	if (entityCode.Length == 6) {  		string eCode = entityCode.Substring (0' 2);  		string etCode = entityCode.Substring (2' 2);  		string estCode = entityCode.Substring (4' 2);  		// Now that we have everything' let's find the pieces in the open symbol set  		SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  		// Find the entity' entity type' and entity subtype for the specified SIDC.  		SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  		if (entity != null) {  			ls.EntityID = entity.ID;  			ls.ID = entity.ID;  			if (etCode != "00") {  				SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  				if (eType != null) {  					ls.EntityTypeID = eType.ID;  					ls.ID = ls.ID + "_" + eType.ID;  					if (estCode != "00") {  						EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  						if (eSubType != null) {  							ls.EntitySubTypeID = eSubType.ID;  							ls.ID = ls.ID + "_" + eSubType.ID;  						}  					}  				}  			}  		}  		// No entities were found' so mark it as retired.  		if (ls.ID == null) {  			ls.ID = "RETIRED";  			ls.Remarks = "Retired";  		}  		// Find the modifier 1 and modifier 2 for the specified SIDC.  		if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  			if (mod1Code.Length == 2) {  				ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  				if (mod != null) {  					ls.ModifierOneID = mod.ID;  					ls.ID = ls.ID + "_" + mod.ID;  				}  			}  		}  		if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  			if (mod2Code.Length == 2) {  				ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  				if (mod != null) {  					ls.ModifierTwoID = mod.ID;  					ls.ID = ls.ID + "_" + mod.ID;  				}  			}  		}  		ls.ID = ls.ID + "_SYM";  		ls.Label = fullLegacyCode;  		// Add the legacy function code  		LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  		lfCode.Name = "2525C";  		if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  			lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  		if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  			lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  		lfCode.Value = functionCode;  		if (status != "")  			lfCode.Description = status;  		if (remarks != "")  			lfCode.Remarks = remarks;  		ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  			lfCode  		};  		// Add it to the current legacy symbol set  		legacySymbols.Add (ls);  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (ssCode == code && legacyCode != "") {  	// Extract the six character function code from the current 2525C SIDC.  	string functionCode = legacyCode.Substring (legacyCode.Length - 6);  	//string schemaCode = legacyCode.Substring(0' 1);  	//string dimensionCode = legacyCode.Substring(2' 1);  	string entityCode = tokens [3];  	if (entityCode.Length == 6) {  		string eCode = entityCode.Substring (0' 2);  		string etCode = entityCode.Substring (2' 2);  		string estCode = entityCode.Substring (4' 2);  		// Now that we have everything' let's find the pieces in the open symbol set  		SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  		// Find the entity' entity type' and entity subtype for the specified SIDC.  		SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  		if (entity != null) {  			ls.EntityID = entity.ID;  			ls.ID = entity.ID;  			if (etCode != "00") {  				SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  				if (eType != null) {  					ls.EntityTypeID = eType.ID;  					ls.ID = ls.ID + "_" + eType.ID;  					if (estCode != "00") {  						EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  						if (eSubType != null) {  							ls.EntitySubTypeID = eSubType.ID;  							ls.ID = ls.ID + "_" + eSubType.ID;  						}  					}  				}  			}  		}  		// No entities were found' so mark it as retired.  		if (ls.ID == null) {  			ls.ID = "RETIRED";  			ls.Remarks = "Retired";  		}  		// Find the modifier 1 and modifier 2 for the specified SIDC.  		if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  			if (mod1Code.Length == 2) {  				ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  				if (mod != null) {  					ls.ModifierOneID = mod.ID;  					ls.ID = ls.ID + "_" + mod.ID;  				}  			}  		}  		if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  			if (mod2Code.Length == 2) {  				ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  				if (mod != null) {  					ls.ModifierTwoID = mod.ID;  					ls.ID = ls.ID + "_" + mod.ID;  				}  			}  		}  		ls.ID = ls.ID + "_SYM";  		ls.Label = fullLegacyCode;  		// Add the legacy function code  		LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  		lfCode.Name = "2525C";  		if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  			lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  		if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  			lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  		lfCode.Value = functionCode;  		if (status != "")  			lfCode.Description = status;  		if (remarks != "")  			lfCode.Remarks = remarks;  		ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  			lfCode  		};  		// Add it to the current legacy symbol set  		legacySymbols.Add (ls);  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (ssCode == code && legacyCode != "") {  	// Extract the six character function code from the current 2525C SIDC.  	string functionCode = legacyCode.Substring (legacyCode.Length - 6);  	//string schemaCode = legacyCode.Substring(0' 1);  	//string dimensionCode = legacyCode.Substring(2' 1);  	string entityCode = tokens [3];  	if (entityCode.Length == 6) {  		string eCode = entityCode.Substring (0' 2);  		string etCode = entityCode.Substring (2' 2);  		string estCode = entityCode.Substring (4' 2);  		// Now that we have everything' let's find the pieces in the open symbol set  		SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  		// Find the entity' entity type' and entity subtype for the specified SIDC.  		SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  		if (entity != null) {  			ls.EntityID = entity.ID;  			ls.ID = entity.ID;  			if (etCode != "00") {  				SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  				if (eType != null) {  					ls.EntityTypeID = eType.ID;  					ls.ID = ls.ID + "_" + eType.ID;  					if (estCode != "00") {  						EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  						if (eSubType != null) {  							ls.EntitySubTypeID = eSubType.ID;  							ls.ID = ls.ID + "_" + eSubType.ID;  						}  					}  				}  			}  		}  		// No entities were found' so mark it as retired.  		if (ls.ID == null) {  			ls.ID = "RETIRED";  			ls.Remarks = "Retired";  		}  		// Find the modifier 1 and modifier 2 for the specified SIDC.  		if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  			if (mod1Code.Length == 2) {  				ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  				if (mod != null) {  					ls.ModifierOneID = mod.ID;  					ls.ID = ls.ID + "_" + mod.ID;  				}  			}  		}  		if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  			if (mod2Code.Length == 2) {  				ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  				if (mod != null) {  					ls.ModifierTwoID = mod.ID;  					ls.ID = ls.ID + "_" + mod.ID;  				}  			}  		}  		ls.ID = ls.ID + "_SYM";  		ls.Label = fullLegacyCode;  		// Add the legacy function code  		LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  		lfCode.Name = "2525C";  		if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  			lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  		if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  			lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  		lfCode.Value = functionCode;  		if (status != "")  			lfCode.Description = status;  		if (remarks != "")  			lfCode.Remarks = remarks;  		ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  			lfCode  		};  		// Add it to the current legacy symbol set  		legacySymbols.Add (ls);  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (ssCode == code && legacyCode != "") {  	// Extract the six character function code from the current 2525C SIDC.  	string functionCode = legacyCode.Substring (legacyCode.Length - 6);  	//string schemaCode = legacyCode.Substring(0' 1);  	//string dimensionCode = legacyCode.Substring(2' 1);  	string entityCode = tokens [3];  	if (entityCode.Length == 6) {  		string eCode = entityCode.Substring (0' 2);  		string etCode = entityCode.Substring (2' 2);  		string estCode = entityCode.Substring (4' 2);  		// Now that we have everything' let's find the pieces in the open symbol set  		SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  		// Find the entity' entity type' and entity subtype for the specified SIDC.  		SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  		if (entity != null) {  			ls.EntityID = entity.ID;  			ls.ID = entity.ID;  			if (etCode != "00") {  				SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  				if (eType != null) {  					ls.EntityTypeID = eType.ID;  					ls.ID = ls.ID + "_" + eType.ID;  					if (estCode != "00") {  						EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  						if (eSubType != null) {  							ls.EntitySubTypeID = eSubType.ID;  							ls.ID = ls.ID + "_" + eSubType.ID;  						}  					}  				}  			}  		}  		// No entities were found' so mark it as retired.  		if (ls.ID == null) {  			ls.ID = "RETIRED";  			ls.Remarks = "Retired";  		}  		// Find the modifier 1 and modifier 2 for the specified SIDC.  		if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  			if (mod1Code.Length == 2) {  				ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  				if (mod != null) {  					ls.ModifierOneID = mod.ID;  					ls.ID = ls.ID + "_" + mod.ID;  				}  			}  		}  		if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  			if (mod2Code.Length == 2) {  				ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  				if (mod != null) {  					ls.ModifierTwoID = mod.ID;  					ls.ID = ls.ID + "_" + mod.ID;  				}  			}  		}  		ls.ID = ls.ID + "_SYM";  		ls.Label = fullLegacyCode;  		// Add the legacy function code  		LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  		lfCode.Name = "2525C";  		if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  			lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  		if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  			lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  		lfCode.Value = functionCode;  		if (status != "")  			lfCode.Description = status;  		if (remarks != "")  			lfCode.Remarks = remarks;  		ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  			lfCode  		};  		// Add it to the current legacy symbol set  		legacySymbols.Add (ls);  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (ssCode == code && legacyCode != "") {  	// Extract the six character function code from the current 2525C SIDC.  	string functionCode = legacyCode.Substring (legacyCode.Length - 6);  	//string schemaCode = legacyCode.Substring(0' 1);  	//string dimensionCode = legacyCode.Substring(2' 1);  	string entityCode = tokens [3];  	if (entityCode.Length == 6) {  		string eCode = entityCode.Substring (0' 2);  		string etCode = entityCode.Substring (2' 2);  		string estCode = entityCode.Substring (4' 2);  		// Now that we have everything' let's find the pieces in the open symbol set  		SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  		// Find the entity' entity type' and entity subtype for the specified SIDC.  		SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  		if (entity != null) {  			ls.EntityID = entity.ID;  			ls.ID = entity.ID;  			if (etCode != "00") {  				SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  				if (eType != null) {  					ls.EntityTypeID = eType.ID;  					ls.ID = ls.ID + "_" + eType.ID;  					if (estCode != "00") {  						EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  						if (eSubType != null) {  							ls.EntitySubTypeID = eSubType.ID;  							ls.ID = ls.ID + "_" + eSubType.ID;  						}  					}  				}  			}  		}  		// No entities were found' so mark it as retired.  		if (ls.ID == null) {  			ls.ID = "RETIRED";  			ls.Remarks = "Retired";  		}  		// Find the modifier 1 and modifier 2 for the specified SIDC.  		if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  			if (mod1Code.Length == 2) {  				ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  				if (mod != null) {  					ls.ModifierOneID = mod.ID;  					ls.ID = ls.ID + "_" + mod.ID;  				}  			}  		}  		if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  			if (mod2Code.Length == 2) {  				ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  				if (mod != null) {  					ls.ModifierTwoID = mod.ID;  					ls.ID = ls.ID + "_" + mod.ID;  				}  			}  		}  		ls.ID = ls.ID + "_SYM";  		ls.Label = fullLegacyCode;  		// Add the legacy function code  		LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  		lfCode.Name = "2525C";  		if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  			lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  		if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  			lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  		lfCode.Value = functionCode;  		if (status != "")  			lfCode.Description = status;  		if (remarks != "")  			lfCode.Remarks = remarks;  		ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  			lfCode  		};  		// Add it to the current legacy symbol set  		legacySymbols.Add (ls);  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (ssCode == code && legacyCode != "") {  	// Extract the six character function code from the current 2525C SIDC.  	string functionCode = legacyCode.Substring (legacyCode.Length - 6);  	//string schemaCode = legacyCode.Substring(0' 1);  	//string dimensionCode = legacyCode.Substring(2' 1);  	string entityCode = tokens [3];  	if (entityCode.Length == 6) {  		string eCode = entityCode.Substring (0' 2);  		string etCode = entityCode.Substring (2' 2);  		string estCode = entityCode.Substring (4' 2);  		// Now that we have everything' let's find the pieces in the open symbol set  		SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  		// Find the entity' entity type' and entity subtype for the specified SIDC.  		SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  		if (entity != null) {  			ls.EntityID = entity.ID;  			ls.ID = entity.ID;  			if (etCode != "00") {  				SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  				if (eType != null) {  					ls.EntityTypeID = eType.ID;  					ls.ID = ls.ID + "_" + eType.ID;  					if (estCode != "00") {  						EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  						if (eSubType != null) {  							ls.EntitySubTypeID = eSubType.ID;  							ls.ID = ls.ID + "_" + eSubType.ID;  						}  					}  				}  			}  		}  		// No entities were found' so mark it as retired.  		if (ls.ID == null) {  			ls.ID = "RETIRED";  			ls.Remarks = "Retired";  		}  		// Find the modifier 1 and modifier 2 for the specified SIDC.  		if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  			if (mod1Code.Length == 2) {  				ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  				if (mod != null) {  					ls.ModifierOneID = mod.ID;  					ls.ID = ls.ID + "_" + mod.ID;  				}  			}  		}  		if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  			if (mod2Code.Length == 2) {  				ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  				if (mod != null) {  					ls.ModifierTwoID = mod.ID;  					ls.ID = ls.ID + "_" + mod.ID;  				}  			}  		}  		ls.ID = ls.ID + "_SYM";  		ls.Label = fullLegacyCode;  		// Add the legacy function code  		LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  		lfCode.Name = "2525C";  		if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  			lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  		if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  			lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  		lfCode.Value = functionCode;  		if (status != "")  			lfCode.Description = status;  		if (remarks != "")  			lfCode.Remarks = remarks;  		ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  			lfCode  		};  		// Add it to the current legacy symbol set  		legacySymbols.Add (ls);  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (ssCode == code && legacyCode != "") {  	// Extract the six character function code from the current 2525C SIDC.  	string functionCode = legacyCode.Substring (legacyCode.Length - 6);  	//string schemaCode = legacyCode.Substring(0' 1);  	//string dimensionCode = legacyCode.Substring(2' 1);  	string entityCode = tokens [3];  	if (entityCode.Length == 6) {  		string eCode = entityCode.Substring (0' 2);  		string etCode = entityCode.Substring (2' 2);  		string estCode = entityCode.Substring (4' 2);  		// Now that we have everything' let's find the pieces in the open symbol set  		SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  		// Find the entity' entity type' and entity subtype for the specified SIDC.  		SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  		if (entity != null) {  			ls.EntityID = entity.ID;  			ls.ID = entity.ID;  			if (etCode != "00") {  				SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  				if (eType != null) {  					ls.EntityTypeID = eType.ID;  					ls.ID = ls.ID + "_" + eType.ID;  					if (estCode != "00") {  						EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  						if (eSubType != null) {  							ls.EntitySubTypeID = eSubType.ID;  							ls.ID = ls.ID + "_" + eSubType.ID;  						}  					}  				}  			}  		}  		// No entities were found' so mark it as retired.  		if (ls.ID == null) {  			ls.ID = "RETIRED";  			ls.Remarks = "Retired";  		}  		// Find the modifier 1 and modifier 2 for the specified SIDC.  		if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  			if (mod1Code.Length == 2) {  				ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  				if (mod != null) {  					ls.ModifierOneID = mod.ID;  					ls.ID = ls.ID + "_" + mod.ID;  				}  			}  		}  		if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  			if (mod2Code.Length == 2) {  				ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  				if (mod != null) {  					ls.ModifierTwoID = mod.ID;  					ls.ID = ls.ID + "_" + mod.ID;  				}  			}  		}  		ls.ID = ls.ID + "_SYM";  		ls.Label = fullLegacyCode;  		// Add the legacy function code  		LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  		lfCode.Name = "2525C";  		if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  			lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  		if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  			lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  		lfCode.Value = functionCode;  		if (status != "")  			lfCode.Description = status;  		if (remarks != "")  			lfCode.Remarks = remarks;  		ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  			lfCode  		};  		// Add it to the current legacy symbol set  		legacySymbols.Add (ls);  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (ssCode == code && legacyCode != "") {  	// Extract the six character function code from the current 2525C SIDC.  	string functionCode = legacyCode.Substring (legacyCode.Length - 6);  	//string schemaCode = legacyCode.Substring(0' 1);  	//string dimensionCode = legacyCode.Substring(2' 1);  	string entityCode = tokens [3];  	if (entityCode.Length == 6) {  		string eCode = entityCode.Substring (0' 2);  		string etCode = entityCode.Substring (2' 2);  		string estCode = entityCode.Substring (4' 2);  		// Now that we have everything' let's find the pieces in the open symbol set  		SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  		// Find the entity' entity type' and entity subtype for the specified SIDC.  		SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  		if (entity != null) {  			ls.EntityID = entity.ID;  			ls.ID = entity.ID;  			if (etCode != "00") {  				SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  				if (eType != null) {  					ls.EntityTypeID = eType.ID;  					ls.ID = ls.ID + "_" + eType.ID;  					if (estCode != "00") {  						EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  						if (eSubType != null) {  							ls.EntitySubTypeID = eSubType.ID;  							ls.ID = ls.ID + "_" + eSubType.ID;  						}  					}  				}  			}  		}  		// No entities were found' so mark it as retired.  		if (ls.ID == null) {  			ls.ID = "RETIRED";  			ls.Remarks = "Retired";  		}  		// Find the modifier 1 and modifier 2 for the specified SIDC.  		if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  			if (mod1Code.Length == 2) {  				ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  				if (mod != null) {  					ls.ModifierOneID = mod.ID;  					ls.ID = ls.ID + "_" + mod.ID;  				}  			}  		}  		if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  			if (mod2Code.Length == 2) {  				ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  				if (mod != null) {  					ls.ModifierTwoID = mod.ID;  					ls.ID = ls.ID + "_" + mod.ID;  				}  			}  		}  		ls.ID = ls.ID + "_SYM";  		ls.Label = fullLegacyCode;  		// Add the legacy function code  		LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  		lfCode.Name = "2525C";  		if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  			lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  		if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  			lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  		lfCode.Value = functionCode;  		if (status != "")  			lfCode.Description = status;  		if (remarks != "")  			lfCode.Remarks = remarks;  		ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  			lfCode  		};  		// Add it to the current legacy symbol set  		legacySymbols.Add (ls);  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (ssCode == code && legacyCode != "") {  	// Extract the six character function code from the current 2525C SIDC.  	string functionCode = legacyCode.Substring (legacyCode.Length - 6);  	//string schemaCode = legacyCode.Substring(0' 1);  	//string dimensionCode = legacyCode.Substring(2' 1);  	string entityCode = tokens [3];  	if (entityCode.Length == 6) {  		string eCode = entityCode.Substring (0' 2);  		string etCode = entityCode.Substring (2' 2);  		string estCode = entityCode.Substring (4' 2);  		// Now that we have everything' let's find the pieces in the open symbol set  		SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  		// Find the entity' entity type' and entity subtype for the specified SIDC.  		SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  		if (entity != null) {  			ls.EntityID = entity.ID;  			ls.ID = entity.ID;  			if (etCode != "00") {  				SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  				if (eType != null) {  					ls.EntityTypeID = eType.ID;  					ls.ID = ls.ID + "_" + eType.ID;  					if (estCode != "00") {  						EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  						if (eSubType != null) {  							ls.EntitySubTypeID = eSubType.ID;  							ls.ID = ls.ID + "_" + eSubType.ID;  						}  					}  				}  			}  		}  		// No entities were found' so mark it as retired.  		if (ls.ID == null) {  			ls.ID = "RETIRED";  			ls.Remarks = "Retired";  		}  		// Find the modifier 1 and modifier 2 for the specified SIDC.  		if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  			if (mod1Code.Length == 2) {  				ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  				if (mod != null) {  					ls.ModifierOneID = mod.ID;  					ls.ID = ls.ID + "_" + mod.ID;  				}  			}  		}  		if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  			if (mod2Code.Length == 2) {  				ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  				if (mod != null) {  					ls.ModifierTwoID = mod.ID;  					ls.ID = ls.ID + "_" + mod.ID;  				}  			}  		}  		ls.ID = ls.ID + "_SYM";  		ls.Label = fullLegacyCode;  		// Add the legacy function code  		LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  		lfCode.Name = "2525C";  		if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  			lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  		if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  			lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  		lfCode.Value = functionCode;  		if (status != "")  			lfCode.Description = status;  		if (remarks != "")  			lfCode.Remarks = remarks;  		ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  			lfCode  		};  		// Add it to the current legacy symbol set  		legacySymbols.Add (ls);  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (entityCode.Length == 6) {  	string eCode = entityCode.Substring (0' 2);  	string etCode = entityCode.Substring (2' 2);  	string estCode = entityCode.Substring (4' 2);  	// Now that we have everything' let's find the pieces in the open symbol set  	SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  	// Find the entity' entity type' and entity subtype for the specified SIDC.  	SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  	if (entity != null) {  		ls.EntityID = entity.ID;  		ls.ID = entity.ID;  		if (etCode != "00") {  			SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  			if (eType != null) {  				ls.EntityTypeID = eType.ID;  				ls.ID = ls.ID + "_" + eType.ID;  				if (estCode != "00") {  					EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  					if (eSubType != null) {  						ls.EntitySubTypeID = eSubType.ID;  						ls.ID = ls.ID + "_" + eSubType.ID;  					}  				}  			}  		}  	}  	// No entities were found' so mark it as retired.  	if (ls.ID == null) {  		ls.ID = "RETIRED";  		ls.Remarks = "Retired";  	}  	// Find the modifier 1 and modifier 2 for the specified SIDC.  	if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  		if (mod1Code.Length == 2) {  			ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  			if (mod != null) {  				ls.ModifierOneID = mod.ID;  				ls.ID = ls.ID + "_" + mod.ID;  			}  		}  	}  	if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  		if (mod2Code.Length == 2) {  			ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  			if (mod != null) {  				ls.ModifierTwoID = mod.ID;  				ls.ID = ls.ID + "_" + mod.ID;  			}  		}  	}  	ls.ID = ls.ID + "_SYM";  	ls.Label = fullLegacyCode;  	// Add the legacy function code  	LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  	lfCode.Name = "2525C";  	if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  		lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  	if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  		lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  	lfCode.Value = functionCode;  	if (status != "")  		lfCode.Description = status;  	if (remarks != "")  		lfCode.Remarks = remarks;  	ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  		lfCode  	};  	// Add it to the current legacy symbol set  	legacySymbols.Add (ls);  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (entityCode.Length == 6) {  	string eCode = entityCode.Substring (0' 2);  	string etCode = entityCode.Substring (2' 2);  	string estCode = entityCode.Substring (4' 2);  	// Now that we have everything' let's find the pieces in the open symbol set  	SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  	// Find the entity' entity type' and entity subtype for the specified SIDC.  	SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  	if (entity != null) {  		ls.EntityID = entity.ID;  		ls.ID = entity.ID;  		if (etCode != "00") {  			SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  			if (eType != null) {  				ls.EntityTypeID = eType.ID;  				ls.ID = ls.ID + "_" + eType.ID;  				if (estCode != "00") {  					EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  					if (eSubType != null) {  						ls.EntitySubTypeID = eSubType.ID;  						ls.ID = ls.ID + "_" + eSubType.ID;  					}  				}  			}  		}  	}  	// No entities were found' so mark it as retired.  	if (ls.ID == null) {  		ls.ID = "RETIRED";  		ls.Remarks = "Retired";  	}  	// Find the modifier 1 and modifier 2 for the specified SIDC.  	if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  		if (mod1Code.Length == 2) {  			ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  			if (mod != null) {  				ls.ModifierOneID = mod.ID;  				ls.ID = ls.ID + "_" + mod.ID;  			}  		}  	}  	if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  		if (mod2Code.Length == 2) {  			ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  			if (mod != null) {  				ls.ModifierTwoID = mod.ID;  				ls.ID = ls.ID + "_" + mod.ID;  			}  		}  	}  	ls.ID = ls.ID + "_SYM";  	ls.Label = fullLegacyCode;  	// Add the legacy function code  	LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  	lfCode.Name = "2525C";  	if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  		lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  	if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  		lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  	lfCode.Value = functionCode;  	if (status != "")  		lfCode.Description = status;  	if (remarks != "")  		lfCode.Remarks = remarks;  	ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  		lfCode  	};  	// Add it to the current legacy symbol set  	legacySymbols.Add (ls);  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (entityCode.Length == 6) {  	string eCode = entityCode.Substring (0' 2);  	string etCode = entityCode.Substring (2' 2);  	string estCode = entityCode.Substring (4' 2);  	// Now that we have everything' let's find the pieces in the open symbol set  	SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  	// Find the entity' entity type' and entity subtype for the specified SIDC.  	SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  	if (entity != null) {  		ls.EntityID = entity.ID;  		ls.ID = entity.ID;  		if (etCode != "00") {  			SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  			if (eType != null) {  				ls.EntityTypeID = eType.ID;  				ls.ID = ls.ID + "_" + eType.ID;  				if (estCode != "00") {  					EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  					if (eSubType != null) {  						ls.EntitySubTypeID = eSubType.ID;  						ls.ID = ls.ID + "_" + eSubType.ID;  					}  				}  			}  		}  	}  	// No entities were found' so mark it as retired.  	if (ls.ID == null) {  		ls.ID = "RETIRED";  		ls.Remarks = "Retired";  	}  	// Find the modifier 1 and modifier 2 for the specified SIDC.  	if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  		if (mod1Code.Length == 2) {  			ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  			if (mod != null) {  				ls.ModifierOneID = mod.ID;  				ls.ID = ls.ID + "_" + mod.ID;  			}  		}  	}  	if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  		if (mod2Code.Length == 2) {  			ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  			if (mod != null) {  				ls.ModifierTwoID = mod.ID;  				ls.ID = ls.ID + "_" + mod.ID;  			}  		}  	}  	ls.ID = ls.ID + "_SYM";  	ls.Label = fullLegacyCode;  	// Add the legacy function code  	LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  	lfCode.Name = "2525C";  	if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  		lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  	if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  		lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  	lfCode.Value = functionCode;  	if (status != "")  		lfCode.Description = status;  	if (remarks != "")  		lfCode.Remarks = remarks;  	ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  		lfCode  	};  	// Add it to the current legacy symbol set  	legacySymbols.Add (ls);  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (entityCode.Length == 6) {  	string eCode = entityCode.Substring (0' 2);  	string etCode = entityCode.Substring (2' 2);  	string estCode = entityCode.Substring (4' 2);  	// Now that we have everything' let's find the pieces in the open symbol set  	SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  	// Find the entity' entity type' and entity subtype for the specified SIDC.  	SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  	if (entity != null) {  		ls.EntityID = entity.ID;  		ls.ID = entity.ID;  		if (etCode != "00") {  			SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  			if (eType != null) {  				ls.EntityTypeID = eType.ID;  				ls.ID = ls.ID + "_" + eType.ID;  				if (estCode != "00") {  					EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  					if (eSubType != null) {  						ls.EntitySubTypeID = eSubType.ID;  						ls.ID = ls.ID + "_" + eSubType.ID;  					}  				}  			}  		}  	}  	// No entities were found' so mark it as retired.  	if (ls.ID == null) {  		ls.ID = "RETIRED";  		ls.Remarks = "Retired";  	}  	// Find the modifier 1 and modifier 2 for the specified SIDC.  	if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  		if (mod1Code.Length == 2) {  			ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  			if (mod != null) {  				ls.ModifierOneID = mod.ID;  				ls.ID = ls.ID + "_" + mod.ID;  			}  		}  	}  	if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  		if (mod2Code.Length == 2) {  			ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  			if (mod != null) {  				ls.ModifierTwoID = mod.ID;  				ls.ID = ls.ID + "_" + mod.ID;  			}  		}  	}  	ls.ID = ls.ID + "_SYM";  	ls.Label = fullLegacyCode;  	// Add the legacy function code  	LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  	lfCode.Name = "2525C";  	if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  		lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  	if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  		lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  	lfCode.Value = functionCode;  	if (status != "")  		lfCode.Description = status;  	if (remarks != "")  		lfCode.Remarks = remarks;  	ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  		lfCode  	};  	// Add it to the current legacy symbol set  	legacySymbols.Add (ls);  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (entityCode.Length == 6) {  	string eCode = entityCode.Substring (0' 2);  	string etCode = entityCode.Substring (2' 2);  	string estCode = entityCode.Substring (4' 2);  	// Now that we have everything' let's find the pieces in the open symbol set  	SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  	// Find the entity' entity type' and entity subtype for the specified SIDC.  	SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  	if (entity != null) {  		ls.EntityID = entity.ID;  		ls.ID = entity.ID;  		if (etCode != "00") {  			SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  			if (eType != null) {  				ls.EntityTypeID = eType.ID;  				ls.ID = ls.ID + "_" + eType.ID;  				if (estCode != "00") {  					EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  					if (eSubType != null) {  						ls.EntitySubTypeID = eSubType.ID;  						ls.ID = ls.ID + "_" + eSubType.ID;  					}  				}  			}  		}  	}  	// No entities were found' so mark it as retired.  	if (ls.ID == null) {  		ls.ID = "RETIRED";  		ls.Remarks = "Retired";  	}  	// Find the modifier 1 and modifier 2 for the specified SIDC.  	if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  		if (mod1Code.Length == 2) {  			ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  			if (mod != null) {  				ls.ModifierOneID = mod.ID;  				ls.ID = ls.ID + "_" + mod.ID;  			}  		}  	}  	if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  		if (mod2Code.Length == 2) {  			ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  			if (mod != null) {  				ls.ModifierTwoID = mod.ID;  				ls.ID = ls.ID + "_" + mod.ID;  			}  		}  	}  	ls.ID = ls.ID + "_SYM";  	ls.Label = fullLegacyCode;  	// Add the legacy function code  	LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  	lfCode.Name = "2525C";  	if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  		lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  	if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  		lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  	lfCode.Value = functionCode;  	if (status != "")  		lfCode.Description = status;  	if (remarks != "")  		lfCode.Remarks = remarks;  	ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  		lfCode  	};  	// Add it to the current legacy symbol set  	legacySymbols.Add (ls);  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (entityCode.Length == 6) {  	string eCode = entityCode.Substring (0' 2);  	string etCode = entityCode.Substring (2' 2);  	string estCode = entityCode.Substring (4' 2);  	// Now that we have everything' let's find the pieces in the open symbol set  	SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  	// Find the entity' entity type' and entity subtype for the specified SIDC.  	SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  	if (entity != null) {  		ls.EntityID = entity.ID;  		ls.ID = entity.ID;  		if (etCode != "00") {  			SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  			if (eType != null) {  				ls.EntityTypeID = eType.ID;  				ls.ID = ls.ID + "_" + eType.ID;  				if (estCode != "00") {  					EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  					if (eSubType != null) {  						ls.EntitySubTypeID = eSubType.ID;  						ls.ID = ls.ID + "_" + eSubType.ID;  					}  				}  			}  		}  	}  	// No entities were found' so mark it as retired.  	if (ls.ID == null) {  		ls.ID = "RETIRED";  		ls.Remarks = "Retired";  	}  	// Find the modifier 1 and modifier 2 for the specified SIDC.  	if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  		if (mod1Code.Length == 2) {  			ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  			if (mod != null) {  				ls.ModifierOneID = mod.ID;  				ls.ID = ls.ID + "_" + mod.ID;  			}  		}  	}  	if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  		if (mod2Code.Length == 2) {  			ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  			if (mod != null) {  				ls.ModifierTwoID = mod.ID;  				ls.ID = ls.ID + "_" + mod.ID;  			}  		}  	}  	ls.ID = ls.ID + "_SYM";  	ls.Label = fullLegacyCode;  	// Add the legacy function code  	LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  	lfCode.Name = "2525C";  	if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  		lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  	if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  		lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  	lfCode.Value = functionCode;  	if (status != "")  		lfCode.Description = status;  	if (remarks != "")  		lfCode.Remarks = remarks;  	ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  		lfCode  	};  	// Add it to the current legacy symbol set  	legacySymbols.Add (ls);  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (entityCode.Length == 6) {  	string eCode = entityCode.Substring (0' 2);  	string etCode = entityCode.Substring (2' 2);  	string estCode = entityCode.Substring (4' 2);  	// Now that we have everything' let's find the pieces in the open symbol set  	SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  	// Find the entity' entity type' and entity subtype for the specified SIDC.  	SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  	if (entity != null) {  		ls.EntityID = entity.ID;  		ls.ID = entity.ID;  		if (etCode != "00") {  			SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  			if (eType != null) {  				ls.EntityTypeID = eType.ID;  				ls.ID = ls.ID + "_" + eType.ID;  				if (estCode != "00") {  					EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  					if (eSubType != null) {  						ls.EntitySubTypeID = eSubType.ID;  						ls.ID = ls.ID + "_" + eSubType.ID;  					}  				}  			}  		}  	}  	// No entities were found' so mark it as retired.  	if (ls.ID == null) {  		ls.ID = "RETIRED";  		ls.Remarks = "Retired";  	}  	// Find the modifier 1 and modifier 2 for the specified SIDC.  	if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  		if (mod1Code.Length == 2) {  			ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  			if (mod != null) {  				ls.ModifierOneID = mod.ID;  				ls.ID = ls.ID + "_" + mod.ID;  			}  		}  	}  	if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  		if (mod2Code.Length == 2) {  			ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  			if (mod != null) {  				ls.ModifierTwoID = mod.ID;  				ls.ID = ls.ID + "_" + mod.ID;  			}  		}  	}  	ls.ID = ls.ID + "_SYM";  	ls.Label = fullLegacyCode;  	// Add the legacy function code  	LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  	lfCode.Name = "2525C";  	if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  		lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  	if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  		lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  	lfCode.Value = functionCode;  	if (status != "")  		lfCode.Description = status;  	if (remarks != "")  		lfCode.Remarks = remarks;  	ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  		lfCode  	};  	// Add it to the current legacy symbol set  	legacySymbols.Add (ls);  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (entityCode.Length == 6) {  	string eCode = entityCode.Substring (0' 2);  	string etCode = entityCode.Substring (2' 2);  	string estCode = entityCode.Substring (4' 2);  	// Now that we have everything' let's find the pieces in the open symbol set  	SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  	// Find the entity' entity type' and entity subtype for the specified SIDC.  	SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  	if (entity != null) {  		ls.EntityID = entity.ID;  		ls.ID = entity.ID;  		if (etCode != "00") {  			SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  			if (eType != null) {  				ls.EntityTypeID = eType.ID;  				ls.ID = ls.ID + "_" + eType.ID;  				if (estCode != "00") {  					EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  					if (eSubType != null) {  						ls.EntitySubTypeID = eSubType.ID;  						ls.ID = ls.ID + "_" + eSubType.ID;  					}  				}  			}  		}  	}  	// No entities were found' so mark it as retired.  	if (ls.ID == null) {  		ls.ID = "RETIRED";  		ls.Remarks = "Retired";  	}  	// Find the modifier 1 and modifier 2 for the specified SIDC.  	if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  		if (mod1Code.Length == 2) {  			ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  			if (mod != null) {  				ls.ModifierOneID = mod.ID;  				ls.ID = ls.ID + "_" + mod.ID;  			}  		}  	}  	if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  		if (mod2Code.Length == 2) {  			ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  			if (mod != null) {  				ls.ModifierTwoID = mod.ID;  				ls.ID = ls.ID + "_" + mod.ID;  			}  		}  	}  	ls.ID = ls.ID + "_SYM";  	ls.Label = fullLegacyCode;  	// Add the legacy function code  	LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  	lfCode.Name = "2525C";  	if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  		lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  	if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  		lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  	lfCode.Value = functionCode;  	if (status != "")  		lfCode.Description = status;  	if (remarks != "")  		lfCode.Remarks = remarks;  	ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  		lfCode  	};  	// Add it to the current legacy symbol set  	legacySymbols.Add (ls);  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (entityCode.Length == 6) {  	string eCode = entityCode.Substring (0' 2);  	string etCode = entityCode.Substring (2' 2);  	string estCode = entityCode.Substring (4' 2);  	// Now that we have everything' let's find the pieces in the open symbol set  	SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  	// Find the entity' entity type' and entity subtype for the specified SIDC.  	SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  	if (entity != null) {  		ls.EntityID = entity.ID;  		ls.ID = entity.ID;  		if (etCode != "00") {  			SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  			if (eType != null) {  				ls.EntityTypeID = eType.ID;  				ls.ID = ls.ID + "_" + eType.ID;  				if (estCode != "00") {  					EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  					if (eSubType != null) {  						ls.EntitySubTypeID = eSubType.ID;  						ls.ID = ls.ID + "_" + eSubType.ID;  					}  				}  			}  		}  	}  	// No entities were found' so mark it as retired.  	if (ls.ID == null) {  		ls.ID = "RETIRED";  		ls.Remarks = "Retired";  	}  	// Find the modifier 1 and modifier 2 for the specified SIDC.  	if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  		if (mod1Code.Length == 2) {  			ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  			if (mod != null) {  				ls.ModifierOneID = mod.ID;  				ls.ID = ls.ID + "_" + mod.ID;  			}  		}  	}  	if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  		if (mod2Code.Length == 2) {  			ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  			if (mod != null) {  				ls.ModifierTwoID = mod.ID;  				ls.ID = ls.ID + "_" + mod.ID;  			}  		}  	}  	ls.ID = ls.ID + "_SYM";  	ls.Label = fullLegacyCode;  	// Add the legacy function code  	LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  	lfCode.Name = "2525C";  	if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  		lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  	if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  		lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  	lfCode.Value = functionCode;  	if (status != "")  		lfCode.Description = status;  	if (remarks != "")  		lfCode.Remarks = remarks;  	ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  		lfCode  	};  	// Add it to the current legacy symbol set  	legacySymbols.Add (ls);  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (entityCode.Length == 6) {  	string eCode = entityCode.Substring (0' 2);  	string etCode = entityCode.Substring (2' 2);  	string estCode = entityCode.Substring (4' 2);  	// Now that we have everything' let's find the pieces in the open symbol set  	SymbolSetLegacySymbol ls = new SymbolSetLegacySymbol ();  	// Find the entity' entity type' and entity subtype for the specified SIDC.  	SymbolSetEntity entity = _librarian.Entity (ss' Convert.ToUInt16 (eCode.Substring (0' 1))' Convert.ToUInt16 (eCode.Substring (1' 1)));  	if (entity != null) {  		ls.EntityID = entity.ID;  		ls.ID = entity.ID;  		if (etCode != "00") {  			SymbolSetEntityEntityType eType = _librarian.EntityType (entity' Convert.ToUInt16 (etCode.Substring (0' 1))' Convert.ToUInt16 (etCode.Substring (1' 1)));  			if (eType != null) {  				ls.EntityTypeID = eType.ID;  				ls.ID = ls.ID + "_" + eType.ID;  				if (estCode != "00") {  					EntitySubTypeType eSubType = _librarian.EntitySubType (eType' Convert.ToUInt16 (estCode.Substring (0' 1))' Convert.ToUInt16 (estCode.Substring (1' 1)));  					if (eSubType != null) {  						ls.EntitySubTypeID = eSubType.ID;  						ls.ID = ls.ID + "_" + eSubType.ID;  					}  				}  			}  		}  	}  	// No entities were found' so mark it as retired.  	if (ls.ID == null) {  		ls.ID = "RETIRED";  		ls.Remarks = "Retired";  	}  	// Find the modifier 1 and modifier 2 for the specified SIDC.  	if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  		if (mod1Code.Length == 2) {  			ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  			if (mod != null) {  				ls.ModifierOneID = mod.ID;  				ls.ID = ls.ID + "_" + mod.ID;  			}  		}  	}  	if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  		if (mod2Code.Length == 2) {  			ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  			if (mod != null) {  				ls.ModifierTwoID = mod.ID;  				ls.ID = ls.ID + "_" + mod.ID;  			}  		}  	}  	ls.ID = ls.ID + "_SYM";  	ls.Label = fullLegacyCode;  	// Add the legacy function code  	LegacyFunctionCodeType lfCode = new LegacyFunctionCodeType ();  	lfCode.Name = "2525C";  	if (fullLegacyCode.Substring (0' 1) != ss.LegacyCodingSchemeCode [0].Value)  		lfCode.SchemaOverride = fullLegacyCode.Substring (0' 1);  	if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  		lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  	lfCode.Value = functionCode;  	if (status != "")  		lfCode.Description = status;  	if (remarks != "")  		lfCode.Remarks = remarks;  	ls.LegacyFunctionCode = new LegacyFunctionCodeType[] {  		lfCode  	};  	// Add it to the current legacy symbol set  	legacySymbols.Add (ls);  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (mod1Code != "" && mod1Code != "00" && mod1Code != "0") {  	if (mod1Code.Length == 2) {  		ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  		if (mod != null) {  			ls.ModifierOneID = mod.ID;  			ls.ID = ls.ID + "_" + mod.ID;  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (mod1Code.Length == 2) {  	ModifiersTypeModifier mod = _librarian.ModifierOne (ss' Convert.ToUInt16 (mod1Code.Substring (0' 1))' Convert.ToUInt16 (mod1Code.Substring (1' 1)));  	if (mod != null) {  		ls.ModifierOneID = mod.ID;  		ls.ID = ls.ID + "_" + mod.ID;  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (mod2Code != "" && mod2Code != "00" && mod2Code != "0") {  	if (mod2Code.Length == 2) {  		ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  		if (mod != null) {  			ls.ModifierTwoID = mod.ID;  			ls.ID = ls.ID + "_" + mod.ID;  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (mod2Code.Length == 2) {  	ModifiersTypeModifier mod = _librarian.ModifierTwo (ss' Convert.ToUInt16 (mod2Code.Substring (0' 1))' Convert.ToUInt16 (mod2Code.Substring (1' 1)));  	if (mod != null) {  		ls.ModifierTwoID = mod.ID;  		ls.ID = ls.ID + "_" + mod.ID;  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  	lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: if (fullLegacyCode.Substring (2' 1) != dimension.LegacyDimensionCode [0].Value)  	lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importLegacyData,The following statement contains a magic number: lfCode.DimensionOverride = fullLegacyCode.Substring (2' 1);  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: using (StreamWriter stream = new StreamWriter (path' false)) {  	long passCount = 0;  	long failCount = 0;  	long cerrorCount = 0;  	long derrorCount = 0;  	long retiredCount = 0;  	long passWithConditionCount = 0;  	long totalCount = 0;  	stream.WriteLine ("2525Charlie1stTen'2525Charlie'2525DeltaSymbolSet'2525DeltaEntity'2525DeltaMod1'2525DeltaMod2'2525DeltaName'2525DeltaMod1Name'2525DeltaMod2Name'DeltaToCharlie'Remarks");  	stream.Flush ();  	foreach (SymbolSet ss in _librarian.SymbolSets) {  		if (ss.LegacySymbols != null) {  			foreach (SymbolSetLegacySymbol legacy in ss.LegacySymbols) {  				string cSIDC = legacy.Label;  				string cSIDCIn = legacy.Label;  				// Create a proper 2525C SIDC for testing  				if (cSIDCIn == null)  					break;  				if (cSIDCIn.Length == 15) {  					if (cSIDCIn.Substring (1' 1) == "*")  						cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  					cSIDCIn = cSIDCIn.Replace ('*'' '-');  					foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  						string dFirst10 = "";  						string dSecond10 = "";  						string cSIDCOut = "";  						string status = "";  						string symbolName = "";  						string modOneName = "";  						string modTwoName = "";  						totalCount++;  						cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  						cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  						if (fcode.SchemaOverride != "") {  							cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  							cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  						}  						if (fcode.DimensionOverride != "") {  							cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  							cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  						}  						// Build a symbol using a 2525C SIDC  						Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  						if (sym != null) {  							if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  								dFirst10 = sym.SIDC.PartAString;  								dSecond10 = sym.SIDC.PartBString;  								// Build a symbol using the 2525D SIDC' to see if reverse  								// conversion works.  								Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  								if (sym2 != null) {  									cSIDCOut = sym2.LegacySIDC;  									symbolName = sym2.Names ["Entity"];  									modOneName = sym2.Names ["ModifierOne"];  									modTwoName = sym2.Names ["ModifierTwo"];  									if (cSIDCIn == cSIDCOut) {  										status = "pass";  										passCount++;  									} else if (sym2.LegacySIDCs.Count > 1) {  										bool match = false;  										foreach (string sidc in sym2.LegacySIDCs) {  											if (cSIDCIn == sidc) {  												match = true;  												break;  											}  										}  										if (match) {  											status = "pass (multiple)";  											passWithConditionCount++;  										} else {  											status = "FAIL";  											failCount++;  										}  									} else {  										status = "FAIL";  										failCount++;  									}  								} else {  									status = "Error making 2525D";  									derrorCount++;  								}  							} else {  								status = "Retired";  								dFirst10 = SIDC.INVALID.PartAString;  								dSecond10 = SIDC.INVALID.PartBString;  								retiredCount++;  							}  						} else {  							status = "Error making 2525C";  							cerrorCount++;  						}  						stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  						stream.Flush ();  					}  				} else  					logger.Error ("Bad SIDC : " + cSIDCIn);  			}  		}  	}  	logger.Info ("----- Legacy Tests -----");  	logger.Info ("Total: " + totalCount);  	logger.Info ("Pass: " + passCount);  	logger.Info ("Pass (multiple): " + passWithConditionCount);  	logger.Info ("Retired: " + retiredCount);  	logger.Info ("Fail: " + failCount);  	logger.Info ("2525C Errors: " + cerrorCount);  	logger.Info ("2525D Errors: " + derrorCount);  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: using (StreamWriter stream = new StreamWriter (path' false)) {  	long passCount = 0;  	long failCount = 0;  	long cerrorCount = 0;  	long derrorCount = 0;  	long retiredCount = 0;  	long passWithConditionCount = 0;  	long totalCount = 0;  	stream.WriteLine ("2525Charlie1stTen'2525Charlie'2525DeltaSymbolSet'2525DeltaEntity'2525DeltaMod1'2525DeltaMod2'2525DeltaName'2525DeltaMod1Name'2525DeltaMod2Name'DeltaToCharlie'Remarks");  	stream.Flush ();  	foreach (SymbolSet ss in _librarian.SymbolSets) {  		if (ss.LegacySymbols != null) {  			foreach (SymbolSetLegacySymbol legacy in ss.LegacySymbols) {  				string cSIDC = legacy.Label;  				string cSIDCIn = legacy.Label;  				// Create a proper 2525C SIDC for testing  				if (cSIDCIn == null)  					break;  				if (cSIDCIn.Length == 15) {  					if (cSIDCIn.Substring (1' 1) == "*")  						cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  					cSIDCIn = cSIDCIn.Replace ('*'' '-');  					foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  						string dFirst10 = "";  						string dSecond10 = "";  						string cSIDCOut = "";  						string status = "";  						string symbolName = "";  						string modOneName = "";  						string modTwoName = "";  						totalCount++;  						cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  						cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  						if (fcode.SchemaOverride != "") {  							cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  							cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  						}  						if (fcode.DimensionOverride != "") {  							cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  							cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  						}  						// Build a symbol using a 2525C SIDC  						Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  						if (sym != null) {  							if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  								dFirst10 = sym.SIDC.PartAString;  								dSecond10 = sym.SIDC.PartBString;  								// Build a symbol using the 2525D SIDC' to see if reverse  								// conversion works.  								Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  								if (sym2 != null) {  									cSIDCOut = sym2.LegacySIDC;  									symbolName = sym2.Names ["Entity"];  									modOneName = sym2.Names ["ModifierOne"];  									modTwoName = sym2.Names ["ModifierTwo"];  									if (cSIDCIn == cSIDCOut) {  										status = "pass";  										passCount++;  									} else if (sym2.LegacySIDCs.Count > 1) {  										bool match = false;  										foreach (string sidc in sym2.LegacySIDCs) {  											if (cSIDCIn == sidc) {  												match = true;  												break;  											}  										}  										if (match) {  											status = "pass (multiple)";  											passWithConditionCount++;  										} else {  											status = "FAIL";  											failCount++;  										}  									} else {  										status = "FAIL";  										failCount++;  									}  								} else {  									status = "Error making 2525D";  									derrorCount++;  								}  							} else {  								status = "Retired";  								dFirst10 = SIDC.INVALID.PartAString;  								dSecond10 = SIDC.INVALID.PartBString;  								retiredCount++;  							}  						} else {  							status = "Error making 2525C";  							cerrorCount++;  						}  						stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  						stream.Flush ();  					}  				} else  					logger.Error ("Bad SIDC : " + cSIDCIn);  			}  		}  	}  	logger.Info ("----- Legacy Tests -----");  	logger.Info ("Total: " + totalCount);  	logger.Info ("Pass: " + passCount);  	logger.Info ("Pass (multiple): " + passWithConditionCount);  	logger.Info ("Retired: " + retiredCount);  	logger.Info ("Fail: " + failCount);  	logger.Info ("2525C Errors: " + cerrorCount);  	logger.Info ("2525D Errors: " + derrorCount);  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: using (StreamWriter stream = new StreamWriter (path' false)) {  	long passCount = 0;  	long failCount = 0;  	long cerrorCount = 0;  	long derrorCount = 0;  	long retiredCount = 0;  	long passWithConditionCount = 0;  	long totalCount = 0;  	stream.WriteLine ("2525Charlie1stTen'2525Charlie'2525DeltaSymbolSet'2525DeltaEntity'2525DeltaMod1'2525DeltaMod2'2525DeltaName'2525DeltaMod1Name'2525DeltaMod2Name'DeltaToCharlie'Remarks");  	stream.Flush ();  	foreach (SymbolSet ss in _librarian.SymbolSets) {  		if (ss.LegacySymbols != null) {  			foreach (SymbolSetLegacySymbol legacy in ss.LegacySymbols) {  				string cSIDC = legacy.Label;  				string cSIDCIn = legacy.Label;  				// Create a proper 2525C SIDC for testing  				if (cSIDCIn == null)  					break;  				if (cSIDCIn.Length == 15) {  					if (cSIDCIn.Substring (1' 1) == "*")  						cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  					cSIDCIn = cSIDCIn.Replace ('*'' '-');  					foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  						string dFirst10 = "";  						string dSecond10 = "";  						string cSIDCOut = "";  						string status = "";  						string symbolName = "";  						string modOneName = "";  						string modTwoName = "";  						totalCount++;  						cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  						cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  						if (fcode.SchemaOverride != "") {  							cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  							cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  						}  						if (fcode.DimensionOverride != "") {  							cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  							cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  						}  						// Build a symbol using a 2525C SIDC  						Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  						if (sym != null) {  							if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  								dFirst10 = sym.SIDC.PartAString;  								dSecond10 = sym.SIDC.PartBString;  								// Build a symbol using the 2525D SIDC' to see if reverse  								// conversion works.  								Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  								if (sym2 != null) {  									cSIDCOut = sym2.LegacySIDC;  									symbolName = sym2.Names ["Entity"];  									modOneName = sym2.Names ["ModifierOne"];  									modTwoName = sym2.Names ["ModifierTwo"];  									if (cSIDCIn == cSIDCOut) {  										status = "pass";  										passCount++;  									} else if (sym2.LegacySIDCs.Count > 1) {  										bool match = false;  										foreach (string sidc in sym2.LegacySIDCs) {  											if (cSIDCIn == sidc) {  												match = true;  												break;  											}  										}  										if (match) {  											status = "pass (multiple)";  											passWithConditionCount++;  										} else {  											status = "FAIL";  											failCount++;  										}  									} else {  										status = "FAIL";  										failCount++;  									}  								} else {  									status = "Error making 2525D";  									derrorCount++;  								}  							} else {  								status = "Retired";  								dFirst10 = SIDC.INVALID.PartAString;  								dSecond10 = SIDC.INVALID.PartBString;  								retiredCount++;  							}  						} else {  							status = "Error making 2525C";  							cerrorCount++;  						}  						stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  						stream.Flush ();  					}  				} else  					logger.Error ("Bad SIDC : " + cSIDCIn);  			}  		}  	}  	logger.Info ("----- Legacy Tests -----");  	logger.Info ("Total: " + totalCount);  	logger.Info ("Pass: " + passCount);  	logger.Info ("Pass (multiple): " + passWithConditionCount);  	logger.Info ("Retired: " + retiredCount);  	logger.Info ("Fail: " + failCount);  	logger.Info ("2525C Errors: " + cerrorCount);  	logger.Info ("2525D Errors: " + derrorCount);  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: using (StreamWriter stream = new StreamWriter (path' false)) {  	long passCount = 0;  	long failCount = 0;  	long cerrorCount = 0;  	long derrorCount = 0;  	long retiredCount = 0;  	long passWithConditionCount = 0;  	long totalCount = 0;  	stream.WriteLine ("2525Charlie1stTen'2525Charlie'2525DeltaSymbolSet'2525DeltaEntity'2525DeltaMod1'2525DeltaMod2'2525DeltaName'2525DeltaMod1Name'2525DeltaMod2Name'DeltaToCharlie'Remarks");  	stream.Flush ();  	foreach (SymbolSet ss in _librarian.SymbolSets) {  		if (ss.LegacySymbols != null) {  			foreach (SymbolSetLegacySymbol legacy in ss.LegacySymbols) {  				string cSIDC = legacy.Label;  				string cSIDCIn = legacy.Label;  				// Create a proper 2525C SIDC for testing  				if (cSIDCIn == null)  					break;  				if (cSIDCIn.Length == 15) {  					if (cSIDCIn.Substring (1' 1) == "*")  						cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  					cSIDCIn = cSIDCIn.Replace ('*'' '-');  					foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  						string dFirst10 = "";  						string dSecond10 = "";  						string cSIDCOut = "";  						string status = "";  						string symbolName = "";  						string modOneName = "";  						string modTwoName = "";  						totalCount++;  						cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  						cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  						if (fcode.SchemaOverride != "") {  							cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  							cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  						}  						if (fcode.DimensionOverride != "") {  							cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  							cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  						}  						// Build a symbol using a 2525C SIDC  						Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  						if (sym != null) {  							if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  								dFirst10 = sym.SIDC.PartAString;  								dSecond10 = sym.SIDC.PartBString;  								// Build a symbol using the 2525D SIDC' to see if reverse  								// conversion works.  								Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  								if (sym2 != null) {  									cSIDCOut = sym2.LegacySIDC;  									symbolName = sym2.Names ["Entity"];  									modOneName = sym2.Names ["ModifierOne"];  									modTwoName = sym2.Names ["ModifierTwo"];  									if (cSIDCIn == cSIDCOut) {  										status = "pass";  										passCount++;  									} else if (sym2.LegacySIDCs.Count > 1) {  										bool match = false;  										foreach (string sidc in sym2.LegacySIDCs) {  											if (cSIDCIn == sidc) {  												match = true;  												break;  											}  										}  										if (match) {  											status = "pass (multiple)";  											passWithConditionCount++;  										} else {  											status = "FAIL";  											failCount++;  										}  									} else {  										status = "FAIL";  										failCount++;  									}  								} else {  									status = "Error making 2525D";  									derrorCount++;  								}  							} else {  								status = "Retired";  								dFirst10 = SIDC.INVALID.PartAString;  								dSecond10 = SIDC.INVALID.PartBString;  								retiredCount++;  							}  						} else {  							status = "Error making 2525C";  							cerrorCount++;  						}  						stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  						stream.Flush ();  					}  				} else  					logger.Error ("Bad SIDC : " + cSIDCIn);  			}  		}  	}  	logger.Info ("----- Legacy Tests -----");  	logger.Info ("Total: " + totalCount);  	logger.Info ("Pass: " + passCount);  	logger.Info ("Pass (multiple): " + passWithConditionCount);  	logger.Info ("Retired: " + retiredCount);  	logger.Info ("Fail: " + failCount);  	logger.Info ("2525C Errors: " + cerrorCount);  	logger.Info ("2525D Errors: " + derrorCount);  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: using (StreamWriter stream = new StreamWriter (path' false)) {  	long passCount = 0;  	long failCount = 0;  	long cerrorCount = 0;  	long derrorCount = 0;  	long retiredCount = 0;  	long passWithConditionCount = 0;  	long totalCount = 0;  	stream.WriteLine ("2525Charlie1stTen'2525Charlie'2525DeltaSymbolSet'2525DeltaEntity'2525DeltaMod1'2525DeltaMod2'2525DeltaName'2525DeltaMod1Name'2525DeltaMod2Name'DeltaToCharlie'Remarks");  	stream.Flush ();  	foreach (SymbolSet ss in _librarian.SymbolSets) {  		if (ss.LegacySymbols != null) {  			foreach (SymbolSetLegacySymbol legacy in ss.LegacySymbols) {  				string cSIDC = legacy.Label;  				string cSIDCIn = legacy.Label;  				// Create a proper 2525C SIDC for testing  				if (cSIDCIn == null)  					break;  				if (cSIDCIn.Length == 15) {  					if (cSIDCIn.Substring (1' 1) == "*")  						cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  					cSIDCIn = cSIDCIn.Replace ('*'' '-');  					foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  						string dFirst10 = "";  						string dSecond10 = "";  						string cSIDCOut = "";  						string status = "";  						string symbolName = "";  						string modOneName = "";  						string modTwoName = "";  						totalCount++;  						cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  						cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  						if (fcode.SchemaOverride != "") {  							cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  							cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  						}  						if (fcode.DimensionOverride != "") {  							cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  							cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  						}  						// Build a symbol using a 2525C SIDC  						Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  						if (sym != null) {  							if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  								dFirst10 = sym.SIDC.PartAString;  								dSecond10 = sym.SIDC.PartBString;  								// Build a symbol using the 2525D SIDC' to see if reverse  								// conversion works.  								Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  								if (sym2 != null) {  									cSIDCOut = sym2.LegacySIDC;  									symbolName = sym2.Names ["Entity"];  									modOneName = sym2.Names ["ModifierOne"];  									modTwoName = sym2.Names ["ModifierTwo"];  									if (cSIDCIn == cSIDCOut) {  										status = "pass";  										passCount++;  									} else if (sym2.LegacySIDCs.Count > 1) {  										bool match = false;  										foreach (string sidc in sym2.LegacySIDCs) {  											if (cSIDCIn == sidc) {  												match = true;  												break;  											}  										}  										if (match) {  											status = "pass (multiple)";  											passWithConditionCount++;  										} else {  											status = "FAIL";  											failCount++;  										}  									} else {  										status = "FAIL";  										failCount++;  									}  								} else {  									status = "Error making 2525D";  									derrorCount++;  								}  							} else {  								status = "Retired";  								dFirst10 = SIDC.INVALID.PartAString;  								dSecond10 = SIDC.INVALID.PartBString;  								retiredCount++;  							}  						} else {  							status = "Error making 2525C";  							cerrorCount++;  						}  						stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  						stream.Flush ();  					}  				} else  					logger.Error ("Bad SIDC : " + cSIDCIn);  			}  		}  	}  	logger.Info ("----- Legacy Tests -----");  	logger.Info ("Total: " + totalCount);  	logger.Info ("Pass: " + passCount);  	logger.Info ("Pass (multiple): " + passWithConditionCount);  	logger.Info ("Retired: " + retiredCount);  	logger.Info ("Fail: " + failCount);  	logger.Info ("2525C Errors: " + cerrorCount);  	logger.Info ("2525D Errors: " + derrorCount);  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: using (StreamWriter stream = new StreamWriter (path' false)) {  	long passCount = 0;  	long failCount = 0;  	long cerrorCount = 0;  	long derrorCount = 0;  	long retiredCount = 0;  	long passWithConditionCount = 0;  	long totalCount = 0;  	stream.WriteLine ("2525Charlie1stTen'2525Charlie'2525DeltaSymbolSet'2525DeltaEntity'2525DeltaMod1'2525DeltaMod2'2525DeltaName'2525DeltaMod1Name'2525DeltaMod2Name'DeltaToCharlie'Remarks");  	stream.Flush ();  	foreach (SymbolSet ss in _librarian.SymbolSets) {  		if (ss.LegacySymbols != null) {  			foreach (SymbolSetLegacySymbol legacy in ss.LegacySymbols) {  				string cSIDC = legacy.Label;  				string cSIDCIn = legacy.Label;  				// Create a proper 2525C SIDC for testing  				if (cSIDCIn == null)  					break;  				if (cSIDCIn.Length == 15) {  					if (cSIDCIn.Substring (1' 1) == "*")  						cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  					cSIDCIn = cSIDCIn.Replace ('*'' '-');  					foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  						string dFirst10 = "";  						string dSecond10 = "";  						string cSIDCOut = "";  						string status = "";  						string symbolName = "";  						string modOneName = "";  						string modTwoName = "";  						totalCount++;  						cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  						cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  						if (fcode.SchemaOverride != "") {  							cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  							cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  						}  						if (fcode.DimensionOverride != "") {  							cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  							cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  						}  						// Build a symbol using a 2525C SIDC  						Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  						if (sym != null) {  							if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  								dFirst10 = sym.SIDC.PartAString;  								dSecond10 = sym.SIDC.PartBString;  								// Build a symbol using the 2525D SIDC' to see if reverse  								// conversion works.  								Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  								if (sym2 != null) {  									cSIDCOut = sym2.LegacySIDC;  									symbolName = sym2.Names ["Entity"];  									modOneName = sym2.Names ["ModifierOne"];  									modTwoName = sym2.Names ["ModifierTwo"];  									if (cSIDCIn == cSIDCOut) {  										status = "pass";  										passCount++;  									} else if (sym2.LegacySIDCs.Count > 1) {  										bool match = false;  										foreach (string sidc in sym2.LegacySIDCs) {  											if (cSIDCIn == sidc) {  												match = true;  												break;  											}  										}  										if (match) {  											status = "pass (multiple)";  											passWithConditionCount++;  										} else {  											status = "FAIL";  											failCount++;  										}  									} else {  										status = "FAIL";  										failCount++;  									}  								} else {  									status = "Error making 2525D";  									derrorCount++;  								}  							} else {  								status = "Retired";  								dFirst10 = SIDC.INVALID.PartAString;  								dSecond10 = SIDC.INVALID.PartBString;  								retiredCount++;  							}  						} else {  							status = "Error making 2525C";  							cerrorCount++;  						}  						stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  						stream.Flush ();  					}  				} else  					logger.Error ("Bad SIDC : " + cSIDCIn);  			}  		}  	}  	logger.Info ("----- Legacy Tests -----");  	logger.Info ("Total: " + totalCount);  	logger.Info ("Pass: " + passCount);  	logger.Info ("Pass (multiple): " + passWithConditionCount);  	logger.Info ("Retired: " + retiredCount);  	logger.Info ("Fail: " + failCount);  	logger.Info ("2525C Errors: " + cerrorCount);  	logger.Info ("2525D Errors: " + derrorCount);  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: using (StreamWriter stream = new StreamWriter (path' false)) {  	long passCount = 0;  	long failCount = 0;  	long cerrorCount = 0;  	long derrorCount = 0;  	long retiredCount = 0;  	long passWithConditionCount = 0;  	long totalCount = 0;  	stream.WriteLine ("2525Charlie1stTen'2525Charlie'2525DeltaSymbolSet'2525DeltaEntity'2525DeltaMod1'2525DeltaMod2'2525DeltaName'2525DeltaMod1Name'2525DeltaMod2Name'DeltaToCharlie'Remarks");  	stream.Flush ();  	foreach (SymbolSet ss in _librarian.SymbolSets) {  		if (ss.LegacySymbols != null) {  			foreach (SymbolSetLegacySymbol legacy in ss.LegacySymbols) {  				string cSIDC = legacy.Label;  				string cSIDCIn = legacy.Label;  				// Create a proper 2525C SIDC for testing  				if (cSIDCIn == null)  					break;  				if (cSIDCIn.Length == 15) {  					if (cSIDCIn.Substring (1' 1) == "*")  						cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  					cSIDCIn = cSIDCIn.Replace ('*'' '-');  					foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  						string dFirst10 = "";  						string dSecond10 = "";  						string cSIDCOut = "";  						string status = "";  						string symbolName = "";  						string modOneName = "";  						string modTwoName = "";  						totalCount++;  						cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  						cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  						if (fcode.SchemaOverride != "") {  							cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  							cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  						}  						if (fcode.DimensionOverride != "") {  							cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  							cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  						}  						// Build a symbol using a 2525C SIDC  						Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  						if (sym != null) {  							if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  								dFirst10 = sym.SIDC.PartAString;  								dSecond10 = sym.SIDC.PartBString;  								// Build a symbol using the 2525D SIDC' to see if reverse  								// conversion works.  								Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  								if (sym2 != null) {  									cSIDCOut = sym2.LegacySIDC;  									symbolName = sym2.Names ["Entity"];  									modOneName = sym2.Names ["ModifierOne"];  									modTwoName = sym2.Names ["ModifierTwo"];  									if (cSIDCIn == cSIDCOut) {  										status = "pass";  										passCount++;  									} else if (sym2.LegacySIDCs.Count > 1) {  										bool match = false;  										foreach (string sidc in sym2.LegacySIDCs) {  											if (cSIDCIn == sidc) {  												match = true;  												break;  											}  										}  										if (match) {  											status = "pass (multiple)";  											passWithConditionCount++;  										} else {  											status = "FAIL";  											failCount++;  										}  									} else {  										status = "FAIL";  										failCount++;  									}  								} else {  									status = "Error making 2525D";  									derrorCount++;  								}  							} else {  								status = "Retired";  								dFirst10 = SIDC.INVALID.PartAString;  								dSecond10 = SIDC.INVALID.PartBString;  								retiredCount++;  							}  						} else {  							status = "Error making 2525C";  							cerrorCount++;  						}  						stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  						stream.Flush ();  					}  				} else  					logger.Error ("Bad SIDC : " + cSIDCIn);  			}  		}  	}  	logger.Info ("----- Legacy Tests -----");  	logger.Info ("Total: " + totalCount);  	logger.Info ("Pass: " + passCount);  	logger.Info ("Pass (multiple): " + passWithConditionCount);  	logger.Info ("Retired: " + retiredCount);  	logger.Info ("Fail: " + failCount);  	logger.Info ("2525C Errors: " + cerrorCount);  	logger.Info ("2525D Errors: " + derrorCount);  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: using (StreamWriter stream = new StreamWriter (path' false)) {  	long passCount = 0;  	long failCount = 0;  	long cerrorCount = 0;  	long derrorCount = 0;  	long retiredCount = 0;  	long passWithConditionCount = 0;  	long totalCount = 0;  	stream.WriteLine ("2525Charlie1stTen'2525Charlie'2525DeltaSymbolSet'2525DeltaEntity'2525DeltaMod1'2525DeltaMod2'2525DeltaName'2525DeltaMod1Name'2525DeltaMod2Name'DeltaToCharlie'Remarks");  	stream.Flush ();  	foreach (SymbolSet ss in _librarian.SymbolSets) {  		if (ss.LegacySymbols != null) {  			foreach (SymbolSetLegacySymbol legacy in ss.LegacySymbols) {  				string cSIDC = legacy.Label;  				string cSIDCIn = legacy.Label;  				// Create a proper 2525C SIDC for testing  				if (cSIDCIn == null)  					break;  				if (cSIDCIn.Length == 15) {  					if (cSIDCIn.Substring (1' 1) == "*")  						cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  					cSIDCIn = cSIDCIn.Replace ('*'' '-');  					foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  						string dFirst10 = "";  						string dSecond10 = "";  						string cSIDCOut = "";  						string status = "";  						string symbolName = "";  						string modOneName = "";  						string modTwoName = "";  						totalCount++;  						cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  						cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  						if (fcode.SchemaOverride != "") {  							cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  							cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  						}  						if (fcode.DimensionOverride != "") {  							cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  							cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  						}  						// Build a symbol using a 2525C SIDC  						Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  						if (sym != null) {  							if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  								dFirst10 = sym.SIDC.PartAString;  								dSecond10 = sym.SIDC.PartBString;  								// Build a symbol using the 2525D SIDC' to see if reverse  								// conversion works.  								Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  								if (sym2 != null) {  									cSIDCOut = sym2.LegacySIDC;  									symbolName = sym2.Names ["Entity"];  									modOneName = sym2.Names ["ModifierOne"];  									modTwoName = sym2.Names ["ModifierTwo"];  									if (cSIDCIn == cSIDCOut) {  										status = "pass";  										passCount++;  									} else if (sym2.LegacySIDCs.Count > 1) {  										bool match = false;  										foreach (string sidc in sym2.LegacySIDCs) {  											if (cSIDCIn == sidc) {  												match = true;  												break;  											}  										}  										if (match) {  											status = "pass (multiple)";  											passWithConditionCount++;  										} else {  											status = "FAIL";  											failCount++;  										}  									} else {  										status = "FAIL";  										failCount++;  									}  								} else {  									status = "Error making 2525D";  									derrorCount++;  								}  							} else {  								status = "Retired";  								dFirst10 = SIDC.INVALID.PartAString;  								dSecond10 = SIDC.INVALID.PartBString;  								retiredCount++;  							}  						} else {  							status = "Error making 2525C";  							cerrorCount++;  						}  						stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  						stream.Flush ();  					}  				} else  					logger.Error ("Bad SIDC : " + cSIDCIn);  			}  		}  	}  	logger.Info ("----- Legacy Tests -----");  	logger.Info ("Total: " + totalCount);  	logger.Info ("Pass: " + passCount);  	logger.Info ("Pass (multiple): " + passWithConditionCount);  	logger.Info ("Retired: " + retiredCount);  	logger.Info ("Fail: " + failCount);  	logger.Info ("2525C Errors: " + cerrorCount);  	logger.Info ("2525D Errors: " + derrorCount);  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: using (StreamWriter stream = new StreamWriter (path' false)) {  	long passCount = 0;  	long failCount = 0;  	long cerrorCount = 0;  	long derrorCount = 0;  	long retiredCount = 0;  	long passWithConditionCount = 0;  	long totalCount = 0;  	stream.WriteLine ("2525Charlie1stTen'2525Charlie'2525DeltaSymbolSet'2525DeltaEntity'2525DeltaMod1'2525DeltaMod2'2525DeltaName'2525DeltaMod1Name'2525DeltaMod2Name'DeltaToCharlie'Remarks");  	stream.Flush ();  	foreach (SymbolSet ss in _librarian.SymbolSets) {  		if (ss.LegacySymbols != null) {  			foreach (SymbolSetLegacySymbol legacy in ss.LegacySymbols) {  				string cSIDC = legacy.Label;  				string cSIDCIn = legacy.Label;  				// Create a proper 2525C SIDC for testing  				if (cSIDCIn == null)  					break;  				if (cSIDCIn.Length == 15) {  					if (cSIDCIn.Substring (1' 1) == "*")  						cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  					cSIDCIn = cSIDCIn.Replace ('*'' '-');  					foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  						string dFirst10 = "";  						string dSecond10 = "";  						string cSIDCOut = "";  						string status = "";  						string symbolName = "";  						string modOneName = "";  						string modTwoName = "";  						totalCount++;  						cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  						cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  						if (fcode.SchemaOverride != "") {  							cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  							cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  						}  						if (fcode.DimensionOverride != "") {  							cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  							cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  						}  						// Build a symbol using a 2525C SIDC  						Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  						if (sym != null) {  							if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  								dFirst10 = sym.SIDC.PartAString;  								dSecond10 = sym.SIDC.PartBString;  								// Build a symbol using the 2525D SIDC' to see if reverse  								// conversion works.  								Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  								if (sym2 != null) {  									cSIDCOut = sym2.LegacySIDC;  									symbolName = sym2.Names ["Entity"];  									modOneName = sym2.Names ["ModifierOne"];  									modTwoName = sym2.Names ["ModifierTwo"];  									if (cSIDCIn == cSIDCOut) {  										status = "pass";  										passCount++;  									} else if (sym2.LegacySIDCs.Count > 1) {  										bool match = false;  										foreach (string sidc in sym2.LegacySIDCs) {  											if (cSIDCIn == sidc) {  												match = true;  												break;  											}  										}  										if (match) {  											status = "pass (multiple)";  											passWithConditionCount++;  										} else {  											status = "FAIL";  											failCount++;  										}  									} else {  										status = "FAIL";  										failCount++;  									}  								} else {  									status = "Error making 2525D";  									derrorCount++;  								}  							} else {  								status = "Retired";  								dFirst10 = SIDC.INVALID.PartAString;  								dSecond10 = SIDC.INVALID.PartBString;  								retiredCount++;  							}  						} else {  							status = "Error making 2525C";  							cerrorCount++;  						}  						stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  						stream.Flush ();  					}  				} else  					logger.Error ("Bad SIDC : " + cSIDCIn);  			}  		}  	}  	logger.Info ("----- Legacy Tests -----");  	logger.Info ("Total: " + totalCount);  	logger.Info ("Pass: " + passCount);  	logger.Info ("Pass (multiple): " + passWithConditionCount);  	logger.Info ("Retired: " + retiredCount);  	logger.Info ("Fail: " + failCount);  	logger.Info ("2525C Errors: " + cerrorCount);  	logger.Info ("2525D Errors: " + derrorCount);  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: using (StreamWriter stream = new StreamWriter (path' false)) {  	long passCount = 0;  	long failCount = 0;  	long cerrorCount = 0;  	long derrorCount = 0;  	long retiredCount = 0;  	long passWithConditionCount = 0;  	long totalCount = 0;  	stream.WriteLine ("2525Charlie1stTen'2525Charlie'2525DeltaSymbolSet'2525DeltaEntity'2525DeltaMod1'2525DeltaMod2'2525DeltaName'2525DeltaMod1Name'2525DeltaMod2Name'DeltaToCharlie'Remarks");  	stream.Flush ();  	foreach (SymbolSet ss in _librarian.SymbolSets) {  		if (ss.LegacySymbols != null) {  			foreach (SymbolSetLegacySymbol legacy in ss.LegacySymbols) {  				string cSIDC = legacy.Label;  				string cSIDCIn = legacy.Label;  				// Create a proper 2525C SIDC for testing  				if (cSIDCIn == null)  					break;  				if (cSIDCIn.Length == 15) {  					if (cSIDCIn.Substring (1' 1) == "*")  						cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  					cSIDCIn = cSIDCIn.Replace ('*'' '-');  					foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  						string dFirst10 = "";  						string dSecond10 = "";  						string cSIDCOut = "";  						string status = "";  						string symbolName = "";  						string modOneName = "";  						string modTwoName = "";  						totalCount++;  						cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  						cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  						if (fcode.SchemaOverride != "") {  							cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  							cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  						}  						if (fcode.DimensionOverride != "") {  							cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  							cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  						}  						// Build a symbol using a 2525C SIDC  						Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  						if (sym != null) {  							if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  								dFirst10 = sym.SIDC.PartAString;  								dSecond10 = sym.SIDC.PartBString;  								// Build a symbol using the 2525D SIDC' to see if reverse  								// conversion works.  								Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  								if (sym2 != null) {  									cSIDCOut = sym2.LegacySIDC;  									symbolName = sym2.Names ["Entity"];  									modOneName = sym2.Names ["ModifierOne"];  									modTwoName = sym2.Names ["ModifierTwo"];  									if (cSIDCIn == cSIDCOut) {  										status = "pass";  										passCount++;  									} else if (sym2.LegacySIDCs.Count > 1) {  										bool match = false;  										foreach (string sidc in sym2.LegacySIDCs) {  											if (cSIDCIn == sidc) {  												match = true;  												break;  											}  										}  										if (match) {  											status = "pass (multiple)";  											passWithConditionCount++;  										} else {  											status = "FAIL";  											failCount++;  										}  									} else {  										status = "FAIL";  										failCount++;  									}  								} else {  									status = "Error making 2525D";  									derrorCount++;  								}  							} else {  								status = "Retired";  								dFirst10 = SIDC.INVALID.PartAString;  								dSecond10 = SIDC.INVALID.PartBString;  								retiredCount++;  							}  						} else {  							status = "Error making 2525C";  							cerrorCount++;  						}  						stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  						stream.Flush ();  					}  				} else  					logger.Error ("Bad SIDC : " + cSIDCIn);  			}  		}  	}  	logger.Info ("----- Legacy Tests -----");  	logger.Info ("Total: " + totalCount);  	logger.Info ("Pass: " + passCount);  	logger.Info ("Pass (multiple): " + passWithConditionCount);  	logger.Info ("Retired: " + retiredCount);  	logger.Info ("Fail: " + failCount);  	logger.Info ("2525C Errors: " + cerrorCount);  	logger.Info ("2525D Errors: " + derrorCount);  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: using (StreamWriter stream = new StreamWriter (path' false)) {  	long passCount = 0;  	long failCount = 0;  	long cerrorCount = 0;  	long derrorCount = 0;  	long retiredCount = 0;  	long passWithConditionCount = 0;  	long totalCount = 0;  	stream.WriteLine ("2525Charlie1stTen'2525Charlie'2525DeltaSymbolSet'2525DeltaEntity'2525DeltaMod1'2525DeltaMod2'2525DeltaName'2525DeltaMod1Name'2525DeltaMod2Name'DeltaToCharlie'Remarks");  	stream.Flush ();  	foreach (SymbolSet ss in _librarian.SymbolSets) {  		if (ss.LegacySymbols != null) {  			foreach (SymbolSetLegacySymbol legacy in ss.LegacySymbols) {  				string cSIDC = legacy.Label;  				string cSIDCIn = legacy.Label;  				// Create a proper 2525C SIDC for testing  				if (cSIDCIn == null)  					break;  				if (cSIDCIn.Length == 15) {  					if (cSIDCIn.Substring (1' 1) == "*")  						cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  					cSIDCIn = cSIDCIn.Replace ('*'' '-');  					foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  						string dFirst10 = "";  						string dSecond10 = "";  						string cSIDCOut = "";  						string status = "";  						string symbolName = "";  						string modOneName = "";  						string modTwoName = "";  						totalCount++;  						cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  						cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  						if (fcode.SchemaOverride != "") {  							cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  							cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  						}  						if (fcode.DimensionOverride != "") {  							cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  							cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  						}  						// Build a symbol using a 2525C SIDC  						Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  						if (sym != null) {  							if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  								dFirst10 = sym.SIDC.PartAString;  								dSecond10 = sym.SIDC.PartBString;  								// Build a symbol using the 2525D SIDC' to see if reverse  								// conversion works.  								Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  								if (sym2 != null) {  									cSIDCOut = sym2.LegacySIDC;  									symbolName = sym2.Names ["Entity"];  									modOneName = sym2.Names ["ModifierOne"];  									modTwoName = sym2.Names ["ModifierTwo"];  									if (cSIDCIn == cSIDCOut) {  										status = "pass";  										passCount++;  									} else if (sym2.LegacySIDCs.Count > 1) {  										bool match = false;  										foreach (string sidc in sym2.LegacySIDCs) {  											if (cSIDCIn == sidc) {  												match = true;  												break;  											}  										}  										if (match) {  											status = "pass (multiple)";  											passWithConditionCount++;  										} else {  											status = "FAIL";  											failCount++;  										}  									} else {  										status = "FAIL";  										failCount++;  									}  								} else {  									status = "Error making 2525D";  									derrorCount++;  								}  							} else {  								status = "Retired";  								dFirst10 = SIDC.INVALID.PartAString;  								dSecond10 = SIDC.INVALID.PartBString;  								retiredCount++;  							}  						} else {  							status = "Error making 2525C";  							cerrorCount++;  						}  						stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  						stream.Flush ();  					}  				} else  					logger.Error ("Bad SIDC : " + cSIDCIn);  			}  		}  	}  	logger.Info ("----- Legacy Tests -----");  	logger.Info ("Total: " + totalCount);  	logger.Info ("Pass: " + passCount);  	logger.Info ("Pass (multiple): " + passWithConditionCount);  	logger.Info ("Retired: " + retiredCount);  	logger.Info ("Fail: " + failCount);  	logger.Info ("2525C Errors: " + cerrorCount);  	logger.Info ("2525D Errors: " + derrorCount);  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: using (StreamWriter stream = new StreamWriter (path' false)) {  	long passCount = 0;  	long failCount = 0;  	long cerrorCount = 0;  	long derrorCount = 0;  	long retiredCount = 0;  	long passWithConditionCount = 0;  	long totalCount = 0;  	stream.WriteLine ("2525Charlie1stTen'2525Charlie'2525DeltaSymbolSet'2525DeltaEntity'2525DeltaMod1'2525DeltaMod2'2525DeltaName'2525DeltaMod1Name'2525DeltaMod2Name'DeltaToCharlie'Remarks");  	stream.Flush ();  	foreach (SymbolSet ss in _librarian.SymbolSets) {  		if (ss.LegacySymbols != null) {  			foreach (SymbolSetLegacySymbol legacy in ss.LegacySymbols) {  				string cSIDC = legacy.Label;  				string cSIDCIn = legacy.Label;  				// Create a proper 2525C SIDC for testing  				if (cSIDCIn == null)  					break;  				if (cSIDCIn.Length == 15) {  					if (cSIDCIn.Substring (1' 1) == "*")  						cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  					cSIDCIn = cSIDCIn.Replace ('*'' '-');  					foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  						string dFirst10 = "";  						string dSecond10 = "";  						string cSIDCOut = "";  						string status = "";  						string symbolName = "";  						string modOneName = "";  						string modTwoName = "";  						totalCount++;  						cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  						cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  						if (fcode.SchemaOverride != "") {  							cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  							cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  						}  						if (fcode.DimensionOverride != "") {  							cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  							cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  						}  						// Build a symbol using a 2525C SIDC  						Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  						if (sym != null) {  							if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  								dFirst10 = sym.SIDC.PartAString;  								dSecond10 = sym.SIDC.PartBString;  								// Build a symbol using the 2525D SIDC' to see if reverse  								// conversion works.  								Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  								if (sym2 != null) {  									cSIDCOut = sym2.LegacySIDC;  									symbolName = sym2.Names ["Entity"];  									modOneName = sym2.Names ["ModifierOne"];  									modTwoName = sym2.Names ["ModifierTwo"];  									if (cSIDCIn == cSIDCOut) {  										status = "pass";  										passCount++;  									} else if (sym2.LegacySIDCs.Count > 1) {  										bool match = false;  										foreach (string sidc in sym2.LegacySIDCs) {  											if (cSIDCIn == sidc) {  												match = true;  												break;  											}  										}  										if (match) {  											status = "pass (multiple)";  											passWithConditionCount++;  										} else {  											status = "FAIL";  											failCount++;  										}  									} else {  										status = "FAIL";  										failCount++;  									}  								} else {  									status = "Error making 2525D";  									derrorCount++;  								}  							} else {  								status = "Retired";  								dFirst10 = SIDC.INVALID.PartAString;  								dSecond10 = SIDC.INVALID.PartBString;  								retiredCount++;  							}  						} else {  							status = "Error making 2525C";  							cerrorCount++;  						}  						stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  						stream.Flush ();  					}  				} else  					logger.Error ("Bad SIDC : " + cSIDCIn);  			}  		}  	}  	logger.Info ("----- Legacy Tests -----");  	logger.Info ("Total: " + totalCount);  	logger.Info ("Pass: " + passCount);  	logger.Info ("Pass (multiple): " + passWithConditionCount);  	logger.Info ("Retired: " + retiredCount);  	logger.Info ("Fail: " + failCount);  	logger.Info ("2525C Errors: " + cerrorCount);  	logger.Info ("2525D Errors: " + derrorCount);  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: using (StreamWriter stream = new StreamWriter (path' false)) {  	long passCount = 0;  	long failCount = 0;  	long cerrorCount = 0;  	long derrorCount = 0;  	long retiredCount = 0;  	long passWithConditionCount = 0;  	long totalCount = 0;  	stream.WriteLine ("2525Charlie1stTen'2525Charlie'2525DeltaSymbolSet'2525DeltaEntity'2525DeltaMod1'2525DeltaMod2'2525DeltaName'2525DeltaMod1Name'2525DeltaMod2Name'DeltaToCharlie'Remarks");  	stream.Flush ();  	foreach (SymbolSet ss in _librarian.SymbolSets) {  		if (ss.LegacySymbols != null) {  			foreach (SymbolSetLegacySymbol legacy in ss.LegacySymbols) {  				string cSIDC = legacy.Label;  				string cSIDCIn = legacy.Label;  				// Create a proper 2525C SIDC for testing  				if (cSIDCIn == null)  					break;  				if (cSIDCIn.Length == 15) {  					if (cSIDCIn.Substring (1' 1) == "*")  						cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  					cSIDCIn = cSIDCIn.Replace ('*'' '-');  					foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  						string dFirst10 = "";  						string dSecond10 = "";  						string cSIDCOut = "";  						string status = "";  						string symbolName = "";  						string modOneName = "";  						string modTwoName = "";  						totalCount++;  						cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  						cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  						if (fcode.SchemaOverride != "") {  							cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  							cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  						}  						if (fcode.DimensionOverride != "") {  							cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  							cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  						}  						// Build a symbol using a 2525C SIDC  						Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  						if (sym != null) {  							if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  								dFirst10 = sym.SIDC.PartAString;  								dSecond10 = sym.SIDC.PartBString;  								// Build a symbol using the 2525D SIDC' to see if reverse  								// conversion works.  								Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  								if (sym2 != null) {  									cSIDCOut = sym2.LegacySIDC;  									symbolName = sym2.Names ["Entity"];  									modOneName = sym2.Names ["ModifierOne"];  									modTwoName = sym2.Names ["ModifierTwo"];  									if (cSIDCIn == cSIDCOut) {  										status = "pass";  										passCount++;  									} else if (sym2.LegacySIDCs.Count > 1) {  										bool match = false;  										foreach (string sidc in sym2.LegacySIDCs) {  											if (cSIDCIn == sidc) {  												match = true;  												break;  											}  										}  										if (match) {  											status = "pass (multiple)";  											passWithConditionCount++;  										} else {  											status = "FAIL";  											failCount++;  										}  									} else {  										status = "FAIL";  										failCount++;  									}  								} else {  									status = "Error making 2525D";  									derrorCount++;  								}  							} else {  								status = "Retired";  								dFirst10 = SIDC.INVALID.PartAString;  								dSecond10 = SIDC.INVALID.PartBString;  								retiredCount++;  							}  						} else {  							status = "Error making 2525C";  							cerrorCount++;  						}  						stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  						stream.Flush ();  					}  				} else  					logger.Error ("Bad SIDC : " + cSIDCIn);  			}  		}  	}  	logger.Info ("----- Legacy Tests -----");  	logger.Info ("Total: " + totalCount);  	logger.Info ("Pass: " + passCount);  	logger.Info ("Pass (multiple): " + passWithConditionCount);  	logger.Info ("Retired: " + retiredCount);  	logger.Info ("Fail: " + failCount);  	logger.Info ("2525C Errors: " + cerrorCount);  	logger.Info ("2525D Errors: " + derrorCount);  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: using (StreamWriter stream = new StreamWriter (path' false)) {  	long passCount = 0;  	long failCount = 0;  	long cerrorCount = 0;  	long derrorCount = 0;  	long retiredCount = 0;  	long passWithConditionCount = 0;  	long totalCount = 0;  	stream.WriteLine ("2525Charlie1stTen'2525Charlie'2525DeltaSymbolSet'2525DeltaEntity'2525DeltaMod1'2525DeltaMod2'2525DeltaName'2525DeltaMod1Name'2525DeltaMod2Name'DeltaToCharlie'Remarks");  	stream.Flush ();  	foreach (SymbolSet ss in _librarian.SymbolSets) {  		if (ss.LegacySymbols != null) {  			foreach (SymbolSetLegacySymbol legacy in ss.LegacySymbols) {  				string cSIDC = legacy.Label;  				string cSIDCIn = legacy.Label;  				// Create a proper 2525C SIDC for testing  				if (cSIDCIn == null)  					break;  				if (cSIDCIn.Length == 15) {  					if (cSIDCIn.Substring (1' 1) == "*")  						cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  					cSIDCIn = cSIDCIn.Replace ('*'' '-');  					foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  						string dFirst10 = "";  						string dSecond10 = "";  						string cSIDCOut = "";  						string status = "";  						string symbolName = "";  						string modOneName = "";  						string modTwoName = "";  						totalCount++;  						cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  						cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  						if (fcode.SchemaOverride != "") {  							cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  							cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  						}  						if (fcode.DimensionOverride != "") {  							cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  							cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  						}  						// Build a symbol using a 2525C SIDC  						Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  						if (sym != null) {  							if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  								dFirst10 = sym.SIDC.PartAString;  								dSecond10 = sym.SIDC.PartBString;  								// Build a symbol using the 2525D SIDC' to see if reverse  								// conversion works.  								Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  								if (sym2 != null) {  									cSIDCOut = sym2.LegacySIDC;  									symbolName = sym2.Names ["Entity"];  									modOneName = sym2.Names ["ModifierOne"];  									modTwoName = sym2.Names ["ModifierTwo"];  									if (cSIDCIn == cSIDCOut) {  										status = "pass";  										passCount++;  									} else if (sym2.LegacySIDCs.Count > 1) {  										bool match = false;  										foreach (string sidc in sym2.LegacySIDCs) {  											if (cSIDCIn == sidc) {  												match = true;  												break;  											}  										}  										if (match) {  											status = "pass (multiple)";  											passWithConditionCount++;  										} else {  											status = "FAIL";  											failCount++;  										}  									} else {  										status = "FAIL";  										failCount++;  									}  								} else {  									status = "Error making 2525D";  									derrorCount++;  								}  							} else {  								status = "Retired";  								dFirst10 = SIDC.INVALID.PartAString;  								dSecond10 = SIDC.INVALID.PartBString;  								retiredCount++;  							}  						} else {  							status = "Error making 2525C";  							cerrorCount++;  						}  						stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  						stream.Flush ();  					}  				} else  					logger.Error ("Bad SIDC : " + cSIDCIn);  			}  		}  	}  	logger.Info ("----- Legacy Tests -----");  	logger.Info ("Total: " + totalCount);  	logger.Info ("Pass: " + passCount);  	logger.Info ("Pass (multiple): " + passWithConditionCount);  	logger.Info ("Retired: " + retiredCount);  	logger.Info ("Fail: " + failCount);  	logger.Info ("2525C Errors: " + cerrorCount);  	logger.Info ("2525D Errors: " + derrorCount);  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: using (StreamWriter stream = new StreamWriter (path' false)) {  	long passCount = 0;  	long failCount = 0;  	long cerrorCount = 0;  	long derrorCount = 0;  	long retiredCount = 0;  	long passWithConditionCount = 0;  	long totalCount = 0;  	stream.WriteLine ("2525Charlie1stTen'2525Charlie'2525DeltaSymbolSet'2525DeltaEntity'2525DeltaMod1'2525DeltaMod2'2525DeltaName'2525DeltaMod1Name'2525DeltaMod2Name'DeltaToCharlie'Remarks");  	stream.Flush ();  	foreach (SymbolSet ss in _librarian.SymbolSets) {  		if (ss.LegacySymbols != null) {  			foreach (SymbolSetLegacySymbol legacy in ss.LegacySymbols) {  				string cSIDC = legacy.Label;  				string cSIDCIn = legacy.Label;  				// Create a proper 2525C SIDC for testing  				if (cSIDCIn == null)  					break;  				if (cSIDCIn.Length == 15) {  					if (cSIDCIn.Substring (1' 1) == "*")  						cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  					cSIDCIn = cSIDCIn.Replace ('*'' '-');  					foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  						string dFirst10 = "";  						string dSecond10 = "";  						string cSIDCOut = "";  						string status = "";  						string symbolName = "";  						string modOneName = "";  						string modTwoName = "";  						totalCount++;  						cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  						cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  						if (fcode.SchemaOverride != "") {  							cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  							cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  						}  						if (fcode.DimensionOverride != "") {  							cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  							cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  						}  						// Build a symbol using a 2525C SIDC  						Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  						if (sym != null) {  							if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  								dFirst10 = sym.SIDC.PartAString;  								dSecond10 = sym.SIDC.PartBString;  								// Build a symbol using the 2525D SIDC' to see if reverse  								// conversion works.  								Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  								if (sym2 != null) {  									cSIDCOut = sym2.LegacySIDC;  									symbolName = sym2.Names ["Entity"];  									modOneName = sym2.Names ["ModifierOne"];  									modTwoName = sym2.Names ["ModifierTwo"];  									if (cSIDCIn == cSIDCOut) {  										status = "pass";  										passCount++;  									} else if (sym2.LegacySIDCs.Count > 1) {  										bool match = false;  										foreach (string sidc in sym2.LegacySIDCs) {  											if (cSIDCIn == sidc) {  												match = true;  												break;  											}  										}  										if (match) {  											status = "pass (multiple)";  											passWithConditionCount++;  										} else {  											status = "FAIL";  											failCount++;  										}  									} else {  										status = "FAIL";  										failCount++;  									}  								} else {  									status = "Error making 2525D";  									derrorCount++;  								}  							} else {  								status = "Retired";  								dFirst10 = SIDC.INVALID.PartAString;  								dSecond10 = SIDC.INVALID.PartBString;  								retiredCount++;  							}  						} else {  							status = "Error making 2525C";  							cerrorCount++;  						}  						stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  						stream.Flush ();  					}  				} else  					logger.Error ("Bad SIDC : " + cSIDCIn);  			}  		}  	}  	logger.Info ("----- Legacy Tests -----");  	logger.Info ("Total: " + totalCount);  	logger.Info ("Pass: " + passCount);  	logger.Info ("Pass (multiple): " + passWithConditionCount);  	logger.Info ("Retired: " + retiredCount);  	logger.Info ("Fail: " + failCount);  	logger.Info ("2525C Errors: " + cerrorCount);  	logger.Info ("2525D Errors: " + derrorCount);  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: using (StreamWriter stream = new StreamWriter (path' false)) {  	long passCount = 0;  	long failCount = 0;  	long cerrorCount = 0;  	long derrorCount = 0;  	long retiredCount = 0;  	long passWithConditionCount = 0;  	long totalCount = 0;  	stream.WriteLine ("2525Charlie1stTen'2525Charlie'2525DeltaSymbolSet'2525DeltaEntity'2525DeltaMod1'2525DeltaMod2'2525DeltaName'2525DeltaMod1Name'2525DeltaMod2Name'DeltaToCharlie'Remarks");  	stream.Flush ();  	foreach (SymbolSet ss in _librarian.SymbolSets) {  		if (ss.LegacySymbols != null) {  			foreach (SymbolSetLegacySymbol legacy in ss.LegacySymbols) {  				string cSIDC = legacy.Label;  				string cSIDCIn = legacy.Label;  				// Create a proper 2525C SIDC for testing  				if (cSIDCIn == null)  					break;  				if (cSIDCIn.Length == 15) {  					if (cSIDCIn.Substring (1' 1) == "*")  						cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  					cSIDCIn = cSIDCIn.Replace ('*'' '-');  					foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  						string dFirst10 = "";  						string dSecond10 = "";  						string cSIDCOut = "";  						string status = "";  						string symbolName = "";  						string modOneName = "";  						string modTwoName = "";  						totalCount++;  						cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  						cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  						if (fcode.SchemaOverride != "") {  							cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  							cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  						}  						if (fcode.DimensionOverride != "") {  							cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  							cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  						}  						// Build a symbol using a 2525C SIDC  						Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  						if (sym != null) {  							if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  								dFirst10 = sym.SIDC.PartAString;  								dSecond10 = sym.SIDC.PartBString;  								// Build a symbol using the 2525D SIDC' to see if reverse  								// conversion works.  								Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  								if (sym2 != null) {  									cSIDCOut = sym2.LegacySIDC;  									symbolName = sym2.Names ["Entity"];  									modOneName = sym2.Names ["ModifierOne"];  									modTwoName = sym2.Names ["ModifierTwo"];  									if (cSIDCIn == cSIDCOut) {  										status = "pass";  										passCount++;  									} else if (sym2.LegacySIDCs.Count > 1) {  										bool match = false;  										foreach (string sidc in sym2.LegacySIDCs) {  											if (cSIDCIn == sidc) {  												match = true;  												break;  											}  										}  										if (match) {  											status = "pass (multiple)";  											passWithConditionCount++;  										} else {  											status = "FAIL";  											failCount++;  										}  									} else {  										status = "FAIL";  										failCount++;  									}  								} else {  									status = "Error making 2525D";  									derrorCount++;  								}  							} else {  								status = "Retired";  								dFirst10 = SIDC.INVALID.PartAString;  								dSecond10 = SIDC.INVALID.PartBString;  								retiredCount++;  							}  						} else {  							status = "Error making 2525C";  							cerrorCount++;  						}  						stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  						stream.Flush ();  					}  				} else  					logger.Error ("Bad SIDC : " + cSIDCIn);  			}  		}  	}  	logger.Info ("----- Legacy Tests -----");  	logger.Info ("Total: " + totalCount);  	logger.Info ("Pass: " + passCount);  	logger.Info ("Pass (multiple): " + passWithConditionCount);  	logger.Info ("Retired: " + retiredCount);  	logger.Info ("Fail: " + failCount);  	logger.Info ("2525C Errors: " + cerrorCount);  	logger.Info ("2525D Errors: " + derrorCount);  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: using (StreamWriter stream = new StreamWriter (path' false)) {  	long passCount = 0;  	long failCount = 0;  	long cerrorCount = 0;  	long derrorCount = 0;  	long retiredCount = 0;  	long passWithConditionCount = 0;  	long totalCount = 0;  	stream.WriteLine ("2525Charlie1stTen'2525Charlie'2525DeltaSymbolSet'2525DeltaEntity'2525DeltaMod1'2525DeltaMod2'2525DeltaName'2525DeltaMod1Name'2525DeltaMod2Name'DeltaToCharlie'Remarks");  	stream.Flush ();  	foreach (SymbolSet ss in _librarian.SymbolSets) {  		if (ss.LegacySymbols != null) {  			foreach (SymbolSetLegacySymbol legacy in ss.LegacySymbols) {  				string cSIDC = legacy.Label;  				string cSIDCIn = legacy.Label;  				// Create a proper 2525C SIDC for testing  				if (cSIDCIn == null)  					break;  				if (cSIDCIn.Length == 15) {  					if (cSIDCIn.Substring (1' 1) == "*")  						cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  					cSIDCIn = cSIDCIn.Replace ('*'' '-');  					foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  						string dFirst10 = "";  						string dSecond10 = "";  						string cSIDCOut = "";  						string status = "";  						string symbolName = "";  						string modOneName = "";  						string modTwoName = "";  						totalCount++;  						cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  						cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  						if (fcode.SchemaOverride != "") {  							cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  							cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  						}  						if (fcode.DimensionOverride != "") {  							cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  							cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  						}  						// Build a symbol using a 2525C SIDC  						Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  						if (sym != null) {  							if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  								dFirst10 = sym.SIDC.PartAString;  								dSecond10 = sym.SIDC.PartBString;  								// Build a symbol using the 2525D SIDC' to see if reverse  								// conversion works.  								Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  								if (sym2 != null) {  									cSIDCOut = sym2.LegacySIDC;  									symbolName = sym2.Names ["Entity"];  									modOneName = sym2.Names ["ModifierOne"];  									modTwoName = sym2.Names ["ModifierTwo"];  									if (cSIDCIn == cSIDCOut) {  										status = "pass";  										passCount++;  									} else if (sym2.LegacySIDCs.Count > 1) {  										bool match = false;  										foreach (string sidc in sym2.LegacySIDCs) {  											if (cSIDCIn == sidc) {  												match = true;  												break;  											}  										}  										if (match) {  											status = "pass (multiple)";  											passWithConditionCount++;  										} else {  											status = "FAIL";  											failCount++;  										}  									} else {  										status = "FAIL";  										failCount++;  									}  								} else {  									status = "Error making 2525D";  									derrorCount++;  								}  							} else {  								status = "Retired";  								dFirst10 = SIDC.INVALID.PartAString;  								dSecond10 = SIDC.INVALID.PartBString;  								retiredCount++;  							}  						} else {  							status = "Error making 2525C";  							cerrorCount++;  						}  						stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  						stream.Flush ();  					}  				} else  					logger.Error ("Bad SIDC : " + cSIDCIn);  			}  		}  	}  	logger.Info ("----- Legacy Tests -----");  	logger.Info ("Total: " + totalCount);  	logger.Info ("Pass: " + passCount);  	logger.Info ("Pass (multiple): " + passWithConditionCount);  	logger.Info ("Retired: " + retiredCount);  	logger.Info ("Fail: " + failCount);  	logger.Info ("2525C Errors: " + cerrorCount);  	logger.Info ("2525D Errors: " + derrorCount);  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: using (StreamWriter stream = new StreamWriter (path' false)) {  	long passCount = 0;  	long failCount = 0;  	long cerrorCount = 0;  	long derrorCount = 0;  	long retiredCount = 0;  	long passWithConditionCount = 0;  	long totalCount = 0;  	stream.WriteLine ("2525Charlie1stTen'2525Charlie'2525DeltaSymbolSet'2525DeltaEntity'2525DeltaMod1'2525DeltaMod2'2525DeltaName'2525DeltaMod1Name'2525DeltaMod2Name'DeltaToCharlie'Remarks");  	stream.Flush ();  	foreach (SymbolSet ss in _librarian.SymbolSets) {  		if (ss.LegacySymbols != null) {  			foreach (SymbolSetLegacySymbol legacy in ss.LegacySymbols) {  				string cSIDC = legacy.Label;  				string cSIDCIn = legacy.Label;  				// Create a proper 2525C SIDC for testing  				if (cSIDCIn == null)  					break;  				if (cSIDCIn.Length == 15) {  					if (cSIDCIn.Substring (1' 1) == "*")  						cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  					cSIDCIn = cSIDCIn.Replace ('*'' '-');  					foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  						string dFirst10 = "";  						string dSecond10 = "";  						string cSIDCOut = "";  						string status = "";  						string symbolName = "";  						string modOneName = "";  						string modTwoName = "";  						totalCount++;  						cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  						cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  						if (fcode.SchemaOverride != "") {  							cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  							cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  						}  						if (fcode.DimensionOverride != "") {  							cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  							cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  						}  						// Build a symbol using a 2525C SIDC  						Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  						if (sym != null) {  							if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  								dFirst10 = sym.SIDC.PartAString;  								dSecond10 = sym.SIDC.PartBString;  								// Build a symbol using the 2525D SIDC' to see if reverse  								// conversion works.  								Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  								if (sym2 != null) {  									cSIDCOut = sym2.LegacySIDC;  									symbolName = sym2.Names ["Entity"];  									modOneName = sym2.Names ["ModifierOne"];  									modTwoName = sym2.Names ["ModifierTwo"];  									if (cSIDCIn == cSIDCOut) {  										status = "pass";  										passCount++;  									} else if (sym2.LegacySIDCs.Count > 1) {  										bool match = false;  										foreach (string sidc in sym2.LegacySIDCs) {  											if (cSIDCIn == sidc) {  												match = true;  												break;  											}  										}  										if (match) {  											status = "pass (multiple)";  											passWithConditionCount++;  										} else {  											status = "FAIL";  											failCount++;  										}  									} else {  										status = "FAIL";  										failCount++;  									}  								} else {  									status = "Error making 2525D";  									derrorCount++;  								}  							} else {  								status = "Retired";  								dFirst10 = SIDC.INVALID.PartAString;  								dSecond10 = SIDC.INVALID.PartBString;  								retiredCount++;  							}  						} else {  							status = "Error making 2525C";  							cerrorCount++;  						}  						stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  						stream.Flush ();  					}  				} else  					logger.Error ("Bad SIDC : " + cSIDCIn);  			}  		}  	}  	logger.Info ("----- Legacy Tests -----");  	logger.Info ("Total: " + totalCount);  	logger.Info ("Pass: " + passCount);  	logger.Info ("Pass (multiple): " + passWithConditionCount);  	logger.Info ("Retired: " + retiredCount);  	logger.Info ("Fail: " + failCount);  	logger.Info ("2525C Errors: " + cerrorCount);  	logger.Info ("2525D Errors: " + derrorCount);  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: foreach (SymbolSet ss in _librarian.SymbolSets) {  	if (ss.LegacySymbols != null) {  		foreach (SymbolSetLegacySymbol legacy in ss.LegacySymbols) {  			string cSIDC = legacy.Label;  			string cSIDCIn = legacy.Label;  			// Create a proper 2525C SIDC for testing  			if (cSIDCIn == null)  				break;  			if (cSIDCIn.Length == 15) {  				if (cSIDCIn.Substring (1' 1) == "*")  					cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  				cSIDCIn = cSIDCIn.Replace ('*'' '-');  				foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  					string dFirst10 = "";  					string dSecond10 = "";  					string cSIDCOut = "";  					string status = "";  					string symbolName = "";  					string modOneName = "";  					string modTwoName = "";  					totalCount++;  					cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  					cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  					if (fcode.SchemaOverride != "") {  						cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  						cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  					}  					if (fcode.DimensionOverride != "") {  						cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  						cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  					}  					// Build a symbol using a 2525C SIDC  					Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  					if (sym != null) {  						if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  							dFirst10 = sym.SIDC.PartAString;  							dSecond10 = sym.SIDC.PartBString;  							// Build a symbol using the 2525D SIDC' to see if reverse  							// conversion works.  							Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  							if (sym2 != null) {  								cSIDCOut = sym2.LegacySIDC;  								symbolName = sym2.Names ["Entity"];  								modOneName = sym2.Names ["ModifierOne"];  								modTwoName = sym2.Names ["ModifierTwo"];  								if (cSIDCIn == cSIDCOut) {  									status = "pass";  									passCount++;  								} else if (sym2.LegacySIDCs.Count > 1) {  									bool match = false;  									foreach (string sidc in sym2.LegacySIDCs) {  										if (cSIDCIn == sidc) {  											match = true;  											break;  										}  									}  									if (match) {  										status = "pass (multiple)";  										passWithConditionCount++;  									} else {  										status = "FAIL";  										failCount++;  									}  								} else {  									status = "FAIL";  									failCount++;  								}  							} else {  								status = "Error making 2525D";  								derrorCount++;  							}  						} else {  							status = "Retired";  							dFirst10 = SIDC.INVALID.PartAString;  							dSecond10 = SIDC.INVALID.PartBString;  							retiredCount++;  						}  					} else {  						status = "Error making 2525C";  						cerrorCount++;  					}  					stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  					stream.Flush ();  				}  			} else  				logger.Error ("Bad SIDC : " + cSIDCIn);  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: foreach (SymbolSet ss in _librarian.SymbolSets) {  	if (ss.LegacySymbols != null) {  		foreach (SymbolSetLegacySymbol legacy in ss.LegacySymbols) {  			string cSIDC = legacy.Label;  			string cSIDCIn = legacy.Label;  			// Create a proper 2525C SIDC for testing  			if (cSIDCIn == null)  				break;  			if (cSIDCIn.Length == 15) {  				if (cSIDCIn.Substring (1' 1) == "*")  					cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  				cSIDCIn = cSIDCIn.Replace ('*'' '-');  				foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  					string dFirst10 = "";  					string dSecond10 = "";  					string cSIDCOut = "";  					string status = "";  					string symbolName = "";  					string modOneName = "";  					string modTwoName = "";  					totalCount++;  					cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  					cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  					if (fcode.SchemaOverride != "") {  						cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  						cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  					}  					if (fcode.DimensionOverride != "") {  						cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  						cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  					}  					// Build a symbol using a 2525C SIDC  					Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  					if (sym != null) {  						if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  							dFirst10 = sym.SIDC.PartAString;  							dSecond10 = sym.SIDC.PartBString;  							// Build a symbol using the 2525D SIDC' to see if reverse  							// conversion works.  							Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  							if (sym2 != null) {  								cSIDCOut = sym2.LegacySIDC;  								symbolName = sym2.Names ["Entity"];  								modOneName = sym2.Names ["ModifierOne"];  								modTwoName = sym2.Names ["ModifierTwo"];  								if (cSIDCIn == cSIDCOut) {  									status = "pass";  									passCount++;  								} else if (sym2.LegacySIDCs.Count > 1) {  									bool match = false;  									foreach (string sidc in sym2.LegacySIDCs) {  										if (cSIDCIn == sidc) {  											match = true;  											break;  										}  									}  									if (match) {  										status = "pass (multiple)";  										passWithConditionCount++;  									} else {  										status = "FAIL";  										failCount++;  									}  								} else {  									status = "FAIL";  									failCount++;  								}  							} else {  								status = "Error making 2525D";  								derrorCount++;  							}  						} else {  							status = "Retired";  							dFirst10 = SIDC.INVALID.PartAString;  							dSecond10 = SIDC.INVALID.PartBString;  							retiredCount++;  						}  					} else {  						status = "Error making 2525C";  						cerrorCount++;  					}  					stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  					stream.Flush ();  				}  			} else  				logger.Error ("Bad SIDC : " + cSIDCIn);  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: foreach (SymbolSet ss in _librarian.SymbolSets) {  	if (ss.LegacySymbols != null) {  		foreach (SymbolSetLegacySymbol legacy in ss.LegacySymbols) {  			string cSIDC = legacy.Label;  			string cSIDCIn = legacy.Label;  			// Create a proper 2525C SIDC for testing  			if (cSIDCIn == null)  				break;  			if (cSIDCIn.Length == 15) {  				if (cSIDCIn.Substring (1' 1) == "*")  					cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  				cSIDCIn = cSIDCIn.Replace ('*'' '-');  				foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  					string dFirst10 = "";  					string dSecond10 = "";  					string cSIDCOut = "";  					string status = "";  					string symbolName = "";  					string modOneName = "";  					string modTwoName = "";  					totalCount++;  					cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  					cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  					if (fcode.SchemaOverride != "") {  						cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  						cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  					}  					if (fcode.DimensionOverride != "") {  						cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  						cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  					}  					// Build a symbol using a 2525C SIDC  					Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  					if (sym != null) {  						if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  							dFirst10 = sym.SIDC.PartAString;  							dSecond10 = sym.SIDC.PartBString;  							// Build a symbol using the 2525D SIDC' to see if reverse  							// conversion works.  							Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  							if (sym2 != null) {  								cSIDCOut = sym2.LegacySIDC;  								symbolName = sym2.Names ["Entity"];  								modOneName = sym2.Names ["ModifierOne"];  								modTwoName = sym2.Names ["ModifierTwo"];  								if (cSIDCIn == cSIDCOut) {  									status = "pass";  									passCount++;  								} else if (sym2.LegacySIDCs.Count > 1) {  									bool match = false;  									foreach (string sidc in sym2.LegacySIDCs) {  										if (cSIDCIn == sidc) {  											match = true;  											break;  										}  									}  									if (match) {  										status = "pass (multiple)";  										passWithConditionCount++;  									} else {  										status = "FAIL";  										failCount++;  									}  								} else {  									status = "FAIL";  									failCount++;  								}  							} else {  								status = "Error making 2525D";  								derrorCount++;  							}  						} else {  							status = "Retired";  							dFirst10 = SIDC.INVALID.PartAString;  							dSecond10 = SIDC.INVALID.PartBString;  							retiredCount++;  						}  					} else {  						status = "Error making 2525C";  						cerrorCount++;  					}  					stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  					stream.Flush ();  				}  			} else  				logger.Error ("Bad SIDC : " + cSIDCIn);  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: foreach (SymbolSet ss in _librarian.SymbolSets) {  	if (ss.LegacySymbols != null) {  		foreach (SymbolSetLegacySymbol legacy in ss.LegacySymbols) {  			string cSIDC = legacy.Label;  			string cSIDCIn = legacy.Label;  			// Create a proper 2525C SIDC for testing  			if (cSIDCIn == null)  				break;  			if (cSIDCIn.Length == 15) {  				if (cSIDCIn.Substring (1' 1) == "*")  					cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  				cSIDCIn = cSIDCIn.Replace ('*'' '-');  				foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  					string dFirst10 = "";  					string dSecond10 = "";  					string cSIDCOut = "";  					string status = "";  					string symbolName = "";  					string modOneName = "";  					string modTwoName = "";  					totalCount++;  					cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  					cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  					if (fcode.SchemaOverride != "") {  						cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  						cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  					}  					if (fcode.DimensionOverride != "") {  						cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  						cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  					}  					// Build a symbol using a 2525C SIDC  					Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  					if (sym != null) {  						if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  							dFirst10 = sym.SIDC.PartAString;  							dSecond10 = sym.SIDC.PartBString;  							// Build a symbol using the 2525D SIDC' to see if reverse  							// conversion works.  							Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  							if (sym2 != null) {  								cSIDCOut = sym2.LegacySIDC;  								symbolName = sym2.Names ["Entity"];  								modOneName = sym2.Names ["ModifierOne"];  								modTwoName = sym2.Names ["ModifierTwo"];  								if (cSIDCIn == cSIDCOut) {  									status = "pass";  									passCount++;  								} else if (sym2.LegacySIDCs.Count > 1) {  									bool match = false;  									foreach (string sidc in sym2.LegacySIDCs) {  										if (cSIDCIn == sidc) {  											match = true;  											break;  										}  									}  									if (match) {  										status = "pass (multiple)";  										passWithConditionCount++;  									} else {  										status = "FAIL";  										failCount++;  									}  								} else {  									status = "FAIL";  									failCount++;  								}  							} else {  								status = "Error making 2525D";  								derrorCount++;  							}  						} else {  							status = "Retired";  							dFirst10 = SIDC.INVALID.PartAString;  							dSecond10 = SIDC.INVALID.PartBString;  							retiredCount++;  						}  					} else {  						status = "Error making 2525C";  						cerrorCount++;  					}  					stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  					stream.Flush ();  				}  			} else  				logger.Error ("Bad SIDC : " + cSIDCIn);  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: foreach (SymbolSet ss in _librarian.SymbolSets) {  	if (ss.LegacySymbols != null) {  		foreach (SymbolSetLegacySymbol legacy in ss.LegacySymbols) {  			string cSIDC = legacy.Label;  			string cSIDCIn = legacy.Label;  			// Create a proper 2525C SIDC for testing  			if (cSIDCIn == null)  				break;  			if (cSIDCIn.Length == 15) {  				if (cSIDCIn.Substring (1' 1) == "*")  					cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  				cSIDCIn = cSIDCIn.Replace ('*'' '-');  				foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  					string dFirst10 = "";  					string dSecond10 = "";  					string cSIDCOut = "";  					string status = "";  					string symbolName = "";  					string modOneName = "";  					string modTwoName = "";  					totalCount++;  					cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  					cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  					if (fcode.SchemaOverride != "") {  						cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  						cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  					}  					if (fcode.DimensionOverride != "") {  						cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  						cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  					}  					// Build a symbol using a 2525C SIDC  					Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  					if (sym != null) {  						if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  							dFirst10 = sym.SIDC.PartAString;  							dSecond10 = sym.SIDC.PartBString;  							// Build a symbol using the 2525D SIDC' to see if reverse  							// conversion works.  							Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  							if (sym2 != null) {  								cSIDCOut = sym2.LegacySIDC;  								symbolName = sym2.Names ["Entity"];  								modOneName = sym2.Names ["ModifierOne"];  								modTwoName = sym2.Names ["ModifierTwo"];  								if (cSIDCIn == cSIDCOut) {  									status = "pass";  									passCount++;  								} else if (sym2.LegacySIDCs.Count > 1) {  									bool match = false;  									foreach (string sidc in sym2.LegacySIDCs) {  										if (cSIDCIn == sidc) {  											match = true;  											break;  										}  									}  									if (match) {  										status = "pass (multiple)";  										passWithConditionCount++;  									} else {  										status = "FAIL";  										failCount++;  									}  								} else {  									status = "FAIL";  									failCount++;  								}  							} else {  								status = "Error making 2525D";  								derrorCount++;  							}  						} else {  							status = "Retired";  							dFirst10 = SIDC.INVALID.PartAString;  							dSecond10 = SIDC.INVALID.PartBString;  							retiredCount++;  						}  					} else {  						status = "Error making 2525C";  						cerrorCount++;  					}  					stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  					stream.Flush ();  				}  			} else  				logger.Error ("Bad SIDC : " + cSIDCIn);  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: foreach (SymbolSet ss in _librarian.SymbolSets) {  	if (ss.LegacySymbols != null) {  		foreach (SymbolSetLegacySymbol legacy in ss.LegacySymbols) {  			string cSIDC = legacy.Label;  			string cSIDCIn = legacy.Label;  			// Create a proper 2525C SIDC for testing  			if (cSIDCIn == null)  				break;  			if (cSIDCIn.Length == 15) {  				if (cSIDCIn.Substring (1' 1) == "*")  					cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  				cSIDCIn = cSIDCIn.Replace ('*'' '-');  				foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  					string dFirst10 = "";  					string dSecond10 = "";  					string cSIDCOut = "";  					string status = "";  					string symbolName = "";  					string modOneName = "";  					string modTwoName = "";  					totalCount++;  					cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  					cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  					if (fcode.SchemaOverride != "") {  						cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  						cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  					}  					if (fcode.DimensionOverride != "") {  						cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  						cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  					}  					// Build a symbol using a 2525C SIDC  					Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  					if (sym != null) {  						if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  							dFirst10 = sym.SIDC.PartAString;  							dSecond10 = sym.SIDC.PartBString;  							// Build a symbol using the 2525D SIDC' to see if reverse  							// conversion works.  							Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  							if (sym2 != null) {  								cSIDCOut = sym2.LegacySIDC;  								symbolName = sym2.Names ["Entity"];  								modOneName = sym2.Names ["ModifierOne"];  								modTwoName = sym2.Names ["ModifierTwo"];  								if (cSIDCIn == cSIDCOut) {  									status = "pass";  									passCount++;  								} else if (sym2.LegacySIDCs.Count > 1) {  									bool match = false;  									foreach (string sidc in sym2.LegacySIDCs) {  										if (cSIDCIn == sidc) {  											match = true;  											break;  										}  									}  									if (match) {  										status = "pass (multiple)";  										passWithConditionCount++;  									} else {  										status = "FAIL";  										failCount++;  									}  								} else {  									status = "FAIL";  									failCount++;  								}  							} else {  								status = "Error making 2525D";  								derrorCount++;  							}  						} else {  							status = "Retired";  							dFirst10 = SIDC.INVALID.PartAString;  							dSecond10 = SIDC.INVALID.PartBString;  							retiredCount++;  						}  					} else {  						status = "Error making 2525C";  						cerrorCount++;  					}  					stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  					stream.Flush ();  				}  			} else  				logger.Error ("Bad SIDC : " + cSIDCIn);  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: foreach (SymbolSet ss in _librarian.SymbolSets) {  	if (ss.LegacySymbols != null) {  		foreach (SymbolSetLegacySymbol legacy in ss.LegacySymbols) {  			string cSIDC = legacy.Label;  			string cSIDCIn = legacy.Label;  			// Create a proper 2525C SIDC for testing  			if (cSIDCIn == null)  				break;  			if (cSIDCIn.Length == 15) {  				if (cSIDCIn.Substring (1' 1) == "*")  					cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  				cSIDCIn = cSIDCIn.Replace ('*'' '-');  				foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  					string dFirst10 = "";  					string dSecond10 = "";  					string cSIDCOut = "";  					string status = "";  					string symbolName = "";  					string modOneName = "";  					string modTwoName = "";  					totalCount++;  					cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  					cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  					if (fcode.SchemaOverride != "") {  						cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  						cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  					}  					if (fcode.DimensionOverride != "") {  						cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  						cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  					}  					// Build a symbol using a 2525C SIDC  					Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  					if (sym != null) {  						if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  							dFirst10 = sym.SIDC.PartAString;  							dSecond10 = sym.SIDC.PartBString;  							// Build a symbol using the 2525D SIDC' to see if reverse  							// conversion works.  							Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  							if (sym2 != null) {  								cSIDCOut = sym2.LegacySIDC;  								symbolName = sym2.Names ["Entity"];  								modOneName = sym2.Names ["ModifierOne"];  								modTwoName = sym2.Names ["ModifierTwo"];  								if (cSIDCIn == cSIDCOut) {  									status = "pass";  									passCount++;  								} else if (sym2.LegacySIDCs.Count > 1) {  									bool match = false;  									foreach (string sidc in sym2.LegacySIDCs) {  										if (cSIDCIn == sidc) {  											match = true;  											break;  										}  									}  									if (match) {  										status = "pass (multiple)";  										passWithConditionCount++;  									} else {  										status = "FAIL";  										failCount++;  									}  								} else {  									status = "FAIL";  									failCount++;  								}  							} else {  								status = "Error making 2525D";  								derrorCount++;  							}  						} else {  							status = "Retired";  							dFirst10 = SIDC.INVALID.PartAString;  							dSecond10 = SIDC.INVALID.PartBString;  							retiredCount++;  						}  					} else {  						status = "Error making 2525C";  						cerrorCount++;  					}  					stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  					stream.Flush ();  				}  			} else  				logger.Error ("Bad SIDC : " + cSIDCIn);  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: foreach (SymbolSet ss in _librarian.SymbolSets) {  	if (ss.LegacySymbols != null) {  		foreach (SymbolSetLegacySymbol legacy in ss.LegacySymbols) {  			string cSIDC = legacy.Label;  			string cSIDCIn = legacy.Label;  			// Create a proper 2525C SIDC for testing  			if (cSIDCIn == null)  				break;  			if (cSIDCIn.Length == 15) {  				if (cSIDCIn.Substring (1' 1) == "*")  					cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  				cSIDCIn = cSIDCIn.Replace ('*'' '-');  				foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  					string dFirst10 = "";  					string dSecond10 = "";  					string cSIDCOut = "";  					string status = "";  					string symbolName = "";  					string modOneName = "";  					string modTwoName = "";  					totalCount++;  					cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  					cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  					if (fcode.SchemaOverride != "") {  						cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  						cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  					}  					if (fcode.DimensionOverride != "") {  						cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  						cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  					}  					// Build a symbol using a 2525C SIDC  					Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  					if (sym != null) {  						if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  							dFirst10 = sym.SIDC.PartAString;  							dSecond10 = sym.SIDC.PartBString;  							// Build a symbol using the 2525D SIDC' to see if reverse  							// conversion works.  							Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  							if (sym2 != null) {  								cSIDCOut = sym2.LegacySIDC;  								symbolName = sym2.Names ["Entity"];  								modOneName = sym2.Names ["ModifierOne"];  								modTwoName = sym2.Names ["ModifierTwo"];  								if (cSIDCIn == cSIDCOut) {  									status = "pass";  									passCount++;  								} else if (sym2.LegacySIDCs.Count > 1) {  									bool match = false;  									foreach (string sidc in sym2.LegacySIDCs) {  										if (cSIDCIn == sidc) {  											match = true;  											break;  										}  									}  									if (match) {  										status = "pass (multiple)";  										passWithConditionCount++;  									} else {  										status = "FAIL";  										failCount++;  									}  								} else {  									status = "FAIL";  									failCount++;  								}  							} else {  								status = "Error making 2525D";  								derrorCount++;  							}  						} else {  							status = "Retired";  							dFirst10 = SIDC.INVALID.PartAString;  							dSecond10 = SIDC.INVALID.PartBString;  							retiredCount++;  						}  					} else {  						status = "Error making 2525C";  						cerrorCount++;  					}  					stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  					stream.Flush ();  				}  			} else  				logger.Error ("Bad SIDC : " + cSIDCIn);  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: foreach (SymbolSet ss in _librarian.SymbolSets) {  	if (ss.LegacySymbols != null) {  		foreach (SymbolSetLegacySymbol legacy in ss.LegacySymbols) {  			string cSIDC = legacy.Label;  			string cSIDCIn = legacy.Label;  			// Create a proper 2525C SIDC for testing  			if (cSIDCIn == null)  				break;  			if (cSIDCIn.Length == 15) {  				if (cSIDCIn.Substring (1' 1) == "*")  					cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  				cSIDCIn = cSIDCIn.Replace ('*'' '-');  				foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  					string dFirst10 = "";  					string dSecond10 = "";  					string cSIDCOut = "";  					string status = "";  					string symbolName = "";  					string modOneName = "";  					string modTwoName = "";  					totalCount++;  					cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  					cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  					if (fcode.SchemaOverride != "") {  						cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  						cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  					}  					if (fcode.DimensionOverride != "") {  						cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  						cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  					}  					// Build a symbol using a 2525C SIDC  					Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  					if (sym != null) {  						if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  							dFirst10 = sym.SIDC.PartAString;  							dSecond10 = sym.SIDC.PartBString;  							// Build a symbol using the 2525D SIDC' to see if reverse  							// conversion works.  							Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  							if (sym2 != null) {  								cSIDCOut = sym2.LegacySIDC;  								symbolName = sym2.Names ["Entity"];  								modOneName = sym2.Names ["ModifierOne"];  								modTwoName = sym2.Names ["ModifierTwo"];  								if (cSIDCIn == cSIDCOut) {  									status = "pass";  									passCount++;  								} else if (sym2.LegacySIDCs.Count > 1) {  									bool match = false;  									foreach (string sidc in sym2.LegacySIDCs) {  										if (cSIDCIn == sidc) {  											match = true;  											break;  										}  									}  									if (match) {  										status = "pass (multiple)";  										passWithConditionCount++;  									} else {  										status = "FAIL";  										failCount++;  									}  								} else {  									status = "FAIL";  									failCount++;  								}  							} else {  								status = "Error making 2525D";  								derrorCount++;  							}  						} else {  							status = "Retired";  							dFirst10 = SIDC.INVALID.PartAString;  							dSecond10 = SIDC.INVALID.PartBString;  							retiredCount++;  						}  					} else {  						status = "Error making 2525C";  						cerrorCount++;  					}  					stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  					stream.Flush ();  				}  			} else  				logger.Error ("Bad SIDC : " + cSIDCIn);  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: foreach (SymbolSet ss in _librarian.SymbolSets) {  	if (ss.LegacySymbols != null) {  		foreach (SymbolSetLegacySymbol legacy in ss.LegacySymbols) {  			string cSIDC = legacy.Label;  			string cSIDCIn = legacy.Label;  			// Create a proper 2525C SIDC for testing  			if (cSIDCIn == null)  				break;  			if (cSIDCIn.Length == 15) {  				if (cSIDCIn.Substring (1' 1) == "*")  					cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  				cSIDCIn = cSIDCIn.Replace ('*'' '-');  				foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  					string dFirst10 = "";  					string dSecond10 = "";  					string cSIDCOut = "";  					string status = "";  					string symbolName = "";  					string modOneName = "";  					string modTwoName = "";  					totalCount++;  					cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  					cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  					if (fcode.SchemaOverride != "") {  						cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  						cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  					}  					if (fcode.DimensionOverride != "") {  						cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  						cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  					}  					// Build a symbol using a 2525C SIDC  					Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  					if (sym != null) {  						if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  							dFirst10 = sym.SIDC.PartAString;  							dSecond10 = sym.SIDC.PartBString;  							// Build a symbol using the 2525D SIDC' to see if reverse  							// conversion works.  							Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  							if (sym2 != null) {  								cSIDCOut = sym2.LegacySIDC;  								symbolName = sym2.Names ["Entity"];  								modOneName = sym2.Names ["ModifierOne"];  								modTwoName = sym2.Names ["ModifierTwo"];  								if (cSIDCIn == cSIDCOut) {  									status = "pass";  									passCount++;  								} else if (sym2.LegacySIDCs.Count > 1) {  									bool match = false;  									foreach (string sidc in sym2.LegacySIDCs) {  										if (cSIDCIn == sidc) {  											match = true;  											break;  										}  									}  									if (match) {  										status = "pass (multiple)";  										passWithConditionCount++;  									} else {  										status = "FAIL";  										failCount++;  									}  								} else {  									status = "FAIL";  									failCount++;  								}  							} else {  								status = "Error making 2525D";  								derrorCount++;  							}  						} else {  							status = "Retired";  							dFirst10 = SIDC.INVALID.PartAString;  							dSecond10 = SIDC.INVALID.PartBString;  							retiredCount++;  						}  					} else {  						status = "Error making 2525C";  						cerrorCount++;  					}  					stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  					stream.Flush ();  				}  			} else  				logger.Error ("Bad SIDC : " + cSIDCIn);  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: foreach (SymbolSet ss in _librarian.SymbolSets) {  	if (ss.LegacySymbols != null) {  		foreach (SymbolSetLegacySymbol legacy in ss.LegacySymbols) {  			string cSIDC = legacy.Label;  			string cSIDCIn = legacy.Label;  			// Create a proper 2525C SIDC for testing  			if (cSIDCIn == null)  				break;  			if (cSIDCIn.Length == 15) {  				if (cSIDCIn.Substring (1' 1) == "*")  					cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  				cSIDCIn = cSIDCIn.Replace ('*'' '-');  				foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  					string dFirst10 = "";  					string dSecond10 = "";  					string cSIDCOut = "";  					string status = "";  					string symbolName = "";  					string modOneName = "";  					string modTwoName = "";  					totalCount++;  					cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  					cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  					if (fcode.SchemaOverride != "") {  						cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  						cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  					}  					if (fcode.DimensionOverride != "") {  						cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  						cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  					}  					// Build a symbol using a 2525C SIDC  					Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  					if (sym != null) {  						if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  							dFirst10 = sym.SIDC.PartAString;  							dSecond10 = sym.SIDC.PartBString;  							// Build a symbol using the 2525D SIDC' to see if reverse  							// conversion works.  							Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  							if (sym2 != null) {  								cSIDCOut = sym2.LegacySIDC;  								symbolName = sym2.Names ["Entity"];  								modOneName = sym2.Names ["ModifierOne"];  								modTwoName = sym2.Names ["ModifierTwo"];  								if (cSIDCIn == cSIDCOut) {  									status = "pass";  									passCount++;  								} else if (sym2.LegacySIDCs.Count > 1) {  									bool match = false;  									foreach (string sidc in sym2.LegacySIDCs) {  										if (cSIDCIn == sidc) {  											match = true;  											break;  										}  									}  									if (match) {  										status = "pass (multiple)";  										passWithConditionCount++;  									} else {  										status = "FAIL";  										failCount++;  									}  								} else {  									status = "FAIL";  									failCount++;  								}  							} else {  								status = "Error making 2525D";  								derrorCount++;  							}  						} else {  							status = "Retired";  							dFirst10 = SIDC.INVALID.PartAString;  							dSecond10 = SIDC.INVALID.PartBString;  							retiredCount++;  						}  					} else {  						status = "Error making 2525C";  						cerrorCount++;  					}  					stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  					stream.Flush ();  				}  			} else  				logger.Error ("Bad SIDC : " + cSIDCIn);  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: foreach (SymbolSet ss in _librarian.SymbolSets) {  	if (ss.LegacySymbols != null) {  		foreach (SymbolSetLegacySymbol legacy in ss.LegacySymbols) {  			string cSIDC = legacy.Label;  			string cSIDCIn = legacy.Label;  			// Create a proper 2525C SIDC for testing  			if (cSIDCIn == null)  				break;  			if (cSIDCIn.Length == 15) {  				if (cSIDCIn.Substring (1' 1) == "*")  					cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  				cSIDCIn = cSIDCIn.Replace ('*'' '-');  				foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  					string dFirst10 = "";  					string dSecond10 = "";  					string cSIDCOut = "";  					string status = "";  					string symbolName = "";  					string modOneName = "";  					string modTwoName = "";  					totalCount++;  					cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  					cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  					if (fcode.SchemaOverride != "") {  						cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  						cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  					}  					if (fcode.DimensionOverride != "") {  						cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  						cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  					}  					// Build a symbol using a 2525C SIDC  					Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  					if (sym != null) {  						if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  							dFirst10 = sym.SIDC.PartAString;  							dSecond10 = sym.SIDC.PartBString;  							// Build a symbol using the 2525D SIDC' to see if reverse  							// conversion works.  							Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  							if (sym2 != null) {  								cSIDCOut = sym2.LegacySIDC;  								symbolName = sym2.Names ["Entity"];  								modOneName = sym2.Names ["ModifierOne"];  								modTwoName = sym2.Names ["ModifierTwo"];  								if (cSIDCIn == cSIDCOut) {  									status = "pass";  									passCount++;  								} else if (sym2.LegacySIDCs.Count > 1) {  									bool match = false;  									foreach (string sidc in sym2.LegacySIDCs) {  										if (cSIDCIn == sidc) {  											match = true;  											break;  										}  									}  									if (match) {  										status = "pass (multiple)";  										passWithConditionCount++;  									} else {  										status = "FAIL";  										failCount++;  									}  								} else {  									status = "FAIL";  									failCount++;  								}  							} else {  								status = "Error making 2525D";  								derrorCount++;  							}  						} else {  							status = "Retired";  							dFirst10 = SIDC.INVALID.PartAString;  							dSecond10 = SIDC.INVALID.PartBString;  							retiredCount++;  						}  					} else {  						status = "Error making 2525C";  						cerrorCount++;  					}  					stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  					stream.Flush ();  				}  			} else  				logger.Error ("Bad SIDC : " + cSIDCIn);  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: foreach (SymbolSet ss in _librarian.SymbolSets) {  	if (ss.LegacySymbols != null) {  		foreach (SymbolSetLegacySymbol legacy in ss.LegacySymbols) {  			string cSIDC = legacy.Label;  			string cSIDCIn = legacy.Label;  			// Create a proper 2525C SIDC for testing  			if (cSIDCIn == null)  				break;  			if (cSIDCIn.Length == 15) {  				if (cSIDCIn.Substring (1' 1) == "*")  					cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  				cSIDCIn = cSIDCIn.Replace ('*'' '-');  				foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  					string dFirst10 = "";  					string dSecond10 = "";  					string cSIDCOut = "";  					string status = "";  					string symbolName = "";  					string modOneName = "";  					string modTwoName = "";  					totalCount++;  					cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  					cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  					if (fcode.SchemaOverride != "") {  						cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  						cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  					}  					if (fcode.DimensionOverride != "") {  						cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  						cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  					}  					// Build a symbol using a 2525C SIDC  					Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  					if (sym != null) {  						if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  							dFirst10 = sym.SIDC.PartAString;  							dSecond10 = sym.SIDC.PartBString;  							// Build a symbol using the 2525D SIDC' to see if reverse  							// conversion works.  							Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  							if (sym2 != null) {  								cSIDCOut = sym2.LegacySIDC;  								symbolName = sym2.Names ["Entity"];  								modOneName = sym2.Names ["ModifierOne"];  								modTwoName = sym2.Names ["ModifierTwo"];  								if (cSIDCIn == cSIDCOut) {  									status = "pass";  									passCount++;  								} else if (sym2.LegacySIDCs.Count > 1) {  									bool match = false;  									foreach (string sidc in sym2.LegacySIDCs) {  										if (cSIDCIn == sidc) {  											match = true;  											break;  										}  									}  									if (match) {  										status = "pass (multiple)";  										passWithConditionCount++;  									} else {  										status = "FAIL";  										failCount++;  									}  								} else {  									status = "FAIL";  									failCount++;  								}  							} else {  								status = "Error making 2525D";  								derrorCount++;  							}  						} else {  							status = "Retired";  							dFirst10 = SIDC.INVALID.PartAString;  							dSecond10 = SIDC.INVALID.PartBString;  							retiredCount++;  						}  					} else {  						status = "Error making 2525C";  						cerrorCount++;  					}  					stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  					stream.Flush ();  				}  			} else  				logger.Error ("Bad SIDC : " + cSIDCIn);  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: foreach (SymbolSet ss in _librarian.SymbolSets) {  	if (ss.LegacySymbols != null) {  		foreach (SymbolSetLegacySymbol legacy in ss.LegacySymbols) {  			string cSIDC = legacy.Label;  			string cSIDCIn = legacy.Label;  			// Create a proper 2525C SIDC for testing  			if (cSIDCIn == null)  				break;  			if (cSIDCIn.Length == 15) {  				if (cSIDCIn.Substring (1' 1) == "*")  					cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  				cSIDCIn = cSIDCIn.Replace ('*'' '-');  				foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  					string dFirst10 = "";  					string dSecond10 = "";  					string cSIDCOut = "";  					string status = "";  					string symbolName = "";  					string modOneName = "";  					string modTwoName = "";  					totalCount++;  					cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  					cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  					if (fcode.SchemaOverride != "") {  						cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  						cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  					}  					if (fcode.DimensionOverride != "") {  						cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  						cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  					}  					// Build a symbol using a 2525C SIDC  					Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  					if (sym != null) {  						if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  							dFirst10 = sym.SIDC.PartAString;  							dSecond10 = sym.SIDC.PartBString;  							// Build a symbol using the 2525D SIDC' to see if reverse  							// conversion works.  							Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  							if (sym2 != null) {  								cSIDCOut = sym2.LegacySIDC;  								symbolName = sym2.Names ["Entity"];  								modOneName = sym2.Names ["ModifierOne"];  								modTwoName = sym2.Names ["ModifierTwo"];  								if (cSIDCIn == cSIDCOut) {  									status = "pass";  									passCount++;  								} else if (sym2.LegacySIDCs.Count > 1) {  									bool match = false;  									foreach (string sidc in sym2.LegacySIDCs) {  										if (cSIDCIn == sidc) {  											match = true;  											break;  										}  									}  									if (match) {  										status = "pass (multiple)";  										passWithConditionCount++;  									} else {  										status = "FAIL";  										failCount++;  									}  								} else {  									status = "FAIL";  									failCount++;  								}  							} else {  								status = "Error making 2525D";  								derrorCount++;  							}  						} else {  							status = "Retired";  							dFirst10 = SIDC.INVALID.PartAString;  							dSecond10 = SIDC.INVALID.PartBString;  							retiredCount++;  						}  					} else {  						status = "Error making 2525C";  						cerrorCount++;  					}  					stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  					stream.Flush ();  				}  			} else  				logger.Error ("Bad SIDC : " + cSIDCIn);  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: foreach (SymbolSet ss in _librarian.SymbolSets) {  	if (ss.LegacySymbols != null) {  		foreach (SymbolSetLegacySymbol legacy in ss.LegacySymbols) {  			string cSIDC = legacy.Label;  			string cSIDCIn = legacy.Label;  			// Create a proper 2525C SIDC for testing  			if (cSIDCIn == null)  				break;  			if (cSIDCIn.Length == 15) {  				if (cSIDCIn.Substring (1' 1) == "*")  					cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  				cSIDCIn = cSIDCIn.Replace ('*'' '-');  				foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  					string dFirst10 = "";  					string dSecond10 = "";  					string cSIDCOut = "";  					string status = "";  					string symbolName = "";  					string modOneName = "";  					string modTwoName = "";  					totalCount++;  					cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  					cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  					if (fcode.SchemaOverride != "") {  						cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  						cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  					}  					if (fcode.DimensionOverride != "") {  						cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  						cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  					}  					// Build a symbol using a 2525C SIDC  					Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  					if (sym != null) {  						if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  							dFirst10 = sym.SIDC.PartAString;  							dSecond10 = sym.SIDC.PartBString;  							// Build a symbol using the 2525D SIDC' to see if reverse  							// conversion works.  							Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  							if (sym2 != null) {  								cSIDCOut = sym2.LegacySIDC;  								symbolName = sym2.Names ["Entity"];  								modOneName = sym2.Names ["ModifierOne"];  								modTwoName = sym2.Names ["ModifierTwo"];  								if (cSIDCIn == cSIDCOut) {  									status = "pass";  									passCount++;  								} else if (sym2.LegacySIDCs.Count > 1) {  									bool match = false;  									foreach (string sidc in sym2.LegacySIDCs) {  										if (cSIDCIn == sidc) {  											match = true;  											break;  										}  									}  									if (match) {  										status = "pass (multiple)";  										passWithConditionCount++;  									} else {  										status = "FAIL";  										failCount++;  									}  								} else {  									status = "FAIL";  									failCount++;  								}  							} else {  								status = "Error making 2525D";  								derrorCount++;  							}  						} else {  							status = "Retired";  							dFirst10 = SIDC.INVALID.PartAString;  							dSecond10 = SIDC.INVALID.PartBString;  							retiredCount++;  						}  					} else {  						status = "Error making 2525C";  						cerrorCount++;  					}  					stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  					stream.Flush ();  				}  			} else  				logger.Error ("Bad SIDC : " + cSIDCIn);  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: foreach (SymbolSet ss in _librarian.SymbolSets) {  	if (ss.LegacySymbols != null) {  		foreach (SymbolSetLegacySymbol legacy in ss.LegacySymbols) {  			string cSIDC = legacy.Label;  			string cSIDCIn = legacy.Label;  			// Create a proper 2525C SIDC for testing  			if (cSIDCIn == null)  				break;  			if (cSIDCIn.Length == 15) {  				if (cSIDCIn.Substring (1' 1) == "*")  					cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  				cSIDCIn = cSIDCIn.Replace ('*'' '-');  				foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  					string dFirst10 = "";  					string dSecond10 = "";  					string cSIDCOut = "";  					string status = "";  					string symbolName = "";  					string modOneName = "";  					string modTwoName = "";  					totalCount++;  					cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  					cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  					if (fcode.SchemaOverride != "") {  						cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  						cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  					}  					if (fcode.DimensionOverride != "") {  						cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  						cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  					}  					// Build a symbol using a 2525C SIDC  					Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  					if (sym != null) {  						if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  							dFirst10 = sym.SIDC.PartAString;  							dSecond10 = sym.SIDC.PartBString;  							// Build a symbol using the 2525D SIDC' to see if reverse  							// conversion works.  							Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  							if (sym2 != null) {  								cSIDCOut = sym2.LegacySIDC;  								symbolName = sym2.Names ["Entity"];  								modOneName = sym2.Names ["ModifierOne"];  								modTwoName = sym2.Names ["ModifierTwo"];  								if (cSIDCIn == cSIDCOut) {  									status = "pass";  									passCount++;  								} else if (sym2.LegacySIDCs.Count > 1) {  									bool match = false;  									foreach (string sidc in sym2.LegacySIDCs) {  										if (cSIDCIn == sidc) {  											match = true;  											break;  										}  									}  									if (match) {  										status = "pass (multiple)";  										passWithConditionCount++;  									} else {  										status = "FAIL";  										failCount++;  									}  								} else {  									status = "FAIL";  									failCount++;  								}  							} else {  								status = "Error making 2525D";  								derrorCount++;  							}  						} else {  							status = "Retired";  							dFirst10 = SIDC.INVALID.PartAString;  							dSecond10 = SIDC.INVALID.PartBString;  							retiredCount++;  						}  					} else {  						status = "Error making 2525C";  						cerrorCount++;  					}  					stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  					stream.Flush ();  				}  			} else  				logger.Error ("Bad SIDC : " + cSIDCIn);  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: foreach (SymbolSet ss in _librarian.SymbolSets) {  	if (ss.LegacySymbols != null) {  		foreach (SymbolSetLegacySymbol legacy in ss.LegacySymbols) {  			string cSIDC = legacy.Label;  			string cSIDCIn = legacy.Label;  			// Create a proper 2525C SIDC for testing  			if (cSIDCIn == null)  				break;  			if (cSIDCIn.Length == 15) {  				if (cSIDCIn.Substring (1' 1) == "*")  					cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  				cSIDCIn = cSIDCIn.Replace ('*'' '-');  				foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  					string dFirst10 = "";  					string dSecond10 = "";  					string cSIDCOut = "";  					string status = "";  					string symbolName = "";  					string modOneName = "";  					string modTwoName = "";  					totalCount++;  					cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  					cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  					if (fcode.SchemaOverride != "") {  						cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  						cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  					}  					if (fcode.DimensionOverride != "") {  						cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  						cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  					}  					// Build a symbol using a 2525C SIDC  					Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  					if (sym != null) {  						if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  							dFirst10 = sym.SIDC.PartAString;  							dSecond10 = sym.SIDC.PartBString;  							// Build a symbol using the 2525D SIDC' to see if reverse  							// conversion works.  							Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  							if (sym2 != null) {  								cSIDCOut = sym2.LegacySIDC;  								symbolName = sym2.Names ["Entity"];  								modOneName = sym2.Names ["ModifierOne"];  								modTwoName = sym2.Names ["ModifierTwo"];  								if (cSIDCIn == cSIDCOut) {  									status = "pass";  									passCount++;  								} else if (sym2.LegacySIDCs.Count > 1) {  									bool match = false;  									foreach (string sidc in sym2.LegacySIDCs) {  										if (cSIDCIn == sidc) {  											match = true;  											break;  										}  									}  									if (match) {  										status = "pass (multiple)";  										passWithConditionCount++;  									} else {  										status = "FAIL";  										failCount++;  									}  								} else {  									status = "FAIL";  									failCount++;  								}  							} else {  								status = "Error making 2525D";  								derrorCount++;  							}  						} else {  							status = "Retired";  							dFirst10 = SIDC.INVALID.PartAString;  							dSecond10 = SIDC.INVALID.PartBString;  							retiredCount++;  						}  					} else {  						status = "Error making 2525C";  						cerrorCount++;  					}  					stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  					stream.Flush ();  				}  			} else  				logger.Error ("Bad SIDC : " + cSIDCIn);  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: foreach (SymbolSet ss in _librarian.SymbolSets) {  	if (ss.LegacySymbols != null) {  		foreach (SymbolSetLegacySymbol legacy in ss.LegacySymbols) {  			string cSIDC = legacy.Label;  			string cSIDCIn = legacy.Label;  			// Create a proper 2525C SIDC for testing  			if (cSIDCIn == null)  				break;  			if (cSIDCIn.Length == 15) {  				if (cSIDCIn.Substring (1' 1) == "*")  					cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  				cSIDCIn = cSIDCIn.Replace ('*'' '-');  				foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  					string dFirst10 = "";  					string dSecond10 = "";  					string cSIDCOut = "";  					string status = "";  					string symbolName = "";  					string modOneName = "";  					string modTwoName = "";  					totalCount++;  					cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  					cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  					if (fcode.SchemaOverride != "") {  						cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  						cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  					}  					if (fcode.DimensionOverride != "") {  						cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  						cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  					}  					// Build a symbol using a 2525C SIDC  					Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  					if (sym != null) {  						if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  							dFirst10 = sym.SIDC.PartAString;  							dSecond10 = sym.SIDC.PartBString;  							// Build a symbol using the 2525D SIDC' to see if reverse  							// conversion works.  							Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  							if (sym2 != null) {  								cSIDCOut = sym2.LegacySIDC;  								symbolName = sym2.Names ["Entity"];  								modOneName = sym2.Names ["ModifierOne"];  								modTwoName = sym2.Names ["ModifierTwo"];  								if (cSIDCIn == cSIDCOut) {  									status = "pass";  									passCount++;  								} else if (sym2.LegacySIDCs.Count > 1) {  									bool match = false;  									foreach (string sidc in sym2.LegacySIDCs) {  										if (cSIDCIn == sidc) {  											match = true;  											break;  										}  									}  									if (match) {  										status = "pass (multiple)";  										passWithConditionCount++;  									} else {  										status = "FAIL";  										failCount++;  									}  								} else {  									status = "FAIL";  									failCount++;  								}  							} else {  								status = "Error making 2525D";  								derrorCount++;  							}  						} else {  							status = "Retired";  							dFirst10 = SIDC.INVALID.PartAString;  							dSecond10 = SIDC.INVALID.PartBString;  							retiredCount++;  						}  					} else {  						status = "Error making 2525C";  						cerrorCount++;  					}  					stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  					stream.Flush ();  				}  			} else  				logger.Error ("Bad SIDC : " + cSIDCIn);  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: if (ss.LegacySymbols != null) {  	foreach (SymbolSetLegacySymbol legacy in ss.LegacySymbols) {  		string cSIDC = legacy.Label;  		string cSIDCIn = legacy.Label;  		// Create a proper 2525C SIDC for testing  		if (cSIDCIn == null)  			break;  		if (cSIDCIn.Length == 15) {  			if (cSIDCIn.Substring (1' 1) == "*")  				cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  			cSIDCIn = cSIDCIn.Replace ('*'' '-');  			foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  				string dFirst10 = "";  				string dSecond10 = "";  				string cSIDCOut = "";  				string status = "";  				string symbolName = "";  				string modOneName = "";  				string modTwoName = "";  				totalCount++;  				cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  				cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  				if (fcode.SchemaOverride != "") {  					cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  					cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  				}  				if (fcode.DimensionOverride != "") {  					cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  					cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  				}  				// Build a symbol using a 2525C SIDC  				Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  				if (sym != null) {  					if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  						dFirst10 = sym.SIDC.PartAString;  						dSecond10 = sym.SIDC.PartBString;  						// Build a symbol using the 2525D SIDC' to see if reverse  						// conversion works.  						Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  						if (sym2 != null) {  							cSIDCOut = sym2.LegacySIDC;  							symbolName = sym2.Names ["Entity"];  							modOneName = sym2.Names ["ModifierOne"];  							modTwoName = sym2.Names ["ModifierTwo"];  							if (cSIDCIn == cSIDCOut) {  								status = "pass";  								passCount++;  							} else if (sym2.LegacySIDCs.Count > 1) {  								bool match = false;  								foreach (string sidc in sym2.LegacySIDCs) {  									if (cSIDCIn == sidc) {  										match = true;  										break;  									}  								}  								if (match) {  									status = "pass (multiple)";  									passWithConditionCount++;  								} else {  									status = "FAIL";  									failCount++;  								}  							} else {  								status = "FAIL";  								failCount++;  							}  						} else {  							status = "Error making 2525D";  							derrorCount++;  						}  					} else {  						status = "Retired";  						dFirst10 = SIDC.INVALID.PartAString;  						dSecond10 = SIDC.INVALID.PartBString;  						retiredCount++;  					}  				} else {  					status = "Error making 2525C";  					cerrorCount++;  				}  				stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  				stream.Flush ();  			}  		} else  			logger.Error ("Bad SIDC : " + cSIDCIn);  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: if (ss.LegacySymbols != null) {  	foreach (SymbolSetLegacySymbol legacy in ss.LegacySymbols) {  		string cSIDC = legacy.Label;  		string cSIDCIn = legacy.Label;  		// Create a proper 2525C SIDC for testing  		if (cSIDCIn == null)  			break;  		if (cSIDCIn.Length == 15) {  			if (cSIDCIn.Substring (1' 1) == "*")  				cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  			cSIDCIn = cSIDCIn.Replace ('*'' '-');  			foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  				string dFirst10 = "";  				string dSecond10 = "";  				string cSIDCOut = "";  				string status = "";  				string symbolName = "";  				string modOneName = "";  				string modTwoName = "";  				totalCount++;  				cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  				cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  				if (fcode.SchemaOverride != "") {  					cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  					cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  				}  				if (fcode.DimensionOverride != "") {  					cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  					cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  				}  				// Build a symbol using a 2525C SIDC  				Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  				if (sym != null) {  					if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  						dFirst10 = sym.SIDC.PartAString;  						dSecond10 = sym.SIDC.PartBString;  						// Build a symbol using the 2525D SIDC' to see if reverse  						// conversion works.  						Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  						if (sym2 != null) {  							cSIDCOut = sym2.LegacySIDC;  							symbolName = sym2.Names ["Entity"];  							modOneName = sym2.Names ["ModifierOne"];  							modTwoName = sym2.Names ["ModifierTwo"];  							if (cSIDCIn == cSIDCOut) {  								status = "pass";  								passCount++;  							} else if (sym2.LegacySIDCs.Count > 1) {  								bool match = false;  								foreach (string sidc in sym2.LegacySIDCs) {  									if (cSIDCIn == sidc) {  										match = true;  										break;  									}  								}  								if (match) {  									status = "pass (multiple)";  									passWithConditionCount++;  								} else {  									status = "FAIL";  									failCount++;  								}  							} else {  								status = "FAIL";  								failCount++;  							}  						} else {  							status = "Error making 2525D";  							derrorCount++;  						}  					} else {  						status = "Retired";  						dFirst10 = SIDC.INVALID.PartAString;  						dSecond10 = SIDC.INVALID.PartBString;  						retiredCount++;  					}  				} else {  					status = "Error making 2525C";  					cerrorCount++;  				}  				stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  				stream.Flush ();  			}  		} else  			logger.Error ("Bad SIDC : " + cSIDCIn);  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: if (ss.LegacySymbols != null) {  	foreach (SymbolSetLegacySymbol legacy in ss.LegacySymbols) {  		string cSIDC = legacy.Label;  		string cSIDCIn = legacy.Label;  		// Create a proper 2525C SIDC for testing  		if (cSIDCIn == null)  			break;  		if (cSIDCIn.Length == 15) {  			if (cSIDCIn.Substring (1' 1) == "*")  				cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  			cSIDCIn = cSIDCIn.Replace ('*'' '-');  			foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  				string dFirst10 = "";  				string dSecond10 = "";  				string cSIDCOut = "";  				string status = "";  				string symbolName = "";  				string modOneName = "";  				string modTwoName = "";  				totalCount++;  				cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  				cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  				if (fcode.SchemaOverride != "") {  					cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  					cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  				}  				if (fcode.DimensionOverride != "") {  					cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  					cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  				}  				// Build a symbol using a 2525C SIDC  				Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  				if (sym != null) {  					if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  						dFirst10 = sym.SIDC.PartAString;  						dSecond10 = sym.SIDC.PartBString;  						// Build a symbol using the 2525D SIDC' to see if reverse  						// conversion works.  						Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  						if (sym2 != null) {  							cSIDCOut = sym2.LegacySIDC;  							symbolName = sym2.Names ["Entity"];  							modOneName = sym2.Names ["ModifierOne"];  							modTwoName = sym2.Names ["ModifierTwo"];  							if (cSIDCIn == cSIDCOut) {  								status = "pass";  								passCount++;  							} else if (sym2.LegacySIDCs.Count > 1) {  								bool match = false;  								foreach (string sidc in sym2.LegacySIDCs) {  									if (cSIDCIn == sidc) {  										match = true;  										break;  									}  								}  								if (match) {  									status = "pass (multiple)";  									passWithConditionCount++;  								} else {  									status = "FAIL";  									failCount++;  								}  							} else {  								status = "FAIL";  								failCount++;  							}  						} else {  							status = "Error making 2525D";  							derrorCount++;  						}  					} else {  						status = "Retired";  						dFirst10 = SIDC.INVALID.PartAString;  						dSecond10 = SIDC.INVALID.PartBString;  						retiredCount++;  					}  				} else {  					status = "Error making 2525C";  					cerrorCount++;  				}  				stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  				stream.Flush ();  			}  		} else  			logger.Error ("Bad SIDC : " + cSIDCIn);  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: if (ss.LegacySymbols != null) {  	foreach (SymbolSetLegacySymbol legacy in ss.LegacySymbols) {  		string cSIDC = legacy.Label;  		string cSIDCIn = legacy.Label;  		// Create a proper 2525C SIDC for testing  		if (cSIDCIn == null)  			break;  		if (cSIDCIn.Length == 15) {  			if (cSIDCIn.Substring (1' 1) == "*")  				cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  			cSIDCIn = cSIDCIn.Replace ('*'' '-');  			foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  				string dFirst10 = "";  				string dSecond10 = "";  				string cSIDCOut = "";  				string status = "";  				string symbolName = "";  				string modOneName = "";  				string modTwoName = "";  				totalCount++;  				cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  				cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  				if (fcode.SchemaOverride != "") {  					cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  					cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  				}  				if (fcode.DimensionOverride != "") {  					cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  					cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  				}  				// Build a symbol using a 2525C SIDC  				Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  				if (sym != null) {  					if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  						dFirst10 = sym.SIDC.PartAString;  						dSecond10 = sym.SIDC.PartBString;  						// Build a symbol using the 2525D SIDC' to see if reverse  						// conversion works.  						Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  						if (sym2 != null) {  							cSIDCOut = sym2.LegacySIDC;  							symbolName = sym2.Names ["Entity"];  							modOneName = sym2.Names ["ModifierOne"];  							modTwoName = sym2.Names ["ModifierTwo"];  							if (cSIDCIn == cSIDCOut) {  								status = "pass";  								passCount++;  							} else if (sym2.LegacySIDCs.Count > 1) {  								bool match = false;  								foreach (string sidc in sym2.LegacySIDCs) {  									if (cSIDCIn == sidc) {  										match = true;  										break;  									}  								}  								if (match) {  									status = "pass (multiple)";  									passWithConditionCount++;  								} else {  									status = "FAIL";  									failCount++;  								}  							} else {  								status = "FAIL";  								failCount++;  							}  						} else {  							status = "Error making 2525D";  							derrorCount++;  						}  					} else {  						status = "Retired";  						dFirst10 = SIDC.INVALID.PartAString;  						dSecond10 = SIDC.INVALID.PartBString;  						retiredCount++;  					}  				} else {  					status = "Error making 2525C";  					cerrorCount++;  				}  				stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  				stream.Flush ();  			}  		} else  			logger.Error ("Bad SIDC : " + cSIDCIn);  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: if (ss.LegacySymbols != null) {  	foreach (SymbolSetLegacySymbol legacy in ss.LegacySymbols) {  		string cSIDC = legacy.Label;  		string cSIDCIn = legacy.Label;  		// Create a proper 2525C SIDC for testing  		if (cSIDCIn == null)  			break;  		if (cSIDCIn.Length == 15) {  			if (cSIDCIn.Substring (1' 1) == "*")  				cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  			cSIDCIn = cSIDCIn.Replace ('*'' '-');  			foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  				string dFirst10 = "";  				string dSecond10 = "";  				string cSIDCOut = "";  				string status = "";  				string symbolName = "";  				string modOneName = "";  				string modTwoName = "";  				totalCount++;  				cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  				cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  				if (fcode.SchemaOverride != "") {  					cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  					cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  				}  				if (fcode.DimensionOverride != "") {  					cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  					cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  				}  				// Build a symbol using a 2525C SIDC  				Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  				if (sym != null) {  					if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  						dFirst10 = sym.SIDC.PartAString;  						dSecond10 = sym.SIDC.PartBString;  						// Build a symbol using the 2525D SIDC' to see if reverse  						// conversion works.  						Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  						if (sym2 != null) {  							cSIDCOut = sym2.LegacySIDC;  							symbolName = sym2.Names ["Entity"];  							modOneName = sym2.Names ["ModifierOne"];  							modTwoName = sym2.Names ["ModifierTwo"];  							if (cSIDCIn == cSIDCOut) {  								status = "pass";  								passCount++;  							} else if (sym2.LegacySIDCs.Count > 1) {  								bool match = false;  								foreach (string sidc in sym2.LegacySIDCs) {  									if (cSIDCIn == sidc) {  										match = true;  										break;  									}  								}  								if (match) {  									status = "pass (multiple)";  									passWithConditionCount++;  								} else {  									status = "FAIL";  									failCount++;  								}  							} else {  								status = "FAIL";  								failCount++;  							}  						} else {  							status = "Error making 2525D";  							derrorCount++;  						}  					} else {  						status = "Retired";  						dFirst10 = SIDC.INVALID.PartAString;  						dSecond10 = SIDC.INVALID.PartBString;  						retiredCount++;  					}  				} else {  					status = "Error making 2525C";  					cerrorCount++;  				}  				stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  				stream.Flush ();  			}  		} else  			logger.Error ("Bad SIDC : " + cSIDCIn);  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: if (ss.LegacySymbols != null) {  	foreach (SymbolSetLegacySymbol legacy in ss.LegacySymbols) {  		string cSIDC = legacy.Label;  		string cSIDCIn = legacy.Label;  		// Create a proper 2525C SIDC for testing  		if (cSIDCIn == null)  			break;  		if (cSIDCIn.Length == 15) {  			if (cSIDCIn.Substring (1' 1) == "*")  				cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  			cSIDCIn = cSIDCIn.Replace ('*'' '-');  			foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  				string dFirst10 = "";  				string dSecond10 = "";  				string cSIDCOut = "";  				string status = "";  				string symbolName = "";  				string modOneName = "";  				string modTwoName = "";  				totalCount++;  				cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  				cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  				if (fcode.SchemaOverride != "") {  					cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  					cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  				}  				if (fcode.DimensionOverride != "") {  					cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  					cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  				}  				// Build a symbol using a 2525C SIDC  				Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  				if (sym != null) {  					if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  						dFirst10 = sym.SIDC.PartAString;  						dSecond10 = sym.SIDC.PartBString;  						// Build a symbol using the 2525D SIDC' to see if reverse  						// conversion works.  						Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  						if (sym2 != null) {  							cSIDCOut = sym2.LegacySIDC;  							symbolName = sym2.Names ["Entity"];  							modOneName = sym2.Names ["ModifierOne"];  							modTwoName = sym2.Names ["ModifierTwo"];  							if (cSIDCIn == cSIDCOut) {  								status = "pass";  								passCount++;  							} else if (sym2.LegacySIDCs.Count > 1) {  								bool match = false;  								foreach (string sidc in sym2.LegacySIDCs) {  									if (cSIDCIn == sidc) {  										match = true;  										break;  									}  								}  								if (match) {  									status = "pass (multiple)";  									passWithConditionCount++;  								} else {  									status = "FAIL";  									failCount++;  								}  							} else {  								status = "FAIL";  								failCount++;  							}  						} else {  							status = "Error making 2525D";  							derrorCount++;  						}  					} else {  						status = "Retired";  						dFirst10 = SIDC.INVALID.PartAString;  						dSecond10 = SIDC.INVALID.PartBString;  						retiredCount++;  					}  				} else {  					status = "Error making 2525C";  					cerrorCount++;  				}  				stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  				stream.Flush ();  			}  		} else  			logger.Error ("Bad SIDC : " + cSIDCIn);  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: if (ss.LegacySymbols != null) {  	foreach (SymbolSetLegacySymbol legacy in ss.LegacySymbols) {  		string cSIDC = legacy.Label;  		string cSIDCIn = legacy.Label;  		// Create a proper 2525C SIDC for testing  		if (cSIDCIn == null)  			break;  		if (cSIDCIn.Length == 15) {  			if (cSIDCIn.Substring (1' 1) == "*")  				cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  			cSIDCIn = cSIDCIn.Replace ('*'' '-');  			foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  				string dFirst10 = "";  				string dSecond10 = "";  				string cSIDCOut = "";  				string status = "";  				string symbolName = "";  				string modOneName = "";  				string modTwoName = "";  				totalCount++;  				cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  				cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  				if (fcode.SchemaOverride != "") {  					cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  					cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  				}  				if (fcode.DimensionOverride != "") {  					cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  					cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  				}  				// Build a symbol using a 2525C SIDC  				Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  				if (sym != null) {  					if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  						dFirst10 = sym.SIDC.PartAString;  						dSecond10 = sym.SIDC.PartBString;  						// Build a symbol using the 2525D SIDC' to see if reverse  						// conversion works.  						Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  						if (sym2 != null) {  							cSIDCOut = sym2.LegacySIDC;  							symbolName = sym2.Names ["Entity"];  							modOneName = sym2.Names ["ModifierOne"];  							modTwoName = sym2.Names ["ModifierTwo"];  							if (cSIDCIn == cSIDCOut) {  								status = "pass";  								passCount++;  							} else if (sym2.LegacySIDCs.Count > 1) {  								bool match = false;  								foreach (string sidc in sym2.LegacySIDCs) {  									if (cSIDCIn == sidc) {  										match = true;  										break;  									}  								}  								if (match) {  									status = "pass (multiple)";  									passWithConditionCount++;  								} else {  									status = "FAIL";  									failCount++;  								}  							} else {  								status = "FAIL";  								failCount++;  							}  						} else {  							status = "Error making 2525D";  							derrorCount++;  						}  					} else {  						status = "Retired";  						dFirst10 = SIDC.INVALID.PartAString;  						dSecond10 = SIDC.INVALID.PartBString;  						retiredCount++;  					}  				} else {  					status = "Error making 2525C";  					cerrorCount++;  				}  				stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  				stream.Flush ();  			}  		} else  			logger.Error ("Bad SIDC : " + cSIDCIn);  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: if (ss.LegacySymbols != null) {  	foreach (SymbolSetLegacySymbol legacy in ss.LegacySymbols) {  		string cSIDC = legacy.Label;  		string cSIDCIn = legacy.Label;  		// Create a proper 2525C SIDC for testing  		if (cSIDCIn == null)  			break;  		if (cSIDCIn.Length == 15) {  			if (cSIDCIn.Substring (1' 1) == "*")  				cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  			cSIDCIn = cSIDCIn.Replace ('*'' '-');  			foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  				string dFirst10 = "";  				string dSecond10 = "";  				string cSIDCOut = "";  				string status = "";  				string symbolName = "";  				string modOneName = "";  				string modTwoName = "";  				totalCount++;  				cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  				cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  				if (fcode.SchemaOverride != "") {  					cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  					cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  				}  				if (fcode.DimensionOverride != "") {  					cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  					cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  				}  				// Build a symbol using a 2525C SIDC  				Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  				if (sym != null) {  					if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  						dFirst10 = sym.SIDC.PartAString;  						dSecond10 = sym.SIDC.PartBString;  						// Build a symbol using the 2525D SIDC' to see if reverse  						// conversion works.  						Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  						if (sym2 != null) {  							cSIDCOut = sym2.LegacySIDC;  							symbolName = sym2.Names ["Entity"];  							modOneName = sym2.Names ["ModifierOne"];  							modTwoName = sym2.Names ["ModifierTwo"];  							if (cSIDCIn == cSIDCOut) {  								status = "pass";  								passCount++;  							} else if (sym2.LegacySIDCs.Count > 1) {  								bool match = false;  								foreach (string sidc in sym2.LegacySIDCs) {  									if (cSIDCIn == sidc) {  										match = true;  										break;  									}  								}  								if (match) {  									status = "pass (multiple)";  									passWithConditionCount++;  								} else {  									status = "FAIL";  									failCount++;  								}  							} else {  								status = "FAIL";  								failCount++;  							}  						} else {  							status = "Error making 2525D";  							derrorCount++;  						}  					} else {  						status = "Retired";  						dFirst10 = SIDC.INVALID.PartAString;  						dSecond10 = SIDC.INVALID.PartBString;  						retiredCount++;  					}  				} else {  					status = "Error making 2525C";  					cerrorCount++;  				}  				stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  				stream.Flush ();  			}  		} else  			logger.Error ("Bad SIDC : " + cSIDCIn);  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: if (ss.LegacySymbols != null) {  	foreach (SymbolSetLegacySymbol legacy in ss.LegacySymbols) {  		string cSIDC = legacy.Label;  		string cSIDCIn = legacy.Label;  		// Create a proper 2525C SIDC for testing  		if (cSIDCIn == null)  			break;  		if (cSIDCIn.Length == 15) {  			if (cSIDCIn.Substring (1' 1) == "*")  				cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  			cSIDCIn = cSIDCIn.Replace ('*'' '-');  			foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  				string dFirst10 = "";  				string dSecond10 = "";  				string cSIDCOut = "";  				string status = "";  				string symbolName = "";  				string modOneName = "";  				string modTwoName = "";  				totalCount++;  				cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  				cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  				if (fcode.SchemaOverride != "") {  					cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  					cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  				}  				if (fcode.DimensionOverride != "") {  					cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  					cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  				}  				// Build a symbol using a 2525C SIDC  				Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  				if (sym != null) {  					if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  						dFirst10 = sym.SIDC.PartAString;  						dSecond10 = sym.SIDC.PartBString;  						// Build a symbol using the 2525D SIDC' to see if reverse  						// conversion works.  						Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  						if (sym2 != null) {  							cSIDCOut = sym2.LegacySIDC;  							symbolName = sym2.Names ["Entity"];  							modOneName = sym2.Names ["ModifierOne"];  							modTwoName = sym2.Names ["ModifierTwo"];  							if (cSIDCIn == cSIDCOut) {  								status = "pass";  								passCount++;  							} else if (sym2.LegacySIDCs.Count > 1) {  								bool match = false;  								foreach (string sidc in sym2.LegacySIDCs) {  									if (cSIDCIn == sidc) {  										match = true;  										break;  									}  								}  								if (match) {  									status = "pass (multiple)";  									passWithConditionCount++;  								} else {  									status = "FAIL";  									failCount++;  								}  							} else {  								status = "FAIL";  								failCount++;  							}  						} else {  							status = "Error making 2525D";  							derrorCount++;  						}  					} else {  						status = "Retired";  						dFirst10 = SIDC.INVALID.PartAString;  						dSecond10 = SIDC.INVALID.PartBString;  						retiredCount++;  					}  				} else {  					status = "Error making 2525C";  					cerrorCount++;  				}  				stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  				stream.Flush ();  			}  		} else  			logger.Error ("Bad SIDC : " + cSIDCIn);  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: if (ss.LegacySymbols != null) {  	foreach (SymbolSetLegacySymbol legacy in ss.LegacySymbols) {  		string cSIDC = legacy.Label;  		string cSIDCIn = legacy.Label;  		// Create a proper 2525C SIDC for testing  		if (cSIDCIn == null)  			break;  		if (cSIDCIn.Length == 15) {  			if (cSIDCIn.Substring (1' 1) == "*")  				cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  			cSIDCIn = cSIDCIn.Replace ('*'' '-');  			foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  				string dFirst10 = "";  				string dSecond10 = "";  				string cSIDCOut = "";  				string status = "";  				string symbolName = "";  				string modOneName = "";  				string modTwoName = "";  				totalCount++;  				cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  				cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  				if (fcode.SchemaOverride != "") {  					cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  					cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  				}  				if (fcode.DimensionOverride != "") {  					cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  					cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  				}  				// Build a symbol using a 2525C SIDC  				Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  				if (sym != null) {  					if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  						dFirst10 = sym.SIDC.PartAString;  						dSecond10 = sym.SIDC.PartBString;  						// Build a symbol using the 2525D SIDC' to see if reverse  						// conversion works.  						Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  						if (sym2 != null) {  							cSIDCOut = sym2.LegacySIDC;  							symbolName = sym2.Names ["Entity"];  							modOneName = sym2.Names ["ModifierOne"];  							modTwoName = sym2.Names ["ModifierTwo"];  							if (cSIDCIn == cSIDCOut) {  								status = "pass";  								passCount++;  							} else if (sym2.LegacySIDCs.Count > 1) {  								bool match = false;  								foreach (string sidc in sym2.LegacySIDCs) {  									if (cSIDCIn == sidc) {  										match = true;  										break;  									}  								}  								if (match) {  									status = "pass (multiple)";  									passWithConditionCount++;  								} else {  									status = "FAIL";  									failCount++;  								}  							} else {  								status = "FAIL";  								failCount++;  							}  						} else {  							status = "Error making 2525D";  							derrorCount++;  						}  					} else {  						status = "Retired";  						dFirst10 = SIDC.INVALID.PartAString;  						dSecond10 = SIDC.INVALID.PartBString;  						retiredCount++;  					}  				} else {  					status = "Error making 2525C";  					cerrorCount++;  				}  				stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  				stream.Flush ();  			}  		} else  			logger.Error ("Bad SIDC : " + cSIDCIn);  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: if (ss.LegacySymbols != null) {  	foreach (SymbolSetLegacySymbol legacy in ss.LegacySymbols) {  		string cSIDC = legacy.Label;  		string cSIDCIn = legacy.Label;  		// Create a proper 2525C SIDC for testing  		if (cSIDCIn == null)  			break;  		if (cSIDCIn.Length == 15) {  			if (cSIDCIn.Substring (1' 1) == "*")  				cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  			cSIDCIn = cSIDCIn.Replace ('*'' '-');  			foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  				string dFirst10 = "";  				string dSecond10 = "";  				string cSIDCOut = "";  				string status = "";  				string symbolName = "";  				string modOneName = "";  				string modTwoName = "";  				totalCount++;  				cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  				cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  				if (fcode.SchemaOverride != "") {  					cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  					cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  				}  				if (fcode.DimensionOverride != "") {  					cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  					cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  				}  				// Build a symbol using a 2525C SIDC  				Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  				if (sym != null) {  					if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  						dFirst10 = sym.SIDC.PartAString;  						dSecond10 = sym.SIDC.PartBString;  						// Build a symbol using the 2525D SIDC' to see if reverse  						// conversion works.  						Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  						if (sym2 != null) {  							cSIDCOut = sym2.LegacySIDC;  							symbolName = sym2.Names ["Entity"];  							modOneName = sym2.Names ["ModifierOne"];  							modTwoName = sym2.Names ["ModifierTwo"];  							if (cSIDCIn == cSIDCOut) {  								status = "pass";  								passCount++;  							} else if (sym2.LegacySIDCs.Count > 1) {  								bool match = false;  								foreach (string sidc in sym2.LegacySIDCs) {  									if (cSIDCIn == sidc) {  										match = true;  										break;  									}  								}  								if (match) {  									status = "pass (multiple)";  									passWithConditionCount++;  								} else {  									status = "FAIL";  									failCount++;  								}  							} else {  								status = "FAIL";  								failCount++;  							}  						} else {  							status = "Error making 2525D";  							derrorCount++;  						}  					} else {  						status = "Retired";  						dFirst10 = SIDC.INVALID.PartAString;  						dSecond10 = SIDC.INVALID.PartBString;  						retiredCount++;  					}  				} else {  					status = "Error making 2525C";  					cerrorCount++;  				}  				stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  				stream.Flush ();  			}  		} else  			logger.Error ("Bad SIDC : " + cSIDCIn);  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: if (ss.LegacySymbols != null) {  	foreach (SymbolSetLegacySymbol legacy in ss.LegacySymbols) {  		string cSIDC = legacy.Label;  		string cSIDCIn = legacy.Label;  		// Create a proper 2525C SIDC for testing  		if (cSIDCIn == null)  			break;  		if (cSIDCIn.Length == 15) {  			if (cSIDCIn.Substring (1' 1) == "*")  				cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  			cSIDCIn = cSIDCIn.Replace ('*'' '-');  			foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  				string dFirst10 = "";  				string dSecond10 = "";  				string cSIDCOut = "";  				string status = "";  				string symbolName = "";  				string modOneName = "";  				string modTwoName = "";  				totalCount++;  				cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  				cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  				if (fcode.SchemaOverride != "") {  					cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  					cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  				}  				if (fcode.DimensionOverride != "") {  					cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  					cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  				}  				// Build a symbol using a 2525C SIDC  				Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  				if (sym != null) {  					if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  						dFirst10 = sym.SIDC.PartAString;  						dSecond10 = sym.SIDC.PartBString;  						// Build a symbol using the 2525D SIDC' to see if reverse  						// conversion works.  						Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  						if (sym2 != null) {  							cSIDCOut = sym2.LegacySIDC;  							symbolName = sym2.Names ["Entity"];  							modOneName = sym2.Names ["ModifierOne"];  							modTwoName = sym2.Names ["ModifierTwo"];  							if (cSIDCIn == cSIDCOut) {  								status = "pass";  								passCount++;  							} else if (sym2.LegacySIDCs.Count > 1) {  								bool match = false;  								foreach (string sidc in sym2.LegacySIDCs) {  									if (cSIDCIn == sidc) {  										match = true;  										break;  									}  								}  								if (match) {  									status = "pass (multiple)";  									passWithConditionCount++;  								} else {  									status = "FAIL";  									failCount++;  								}  							} else {  								status = "FAIL";  								failCount++;  							}  						} else {  							status = "Error making 2525D";  							derrorCount++;  						}  					} else {  						status = "Retired";  						dFirst10 = SIDC.INVALID.PartAString;  						dSecond10 = SIDC.INVALID.PartBString;  						retiredCount++;  					}  				} else {  					status = "Error making 2525C";  					cerrorCount++;  				}  				stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  				stream.Flush ();  			}  		} else  			logger.Error ("Bad SIDC : " + cSIDCIn);  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: if (ss.LegacySymbols != null) {  	foreach (SymbolSetLegacySymbol legacy in ss.LegacySymbols) {  		string cSIDC = legacy.Label;  		string cSIDCIn = legacy.Label;  		// Create a proper 2525C SIDC for testing  		if (cSIDCIn == null)  			break;  		if (cSIDCIn.Length == 15) {  			if (cSIDCIn.Substring (1' 1) == "*")  				cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  			cSIDCIn = cSIDCIn.Replace ('*'' '-');  			foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  				string dFirst10 = "";  				string dSecond10 = "";  				string cSIDCOut = "";  				string status = "";  				string symbolName = "";  				string modOneName = "";  				string modTwoName = "";  				totalCount++;  				cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  				cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  				if (fcode.SchemaOverride != "") {  					cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  					cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  				}  				if (fcode.DimensionOverride != "") {  					cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  					cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  				}  				// Build a symbol using a 2525C SIDC  				Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  				if (sym != null) {  					if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  						dFirst10 = sym.SIDC.PartAString;  						dSecond10 = sym.SIDC.PartBString;  						// Build a symbol using the 2525D SIDC' to see if reverse  						// conversion works.  						Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  						if (sym2 != null) {  							cSIDCOut = sym2.LegacySIDC;  							symbolName = sym2.Names ["Entity"];  							modOneName = sym2.Names ["ModifierOne"];  							modTwoName = sym2.Names ["ModifierTwo"];  							if (cSIDCIn == cSIDCOut) {  								status = "pass";  								passCount++;  							} else if (sym2.LegacySIDCs.Count > 1) {  								bool match = false;  								foreach (string sidc in sym2.LegacySIDCs) {  									if (cSIDCIn == sidc) {  										match = true;  										break;  									}  								}  								if (match) {  									status = "pass (multiple)";  									passWithConditionCount++;  								} else {  									status = "FAIL";  									failCount++;  								}  							} else {  								status = "FAIL";  								failCount++;  							}  						} else {  							status = "Error making 2525D";  							derrorCount++;  						}  					} else {  						status = "Retired";  						dFirst10 = SIDC.INVALID.PartAString;  						dSecond10 = SIDC.INVALID.PartBString;  						retiredCount++;  					}  				} else {  					status = "Error making 2525C";  					cerrorCount++;  				}  				stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  				stream.Flush ();  			}  		} else  			logger.Error ("Bad SIDC : " + cSIDCIn);  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: if (ss.LegacySymbols != null) {  	foreach (SymbolSetLegacySymbol legacy in ss.LegacySymbols) {  		string cSIDC = legacy.Label;  		string cSIDCIn = legacy.Label;  		// Create a proper 2525C SIDC for testing  		if (cSIDCIn == null)  			break;  		if (cSIDCIn.Length == 15) {  			if (cSIDCIn.Substring (1' 1) == "*")  				cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  			cSIDCIn = cSIDCIn.Replace ('*'' '-');  			foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  				string dFirst10 = "";  				string dSecond10 = "";  				string cSIDCOut = "";  				string status = "";  				string symbolName = "";  				string modOneName = "";  				string modTwoName = "";  				totalCount++;  				cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  				cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  				if (fcode.SchemaOverride != "") {  					cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  					cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  				}  				if (fcode.DimensionOverride != "") {  					cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  					cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  				}  				// Build a symbol using a 2525C SIDC  				Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  				if (sym != null) {  					if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  						dFirst10 = sym.SIDC.PartAString;  						dSecond10 = sym.SIDC.PartBString;  						// Build a symbol using the 2525D SIDC' to see if reverse  						// conversion works.  						Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  						if (sym2 != null) {  							cSIDCOut = sym2.LegacySIDC;  							symbolName = sym2.Names ["Entity"];  							modOneName = sym2.Names ["ModifierOne"];  							modTwoName = sym2.Names ["ModifierTwo"];  							if (cSIDCIn == cSIDCOut) {  								status = "pass";  								passCount++;  							} else if (sym2.LegacySIDCs.Count > 1) {  								bool match = false;  								foreach (string sidc in sym2.LegacySIDCs) {  									if (cSIDCIn == sidc) {  										match = true;  										break;  									}  								}  								if (match) {  									status = "pass (multiple)";  									passWithConditionCount++;  								} else {  									status = "FAIL";  									failCount++;  								}  							} else {  								status = "FAIL";  								failCount++;  							}  						} else {  							status = "Error making 2525D";  							derrorCount++;  						}  					} else {  						status = "Retired";  						dFirst10 = SIDC.INVALID.PartAString;  						dSecond10 = SIDC.INVALID.PartBString;  						retiredCount++;  					}  				} else {  					status = "Error making 2525C";  					cerrorCount++;  				}  				stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  				stream.Flush ();  			}  		} else  			logger.Error ("Bad SIDC : " + cSIDCIn);  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: if (ss.LegacySymbols != null) {  	foreach (SymbolSetLegacySymbol legacy in ss.LegacySymbols) {  		string cSIDC = legacy.Label;  		string cSIDCIn = legacy.Label;  		// Create a proper 2525C SIDC for testing  		if (cSIDCIn == null)  			break;  		if (cSIDCIn.Length == 15) {  			if (cSIDCIn.Substring (1' 1) == "*")  				cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  			cSIDCIn = cSIDCIn.Replace ('*'' '-');  			foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  				string dFirst10 = "";  				string dSecond10 = "";  				string cSIDCOut = "";  				string status = "";  				string symbolName = "";  				string modOneName = "";  				string modTwoName = "";  				totalCount++;  				cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  				cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  				if (fcode.SchemaOverride != "") {  					cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  					cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  				}  				if (fcode.DimensionOverride != "") {  					cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  					cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  				}  				// Build a symbol using a 2525C SIDC  				Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  				if (sym != null) {  					if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  						dFirst10 = sym.SIDC.PartAString;  						dSecond10 = sym.SIDC.PartBString;  						// Build a symbol using the 2525D SIDC' to see if reverse  						// conversion works.  						Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  						if (sym2 != null) {  							cSIDCOut = sym2.LegacySIDC;  							symbolName = sym2.Names ["Entity"];  							modOneName = sym2.Names ["ModifierOne"];  							modTwoName = sym2.Names ["ModifierTwo"];  							if (cSIDCIn == cSIDCOut) {  								status = "pass";  								passCount++;  							} else if (sym2.LegacySIDCs.Count > 1) {  								bool match = false;  								foreach (string sidc in sym2.LegacySIDCs) {  									if (cSIDCIn == sidc) {  										match = true;  										break;  									}  								}  								if (match) {  									status = "pass (multiple)";  									passWithConditionCount++;  								} else {  									status = "FAIL";  									failCount++;  								}  							} else {  								status = "FAIL";  								failCount++;  							}  						} else {  							status = "Error making 2525D";  							derrorCount++;  						}  					} else {  						status = "Retired";  						dFirst10 = SIDC.INVALID.PartAString;  						dSecond10 = SIDC.INVALID.PartBString;  						retiredCount++;  					}  				} else {  					status = "Error making 2525C";  					cerrorCount++;  				}  				stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  				stream.Flush ();  			}  		} else  			logger.Error ("Bad SIDC : " + cSIDCIn);  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: if (ss.LegacySymbols != null) {  	foreach (SymbolSetLegacySymbol legacy in ss.LegacySymbols) {  		string cSIDC = legacy.Label;  		string cSIDCIn = legacy.Label;  		// Create a proper 2525C SIDC for testing  		if (cSIDCIn == null)  			break;  		if (cSIDCIn.Length == 15) {  			if (cSIDCIn.Substring (1' 1) == "*")  				cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  			cSIDCIn = cSIDCIn.Replace ('*'' '-');  			foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  				string dFirst10 = "";  				string dSecond10 = "";  				string cSIDCOut = "";  				string status = "";  				string symbolName = "";  				string modOneName = "";  				string modTwoName = "";  				totalCount++;  				cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  				cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  				if (fcode.SchemaOverride != "") {  					cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  					cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  				}  				if (fcode.DimensionOverride != "") {  					cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  					cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  				}  				// Build a symbol using a 2525C SIDC  				Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  				if (sym != null) {  					if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  						dFirst10 = sym.SIDC.PartAString;  						dSecond10 = sym.SIDC.PartBString;  						// Build a symbol using the 2525D SIDC' to see if reverse  						// conversion works.  						Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  						if (sym2 != null) {  							cSIDCOut = sym2.LegacySIDC;  							symbolName = sym2.Names ["Entity"];  							modOneName = sym2.Names ["ModifierOne"];  							modTwoName = sym2.Names ["ModifierTwo"];  							if (cSIDCIn == cSIDCOut) {  								status = "pass";  								passCount++;  							} else if (sym2.LegacySIDCs.Count > 1) {  								bool match = false;  								foreach (string sidc in sym2.LegacySIDCs) {  									if (cSIDCIn == sidc) {  										match = true;  										break;  									}  								}  								if (match) {  									status = "pass (multiple)";  									passWithConditionCount++;  								} else {  									status = "FAIL";  									failCount++;  								}  							} else {  								status = "FAIL";  								failCount++;  							}  						} else {  							status = "Error making 2525D";  							derrorCount++;  						}  					} else {  						status = "Retired";  						dFirst10 = SIDC.INVALID.PartAString;  						dSecond10 = SIDC.INVALID.PartBString;  						retiredCount++;  					}  				} else {  					status = "Error making 2525C";  					cerrorCount++;  				}  				stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  				stream.Flush ();  			}  		} else  			logger.Error ("Bad SIDC : " + cSIDCIn);  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: if (ss.LegacySymbols != null) {  	foreach (SymbolSetLegacySymbol legacy in ss.LegacySymbols) {  		string cSIDC = legacy.Label;  		string cSIDCIn = legacy.Label;  		// Create a proper 2525C SIDC for testing  		if (cSIDCIn == null)  			break;  		if (cSIDCIn.Length == 15) {  			if (cSIDCIn.Substring (1' 1) == "*")  				cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  			cSIDCIn = cSIDCIn.Replace ('*'' '-');  			foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  				string dFirst10 = "";  				string dSecond10 = "";  				string cSIDCOut = "";  				string status = "";  				string symbolName = "";  				string modOneName = "";  				string modTwoName = "";  				totalCount++;  				cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  				cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  				if (fcode.SchemaOverride != "") {  					cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  					cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  				}  				if (fcode.DimensionOverride != "") {  					cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  					cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  				}  				// Build a symbol using a 2525C SIDC  				Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  				if (sym != null) {  					if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  						dFirst10 = sym.SIDC.PartAString;  						dSecond10 = sym.SIDC.PartBString;  						// Build a symbol using the 2525D SIDC' to see if reverse  						// conversion works.  						Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  						if (sym2 != null) {  							cSIDCOut = sym2.LegacySIDC;  							symbolName = sym2.Names ["Entity"];  							modOneName = sym2.Names ["ModifierOne"];  							modTwoName = sym2.Names ["ModifierTwo"];  							if (cSIDCIn == cSIDCOut) {  								status = "pass";  								passCount++;  							} else if (sym2.LegacySIDCs.Count > 1) {  								bool match = false;  								foreach (string sidc in sym2.LegacySIDCs) {  									if (cSIDCIn == sidc) {  										match = true;  										break;  									}  								}  								if (match) {  									status = "pass (multiple)";  									passWithConditionCount++;  								} else {  									status = "FAIL";  									failCount++;  								}  							} else {  								status = "FAIL";  								failCount++;  							}  						} else {  							status = "Error making 2525D";  							derrorCount++;  						}  					} else {  						status = "Retired";  						dFirst10 = SIDC.INVALID.PartAString;  						dSecond10 = SIDC.INVALID.PartBString;  						retiredCount++;  					}  				} else {  					status = "Error making 2525C";  					cerrorCount++;  				}  				stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  				stream.Flush ();  			}  		} else  			logger.Error ("Bad SIDC : " + cSIDCIn);  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: if (ss.LegacySymbols != null) {  	foreach (SymbolSetLegacySymbol legacy in ss.LegacySymbols) {  		string cSIDC = legacy.Label;  		string cSIDCIn = legacy.Label;  		// Create a proper 2525C SIDC for testing  		if (cSIDCIn == null)  			break;  		if (cSIDCIn.Length == 15) {  			if (cSIDCIn.Substring (1' 1) == "*")  				cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  			cSIDCIn = cSIDCIn.Replace ('*'' '-');  			foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  				string dFirst10 = "";  				string dSecond10 = "";  				string cSIDCOut = "";  				string status = "";  				string symbolName = "";  				string modOneName = "";  				string modTwoName = "";  				totalCount++;  				cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  				cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  				if (fcode.SchemaOverride != "") {  					cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  					cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  				}  				if (fcode.DimensionOverride != "") {  					cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  					cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  				}  				// Build a symbol using a 2525C SIDC  				Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  				if (sym != null) {  					if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  						dFirst10 = sym.SIDC.PartAString;  						dSecond10 = sym.SIDC.PartBString;  						// Build a symbol using the 2525D SIDC' to see if reverse  						// conversion works.  						Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  						if (sym2 != null) {  							cSIDCOut = sym2.LegacySIDC;  							symbolName = sym2.Names ["Entity"];  							modOneName = sym2.Names ["ModifierOne"];  							modTwoName = sym2.Names ["ModifierTwo"];  							if (cSIDCIn == cSIDCOut) {  								status = "pass";  								passCount++;  							} else if (sym2.LegacySIDCs.Count > 1) {  								bool match = false;  								foreach (string sidc in sym2.LegacySIDCs) {  									if (cSIDCIn == sidc) {  										match = true;  										break;  									}  								}  								if (match) {  									status = "pass (multiple)";  									passWithConditionCount++;  								} else {  									status = "FAIL";  									failCount++;  								}  							} else {  								status = "FAIL";  								failCount++;  							}  						} else {  							status = "Error making 2525D";  							derrorCount++;  						}  					} else {  						status = "Retired";  						dFirst10 = SIDC.INVALID.PartAString;  						dSecond10 = SIDC.INVALID.PartBString;  						retiredCount++;  					}  				} else {  					status = "Error making 2525C";  					cerrorCount++;  				}  				stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  				stream.Flush ();  			}  		} else  			logger.Error ("Bad SIDC : " + cSIDCIn);  	}  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: foreach (SymbolSetLegacySymbol legacy in ss.LegacySymbols) {  	string cSIDC = legacy.Label;  	string cSIDCIn = legacy.Label;  	// Create a proper 2525C SIDC for testing  	if (cSIDCIn == null)  		break;  	if (cSIDCIn.Length == 15) {  		if (cSIDCIn.Substring (1' 1) == "*")  			cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  		cSIDCIn = cSIDCIn.Replace ('*'' '-');  		foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  			string dFirst10 = "";  			string dSecond10 = "";  			string cSIDCOut = "";  			string status = "";  			string symbolName = "";  			string modOneName = "";  			string modTwoName = "";  			totalCount++;  			cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  			cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  			if (fcode.SchemaOverride != "") {  				cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  				cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  			}  			if (fcode.DimensionOverride != "") {  				cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  				cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  			}  			// Build a symbol using a 2525C SIDC  			Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  			if (sym != null) {  				if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  					dFirst10 = sym.SIDC.PartAString;  					dSecond10 = sym.SIDC.PartBString;  					// Build a symbol using the 2525D SIDC' to see if reverse  					// conversion works.  					Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  					if (sym2 != null) {  						cSIDCOut = sym2.LegacySIDC;  						symbolName = sym2.Names ["Entity"];  						modOneName = sym2.Names ["ModifierOne"];  						modTwoName = sym2.Names ["ModifierTwo"];  						if (cSIDCIn == cSIDCOut) {  							status = "pass";  							passCount++;  						} else if (sym2.LegacySIDCs.Count > 1) {  							bool match = false;  							foreach (string sidc in sym2.LegacySIDCs) {  								if (cSIDCIn == sidc) {  									match = true;  									break;  								}  							}  							if (match) {  								status = "pass (multiple)";  								passWithConditionCount++;  							} else {  								status = "FAIL";  								failCount++;  							}  						} else {  							status = "FAIL";  							failCount++;  						}  					} else {  						status = "Error making 2525D";  						derrorCount++;  					}  				} else {  					status = "Retired";  					dFirst10 = SIDC.INVALID.PartAString;  					dSecond10 = SIDC.INVALID.PartBString;  					retiredCount++;  				}  			} else {  				status = "Error making 2525C";  				cerrorCount++;  			}  			stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  			stream.Flush ();  		}  	} else  		logger.Error ("Bad SIDC : " + cSIDCIn);  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: foreach (SymbolSetLegacySymbol legacy in ss.LegacySymbols) {  	string cSIDC = legacy.Label;  	string cSIDCIn = legacy.Label;  	// Create a proper 2525C SIDC for testing  	if (cSIDCIn == null)  		break;  	if (cSIDCIn.Length == 15) {  		if (cSIDCIn.Substring (1' 1) == "*")  			cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  		cSIDCIn = cSIDCIn.Replace ('*'' '-');  		foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  			string dFirst10 = "";  			string dSecond10 = "";  			string cSIDCOut = "";  			string status = "";  			string symbolName = "";  			string modOneName = "";  			string modTwoName = "";  			totalCount++;  			cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  			cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  			if (fcode.SchemaOverride != "") {  				cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  				cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  			}  			if (fcode.DimensionOverride != "") {  				cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  				cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  			}  			// Build a symbol using a 2525C SIDC  			Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  			if (sym != null) {  				if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  					dFirst10 = sym.SIDC.PartAString;  					dSecond10 = sym.SIDC.PartBString;  					// Build a symbol using the 2525D SIDC' to see if reverse  					// conversion works.  					Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  					if (sym2 != null) {  						cSIDCOut = sym2.LegacySIDC;  						symbolName = sym2.Names ["Entity"];  						modOneName = sym2.Names ["ModifierOne"];  						modTwoName = sym2.Names ["ModifierTwo"];  						if (cSIDCIn == cSIDCOut) {  							status = "pass";  							passCount++;  						} else if (sym2.LegacySIDCs.Count > 1) {  							bool match = false;  							foreach (string sidc in sym2.LegacySIDCs) {  								if (cSIDCIn == sidc) {  									match = true;  									break;  								}  							}  							if (match) {  								status = "pass (multiple)";  								passWithConditionCount++;  							} else {  								status = "FAIL";  								failCount++;  							}  						} else {  							status = "FAIL";  							failCount++;  						}  					} else {  						status = "Error making 2525D";  						derrorCount++;  					}  				} else {  					status = "Retired";  					dFirst10 = SIDC.INVALID.PartAString;  					dSecond10 = SIDC.INVALID.PartBString;  					retiredCount++;  				}  			} else {  				status = "Error making 2525C";  				cerrorCount++;  			}  			stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  			stream.Flush ();  		}  	} else  		logger.Error ("Bad SIDC : " + cSIDCIn);  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: foreach (SymbolSetLegacySymbol legacy in ss.LegacySymbols) {  	string cSIDC = legacy.Label;  	string cSIDCIn = legacy.Label;  	// Create a proper 2525C SIDC for testing  	if (cSIDCIn == null)  		break;  	if (cSIDCIn.Length == 15) {  		if (cSIDCIn.Substring (1' 1) == "*")  			cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  		cSIDCIn = cSIDCIn.Replace ('*'' '-');  		foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  			string dFirst10 = "";  			string dSecond10 = "";  			string cSIDCOut = "";  			string status = "";  			string symbolName = "";  			string modOneName = "";  			string modTwoName = "";  			totalCount++;  			cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  			cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  			if (fcode.SchemaOverride != "") {  				cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  				cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  			}  			if (fcode.DimensionOverride != "") {  				cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  				cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  			}  			// Build a symbol using a 2525C SIDC  			Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  			if (sym != null) {  				if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  					dFirst10 = sym.SIDC.PartAString;  					dSecond10 = sym.SIDC.PartBString;  					// Build a symbol using the 2525D SIDC' to see if reverse  					// conversion works.  					Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  					if (sym2 != null) {  						cSIDCOut = sym2.LegacySIDC;  						symbolName = sym2.Names ["Entity"];  						modOneName = sym2.Names ["ModifierOne"];  						modTwoName = sym2.Names ["ModifierTwo"];  						if (cSIDCIn == cSIDCOut) {  							status = "pass";  							passCount++;  						} else if (sym2.LegacySIDCs.Count > 1) {  							bool match = false;  							foreach (string sidc in sym2.LegacySIDCs) {  								if (cSIDCIn == sidc) {  									match = true;  									break;  								}  							}  							if (match) {  								status = "pass (multiple)";  								passWithConditionCount++;  							} else {  								status = "FAIL";  								failCount++;  							}  						} else {  							status = "FAIL";  							failCount++;  						}  					} else {  						status = "Error making 2525D";  						derrorCount++;  					}  				} else {  					status = "Retired";  					dFirst10 = SIDC.INVALID.PartAString;  					dSecond10 = SIDC.INVALID.PartBString;  					retiredCount++;  				}  			} else {  				status = "Error making 2525C";  				cerrorCount++;  			}  			stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  			stream.Flush ();  		}  	} else  		logger.Error ("Bad SIDC : " + cSIDCIn);  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: foreach (SymbolSetLegacySymbol legacy in ss.LegacySymbols) {  	string cSIDC = legacy.Label;  	string cSIDCIn = legacy.Label;  	// Create a proper 2525C SIDC for testing  	if (cSIDCIn == null)  		break;  	if (cSIDCIn.Length == 15) {  		if (cSIDCIn.Substring (1' 1) == "*")  			cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  		cSIDCIn = cSIDCIn.Replace ('*'' '-');  		foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  			string dFirst10 = "";  			string dSecond10 = "";  			string cSIDCOut = "";  			string status = "";  			string symbolName = "";  			string modOneName = "";  			string modTwoName = "";  			totalCount++;  			cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  			cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  			if (fcode.SchemaOverride != "") {  				cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  				cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  			}  			if (fcode.DimensionOverride != "") {  				cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  				cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  			}  			// Build a symbol using a 2525C SIDC  			Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  			if (sym != null) {  				if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  					dFirst10 = sym.SIDC.PartAString;  					dSecond10 = sym.SIDC.PartBString;  					// Build a symbol using the 2525D SIDC' to see if reverse  					// conversion works.  					Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  					if (sym2 != null) {  						cSIDCOut = sym2.LegacySIDC;  						symbolName = sym2.Names ["Entity"];  						modOneName = sym2.Names ["ModifierOne"];  						modTwoName = sym2.Names ["ModifierTwo"];  						if (cSIDCIn == cSIDCOut) {  							status = "pass";  							passCount++;  						} else if (sym2.LegacySIDCs.Count > 1) {  							bool match = false;  							foreach (string sidc in sym2.LegacySIDCs) {  								if (cSIDCIn == sidc) {  									match = true;  									break;  								}  							}  							if (match) {  								status = "pass (multiple)";  								passWithConditionCount++;  							} else {  								status = "FAIL";  								failCount++;  							}  						} else {  							status = "FAIL";  							failCount++;  						}  					} else {  						status = "Error making 2525D";  						derrorCount++;  					}  				} else {  					status = "Retired";  					dFirst10 = SIDC.INVALID.PartAString;  					dSecond10 = SIDC.INVALID.PartBString;  					retiredCount++;  				}  			} else {  				status = "Error making 2525C";  				cerrorCount++;  			}  			stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  			stream.Flush ();  		}  	} else  		logger.Error ("Bad SIDC : " + cSIDCIn);  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: foreach (SymbolSetLegacySymbol legacy in ss.LegacySymbols) {  	string cSIDC = legacy.Label;  	string cSIDCIn = legacy.Label;  	// Create a proper 2525C SIDC for testing  	if (cSIDCIn == null)  		break;  	if (cSIDCIn.Length == 15) {  		if (cSIDCIn.Substring (1' 1) == "*")  			cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  		cSIDCIn = cSIDCIn.Replace ('*'' '-');  		foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  			string dFirst10 = "";  			string dSecond10 = "";  			string cSIDCOut = "";  			string status = "";  			string symbolName = "";  			string modOneName = "";  			string modTwoName = "";  			totalCount++;  			cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  			cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  			if (fcode.SchemaOverride != "") {  				cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  				cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  			}  			if (fcode.DimensionOverride != "") {  				cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  				cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  			}  			// Build a symbol using a 2525C SIDC  			Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  			if (sym != null) {  				if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  					dFirst10 = sym.SIDC.PartAString;  					dSecond10 = sym.SIDC.PartBString;  					// Build a symbol using the 2525D SIDC' to see if reverse  					// conversion works.  					Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  					if (sym2 != null) {  						cSIDCOut = sym2.LegacySIDC;  						symbolName = sym2.Names ["Entity"];  						modOneName = sym2.Names ["ModifierOne"];  						modTwoName = sym2.Names ["ModifierTwo"];  						if (cSIDCIn == cSIDCOut) {  							status = "pass";  							passCount++;  						} else if (sym2.LegacySIDCs.Count > 1) {  							bool match = false;  							foreach (string sidc in sym2.LegacySIDCs) {  								if (cSIDCIn == sidc) {  									match = true;  									break;  								}  							}  							if (match) {  								status = "pass (multiple)";  								passWithConditionCount++;  							} else {  								status = "FAIL";  								failCount++;  							}  						} else {  							status = "FAIL";  							failCount++;  						}  					} else {  						status = "Error making 2525D";  						derrorCount++;  					}  				} else {  					status = "Retired";  					dFirst10 = SIDC.INVALID.PartAString;  					dSecond10 = SIDC.INVALID.PartBString;  					retiredCount++;  				}  			} else {  				status = "Error making 2525C";  				cerrorCount++;  			}  			stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  			stream.Flush ();  		}  	} else  		logger.Error ("Bad SIDC : " + cSIDCIn);  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: foreach (SymbolSetLegacySymbol legacy in ss.LegacySymbols) {  	string cSIDC = legacy.Label;  	string cSIDCIn = legacy.Label;  	// Create a proper 2525C SIDC for testing  	if (cSIDCIn == null)  		break;  	if (cSIDCIn.Length == 15) {  		if (cSIDCIn.Substring (1' 1) == "*")  			cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  		cSIDCIn = cSIDCIn.Replace ('*'' '-');  		foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  			string dFirst10 = "";  			string dSecond10 = "";  			string cSIDCOut = "";  			string status = "";  			string symbolName = "";  			string modOneName = "";  			string modTwoName = "";  			totalCount++;  			cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  			cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  			if (fcode.SchemaOverride != "") {  				cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  				cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  			}  			if (fcode.DimensionOverride != "") {  				cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  				cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  			}  			// Build a symbol using a 2525C SIDC  			Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  			if (sym != null) {  				if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  					dFirst10 = sym.SIDC.PartAString;  					dSecond10 = sym.SIDC.PartBString;  					// Build a symbol using the 2525D SIDC' to see if reverse  					// conversion works.  					Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  					if (sym2 != null) {  						cSIDCOut = sym2.LegacySIDC;  						symbolName = sym2.Names ["Entity"];  						modOneName = sym2.Names ["ModifierOne"];  						modTwoName = sym2.Names ["ModifierTwo"];  						if (cSIDCIn == cSIDCOut) {  							status = "pass";  							passCount++;  						} else if (sym2.LegacySIDCs.Count > 1) {  							bool match = false;  							foreach (string sidc in sym2.LegacySIDCs) {  								if (cSIDCIn == sidc) {  									match = true;  									break;  								}  							}  							if (match) {  								status = "pass (multiple)";  								passWithConditionCount++;  							} else {  								status = "FAIL";  								failCount++;  							}  						} else {  							status = "FAIL";  							failCount++;  						}  					} else {  						status = "Error making 2525D";  						derrorCount++;  					}  				} else {  					status = "Retired";  					dFirst10 = SIDC.INVALID.PartAString;  					dSecond10 = SIDC.INVALID.PartBString;  					retiredCount++;  				}  			} else {  				status = "Error making 2525C";  				cerrorCount++;  			}  			stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  			stream.Flush ();  		}  	} else  		logger.Error ("Bad SIDC : " + cSIDCIn);  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: foreach (SymbolSetLegacySymbol legacy in ss.LegacySymbols) {  	string cSIDC = legacy.Label;  	string cSIDCIn = legacy.Label;  	// Create a proper 2525C SIDC for testing  	if (cSIDCIn == null)  		break;  	if (cSIDCIn.Length == 15) {  		if (cSIDCIn.Substring (1' 1) == "*")  			cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  		cSIDCIn = cSIDCIn.Replace ('*'' '-');  		foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  			string dFirst10 = "";  			string dSecond10 = "";  			string cSIDCOut = "";  			string status = "";  			string symbolName = "";  			string modOneName = "";  			string modTwoName = "";  			totalCount++;  			cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  			cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  			if (fcode.SchemaOverride != "") {  				cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  				cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  			}  			if (fcode.DimensionOverride != "") {  				cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  				cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  			}  			// Build a symbol using a 2525C SIDC  			Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  			if (sym != null) {  				if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  					dFirst10 = sym.SIDC.PartAString;  					dSecond10 = sym.SIDC.PartBString;  					// Build a symbol using the 2525D SIDC' to see if reverse  					// conversion works.  					Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  					if (sym2 != null) {  						cSIDCOut = sym2.LegacySIDC;  						symbolName = sym2.Names ["Entity"];  						modOneName = sym2.Names ["ModifierOne"];  						modTwoName = sym2.Names ["ModifierTwo"];  						if (cSIDCIn == cSIDCOut) {  							status = "pass";  							passCount++;  						} else if (sym2.LegacySIDCs.Count > 1) {  							bool match = false;  							foreach (string sidc in sym2.LegacySIDCs) {  								if (cSIDCIn == sidc) {  									match = true;  									break;  								}  							}  							if (match) {  								status = "pass (multiple)";  								passWithConditionCount++;  							} else {  								status = "FAIL";  								failCount++;  							}  						} else {  							status = "FAIL";  							failCount++;  						}  					} else {  						status = "Error making 2525D";  						derrorCount++;  					}  				} else {  					status = "Retired";  					dFirst10 = SIDC.INVALID.PartAString;  					dSecond10 = SIDC.INVALID.PartBString;  					retiredCount++;  				}  			} else {  				status = "Error making 2525C";  				cerrorCount++;  			}  			stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  			stream.Flush ();  		}  	} else  		logger.Error ("Bad SIDC : " + cSIDCIn);  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: foreach (SymbolSetLegacySymbol legacy in ss.LegacySymbols) {  	string cSIDC = legacy.Label;  	string cSIDCIn = legacy.Label;  	// Create a proper 2525C SIDC for testing  	if (cSIDCIn == null)  		break;  	if (cSIDCIn.Length == 15) {  		if (cSIDCIn.Substring (1' 1) == "*")  			cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  		cSIDCIn = cSIDCIn.Replace ('*'' '-');  		foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  			string dFirst10 = "";  			string dSecond10 = "";  			string cSIDCOut = "";  			string status = "";  			string symbolName = "";  			string modOneName = "";  			string modTwoName = "";  			totalCount++;  			cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  			cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  			if (fcode.SchemaOverride != "") {  				cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  				cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  			}  			if (fcode.DimensionOverride != "") {  				cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  				cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  			}  			// Build a symbol using a 2525C SIDC  			Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  			if (sym != null) {  				if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  					dFirst10 = sym.SIDC.PartAString;  					dSecond10 = sym.SIDC.PartBString;  					// Build a symbol using the 2525D SIDC' to see if reverse  					// conversion works.  					Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  					if (sym2 != null) {  						cSIDCOut = sym2.LegacySIDC;  						symbolName = sym2.Names ["Entity"];  						modOneName = sym2.Names ["ModifierOne"];  						modTwoName = sym2.Names ["ModifierTwo"];  						if (cSIDCIn == cSIDCOut) {  							status = "pass";  							passCount++;  						} else if (sym2.LegacySIDCs.Count > 1) {  							bool match = false;  							foreach (string sidc in sym2.LegacySIDCs) {  								if (cSIDCIn == sidc) {  									match = true;  									break;  								}  							}  							if (match) {  								status = "pass (multiple)";  								passWithConditionCount++;  							} else {  								status = "FAIL";  								failCount++;  							}  						} else {  							status = "FAIL";  							failCount++;  						}  					} else {  						status = "Error making 2525D";  						derrorCount++;  					}  				} else {  					status = "Retired";  					dFirst10 = SIDC.INVALID.PartAString;  					dSecond10 = SIDC.INVALID.PartBString;  					retiredCount++;  				}  			} else {  				status = "Error making 2525C";  				cerrorCount++;  			}  			stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  			stream.Flush ();  		}  	} else  		logger.Error ("Bad SIDC : " + cSIDCIn);  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: foreach (SymbolSetLegacySymbol legacy in ss.LegacySymbols) {  	string cSIDC = legacy.Label;  	string cSIDCIn = legacy.Label;  	// Create a proper 2525C SIDC for testing  	if (cSIDCIn == null)  		break;  	if (cSIDCIn.Length == 15) {  		if (cSIDCIn.Substring (1' 1) == "*")  			cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  		cSIDCIn = cSIDCIn.Replace ('*'' '-');  		foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  			string dFirst10 = "";  			string dSecond10 = "";  			string cSIDCOut = "";  			string status = "";  			string symbolName = "";  			string modOneName = "";  			string modTwoName = "";  			totalCount++;  			cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  			cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  			if (fcode.SchemaOverride != "") {  				cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  				cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  			}  			if (fcode.DimensionOverride != "") {  				cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  				cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  			}  			// Build a symbol using a 2525C SIDC  			Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  			if (sym != null) {  				if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  					dFirst10 = sym.SIDC.PartAString;  					dSecond10 = sym.SIDC.PartBString;  					// Build a symbol using the 2525D SIDC' to see if reverse  					// conversion works.  					Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  					if (sym2 != null) {  						cSIDCOut = sym2.LegacySIDC;  						symbolName = sym2.Names ["Entity"];  						modOneName = sym2.Names ["ModifierOne"];  						modTwoName = sym2.Names ["ModifierTwo"];  						if (cSIDCIn == cSIDCOut) {  							status = "pass";  							passCount++;  						} else if (sym2.LegacySIDCs.Count > 1) {  							bool match = false;  							foreach (string sidc in sym2.LegacySIDCs) {  								if (cSIDCIn == sidc) {  									match = true;  									break;  								}  							}  							if (match) {  								status = "pass (multiple)";  								passWithConditionCount++;  							} else {  								status = "FAIL";  								failCount++;  							}  						} else {  							status = "FAIL";  							failCount++;  						}  					} else {  						status = "Error making 2525D";  						derrorCount++;  					}  				} else {  					status = "Retired";  					dFirst10 = SIDC.INVALID.PartAString;  					dSecond10 = SIDC.INVALID.PartBString;  					retiredCount++;  				}  			} else {  				status = "Error making 2525C";  				cerrorCount++;  			}  			stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  			stream.Flush ();  		}  	} else  		logger.Error ("Bad SIDC : " + cSIDCIn);  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: foreach (SymbolSetLegacySymbol legacy in ss.LegacySymbols) {  	string cSIDC = legacy.Label;  	string cSIDCIn = legacy.Label;  	// Create a proper 2525C SIDC for testing  	if (cSIDCIn == null)  		break;  	if (cSIDCIn.Length == 15) {  		if (cSIDCIn.Substring (1' 1) == "*")  			cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  		cSIDCIn = cSIDCIn.Replace ('*'' '-');  		foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  			string dFirst10 = "";  			string dSecond10 = "";  			string cSIDCOut = "";  			string status = "";  			string symbolName = "";  			string modOneName = "";  			string modTwoName = "";  			totalCount++;  			cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  			cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  			if (fcode.SchemaOverride != "") {  				cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  				cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  			}  			if (fcode.DimensionOverride != "") {  				cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  				cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  			}  			// Build a symbol using a 2525C SIDC  			Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  			if (sym != null) {  				if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  					dFirst10 = sym.SIDC.PartAString;  					dSecond10 = sym.SIDC.PartBString;  					// Build a symbol using the 2525D SIDC' to see if reverse  					// conversion works.  					Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  					if (sym2 != null) {  						cSIDCOut = sym2.LegacySIDC;  						symbolName = sym2.Names ["Entity"];  						modOneName = sym2.Names ["ModifierOne"];  						modTwoName = sym2.Names ["ModifierTwo"];  						if (cSIDCIn == cSIDCOut) {  							status = "pass";  							passCount++;  						} else if (sym2.LegacySIDCs.Count > 1) {  							bool match = false;  							foreach (string sidc in sym2.LegacySIDCs) {  								if (cSIDCIn == sidc) {  									match = true;  									break;  								}  							}  							if (match) {  								status = "pass (multiple)";  								passWithConditionCount++;  							} else {  								status = "FAIL";  								failCount++;  							}  						} else {  							status = "FAIL";  							failCount++;  						}  					} else {  						status = "Error making 2525D";  						derrorCount++;  					}  				} else {  					status = "Retired";  					dFirst10 = SIDC.INVALID.PartAString;  					dSecond10 = SIDC.INVALID.PartBString;  					retiredCount++;  				}  			} else {  				status = "Error making 2525C";  				cerrorCount++;  			}  			stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  			stream.Flush ();  		}  	} else  		logger.Error ("Bad SIDC : " + cSIDCIn);  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: foreach (SymbolSetLegacySymbol legacy in ss.LegacySymbols) {  	string cSIDC = legacy.Label;  	string cSIDCIn = legacy.Label;  	// Create a proper 2525C SIDC for testing  	if (cSIDCIn == null)  		break;  	if (cSIDCIn.Length == 15) {  		if (cSIDCIn.Substring (1' 1) == "*")  			cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  		cSIDCIn = cSIDCIn.Replace ('*'' '-');  		foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  			string dFirst10 = "";  			string dSecond10 = "";  			string cSIDCOut = "";  			string status = "";  			string symbolName = "";  			string modOneName = "";  			string modTwoName = "";  			totalCount++;  			cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  			cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  			if (fcode.SchemaOverride != "") {  				cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  				cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  			}  			if (fcode.DimensionOverride != "") {  				cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  				cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  			}  			// Build a symbol using a 2525C SIDC  			Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  			if (sym != null) {  				if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  					dFirst10 = sym.SIDC.PartAString;  					dSecond10 = sym.SIDC.PartBString;  					// Build a symbol using the 2525D SIDC' to see if reverse  					// conversion works.  					Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  					if (sym2 != null) {  						cSIDCOut = sym2.LegacySIDC;  						symbolName = sym2.Names ["Entity"];  						modOneName = sym2.Names ["ModifierOne"];  						modTwoName = sym2.Names ["ModifierTwo"];  						if (cSIDCIn == cSIDCOut) {  							status = "pass";  							passCount++;  						} else if (sym2.LegacySIDCs.Count > 1) {  							bool match = false;  							foreach (string sidc in sym2.LegacySIDCs) {  								if (cSIDCIn == sidc) {  									match = true;  									break;  								}  							}  							if (match) {  								status = "pass (multiple)";  								passWithConditionCount++;  							} else {  								status = "FAIL";  								failCount++;  							}  						} else {  							status = "FAIL";  							failCount++;  						}  					} else {  						status = "Error making 2525D";  						derrorCount++;  					}  				} else {  					status = "Retired";  					dFirst10 = SIDC.INVALID.PartAString;  					dSecond10 = SIDC.INVALID.PartBString;  					retiredCount++;  				}  			} else {  				status = "Error making 2525C";  				cerrorCount++;  			}  			stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  			stream.Flush ();  		}  	} else  		logger.Error ("Bad SIDC : " + cSIDCIn);  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: foreach (SymbolSetLegacySymbol legacy in ss.LegacySymbols) {  	string cSIDC = legacy.Label;  	string cSIDCIn = legacy.Label;  	// Create a proper 2525C SIDC for testing  	if (cSIDCIn == null)  		break;  	if (cSIDCIn.Length == 15) {  		if (cSIDCIn.Substring (1' 1) == "*")  			cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  		cSIDCIn = cSIDCIn.Replace ('*'' '-');  		foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  			string dFirst10 = "";  			string dSecond10 = "";  			string cSIDCOut = "";  			string status = "";  			string symbolName = "";  			string modOneName = "";  			string modTwoName = "";  			totalCount++;  			cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  			cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  			if (fcode.SchemaOverride != "") {  				cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  				cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  			}  			if (fcode.DimensionOverride != "") {  				cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  				cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  			}  			// Build a symbol using a 2525C SIDC  			Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  			if (sym != null) {  				if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  					dFirst10 = sym.SIDC.PartAString;  					dSecond10 = sym.SIDC.PartBString;  					// Build a symbol using the 2525D SIDC' to see if reverse  					// conversion works.  					Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  					if (sym2 != null) {  						cSIDCOut = sym2.LegacySIDC;  						symbolName = sym2.Names ["Entity"];  						modOneName = sym2.Names ["ModifierOne"];  						modTwoName = sym2.Names ["ModifierTwo"];  						if (cSIDCIn == cSIDCOut) {  							status = "pass";  							passCount++;  						} else if (sym2.LegacySIDCs.Count > 1) {  							bool match = false;  							foreach (string sidc in sym2.LegacySIDCs) {  								if (cSIDCIn == sidc) {  									match = true;  									break;  								}  							}  							if (match) {  								status = "pass (multiple)";  								passWithConditionCount++;  							} else {  								status = "FAIL";  								failCount++;  							}  						} else {  							status = "FAIL";  							failCount++;  						}  					} else {  						status = "Error making 2525D";  						derrorCount++;  					}  				} else {  					status = "Retired";  					dFirst10 = SIDC.INVALID.PartAString;  					dSecond10 = SIDC.INVALID.PartBString;  					retiredCount++;  				}  			} else {  				status = "Error making 2525C";  				cerrorCount++;  			}  			stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  			stream.Flush ();  		}  	} else  		logger.Error ("Bad SIDC : " + cSIDCIn);  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: foreach (SymbolSetLegacySymbol legacy in ss.LegacySymbols) {  	string cSIDC = legacy.Label;  	string cSIDCIn = legacy.Label;  	// Create a proper 2525C SIDC for testing  	if (cSIDCIn == null)  		break;  	if (cSIDCIn.Length == 15) {  		if (cSIDCIn.Substring (1' 1) == "*")  			cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  		cSIDCIn = cSIDCIn.Replace ('*'' '-');  		foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  			string dFirst10 = "";  			string dSecond10 = "";  			string cSIDCOut = "";  			string status = "";  			string symbolName = "";  			string modOneName = "";  			string modTwoName = "";  			totalCount++;  			cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  			cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  			if (fcode.SchemaOverride != "") {  				cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  				cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  			}  			if (fcode.DimensionOverride != "") {  				cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  				cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  			}  			// Build a symbol using a 2525C SIDC  			Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  			if (sym != null) {  				if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  					dFirst10 = sym.SIDC.PartAString;  					dSecond10 = sym.SIDC.PartBString;  					// Build a symbol using the 2525D SIDC' to see if reverse  					// conversion works.  					Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  					if (sym2 != null) {  						cSIDCOut = sym2.LegacySIDC;  						symbolName = sym2.Names ["Entity"];  						modOneName = sym2.Names ["ModifierOne"];  						modTwoName = sym2.Names ["ModifierTwo"];  						if (cSIDCIn == cSIDCOut) {  							status = "pass";  							passCount++;  						} else if (sym2.LegacySIDCs.Count > 1) {  							bool match = false;  							foreach (string sidc in sym2.LegacySIDCs) {  								if (cSIDCIn == sidc) {  									match = true;  									break;  								}  							}  							if (match) {  								status = "pass (multiple)";  								passWithConditionCount++;  							} else {  								status = "FAIL";  								failCount++;  							}  						} else {  							status = "FAIL";  							failCount++;  						}  					} else {  						status = "Error making 2525D";  						derrorCount++;  					}  				} else {  					status = "Retired";  					dFirst10 = SIDC.INVALID.PartAString;  					dSecond10 = SIDC.INVALID.PartBString;  					retiredCount++;  				}  			} else {  				status = "Error making 2525C";  				cerrorCount++;  			}  			stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  			stream.Flush ();  		}  	} else  		logger.Error ("Bad SIDC : " + cSIDCIn);  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: foreach (SymbolSetLegacySymbol legacy in ss.LegacySymbols) {  	string cSIDC = legacy.Label;  	string cSIDCIn = legacy.Label;  	// Create a proper 2525C SIDC for testing  	if (cSIDCIn == null)  		break;  	if (cSIDCIn.Length == 15) {  		if (cSIDCIn.Substring (1' 1) == "*")  			cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  		cSIDCIn = cSIDCIn.Replace ('*'' '-');  		foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  			string dFirst10 = "";  			string dSecond10 = "";  			string cSIDCOut = "";  			string status = "";  			string symbolName = "";  			string modOneName = "";  			string modTwoName = "";  			totalCount++;  			cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  			cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  			if (fcode.SchemaOverride != "") {  				cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  				cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  			}  			if (fcode.DimensionOverride != "") {  				cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  				cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  			}  			// Build a symbol using a 2525C SIDC  			Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  			if (sym != null) {  				if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  					dFirst10 = sym.SIDC.PartAString;  					dSecond10 = sym.SIDC.PartBString;  					// Build a symbol using the 2525D SIDC' to see if reverse  					// conversion works.  					Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  					if (sym2 != null) {  						cSIDCOut = sym2.LegacySIDC;  						symbolName = sym2.Names ["Entity"];  						modOneName = sym2.Names ["ModifierOne"];  						modTwoName = sym2.Names ["ModifierTwo"];  						if (cSIDCIn == cSIDCOut) {  							status = "pass";  							passCount++;  						} else if (sym2.LegacySIDCs.Count > 1) {  							bool match = false;  							foreach (string sidc in sym2.LegacySIDCs) {  								if (cSIDCIn == sidc) {  									match = true;  									break;  								}  							}  							if (match) {  								status = "pass (multiple)";  								passWithConditionCount++;  							} else {  								status = "FAIL";  								failCount++;  							}  						} else {  							status = "FAIL";  							failCount++;  						}  					} else {  						status = "Error making 2525D";  						derrorCount++;  					}  				} else {  					status = "Retired";  					dFirst10 = SIDC.INVALID.PartAString;  					dSecond10 = SIDC.INVALID.PartBString;  					retiredCount++;  				}  			} else {  				status = "Error making 2525C";  				cerrorCount++;  			}  			stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  			stream.Flush ();  		}  	} else  		logger.Error ("Bad SIDC : " + cSIDCIn);  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: foreach (SymbolSetLegacySymbol legacy in ss.LegacySymbols) {  	string cSIDC = legacy.Label;  	string cSIDCIn = legacy.Label;  	// Create a proper 2525C SIDC for testing  	if (cSIDCIn == null)  		break;  	if (cSIDCIn.Length == 15) {  		if (cSIDCIn.Substring (1' 1) == "*")  			cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  		cSIDCIn = cSIDCIn.Replace ('*'' '-');  		foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  			string dFirst10 = "";  			string dSecond10 = "";  			string cSIDCOut = "";  			string status = "";  			string symbolName = "";  			string modOneName = "";  			string modTwoName = "";  			totalCount++;  			cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  			cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  			if (fcode.SchemaOverride != "") {  				cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  				cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  			}  			if (fcode.DimensionOverride != "") {  				cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  				cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  			}  			// Build a symbol using a 2525C SIDC  			Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  			if (sym != null) {  				if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  					dFirst10 = sym.SIDC.PartAString;  					dSecond10 = sym.SIDC.PartBString;  					// Build a symbol using the 2525D SIDC' to see if reverse  					// conversion works.  					Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  					if (sym2 != null) {  						cSIDCOut = sym2.LegacySIDC;  						symbolName = sym2.Names ["Entity"];  						modOneName = sym2.Names ["ModifierOne"];  						modTwoName = sym2.Names ["ModifierTwo"];  						if (cSIDCIn == cSIDCOut) {  							status = "pass";  							passCount++;  						} else if (sym2.LegacySIDCs.Count > 1) {  							bool match = false;  							foreach (string sidc in sym2.LegacySIDCs) {  								if (cSIDCIn == sidc) {  									match = true;  									break;  								}  							}  							if (match) {  								status = "pass (multiple)";  								passWithConditionCount++;  							} else {  								status = "FAIL";  								failCount++;  							}  						} else {  							status = "FAIL";  							failCount++;  						}  					} else {  						status = "Error making 2525D";  						derrorCount++;  					}  				} else {  					status = "Retired";  					dFirst10 = SIDC.INVALID.PartAString;  					dSecond10 = SIDC.INVALID.PartBString;  					retiredCount++;  				}  			} else {  				status = "Error making 2525C";  				cerrorCount++;  			}  			stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  			stream.Flush ();  		}  	} else  		logger.Error ("Bad SIDC : " + cSIDCIn);  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: foreach (SymbolSetLegacySymbol legacy in ss.LegacySymbols) {  	string cSIDC = legacy.Label;  	string cSIDCIn = legacy.Label;  	// Create a proper 2525C SIDC for testing  	if (cSIDCIn == null)  		break;  	if (cSIDCIn.Length == 15) {  		if (cSIDCIn.Substring (1' 1) == "*")  			cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  		cSIDCIn = cSIDCIn.Replace ('*'' '-');  		foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  			string dFirst10 = "";  			string dSecond10 = "";  			string cSIDCOut = "";  			string status = "";  			string symbolName = "";  			string modOneName = "";  			string modTwoName = "";  			totalCount++;  			cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  			cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  			if (fcode.SchemaOverride != "") {  				cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  				cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  			}  			if (fcode.DimensionOverride != "") {  				cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  				cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  			}  			// Build a symbol using a 2525C SIDC  			Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  			if (sym != null) {  				if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  					dFirst10 = sym.SIDC.PartAString;  					dSecond10 = sym.SIDC.PartBString;  					// Build a symbol using the 2525D SIDC' to see if reverse  					// conversion works.  					Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  					if (sym2 != null) {  						cSIDCOut = sym2.LegacySIDC;  						symbolName = sym2.Names ["Entity"];  						modOneName = sym2.Names ["ModifierOne"];  						modTwoName = sym2.Names ["ModifierTwo"];  						if (cSIDCIn == cSIDCOut) {  							status = "pass";  							passCount++;  						} else if (sym2.LegacySIDCs.Count > 1) {  							bool match = false;  							foreach (string sidc in sym2.LegacySIDCs) {  								if (cSIDCIn == sidc) {  									match = true;  									break;  								}  							}  							if (match) {  								status = "pass (multiple)";  								passWithConditionCount++;  							} else {  								status = "FAIL";  								failCount++;  							}  						} else {  							status = "FAIL";  							failCount++;  						}  					} else {  						status = "Error making 2525D";  						derrorCount++;  					}  				} else {  					status = "Retired";  					dFirst10 = SIDC.INVALID.PartAString;  					dSecond10 = SIDC.INVALID.PartBString;  					retiredCount++;  				}  			} else {  				status = "Error making 2525C";  				cerrorCount++;  			}  			stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  			stream.Flush ();  		}  	} else  		logger.Error ("Bad SIDC : " + cSIDCIn);  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: foreach (SymbolSetLegacySymbol legacy in ss.LegacySymbols) {  	string cSIDC = legacy.Label;  	string cSIDCIn = legacy.Label;  	// Create a proper 2525C SIDC for testing  	if (cSIDCIn == null)  		break;  	if (cSIDCIn.Length == 15) {  		if (cSIDCIn.Substring (1' 1) == "*")  			cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  		cSIDCIn = cSIDCIn.Replace ('*'' '-');  		foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  			string dFirst10 = "";  			string dSecond10 = "";  			string cSIDCOut = "";  			string status = "";  			string symbolName = "";  			string modOneName = "";  			string modTwoName = "";  			totalCount++;  			cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  			cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  			if (fcode.SchemaOverride != "") {  				cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  				cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  			}  			if (fcode.DimensionOverride != "") {  				cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  				cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  			}  			// Build a symbol using a 2525C SIDC  			Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  			if (sym != null) {  				if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  					dFirst10 = sym.SIDC.PartAString;  					dSecond10 = sym.SIDC.PartBString;  					// Build a symbol using the 2525D SIDC' to see if reverse  					// conversion works.  					Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  					if (sym2 != null) {  						cSIDCOut = sym2.LegacySIDC;  						symbolName = sym2.Names ["Entity"];  						modOneName = sym2.Names ["ModifierOne"];  						modTwoName = sym2.Names ["ModifierTwo"];  						if (cSIDCIn == cSIDCOut) {  							status = "pass";  							passCount++;  						} else if (sym2.LegacySIDCs.Count > 1) {  							bool match = false;  							foreach (string sidc in sym2.LegacySIDCs) {  								if (cSIDCIn == sidc) {  									match = true;  									break;  								}  							}  							if (match) {  								status = "pass (multiple)";  								passWithConditionCount++;  							} else {  								status = "FAIL";  								failCount++;  							}  						} else {  							status = "FAIL";  							failCount++;  						}  					} else {  						status = "Error making 2525D";  						derrorCount++;  					}  				} else {  					status = "Retired";  					dFirst10 = SIDC.INVALID.PartAString;  					dSecond10 = SIDC.INVALID.PartBString;  					retiredCount++;  				}  			} else {  				status = "Error making 2525C";  				cerrorCount++;  			}  			stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  			stream.Flush ();  		}  	} else  		logger.Error ("Bad SIDC : " + cSIDCIn);  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: foreach (SymbolSetLegacySymbol legacy in ss.LegacySymbols) {  	string cSIDC = legacy.Label;  	string cSIDCIn = legacy.Label;  	// Create a proper 2525C SIDC for testing  	if (cSIDCIn == null)  		break;  	if (cSIDCIn.Length == 15) {  		if (cSIDCIn.Substring (1' 1) == "*")  			cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  		cSIDCIn = cSIDCIn.Replace ('*'' '-');  		foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  			string dFirst10 = "";  			string dSecond10 = "";  			string cSIDCOut = "";  			string status = "";  			string symbolName = "";  			string modOneName = "";  			string modTwoName = "";  			totalCount++;  			cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  			cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  			if (fcode.SchemaOverride != "") {  				cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  				cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  			}  			if (fcode.DimensionOverride != "") {  				cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  				cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  			}  			// Build a symbol using a 2525C SIDC  			Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  			if (sym != null) {  				if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  					dFirst10 = sym.SIDC.PartAString;  					dSecond10 = sym.SIDC.PartBString;  					// Build a symbol using the 2525D SIDC' to see if reverse  					// conversion works.  					Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  					if (sym2 != null) {  						cSIDCOut = sym2.LegacySIDC;  						symbolName = sym2.Names ["Entity"];  						modOneName = sym2.Names ["ModifierOne"];  						modTwoName = sym2.Names ["ModifierTwo"];  						if (cSIDCIn == cSIDCOut) {  							status = "pass";  							passCount++;  						} else if (sym2.LegacySIDCs.Count > 1) {  							bool match = false;  							foreach (string sidc in sym2.LegacySIDCs) {  								if (cSIDCIn == sidc) {  									match = true;  									break;  								}  							}  							if (match) {  								status = "pass (multiple)";  								passWithConditionCount++;  							} else {  								status = "FAIL";  								failCount++;  							}  						} else {  							status = "FAIL";  							failCount++;  						}  					} else {  						status = "Error making 2525D";  						derrorCount++;  					}  				} else {  					status = "Retired";  					dFirst10 = SIDC.INVALID.PartAString;  					dSecond10 = SIDC.INVALID.PartBString;  					retiredCount++;  				}  			} else {  				status = "Error making 2525C";  				cerrorCount++;  			}  			stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  			stream.Flush ();  		}  	} else  		logger.Error ("Bad SIDC : " + cSIDCIn);  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: if (cSIDCIn.Length == 15) {  	if (cSIDCIn.Substring (1' 1) == "*")  		cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  	cSIDCIn = cSIDCIn.Replace ('*'' '-');  	foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  		string dFirst10 = "";  		string dSecond10 = "";  		string cSIDCOut = "";  		string status = "";  		string symbolName = "";  		string modOneName = "";  		string modTwoName = "";  		totalCount++;  		cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  		cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  		if (fcode.SchemaOverride != "") {  			cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  			cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  		}  		if (fcode.DimensionOverride != "") {  			cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  			cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  		}  		// Build a symbol using a 2525C SIDC  		Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  		if (sym != null) {  			if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  				dFirst10 = sym.SIDC.PartAString;  				dSecond10 = sym.SIDC.PartBString;  				// Build a symbol using the 2525D SIDC' to see if reverse  				// conversion works.  				Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  				if (sym2 != null) {  					cSIDCOut = sym2.LegacySIDC;  					symbolName = sym2.Names ["Entity"];  					modOneName = sym2.Names ["ModifierOne"];  					modTwoName = sym2.Names ["ModifierTwo"];  					if (cSIDCIn == cSIDCOut) {  						status = "pass";  						passCount++;  					} else if (sym2.LegacySIDCs.Count > 1) {  						bool match = false;  						foreach (string sidc in sym2.LegacySIDCs) {  							if (cSIDCIn == sidc) {  								match = true;  								break;  							}  						}  						if (match) {  							status = "pass (multiple)";  							passWithConditionCount++;  						} else {  							status = "FAIL";  							failCount++;  						}  					} else {  						status = "FAIL";  						failCount++;  					}  				} else {  					status = "Error making 2525D";  					derrorCount++;  				}  			} else {  				status = "Retired";  				dFirst10 = SIDC.INVALID.PartAString;  				dSecond10 = SIDC.INVALID.PartBString;  				retiredCount++;  			}  		} else {  			status = "Error making 2525C";  			cerrorCount++;  		}  		stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  		stream.Flush ();  	}  } else  	logger.Error ("Bad SIDC : " + cSIDCIn);  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: if (cSIDCIn.Length == 15) {  	if (cSIDCIn.Substring (1' 1) == "*")  		cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  	cSIDCIn = cSIDCIn.Replace ('*'' '-');  	foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  		string dFirst10 = "";  		string dSecond10 = "";  		string cSIDCOut = "";  		string status = "";  		string symbolName = "";  		string modOneName = "";  		string modTwoName = "";  		totalCount++;  		cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  		cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  		if (fcode.SchemaOverride != "") {  			cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  			cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  		}  		if (fcode.DimensionOverride != "") {  			cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  			cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  		}  		// Build a symbol using a 2525C SIDC  		Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  		if (sym != null) {  			if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  				dFirst10 = sym.SIDC.PartAString;  				dSecond10 = sym.SIDC.PartBString;  				// Build a symbol using the 2525D SIDC' to see if reverse  				// conversion works.  				Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  				if (sym2 != null) {  					cSIDCOut = sym2.LegacySIDC;  					symbolName = sym2.Names ["Entity"];  					modOneName = sym2.Names ["ModifierOne"];  					modTwoName = sym2.Names ["ModifierTwo"];  					if (cSIDCIn == cSIDCOut) {  						status = "pass";  						passCount++;  					} else if (sym2.LegacySIDCs.Count > 1) {  						bool match = false;  						foreach (string sidc in sym2.LegacySIDCs) {  							if (cSIDCIn == sidc) {  								match = true;  								break;  							}  						}  						if (match) {  							status = "pass (multiple)";  							passWithConditionCount++;  						} else {  							status = "FAIL";  							failCount++;  						}  					} else {  						status = "FAIL";  						failCount++;  					}  				} else {  					status = "Error making 2525D";  					derrorCount++;  				}  			} else {  				status = "Retired";  				dFirst10 = SIDC.INVALID.PartAString;  				dSecond10 = SIDC.INVALID.PartBString;  				retiredCount++;  			}  		} else {  			status = "Error making 2525C";  			cerrorCount++;  		}  		stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  		stream.Flush ();  	}  } else  	logger.Error ("Bad SIDC : " + cSIDCIn);  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: if (cSIDCIn.Length == 15) {  	if (cSIDCIn.Substring (1' 1) == "*")  		cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  	cSIDCIn = cSIDCIn.Replace ('*'' '-');  	foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  		string dFirst10 = "";  		string dSecond10 = "";  		string cSIDCOut = "";  		string status = "";  		string symbolName = "";  		string modOneName = "";  		string modTwoName = "";  		totalCount++;  		cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  		cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  		if (fcode.SchemaOverride != "") {  			cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  			cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  		}  		if (fcode.DimensionOverride != "") {  			cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  			cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  		}  		// Build a symbol using a 2525C SIDC  		Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  		if (sym != null) {  			if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  				dFirst10 = sym.SIDC.PartAString;  				dSecond10 = sym.SIDC.PartBString;  				// Build a symbol using the 2525D SIDC' to see if reverse  				// conversion works.  				Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  				if (sym2 != null) {  					cSIDCOut = sym2.LegacySIDC;  					symbolName = sym2.Names ["Entity"];  					modOneName = sym2.Names ["ModifierOne"];  					modTwoName = sym2.Names ["ModifierTwo"];  					if (cSIDCIn == cSIDCOut) {  						status = "pass";  						passCount++;  					} else if (sym2.LegacySIDCs.Count > 1) {  						bool match = false;  						foreach (string sidc in sym2.LegacySIDCs) {  							if (cSIDCIn == sidc) {  								match = true;  								break;  							}  						}  						if (match) {  							status = "pass (multiple)";  							passWithConditionCount++;  						} else {  							status = "FAIL";  							failCount++;  						}  					} else {  						status = "FAIL";  						failCount++;  					}  				} else {  					status = "Error making 2525D";  					derrorCount++;  				}  			} else {  				status = "Retired";  				dFirst10 = SIDC.INVALID.PartAString;  				dSecond10 = SIDC.INVALID.PartBString;  				retiredCount++;  			}  		} else {  			status = "Error making 2525C";  			cerrorCount++;  		}  		stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  		stream.Flush ();  	}  } else  	logger.Error ("Bad SIDC : " + cSIDCIn);  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: if (cSIDCIn.Length == 15) {  	if (cSIDCIn.Substring (1' 1) == "*")  		cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  	cSIDCIn = cSIDCIn.Replace ('*'' '-');  	foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  		string dFirst10 = "";  		string dSecond10 = "";  		string cSIDCOut = "";  		string status = "";  		string symbolName = "";  		string modOneName = "";  		string modTwoName = "";  		totalCount++;  		cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  		cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  		if (fcode.SchemaOverride != "") {  			cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  			cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  		}  		if (fcode.DimensionOverride != "") {  			cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  			cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  		}  		// Build a symbol using a 2525C SIDC  		Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  		if (sym != null) {  			if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  				dFirst10 = sym.SIDC.PartAString;  				dSecond10 = sym.SIDC.PartBString;  				// Build a symbol using the 2525D SIDC' to see if reverse  				// conversion works.  				Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  				if (sym2 != null) {  					cSIDCOut = sym2.LegacySIDC;  					symbolName = sym2.Names ["Entity"];  					modOneName = sym2.Names ["ModifierOne"];  					modTwoName = sym2.Names ["ModifierTwo"];  					if (cSIDCIn == cSIDCOut) {  						status = "pass";  						passCount++;  					} else if (sym2.LegacySIDCs.Count > 1) {  						bool match = false;  						foreach (string sidc in sym2.LegacySIDCs) {  							if (cSIDCIn == sidc) {  								match = true;  								break;  							}  						}  						if (match) {  							status = "pass (multiple)";  							passWithConditionCount++;  						} else {  							status = "FAIL";  							failCount++;  						}  					} else {  						status = "FAIL";  						failCount++;  					}  				} else {  					status = "Error making 2525D";  					derrorCount++;  				}  			} else {  				status = "Retired";  				dFirst10 = SIDC.INVALID.PartAString;  				dSecond10 = SIDC.INVALID.PartBString;  				retiredCount++;  			}  		} else {  			status = "Error making 2525C";  			cerrorCount++;  		}  		stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  		stream.Flush ();  	}  } else  	logger.Error ("Bad SIDC : " + cSIDCIn);  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: if (cSIDCIn.Length == 15) {  	if (cSIDCIn.Substring (1' 1) == "*")  		cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  	cSIDCIn = cSIDCIn.Replace ('*'' '-');  	foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  		string dFirst10 = "";  		string dSecond10 = "";  		string cSIDCOut = "";  		string status = "";  		string symbolName = "";  		string modOneName = "";  		string modTwoName = "";  		totalCount++;  		cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  		cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  		if (fcode.SchemaOverride != "") {  			cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  			cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  		}  		if (fcode.DimensionOverride != "") {  			cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  			cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  		}  		// Build a symbol using a 2525C SIDC  		Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  		if (sym != null) {  			if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  				dFirst10 = sym.SIDC.PartAString;  				dSecond10 = sym.SIDC.PartBString;  				// Build a symbol using the 2525D SIDC' to see if reverse  				// conversion works.  				Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  				if (sym2 != null) {  					cSIDCOut = sym2.LegacySIDC;  					symbolName = sym2.Names ["Entity"];  					modOneName = sym2.Names ["ModifierOne"];  					modTwoName = sym2.Names ["ModifierTwo"];  					if (cSIDCIn == cSIDCOut) {  						status = "pass";  						passCount++;  					} else if (sym2.LegacySIDCs.Count > 1) {  						bool match = false;  						foreach (string sidc in sym2.LegacySIDCs) {  							if (cSIDCIn == sidc) {  								match = true;  								break;  							}  						}  						if (match) {  							status = "pass (multiple)";  							passWithConditionCount++;  						} else {  							status = "FAIL";  							failCount++;  						}  					} else {  						status = "FAIL";  						failCount++;  					}  				} else {  					status = "Error making 2525D";  					derrorCount++;  				}  			} else {  				status = "Retired";  				dFirst10 = SIDC.INVALID.PartAString;  				dSecond10 = SIDC.INVALID.PartBString;  				retiredCount++;  			}  		} else {  			status = "Error making 2525C";  			cerrorCount++;  		}  		stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  		stream.Flush ();  	}  } else  	logger.Error ("Bad SIDC : " + cSIDCIn);  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: if (cSIDCIn.Length == 15) {  	if (cSIDCIn.Substring (1' 1) == "*")  		cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  	cSIDCIn = cSIDCIn.Replace ('*'' '-');  	foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  		string dFirst10 = "";  		string dSecond10 = "";  		string cSIDCOut = "";  		string status = "";  		string symbolName = "";  		string modOneName = "";  		string modTwoName = "";  		totalCount++;  		cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  		cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  		if (fcode.SchemaOverride != "") {  			cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  			cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  		}  		if (fcode.DimensionOverride != "") {  			cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  			cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  		}  		// Build a symbol using a 2525C SIDC  		Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  		if (sym != null) {  			if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  				dFirst10 = sym.SIDC.PartAString;  				dSecond10 = sym.SIDC.PartBString;  				// Build a symbol using the 2525D SIDC' to see if reverse  				// conversion works.  				Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  				if (sym2 != null) {  					cSIDCOut = sym2.LegacySIDC;  					symbolName = sym2.Names ["Entity"];  					modOneName = sym2.Names ["ModifierOne"];  					modTwoName = sym2.Names ["ModifierTwo"];  					if (cSIDCIn == cSIDCOut) {  						status = "pass";  						passCount++;  					} else if (sym2.LegacySIDCs.Count > 1) {  						bool match = false;  						foreach (string sidc in sym2.LegacySIDCs) {  							if (cSIDCIn == sidc) {  								match = true;  								break;  							}  						}  						if (match) {  							status = "pass (multiple)";  							passWithConditionCount++;  						} else {  							status = "FAIL";  							failCount++;  						}  					} else {  						status = "FAIL";  						failCount++;  					}  				} else {  					status = "Error making 2525D";  					derrorCount++;  				}  			} else {  				status = "Retired";  				dFirst10 = SIDC.INVALID.PartAString;  				dSecond10 = SIDC.INVALID.PartBString;  				retiredCount++;  			}  		} else {  			status = "Error making 2525C";  			cerrorCount++;  		}  		stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  		stream.Flush ();  	}  } else  	logger.Error ("Bad SIDC : " + cSIDCIn);  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: if (cSIDCIn.Length == 15) {  	if (cSIDCIn.Substring (1' 1) == "*")  		cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  	cSIDCIn = cSIDCIn.Replace ('*'' '-');  	foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  		string dFirst10 = "";  		string dSecond10 = "";  		string cSIDCOut = "";  		string status = "";  		string symbolName = "";  		string modOneName = "";  		string modTwoName = "";  		totalCount++;  		cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  		cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  		if (fcode.SchemaOverride != "") {  			cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  			cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  		}  		if (fcode.DimensionOverride != "") {  			cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  			cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  		}  		// Build a symbol using a 2525C SIDC  		Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  		if (sym != null) {  			if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  				dFirst10 = sym.SIDC.PartAString;  				dSecond10 = sym.SIDC.PartBString;  				// Build a symbol using the 2525D SIDC' to see if reverse  				// conversion works.  				Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  				if (sym2 != null) {  					cSIDCOut = sym2.LegacySIDC;  					symbolName = sym2.Names ["Entity"];  					modOneName = sym2.Names ["ModifierOne"];  					modTwoName = sym2.Names ["ModifierTwo"];  					if (cSIDCIn == cSIDCOut) {  						status = "pass";  						passCount++;  					} else if (sym2.LegacySIDCs.Count > 1) {  						bool match = false;  						foreach (string sidc in sym2.LegacySIDCs) {  							if (cSIDCIn == sidc) {  								match = true;  								break;  							}  						}  						if (match) {  							status = "pass (multiple)";  							passWithConditionCount++;  						} else {  							status = "FAIL";  							failCount++;  						}  					} else {  						status = "FAIL";  						failCount++;  					}  				} else {  					status = "Error making 2525D";  					derrorCount++;  				}  			} else {  				status = "Retired";  				dFirst10 = SIDC.INVALID.PartAString;  				dSecond10 = SIDC.INVALID.PartBString;  				retiredCount++;  			}  		} else {  			status = "Error making 2525C";  			cerrorCount++;  		}  		stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  		stream.Flush ();  	}  } else  	logger.Error ("Bad SIDC : " + cSIDCIn);  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: if (cSIDCIn.Length == 15) {  	if (cSIDCIn.Substring (1' 1) == "*")  		cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  	cSIDCIn = cSIDCIn.Replace ('*'' '-');  	foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  		string dFirst10 = "";  		string dSecond10 = "";  		string cSIDCOut = "";  		string status = "";  		string symbolName = "";  		string modOneName = "";  		string modTwoName = "";  		totalCount++;  		cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  		cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  		if (fcode.SchemaOverride != "") {  			cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  			cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  		}  		if (fcode.DimensionOverride != "") {  			cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  			cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  		}  		// Build a symbol using a 2525C SIDC  		Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  		if (sym != null) {  			if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  				dFirst10 = sym.SIDC.PartAString;  				dSecond10 = sym.SIDC.PartBString;  				// Build a symbol using the 2525D SIDC' to see if reverse  				// conversion works.  				Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  				if (sym2 != null) {  					cSIDCOut = sym2.LegacySIDC;  					symbolName = sym2.Names ["Entity"];  					modOneName = sym2.Names ["ModifierOne"];  					modTwoName = sym2.Names ["ModifierTwo"];  					if (cSIDCIn == cSIDCOut) {  						status = "pass";  						passCount++;  					} else if (sym2.LegacySIDCs.Count > 1) {  						bool match = false;  						foreach (string sidc in sym2.LegacySIDCs) {  							if (cSIDCIn == sidc) {  								match = true;  								break;  							}  						}  						if (match) {  							status = "pass (multiple)";  							passWithConditionCount++;  						} else {  							status = "FAIL";  							failCount++;  						}  					} else {  						status = "FAIL";  						failCount++;  					}  				} else {  					status = "Error making 2525D";  					derrorCount++;  				}  			} else {  				status = "Retired";  				dFirst10 = SIDC.INVALID.PartAString;  				dSecond10 = SIDC.INVALID.PartBString;  				retiredCount++;  			}  		} else {  			status = "Error making 2525C";  			cerrorCount++;  		}  		stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  		stream.Flush ();  	}  } else  	logger.Error ("Bad SIDC : " + cSIDCIn);  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: if (cSIDCIn.Length == 15) {  	if (cSIDCIn.Substring (1' 1) == "*")  		cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  	cSIDCIn = cSIDCIn.Replace ('*'' '-');  	foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  		string dFirst10 = "";  		string dSecond10 = "";  		string cSIDCOut = "";  		string status = "";  		string symbolName = "";  		string modOneName = "";  		string modTwoName = "";  		totalCount++;  		cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  		cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  		if (fcode.SchemaOverride != "") {  			cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  			cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  		}  		if (fcode.DimensionOverride != "") {  			cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  			cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  		}  		// Build a symbol using a 2525C SIDC  		Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  		if (sym != null) {  			if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  				dFirst10 = sym.SIDC.PartAString;  				dSecond10 = sym.SIDC.PartBString;  				// Build a symbol using the 2525D SIDC' to see if reverse  				// conversion works.  				Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  				if (sym2 != null) {  					cSIDCOut = sym2.LegacySIDC;  					symbolName = sym2.Names ["Entity"];  					modOneName = sym2.Names ["ModifierOne"];  					modTwoName = sym2.Names ["ModifierTwo"];  					if (cSIDCIn == cSIDCOut) {  						status = "pass";  						passCount++;  					} else if (sym2.LegacySIDCs.Count > 1) {  						bool match = false;  						foreach (string sidc in sym2.LegacySIDCs) {  							if (cSIDCIn == sidc) {  								match = true;  								break;  							}  						}  						if (match) {  							status = "pass (multiple)";  							passWithConditionCount++;  						} else {  							status = "FAIL";  							failCount++;  						}  					} else {  						status = "FAIL";  						failCount++;  					}  				} else {  					status = "Error making 2525D";  					derrorCount++;  				}  			} else {  				status = "Retired";  				dFirst10 = SIDC.INVALID.PartAString;  				dSecond10 = SIDC.INVALID.PartBString;  				retiredCount++;  			}  		} else {  			status = "Error making 2525C";  			cerrorCount++;  		}  		stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  		stream.Flush ();  	}  } else  	logger.Error ("Bad SIDC : " + cSIDCIn);  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: if (cSIDCIn.Length == 15) {  	if (cSIDCIn.Substring (1' 1) == "*")  		cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  	cSIDCIn = cSIDCIn.Replace ('*'' '-');  	foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  		string dFirst10 = "";  		string dSecond10 = "";  		string cSIDCOut = "";  		string status = "";  		string symbolName = "";  		string modOneName = "";  		string modTwoName = "";  		totalCount++;  		cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  		cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  		if (fcode.SchemaOverride != "") {  			cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  			cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  		}  		if (fcode.DimensionOverride != "") {  			cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  			cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  		}  		// Build a symbol using a 2525C SIDC  		Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  		if (sym != null) {  			if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  				dFirst10 = sym.SIDC.PartAString;  				dSecond10 = sym.SIDC.PartBString;  				// Build a symbol using the 2525D SIDC' to see if reverse  				// conversion works.  				Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  				if (sym2 != null) {  					cSIDCOut = sym2.LegacySIDC;  					symbolName = sym2.Names ["Entity"];  					modOneName = sym2.Names ["ModifierOne"];  					modTwoName = sym2.Names ["ModifierTwo"];  					if (cSIDCIn == cSIDCOut) {  						status = "pass";  						passCount++;  					} else if (sym2.LegacySIDCs.Count > 1) {  						bool match = false;  						foreach (string sidc in sym2.LegacySIDCs) {  							if (cSIDCIn == sidc) {  								match = true;  								break;  							}  						}  						if (match) {  							status = "pass (multiple)";  							passWithConditionCount++;  						} else {  							status = "FAIL";  							failCount++;  						}  					} else {  						status = "FAIL";  						failCount++;  					}  				} else {  					status = "Error making 2525D";  					derrorCount++;  				}  			} else {  				status = "Retired";  				dFirst10 = SIDC.INVALID.PartAString;  				dSecond10 = SIDC.INVALID.PartBString;  				retiredCount++;  			}  		} else {  			status = "Error making 2525C";  			cerrorCount++;  		}  		stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  		stream.Flush ();  	}  } else  	logger.Error ("Bad SIDC : " + cSIDCIn);  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: if (cSIDCIn.Length == 15) {  	if (cSIDCIn.Substring (1' 1) == "*")  		cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  	cSIDCIn = cSIDCIn.Replace ('*'' '-');  	foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  		string dFirst10 = "";  		string dSecond10 = "";  		string cSIDCOut = "";  		string status = "";  		string symbolName = "";  		string modOneName = "";  		string modTwoName = "";  		totalCount++;  		cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  		cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  		if (fcode.SchemaOverride != "") {  			cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  			cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  		}  		if (fcode.DimensionOverride != "") {  			cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  			cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  		}  		// Build a symbol using a 2525C SIDC  		Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  		if (sym != null) {  			if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  				dFirst10 = sym.SIDC.PartAString;  				dSecond10 = sym.SIDC.PartBString;  				// Build a symbol using the 2525D SIDC' to see if reverse  				// conversion works.  				Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  				if (sym2 != null) {  					cSIDCOut = sym2.LegacySIDC;  					symbolName = sym2.Names ["Entity"];  					modOneName = sym2.Names ["ModifierOne"];  					modTwoName = sym2.Names ["ModifierTwo"];  					if (cSIDCIn == cSIDCOut) {  						status = "pass";  						passCount++;  					} else if (sym2.LegacySIDCs.Count > 1) {  						bool match = false;  						foreach (string sidc in sym2.LegacySIDCs) {  							if (cSIDCIn == sidc) {  								match = true;  								break;  							}  						}  						if (match) {  							status = "pass (multiple)";  							passWithConditionCount++;  						} else {  							status = "FAIL";  							failCount++;  						}  					} else {  						status = "FAIL";  						failCount++;  					}  				} else {  					status = "Error making 2525D";  					derrorCount++;  				}  			} else {  				status = "Retired";  				dFirst10 = SIDC.INVALID.PartAString;  				dSecond10 = SIDC.INVALID.PartBString;  				retiredCount++;  			}  		} else {  			status = "Error making 2525C";  			cerrorCount++;  		}  		stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  		stream.Flush ();  	}  } else  	logger.Error ("Bad SIDC : " + cSIDCIn);  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: if (cSIDCIn.Length == 15) {  	if (cSIDCIn.Substring (1' 1) == "*")  		cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  	cSIDCIn = cSIDCIn.Replace ('*'' '-');  	foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  		string dFirst10 = "";  		string dSecond10 = "";  		string cSIDCOut = "";  		string status = "";  		string symbolName = "";  		string modOneName = "";  		string modTwoName = "";  		totalCount++;  		cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  		cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  		if (fcode.SchemaOverride != "") {  			cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  			cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  		}  		if (fcode.DimensionOverride != "") {  			cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  			cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  		}  		// Build a symbol using a 2525C SIDC  		Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  		if (sym != null) {  			if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  				dFirst10 = sym.SIDC.PartAString;  				dSecond10 = sym.SIDC.PartBString;  				// Build a symbol using the 2525D SIDC' to see if reverse  				// conversion works.  				Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  				if (sym2 != null) {  					cSIDCOut = sym2.LegacySIDC;  					symbolName = sym2.Names ["Entity"];  					modOneName = sym2.Names ["ModifierOne"];  					modTwoName = sym2.Names ["ModifierTwo"];  					if (cSIDCIn == cSIDCOut) {  						status = "pass";  						passCount++;  					} else if (sym2.LegacySIDCs.Count > 1) {  						bool match = false;  						foreach (string sidc in sym2.LegacySIDCs) {  							if (cSIDCIn == sidc) {  								match = true;  								break;  							}  						}  						if (match) {  							status = "pass (multiple)";  							passWithConditionCount++;  						} else {  							status = "FAIL";  							failCount++;  						}  					} else {  						status = "FAIL";  						failCount++;  					}  				} else {  					status = "Error making 2525D";  					derrorCount++;  				}  			} else {  				status = "Retired";  				dFirst10 = SIDC.INVALID.PartAString;  				dSecond10 = SIDC.INVALID.PartBString;  				retiredCount++;  			}  		} else {  			status = "Error making 2525C";  			cerrorCount++;  		}  		stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  		stream.Flush ();  	}  } else  	logger.Error ("Bad SIDC : " + cSIDCIn);  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: if (cSIDCIn.Length == 15) {  	if (cSIDCIn.Substring (1' 1) == "*")  		cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  	cSIDCIn = cSIDCIn.Replace ('*'' '-');  	foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  		string dFirst10 = "";  		string dSecond10 = "";  		string cSIDCOut = "";  		string status = "";  		string symbolName = "";  		string modOneName = "";  		string modTwoName = "";  		totalCount++;  		cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  		cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  		if (fcode.SchemaOverride != "") {  			cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  			cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  		}  		if (fcode.DimensionOverride != "") {  			cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  			cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  		}  		// Build a symbol using a 2525C SIDC  		Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  		if (sym != null) {  			if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  				dFirst10 = sym.SIDC.PartAString;  				dSecond10 = sym.SIDC.PartBString;  				// Build a symbol using the 2525D SIDC' to see if reverse  				// conversion works.  				Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  				if (sym2 != null) {  					cSIDCOut = sym2.LegacySIDC;  					symbolName = sym2.Names ["Entity"];  					modOneName = sym2.Names ["ModifierOne"];  					modTwoName = sym2.Names ["ModifierTwo"];  					if (cSIDCIn == cSIDCOut) {  						status = "pass";  						passCount++;  					} else if (sym2.LegacySIDCs.Count > 1) {  						bool match = false;  						foreach (string sidc in sym2.LegacySIDCs) {  							if (cSIDCIn == sidc) {  								match = true;  								break;  							}  						}  						if (match) {  							status = "pass (multiple)";  							passWithConditionCount++;  						} else {  							status = "FAIL";  							failCount++;  						}  					} else {  						status = "FAIL";  						failCount++;  					}  				} else {  					status = "Error making 2525D";  					derrorCount++;  				}  			} else {  				status = "Retired";  				dFirst10 = SIDC.INVALID.PartAString;  				dSecond10 = SIDC.INVALID.PartBString;  				retiredCount++;  			}  		} else {  			status = "Error making 2525C";  			cerrorCount++;  		}  		stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  		stream.Flush ();  	}  } else  	logger.Error ("Bad SIDC : " + cSIDCIn);  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: if (cSIDCIn.Length == 15) {  	if (cSIDCIn.Substring (1' 1) == "*")  		cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  	cSIDCIn = cSIDCIn.Replace ('*'' '-');  	foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  		string dFirst10 = "";  		string dSecond10 = "";  		string cSIDCOut = "";  		string status = "";  		string symbolName = "";  		string modOneName = "";  		string modTwoName = "";  		totalCount++;  		cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  		cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  		if (fcode.SchemaOverride != "") {  			cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  			cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  		}  		if (fcode.DimensionOverride != "") {  			cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  			cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  		}  		// Build a symbol using a 2525C SIDC  		Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  		if (sym != null) {  			if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  				dFirst10 = sym.SIDC.PartAString;  				dSecond10 = sym.SIDC.PartBString;  				// Build a symbol using the 2525D SIDC' to see if reverse  				// conversion works.  				Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  				if (sym2 != null) {  					cSIDCOut = sym2.LegacySIDC;  					symbolName = sym2.Names ["Entity"];  					modOneName = sym2.Names ["ModifierOne"];  					modTwoName = sym2.Names ["ModifierTwo"];  					if (cSIDCIn == cSIDCOut) {  						status = "pass";  						passCount++;  					} else if (sym2.LegacySIDCs.Count > 1) {  						bool match = false;  						foreach (string sidc in sym2.LegacySIDCs) {  							if (cSIDCIn == sidc) {  								match = true;  								break;  							}  						}  						if (match) {  							status = "pass (multiple)";  							passWithConditionCount++;  						} else {  							status = "FAIL";  							failCount++;  						}  					} else {  						status = "FAIL";  						failCount++;  					}  				} else {  					status = "Error making 2525D";  					derrorCount++;  				}  			} else {  				status = "Retired";  				dFirst10 = SIDC.INVALID.PartAString;  				dSecond10 = SIDC.INVALID.PartBString;  				retiredCount++;  			}  		} else {  			status = "Error making 2525C";  			cerrorCount++;  		}  		stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  		stream.Flush ();  	}  } else  	logger.Error ("Bad SIDC : " + cSIDCIn);  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: if (cSIDCIn.Length == 15) {  	if (cSIDCIn.Substring (1' 1) == "*")  		cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  	cSIDCIn = cSIDCIn.Replace ('*'' '-');  	foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  		string dFirst10 = "";  		string dSecond10 = "";  		string cSIDCOut = "";  		string status = "";  		string symbolName = "";  		string modOneName = "";  		string modTwoName = "";  		totalCount++;  		cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  		cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  		if (fcode.SchemaOverride != "") {  			cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  			cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  		}  		if (fcode.DimensionOverride != "") {  			cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  			cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  		}  		// Build a symbol using a 2525C SIDC  		Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  		if (sym != null) {  			if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  				dFirst10 = sym.SIDC.PartAString;  				dSecond10 = sym.SIDC.PartBString;  				// Build a symbol using the 2525D SIDC' to see if reverse  				// conversion works.  				Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  				if (sym2 != null) {  					cSIDCOut = sym2.LegacySIDC;  					symbolName = sym2.Names ["Entity"];  					modOneName = sym2.Names ["ModifierOne"];  					modTwoName = sym2.Names ["ModifierTwo"];  					if (cSIDCIn == cSIDCOut) {  						status = "pass";  						passCount++;  					} else if (sym2.LegacySIDCs.Count > 1) {  						bool match = false;  						foreach (string sidc in sym2.LegacySIDCs) {  							if (cSIDCIn == sidc) {  								match = true;  								break;  							}  						}  						if (match) {  							status = "pass (multiple)";  							passWithConditionCount++;  						} else {  							status = "FAIL";  							failCount++;  						}  					} else {  						status = "FAIL";  						failCount++;  					}  				} else {  					status = "Error making 2525D";  					derrorCount++;  				}  			} else {  				status = "Retired";  				dFirst10 = SIDC.INVALID.PartAString;  				dSecond10 = SIDC.INVALID.PartBString;  				retiredCount++;  			}  		} else {  			status = "Error making 2525C";  			cerrorCount++;  		}  		stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  		stream.Flush ();  	}  } else  	logger.Error ("Bad SIDC : " + cSIDCIn);  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: if (cSIDCIn.Length == 15) {  	if (cSIDCIn.Substring (1' 1) == "*")  		cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  	cSIDCIn = cSIDCIn.Replace ('*'' '-');  	foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  		string dFirst10 = "";  		string dSecond10 = "";  		string cSIDCOut = "";  		string status = "";  		string symbolName = "";  		string modOneName = "";  		string modTwoName = "";  		totalCount++;  		cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  		cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  		if (fcode.SchemaOverride != "") {  			cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  			cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  		}  		if (fcode.DimensionOverride != "") {  			cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  			cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  		}  		// Build a symbol using a 2525C SIDC  		Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  		if (sym != null) {  			if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  				dFirst10 = sym.SIDC.PartAString;  				dSecond10 = sym.SIDC.PartBString;  				// Build a symbol using the 2525D SIDC' to see if reverse  				// conversion works.  				Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  				if (sym2 != null) {  					cSIDCOut = sym2.LegacySIDC;  					symbolName = sym2.Names ["Entity"];  					modOneName = sym2.Names ["ModifierOne"];  					modTwoName = sym2.Names ["ModifierTwo"];  					if (cSIDCIn == cSIDCOut) {  						status = "pass";  						passCount++;  					} else if (sym2.LegacySIDCs.Count > 1) {  						bool match = false;  						foreach (string sidc in sym2.LegacySIDCs) {  							if (cSIDCIn == sidc) {  								match = true;  								break;  							}  						}  						if (match) {  							status = "pass (multiple)";  							passWithConditionCount++;  						} else {  							status = "FAIL";  							failCount++;  						}  					} else {  						status = "FAIL";  						failCount++;  					}  				} else {  					status = "Error making 2525D";  					derrorCount++;  				}  			} else {  				status = "Retired";  				dFirst10 = SIDC.INVALID.PartAString;  				dSecond10 = SIDC.INVALID.PartBString;  				retiredCount++;  			}  		} else {  			status = "Error making 2525C";  			cerrorCount++;  		}  		stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  		stream.Flush ();  	}  } else  	logger.Error ("Bad SIDC : " + cSIDCIn);  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: if (cSIDCIn.Length == 15) {  	if (cSIDCIn.Substring (1' 1) == "*")  		cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  	cSIDCIn = cSIDCIn.Replace ('*'' '-');  	foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  		string dFirst10 = "";  		string dSecond10 = "";  		string cSIDCOut = "";  		string status = "";  		string symbolName = "";  		string modOneName = "";  		string modTwoName = "";  		totalCount++;  		cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  		cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  		if (fcode.SchemaOverride != "") {  			cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  			cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  		}  		if (fcode.DimensionOverride != "") {  			cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  			cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  		}  		// Build a symbol using a 2525C SIDC  		Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  		if (sym != null) {  			if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  				dFirst10 = sym.SIDC.PartAString;  				dSecond10 = sym.SIDC.PartBString;  				// Build a symbol using the 2525D SIDC' to see if reverse  				// conversion works.  				Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  				if (sym2 != null) {  					cSIDCOut = sym2.LegacySIDC;  					symbolName = sym2.Names ["Entity"];  					modOneName = sym2.Names ["ModifierOne"];  					modTwoName = sym2.Names ["ModifierTwo"];  					if (cSIDCIn == cSIDCOut) {  						status = "pass";  						passCount++;  					} else if (sym2.LegacySIDCs.Count > 1) {  						bool match = false;  						foreach (string sidc in sym2.LegacySIDCs) {  							if (cSIDCIn == sidc) {  								match = true;  								break;  							}  						}  						if (match) {  							status = "pass (multiple)";  							passWithConditionCount++;  						} else {  							status = "FAIL";  							failCount++;  						}  					} else {  						status = "FAIL";  						failCount++;  					}  				} else {  					status = "Error making 2525D";  					derrorCount++;  				}  			} else {  				status = "Retired";  				dFirst10 = SIDC.INVALID.PartAString;  				dSecond10 = SIDC.INVALID.PartBString;  				retiredCount++;  			}  		} else {  			status = "Error making 2525C";  			cerrorCount++;  		}  		stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  		stream.Flush ();  	}  } else  	logger.Error ("Bad SIDC : " + cSIDCIn);  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: if (cSIDCIn.Length == 15) {  	if (cSIDCIn.Substring (1' 1) == "*")  		cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  	cSIDCIn = cSIDCIn.Replace ('*'' '-');  	foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  		string dFirst10 = "";  		string dSecond10 = "";  		string cSIDCOut = "";  		string status = "";  		string symbolName = "";  		string modOneName = "";  		string modTwoName = "";  		totalCount++;  		cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  		cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  		if (fcode.SchemaOverride != "") {  			cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  			cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  		}  		if (fcode.DimensionOverride != "") {  			cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  			cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  		}  		// Build a symbol using a 2525C SIDC  		Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  		if (sym != null) {  			if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  				dFirst10 = sym.SIDC.PartAString;  				dSecond10 = sym.SIDC.PartBString;  				// Build a symbol using the 2525D SIDC' to see if reverse  				// conversion works.  				Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  				if (sym2 != null) {  					cSIDCOut = sym2.LegacySIDC;  					symbolName = sym2.Names ["Entity"];  					modOneName = sym2.Names ["ModifierOne"];  					modTwoName = sym2.Names ["ModifierTwo"];  					if (cSIDCIn == cSIDCOut) {  						status = "pass";  						passCount++;  					} else if (sym2.LegacySIDCs.Count > 1) {  						bool match = false;  						foreach (string sidc in sym2.LegacySIDCs) {  							if (cSIDCIn == sidc) {  								match = true;  								break;  							}  						}  						if (match) {  							status = "pass (multiple)";  							passWithConditionCount++;  						} else {  							status = "FAIL";  							failCount++;  						}  					} else {  						status = "FAIL";  						failCount++;  					}  				} else {  					status = "Error making 2525D";  					derrorCount++;  				}  			} else {  				status = "Retired";  				dFirst10 = SIDC.INVALID.PartAString;  				dSecond10 = SIDC.INVALID.PartBString;  				retiredCount++;  			}  		} else {  			status = "Error making 2525C";  			cerrorCount++;  		}  		stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  		stream.Flush ();  	}  } else  	logger.Error ("Bad SIDC : " + cSIDCIn);  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: if (cSIDCIn.Substring (1' 1) == "*")  	cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: cSIDCIn = cSIDCIn.Substring (0' 1) + "P" + cSIDCIn.Substring (2);  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  	string dFirst10 = "";  	string dSecond10 = "";  	string cSIDCOut = "";  	string status = "";  	string symbolName = "";  	string modOneName = "";  	string modTwoName = "";  	totalCount++;  	cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  	cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  	if (fcode.SchemaOverride != "") {  		cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  		cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  	}  	if (fcode.DimensionOverride != "") {  		cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  		cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  	}  	// Build a symbol using a 2525C SIDC  	Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  	if (sym != null) {  		if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  			dFirst10 = sym.SIDC.PartAString;  			dSecond10 = sym.SIDC.PartBString;  			// Build a symbol using the 2525D SIDC' to see if reverse  			// conversion works.  			Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  			if (sym2 != null) {  				cSIDCOut = sym2.LegacySIDC;  				symbolName = sym2.Names ["Entity"];  				modOneName = sym2.Names ["ModifierOne"];  				modTwoName = sym2.Names ["ModifierTwo"];  				if (cSIDCIn == cSIDCOut) {  					status = "pass";  					passCount++;  				} else if (sym2.LegacySIDCs.Count > 1) {  					bool match = false;  					foreach (string sidc in sym2.LegacySIDCs) {  						if (cSIDCIn == sidc) {  							match = true;  							break;  						}  					}  					if (match) {  						status = "pass (multiple)";  						passWithConditionCount++;  					} else {  						status = "FAIL";  						failCount++;  					}  				} else {  					status = "FAIL";  					failCount++;  				}  			} else {  				status = "Error making 2525D";  				derrorCount++;  			}  		} else {  			status = "Retired";  			dFirst10 = SIDC.INVALID.PartAString;  			dSecond10 = SIDC.INVALID.PartBString;  			retiredCount++;  		}  	} else {  		status = "Error making 2525C";  		cerrorCount++;  	}  	stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  	stream.Flush ();  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  	string dFirst10 = "";  	string dSecond10 = "";  	string cSIDCOut = "";  	string status = "";  	string symbolName = "";  	string modOneName = "";  	string modTwoName = "";  	totalCount++;  	cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  	cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  	if (fcode.SchemaOverride != "") {  		cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  		cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  	}  	if (fcode.DimensionOverride != "") {  		cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  		cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  	}  	// Build a symbol using a 2525C SIDC  	Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  	if (sym != null) {  		if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  			dFirst10 = sym.SIDC.PartAString;  			dSecond10 = sym.SIDC.PartBString;  			// Build a symbol using the 2525D SIDC' to see if reverse  			// conversion works.  			Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  			if (sym2 != null) {  				cSIDCOut = sym2.LegacySIDC;  				symbolName = sym2.Names ["Entity"];  				modOneName = sym2.Names ["ModifierOne"];  				modTwoName = sym2.Names ["ModifierTwo"];  				if (cSIDCIn == cSIDCOut) {  					status = "pass";  					passCount++;  				} else if (sym2.LegacySIDCs.Count > 1) {  					bool match = false;  					foreach (string sidc in sym2.LegacySIDCs) {  						if (cSIDCIn == sidc) {  							match = true;  							break;  						}  					}  					if (match) {  						status = "pass (multiple)";  						passWithConditionCount++;  					} else {  						status = "FAIL";  						failCount++;  					}  				} else {  					status = "FAIL";  					failCount++;  				}  			} else {  				status = "Error making 2525D";  				derrorCount++;  			}  		} else {  			status = "Retired";  			dFirst10 = SIDC.INVALID.PartAString;  			dSecond10 = SIDC.INVALID.PartBString;  			retiredCount++;  		}  	} else {  		status = "Error making 2525C";  		cerrorCount++;  	}  	stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  	stream.Flush ();  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  	string dFirst10 = "";  	string dSecond10 = "";  	string cSIDCOut = "";  	string status = "";  	string symbolName = "";  	string modOneName = "";  	string modTwoName = "";  	totalCount++;  	cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  	cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  	if (fcode.SchemaOverride != "") {  		cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  		cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  	}  	if (fcode.DimensionOverride != "") {  		cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  		cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  	}  	// Build a symbol using a 2525C SIDC  	Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  	if (sym != null) {  		if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  			dFirst10 = sym.SIDC.PartAString;  			dSecond10 = sym.SIDC.PartBString;  			// Build a symbol using the 2525D SIDC' to see if reverse  			// conversion works.  			Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  			if (sym2 != null) {  				cSIDCOut = sym2.LegacySIDC;  				symbolName = sym2.Names ["Entity"];  				modOneName = sym2.Names ["ModifierOne"];  				modTwoName = sym2.Names ["ModifierTwo"];  				if (cSIDCIn == cSIDCOut) {  					status = "pass";  					passCount++;  				} else if (sym2.LegacySIDCs.Count > 1) {  					bool match = false;  					foreach (string sidc in sym2.LegacySIDCs) {  						if (cSIDCIn == sidc) {  							match = true;  							break;  						}  					}  					if (match) {  						status = "pass (multiple)";  						passWithConditionCount++;  					} else {  						status = "FAIL";  						failCount++;  					}  				} else {  					status = "FAIL";  					failCount++;  				}  			} else {  				status = "Error making 2525D";  				derrorCount++;  			}  		} else {  			status = "Retired";  			dFirst10 = SIDC.INVALID.PartAString;  			dSecond10 = SIDC.INVALID.PartBString;  			retiredCount++;  		}  	} else {  		status = "Error making 2525C";  		cerrorCount++;  	}  	stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  	stream.Flush ();  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  	string dFirst10 = "";  	string dSecond10 = "";  	string cSIDCOut = "";  	string status = "";  	string symbolName = "";  	string modOneName = "";  	string modTwoName = "";  	totalCount++;  	cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  	cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  	if (fcode.SchemaOverride != "") {  		cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  		cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  	}  	if (fcode.DimensionOverride != "") {  		cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  		cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  	}  	// Build a symbol using a 2525C SIDC  	Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  	if (sym != null) {  		if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  			dFirst10 = sym.SIDC.PartAString;  			dSecond10 = sym.SIDC.PartBString;  			// Build a symbol using the 2525D SIDC' to see if reverse  			// conversion works.  			Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  			if (sym2 != null) {  				cSIDCOut = sym2.LegacySIDC;  				symbolName = sym2.Names ["Entity"];  				modOneName = sym2.Names ["ModifierOne"];  				modTwoName = sym2.Names ["ModifierTwo"];  				if (cSIDCIn == cSIDCOut) {  					status = "pass";  					passCount++;  				} else if (sym2.LegacySIDCs.Count > 1) {  					bool match = false;  					foreach (string sidc in sym2.LegacySIDCs) {  						if (cSIDCIn == sidc) {  							match = true;  							break;  						}  					}  					if (match) {  						status = "pass (multiple)";  						passWithConditionCount++;  					} else {  						status = "FAIL";  						failCount++;  					}  				} else {  					status = "FAIL";  					failCount++;  				}  			} else {  				status = "Error making 2525D";  				derrorCount++;  			}  		} else {  			status = "Retired";  			dFirst10 = SIDC.INVALID.PartAString;  			dSecond10 = SIDC.INVALID.PartBString;  			retiredCount++;  		}  	} else {  		status = "Error making 2525C";  		cerrorCount++;  	}  	stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  	stream.Flush ();  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  	string dFirst10 = "";  	string dSecond10 = "";  	string cSIDCOut = "";  	string status = "";  	string symbolName = "";  	string modOneName = "";  	string modTwoName = "";  	totalCount++;  	cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  	cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  	if (fcode.SchemaOverride != "") {  		cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  		cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  	}  	if (fcode.DimensionOverride != "") {  		cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  		cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  	}  	// Build a symbol using a 2525C SIDC  	Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  	if (sym != null) {  		if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  			dFirst10 = sym.SIDC.PartAString;  			dSecond10 = sym.SIDC.PartBString;  			// Build a symbol using the 2525D SIDC' to see if reverse  			// conversion works.  			Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  			if (sym2 != null) {  				cSIDCOut = sym2.LegacySIDC;  				symbolName = sym2.Names ["Entity"];  				modOneName = sym2.Names ["ModifierOne"];  				modTwoName = sym2.Names ["ModifierTwo"];  				if (cSIDCIn == cSIDCOut) {  					status = "pass";  					passCount++;  				} else if (sym2.LegacySIDCs.Count > 1) {  					bool match = false;  					foreach (string sidc in sym2.LegacySIDCs) {  						if (cSIDCIn == sidc) {  							match = true;  							break;  						}  					}  					if (match) {  						status = "pass (multiple)";  						passWithConditionCount++;  					} else {  						status = "FAIL";  						failCount++;  					}  				} else {  					status = "FAIL";  					failCount++;  				}  			} else {  				status = "Error making 2525D";  				derrorCount++;  			}  		} else {  			status = "Retired";  			dFirst10 = SIDC.INVALID.PartAString;  			dSecond10 = SIDC.INVALID.PartBString;  			retiredCount++;  		}  	} else {  		status = "Error making 2525C";  		cerrorCount++;  	}  	stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  	stream.Flush ();  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  	string dFirst10 = "";  	string dSecond10 = "";  	string cSIDCOut = "";  	string status = "";  	string symbolName = "";  	string modOneName = "";  	string modTwoName = "";  	totalCount++;  	cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  	cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  	if (fcode.SchemaOverride != "") {  		cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  		cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  	}  	if (fcode.DimensionOverride != "") {  		cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  		cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  	}  	// Build a symbol using a 2525C SIDC  	Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  	if (sym != null) {  		if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  			dFirst10 = sym.SIDC.PartAString;  			dSecond10 = sym.SIDC.PartBString;  			// Build a symbol using the 2525D SIDC' to see if reverse  			// conversion works.  			Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  			if (sym2 != null) {  				cSIDCOut = sym2.LegacySIDC;  				symbolName = sym2.Names ["Entity"];  				modOneName = sym2.Names ["ModifierOne"];  				modTwoName = sym2.Names ["ModifierTwo"];  				if (cSIDCIn == cSIDCOut) {  					status = "pass";  					passCount++;  				} else if (sym2.LegacySIDCs.Count > 1) {  					bool match = false;  					foreach (string sidc in sym2.LegacySIDCs) {  						if (cSIDCIn == sidc) {  							match = true;  							break;  						}  					}  					if (match) {  						status = "pass (multiple)";  						passWithConditionCount++;  					} else {  						status = "FAIL";  						failCount++;  					}  				} else {  					status = "FAIL";  					failCount++;  				}  			} else {  				status = "Error making 2525D";  				derrorCount++;  			}  		} else {  			status = "Retired";  			dFirst10 = SIDC.INVALID.PartAString;  			dSecond10 = SIDC.INVALID.PartBString;  			retiredCount++;  		}  	} else {  		status = "Error making 2525C";  		cerrorCount++;  	}  	stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  	stream.Flush ();  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  	string dFirst10 = "";  	string dSecond10 = "";  	string cSIDCOut = "";  	string status = "";  	string symbolName = "";  	string modOneName = "";  	string modTwoName = "";  	totalCount++;  	cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  	cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  	if (fcode.SchemaOverride != "") {  		cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  		cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  	}  	if (fcode.DimensionOverride != "") {  		cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  		cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  	}  	// Build a symbol using a 2525C SIDC  	Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  	if (sym != null) {  		if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  			dFirst10 = sym.SIDC.PartAString;  			dSecond10 = sym.SIDC.PartBString;  			// Build a symbol using the 2525D SIDC' to see if reverse  			// conversion works.  			Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  			if (sym2 != null) {  				cSIDCOut = sym2.LegacySIDC;  				symbolName = sym2.Names ["Entity"];  				modOneName = sym2.Names ["ModifierOne"];  				modTwoName = sym2.Names ["ModifierTwo"];  				if (cSIDCIn == cSIDCOut) {  					status = "pass";  					passCount++;  				} else if (sym2.LegacySIDCs.Count > 1) {  					bool match = false;  					foreach (string sidc in sym2.LegacySIDCs) {  						if (cSIDCIn == sidc) {  							match = true;  							break;  						}  					}  					if (match) {  						status = "pass (multiple)";  						passWithConditionCount++;  					} else {  						status = "FAIL";  						failCount++;  					}  				} else {  					status = "FAIL";  					failCount++;  				}  			} else {  				status = "Error making 2525D";  				derrorCount++;  			}  		} else {  			status = "Retired";  			dFirst10 = SIDC.INVALID.PartAString;  			dSecond10 = SIDC.INVALID.PartBString;  			retiredCount++;  		}  	} else {  		status = "Error making 2525C";  		cerrorCount++;  	}  	stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  	stream.Flush ();  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  	string dFirst10 = "";  	string dSecond10 = "";  	string cSIDCOut = "";  	string status = "";  	string symbolName = "";  	string modOneName = "";  	string modTwoName = "";  	totalCount++;  	cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  	cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  	if (fcode.SchemaOverride != "") {  		cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  		cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  	}  	if (fcode.DimensionOverride != "") {  		cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  		cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  	}  	// Build a symbol using a 2525C SIDC  	Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  	if (sym != null) {  		if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  			dFirst10 = sym.SIDC.PartAString;  			dSecond10 = sym.SIDC.PartBString;  			// Build a symbol using the 2525D SIDC' to see if reverse  			// conversion works.  			Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  			if (sym2 != null) {  				cSIDCOut = sym2.LegacySIDC;  				symbolName = sym2.Names ["Entity"];  				modOneName = sym2.Names ["ModifierOne"];  				modTwoName = sym2.Names ["ModifierTwo"];  				if (cSIDCIn == cSIDCOut) {  					status = "pass";  					passCount++;  				} else if (sym2.LegacySIDCs.Count > 1) {  					bool match = false;  					foreach (string sidc in sym2.LegacySIDCs) {  						if (cSIDCIn == sidc) {  							match = true;  							break;  						}  					}  					if (match) {  						status = "pass (multiple)";  						passWithConditionCount++;  					} else {  						status = "FAIL";  						failCount++;  					}  				} else {  					status = "FAIL";  					failCount++;  				}  			} else {  				status = "Error making 2525D";  				derrorCount++;  			}  		} else {  			status = "Retired";  			dFirst10 = SIDC.INVALID.PartAString;  			dSecond10 = SIDC.INVALID.PartBString;  			retiredCount++;  		}  	} else {  		status = "Error making 2525C";  		cerrorCount++;  	}  	stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  	stream.Flush ();  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  	string dFirst10 = "";  	string dSecond10 = "";  	string cSIDCOut = "";  	string status = "";  	string symbolName = "";  	string modOneName = "";  	string modTwoName = "";  	totalCount++;  	cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  	cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  	if (fcode.SchemaOverride != "") {  		cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  		cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  	}  	if (fcode.DimensionOverride != "") {  		cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  		cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  	}  	// Build a symbol using a 2525C SIDC  	Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  	if (sym != null) {  		if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  			dFirst10 = sym.SIDC.PartAString;  			dSecond10 = sym.SIDC.PartBString;  			// Build a symbol using the 2525D SIDC' to see if reverse  			// conversion works.  			Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  			if (sym2 != null) {  				cSIDCOut = sym2.LegacySIDC;  				symbolName = sym2.Names ["Entity"];  				modOneName = sym2.Names ["ModifierOne"];  				modTwoName = sym2.Names ["ModifierTwo"];  				if (cSIDCIn == cSIDCOut) {  					status = "pass";  					passCount++;  				} else if (sym2.LegacySIDCs.Count > 1) {  					bool match = false;  					foreach (string sidc in sym2.LegacySIDCs) {  						if (cSIDCIn == sidc) {  							match = true;  							break;  						}  					}  					if (match) {  						status = "pass (multiple)";  						passWithConditionCount++;  					} else {  						status = "FAIL";  						failCount++;  					}  				} else {  					status = "FAIL";  					failCount++;  				}  			} else {  				status = "Error making 2525D";  				derrorCount++;  			}  		} else {  			status = "Retired";  			dFirst10 = SIDC.INVALID.PartAString;  			dSecond10 = SIDC.INVALID.PartBString;  			retiredCount++;  		}  	} else {  		status = "Error making 2525C";  		cerrorCount++;  	}  	stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  	stream.Flush ();  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  	string dFirst10 = "";  	string dSecond10 = "";  	string cSIDCOut = "";  	string status = "";  	string symbolName = "";  	string modOneName = "";  	string modTwoName = "";  	totalCount++;  	cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  	cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  	if (fcode.SchemaOverride != "") {  		cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  		cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  	}  	if (fcode.DimensionOverride != "") {  		cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  		cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  	}  	// Build a symbol using a 2525C SIDC  	Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  	if (sym != null) {  		if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  			dFirst10 = sym.SIDC.PartAString;  			dSecond10 = sym.SIDC.PartBString;  			// Build a symbol using the 2525D SIDC' to see if reverse  			// conversion works.  			Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  			if (sym2 != null) {  				cSIDCOut = sym2.LegacySIDC;  				symbolName = sym2.Names ["Entity"];  				modOneName = sym2.Names ["ModifierOne"];  				modTwoName = sym2.Names ["ModifierTwo"];  				if (cSIDCIn == cSIDCOut) {  					status = "pass";  					passCount++;  				} else if (sym2.LegacySIDCs.Count > 1) {  					bool match = false;  					foreach (string sidc in sym2.LegacySIDCs) {  						if (cSIDCIn == sidc) {  							match = true;  							break;  						}  					}  					if (match) {  						status = "pass (multiple)";  						passWithConditionCount++;  					} else {  						status = "FAIL";  						failCount++;  					}  				} else {  					status = "FAIL";  					failCount++;  				}  			} else {  				status = "Error making 2525D";  				derrorCount++;  			}  		} else {  			status = "Retired";  			dFirst10 = SIDC.INVALID.PartAString;  			dSecond10 = SIDC.INVALID.PartBString;  			retiredCount++;  		}  	} else {  		status = "Error making 2525C";  		cerrorCount++;  	}  	stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  	stream.Flush ();  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  	string dFirst10 = "";  	string dSecond10 = "";  	string cSIDCOut = "";  	string status = "";  	string symbolName = "";  	string modOneName = "";  	string modTwoName = "";  	totalCount++;  	cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  	cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  	if (fcode.SchemaOverride != "") {  		cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  		cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  	}  	if (fcode.DimensionOverride != "") {  		cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  		cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  	}  	// Build a symbol using a 2525C SIDC  	Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  	if (sym != null) {  		if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  			dFirst10 = sym.SIDC.PartAString;  			dSecond10 = sym.SIDC.PartBString;  			// Build a symbol using the 2525D SIDC' to see if reverse  			// conversion works.  			Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  			if (sym2 != null) {  				cSIDCOut = sym2.LegacySIDC;  				symbolName = sym2.Names ["Entity"];  				modOneName = sym2.Names ["ModifierOne"];  				modTwoName = sym2.Names ["ModifierTwo"];  				if (cSIDCIn == cSIDCOut) {  					status = "pass";  					passCount++;  				} else if (sym2.LegacySIDCs.Count > 1) {  					bool match = false;  					foreach (string sidc in sym2.LegacySIDCs) {  						if (cSIDCIn == sidc) {  							match = true;  							break;  						}  					}  					if (match) {  						status = "pass (multiple)";  						passWithConditionCount++;  					} else {  						status = "FAIL";  						failCount++;  					}  				} else {  					status = "FAIL";  					failCount++;  				}  			} else {  				status = "Error making 2525D";  				derrorCount++;  			}  		} else {  			status = "Retired";  			dFirst10 = SIDC.INVALID.PartAString;  			dSecond10 = SIDC.INVALID.PartBString;  			retiredCount++;  		}  	} else {  		status = "Error making 2525C";  		cerrorCount++;  	}  	stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  	stream.Flush ();  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  	string dFirst10 = "";  	string dSecond10 = "";  	string cSIDCOut = "";  	string status = "";  	string symbolName = "";  	string modOneName = "";  	string modTwoName = "";  	totalCount++;  	cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  	cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  	if (fcode.SchemaOverride != "") {  		cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  		cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  	}  	if (fcode.DimensionOverride != "") {  		cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  		cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  	}  	// Build a symbol using a 2525C SIDC  	Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  	if (sym != null) {  		if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  			dFirst10 = sym.SIDC.PartAString;  			dSecond10 = sym.SIDC.PartBString;  			// Build a symbol using the 2525D SIDC' to see if reverse  			// conversion works.  			Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  			if (sym2 != null) {  				cSIDCOut = sym2.LegacySIDC;  				symbolName = sym2.Names ["Entity"];  				modOneName = sym2.Names ["ModifierOne"];  				modTwoName = sym2.Names ["ModifierTwo"];  				if (cSIDCIn == cSIDCOut) {  					status = "pass";  					passCount++;  				} else if (sym2.LegacySIDCs.Count > 1) {  					bool match = false;  					foreach (string sidc in sym2.LegacySIDCs) {  						if (cSIDCIn == sidc) {  							match = true;  							break;  						}  					}  					if (match) {  						status = "pass (multiple)";  						passWithConditionCount++;  					} else {  						status = "FAIL";  						failCount++;  					}  				} else {  					status = "FAIL";  					failCount++;  				}  			} else {  				status = "Error making 2525D";  				derrorCount++;  			}  		} else {  			status = "Retired";  			dFirst10 = SIDC.INVALID.PartAString;  			dSecond10 = SIDC.INVALID.PartBString;  			retiredCount++;  		}  	} else {  		status = "Error making 2525C";  		cerrorCount++;  	}  	stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  	stream.Flush ();  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  	string dFirst10 = "";  	string dSecond10 = "";  	string cSIDCOut = "";  	string status = "";  	string symbolName = "";  	string modOneName = "";  	string modTwoName = "";  	totalCount++;  	cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  	cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  	if (fcode.SchemaOverride != "") {  		cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  		cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  	}  	if (fcode.DimensionOverride != "") {  		cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  		cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  	}  	// Build a symbol using a 2525C SIDC  	Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  	if (sym != null) {  		if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  			dFirst10 = sym.SIDC.PartAString;  			dSecond10 = sym.SIDC.PartBString;  			// Build a symbol using the 2525D SIDC' to see if reverse  			// conversion works.  			Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  			if (sym2 != null) {  				cSIDCOut = sym2.LegacySIDC;  				symbolName = sym2.Names ["Entity"];  				modOneName = sym2.Names ["ModifierOne"];  				modTwoName = sym2.Names ["ModifierTwo"];  				if (cSIDCIn == cSIDCOut) {  					status = "pass";  					passCount++;  				} else if (sym2.LegacySIDCs.Count > 1) {  					bool match = false;  					foreach (string sidc in sym2.LegacySIDCs) {  						if (cSIDCIn == sidc) {  							match = true;  							break;  						}  					}  					if (match) {  						status = "pass (multiple)";  						passWithConditionCount++;  					} else {  						status = "FAIL";  						failCount++;  					}  				} else {  					status = "FAIL";  					failCount++;  				}  			} else {  				status = "Error making 2525D";  				derrorCount++;  			}  		} else {  			status = "Retired";  			dFirst10 = SIDC.INVALID.PartAString;  			dSecond10 = SIDC.INVALID.PartBString;  			retiredCount++;  		}  	} else {  		status = "Error making 2525C";  		cerrorCount++;  	}  	stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  	stream.Flush ();  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  	string dFirst10 = "";  	string dSecond10 = "";  	string cSIDCOut = "";  	string status = "";  	string symbolName = "";  	string modOneName = "";  	string modTwoName = "";  	totalCount++;  	cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  	cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  	if (fcode.SchemaOverride != "") {  		cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  		cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  	}  	if (fcode.DimensionOverride != "") {  		cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  		cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  	}  	// Build a symbol using a 2525C SIDC  	Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  	if (sym != null) {  		if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  			dFirst10 = sym.SIDC.PartAString;  			dSecond10 = sym.SIDC.PartBString;  			// Build a symbol using the 2525D SIDC' to see if reverse  			// conversion works.  			Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  			if (sym2 != null) {  				cSIDCOut = sym2.LegacySIDC;  				symbolName = sym2.Names ["Entity"];  				modOneName = sym2.Names ["ModifierOne"];  				modTwoName = sym2.Names ["ModifierTwo"];  				if (cSIDCIn == cSIDCOut) {  					status = "pass";  					passCount++;  				} else if (sym2.LegacySIDCs.Count > 1) {  					bool match = false;  					foreach (string sidc in sym2.LegacySIDCs) {  						if (cSIDCIn == sidc) {  							match = true;  							break;  						}  					}  					if (match) {  						status = "pass (multiple)";  						passWithConditionCount++;  					} else {  						status = "FAIL";  						failCount++;  					}  				} else {  					status = "FAIL";  					failCount++;  				}  			} else {  				status = "Error making 2525D";  				derrorCount++;  			}  		} else {  			status = "Retired";  			dFirst10 = SIDC.INVALID.PartAString;  			dSecond10 = SIDC.INVALID.PartBString;  			retiredCount++;  		}  	} else {  		status = "Error making 2525C";  		cerrorCount++;  	}  	stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  	stream.Flush ();  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  	string dFirst10 = "";  	string dSecond10 = "";  	string cSIDCOut = "";  	string status = "";  	string symbolName = "";  	string modOneName = "";  	string modTwoName = "";  	totalCount++;  	cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  	cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  	if (fcode.SchemaOverride != "") {  		cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  		cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  	}  	if (fcode.DimensionOverride != "") {  		cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  		cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  	}  	// Build a symbol using a 2525C SIDC  	Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  	if (sym != null) {  		if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  			dFirst10 = sym.SIDC.PartAString;  			dSecond10 = sym.SIDC.PartBString;  			// Build a symbol using the 2525D SIDC' to see if reverse  			// conversion works.  			Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  			if (sym2 != null) {  				cSIDCOut = sym2.LegacySIDC;  				symbolName = sym2.Names ["Entity"];  				modOneName = sym2.Names ["ModifierOne"];  				modTwoName = sym2.Names ["ModifierTwo"];  				if (cSIDCIn == cSIDCOut) {  					status = "pass";  					passCount++;  				} else if (sym2.LegacySIDCs.Count > 1) {  					bool match = false;  					foreach (string sidc in sym2.LegacySIDCs) {  						if (cSIDCIn == sidc) {  							match = true;  							break;  						}  					}  					if (match) {  						status = "pass (multiple)";  						passWithConditionCount++;  					} else {  						status = "FAIL";  						failCount++;  					}  				} else {  					status = "FAIL";  					failCount++;  				}  			} else {  				status = "Error making 2525D";  				derrorCount++;  			}  		} else {  			status = "Retired";  			dFirst10 = SIDC.INVALID.PartAString;  			dSecond10 = SIDC.INVALID.PartBString;  			retiredCount++;  		}  	} else {  		status = "Error making 2525C";  		cerrorCount++;  	}  	stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  	stream.Flush ();  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: foreach (LegacyFunctionCodeType fcode in legacy.LegacyFunctionCode) {  	string dFirst10 = "";  	string dSecond10 = "";  	string cSIDCOut = "";  	string status = "";  	string symbolName = "";  	string modOneName = "";  	string modTwoName = "";  	totalCount++;  	cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  	cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  	if (fcode.SchemaOverride != "") {  		cSIDC = fcode.SchemaOverride + cSIDC.Substring (1);  		cSIDCIn = fcode.SchemaOverride + cSIDCIn.Substring (1);  	}  	if (fcode.DimensionOverride != "") {  		cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  		cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  	}  	// Build a symbol using a 2525C SIDC  	Symbol sym = _librarian.MakeSymbol ("2525C"' cSIDCIn);  	if (sym != null) {  		if (sym.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  			dFirst10 = sym.SIDC.PartAString;  			dSecond10 = sym.SIDC.PartBString;  			// Build a symbol using the 2525D SIDC' to see if reverse  			// conversion works.  			Symbol sym2 = _librarian.MakeSymbol (sym.SIDC);  			if (sym2 != null) {  				cSIDCOut = sym2.LegacySIDC;  				symbolName = sym2.Names ["Entity"];  				modOneName = sym2.Names ["ModifierOne"];  				modTwoName = sym2.Names ["ModifierTwo"];  				if (cSIDCIn == cSIDCOut) {  					status = "pass";  					passCount++;  				} else if (sym2.LegacySIDCs.Count > 1) {  					bool match = false;  					foreach (string sidc in sym2.LegacySIDCs) {  						if (cSIDCIn == sidc) {  							match = true;  							break;  						}  					}  					if (match) {  						status = "pass (multiple)";  						passWithConditionCount++;  					} else {  						status = "FAIL";  						failCount++;  					}  				} else {  					status = "FAIL";  					failCount++;  				}  			} else {  				status = "Error making 2525D";  				derrorCount++;  			}  		} else {  			status = "Retired";  			dFirst10 = SIDC.INVALID.PartAString;  			dSecond10 = SIDC.INVALID.PartBString;  			retiredCount++;  		}  	} else {  		status = "Error making 2525C";  		cerrorCount++;  	}  	stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  	stream.Flush ();  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: cSIDC = cSIDC.Substring (0' 4) + fcode.Value + cSIDC.Substring (10);  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: cSIDCIn = cSIDCIn.Substring (0' 4) + fcode.Value + cSIDCIn.Substring (10);  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: if (fcode.DimensionOverride != "") {  	cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  	cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: if (fcode.DimensionOverride != "") {  	cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  	cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: if (fcode.DimensionOverride != "") {  	cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  	cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: if (fcode.DimensionOverride != "") {  	cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  	cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  }  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: cSIDC = cSIDC.Substring (0' 2) + fcode.DimensionOverride + cSIDC.Substring (3);  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: cSIDCIn = cSIDCIn.Substring (0' 2) + fcode.DimensionOverride + cSIDCIn.Substring (3);  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  
Magic Number,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_exportLegacyData,The following statement contains a magic number: stream.WriteLine (cSIDC.Substring (0' 10) + "'" + cSIDCIn + "'" + dFirst10.Substring (4' 2) + "'" + dSecond10.Substring (0' 6) + "'" + dSecond10.Substring (6' 2) + "'" + dSecond10.Substring (8' 2) + "'" + symbolName + "'" + modOneName + "'" + modTwoName + "'" + cSIDCOut + "'" + status);  
Magic Number,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildEntityItemTags,The following statement contains a magic number: if (result.Length > 255) {  	// Can't have a tag string greater than 255 in length.  	// Human interaction will be required to resolve these on a case by case basis.  	_notes = _notes + "styleItemTags > 255;";  }  
Magic Number,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildEntityItemTags,The following statement contains a magic number: if (result.Length > 255) {  	// Can't have a tag string greater than 255 in length.  	// Human interaction will be required to resolve these on a case by case basis.  	_notes = _notes + "styleItemTags > 255;";  }  
Magic Number,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,The following statement contains a magic number: if (ss != null && e != null) {  	uint partA = 1000000000 + (ss.SymbolSetCode.DigitOne * (uint)100000) + (ss.SymbolSetCode.DigitTwo * (uint)10000);  	if (sig != null) {  		partA = partA + (sig.StandardIdentityGroupCode * (uint)1000000);  	}  	uint partB = (e.EntityCode.DigitOne * (uint)1000000000) + (e.EntityCode.DigitTwo * (uint)100000000);  	if (eType != null) {  		partB = partB + (eType.EntityTypeCode.DigitOne * (uint)10000000) + (eType.EntityTypeCode.DigitTwo * (uint)1000000);  	}  	if (eSubType != null) {  		partB = partB + (eSubType.EntitySubTypeCode.DigitOne * (uint)100000) + (eSubType.EntitySubTypeCode.DigitTwo * (uint)10000);  	}  	Symbol symbol = _configHelper.Librarian.MakeSymbol (new SIDC (partA' partB));  	//  	// If the symbol has a 2525C equivalent' return it  	//  	if (symbol != null) {  		if (symbol.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  			result = symbol.LegacySIDC;  			if (sig == null && result.Substring (1' 1) == "P") {  				result = result.Substring (0' 1) + "*" + result.Substring (2);  			}  			if (result.Substring (14' 1) == "X")  				result = result.Substring (0' 10) + "****X";  			else if (result.Substring (0' 1) == "W")  				result = result.Substring (0' 13) + "**";  			else if (result.Substring (10' 5) == "-----")  				result = result.Substring (0' 10) + "*****";  			else if (result.Substring (11' 4) == "----")  				result = result.Substring (0' 11) + "****";  		}  	} else {  		logger.Warn ("Symbol could not be built from: " + partA + ":" + partB);  	}  }  
Magic Number,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,The following statement contains a magic number: if (ss != null && e != null) {  	uint partA = 1000000000 + (ss.SymbolSetCode.DigitOne * (uint)100000) + (ss.SymbolSetCode.DigitTwo * (uint)10000);  	if (sig != null) {  		partA = partA + (sig.StandardIdentityGroupCode * (uint)1000000);  	}  	uint partB = (e.EntityCode.DigitOne * (uint)1000000000) + (e.EntityCode.DigitTwo * (uint)100000000);  	if (eType != null) {  		partB = partB + (eType.EntityTypeCode.DigitOne * (uint)10000000) + (eType.EntityTypeCode.DigitTwo * (uint)1000000);  	}  	if (eSubType != null) {  		partB = partB + (eSubType.EntitySubTypeCode.DigitOne * (uint)100000) + (eSubType.EntitySubTypeCode.DigitTwo * (uint)10000);  	}  	Symbol symbol = _configHelper.Librarian.MakeSymbol (new SIDC (partA' partB));  	//  	// If the symbol has a 2525C equivalent' return it  	//  	if (symbol != null) {  		if (symbol.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  			result = symbol.LegacySIDC;  			if (sig == null && result.Substring (1' 1) == "P") {  				result = result.Substring (0' 1) + "*" + result.Substring (2);  			}  			if (result.Substring (14' 1) == "X")  				result = result.Substring (0' 10) + "****X";  			else if (result.Substring (0' 1) == "W")  				result = result.Substring (0' 13) + "**";  			else if (result.Substring (10' 5) == "-----")  				result = result.Substring (0' 10) + "*****";  			else if (result.Substring (11' 4) == "----")  				result = result.Substring (0' 11) + "****";  		}  	} else {  		logger.Warn ("Symbol could not be built from: " + partA + ":" + partB);  	}  }  
Magic Number,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,The following statement contains a magic number: if (ss != null && e != null) {  	uint partA = 1000000000 + (ss.SymbolSetCode.DigitOne * (uint)100000) + (ss.SymbolSetCode.DigitTwo * (uint)10000);  	if (sig != null) {  		partA = partA + (sig.StandardIdentityGroupCode * (uint)1000000);  	}  	uint partB = (e.EntityCode.DigitOne * (uint)1000000000) + (e.EntityCode.DigitTwo * (uint)100000000);  	if (eType != null) {  		partB = partB + (eType.EntityTypeCode.DigitOne * (uint)10000000) + (eType.EntityTypeCode.DigitTwo * (uint)1000000);  	}  	if (eSubType != null) {  		partB = partB + (eSubType.EntitySubTypeCode.DigitOne * (uint)100000) + (eSubType.EntitySubTypeCode.DigitTwo * (uint)10000);  	}  	Symbol symbol = _configHelper.Librarian.MakeSymbol (new SIDC (partA' partB));  	//  	// If the symbol has a 2525C equivalent' return it  	//  	if (symbol != null) {  		if (symbol.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  			result = symbol.LegacySIDC;  			if (sig == null && result.Substring (1' 1) == "P") {  				result = result.Substring (0' 1) + "*" + result.Substring (2);  			}  			if (result.Substring (14' 1) == "X")  				result = result.Substring (0' 10) + "****X";  			else if (result.Substring (0' 1) == "W")  				result = result.Substring (0' 13) + "**";  			else if (result.Substring (10' 5) == "-----")  				result = result.Substring (0' 10) + "*****";  			else if (result.Substring (11' 4) == "----")  				result = result.Substring (0' 11) + "****";  		}  	} else {  		logger.Warn ("Symbol could not be built from: " + partA + ":" + partB);  	}  }  
Magic Number,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,The following statement contains a magic number: if (ss != null && e != null) {  	uint partA = 1000000000 + (ss.SymbolSetCode.DigitOne * (uint)100000) + (ss.SymbolSetCode.DigitTwo * (uint)10000);  	if (sig != null) {  		partA = partA + (sig.StandardIdentityGroupCode * (uint)1000000);  	}  	uint partB = (e.EntityCode.DigitOne * (uint)1000000000) + (e.EntityCode.DigitTwo * (uint)100000000);  	if (eType != null) {  		partB = partB + (eType.EntityTypeCode.DigitOne * (uint)10000000) + (eType.EntityTypeCode.DigitTwo * (uint)1000000);  	}  	if (eSubType != null) {  		partB = partB + (eSubType.EntitySubTypeCode.DigitOne * (uint)100000) + (eSubType.EntitySubTypeCode.DigitTwo * (uint)10000);  	}  	Symbol symbol = _configHelper.Librarian.MakeSymbol (new SIDC (partA' partB));  	//  	// If the symbol has a 2525C equivalent' return it  	//  	if (symbol != null) {  		if (symbol.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  			result = symbol.LegacySIDC;  			if (sig == null && result.Substring (1' 1) == "P") {  				result = result.Substring (0' 1) + "*" + result.Substring (2);  			}  			if (result.Substring (14' 1) == "X")  				result = result.Substring (0' 10) + "****X";  			else if (result.Substring (0' 1) == "W")  				result = result.Substring (0' 13) + "**";  			else if (result.Substring (10' 5) == "-----")  				result = result.Substring (0' 10) + "*****";  			else if (result.Substring (11' 4) == "----")  				result = result.Substring (0' 11) + "****";  		}  	} else {  		logger.Warn ("Symbol could not be built from: " + partA + ":" + partB);  	}  }  
Magic Number,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,The following statement contains a magic number: if (ss != null && e != null) {  	uint partA = 1000000000 + (ss.SymbolSetCode.DigitOne * (uint)100000) + (ss.SymbolSetCode.DigitTwo * (uint)10000);  	if (sig != null) {  		partA = partA + (sig.StandardIdentityGroupCode * (uint)1000000);  	}  	uint partB = (e.EntityCode.DigitOne * (uint)1000000000) + (e.EntityCode.DigitTwo * (uint)100000000);  	if (eType != null) {  		partB = partB + (eType.EntityTypeCode.DigitOne * (uint)10000000) + (eType.EntityTypeCode.DigitTwo * (uint)1000000);  	}  	if (eSubType != null) {  		partB = partB + (eSubType.EntitySubTypeCode.DigitOne * (uint)100000) + (eSubType.EntitySubTypeCode.DigitTwo * (uint)10000);  	}  	Symbol symbol = _configHelper.Librarian.MakeSymbol (new SIDC (partA' partB));  	//  	// If the symbol has a 2525C equivalent' return it  	//  	if (symbol != null) {  		if (symbol.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  			result = symbol.LegacySIDC;  			if (sig == null && result.Substring (1' 1) == "P") {  				result = result.Substring (0' 1) + "*" + result.Substring (2);  			}  			if (result.Substring (14' 1) == "X")  				result = result.Substring (0' 10) + "****X";  			else if (result.Substring (0' 1) == "W")  				result = result.Substring (0' 13) + "**";  			else if (result.Substring (10' 5) == "-----")  				result = result.Substring (0' 10) + "*****";  			else if (result.Substring (11' 4) == "----")  				result = result.Substring (0' 11) + "****";  		}  	} else {  		logger.Warn ("Symbol could not be built from: " + partA + ":" + partB);  	}  }  
Magic Number,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,The following statement contains a magic number: if (ss != null && e != null) {  	uint partA = 1000000000 + (ss.SymbolSetCode.DigitOne * (uint)100000) + (ss.SymbolSetCode.DigitTwo * (uint)10000);  	if (sig != null) {  		partA = partA + (sig.StandardIdentityGroupCode * (uint)1000000);  	}  	uint partB = (e.EntityCode.DigitOne * (uint)1000000000) + (e.EntityCode.DigitTwo * (uint)100000000);  	if (eType != null) {  		partB = partB + (eType.EntityTypeCode.DigitOne * (uint)10000000) + (eType.EntityTypeCode.DigitTwo * (uint)1000000);  	}  	if (eSubType != null) {  		partB = partB + (eSubType.EntitySubTypeCode.DigitOne * (uint)100000) + (eSubType.EntitySubTypeCode.DigitTwo * (uint)10000);  	}  	Symbol symbol = _configHelper.Librarian.MakeSymbol (new SIDC (partA' partB));  	//  	// If the symbol has a 2525C equivalent' return it  	//  	if (symbol != null) {  		if (symbol.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  			result = symbol.LegacySIDC;  			if (sig == null && result.Substring (1' 1) == "P") {  				result = result.Substring (0' 1) + "*" + result.Substring (2);  			}  			if (result.Substring (14' 1) == "X")  				result = result.Substring (0' 10) + "****X";  			else if (result.Substring (0' 1) == "W")  				result = result.Substring (0' 13) + "**";  			else if (result.Substring (10' 5) == "-----")  				result = result.Substring (0' 10) + "*****";  			else if (result.Substring (11' 4) == "----")  				result = result.Substring (0' 11) + "****";  		}  	} else {  		logger.Warn ("Symbol could not be built from: " + partA + ":" + partB);  	}  }  
Magic Number,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,The following statement contains a magic number: if (ss != null && e != null) {  	uint partA = 1000000000 + (ss.SymbolSetCode.DigitOne * (uint)100000) + (ss.SymbolSetCode.DigitTwo * (uint)10000);  	if (sig != null) {  		partA = partA + (sig.StandardIdentityGroupCode * (uint)1000000);  	}  	uint partB = (e.EntityCode.DigitOne * (uint)1000000000) + (e.EntityCode.DigitTwo * (uint)100000000);  	if (eType != null) {  		partB = partB + (eType.EntityTypeCode.DigitOne * (uint)10000000) + (eType.EntityTypeCode.DigitTwo * (uint)1000000);  	}  	if (eSubType != null) {  		partB = partB + (eSubType.EntitySubTypeCode.DigitOne * (uint)100000) + (eSubType.EntitySubTypeCode.DigitTwo * (uint)10000);  	}  	Symbol symbol = _configHelper.Librarian.MakeSymbol (new SIDC (partA' partB));  	//  	// If the symbol has a 2525C equivalent' return it  	//  	if (symbol != null) {  		if (symbol.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  			result = symbol.LegacySIDC;  			if (sig == null && result.Substring (1' 1) == "P") {  				result = result.Substring (0' 1) + "*" + result.Substring (2);  			}  			if (result.Substring (14' 1) == "X")  				result = result.Substring (0' 10) + "****X";  			else if (result.Substring (0' 1) == "W")  				result = result.Substring (0' 13) + "**";  			else if (result.Substring (10' 5) == "-----")  				result = result.Substring (0' 10) + "*****";  			else if (result.Substring (11' 4) == "----")  				result = result.Substring (0' 11) + "****";  		}  	} else {  		logger.Warn ("Symbol could not be built from: " + partA + ":" + partB);  	}  }  
Magic Number,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,The following statement contains a magic number: if (ss != null && e != null) {  	uint partA = 1000000000 + (ss.SymbolSetCode.DigitOne * (uint)100000) + (ss.SymbolSetCode.DigitTwo * (uint)10000);  	if (sig != null) {  		partA = partA + (sig.StandardIdentityGroupCode * (uint)1000000);  	}  	uint partB = (e.EntityCode.DigitOne * (uint)1000000000) + (e.EntityCode.DigitTwo * (uint)100000000);  	if (eType != null) {  		partB = partB + (eType.EntityTypeCode.DigitOne * (uint)10000000) + (eType.EntityTypeCode.DigitTwo * (uint)1000000);  	}  	if (eSubType != null) {  		partB = partB + (eSubType.EntitySubTypeCode.DigitOne * (uint)100000) + (eSubType.EntitySubTypeCode.DigitTwo * (uint)10000);  	}  	Symbol symbol = _configHelper.Librarian.MakeSymbol (new SIDC (partA' partB));  	//  	// If the symbol has a 2525C equivalent' return it  	//  	if (symbol != null) {  		if (symbol.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  			result = symbol.LegacySIDC;  			if (sig == null && result.Substring (1' 1) == "P") {  				result = result.Substring (0' 1) + "*" + result.Substring (2);  			}  			if (result.Substring (14' 1) == "X")  				result = result.Substring (0' 10) + "****X";  			else if (result.Substring (0' 1) == "W")  				result = result.Substring (0' 13) + "**";  			else if (result.Substring (10' 5) == "-----")  				result = result.Substring (0' 10) + "*****";  			else if (result.Substring (11' 4) == "----")  				result = result.Substring (0' 11) + "****";  		}  	} else {  		logger.Warn ("Symbol could not be built from: " + partA + ":" + partB);  	}  }  
Magic Number,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,The following statement contains a magic number: if (ss != null && e != null) {  	uint partA = 1000000000 + (ss.SymbolSetCode.DigitOne * (uint)100000) + (ss.SymbolSetCode.DigitTwo * (uint)10000);  	if (sig != null) {  		partA = partA + (sig.StandardIdentityGroupCode * (uint)1000000);  	}  	uint partB = (e.EntityCode.DigitOne * (uint)1000000000) + (e.EntityCode.DigitTwo * (uint)100000000);  	if (eType != null) {  		partB = partB + (eType.EntityTypeCode.DigitOne * (uint)10000000) + (eType.EntityTypeCode.DigitTwo * (uint)1000000);  	}  	if (eSubType != null) {  		partB = partB + (eSubType.EntitySubTypeCode.DigitOne * (uint)100000) + (eSubType.EntitySubTypeCode.DigitTwo * (uint)10000);  	}  	Symbol symbol = _configHelper.Librarian.MakeSymbol (new SIDC (partA' partB));  	//  	// If the symbol has a 2525C equivalent' return it  	//  	if (symbol != null) {  		if (symbol.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  			result = symbol.LegacySIDC;  			if (sig == null && result.Substring (1' 1) == "P") {  				result = result.Substring (0' 1) + "*" + result.Substring (2);  			}  			if (result.Substring (14' 1) == "X")  				result = result.Substring (0' 10) + "****X";  			else if (result.Substring (0' 1) == "W")  				result = result.Substring (0' 13) + "**";  			else if (result.Substring (10' 5) == "-----")  				result = result.Substring (0' 10) + "*****";  			else if (result.Substring (11' 4) == "----")  				result = result.Substring (0' 11) + "****";  		}  	} else {  		logger.Warn ("Symbol could not be built from: " + partA + ":" + partB);  	}  }  
Magic Number,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,The following statement contains a magic number: if (ss != null && e != null) {  	uint partA = 1000000000 + (ss.SymbolSetCode.DigitOne * (uint)100000) + (ss.SymbolSetCode.DigitTwo * (uint)10000);  	if (sig != null) {  		partA = partA + (sig.StandardIdentityGroupCode * (uint)1000000);  	}  	uint partB = (e.EntityCode.DigitOne * (uint)1000000000) + (e.EntityCode.DigitTwo * (uint)100000000);  	if (eType != null) {  		partB = partB + (eType.EntityTypeCode.DigitOne * (uint)10000000) + (eType.EntityTypeCode.DigitTwo * (uint)1000000);  	}  	if (eSubType != null) {  		partB = partB + (eSubType.EntitySubTypeCode.DigitOne * (uint)100000) + (eSubType.EntitySubTypeCode.DigitTwo * (uint)10000);  	}  	Symbol symbol = _configHelper.Librarian.MakeSymbol (new SIDC (partA' partB));  	//  	// If the symbol has a 2525C equivalent' return it  	//  	if (symbol != null) {  		if (symbol.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  			result = symbol.LegacySIDC;  			if (sig == null && result.Substring (1' 1) == "P") {  				result = result.Substring (0' 1) + "*" + result.Substring (2);  			}  			if (result.Substring (14' 1) == "X")  				result = result.Substring (0' 10) + "****X";  			else if (result.Substring (0' 1) == "W")  				result = result.Substring (0' 13) + "**";  			else if (result.Substring (10' 5) == "-----")  				result = result.Substring (0' 10) + "*****";  			else if (result.Substring (11' 4) == "----")  				result = result.Substring (0' 11) + "****";  		}  	} else {  		logger.Warn ("Symbol could not be built from: " + partA + ":" + partB);  	}  }  
Magic Number,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,The following statement contains a magic number: if (ss != null && e != null) {  	uint partA = 1000000000 + (ss.SymbolSetCode.DigitOne * (uint)100000) + (ss.SymbolSetCode.DigitTwo * (uint)10000);  	if (sig != null) {  		partA = partA + (sig.StandardIdentityGroupCode * (uint)1000000);  	}  	uint partB = (e.EntityCode.DigitOne * (uint)1000000000) + (e.EntityCode.DigitTwo * (uint)100000000);  	if (eType != null) {  		partB = partB + (eType.EntityTypeCode.DigitOne * (uint)10000000) + (eType.EntityTypeCode.DigitTwo * (uint)1000000);  	}  	if (eSubType != null) {  		partB = partB + (eSubType.EntitySubTypeCode.DigitOne * (uint)100000) + (eSubType.EntitySubTypeCode.DigitTwo * (uint)10000);  	}  	Symbol symbol = _configHelper.Librarian.MakeSymbol (new SIDC (partA' partB));  	//  	// If the symbol has a 2525C equivalent' return it  	//  	if (symbol != null) {  		if (symbol.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  			result = symbol.LegacySIDC;  			if (sig == null && result.Substring (1' 1) == "P") {  				result = result.Substring (0' 1) + "*" + result.Substring (2);  			}  			if (result.Substring (14' 1) == "X")  				result = result.Substring (0' 10) + "****X";  			else if (result.Substring (0' 1) == "W")  				result = result.Substring (0' 13) + "**";  			else if (result.Substring (10' 5) == "-----")  				result = result.Substring (0' 10) + "*****";  			else if (result.Substring (11' 4) == "----")  				result = result.Substring (0' 11) + "****";  		}  	} else {  		logger.Warn ("Symbol could not be built from: " + partA + ":" + partB);  	}  }  
Magic Number,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,The following statement contains a magic number: if (ss != null && e != null) {  	uint partA = 1000000000 + (ss.SymbolSetCode.DigitOne * (uint)100000) + (ss.SymbolSetCode.DigitTwo * (uint)10000);  	if (sig != null) {  		partA = partA + (sig.StandardIdentityGroupCode * (uint)1000000);  	}  	uint partB = (e.EntityCode.DigitOne * (uint)1000000000) + (e.EntityCode.DigitTwo * (uint)100000000);  	if (eType != null) {  		partB = partB + (eType.EntityTypeCode.DigitOne * (uint)10000000) + (eType.EntityTypeCode.DigitTwo * (uint)1000000);  	}  	if (eSubType != null) {  		partB = partB + (eSubType.EntitySubTypeCode.DigitOne * (uint)100000) + (eSubType.EntitySubTypeCode.DigitTwo * (uint)10000);  	}  	Symbol symbol = _configHelper.Librarian.MakeSymbol (new SIDC (partA' partB));  	//  	// If the symbol has a 2525C equivalent' return it  	//  	if (symbol != null) {  		if (symbol.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  			result = symbol.LegacySIDC;  			if (sig == null && result.Substring (1' 1) == "P") {  				result = result.Substring (0' 1) + "*" + result.Substring (2);  			}  			if (result.Substring (14' 1) == "X")  				result = result.Substring (0' 10) + "****X";  			else if (result.Substring (0' 1) == "W")  				result = result.Substring (0' 13) + "**";  			else if (result.Substring (10' 5) == "-----")  				result = result.Substring (0' 10) + "*****";  			else if (result.Substring (11' 4) == "----")  				result = result.Substring (0' 11) + "****";  		}  	} else {  		logger.Warn ("Symbol could not be built from: " + partA + ":" + partB);  	}  }  
Magic Number,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,The following statement contains a magic number: if (ss != null && e != null) {  	uint partA = 1000000000 + (ss.SymbolSetCode.DigitOne * (uint)100000) + (ss.SymbolSetCode.DigitTwo * (uint)10000);  	if (sig != null) {  		partA = partA + (sig.StandardIdentityGroupCode * (uint)1000000);  	}  	uint partB = (e.EntityCode.DigitOne * (uint)1000000000) + (e.EntityCode.DigitTwo * (uint)100000000);  	if (eType != null) {  		partB = partB + (eType.EntityTypeCode.DigitOne * (uint)10000000) + (eType.EntityTypeCode.DigitTwo * (uint)1000000);  	}  	if (eSubType != null) {  		partB = partB + (eSubType.EntitySubTypeCode.DigitOne * (uint)100000) + (eSubType.EntitySubTypeCode.DigitTwo * (uint)10000);  	}  	Symbol symbol = _configHelper.Librarian.MakeSymbol (new SIDC (partA' partB));  	//  	// If the symbol has a 2525C equivalent' return it  	//  	if (symbol != null) {  		if (symbol.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  			result = symbol.LegacySIDC;  			if (sig == null && result.Substring (1' 1) == "P") {  				result = result.Substring (0' 1) + "*" + result.Substring (2);  			}  			if (result.Substring (14' 1) == "X")  				result = result.Substring (0' 10) + "****X";  			else if (result.Substring (0' 1) == "W")  				result = result.Substring (0' 13) + "**";  			else if (result.Substring (10' 5) == "-----")  				result = result.Substring (0' 10) + "*****";  			else if (result.Substring (11' 4) == "----")  				result = result.Substring (0' 11) + "****";  		}  	} else {  		logger.Warn ("Symbol could not be built from: " + partA + ":" + partB);  	}  }  
Magic Number,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,The following statement contains a magic number: if (ss != null && e != null) {  	uint partA = 1000000000 + (ss.SymbolSetCode.DigitOne * (uint)100000) + (ss.SymbolSetCode.DigitTwo * (uint)10000);  	if (sig != null) {  		partA = partA + (sig.StandardIdentityGroupCode * (uint)1000000);  	}  	uint partB = (e.EntityCode.DigitOne * (uint)1000000000) + (e.EntityCode.DigitTwo * (uint)100000000);  	if (eType != null) {  		partB = partB + (eType.EntityTypeCode.DigitOne * (uint)10000000) + (eType.EntityTypeCode.DigitTwo * (uint)1000000);  	}  	if (eSubType != null) {  		partB = partB + (eSubType.EntitySubTypeCode.DigitOne * (uint)100000) + (eSubType.EntitySubTypeCode.DigitTwo * (uint)10000);  	}  	Symbol symbol = _configHelper.Librarian.MakeSymbol (new SIDC (partA' partB));  	//  	// If the symbol has a 2525C equivalent' return it  	//  	if (symbol != null) {  		if (symbol.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  			result = symbol.LegacySIDC;  			if (sig == null && result.Substring (1' 1) == "P") {  				result = result.Substring (0' 1) + "*" + result.Substring (2);  			}  			if (result.Substring (14' 1) == "X")  				result = result.Substring (0' 10) + "****X";  			else if (result.Substring (0' 1) == "W")  				result = result.Substring (0' 13) + "**";  			else if (result.Substring (10' 5) == "-----")  				result = result.Substring (0' 10) + "*****";  			else if (result.Substring (11' 4) == "----")  				result = result.Substring (0' 11) + "****";  		}  	} else {  		logger.Warn ("Symbol could not be built from: " + partA + ":" + partB);  	}  }  
Magic Number,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,The following statement contains a magic number: if (ss != null && e != null) {  	uint partA = 1000000000 + (ss.SymbolSetCode.DigitOne * (uint)100000) + (ss.SymbolSetCode.DigitTwo * (uint)10000);  	if (sig != null) {  		partA = partA + (sig.StandardIdentityGroupCode * (uint)1000000);  	}  	uint partB = (e.EntityCode.DigitOne * (uint)1000000000) + (e.EntityCode.DigitTwo * (uint)100000000);  	if (eType != null) {  		partB = partB + (eType.EntityTypeCode.DigitOne * (uint)10000000) + (eType.EntityTypeCode.DigitTwo * (uint)1000000);  	}  	if (eSubType != null) {  		partB = partB + (eSubType.EntitySubTypeCode.DigitOne * (uint)100000) + (eSubType.EntitySubTypeCode.DigitTwo * (uint)10000);  	}  	Symbol symbol = _configHelper.Librarian.MakeSymbol (new SIDC (partA' partB));  	//  	// If the symbol has a 2525C equivalent' return it  	//  	if (symbol != null) {  		if (symbol.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  			result = symbol.LegacySIDC;  			if (sig == null && result.Substring (1' 1) == "P") {  				result = result.Substring (0' 1) + "*" + result.Substring (2);  			}  			if (result.Substring (14' 1) == "X")  				result = result.Substring (0' 10) + "****X";  			else if (result.Substring (0' 1) == "W")  				result = result.Substring (0' 13) + "**";  			else if (result.Substring (10' 5) == "-----")  				result = result.Substring (0' 10) + "*****";  			else if (result.Substring (11' 4) == "----")  				result = result.Substring (0' 11) + "****";  		}  	} else {  		logger.Warn ("Symbol could not be built from: " + partA + ":" + partB);  	}  }  
Magic Number,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,The following statement contains a magic number: if (ss != null && e != null) {  	uint partA = 1000000000 + (ss.SymbolSetCode.DigitOne * (uint)100000) + (ss.SymbolSetCode.DigitTwo * (uint)10000);  	if (sig != null) {  		partA = partA + (sig.StandardIdentityGroupCode * (uint)1000000);  	}  	uint partB = (e.EntityCode.DigitOne * (uint)1000000000) + (e.EntityCode.DigitTwo * (uint)100000000);  	if (eType != null) {  		partB = partB + (eType.EntityTypeCode.DigitOne * (uint)10000000) + (eType.EntityTypeCode.DigitTwo * (uint)1000000);  	}  	if (eSubType != null) {  		partB = partB + (eSubType.EntitySubTypeCode.DigitOne * (uint)100000) + (eSubType.EntitySubTypeCode.DigitTwo * (uint)10000);  	}  	Symbol symbol = _configHelper.Librarian.MakeSymbol (new SIDC (partA' partB));  	//  	// If the symbol has a 2525C equivalent' return it  	//  	if (symbol != null) {  		if (symbol.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  			result = symbol.LegacySIDC;  			if (sig == null && result.Substring (1' 1) == "P") {  				result = result.Substring (0' 1) + "*" + result.Substring (2);  			}  			if (result.Substring (14' 1) == "X")  				result = result.Substring (0' 10) + "****X";  			else if (result.Substring (0' 1) == "W")  				result = result.Substring (0' 13) + "**";  			else if (result.Substring (10' 5) == "-----")  				result = result.Substring (0' 10) + "*****";  			else if (result.Substring (11' 4) == "----")  				result = result.Substring (0' 11) + "****";  		}  	} else {  		logger.Warn ("Symbol could not be built from: " + partA + ":" + partB);  	}  }  
Magic Number,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,The following statement contains a magic number: if (ss != null && e != null) {  	uint partA = 1000000000 + (ss.SymbolSetCode.DigitOne * (uint)100000) + (ss.SymbolSetCode.DigitTwo * (uint)10000);  	if (sig != null) {  		partA = partA + (sig.StandardIdentityGroupCode * (uint)1000000);  	}  	uint partB = (e.EntityCode.DigitOne * (uint)1000000000) + (e.EntityCode.DigitTwo * (uint)100000000);  	if (eType != null) {  		partB = partB + (eType.EntityTypeCode.DigitOne * (uint)10000000) + (eType.EntityTypeCode.DigitTwo * (uint)1000000);  	}  	if (eSubType != null) {  		partB = partB + (eSubType.EntitySubTypeCode.DigitOne * (uint)100000) + (eSubType.EntitySubTypeCode.DigitTwo * (uint)10000);  	}  	Symbol symbol = _configHelper.Librarian.MakeSymbol (new SIDC (partA' partB));  	//  	// If the symbol has a 2525C equivalent' return it  	//  	if (symbol != null) {  		if (symbol.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  			result = symbol.LegacySIDC;  			if (sig == null && result.Substring (1' 1) == "P") {  				result = result.Substring (0' 1) + "*" + result.Substring (2);  			}  			if (result.Substring (14' 1) == "X")  				result = result.Substring (0' 10) + "****X";  			else if (result.Substring (0' 1) == "W")  				result = result.Substring (0' 13) + "**";  			else if (result.Substring (10' 5) == "-----")  				result = result.Substring (0' 10) + "*****";  			else if (result.Substring (11' 4) == "----")  				result = result.Substring (0' 11) + "****";  		}  	} else {  		logger.Warn ("Symbol could not be built from: " + partA + ":" + partB);  	}  }  
Magic Number,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,The following statement contains a magic number: if (ss != null && e != null) {  	uint partA = 1000000000 + (ss.SymbolSetCode.DigitOne * (uint)100000) + (ss.SymbolSetCode.DigitTwo * (uint)10000);  	if (sig != null) {  		partA = partA + (sig.StandardIdentityGroupCode * (uint)1000000);  	}  	uint partB = (e.EntityCode.DigitOne * (uint)1000000000) + (e.EntityCode.DigitTwo * (uint)100000000);  	if (eType != null) {  		partB = partB + (eType.EntityTypeCode.DigitOne * (uint)10000000) + (eType.EntityTypeCode.DigitTwo * (uint)1000000);  	}  	if (eSubType != null) {  		partB = partB + (eSubType.EntitySubTypeCode.DigitOne * (uint)100000) + (eSubType.EntitySubTypeCode.DigitTwo * (uint)10000);  	}  	Symbol symbol = _configHelper.Librarian.MakeSymbol (new SIDC (partA' partB));  	//  	// If the symbol has a 2525C equivalent' return it  	//  	if (symbol != null) {  		if (symbol.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  			result = symbol.LegacySIDC;  			if (sig == null && result.Substring (1' 1) == "P") {  				result = result.Substring (0' 1) + "*" + result.Substring (2);  			}  			if (result.Substring (14' 1) == "X")  				result = result.Substring (0' 10) + "****X";  			else if (result.Substring (0' 1) == "W")  				result = result.Substring (0' 13) + "**";  			else if (result.Substring (10' 5) == "-----")  				result = result.Substring (0' 10) + "*****";  			else if (result.Substring (11' 4) == "----")  				result = result.Substring (0' 11) + "****";  		}  	} else {  		logger.Warn ("Symbol could not be built from: " + partA + ":" + partB);  	}  }  
Magic Number,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,The following statement contains a magic number: if (ss != null && e != null) {  	uint partA = 1000000000 + (ss.SymbolSetCode.DigitOne * (uint)100000) + (ss.SymbolSetCode.DigitTwo * (uint)10000);  	if (sig != null) {  		partA = partA + (sig.StandardIdentityGroupCode * (uint)1000000);  	}  	uint partB = (e.EntityCode.DigitOne * (uint)1000000000) + (e.EntityCode.DigitTwo * (uint)100000000);  	if (eType != null) {  		partB = partB + (eType.EntityTypeCode.DigitOne * (uint)10000000) + (eType.EntityTypeCode.DigitTwo * (uint)1000000);  	}  	if (eSubType != null) {  		partB = partB + (eSubType.EntitySubTypeCode.DigitOne * (uint)100000) + (eSubType.EntitySubTypeCode.DigitTwo * (uint)10000);  	}  	Symbol symbol = _configHelper.Librarian.MakeSymbol (new SIDC (partA' partB));  	//  	// If the symbol has a 2525C equivalent' return it  	//  	if (symbol != null) {  		if (symbol.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  			result = symbol.LegacySIDC;  			if (sig == null && result.Substring (1' 1) == "P") {  				result = result.Substring (0' 1) + "*" + result.Substring (2);  			}  			if (result.Substring (14' 1) == "X")  				result = result.Substring (0' 10) + "****X";  			else if (result.Substring (0' 1) == "W")  				result = result.Substring (0' 13) + "**";  			else if (result.Substring (10' 5) == "-----")  				result = result.Substring (0' 10) + "*****";  			else if (result.Substring (11' 4) == "----")  				result = result.Substring (0' 11) + "****";  		}  	} else {  		logger.Warn ("Symbol could not be built from: " + partA + ":" + partB);  	}  }  
Magic Number,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,The following statement contains a magic number: if (ss != null && e != null) {  	uint partA = 1000000000 + (ss.SymbolSetCode.DigitOne * (uint)100000) + (ss.SymbolSetCode.DigitTwo * (uint)10000);  	if (sig != null) {  		partA = partA + (sig.StandardIdentityGroupCode * (uint)1000000);  	}  	uint partB = (e.EntityCode.DigitOne * (uint)1000000000) + (e.EntityCode.DigitTwo * (uint)100000000);  	if (eType != null) {  		partB = partB + (eType.EntityTypeCode.DigitOne * (uint)10000000) + (eType.EntityTypeCode.DigitTwo * (uint)1000000);  	}  	if (eSubType != null) {  		partB = partB + (eSubType.EntitySubTypeCode.DigitOne * (uint)100000) + (eSubType.EntitySubTypeCode.DigitTwo * (uint)10000);  	}  	Symbol symbol = _configHelper.Librarian.MakeSymbol (new SIDC (partA' partB));  	//  	// If the symbol has a 2525C equivalent' return it  	//  	if (symbol != null) {  		if (symbol.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  			result = symbol.LegacySIDC;  			if (sig == null && result.Substring (1' 1) == "P") {  				result = result.Substring (0' 1) + "*" + result.Substring (2);  			}  			if (result.Substring (14' 1) == "X")  				result = result.Substring (0' 10) + "****X";  			else if (result.Substring (0' 1) == "W")  				result = result.Substring (0' 13) + "**";  			else if (result.Substring (10' 5) == "-----")  				result = result.Substring (0' 10) + "*****";  			else if (result.Substring (11' 4) == "----")  				result = result.Substring (0' 11) + "****";  		}  	} else {  		logger.Warn ("Symbol could not be built from: " + partA + ":" + partB);  	}  }  
Magic Number,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,The following statement contains a magic number: if (sig != null) {  	partA = partA + (sig.StandardIdentityGroupCode * (uint)1000000);  }  
Magic Number,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,The following statement contains a magic number: partA = partA + (sig.StandardIdentityGroupCode * (uint)1000000);  
Magic Number,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,The following statement contains a magic number: if (eType != null) {  	partB = partB + (eType.EntityTypeCode.DigitOne * (uint)10000000) + (eType.EntityTypeCode.DigitTwo * (uint)1000000);  }  
Magic Number,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,The following statement contains a magic number: if (eType != null) {  	partB = partB + (eType.EntityTypeCode.DigitOne * (uint)10000000) + (eType.EntityTypeCode.DigitTwo * (uint)1000000);  }  
Magic Number,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,The following statement contains a magic number: partB = partB + (eType.EntityTypeCode.DigitOne * (uint)10000000) + (eType.EntityTypeCode.DigitTwo * (uint)1000000);  
Magic Number,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,The following statement contains a magic number: partB = partB + (eType.EntityTypeCode.DigitOne * (uint)10000000) + (eType.EntityTypeCode.DigitTwo * (uint)1000000);  
Magic Number,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,The following statement contains a magic number: if (eSubType != null) {  	partB = partB + (eSubType.EntitySubTypeCode.DigitOne * (uint)100000) + (eSubType.EntitySubTypeCode.DigitTwo * (uint)10000);  }  
Magic Number,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,The following statement contains a magic number: if (eSubType != null) {  	partB = partB + (eSubType.EntitySubTypeCode.DigitOne * (uint)100000) + (eSubType.EntitySubTypeCode.DigitTwo * (uint)10000);  }  
Magic Number,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,The following statement contains a magic number: partB = partB + (eSubType.EntitySubTypeCode.DigitOne * (uint)100000) + (eSubType.EntitySubTypeCode.DigitTwo * (uint)10000);  
Magic Number,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,The following statement contains a magic number: partB = partB + (eSubType.EntitySubTypeCode.DigitOne * (uint)100000) + (eSubType.EntitySubTypeCode.DigitTwo * (uint)10000);  
Magic Number,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,The following statement contains a magic number: if (symbol != null) {  	if (symbol.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  		result = symbol.LegacySIDC;  		if (sig == null && result.Substring (1' 1) == "P") {  			result = result.Substring (0' 1) + "*" + result.Substring (2);  		}  		if (result.Substring (14' 1) == "X")  			result = result.Substring (0' 10) + "****X";  		else if (result.Substring (0' 1) == "W")  			result = result.Substring (0' 13) + "**";  		else if (result.Substring (10' 5) == "-----")  			result = result.Substring (0' 10) + "*****";  		else if (result.Substring (11' 4) == "----")  			result = result.Substring (0' 11) + "****";  	}  } else {  	logger.Warn ("Symbol could not be built from: " + partA + ":" + partB);  }  
Magic Number,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,The following statement contains a magic number: if (symbol != null) {  	if (symbol.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  		result = symbol.LegacySIDC;  		if (sig == null && result.Substring (1' 1) == "P") {  			result = result.Substring (0' 1) + "*" + result.Substring (2);  		}  		if (result.Substring (14' 1) == "X")  			result = result.Substring (0' 10) + "****X";  		else if (result.Substring (0' 1) == "W")  			result = result.Substring (0' 13) + "**";  		else if (result.Substring (10' 5) == "-----")  			result = result.Substring (0' 10) + "*****";  		else if (result.Substring (11' 4) == "----")  			result = result.Substring (0' 11) + "****";  	}  } else {  	logger.Warn ("Symbol could not be built from: " + partA + ":" + partB);  }  
Magic Number,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,The following statement contains a magic number: if (symbol != null) {  	if (symbol.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  		result = symbol.LegacySIDC;  		if (sig == null && result.Substring (1' 1) == "P") {  			result = result.Substring (0' 1) + "*" + result.Substring (2);  		}  		if (result.Substring (14' 1) == "X")  			result = result.Substring (0' 10) + "****X";  		else if (result.Substring (0' 1) == "W")  			result = result.Substring (0' 13) + "**";  		else if (result.Substring (10' 5) == "-----")  			result = result.Substring (0' 10) + "*****";  		else if (result.Substring (11' 4) == "----")  			result = result.Substring (0' 11) + "****";  	}  } else {  	logger.Warn ("Symbol could not be built from: " + partA + ":" + partB);  }  
Magic Number,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,The following statement contains a magic number: if (symbol != null) {  	if (symbol.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  		result = symbol.LegacySIDC;  		if (sig == null && result.Substring (1' 1) == "P") {  			result = result.Substring (0' 1) + "*" + result.Substring (2);  		}  		if (result.Substring (14' 1) == "X")  			result = result.Substring (0' 10) + "****X";  		else if (result.Substring (0' 1) == "W")  			result = result.Substring (0' 13) + "**";  		else if (result.Substring (10' 5) == "-----")  			result = result.Substring (0' 10) + "*****";  		else if (result.Substring (11' 4) == "----")  			result = result.Substring (0' 11) + "****";  	}  } else {  	logger.Warn ("Symbol could not be built from: " + partA + ":" + partB);  }  
Magic Number,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,The following statement contains a magic number: if (symbol != null) {  	if (symbol.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  		result = symbol.LegacySIDC;  		if (sig == null && result.Substring (1' 1) == "P") {  			result = result.Substring (0' 1) + "*" + result.Substring (2);  		}  		if (result.Substring (14' 1) == "X")  			result = result.Substring (0' 10) + "****X";  		else if (result.Substring (0' 1) == "W")  			result = result.Substring (0' 13) + "**";  		else if (result.Substring (10' 5) == "-----")  			result = result.Substring (0' 10) + "*****";  		else if (result.Substring (11' 4) == "----")  			result = result.Substring (0' 11) + "****";  	}  } else {  	logger.Warn ("Symbol could not be built from: " + partA + ":" + partB);  }  
Magic Number,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,The following statement contains a magic number: if (symbol != null) {  	if (symbol.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  		result = symbol.LegacySIDC;  		if (sig == null && result.Substring (1' 1) == "P") {  			result = result.Substring (0' 1) + "*" + result.Substring (2);  		}  		if (result.Substring (14' 1) == "X")  			result = result.Substring (0' 10) + "****X";  		else if (result.Substring (0' 1) == "W")  			result = result.Substring (0' 13) + "**";  		else if (result.Substring (10' 5) == "-----")  			result = result.Substring (0' 10) + "*****";  		else if (result.Substring (11' 4) == "----")  			result = result.Substring (0' 11) + "****";  	}  } else {  	logger.Warn ("Symbol could not be built from: " + partA + ":" + partB);  }  
Magic Number,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,The following statement contains a magic number: if (symbol != null) {  	if (symbol.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  		result = symbol.LegacySIDC;  		if (sig == null && result.Substring (1' 1) == "P") {  			result = result.Substring (0' 1) + "*" + result.Substring (2);  		}  		if (result.Substring (14' 1) == "X")  			result = result.Substring (0' 10) + "****X";  		else if (result.Substring (0' 1) == "W")  			result = result.Substring (0' 13) + "**";  		else if (result.Substring (10' 5) == "-----")  			result = result.Substring (0' 10) + "*****";  		else if (result.Substring (11' 4) == "----")  			result = result.Substring (0' 11) + "****";  	}  } else {  	logger.Warn ("Symbol could not be built from: " + partA + ":" + partB);  }  
Magic Number,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,The following statement contains a magic number: if (symbol != null) {  	if (symbol.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  		result = symbol.LegacySIDC;  		if (sig == null && result.Substring (1' 1) == "P") {  			result = result.Substring (0' 1) + "*" + result.Substring (2);  		}  		if (result.Substring (14' 1) == "X")  			result = result.Substring (0' 10) + "****X";  		else if (result.Substring (0' 1) == "W")  			result = result.Substring (0' 13) + "**";  		else if (result.Substring (10' 5) == "-----")  			result = result.Substring (0' 10) + "*****";  		else if (result.Substring (11' 4) == "----")  			result = result.Substring (0' 11) + "****";  	}  } else {  	logger.Warn ("Symbol could not be built from: " + partA + ":" + partB);  }  
Magic Number,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,The following statement contains a magic number: if (symbol != null) {  	if (symbol.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  		result = symbol.LegacySIDC;  		if (sig == null && result.Substring (1' 1) == "P") {  			result = result.Substring (0' 1) + "*" + result.Substring (2);  		}  		if (result.Substring (14' 1) == "X")  			result = result.Substring (0' 10) + "****X";  		else if (result.Substring (0' 1) == "W")  			result = result.Substring (0' 13) + "**";  		else if (result.Substring (10' 5) == "-----")  			result = result.Substring (0' 10) + "*****";  		else if (result.Substring (11' 4) == "----")  			result = result.Substring (0' 11) + "****";  	}  } else {  	logger.Warn ("Symbol could not be built from: " + partA + ":" + partB);  }  
Magic Number,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,The following statement contains a magic number: if (symbol != null) {  	if (symbol.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  		result = symbol.LegacySIDC;  		if (sig == null && result.Substring (1' 1) == "P") {  			result = result.Substring (0' 1) + "*" + result.Substring (2);  		}  		if (result.Substring (14' 1) == "X")  			result = result.Substring (0' 10) + "****X";  		else if (result.Substring (0' 1) == "W")  			result = result.Substring (0' 13) + "**";  		else if (result.Substring (10' 5) == "-----")  			result = result.Substring (0' 10) + "*****";  		else if (result.Substring (11' 4) == "----")  			result = result.Substring (0' 11) + "****";  	}  } else {  	logger.Warn ("Symbol could not be built from: " + partA + ":" + partB);  }  
Magic Number,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,The following statement contains a magic number: if (symbol.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  	result = symbol.LegacySIDC;  	if (sig == null && result.Substring (1' 1) == "P") {  		result = result.Substring (0' 1) + "*" + result.Substring (2);  	}  	if (result.Substring (14' 1) == "X")  		result = result.Substring (0' 10) + "****X";  	else if (result.Substring (0' 1) == "W")  		result = result.Substring (0' 13) + "**";  	else if (result.Substring (10' 5) == "-----")  		result = result.Substring (0' 10) + "*****";  	else if (result.Substring (11' 4) == "----")  		result = result.Substring (0' 11) + "****";  }  
Magic Number,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,The following statement contains a magic number: if (symbol.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  	result = symbol.LegacySIDC;  	if (sig == null && result.Substring (1' 1) == "P") {  		result = result.Substring (0' 1) + "*" + result.Substring (2);  	}  	if (result.Substring (14' 1) == "X")  		result = result.Substring (0' 10) + "****X";  	else if (result.Substring (0' 1) == "W")  		result = result.Substring (0' 13) + "**";  	else if (result.Substring (10' 5) == "-----")  		result = result.Substring (0' 10) + "*****";  	else if (result.Substring (11' 4) == "----")  		result = result.Substring (0' 11) + "****";  }  
Magic Number,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,The following statement contains a magic number: if (symbol.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  	result = symbol.LegacySIDC;  	if (sig == null && result.Substring (1' 1) == "P") {  		result = result.Substring (0' 1) + "*" + result.Substring (2);  	}  	if (result.Substring (14' 1) == "X")  		result = result.Substring (0' 10) + "****X";  	else if (result.Substring (0' 1) == "W")  		result = result.Substring (0' 13) + "**";  	else if (result.Substring (10' 5) == "-----")  		result = result.Substring (0' 10) + "*****";  	else if (result.Substring (11' 4) == "----")  		result = result.Substring (0' 11) + "****";  }  
Magic Number,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,The following statement contains a magic number: if (symbol.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  	result = symbol.LegacySIDC;  	if (sig == null && result.Substring (1' 1) == "P") {  		result = result.Substring (0' 1) + "*" + result.Substring (2);  	}  	if (result.Substring (14' 1) == "X")  		result = result.Substring (0' 10) + "****X";  	else if (result.Substring (0' 1) == "W")  		result = result.Substring (0' 13) + "**";  	else if (result.Substring (10' 5) == "-----")  		result = result.Substring (0' 10) + "*****";  	else if (result.Substring (11' 4) == "----")  		result = result.Substring (0' 11) + "****";  }  
Magic Number,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,The following statement contains a magic number: if (symbol.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  	result = symbol.LegacySIDC;  	if (sig == null && result.Substring (1' 1) == "P") {  		result = result.Substring (0' 1) + "*" + result.Substring (2);  	}  	if (result.Substring (14' 1) == "X")  		result = result.Substring (0' 10) + "****X";  	else if (result.Substring (0' 1) == "W")  		result = result.Substring (0' 13) + "**";  	else if (result.Substring (10' 5) == "-----")  		result = result.Substring (0' 10) + "*****";  	else if (result.Substring (11' 4) == "----")  		result = result.Substring (0' 11) + "****";  }  
Magic Number,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,The following statement contains a magic number: if (symbol.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  	result = symbol.LegacySIDC;  	if (sig == null && result.Substring (1' 1) == "P") {  		result = result.Substring (0' 1) + "*" + result.Substring (2);  	}  	if (result.Substring (14' 1) == "X")  		result = result.Substring (0' 10) + "****X";  	else if (result.Substring (0' 1) == "W")  		result = result.Substring (0' 13) + "**";  	else if (result.Substring (10' 5) == "-----")  		result = result.Substring (0' 10) + "*****";  	else if (result.Substring (11' 4) == "----")  		result = result.Substring (0' 11) + "****";  }  
Magic Number,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,The following statement contains a magic number: if (symbol.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  	result = symbol.LegacySIDC;  	if (sig == null && result.Substring (1' 1) == "P") {  		result = result.Substring (0' 1) + "*" + result.Substring (2);  	}  	if (result.Substring (14' 1) == "X")  		result = result.Substring (0' 10) + "****X";  	else if (result.Substring (0' 1) == "W")  		result = result.Substring (0' 13) + "**";  	else if (result.Substring (10' 5) == "-----")  		result = result.Substring (0' 10) + "*****";  	else if (result.Substring (11' 4) == "----")  		result = result.Substring (0' 11) + "****";  }  
Magic Number,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,The following statement contains a magic number: if (symbol.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  	result = symbol.LegacySIDC;  	if (sig == null && result.Substring (1' 1) == "P") {  		result = result.Substring (0' 1) + "*" + result.Substring (2);  	}  	if (result.Substring (14' 1) == "X")  		result = result.Substring (0' 10) + "****X";  	else if (result.Substring (0' 1) == "W")  		result = result.Substring (0' 13) + "**";  	else if (result.Substring (10' 5) == "-----")  		result = result.Substring (0' 10) + "*****";  	else if (result.Substring (11' 4) == "----")  		result = result.Substring (0' 11) + "****";  }  
Magic Number,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,The following statement contains a magic number: if (symbol.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  	result = symbol.LegacySIDC;  	if (sig == null && result.Substring (1' 1) == "P") {  		result = result.Substring (0' 1) + "*" + result.Substring (2);  	}  	if (result.Substring (14' 1) == "X")  		result = result.Substring (0' 10) + "****X";  	else if (result.Substring (0' 1) == "W")  		result = result.Substring (0' 13) + "**";  	else if (result.Substring (10' 5) == "-----")  		result = result.Substring (0' 10) + "*****";  	else if (result.Substring (11' 4) == "----")  		result = result.Substring (0' 11) + "****";  }  
Magic Number,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,The following statement contains a magic number: if (symbol.SymbolStatus == SymbolStatusEnum.statusEnumOld) {  	result = symbol.LegacySIDC;  	if (sig == null && result.Substring (1' 1) == "P") {  		result = result.Substring (0' 1) + "*" + result.Substring (2);  	}  	if (result.Substring (14' 1) == "X")  		result = result.Substring (0' 10) + "****X";  	else if (result.Substring (0' 1) == "W")  		result = result.Substring (0' 13) + "**";  	else if (result.Substring (10' 5) == "-----")  		result = result.Substring (0' 10) + "*****";  	else if (result.Substring (11' 4) == "----")  		result = result.Substring (0' 11) + "****";  }  
Magic Number,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,The following statement contains a magic number: if (sig == null && result.Substring (1' 1) == "P") {  	result = result.Substring (0' 1) + "*" + result.Substring (2);  }  
Magic Number,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,The following statement contains a magic number: result = result.Substring (0' 1) + "*" + result.Substring (2);  
Magic Number,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,The following statement contains a magic number: if (result.Substring (14' 1) == "X")  	result = result.Substring (0' 10) + "****X";  else if (result.Substring (0' 1) == "W")  	result = result.Substring (0' 13) + "**";  else if (result.Substring (10' 5) == "-----")  	result = result.Substring (0' 10) + "*****";  else if (result.Substring (11' 4) == "----")  	result = result.Substring (0' 11) + "****";  
Magic Number,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,The following statement contains a magic number: if (result.Substring (14' 1) == "X")  	result = result.Substring (0' 10) + "****X";  else if (result.Substring (0' 1) == "W")  	result = result.Substring (0' 13) + "**";  else if (result.Substring (10' 5) == "-----")  	result = result.Substring (0' 10) + "*****";  else if (result.Substring (11' 4) == "----")  	result = result.Substring (0' 11) + "****";  
Magic Number,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,The following statement contains a magic number: if (result.Substring (14' 1) == "X")  	result = result.Substring (0' 10) + "****X";  else if (result.Substring (0' 1) == "W")  	result = result.Substring (0' 13) + "**";  else if (result.Substring (10' 5) == "-----")  	result = result.Substring (0' 10) + "*****";  else if (result.Substring (11' 4) == "----")  	result = result.Substring (0' 11) + "****";  
Magic Number,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,The following statement contains a magic number: if (result.Substring (14' 1) == "X")  	result = result.Substring (0' 10) + "****X";  else if (result.Substring (0' 1) == "W")  	result = result.Substring (0' 13) + "**";  else if (result.Substring (10' 5) == "-----")  	result = result.Substring (0' 10) + "*****";  else if (result.Substring (11' 4) == "----")  	result = result.Substring (0' 11) + "****";  
Magic Number,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,The following statement contains a magic number: if (result.Substring (14' 1) == "X")  	result = result.Substring (0' 10) + "****X";  else if (result.Substring (0' 1) == "W")  	result = result.Substring (0' 13) + "**";  else if (result.Substring (10' 5) == "-----")  	result = result.Substring (0' 10) + "*****";  else if (result.Substring (11' 4) == "----")  	result = result.Substring (0' 11) + "****";  
Magic Number,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,The following statement contains a magic number: if (result.Substring (14' 1) == "X")  	result = result.Substring (0' 10) + "****X";  else if (result.Substring (0' 1) == "W")  	result = result.Substring (0' 13) + "**";  else if (result.Substring (10' 5) == "-----")  	result = result.Substring (0' 10) + "*****";  else if (result.Substring (11' 4) == "----")  	result = result.Substring (0' 11) + "****";  
Magic Number,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,The following statement contains a magic number: if (result.Substring (14' 1) == "X")  	result = result.Substring (0' 10) + "****X";  else if (result.Substring (0' 1) == "W")  	result = result.Substring (0' 13) + "**";  else if (result.Substring (10' 5) == "-----")  	result = result.Substring (0' 10) + "*****";  else if (result.Substring (11' 4) == "----")  	result = result.Substring (0' 11) + "****";  
Magic Number,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,The following statement contains a magic number: if (result.Substring (14' 1) == "X")  	result = result.Substring (0' 10) + "****X";  else if (result.Substring (0' 1) == "W")  	result = result.Substring (0' 13) + "**";  else if (result.Substring (10' 5) == "-----")  	result = result.Substring (0' 10) + "*****";  else if (result.Substring (11' 4) == "----")  	result = result.Substring (0' 11) + "****";  
Magic Number,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,The following statement contains a magic number: if (result.Substring (14' 1) == "X")  	result = result.Substring (0' 10) + "****X";  else if (result.Substring (0' 1) == "W")  	result = result.Substring (0' 13) + "**";  else if (result.Substring (10' 5) == "-----")  	result = result.Substring (0' 10) + "*****";  else if (result.Substring (11' 4) == "----")  	result = result.Substring (0' 11) + "****";  
Magic Number,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,The following statement contains a magic number: result = result.Substring (0' 10) + "****X";  
Magic Number,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,The following statement contains a magic number: if (result.Substring (0' 1) == "W")  	result = result.Substring (0' 13) + "**";  else if (result.Substring (10' 5) == "-----")  	result = result.Substring (0' 10) + "*****";  else if (result.Substring (11' 4) == "----")  	result = result.Substring (0' 11) + "****";  
Magic Number,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,The following statement contains a magic number: if (result.Substring (0' 1) == "W")  	result = result.Substring (0' 13) + "**";  else if (result.Substring (10' 5) == "-----")  	result = result.Substring (0' 10) + "*****";  else if (result.Substring (11' 4) == "----")  	result = result.Substring (0' 11) + "****";  
Magic Number,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,The following statement contains a magic number: if (result.Substring (0' 1) == "W")  	result = result.Substring (0' 13) + "**";  else if (result.Substring (10' 5) == "-----")  	result = result.Substring (0' 10) + "*****";  else if (result.Substring (11' 4) == "----")  	result = result.Substring (0' 11) + "****";  
Magic Number,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,The following statement contains a magic number: if (result.Substring (0' 1) == "W")  	result = result.Substring (0' 13) + "**";  else if (result.Substring (10' 5) == "-----")  	result = result.Substring (0' 10) + "*****";  else if (result.Substring (11' 4) == "----")  	result = result.Substring (0' 11) + "****";  
Magic Number,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,The following statement contains a magic number: if (result.Substring (0' 1) == "W")  	result = result.Substring (0' 13) + "**";  else if (result.Substring (10' 5) == "-----")  	result = result.Substring (0' 10) + "*****";  else if (result.Substring (11' 4) == "----")  	result = result.Substring (0' 11) + "****";  
Magic Number,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,The following statement contains a magic number: if (result.Substring (0' 1) == "W")  	result = result.Substring (0' 13) + "**";  else if (result.Substring (10' 5) == "-----")  	result = result.Substring (0' 10) + "*****";  else if (result.Substring (11' 4) == "----")  	result = result.Substring (0' 11) + "****";  
Magic Number,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,The following statement contains a magic number: if (result.Substring (0' 1) == "W")  	result = result.Substring (0' 13) + "**";  else if (result.Substring (10' 5) == "-----")  	result = result.Substring (0' 10) + "*****";  else if (result.Substring (11' 4) == "----")  	result = result.Substring (0' 11) + "****";  
Magic Number,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,The following statement contains a magic number: result = result.Substring (0' 13) + "**";  
Magic Number,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,The following statement contains a magic number: if (result.Substring (10' 5) == "-----")  	result = result.Substring (0' 10) + "*****";  else if (result.Substring (11' 4) == "----")  	result = result.Substring (0' 11) + "****";  
Magic Number,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,The following statement contains a magic number: if (result.Substring (10' 5) == "-----")  	result = result.Substring (0' 10) + "*****";  else if (result.Substring (11' 4) == "----")  	result = result.Substring (0' 11) + "****";  
Magic Number,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,The following statement contains a magic number: if (result.Substring (10' 5) == "-----")  	result = result.Substring (0' 10) + "*****";  else if (result.Substring (11' 4) == "----")  	result = result.Substring (0' 11) + "****";  
Magic Number,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,The following statement contains a magic number: if (result.Substring (10' 5) == "-----")  	result = result.Substring (0' 10) + "*****";  else if (result.Substring (11' 4) == "----")  	result = result.Substring (0' 11) + "****";  
Magic Number,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,The following statement contains a magic number: if (result.Substring (10' 5) == "-----")  	result = result.Substring (0' 10) + "*****";  else if (result.Substring (11' 4) == "----")  	result = result.Substring (0' 11) + "****";  
Magic Number,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,The following statement contains a magic number: if (result.Substring (10' 5) == "-----")  	result = result.Substring (0' 10) + "*****";  else if (result.Substring (11' 4) == "----")  	result = result.Substring (0' 11) + "****";  
Magic Number,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,The following statement contains a magic number: result = result.Substring (0' 10) + "*****";  
Magic Number,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,The following statement contains a magic number: if (result.Substring (11' 4) == "----")  	result = result.Substring (0' 11) + "****";  
Magic Number,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,The following statement contains a magic number: if (result.Substring (11' 4) == "----")  	result = result.Substring (0' 11) + "****";  
Magic Number,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,The following statement contains a magic number: if (result.Substring (11' 4) == "----")  	result = result.Substring (0' 11) + "****";  
Magic Number,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,BuildLegacySIDCTag,The following statement contains a magic number: result = result.Substring (0' 11) + "****";  
Magic Number,JointMilitarySymbologyLibrary,ImageAmplifierExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ImageAmplifierExport.cs,Line,The following statement contains a magic number: switch (amplifierGroup.AmplifierGroupCode) {  case 1:  case 2:  	find = FindEnum.FindEchelons;  	category = "Echelon";  	break;  case 3:  case 4:  case 5:  	find = FindEnum.FindMobilities;  	category = "Mobility";  	break;  case 6:  	find = FindEnum.FindAuxiliaryEquipment;  	category = "Auxiliary Equipment";  	break;  }  
Magic Number,JointMilitarySymbologyLibrary,ImageAmplifierExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ImageAmplifierExport.cs,Line,The following statement contains a magic number: switch (amplifierGroup.AmplifierGroupCode) {  case 1:  case 2:  	find = FindEnum.FindEchelons;  	category = "Echelon";  	break;  case 3:  case 4:  case 5:  	find = FindEnum.FindMobilities;  	category = "Mobility";  	break;  case 6:  	find = FindEnum.FindAuxiliaryEquipment;  	category = "Auxiliary Equipment";  	break;  }  
Magic Number,JointMilitarySymbologyLibrary,ImageAmplifierExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ImageAmplifierExport.cs,Line,The following statement contains a magic number: switch (amplifierGroup.AmplifierGroupCode) {  case 1:  case 2:  	find = FindEnum.FindEchelons;  	category = "Echelon";  	break;  case 3:  case 4:  case 5:  	find = FindEnum.FindMobilities;  	category = "Mobility";  	break;  case 6:  	find = FindEnum.FindAuxiliaryEquipment;  	category = "Auxiliary Equipment";  	break;  }  
Magic Number,JointMilitarySymbologyLibrary,ImageAmplifierExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ImageAmplifierExport.cs,Line,The following statement contains a magic number: switch (amplifierGroup.AmplifierGroupCode) {  case 1:  case 2:  	find = FindEnum.FindEchelons;  	category = "Echelon";  	break;  case 3:  case 4:  case 5:  	find = FindEnum.FindMobilities;  	category = "Mobility";  	break;  case 6:  	find = FindEnum.FindAuxiliaryEquipment;  	category = "Auxiliary Equipment";  	break;  }  
Magic Number,JointMilitarySymbologyLibrary,ImageAmplifierExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ImageAmplifierExport.cs,Line,The following statement contains a magic number: switch (amplifierGroup.AmplifierGroupCode) {  case 1:  case 2:  	find = FindEnum.FindEchelons;  	category = "Echelon";  	break;  case 3:  case 4:  case 5:  	find = FindEnum.FindMobilities;  	category = "Mobility";  	break;  case 6:  	find = FindEnum.FindAuxiliaryEquipment;  	category = "Auxiliary Equipment";  	break;  }  
Magic Number,JointMilitarySymbologyLibrary,LegacyFrameGraphicExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\LegacyFrameGraphicExport.cs,Line,The following statement contains a magic number: if (status.LabelAlias == "Planned")  	graphic = graphic.Substring (0' 3) + "A" + graphic.Substring (4);  
Magic Number,JointMilitarySymbologyLibrary,LegacyFrameGraphicExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\LegacyFrameGraphicExport.cs,Line,The following statement contains a magic number: if (status.LabelAlias == "Planned")  	graphic = graphic.Substring (0' 3) + "A" + graphic.Substring (4);  
Magic Number,JointMilitarySymbologyLibrary,LegacyFrameGraphicExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\LegacyFrameGraphicExport.cs,Line,The following statement contains a magic number: graphic = graphic.Substring (0' 3) + "A" + graphic.Substring (4);  
Magic Number,JointMilitarySymbologyLibrary,LegacyFrameGraphicExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\LegacyFrameGraphicExport.cs,Line,The following statement contains a magic number: graphic = graphic.Substring (0' 3) + "A" + graphic.Substring (4);  
Magic Number,JointMilitarySymbologyLibrary,SIDC,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\SIDC.cs,SIDC,The following statement contains a magic number: if (partA.Length != 10 || partB.Length != 10) {  	partA = SIDC.INVALID.PartAString;  	partB = SIDC.INVALID.PartBString;  }  
Magic Number,JointMilitarySymbologyLibrary,SIDC,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\SIDC.cs,SIDC,The following statement contains a magic number: if (partA.Length != 10 || partB.Length != 10) {  	partA = SIDC.INVALID.PartAString;  	partB = SIDC.INVALID.PartBString;  }  
Magic Number,JointMilitarySymbologyLibrary,SimpleEntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\SimpleEntityExport.cs,Line,The following statement contains a magic number: code = code.Substring (2' 6);  
Magic Number,JointMilitarySymbologyLibrary,SimpleEntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\SimpleEntityExport.cs,Line,The following statement contains a magic number: code = code.Substring (2' 6);  
Magic Number,JointMilitarySymbologyLibrary,SimpleEntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\SimpleEntityExport.cs,Line,The following statement contains a magic number: code = code.Substring (2' 6);  
Magic Number,JointMilitarySymbologyLibrary,SimpleEntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\SimpleEntityExport.cs,Line,The following statement contains a magic number: code = code.Substring (2' 6);  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_BuildGraphics,The following statement contains a magic number: if (_sig != null && _amplifierGroup != null && _amplifier != null) {  	if (_amplifier.Graphics != null) {  		switch (_amplifierGroup.AmplifierGroupCode) {  		case 1:  		case 2:  			path = _configHelper.GetPath (""' FindEnum.FindEchelons);  			break;  		case 3:  		case 4:  		case 5:  			path = _configHelper.GetPath (""' FindEnum.FindMobilities);  			break;  		case 6:  			path = _configHelper.GetPath (""' FindEnum.FindAuxiliaryEquipment);  			break;  		}  		graphic = "";  		foreach (LibraryAmplifierGroupAmplifierGraphic lag in _amplifier.Graphics) {  			if (lag.StandardIdentityGroup == _sig.ID) {  				graphic = lag.Graphic;  			}  		}  		if (graphic != "") {  			path = _configHelper.BuildOriginalPath (path' graphic);  			_graphics.Add (path);  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_BuildGraphics,The following statement contains a magic number: if (_sig != null && _amplifierGroup != null && _amplifier != null) {  	if (_amplifier.Graphics != null) {  		switch (_amplifierGroup.AmplifierGroupCode) {  		case 1:  		case 2:  			path = _configHelper.GetPath (""' FindEnum.FindEchelons);  			break;  		case 3:  		case 4:  		case 5:  			path = _configHelper.GetPath (""' FindEnum.FindMobilities);  			break;  		case 6:  			path = _configHelper.GetPath (""' FindEnum.FindAuxiliaryEquipment);  			break;  		}  		graphic = "";  		foreach (LibraryAmplifierGroupAmplifierGraphic lag in _amplifier.Graphics) {  			if (lag.StandardIdentityGroup == _sig.ID) {  				graphic = lag.Graphic;  			}  		}  		if (graphic != "") {  			path = _configHelper.BuildOriginalPath (path' graphic);  			_graphics.Add (path);  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_BuildGraphics,The following statement contains a magic number: if (_sig != null && _amplifierGroup != null && _amplifier != null) {  	if (_amplifier.Graphics != null) {  		switch (_amplifierGroup.AmplifierGroupCode) {  		case 1:  		case 2:  			path = _configHelper.GetPath (""' FindEnum.FindEchelons);  			break;  		case 3:  		case 4:  		case 5:  			path = _configHelper.GetPath (""' FindEnum.FindMobilities);  			break;  		case 6:  			path = _configHelper.GetPath (""' FindEnum.FindAuxiliaryEquipment);  			break;  		}  		graphic = "";  		foreach (LibraryAmplifierGroupAmplifierGraphic lag in _amplifier.Graphics) {  			if (lag.StandardIdentityGroup == _sig.ID) {  				graphic = lag.Graphic;  			}  		}  		if (graphic != "") {  			path = _configHelper.BuildOriginalPath (path' graphic);  			_graphics.Add (path);  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_BuildGraphics,The following statement contains a magic number: if (_sig != null && _amplifierGroup != null && _amplifier != null) {  	if (_amplifier.Graphics != null) {  		switch (_amplifierGroup.AmplifierGroupCode) {  		case 1:  		case 2:  			path = _configHelper.GetPath (""' FindEnum.FindEchelons);  			break;  		case 3:  		case 4:  		case 5:  			path = _configHelper.GetPath (""' FindEnum.FindMobilities);  			break;  		case 6:  			path = _configHelper.GetPath (""' FindEnum.FindAuxiliaryEquipment);  			break;  		}  		graphic = "";  		foreach (LibraryAmplifierGroupAmplifierGraphic lag in _amplifier.Graphics) {  			if (lag.StandardIdentityGroup == _sig.ID) {  				graphic = lag.Graphic;  			}  		}  		if (graphic != "") {  			path = _configHelper.BuildOriginalPath (path' graphic);  			_graphics.Add (path);  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_BuildGraphics,The following statement contains a magic number: if (_sig != null && _amplifierGroup != null && _amplifier != null) {  	if (_amplifier.Graphics != null) {  		switch (_amplifierGroup.AmplifierGroupCode) {  		case 1:  		case 2:  			path = _configHelper.GetPath (""' FindEnum.FindEchelons);  			break;  		case 3:  		case 4:  		case 5:  			path = _configHelper.GetPath (""' FindEnum.FindMobilities);  			break;  		case 6:  			path = _configHelper.GetPath (""' FindEnum.FindAuxiliaryEquipment);  			break;  		}  		graphic = "";  		foreach (LibraryAmplifierGroupAmplifierGraphic lag in _amplifier.Graphics) {  			if (lag.StandardIdentityGroup == _sig.ID) {  				graphic = lag.Graphic;  			}  		}  		if (graphic != "") {  			path = _configHelper.BuildOriginalPath (path' graphic);  			_graphics.Add (path);  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_BuildGraphics,The following statement contains a magic number: if (_amplifier.Graphics != null) {  	switch (_amplifierGroup.AmplifierGroupCode) {  	case 1:  	case 2:  		path = _configHelper.GetPath (""' FindEnum.FindEchelons);  		break;  	case 3:  	case 4:  	case 5:  		path = _configHelper.GetPath (""' FindEnum.FindMobilities);  		break;  	case 6:  		path = _configHelper.GetPath (""' FindEnum.FindAuxiliaryEquipment);  		break;  	}  	graphic = "";  	foreach (LibraryAmplifierGroupAmplifierGraphic lag in _amplifier.Graphics) {  		if (lag.StandardIdentityGroup == _sig.ID) {  			graphic = lag.Graphic;  		}  	}  	if (graphic != "") {  		path = _configHelper.BuildOriginalPath (path' graphic);  		_graphics.Add (path);  	}  }  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_BuildGraphics,The following statement contains a magic number: if (_amplifier.Graphics != null) {  	switch (_amplifierGroup.AmplifierGroupCode) {  	case 1:  	case 2:  		path = _configHelper.GetPath (""' FindEnum.FindEchelons);  		break;  	case 3:  	case 4:  	case 5:  		path = _configHelper.GetPath (""' FindEnum.FindMobilities);  		break;  	case 6:  		path = _configHelper.GetPath (""' FindEnum.FindAuxiliaryEquipment);  		break;  	}  	graphic = "";  	foreach (LibraryAmplifierGroupAmplifierGraphic lag in _amplifier.Graphics) {  		if (lag.StandardIdentityGroup == _sig.ID) {  			graphic = lag.Graphic;  		}  	}  	if (graphic != "") {  		path = _configHelper.BuildOriginalPath (path' graphic);  		_graphics.Add (path);  	}  }  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_BuildGraphics,The following statement contains a magic number: if (_amplifier.Graphics != null) {  	switch (_amplifierGroup.AmplifierGroupCode) {  	case 1:  	case 2:  		path = _configHelper.GetPath (""' FindEnum.FindEchelons);  		break;  	case 3:  	case 4:  	case 5:  		path = _configHelper.GetPath (""' FindEnum.FindMobilities);  		break;  	case 6:  		path = _configHelper.GetPath (""' FindEnum.FindAuxiliaryEquipment);  		break;  	}  	graphic = "";  	foreach (LibraryAmplifierGroupAmplifierGraphic lag in _amplifier.Graphics) {  		if (lag.StandardIdentityGroup == _sig.ID) {  			graphic = lag.Graphic;  		}  	}  	if (graphic != "") {  		path = _configHelper.BuildOriginalPath (path' graphic);  		_graphics.Add (path);  	}  }  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_BuildGraphics,The following statement contains a magic number: if (_amplifier.Graphics != null) {  	switch (_amplifierGroup.AmplifierGroupCode) {  	case 1:  	case 2:  		path = _configHelper.GetPath (""' FindEnum.FindEchelons);  		break;  	case 3:  	case 4:  	case 5:  		path = _configHelper.GetPath (""' FindEnum.FindMobilities);  		break;  	case 6:  		path = _configHelper.GetPath (""' FindEnum.FindAuxiliaryEquipment);  		break;  	}  	graphic = "";  	foreach (LibraryAmplifierGroupAmplifierGraphic lag in _amplifier.Graphics) {  		if (lag.StandardIdentityGroup == _sig.ID) {  			graphic = lag.Graphic;  		}  	}  	if (graphic != "") {  		path = _configHelper.BuildOriginalPath (path' graphic);  		_graphics.Add (path);  	}  }  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_BuildGraphics,The following statement contains a magic number: if (_amplifier.Graphics != null) {  	switch (_amplifierGroup.AmplifierGroupCode) {  	case 1:  	case 2:  		path = _configHelper.GetPath (""' FindEnum.FindEchelons);  		break;  	case 3:  	case 4:  	case 5:  		path = _configHelper.GetPath (""' FindEnum.FindMobilities);  		break;  	case 6:  		path = _configHelper.GetPath (""' FindEnum.FindAuxiliaryEquipment);  		break;  	}  	graphic = "";  	foreach (LibraryAmplifierGroupAmplifierGraphic lag in _amplifier.Graphics) {  		if (lag.StandardIdentityGroup == _sig.ID) {  			graphic = lag.Graphic;  		}  	}  	if (graphic != "") {  		path = _configHelper.BuildOriginalPath (path' graphic);  		_graphics.Add (path);  	}  }  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_BuildGraphics,The following statement contains a magic number: switch (_amplifierGroup.AmplifierGroupCode) {  case 1:  case 2:  	path = _configHelper.GetPath (""' FindEnum.FindEchelons);  	break;  case 3:  case 4:  case 5:  	path = _configHelper.GetPath (""' FindEnum.FindMobilities);  	break;  case 6:  	path = _configHelper.GetPath (""' FindEnum.FindAuxiliaryEquipment);  	break;  }  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_BuildGraphics,The following statement contains a magic number: switch (_amplifierGroup.AmplifierGroupCode) {  case 1:  case 2:  	path = _configHelper.GetPath (""' FindEnum.FindEchelons);  	break;  case 3:  case 4:  case 5:  	path = _configHelper.GetPath (""' FindEnum.FindMobilities);  	break;  case 6:  	path = _configHelper.GetPath (""' FindEnum.FindAuxiliaryEquipment);  	break;  }  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_BuildGraphics,The following statement contains a magic number: switch (_amplifierGroup.AmplifierGroupCode) {  case 1:  case 2:  	path = _configHelper.GetPath (""' FindEnum.FindEchelons);  	break;  case 3:  case 4:  case 5:  	path = _configHelper.GetPath (""' FindEnum.FindMobilities);  	break;  case 6:  	path = _configHelper.GetPath (""' FindEnum.FindAuxiliaryEquipment);  	break;  }  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_BuildGraphics,The following statement contains a magic number: switch (_amplifierGroup.AmplifierGroupCode) {  case 1:  case 2:  	path = _configHelper.GetPath (""' FindEnum.FindEchelons);  	break;  case 3:  case 4:  case 5:  	path = _configHelper.GetPath (""' FindEnum.FindMobilities);  	break;  case 6:  	path = _configHelper.GetPath (""' FindEnum.FindAuxiliaryEquipment);  	break;  }  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_BuildGraphics,The following statement contains a magic number: switch (_amplifierGroup.AmplifierGroupCode) {  case 1:  case 2:  	path = _configHelper.GetPath (""' FindEnum.FindEchelons);  	break;  case 3:  case 4:  case 5:  	path = _configHelper.GetPath (""' FindEnum.FindMobilities);  	break;  case 6:  	path = _configHelper.GetPath (""' FindEnum.FindAuxiliaryEquipment);  	break;  }  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_BuildSIDC,The following statement contains a magic number: if (_version != null && _context != null && _standardIdentity != null && _symbolSet != null && _status != null && _hqTFDummy != null && _amplifierGroup != null && _amplifier != null) {  	_sidc.PartAUInt = (uint)_version.VersionCode.DigitOne * 1000000000 + (uint)_version.VersionCode.DigitTwo * 100000000 + (uint)_context.ContextCode * 10000000 + (uint)_standardIdentity.StandardIdentityCode * 1000000 + (uint)_symbolSet.SymbolSetCode.DigitOne * 100000 + (uint)_symbolSet.SymbolSetCode.DigitTwo * 10000 + (uint)_status.StatusCode * 1000 + (uint)_hqTFDummy.HQTFDummyCode * 100 + (uint)_amplifierGroup.AmplifierGroupCode * 10 + (uint)_amplifier.AmplifierCode;  }  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_BuildSIDC,The following statement contains a magic number: if (_version != null && _context != null && _standardIdentity != null && _symbolSet != null && _status != null && _hqTFDummy != null && _amplifierGroup != null && _amplifier != null) {  	_sidc.PartAUInt = (uint)_version.VersionCode.DigitOne * 1000000000 + (uint)_version.VersionCode.DigitTwo * 100000000 + (uint)_context.ContextCode * 10000000 + (uint)_standardIdentity.StandardIdentityCode * 1000000 + (uint)_symbolSet.SymbolSetCode.DigitOne * 100000 + (uint)_symbolSet.SymbolSetCode.DigitTwo * 10000 + (uint)_status.StatusCode * 1000 + (uint)_hqTFDummy.HQTFDummyCode * 100 + (uint)_amplifierGroup.AmplifierGroupCode * 10 + (uint)_amplifier.AmplifierCode;  }  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_BuildSIDC,The following statement contains a magic number: if (_version != null && _context != null && _standardIdentity != null && _symbolSet != null && _status != null && _hqTFDummy != null && _amplifierGroup != null && _amplifier != null) {  	_sidc.PartAUInt = (uint)_version.VersionCode.DigitOne * 1000000000 + (uint)_version.VersionCode.DigitTwo * 100000000 + (uint)_context.ContextCode * 10000000 + (uint)_standardIdentity.StandardIdentityCode * 1000000 + (uint)_symbolSet.SymbolSetCode.DigitOne * 100000 + (uint)_symbolSet.SymbolSetCode.DigitTwo * 10000 + (uint)_status.StatusCode * 1000 + (uint)_hqTFDummy.HQTFDummyCode * 100 + (uint)_amplifierGroup.AmplifierGroupCode * 10 + (uint)_amplifier.AmplifierCode;  }  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_BuildSIDC,The following statement contains a magic number: if (_version != null && _context != null && _standardIdentity != null && _symbolSet != null && _status != null && _hqTFDummy != null && _amplifierGroup != null && _amplifier != null) {  	_sidc.PartAUInt = (uint)_version.VersionCode.DigitOne * 1000000000 + (uint)_version.VersionCode.DigitTwo * 100000000 + (uint)_context.ContextCode * 10000000 + (uint)_standardIdentity.StandardIdentityCode * 1000000 + (uint)_symbolSet.SymbolSetCode.DigitOne * 100000 + (uint)_symbolSet.SymbolSetCode.DigitTwo * 10000 + (uint)_status.StatusCode * 1000 + (uint)_hqTFDummy.HQTFDummyCode * 100 + (uint)_amplifierGroup.AmplifierGroupCode * 10 + (uint)_amplifier.AmplifierCode;  }  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_BuildSIDC,The following statement contains a magic number: if (_version != null && _context != null && _standardIdentity != null && _symbolSet != null && _status != null && _hqTFDummy != null && _amplifierGroup != null && _amplifier != null) {  	_sidc.PartAUInt = (uint)_version.VersionCode.DigitOne * 1000000000 + (uint)_version.VersionCode.DigitTwo * 100000000 + (uint)_context.ContextCode * 10000000 + (uint)_standardIdentity.StandardIdentityCode * 1000000 + (uint)_symbolSet.SymbolSetCode.DigitOne * 100000 + (uint)_symbolSet.SymbolSetCode.DigitTwo * 10000 + (uint)_status.StatusCode * 1000 + (uint)_hqTFDummy.HQTFDummyCode * 100 + (uint)_amplifierGroup.AmplifierGroupCode * 10 + (uint)_amplifier.AmplifierCode;  }  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_BuildSIDC,The following statement contains a magic number: if (_version != null && _context != null && _standardIdentity != null && _symbolSet != null && _status != null && _hqTFDummy != null && _amplifierGroup != null && _amplifier != null) {  	_sidc.PartAUInt = (uint)_version.VersionCode.DigitOne * 1000000000 + (uint)_version.VersionCode.DigitTwo * 100000000 + (uint)_context.ContextCode * 10000000 + (uint)_standardIdentity.StandardIdentityCode * 1000000 + (uint)_symbolSet.SymbolSetCode.DigitOne * 100000 + (uint)_symbolSet.SymbolSetCode.DigitTwo * 10000 + (uint)_status.StatusCode * 1000 + (uint)_hqTFDummy.HQTFDummyCode * 100 + (uint)_amplifierGroup.AmplifierGroupCode * 10 + (uint)_amplifier.AmplifierCode;  }  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_BuildSIDC,The following statement contains a magic number: if (_version != null && _context != null && _standardIdentity != null && _symbolSet != null && _status != null && _hqTFDummy != null && _amplifierGroup != null && _amplifier != null) {  	_sidc.PartAUInt = (uint)_version.VersionCode.DigitOne * 1000000000 + (uint)_version.VersionCode.DigitTwo * 100000000 + (uint)_context.ContextCode * 10000000 + (uint)_standardIdentity.StandardIdentityCode * 1000000 + (uint)_symbolSet.SymbolSetCode.DigitOne * 100000 + (uint)_symbolSet.SymbolSetCode.DigitTwo * 10000 + (uint)_status.StatusCode * 1000 + (uint)_hqTFDummy.HQTFDummyCode * 100 + (uint)_amplifierGroup.AmplifierGroupCode * 10 + (uint)_amplifier.AmplifierCode;  }  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_BuildSIDC,The following statement contains a magic number: if (_version != null && _context != null && _standardIdentity != null && _symbolSet != null && _status != null && _hqTFDummy != null && _amplifierGroup != null && _amplifier != null) {  	_sidc.PartAUInt = (uint)_version.VersionCode.DigitOne * 1000000000 + (uint)_version.VersionCode.DigitTwo * 100000000 + (uint)_context.ContextCode * 10000000 + (uint)_standardIdentity.StandardIdentityCode * 1000000 + (uint)_symbolSet.SymbolSetCode.DigitOne * 100000 + (uint)_symbolSet.SymbolSetCode.DigitTwo * 10000 + (uint)_status.StatusCode * 1000 + (uint)_hqTFDummy.HQTFDummyCode * 100 + (uint)_amplifierGroup.AmplifierGroupCode * 10 + (uint)_amplifier.AmplifierCode;  }  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_BuildSIDC,The following statement contains a magic number: if (_version != null && _context != null && _standardIdentity != null && _symbolSet != null && _status != null && _hqTFDummy != null && _amplifierGroup != null && _amplifier != null) {  	_sidc.PartAUInt = (uint)_version.VersionCode.DigitOne * 1000000000 + (uint)_version.VersionCode.DigitTwo * 100000000 + (uint)_context.ContextCode * 10000000 + (uint)_standardIdentity.StandardIdentityCode * 1000000 + (uint)_symbolSet.SymbolSetCode.DigitOne * 100000 + (uint)_symbolSet.SymbolSetCode.DigitTwo * 10000 + (uint)_status.StatusCode * 1000 + (uint)_hqTFDummy.HQTFDummyCode * 100 + (uint)_amplifierGroup.AmplifierGroupCode * 10 + (uint)_amplifier.AmplifierCode;  }  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_BuildSIDC,The following statement contains a magic number: _sidc.PartAUInt = (uint)_version.VersionCode.DigitOne * 1000000000 + (uint)_version.VersionCode.DigitTwo * 100000000 + (uint)_context.ContextCode * 10000000 + (uint)_standardIdentity.StandardIdentityCode * 1000000 + (uint)_symbolSet.SymbolSetCode.DigitOne * 100000 + (uint)_symbolSet.SymbolSetCode.DigitTwo * 10000 + (uint)_status.StatusCode * 1000 + (uint)_hqTFDummy.HQTFDummyCode * 100 + (uint)_amplifierGroup.AmplifierGroupCode * 10 + (uint)_amplifier.AmplifierCode;  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_BuildSIDC,The following statement contains a magic number: _sidc.PartAUInt = (uint)_version.VersionCode.DigitOne * 1000000000 + (uint)_version.VersionCode.DigitTwo * 100000000 + (uint)_context.ContextCode * 10000000 + (uint)_standardIdentity.StandardIdentityCode * 1000000 + (uint)_symbolSet.SymbolSetCode.DigitOne * 100000 + (uint)_symbolSet.SymbolSetCode.DigitTwo * 10000 + (uint)_status.StatusCode * 1000 + (uint)_hqTFDummy.HQTFDummyCode * 100 + (uint)_amplifierGroup.AmplifierGroupCode * 10 + (uint)_amplifier.AmplifierCode;  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_BuildSIDC,The following statement contains a magic number: _sidc.PartAUInt = (uint)_version.VersionCode.DigitOne * 1000000000 + (uint)_version.VersionCode.DigitTwo * 100000000 + (uint)_context.ContextCode * 10000000 + (uint)_standardIdentity.StandardIdentityCode * 1000000 + (uint)_symbolSet.SymbolSetCode.DigitOne * 100000 + (uint)_symbolSet.SymbolSetCode.DigitTwo * 10000 + (uint)_status.StatusCode * 1000 + (uint)_hqTFDummy.HQTFDummyCode * 100 + (uint)_amplifierGroup.AmplifierGroupCode * 10 + (uint)_amplifier.AmplifierCode;  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_BuildSIDC,The following statement contains a magic number: _sidc.PartAUInt = (uint)_version.VersionCode.DigitOne * 1000000000 + (uint)_version.VersionCode.DigitTwo * 100000000 + (uint)_context.ContextCode * 10000000 + (uint)_standardIdentity.StandardIdentityCode * 1000000 + (uint)_symbolSet.SymbolSetCode.DigitOne * 100000 + (uint)_symbolSet.SymbolSetCode.DigitTwo * 10000 + (uint)_status.StatusCode * 1000 + (uint)_hqTFDummy.HQTFDummyCode * 100 + (uint)_amplifierGroup.AmplifierGroupCode * 10 + (uint)_amplifier.AmplifierCode;  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_BuildSIDC,The following statement contains a magic number: _sidc.PartAUInt = (uint)_version.VersionCode.DigitOne * 1000000000 + (uint)_version.VersionCode.DigitTwo * 100000000 + (uint)_context.ContextCode * 10000000 + (uint)_standardIdentity.StandardIdentityCode * 1000000 + (uint)_symbolSet.SymbolSetCode.DigitOne * 100000 + (uint)_symbolSet.SymbolSetCode.DigitTwo * 10000 + (uint)_status.StatusCode * 1000 + (uint)_hqTFDummy.HQTFDummyCode * 100 + (uint)_amplifierGroup.AmplifierGroupCode * 10 + (uint)_amplifier.AmplifierCode;  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_BuildSIDC,The following statement contains a magic number: _sidc.PartAUInt = (uint)_version.VersionCode.DigitOne * 1000000000 + (uint)_version.VersionCode.DigitTwo * 100000000 + (uint)_context.ContextCode * 10000000 + (uint)_standardIdentity.StandardIdentityCode * 1000000 + (uint)_symbolSet.SymbolSetCode.DigitOne * 100000 + (uint)_symbolSet.SymbolSetCode.DigitTwo * 10000 + (uint)_status.StatusCode * 1000 + (uint)_hqTFDummy.HQTFDummyCode * 100 + (uint)_amplifierGroup.AmplifierGroupCode * 10 + (uint)_amplifier.AmplifierCode;  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_BuildSIDC,The following statement contains a magic number: _sidc.PartAUInt = (uint)_version.VersionCode.DigitOne * 1000000000 + (uint)_version.VersionCode.DigitTwo * 100000000 + (uint)_context.ContextCode * 10000000 + (uint)_standardIdentity.StandardIdentityCode * 1000000 + (uint)_symbolSet.SymbolSetCode.DigitOne * 100000 + (uint)_symbolSet.SymbolSetCode.DigitTwo * 10000 + (uint)_status.StatusCode * 1000 + (uint)_hqTFDummy.HQTFDummyCode * 100 + (uint)_amplifierGroup.AmplifierGroupCode * 10 + (uint)_amplifier.AmplifierCode;  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_BuildSIDC,The following statement contains a magic number: _sidc.PartAUInt = (uint)_version.VersionCode.DigitOne * 1000000000 + (uint)_version.VersionCode.DigitTwo * 100000000 + (uint)_context.ContextCode * 10000000 + (uint)_standardIdentity.StandardIdentityCode * 1000000 + (uint)_symbolSet.SymbolSetCode.DigitOne * 100000 + (uint)_symbolSet.SymbolSetCode.DigitTwo * 10000 + (uint)_status.StatusCode * 1000 + (uint)_hqTFDummy.HQTFDummyCode * 100 + (uint)_amplifierGroup.AmplifierGroupCode * 10 + (uint)_amplifier.AmplifierCode;  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_BuildSIDC,The following statement contains a magic number: _sidc.PartAUInt = (uint)_version.VersionCode.DigitOne * 1000000000 + (uint)_version.VersionCode.DigitTwo * 100000000 + (uint)_context.ContextCode * 10000000 + (uint)_standardIdentity.StandardIdentityCode * 1000000 + (uint)_symbolSet.SymbolSetCode.DigitOne * 100000 + (uint)_symbolSet.SymbolSetCode.DigitTwo * 10000 + (uint)_status.StatusCode * 1000 + (uint)_hqTFDummy.HQTFDummyCode * 100 + (uint)_amplifierGroup.AmplifierGroupCode * 10 + (uint)_amplifier.AmplifierCode;  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_BuildSIDC,The following statement contains a magic number: if (_entity != null) {  	_sidc.PartBUInt = (uint)_entity.EntityCode.DigitOne * 1000000000 + (uint)_entity.EntityCode.DigitTwo * 100000000;  }  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_BuildSIDC,The following statement contains a magic number: if (_entity != null) {  	_sidc.PartBUInt = (uint)_entity.EntityCode.DigitOne * 1000000000 + (uint)_entity.EntityCode.DigitTwo * 100000000;  }  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_BuildSIDC,The following statement contains a magic number: _sidc.PartBUInt = (uint)_entity.EntityCode.DigitOne * 1000000000 + (uint)_entity.EntityCode.DigitTwo * 100000000;  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_BuildSIDC,The following statement contains a magic number: _sidc.PartBUInt = (uint)_entity.EntityCode.DigitOne * 1000000000 + (uint)_entity.EntityCode.DigitTwo * 100000000;  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_BuildSIDC,The following statement contains a magic number: if (_entityType != null) {  	_sidc.PartBUInt = _sidc.PartBUInt + (uint)_entityType.EntityTypeCode.DigitOne * 10000000 + (uint)_entityType.EntityTypeCode.DigitTwo * 1000000;  }  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_BuildSIDC,The following statement contains a magic number: if (_entityType != null) {  	_sidc.PartBUInt = _sidc.PartBUInt + (uint)_entityType.EntityTypeCode.DigitOne * 10000000 + (uint)_entityType.EntityTypeCode.DigitTwo * 1000000;  }  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_BuildSIDC,The following statement contains a magic number: _sidc.PartBUInt = _sidc.PartBUInt + (uint)_entityType.EntityTypeCode.DigitOne * 10000000 + (uint)_entityType.EntityTypeCode.DigitTwo * 1000000;  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_BuildSIDC,The following statement contains a magic number: _sidc.PartBUInt = _sidc.PartBUInt + (uint)_entityType.EntityTypeCode.DigitOne * 10000000 + (uint)_entityType.EntityTypeCode.DigitTwo * 1000000;  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_BuildSIDC,The following statement contains a magic number: if (_entitySubType != null) {  	_sidc.PartBUInt = _sidc.PartBUInt + (uint)_entitySubType.EntitySubTypeCode.DigitOne * 100000 + (uint)_entitySubType.EntitySubTypeCode.DigitTwo * 10000;  }  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_BuildSIDC,The following statement contains a magic number: if (_entitySubType != null) {  	_sidc.PartBUInt = _sidc.PartBUInt + (uint)_entitySubType.EntitySubTypeCode.DigitOne * 100000 + (uint)_entitySubType.EntitySubTypeCode.DigitTwo * 10000;  }  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_BuildSIDC,The following statement contains a magic number: _sidc.PartBUInt = _sidc.PartBUInt + (uint)_entitySubType.EntitySubTypeCode.DigitOne * 100000 + (uint)_entitySubType.EntitySubTypeCode.DigitTwo * 10000;  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_BuildSIDC,The following statement contains a magic number: _sidc.PartBUInt = _sidc.PartBUInt + (uint)_entitySubType.EntitySubTypeCode.DigitOne * 100000 + (uint)_entitySubType.EntitySubTypeCode.DigitTwo * 10000;  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_BuildSIDC,The following statement contains a magic number: if (_modifierOne != null) {  	_sidc.PartBUInt = _sidc.PartBUInt + (uint)_modifierOne.ModifierCode.DigitOne * 1000 + (uint)_modifierOne.ModifierCode.DigitTwo * 100;  }  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_BuildSIDC,The following statement contains a magic number: if (_modifierOne != null) {  	_sidc.PartBUInt = _sidc.PartBUInt + (uint)_modifierOne.ModifierCode.DigitOne * 1000 + (uint)_modifierOne.ModifierCode.DigitTwo * 100;  }  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_BuildSIDC,The following statement contains a magic number: _sidc.PartBUInt = _sidc.PartBUInt + (uint)_modifierOne.ModifierCode.DigitOne * 1000 + (uint)_modifierOne.ModifierCode.DigitTwo * 100;  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_BuildSIDC,The following statement contains a magic number: _sidc.PartBUInt = _sidc.PartBUInt + (uint)_modifierOne.ModifierCode.DigitOne * 1000 + (uint)_modifierOne.ModifierCode.DigitTwo * 100;  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_BuildSIDC,The following statement contains a magic number: if (_modifierTwo != null) {  	_sidc.PartBUInt = _sidc.PartBUInt + (uint)_modifierTwo.ModifierCode.DigitOne * 10 + (uint)_modifierTwo.ModifierCode.DigitTwo;  }  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_BuildSIDC,The following statement contains a magic number: _sidc.PartBUInt = _sidc.PartBUInt + (uint)_modifierTwo.ModifierCode.DigitOne * 10 + (uint)_modifierTwo.ModifierCode.DigitTwo;  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_BuildLegacySIDC,The following statement contains a magic number: if (_symbolSet != null && _affiliation != null && _dimension != null && _status != null && _amplifierGroup != null && _amplifier != null && _context.ContextCode != 2) {  	if (_legacySymbol != null) {  		// Schema  		if (functionCode.SchemaOverride != "")  			result = functionCode.SchemaOverride;  		else  			result = _symbolSet.LegacyCodingSchemeCode [0].Value;  		// Standard Identity  		if (functionCode.StandardIdentityOverride != "")  			result = result + functionCode.StandardIdentityOverride;  		else  			result = result + _affiliation.LegacyStandardIdentityCode [0].Value;  		// Dimension  		if (functionCode.DimensionOverride != "")  			result = result + functionCode.DimensionOverride;  		else  			result = result + _dimension.LegacyDimensionCode [0].Value;  		// Status  		if (functionCode.StatusOverride != "")  			result = result + functionCode.StatusOverride;  		else  			result = result + _status.LegacyStatusCode [0].Value;  		// Function  		result = result + functionCode.Value;  	} else {  		result = _symbolSet.LegacyCodingSchemeCode [0].Value + _affiliation.LegacyStandardIdentityCode [0].Value + _dimension.LegacyDimensionCode [0].Value + _status.LegacyStatusCode [0].Value + _blankLegacyFunction;  	}  	// HQTFFD  	if (functionCode.HQTFFDOverride != "")  		result = result + functionCode.HQTFFDOverride;  	else  		result = result + _amplifierGroup.LegacyModifierCode [0].Value;  	// Amplifier  	if (functionCode.AmplifierOverride != "")  		result = result + functionCode.AmplifierOverride;  	else  		result = result + _amplifier.LegacyModifierCode [0].Value;  	//Tail  	if (functionCode.TailOverride != "")  		result = result + functionCode.TailOverride;  	else  		result = result + _blankLegacyTail;  }  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_UpdateFromCurrent,The following statement contains a magic number: _context = _librarian.Context (Convert.ToUInt16 (first10.Substring (2' 1)));  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_UpdateFromCurrent,The following statement contains a magic number: _standardIdentity = _librarian.StandardIdentity (Convert.ToUInt16 (first10.Substring (3' 1)));  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_UpdateFromCurrent,The following statement contains a magic number: _symbolSet = _librarian.SymbolSet (Convert.ToUInt16 (first10.Substring (4' 1))' Convert.ToUInt16 (first10.Substring (5' 1)));  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_UpdateFromCurrent,The following statement contains a magic number: _symbolSet = _librarian.SymbolSet (Convert.ToUInt16 (first10.Substring (4' 1))' Convert.ToUInt16 (first10.Substring (5' 1)));  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_UpdateFromCurrent,The following statement contains a magic number: _status = _librarian.Status (Convert.ToUInt16 (first10.Substring (6' 1)));  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_UpdateFromCurrent,The following statement contains a magic number: _hqTFDummy = _librarian.HQTFDummy (Convert.ToUInt16 (first10.Substring (7' 1)));  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_UpdateFromCurrent,The following statement contains a magic number: _amplifierGroup = _librarian.AmplifierGroup (Convert.ToUInt16 (first10.Substring (8' 1)));  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_UpdateFromCurrent,The following statement contains a magic number: if (_amplifierGroup != null) {  	_amplifier = _librarian.Amplifier (_amplifierGroup' Convert.ToUInt16 (first10.Substring (9' 1)));  }  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_UpdateFromCurrent,The following statement contains a magic number: _amplifier = _librarian.Amplifier (_amplifierGroup' Convert.ToUInt16 (first10.Substring (9' 1)));  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_UpdateFromCurrent,The following statement contains a magic number: if (_symbolSet != null) {  	_entity = _librarian.Entity (_symbolSet' Convert.ToUInt16 (second10.Substring (0' 1))' Convert.ToUInt16 (second10.Substring (1' 1)));  	if (_entity != null) {  		_entityType = _librarian.EntityType (_entity' Convert.ToUInt16 (second10.Substring (2' 1))' Convert.ToUInt16 (second10.Substring (3' 1)));  	}  	if (_entityType != null) {  		_entitySubType = _librarian.EntitySubType (_entityType' Convert.ToUInt16 (second10.Substring (4' 1))' Convert.ToUInt16 (second10.Substring (5' 1)));  		if (_entitySubType == null) {  			_entitySubType = _librarian.EntitySubType (_symbolSet' Convert.ToUInt16 (second10.Substring (4' 1))' Convert.ToUInt16 (second10.Substring (5' 1)));  		}  	}  	_modifierOne = _librarian.ModifierOne (_symbolSet' Convert.ToUInt16 (second10.Substring (6' 1))' Convert.ToUInt16 (second10.Substring (7' 1)));  	_modifierTwo = _librarian.ModifierTwo (_symbolSet' Convert.ToUInt16 (second10.Substring (8' 1))' Convert.ToUInt16 (second10.Substring (9' 1)));  	_legacySymbol = _librarian.LegacySymbol (_symbolSet' _entity' _entityType' _entitySubType' _modifierOne' _modifierTwo);  }  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_UpdateFromCurrent,The following statement contains a magic number: if (_symbolSet != null) {  	_entity = _librarian.Entity (_symbolSet' Convert.ToUInt16 (second10.Substring (0' 1))' Convert.ToUInt16 (second10.Substring (1' 1)));  	if (_entity != null) {  		_entityType = _librarian.EntityType (_entity' Convert.ToUInt16 (second10.Substring (2' 1))' Convert.ToUInt16 (second10.Substring (3' 1)));  	}  	if (_entityType != null) {  		_entitySubType = _librarian.EntitySubType (_entityType' Convert.ToUInt16 (second10.Substring (4' 1))' Convert.ToUInt16 (second10.Substring (5' 1)));  		if (_entitySubType == null) {  			_entitySubType = _librarian.EntitySubType (_symbolSet' Convert.ToUInt16 (second10.Substring (4' 1))' Convert.ToUInt16 (second10.Substring (5' 1)));  		}  	}  	_modifierOne = _librarian.ModifierOne (_symbolSet' Convert.ToUInt16 (second10.Substring (6' 1))' Convert.ToUInt16 (second10.Substring (7' 1)));  	_modifierTwo = _librarian.ModifierTwo (_symbolSet' Convert.ToUInt16 (second10.Substring (8' 1))' Convert.ToUInt16 (second10.Substring (9' 1)));  	_legacySymbol = _librarian.LegacySymbol (_symbolSet' _entity' _entityType' _entitySubType' _modifierOne' _modifierTwo);  }  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_UpdateFromCurrent,The following statement contains a magic number: if (_symbolSet != null) {  	_entity = _librarian.Entity (_symbolSet' Convert.ToUInt16 (second10.Substring (0' 1))' Convert.ToUInt16 (second10.Substring (1' 1)));  	if (_entity != null) {  		_entityType = _librarian.EntityType (_entity' Convert.ToUInt16 (second10.Substring (2' 1))' Convert.ToUInt16 (second10.Substring (3' 1)));  	}  	if (_entityType != null) {  		_entitySubType = _librarian.EntitySubType (_entityType' Convert.ToUInt16 (second10.Substring (4' 1))' Convert.ToUInt16 (second10.Substring (5' 1)));  		if (_entitySubType == null) {  			_entitySubType = _librarian.EntitySubType (_symbolSet' Convert.ToUInt16 (second10.Substring (4' 1))' Convert.ToUInt16 (second10.Substring (5' 1)));  		}  	}  	_modifierOne = _librarian.ModifierOne (_symbolSet' Convert.ToUInt16 (second10.Substring (6' 1))' Convert.ToUInt16 (second10.Substring (7' 1)));  	_modifierTwo = _librarian.ModifierTwo (_symbolSet' Convert.ToUInt16 (second10.Substring (8' 1))' Convert.ToUInt16 (second10.Substring (9' 1)));  	_legacySymbol = _librarian.LegacySymbol (_symbolSet' _entity' _entityType' _entitySubType' _modifierOne' _modifierTwo);  }  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_UpdateFromCurrent,The following statement contains a magic number: if (_symbolSet != null) {  	_entity = _librarian.Entity (_symbolSet' Convert.ToUInt16 (second10.Substring (0' 1))' Convert.ToUInt16 (second10.Substring (1' 1)));  	if (_entity != null) {  		_entityType = _librarian.EntityType (_entity' Convert.ToUInt16 (second10.Substring (2' 1))' Convert.ToUInt16 (second10.Substring (3' 1)));  	}  	if (_entityType != null) {  		_entitySubType = _librarian.EntitySubType (_entityType' Convert.ToUInt16 (second10.Substring (4' 1))' Convert.ToUInt16 (second10.Substring (5' 1)));  		if (_entitySubType == null) {  			_entitySubType = _librarian.EntitySubType (_symbolSet' Convert.ToUInt16 (second10.Substring (4' 1))' Convert.ToUInt16 (second10.Substring (5' 1)));  		}  	}  	_modifierOne = _librarian.ModifierOne (_symbolSet' Convert.ToUInt16 (second10.Substring (6' 1))' Convert.ToUInt16 (second10.Substring (7' 1)));  	_modifierTwo = _librarian.ModifierTwo (_symbolSet' Convert.ToUInt16 (second10.Substring (8' 1))' Convert.ToUInt16 (second10.Substring (9' 1)));  	_legacySymbol = _librarian.LegacySymbol (_symbolSet' _entity' _entityType' _entitySubType' _modifierOne' _modifierTwo);  }  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_UpdateFromCurrent,The following statement contains a magic number: if (_symbolSet != null) {  	_entity = _librarian.Entity (_symbolSet' Convert.ToUInt16 (second10.Substring (0' 1))' Convert.ToUInt16 (second10.Substring (1' 1)));  	if (_entity != null) {  		_entityType = _librarian.EntityType (_entity' Convert.ToUInt16 (second10.Substring (2' 1))' Convert.ToUInt16 (second10.Substring (3' 1)));  	}  	if (_entityType != null) {  		_entitySubType = _librarian.EntitySubType (_entityType' Convert.ToUInt16 (second10.Substring (4' 1))' Convert.ToUInt16 (second10.Substring (5' 1)));  		if (_entitySubType == null) {  			_entitySubType = _librarian.EntitySubType (_symbolSet' Convert.ToUInt16 (second10.Substring (4' 1))' Convert.ToUInt16 (second10.Substring (5' 1)));  		}  	}  	_modifierOne = _librarian.ModifierOne (_symbolSet' Convert.ToUInt16 (second10.Substring (6' 1))' Convert.ToUInt16 (second10.Substring (7' 1)));  	_modifierTwo = _librarian.ModifierTwo (_symbolSet' Convert.ToUInt16 (second10.Substring (8' 1))' Convert.ToUInt16 (second10.Substring (9' 1)));  	_legacySymbol = _librarian.LegacySymbol (_symbolSet' _entity' _entityType' _entitySubType' _modifierOne' _modifierTwo);  }  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_UpdateFromCurrent,The following statement contains a magic number: if (_symbolSet != null) {  	_entity = _librarian.Entity (_symbolSet' Convert.ToUInt16 (second10.Substring (0' 1))' Convert.ToUInt16 (second10.Substring (1' 1)));  	if (_entity != null) {  		_entityType = _librarian.EntityType (_entity' Convert.ToUInt16 (second10.Substring (2' 1))' Convert.ToUInt16 (second10.Substring (3' 1)));  	}  	if (_entityType != null) {  		_entitySubType = _librarian.EntitySubType (_entityType' Convert.ToUInt16 (second10.Substring (4' 1))' Convert.ToUInt16 (second10.Substring (5' 1)));  		if (_entitySubType == null) {  			_entitySubType = _librarian.EntitySubType (_symbolSet' Convert.ToUInt16 (second10.Substring (4' 1))' Convert.ToUInt16 (second10.Substring (5' 1)));  		}  	}  	_modifierOne = _librarian.ModifierOne (_symbolSet' Convert.ToUInt16 (second10.Substring (6' 1))' Convert.ToUInt16 (second10.Substring (7' 1)));  	_modifierTwo = _librarian.ModifierTwo (_symbolSet' Convert.ToUInt16 (second10.Substring (8' 1))' Convert.ToUInt16 (second10.Substring (9' 1)));  	_legacySymbol = _librarian.LegacySymbol (_symbolSet' _entity' _entityType' _entitySubType' _modifierOne' _modifierTwo);  }  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_UpdateFromCurrent,The following statement contains a magic number: if (_symbolSet != null) {  	_entity = _librarian.Entity (_symbolSet' Convert.ToUInt16 (second10.Substring (0' 1))' Convert.ToUInt16 (second10.Substring (1' 1)));  	if (_entity != null) {  		_entityType = _librarian.EntityType (_entity' Convert.ToUInt16 (second10.Substring (2' 1))' Convert.ToUInt16 (second10.Substring (3' 1)));  	}  	if (_entityType != null) {  		_entitySubType = _librarian.EntitySubType (_entityType' Convert.ToUInt16 (second10.Substring (4' 1))' Convert.ToUInt16 (second10.Substring (5' 1)));  		if (_entitySubType == null) {  			_entitySubType = _librarian.EntitySubType (_symbolSet' Convert.ToUInt16 (second10.Substring (4' 1))' Convert.ToUInt16 (second10.Substring (5' 1)));  		}  	}  	_modifierOne = _librarian.ModifierOne (_symbolSet' Convert.ToUInt16 (second10.Substring (6' 1))' Convert.ToUInt16 (second10.Substring (7' 1)));  	_modifierTwo = _librarian.ModifierTwo (_symbolSet' Convert.ToUInt16 (second10.Substring (8' 1))' Convert.ToUInt16 (second10.Substring (9' 1)));  	_legacySymbol = _librarian.LegacySymbol (_symbolSet' _entity' _entityType' _entitySubType' _modifierOne' _modifierTwo);  }  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_UpdateFromCurrent,The following statement contains a magic number: if (_symbolSet != null) {  	_entity = _librarian.Entity (_symbolSet' Convert.ToUInt16 (second10.Substring (0' 1))' Convert.ToUInt16 (second10.Substring (1' 1)));  	if (_entity != null) {  		_entityType = _librarian.EntityType (_entity' Convert.ToUInt16 (second10.Substring (2' 1))' Convert.ToUInt16 (second10.Substring (3' 1)));  	}  	if (_entityType != null) {  		_entitySubType = _librarian.EntitySubType (_entityType' Convert.ToUInt16 (second10.Substring (4' 1))' Convert.ToUInt16 (second10.Substring (5' 1)));  		if (_entitySubType == null) {  			_entitySubType = _librarian.EntitySubType (_symbolSet' Convert.ToUInt16 (second10.Substring (4' 1))' Convert.ToUInt16 (second10.Substring (5' 1)));  		}  	}  	_modifierOne = _librarian.ModifierOne (_symbolSet' Convert.ToUInt16 (second10.Substring (6' 1))' Convert.ToUInt16 (second10.Substring (7' 1)));  	_modifierTwo = _librarian.ModifierTwo (_symbolSet' Convert.ToUInt16 (second10.Substring (8' 1))' Convert.ToUInt16 (second10.Substring (9' 1)));  	_legacySymbol = _librarian.LegacySymbol (_symbolSet' _entity' _entityType' _entitySubType' _modifierOne' _modifierTwo);  }  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_UpdateFromCurrent,The following statement contains a magic number: if (_symbolSet != null) {  	_entity = _librarian.Entity (_symbolSet' Convert.ToUInt16 (second10.Substring (0' 1))' Convert.ToUInt16 (second10.Substring (1' 1)));  	if (_entity != null) {  		_entityType = _librarian.EntityType (_entity' Convert.ToUInt16 (second10.Substring (2' 1))' Convert.ToUInt16 (second10.Substring (3' 1)));  	}  	if (_entityType != null) {  		_entitySubType = _librarian.EntitySubType (_entityType' Convert.ToUInt16 (second10.Substring (4' 1))' Convert.ToUInt16 (second10.Substring (5' 1)));  		if (_entitySubType == null) {  			_entitySubType = _librarian.EntitySubType (_symbolSet' Convert.ToUInt16 (second10.Substring (4' 1))' Convert.ToUInt16 (second10.Substring (5' 1)));  		}  	}  	_modifierOne = _librarian.ModifierOne (_symbolSet' Convert.ToUInt16 (second10.Substring (6' 1))' Convert.ToUInt16 (second10.Substring (7' 1)));  	_modifierTwo = _librarian.ModifierTwo (_symbolSet' Convert.ToUInt16 (second10.Substring (8' 1))' Convert.ToUInt16 (second10.Substring (9' 1)));  	_legacySymbol = _librarian.LegacySymbol (_symbolSet' _entity' _entityType' _entitySubType' _modifierOne' _modifierTwo);  }  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_UpdateFromCurrent,The following statement contains a magic number: if (_symbolSet != null) {  	_entity = _librarian.Entity (_symbolSet' Convert.ToUInt16 (second10.Substring (0' 1))' Convert.ToUInt16 (second10.Substring (1' 1)));  	if (_entity != null) {  		_entityType = _librarian.EntityType (_entity' Convert.ToUInt16 (second10.Substring (2' 1))' Convert.ToUInt16 (second10.Substring (3' 1)));  	}  	if (_entityType != null) {  		_entitySubType = _librarian.EntitySubType (_entityType' Convert.ToUInt16 (second10.Substring (4' 1))' Convert.ToUInt16 (second10.Substring (5' 1)));  		if (_entitySubType == null) {  			_entitySubType = _librarian.EntitySubType (_symbolSet' Convert.ToUInt16 (second10.Substring (4' 1))' Convert.ToUInt16 (second10.Substring (5' 1)));  		}  	}  	_modifierOne = _librarian.ModifierOne (_symbolSet' Convert.ToUInt16 (second10.Substring (6' 1))' Convert.ToUInt16 (second10.Substring (7' 1)));  	_modifierTwo = _librarian.ModifierTwo (_symbolSet' Convert.ToUInt16 (second10.Substring (8' 1))' Convert.ToUInt16 (second10.Substring (9' 1)));  	_legacySymbol = _librarian.LegacySymbol (_symbolSet' _entity' _entityType' _entitySubType' _modifierOne' _modifierTwo);  }  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_UpdateFromCurrent,The following statement contains a magic number: if (_entity != null) {  	_entityType = _librarian.EntityType (_entity' Convert.ToUInt16 (second10.Substring (2' 1))' Convert.ToUInt16 (second10.Substring (3' 1)));  }  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_UpdateFromCurrent,The following statement contains a magic number: if (_entity != null) {  	_entityType = _librarian.EntityType (_entity' Convert.ToUInt16 (second10.Substring (2' 1))' Convert.ToUInt16 (second10.Substring (3' 1)));  }  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_UpdateFromCurrent,The following statement contains a magic number: _entityType = _librarian.EntityType (_entity' Convert.ToUInt16 (second10.Substring (2' 1))' Convert.ToUInt16 (second10.Substring (3' 1)));  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_UpdateFromCurrent,The following statement contains a magic number: _entityType = _librarian.EntityType (_entity' Convert.ToUInt16 (second10.Substring (2' 1))' Convert.ToUInt16 (second10.Substring (3' 1)));  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_UpdateFromCurrent,The following statement contains a magic number: if (_entityType != null) {  	_entitySubType = _librarian.EntitySubType (_entityType' Convert.ToUInt16 (second10.Substring (4' 1))' Convert.ToUInt16 (second10.Substring (5' 1)));  	if (_entitySubType == null) {  		_entitySubType = _librarian.EntitySubType (_symbolSet' Convert.ToUInt16 (second10.Substring (4' 1))' Convert.ToUInt16 (second10.Substring (5' 1)));  	}  }  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_UpdateFromCurrent,The following statement contains a magic number: if (_entityType != null) {  	_entitySubType = _librarian.EntitySubType (_entityType' Convert.ToUInt16 (second10.Substring (4' 1))' Convert.ToUInt16 (second10.Substring (5' 1)));  	if (_entitySubType == null) {  		_entitySubType = _librarian.EntitySubType (_symbolSet' Convert.ToUInt16 (second10.Substring (4' 1))' Convert.ToUInt16 (second10.Substring (5' 1)));  	}  }  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_UpdateFromCurrent,The following statement contains a magic number: if (_entityType != null) {  	_entitySubType = _librarian.EntitySubType (_entityType' Convert.ToUInt16 (second10.Substring (4' 1))' Convert.ToUInt16 (second10.Substring (5' 1)));  	if (_entitySubType == null) {  		_entitySubType = _librarian.EntitySubType (_symbolSet' Convert.ToUInt16 (second10.Substring (4' 1))' Convert.ToUInt16 (second10.Substring (5' 1)));  	}  }  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_UpdateFromCurrent,The following statement contains a magic number: if (_entityType != null) {  	_entitySubType = _librarian.EntitySubType (_entityType' Convert.ToUInt16 (second10.Substring (4' 1))' Convert.ToUInt16 (second10.Substring (5' 1)));  	if (_entitySubType == null) {  		_entitySubType = _librarian.EntitySubType (_symbolSet' Convert.ToUInt16 (second10.Substring (4' 1))' Convert.ToUInt16 (second10.Substring (5' 1)));  	}  }  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_UpdateFromCurrent,The following statement contains a magic number: _entitySubType = _librarian.EntitySubType (_entityType' Convert.ToUInt16 (second10.Substring (4' 1))' Convert.ToUInt16 (second10.Substring (5' 1)));  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_UpdateFromCurrent,The following statement contains a magic number: _entitySubType = _librarian.EntitySubType (_entityType' Convert.ToUInt16 (second10.Substring (4' 1))' Convert.ToUInt16 (second10.Substring (5' 1)));  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_UpdateFromCurrent,The following statement contains a magic number: if (_entitySubType == null) {  	_entitySubType = _librarian.EntitySubType (_symbolSet' Convert.ToUInt16 (second10.Substring (4' 1))' Convert.ToUInt16 (second10.Substring (5' 1)));  }  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_UpdateFromCurrent,The following statement contains a magic number: if (_entitySubType == null) {  	_entitySubType = _librarian.EntitySubType (_symbolSet' Convert.ToUInt16 (second10.Substring (4' 1))' Convert.ToUInt16 (second10.Substring (5' 1)));  }  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_UpdateFromCurrent,The following statement contains a magic number: _entitySubType = _librarian.EntitySubType (_symbolSet' Convert.ToUInt16 (second10.Substring (4' 1))' Convert.ToUInt16 (second10.Substring (5' 1)));  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_UpdateFromCurrent,The following statement contains a magic number: _entitySubType = _librarian.EntitySubType (_symbolSet' Convert.ToUInt16 (second10.Substring (4' 1))' Convert.ToUInt16 (second10.Substring (5' 1)));  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_UpdateFromCurrent,The following statement contains a magic number: _modifierOne = _librarian.ModifierOne (_symbolSet' Convert.ToUInt16 (second10.Substring (6' 1))' Convert.ToUInt16 (second10.Substring (7' 1)));  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_UpdateFromCurrent,The following statement contains a magic number: _modifierOne = _librarian.ModifierOne (_symbolSet' Convert.ToUInt16 (second10.Substring (6' 1))' Convert.ToUInt16 (second10.Substring (7' 1)));  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_UpdateFromCurrent,The following statement contains a magic number: _modifierTwo = _librarian.ModifierTwo (_symbolSet' Convert.ToUInt16 (second10.Substring (8' 1))' Convert.ToUInt16 (second10.Substring (9' 1)));  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_UpdateFromCurrent,The following statement contains a magic number: _modifierTwo = _librarian.ModifierTwo (_symbolSet' Convert.ToUInt16 (second10.Substring (8' 1))' Convert.ToUInt16 (second10.Substring (9' 1)));  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_UpdateFromLegacy,The following statement contains a magic number: if (_legacySymbol != null) {  	_affiliation = _librarian.AffiliationByLegacyCode (_legacySIDC.Substring (1' 1)' _dimension.ID);  	if (_affiliation != null) {  		_context = _librarian.Context (_affiliation.ContextID);  		_standardIdentity = _librarian.StandardIdentity (_affiliation.StandardIdentityID);  		_sig = _librarian.StandardIdentityGroup (_standardIdentity);  	}  	_status = _librarian.Status (_legacySIDC.Substring (3' 1)' _legacySIDC.Substring (0' 1));  	_hqTFDummy = _librarian.HQTFDummy (_legacySIDC.Substring (10' 1));  	_amplifier = _librarian.Amplifier (_legacySIDC.Substring (11' 1)' _legacySIDC.Substring (0' 1));  	if (_amplifier != null) {  		_amplifierGroup = _librarian.AmplifierGroup (_amplifier);  	}  	_entity = _librarian.Entity (_symbolSet' _legacySymbol.EntityID);  	_entityType = _librarian.EntityType (_entity' _legacySymbol.EntityTypeID);  	_entitySubType = _librarian.EntitySubType (_symbolSet' _entityType' _legacySymbol.EntitySubTypeID);  	_modifierOne = _librarian.ModifierOne (_symbolSet' _legacySymbol.ModifierOneID);  	_modifierTwo = _librarian.ModifierTwo (_symbolSet' _legacySymbol.ModifierTwoID);  }  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_UpdateFromLegacy,The following statement contains a magic number: if (_legacySymbol != null) {  	_affiliation = _librarian.AffiliationByLegacyCode (_legacySIDC.Substring (1' 1)' _dimension.ID);  	if (_affiliation != null) {  		_context = _librarian.Context (_affiliation.ContextID);  		_standardIdentity = _librarian.StandardIdentity (_affiliation.StandardIdentityID);  		_sig = _librarian.StandardIdentityGroup (_standardIdentity);  	}  	_status = _librarian.Status (_legacySIDC.Substring (3' 1)' _legacySIDC.Substring (0' 1));  	_hqTFDummy = _librarian.HQTFDummy (_legacySIDC.Substring (10' 1));  	_amplifier = _librarian.Amplifier (_legacySIDC.Substring (11' 1)' _legacySIDC.Substring (0' 1));  	if (_amplifier != null) {  		_amplifierGroup = _librarian.AmplifierGroup (_amplifier);  	}  	_entity = _librarian.Entity (_symbolSet' _legacySymbol.EntityID);  	_entityType = _librarian.EntityType (_entity' _legacySymbol.EntityTypeID);  	_entitySubType = _librarian.EntitySubType (_symbolSet' _entityType' _legacySymbol.EntitySubTypeID);  	_modifierOne = _librarian.ModifierOne (_symbolSet' _legacySymbol.ModifierOneID);  	_modifierTwo = _librarian.ModifierTwo (_symbolSet' _legacySymbol.ModifierTwoID);  }  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_UpdateFromLegacy,The following statement contains a magic number: if (_legacySymbol != null) {  	_affiliation = _librarian.AffiliationByLegacyCode (_legacySIDC.Substring (1' 1)' _dimension.ID);  	if (_affiliation != null) {  		_context = _librarian.Context (_affiliation.ContextID);  		_standardIdentity = _librarian.StandardIdentity (_affiliation.StandardIdentityID);  		_sig = _librarian.StandardIdentityGroup (_standardIdentity);  	}  	_status = _librarian.Status (_legacySIDC.Substring (3' 1)' _legacySIDC.Substring (0' 1));  	_hqTFDummy = _librarian.HQTFDummy (_legacySIDC.Substring (10' 1));  	_amplifier = _librarian.Amplifier (_legacySIDC.Substring (11' 1)' _legacySIDC.Substring (0' 1));  	if (_amplifier != null) {  		_amplifierGroup = _librarian.AmplifierGroup (_amplifier);  	}  	_entity = _librarian.Entity (_symbolSet' _legacySymbol.EntityID);  	_entityType = _librarian.EntityType (_entity' _legacySymbol.EntityTypeID);  	_entitySubType = _librarian.EntitySubType (_symbolSet' _entityType' _legacySymbol.EntitySubTypeID);  	_modifierOne = _librarian.ModifierOne (_symbolSet' _legacySymbol.ModifierOneID);  	_modifierTwo = _librarian.ModifierTwo (_symbolSet' _legacySymbol.ModifierTwoID);  }  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_UpdateFromLegacy,The following statement contains a magic number: _status = _librarian.Status (_legacySIDC.Substring (3' 1)' _legacySIDC.Substring (0' 1));  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_UpdateFromLegacy,The following statement contains a magic number: _hqTFDummy = _librarian.HQTFDummy (_legacySIDC.Substring (10' 1));  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_UpdateFromLegacy,The following statement contains a magic number: _amplifier = _librarian.Amplifier (_legacySIDC.Substring (11' 1)' _legacySIDC.Substring (0' 1));  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_SetInvalidSymbolProps,The following statement contains a magic number: _symbolSet = _librarian.SymbolSet (9' 8);  
Magic Number,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_SetInvalidSymbolProps,The following statement contains a magic number: _symbolSet = _librarian.SymbolSet (9' 8);  
Magic Number,JointMilitarySymbologyLibrary,Librarian,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Librarian.cs,CodeToShort,The following statement contains a magic number: if (code.DigitOne == 0)  	return code.DigitTwo;  else  	return (ushort)(code.DigitOne * 10 + code.DigitTwo);  
Magic Number,JointMilitarySymbologyLibrary,Librarian,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Librarian.cs,CodeToShort,The following statement contains a magic number: return (ushort)(code.DigitOne * 10 + code.DigitTwo);  
Magic Number,JointMilitarySymbologyLibrary,Librarian,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Librarian.cs,InitializeNLog,The following statement contains a magic number: wrapper.QueueLimit = 5000;  
Magic Number,JointMilitarySymbologyLibrary,Librarian,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Librarian.cs,LogConversionResult,The following statement contains a magic number: if (_logConversion) {  	string s = Convert.ToString (0 - _statusFlag' 2);  	char[] bits = s.PadLeft (17' '0').ToCharArray ();  	Array.Reverse (bits);  	logger.Info ("----------------------------");  	logger.Info ("Converting: " + converting + " (" + _statusFlag + ")");  	for (int i = 0; i < 17; i++) {  		if (bits [i] == '1') {  			logger.Info (_statusMessages [i]);  		}  	}  	logger.Info ("----------------------------");  }  
Magic Number,JointMilitarySymbologyLibrary,Librarian,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Librarian.cs,LogConversionResult,The following statement contains a magic number: if (_logConversion) {  	string s = Convert.ToString (0 - _statusFlag' 2);  	char[] bits = s.PadLeft (17' '0').ToCharArray ();  	Array.Reverse (bits);  	logger.Info ("----------------------------");  	logger.Info ("Converting: " + converting + " (" + _statusFlag + ")");  	for (int i = 0; i < 17; i++) {  		if (bits [i] == '1') {  			logger.Info (_statusMessages [i]);  		}  	}  	logger.Info ("----------------------------");  }  
Magic Number,JointMilitarySymbologyLibrary,Librarian,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Librarian.cs,LogConversionResult,The following statement contains a magic number: if (_logConversion) {  	string s = Convert.ToString (0 - _statusFlag' 2);  	char[] bits = s.PadLeft (17' '0').ToCharArray ();  	Array.Reverse (bits);  	logger.Info ("----------------------------");  	logger.Info ("Converting: " + converting + " (" + _statusFlag + ")");  	for (int i = 0; i < 17; i++) {  		if (bits [i] == '1') {  			logger.Info (_statusMessages [i]);  		}  	}  	logger.Info ("----------------------------");  }  
Magic Number,JointMilitarySymbologyLibrary,Librarian,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Librarian.cs,LogConversionResult,The following statement contains a magic number: for (int i = 0; i < 17; i++) {  	if (bits [i] == '1') {  		logger.Info (_statusMessages [i]);  	}  }  
Magic Number,JointMilitarySymbologyLibrary,Librarian,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Librarian.cs,Context,The following statement contains a magic number: _statusFlag -= 2;  
Magic Number,JointMilitarySymbologyLibrary,Librarian,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Librarian.cs,Context,The following statement contains a magic number: _statusFlag -= 2;  
Magic Number,JointMilitarySymbologyLibrary,Librarian,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Librarian.cs,Dimension,The following statement contains a magic number: _statusFlag -= 4;  
Magic Number,JointMilitarySymbologyLibrary,Librarian,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Librarian.cs,DimensionBySymbolSet,The following statement contains a magic number: _statusFlag -= 4;  
Magic Number,JointMilitarySymbologyLibrary,Librarian,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Librarian.cs,DimensionByLegacyCode,The following statement contains a magic number: _statusFlag -= 4;  
Magic Number,JointMilitarySymbologyLibrary,Librarian,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Librarian.cs,StandardIdentity,The following statement contains a magic number: _statusFlag -= 8;  
Magic Number,JointMilitarySymbologyLibrary,Librarian,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Librarian.cs,StandardIdentity,The following statement contains a magic number: _statusFlag -= 8;  
Magic Number,JointMilitarySymbologyLibrary,Librarian,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Librarian.cs,SymbolSet,The following statement contains a magic number: _statusFlag -= 16;  
Magic Number,JointMilitarySymbologyLibrary,Librarian,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Librarian.cs,SymbolSet,The following statement contains a magic number: _statusFlag -= 16;  
Magic Number,JointMilitarySymbologyLibrary,Librarian,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Librarian.cs,Status,The following statement contains a magic number: _statusFlag -= 32;  
Magic Number,JointMilitarySymbologyLibrary,Librarian,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Librarian.cs,HQTFDummy,The following statement contains a magic number: _statusFlag -= 64;  
Magic Number,JointMilitarySymbologyLibrary,Librarian,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Librarian.cs,AmplifierGroup,The following statement contains a magic number: _statusFlag -= 128;  
Magic Number,JointMilitarySymbologyLibrary,Librarian,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Librarian.cs,AmplifierGroup,The following statement contains a magic number: _statusFlag -= 128;  
Magic Number,JointMilitarySymbologyLibrary,Librarian,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Librarian.cs,Amplifier,The following statement contains a magic number: _statusFlag -= 256;  
Magic Number,JointMilitarySymbologyLibrary,Librarian,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Librarian.cs,Affiliation,The following statement contains a magic number: _statusFlag -= 512;  
Magic Number,JointMilitarySymbologyLibrary,Librarian,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Librarian.cs,AffiliationByLegacyCode,The following statement contains a magic number: _statusFlag -= 512;  
Magic Number,JointMilitarySymbologyLibrary,Librarian,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Librarian.cs,Entity,The following statement contains a magic number: _statusFlag -= 2048;  
Magic Number,JointMilitarySymbologyLibrary,Librarian,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Librarian.cs,Entity,The following statement contains a magic number: _statusFlag -= 2048;  
Magic Number,JointMilitarySymbologyLibrary,Librarian,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Librarian.cs,EntityType,The following statement contains a magic number: _statusFlag -= 4096;  
Magic Number,JointMilitarySymbologyLibrary,Librarian,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Librarian.cs,EntityType,The following statement contains a magic number: _statusFlag -= 4096;  
Magic Number,JointMilitarySymbologyLibrary,Librarian,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Librarian.cs,EntitySubType,The following statement contains a magic number: _statusFlag -= 8192;  
Magic Number,JointMilitarySymbologyLibrary,Librarian,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Librarian.cs,EntitySubType,The following statement contains a magic number: _statusFlag -= 8192;  
Magic Number,JointMilitarySymbologyLibrary,Librarian,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Librarian.cs,ModifierOne,The following statement contains a magic number: _statusFlag -= 16384;  
Magic Number,JointMilitarySymbologyLibrary,Librarian,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Librarian.cs,ModifierOne,The following statement contains a magic number: _statusFlag -= 16384;  
Magic Number,JointMilitarySymbologyLibrary,Librarian,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Librarian.cs,ModifierTwo,The following statement contains a magic number: _statusFlag -= 32768;  
Magic Number,JointMilitarySymbologyLibrary,Librarian,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Librarian.cs,ModifierTwo,The following statement contains a magic number: _statusFlag -= 32768;  
Magic Number,JointMilitarySymbologyLibrary,Librarian,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Librarian.cs,LegacySymbol,The following statement contains a magic number: if (retObj == null) {  	_statusFlag -= 4;  	// Can't find a Dimension  	_statusFlag -= 16;  	// Can't find a SymbolSet  	_statusFlag -= 65536;  	// Can't find a LegacySymbol  }  
Magic Number,JointMilitarySymbologyLibrary,Librarian,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Librarian.cs,LegacySymbol,The following statement contains a magic number: if (retObj == null) {  	_statusFlag -= 4;  	// Can't find a Dimension  	_statusFlag -= 16;  	// Can't find a SymbolSet  	_statusFlag -= 65536;  	// Can't find a LegacySymbol  }  
Magic Number,JointMilitarySymbologyLibrary,Librarian,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Librarian.cs,LegacySymbol,The following statement contains a magic number: if (retObj == null) {  	_statusFlag -= 4;  	// Can't find a Dimension  	_statusFlag -= 16;  	// Can't find a SymbolSet  	_statusFlag -= 65536;  	// Can't find a LegacySymbol  }  
Magic Number,JointMilitarySymbologyLibrary,Librarian,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Librarian.cs,LegacySymbol,The following statement contains a magic number: _statusFlag -= 4;  
Magic Number,JointMilitarySymbologyLibrary,Librarian,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Librarian.cs,LegacySymbol,The following statement contains a magic number: _statusFlag -= 16;  
Magic Number,JointMilitarySymbologyLibrary,Librarian,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Librarian.cs,LegacySymbol,The following statement contains a magic number: _statusFlag -= 65536;  
Magic Number,JointMilitarySymbologyLibrary,Librarian,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Librarian.cs,LegacySymbol,The following statement contains a magic number: if (symbolSet != null) {  	if (symbolSet.LegacySymbols != null) {  		int match = 0;  		foreach (SymbolSetLegacySymbol lObj in symbolSet.LegacySymbols) {  			if (entity != null) {  				if (lObj.EntityID != "NA") {  					if (lObj.EntityID == entity.ID)  						match++;  				}  			} else if (lObj.EntityID == "NA")  				match++;  			if (entityType != null) {  				if (lObj.EntityTypeID != "NA") {  					if (lObj.EntityTypeID == entityType.ID)  						match++;  				}  			} else if (lObj.EntityTypeID == "NA")  				match++;  			if (entitySubType != null) {  				if (lObj.EntitySubTypeID != "NA") {  					if (lObj.EntitySubTypeID == entitySubType.ID)  						match++;  				}  			} else if (lObj.EntitySubTypeID == "NA")  				match++;  			if (modifierOne != null) {  				if (lObj.ModifierOneID != "NA") {  					if (lObj.ModifierOneID == modifierOne.ID)  						match++;  				}  			} else if (lObj.ModifierOneID == "NA")  				match++;  			if (modifierTwo != null) {  				if (lObj.ModifierTwoID != "NA") {  					if (lObj.ModifierTwoID == modifierTwo.ID)  						match++;  				}  			} else if (lObj.ModifierTwoID == "NA")  				match++;  			if (match == 5) {  				return lObj;  			}  			match = 0;  		}  	}  }  
Magic Number,JointMilitarySymbologyLibrary,Librarian,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Librarian.cs,LegacySymbol,The following statement contains a magic number: if (symbolSet.LegacySymbols != null) {  	int match = 0;  	foreach (SymbolSetLegacySymbol lObj in symbolSet.LegacySymbols) {  		if (entity != null) {  			if (lObj.EntityID != "NA") {  				if (lObj.EntityID == entity.ID)  					match++;  			}  		} else if (lObj.EntityID == "NA")  			match++;  		if (entityType != null) {  			if (lObj.EntityTypeID != "NA") {  				if (lObj.EntityTypeID == entityType.ID)  					match++;  			}  		} else if (lObj.EntityTypeID == "NA")  			match++;  		if (entitySubType != null) {  			if (lObj.EntitySubTypeID != "NA") {  				if (lObj.EntitySubTypeID == entitySubType.ID)  					match++;  			}  		} else if (lObj.EntitySubTypeID == "NA")  			match++;  		if (modifierOne != null) {  			if (lObj.ModifierOneID != "NA") {  				if (lObj.ModifierOneID == modifierOne.ID)  					match++;  			}  		} else if (lObj.ModifierOneID == "NA")  			match++;  		if (modifierTwo != null) {  			if (lObj.ModifierTwoID != "NA") {  				if (lObj.ModifierTwoID == modifierTwo.ID)  					match++;  			}  		} else if (lObj.ModifierTwoID == "NA")  			match++;  		if (match == 5) {  			return lObj;  		}  		match = 0;  	}  }  
Magic Number,JointMilitarySymbologyLibrary,Librarian,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Librarian.cs,LegacySymbol,The following statement contains a magic number: foreach (SymbolSetLegacySymbol lObj in symbolSet.LegacySymbols) {  	if (entity != null) {  		if (lObj.EntityID != "NA") {  			if (lObj.EntityID == entity.ID)  				match++;  		}  	} else if (lObj.EntityID == "NA")  		match++;  	if (entityType != null) {  		if (lObj.EntityTypeID != "NA") {  			if (lObj.EntityTypeID == entityType.ID)  				match++;  		}  	} else if (lObj.EntityTypeID == "NA")  		match++;  	if (entitySubType != null) {  		if (lObj.EntitySubTypeID != "NA") {  			if (lObj.EntitySubTypeID == entitySubType.ID)  				match++;  		}  	} else if (lObj.EntitySubTypeID == "NA")  		match++;  	if (modifierOne != null) {  		if (lObj.ModifierOneID != "NA") {  			if (lObj.ModifierOneID == modifierOne.ID)  				match++;  		}  	} else if (lObj.ModifierOneID == "NA")  		match++;  	if (modifierTwo != null) {  		if (lObj.ModifierTwoID != "NA") {  			if (lObj.ModifierTwoID == modifierTwo.ID)  				match++;  		}  	} else if (lObj.ModifierTwoID == "NA")  		match++;  	if (match == 5) {  		return lObj;  	}  	match = 0;  }  
Magic Number,JointMilitarySymbologyLibrary,Librarian,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Librarian.cs,LegacySymbol,The following statement contains a magic number: if (match == 5) {  	return lObj;  }  
Magic Number,JointMilitarySymbologyLibrary,Librarian,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Librarian.cs,LegacySymbol,The following statement contains a magic number: _statusFlag -= 65536;  
Magic Number,JointMilitarySymbologyLibrary,Librarian,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Librarian.cs,MakeSymbol,The following statement contains a magic number: if (legacySIDC.Length == 15) {  	legacyStandard = legacyStandard.ToUpper ();  	legacySIDC = legacySIDC.Replace ('*'' '-');  	legacySIDC = legacySIDC.ToUpper ();  	s = new Symbol (this' legacyStandard' legacySIDC' _drawColoredOCABars' _drawCivilianFrames);  	if (s.SymbolStatus == SymbolStatusEnum.statusEnumInvalid) {  		logger.Warn ("SIDC " + legacySIDC + " is an invalid symbol.");  		s = null;  	}  } else {  	logger.Error ("SIDC " + legacySIDC + " is not 15 characters in length.");  }  
Missing Default,JointMilitarySymbologyLibrary,AmplifierExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\AmplifierExport.cs,BuildAmplifierItemName,The following switch statement is missing a default case: switch (amplifierGroup.AmplifierGroupCode) {  case 1:  case 2:  	category = "Echelon";  	break;  case 3:  case 4:  case 5:  	category = "Mobility";  	break;  case 6:  	category = "Auxiliary Equipment";  	break;  }  
Missing Default,JointMilitarySymbologyLibrary,AmplifierExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\AmplifierExport.cs,BuildAmplifierItemTags,The following switch statement is missing a default case: switch (amplifierGroup.AmplifierGroupCode) {  case 1:  case 2:  	category = "Echelon;";  	iType = "ECHELON";  	break;  case 3:  case 4:  case 5:  	category = "Mobility;";  	iType = "MOBILITY";  	break;  case 6:  	category = "Auxiliary Equipment;";  	iType = "AUXILIARY";  	break;  }  
Missing Default,JointMilitarySymbologyLibrary,AmplifierExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\AmplifierExport.cs,BuildSIDCKey,The following switch statement is missing a default case: switch (amplifierGroup.AmplifierGroupCode) {  case 1:  case 2:  	key = key + amplifier.LegacyModifierCode [0].Value;  	break;  case 3:  case 4:  case 5:  	key = key + "M" + amplifier.LegacyModifierCode [0].Value;  	break;  case 6:  	key = key + "N" + amplifier.LegacyModifierCode [0].Value;  	break;  }  
Missing Default,JointMilitarySymbologyLibrary,ConfigHelper,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ConfigHelper.cs,_findIt,The following switch statement is missing a default case: switch (findThis) {  case FindEnum.FindAuxiliaryEquipment:  	foundIt = inThis.AuxiliaryEquipment;  	break;  case FindEnum.FindEchelons:  	foundIt = inThis.Echelons;  	break;  case FindEnum.FindEntities:  	if (inThis.Entities != null) {  		foundIt = _splitAndSearch (inThis.Entities' forThis);  	}  	break;  case FindEnum.FindFrames:  	if (inThis.Frames != null) {  		foundIt = _splitAndSearch (inThis.Frames' forThis);  	}  	break;  case FindEnum.FindHQTFFD:  	foundIt = inThis.HQTFFD;  	break;  case FindEnum.FindMobilities:  	foundIt = inThis.Mobilities;  	break;  case FindEnum.FindModifierOnes:  	if (inThis.ModifierOnes != null) {  		foundIt = _splitAndSearch (inThis.ModifierOnes' forThis);  	}  	break;  case FindEnum.FindModifierTwos:  	if (inThis.ModifierTwos != null) {  		foundIt = _splitAndSearch (inThis.ModifierTwos' forThis);  	}  	break;  case FindEnum.FindSpecials:  	foundIt = inThis.Specials;  	break;  case FindEnum.FindOCA:  	foundIt = inThis.OCA;  	break;  case FindEnum.Find2525C:  	foundIt = inThis.LegacyStandard == "2525C";  	break;  case FindEnum.Find2525BC2:  	foundIt = inThis.LegacyStandard == "2525BC2";  	break;  }  
Missing Default,JointMilitarySymbologyLibrary,ConfigHelper,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ConfigHelper.cs,GetPath,The following switch statement is missing a default case: switch (ofType) {  case FindEnum.FindAuxiliaryEquipment:  	result = _getPath ("JMSML_AUXILIARY"' _basePaths);  	break;  case FindEnum.FindEchelons:  	result = _getPath ("JMSML_ECHELONS"' _basePaths);  	break;  case FindEnum.FindEntities:  	result = _getPath (getWhat' _entityPaths);  	break;  case FindEnum.FindFrames:  	result = _getPath (getWhat' _framePaths);  	break;  case FindEnum.FindHQTFFD:  	result = _getPath ("JMSML_HQTFDUMMIES"' _basePaths);  	break;  case FindEnum.FindMobilities:  	result = _getPath ("JMSML_MOBILITIES"' _basePaths);  	break;  case FindEnum.FindModifierOnes:  	result = _getPath (getWhat' _modifierOnePaths);  	break;  case FindEnum.FindModifierTwos:  	result = _getPath (getWhat' _modifierTwoPaths);  	break;  case FindEnum.FindSpecials:  	result = _getPath ("JMSML_SPECIALS"' _basePaths);  	break;  case FindEnum.FindOCA:  	result = _getPath ("JMSML_OCA"' _basePaths);  	break;  case FindEnum.Find2525C:  	result = _getPath ("JMSML_2525C"' _basePaths);  	break;  case FindEnum.Find2525BC2:  	result = _getPath ("JMSML_2525BC2"' _basePaths);  	break;  }  
Missing Default,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_writeEntity,The following switch statement is missing a default case: switch (mode) {  case 0:  	w.WriteLine ("</Entity>");  	break;  case 1:  	w.WriteLine ("</EntityType>");  	w.WriteLine ("</EntityTypes>");  	w.WriteLine ("</Entity>");  	break;  case 2:  	w.WriteLine ("</EntitySubTypes>");  	w.WriteLine ("</EntityType>");  	w.WriteLine ("</EntityTypes>");  	w.WriteLine ("</Entity>");  	break;  }  
Missing Default,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_writeEntityType,The following switch statement is missing a default case: switch (mode) {  case 0:  	w.WriteLine ("<EntityTypes>");  	break;  case 1:  	w.WriteLine ("</EntityType>");  	break;  case 2:  	w.WriteLine ("</EntitySubTypes>");  	w.WriteLine ("</EntityType>");  	break;  }  
Missing Default,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_writeEntitySubType,The following switch statement is missing a default case: switch (mode) {  case 1:  	w.WriteLine ("<EntitySubTypes>");  	break;  }  
Missing Default,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,_importCSV,The following switch statement is missing a default case: switch (mode) {  case 1:  	w.WriteLine ("</EntityType>");  	w.WriteLine ("</EntityTypes>");  	break;  case 2:  	w.WriteLine ("</EntitySubTypes>");  	w.WriteLine ("</EntityType>");  	w.WriteLine ("</EntityTypes>");  	break;  }  
Missing Default,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,Export,The following switch statement is missing a default case: switch (exportType) {  // Based on the type of export' create instances of the  // appropriate helper class(es).  case ETLExportEnum.ETLExportSimple:  	entityExporter = new SimpleEntityExport (_configHelper);  	modifierExporter = new SimpleModifierExport (_configHelper);  	break;  case ETLExportEnum.ETLExportDomain:  	entityExporter = new DomainEntityExport (_configHelper);  	modifierExporter = new DomainModifierExport (_configHelper);  	break;  case ETLExportEnum.ETLExportImage:  	entityExporter = new ImageEntityExport (_configHelper' omitSource' omitLegacy);  	modifierExporter = new ImageModifierExport (_configHelper' omitSource' true);  	// Suppress legacy tag  	break;  }  
Missing Default,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,ExportAmplifiers,The following switch statement is missing a default case: switch (exportType) {  case ETLExportEnum.ETLExportDomain:  	amplifierExporter = new DomainAmplifierExport (_configHelper);  	break;  case ETLExportEnum.ETLExportImage:  	amplifierExporter = new ImageAmplifierExport (_configHelper' omitSource' omitLegacy);  	break;  }  
Missing Default,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,ExportFrames,The following switch statement is missing a default case: switch (exportType) {  case ETLExportEnum.ETLExportDomain:  	frameExporter = new DomainFrameExport (_configHelper);  	break;  case ETLExportEnum.ETLExportImage:  	frameExporter = new ImageFrameExport (_configHelper' omitSource' omitLegacy);  	break;  }  
Missing Default,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,ExportHQTFFD,The following switch statement is missing a default case: switch (exportType) {  case ETLExportEnum.ETLExportDomain:  	hqTFFDExporter = new DomainHQTFFDExport (_configHelper);  	break;  case ETLExportEnum.ETLExportImage:  	hqTFFDExporter = new ImageHQTFFDExport (_configHelper' omitSource' omitLegacy);  	break;  }  
Missing Default,JointMilitarySymbologyLibrary,ETL,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ETL.cs,ExportOCA,The following switch statement is missing a default case: switch (exportType) {  case ETLExportEnum.ETLExportDomain:  	ocaExporter = new DomainOCAExport (_configHelper);  	break;  case ETLExportEnum.ETLExportImage:  	ocaExporter = new ImageOCAExport (_configHelper' omitSource' omitLegacy);  	break;  }  
Missing Default,JointMilitarySymbologyLibrary,EntityExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\EntityExport.cs,GrabGraphic,The following switch statement is missing a default case: switch (gSuffix) {  case "_0":  	graphic = uGraphic;  	break;  case "_1":  	graphic = fGraphic;  	break;  case "_2":  	graphic = nGraphic;  	break;  case "_3":  	graphic = hGraphic;  	break;  }  
Missing Default,JointMilitarySymbologyLibrary,ImageAmplifierExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ImageAmplifierExport.cs,Line,The following switch statement is missing a default case: switch (amplifierGroup.AmplifierGroupCode) {  case 1:  case 2:  	find = FindEnum.FindEchelons;  	category = "Echelon";  	break;  case 3:  case 4:  case 5:  	find = FindEnum.FindMobilities;  	category = "Mobility";  	break;  case 6:  	find = FindEnum.FindAuxiliaryEquipment;  	category = "Auxiliary Equipment";  	break;  }  
Missing Default,JointMilitarySymbologyLibrary,ImageModifierExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ImageModifierExport.cs,Line,The following switch statement is missing a default case: switch (modNumber) {  case "1":  	graphicPath = _configHelper.GetPath (ss.ID' FindEnum.FindModifierOnes);  	break;  case "2":  	graphicPath = _configHelper.GetPath (ss.ID' FindEnum.FindModifierTwos);  	break;  }  
Missing Default,JointMilitarySymbologyLibrary,ModifierExport,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\ModifierExport.cs,BuildModifierItemTags,The following switch statement is missing a default case: switch (modNumber) {  case "1":  	path = _configHelper.GetPath (ss.ID' FindEnum.FindModifierOnes' true);  	typ = "MOD1";  	break;  case "2":  	path = _configHelper.GetPath (ss.ID' FindEnum.FindModifierTwos' true);  	typ = "MOD2";  	break;  }  
Missing Default,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,Symbol,The following switch statement is missing a default case: switch (_symbolStat) {  case SymbolStatusEnum.statusEnumOld:  	_BuildLegacySIDC ();  	break;  case SymbolStatusEnum.statusEnumNew:  	_legacySIDC = _blankLegacySIDC;  	break;  }  
Missing Default,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,Symbol,The following switch statement is missing a default case: switch (_symbolStat) {  case SymbolStatusEnum.statusEnumOld:  	_BuildSIDC ();  	break;  case SymbolStatusEnum.statusEnumRetired:  	_sidc.PartAUInt = SIDC.RETIRED.PartAUInt;  	_sidc.PartBUInt = SIDC.RETIRED.PartBUInt;  	break;  }  
Missing Default,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_BuildEntityTypeGraphics,The following switch statement is missing a default case: switch (_sig.ID) {  case "SIG_UNKNOWN":  	graphic = _entityType.CloverGraphic;  	break;  case "SIG_FRIEND":  	graphic = _entityType.RectangleGraphic;  	break;  case "SIG_NEUTRAL":  	graphic = _entityType.SquareGraphic;  	break;  case "SIG_HOSTILE":  	graphic = _entityType.DiamondGraphic;  	break;  }  
Missing Default,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_BuildEntityTypeGraphics,The following switch statement is missing a default case: switch (_sig.ID) {  case "SIG_UNKNOWN":  	graphic = _entity.CloverGraphic;  	break;  case "SIG_FRIEND":  	graphic = _entity.RectangleGraphic;  	break;  case "SIG_NEUTRAL":  	graphic = _entity.SquareGraphic;  	break;  case "SIG_HOSTILE":  	graphic = _entity.DiamondGraphic;  	break;  }  
Missing Default,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_BuildGraphics,The following switch statement is missing a default case: switch (_sig.ID) {  case "SIG_UNKNOWN":  	graphic = _entitySubType.CloverGraphic;  	break;  case "SIG_FRIEND":  	graphic = _entitySubType.RectangleGraphic;  	break;  case "SIG_NEUTRAL":  	graphic = _entitySubType.SquareGraphic;  	break;  case "SIG_HOSTILE":  	graphic = _entitySubType.DiamondGraphic;  	break;  }  
Missing Default,JointMilitarySymbologyLibrary,Symbol,F:\newReposMay17\Esri_joint-military-symbology-xml\source\JointMilitarySymbologyLibraryCS\Symbol.cs,_BuildGraphics,The following switch statement is missing a default case: switch (_amplifierGroup.AmplifierGroupCode) {  case 1:  case 2:  	path = _configHelper.GetPath (""' FindEnum.FindEchelons);  	break;  case 3:  case 4:  case 5:  	path = _configHelper.GetPath (""' FindEnum.FindMobilities);  	break;  case 6:  	path = _configHelper.GetPath (""' FindEnum.FindAuxiliaryEquipment);  	break;  }  
