Implementation smell,Namespace,Class,File,Method,Description
Complex Method,Microsoft.Orleans.CodeGenerator.MSBuild,LogFormatter,D:\research\architectureSmells\repos\dotnet_orleans\src\Orleans.CodeGenerator.MSBuild\LogFormatter.cs,PrintException_Helper,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Orleans.CodeGenerator.MSBuild,Program,D:\research\architectureSmells\repos\dotnet_orleans\src\Orleans.CodeGenerator.MSBuild\Program.cs,SourceToSource,Cyclomatic complexity of the method is 21
Complex Method,Orleans.CodeGenerator.MSBuild,CodeGeneratorCommand,D:\research\architectureSmells\repos\dotnet_orleans\src\Orleans.CodeGenerator.MSBuild\CodeGeneratorCommand.cs,Execute,Cyclomatic complexity of the method is 8
Long Statement,Microsoft.Orleans.CodeGenerator.MSBuild,Program,D:\research\architectureSmells\repos\dotnet_orleans\src\Orleans.CodeGenerator.MSBuild\Program.cs,PrintUsage,The length of the statement  "            Console.WriteLine("Example: /in:MyGrain.dll /out:C:\\OrleansSample\\MyGrain\\obj\\Debug\\MyGrain.orleans.g.cs /r:Orleans.dll;..\\MyInterfaces\\bin\\Debug\\MyInterfaces.dll"); " is 174.
Long Statement,Orleans.CodeGenerator.MSBuild,CodeGeneratorCommand,D:\research\architectureSmells\repos\dotnet_orleans\src\Orleans.CodeGenerator.MSBuild\CodeGeneratorCommand.cs,Execute,The length of the statement  "                this.Log.LogWarning($"Project {compilation.AssemblyName} does not reference {AbstractionsAssemblyShortName} (references: {string.Join("' "' compilation.ReferencedAssemblyNames)})"); " is 181.
Magic Number,Microsoft.Orleans.CodeGenerator.MSBuild,Program,D:\research\architectureSmells\repos\dotnet_orleans\src\Orleans.CodeGenerator.MSBuild\Program.cs,SourceToSource,The following statement contains a magic number: return -2;
Magic Number,Microsoft.Orleans.CodeGenerator.MSBuild,Program,D:\research\architectureSmells\repos\dotnet_orleans\src\Orleans.CodeGenerator.MSBuild\Program.cs,SourceToSource,The following statement contains a magic number: var parts = arg.Split(new[] {':'}' 2);
Magic Number,Microsoft.Orleans.CodeGenerator.MSBuild,Program,D:\research\architectureSmells\repos\dotnet_orleans\src\Orleans.CodeGenerator.MSBuild\Program.cs,SourceToSource,The following statement contains a magic number: parts.Length > 2
Magic Number,Microsoft.Orleans.CodeGenerator.MSBuild,Program,D:\research\architectureSmells\repos\dotnet_orleans\src\Orleans.CodeGenerator.MSBuild\Program.cs,SourceToSource,The following statement contains a magic number: switch (key)                      {                          case "WaitForDebugger":                              var i = 0;                              while (!Debugger.IsAttached)                              {                                  if (i++ % 50 == 0)                                  {                                      Console.WriteLine("Waiting for debugger to attach.");                                  }                                    Thread.Sleep(100);                              }                                break;                          case nameof(cmd.ProjectGuid):                              cmd.ProjectGuid = value;                              break;                          case nameof(cmd.ProjectPath):                              cmd.ProjectPath = value;                              break;                          case nameof(cmd.OutputType):                              cmd.OutputType = value;                              break;                          case nameof(cmd.TargetPath):                              cmd.TargetPath = value;                              break;                          case nameof(cmd.AssemblyName):                              cmd.AssemblyName = value;                              break;                          case nameof(cmd.Compile):                              cmd.Compile.Add(value);                              break;                          case nameof(cmd.Reference):                              cmd.Reference.Add(value);                              break;                          case nameof(cmd.DefineConstants):                              cmd.DefineConstants.AddRange(value.Split('''' StringSplitOptions.RemoveEmptyEntries));                              break;                          case nameof(cmd.CodeGenOutputFile):                              cmd.CodeGenOutputFile = value;                              break;                          case nameof(cmd.DebuggerStepThrough):                              cmd.DebuggerStepThrough = bool.Parse(value);                              break;                          case nameof(LogLevel):                              if (!Enum.TryParse(ignoreCase: true' value: value' result: out logLevel))                              {                                  var validValues = string.Join("' "' Enum.GetNames(typeof(LogLevel)).Select(v => v.ToString()));                                  Console.WriteLine($"ERROR: \"{value}\" is not a valid log level. Valid values are {validValues}");                                  return -3;                              }                                break;                          default:                              throw new ArgumentOutOfRangeException($"Key \"{key}\" in argument file is unknown.");                      }
Magic Number,Microsoft.Orleans.CodeGenerator.MSBuild,Program,D:\research\architectureSmells\repos\dotnet_orleans\src\Orleans.CodeGenerator.MSBuild\Program.cs,SourceToSource,The following statement contains a magic number: switch (key)                      {                          case "WaitForDebugger":                              var i = 0;                              while (!Debugger.IsAttached)                              {                                  if (i++ % 50 == 0)                                  {                                      Console.WriteLine("Waiting for debugger to attach.");                                  }                                    Thread.Sleep(100);                              }                                break;                          case nameof(cmd.ProjectGuid):                              cmd.ProjectGuid = value;                              break;                          case nameof(cmd.ProjectPath):                              cmd.ProjectPath = value;                              break;                          case nameof(cmd.OutputType):                              cmd.OutputType = value;                              break;                          case nameof(cmd.TargetPath):                              cmd.TargetPath = value;                              break;                          case nameof(cmd.AssemblyName):                              cmd.AssemblyName = value;                              break;                          case nameof(cmd.Compile):                              cmd.Compile.Add(value);                              break;                          case nameof(cmd.Reference):                              cmd.Reference.Add(value);                              break;                          case nameof(cmd.DefineConstants):                              cmd.DefineConstants.AddRange(value.Split('''' StringSplitOptions.RemoveEmptyEntries));                              break;                          case nameof(cmd.CodeGenOutputFile):                              cmd.CodeGenOutputFile = value;                              break;                          case nameof(cmd.DebuggerStepThrough):                              cmd.DebuggerStepThrough = bool.Parse(value);                              break;                          case nameof(LogLevel):                              if (!Enum.TryParse(ignoreCase: true' value: value' result: out logLevel))                              {                                  var validValues = string.Join("' "' Enum.GetNames(typeof(LogLevel)).Select(v => v.ToString()));                                  Console.WriteLine($"ERROR: \"{value}\" is not a valid log level. Valid values are {validValues}");                                  return -3;                              }                                break;                          default:                              throw new ArgumentOutOfRangeException($"Key \"{key}\" in argument file is unknown.");                      }
Magic Number,Microsoft.Orleans.CodeGenerator.MSBuild,Program,D:\research\architectureSmells\repos\dotnet_orleans\src\Orleans.CodeGenerator.MSBuild\Program.cs,SourceToSource,The following statement contains a magic number: switch (key)                      {                          case "WaitForDebugger":                              var i = 0;                              while (!Debugger.IsAttached)                              {                                  if (i++ % 50 == 0)                                  {                                      Console.WriteLine("Waiting for debugger to attach.");                                  }                                    Thread.Sleep(100);                              }                                break;                          case nameof(cmd.ProjectGuid):                              cmd.ProjectGuid = value;                              break;                          case nameof(cmd.ProjectPath):                              cmd.ProjectPath = value;                              break;                          case nameof(cmd.OutputType):                              cmd.OutputType = value;                              break;                          case nameof(cmd.TargetPath):                              cmd.TargetPath = value;                              break;                          case nameof(cmd.AssemblyName):                              cmd.AssemblyName = value;                              break;                          case nameof(cmd.Compile):                              cmd.Compile.Add(value);                              break;                          case nameof(cmd.Reference):                              cmd.Reference.Add(value);                              break;                          case nameof(cmd.DefineConstants):                              cmd.DefineConstants.AddRange(value.Split('''' StringSplitOptions.RemoveEmptyEntries));                              break;                          case nameof(cmd.CodeGenOutputFile):                              cmd.CodeGenOutputFile = value;                              break;                          case nameof(cmd.DebuggerStepThrough):                              cmd.DebuggerStepThrough = bool.Parse(value);                              break;                          case nameof(LogLevel):                              if (!Enum.TryParse(ignoreCase: true' value: value' result: out logLevel))                              {                                  var validValues = string.Join("' "' Enum.GetNames(typeof(LogLevel)).Select(v => v.ToString()));                                  Console.WriteLine($"ERROR: \"{value}\" is not a valid log level. Valid values are {validValues}");                                  return -3;                              }                                break;                          default:                              throw new ArgumentOutOfRangeException($"Key \"{key}\" in argument file is unknown.");                      }
