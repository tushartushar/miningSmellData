Implementation smell,Namespace,Class,File,Method,Description
Complex Method,Orleans,JenkinsHash,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\IDs\JenkinsHash.cs,ComputeHash,Cyclomatic complexity of the method is 13
Complex Method,Orleans.Runtime,GrainReference,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\Runtime\GrainReference.cs,GrainReference,Cyclomatic complexity of the method is 10
Long Parameter List,Orleans.Runtime,UniqueKey,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\IDs\UniqueKey.cs,NewKey,The method has 5 parameters. Parameters: n0' n1' category' typeData' keyExt
Long Parameter List,Orleans.Runtime,Logger,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\Logging\Logger.cs,Log,The method has 5 parameters. Parameters: errorCode' sev' format' args' exception
Long Parameter List,Orleans.Runtime,GrainReference,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\Runtime\GrainReference.cs,GrainReference,The method has 5 parameters. Parameters: grainId' genericArgument' systemTargetSilo' observerId' runtime
Long Parameter List,Orleans.Runtime,IGrainReferenceRuntime,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\Runtime\IGrainReferenceRuntime.cs,InvokeOneWayMethod,The method has 5 parameters. Parameters: reference' methodId' arguments' options' silo
Long Parameter List,Orleans.Runtime,IGrainReferenceRuntime,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\Runtime\IGrainReferenceRuntime.cs,InvokeMethodAsync,The method has 5 parameters. Parameters: reference' methodId' arguments' options' silo
Long Parameter List,Orleans.Timers,ITimerRegistry,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\Timers\ITimerRegistry.cs,RegisterTimer,The method has 5 parameters. Parameters: grain' asyncCallback' state' dueTime' period
Long Identifier,Orleans.Runtime,RequestContext,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\Runtime\RequestContext.cs,,The length of the parameter CALL_CHAIN_REQUEST_CONTEXT_HEADER is 33.
Long Identifier,Orleans.Runtime,RequestContext,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\Runtime\RequestContext.cs,,The length of the parameter E2_E_TRACING_ACTIVITY_ID_HEADER is 31.
Long Identifier,Orleans.Providers,ProviderConstants,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\Providers\ProviderConstants.cs,,The length of the parameter DEFAULT_LOG_CONSISTENCY_PROVIDER_NAME is 37.
Long Statement,Orleans,GrainCancellationToken,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\Cancellation\GrainCancellationToken.cs,DeserializeGrainCancellationToken,The length of the statement  "            var runtime = context.ServiceProvider.GetService(typeof(IGrainCancellationTokenRuntime)) as IGrainCancellationTokenRuntime; " is 123.
Long Statement,Orleans,GrainCancellationToken,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\Cancellation\GrainCancellationToken.cs,CopyGrainCancellationToken,The length of the statement  "            var runtime = context.ServiceProvider.GetService(typeof(IGrainCancellationTokenRuntime)) as IGrainCancellationTokenRuntime; " is 123.
Long Statement,Orleans,Grain,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\Core\Grain.cs,RegisterOrUpdateReminder,The length of the statement  "                throw new InvalidOperationException($"Grain {IdentityString} is not 'IRemindable'. A grain should implement IRemindable to use the persistent reminder service"); " is 161.
Long Statement,Orleans,Grain,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\Core\Grain.cs,EnsureRuntime,The length of the statement  "                throw new InvalidOperationException("Grain was created outside of the Orleans creation process and no runtime was specified."); " is 127.
Long Statement,Orleans,GrainExtensions,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\Core\GrainExtensions.cs,AsWeaklyTypedReference,The length of the statement  "            if (systemTarget != null) return GrainReference.FromGrainId(systemTarget.GrainId' systemTarget.GrainReferenceRuntime' null' systemTarget.Silo); " is 143.
Long Statement,Orleans,GrainExtensions,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\Core\GrainExtensions.cs,GetGrainId,The length of the statement  "            throw new ArgumentException(String.Format("GetGrainId has been called on an unexpected type: {0}."' grain.GetType().FullName)' "grain"); " is 136.
Long Statement,Orleans,GrainExtensions,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\Core\GrainExtensions.cs,GetGrainIdentity,The length of the statement  "            throw new ArgumentException(String.Format("GetGrainIdentity has been called on an unexpected type: {0}."' grain.GetType().FullName)' "grain"); " is 142.
Long Statement,Orleans,GrainExtensions,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\Core\GrainExtensions.cs,InvokeOneWay,The length of the statement  "            var oneWayGrainReferenceCopy = new GrainReference(grainReference.AsWeaklyTypedReference()' InvokeMethodOptions.OneWay).Cast<T>(); " is 129.
Long Statement,Orleans,GrainExtensions,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\Core\GrainExtensions.cs,InvokeOneWay,The length of the statement  "            // Task is always completed at this point. Should also help to catch situations of mistakenly calling the method on original grain reference " is 140.
Long Statement,Orleans.Runtime,GrainId,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\IDs\GrainId.cs,FindOrCreateGrainId,The length of the statement  "            // Note: This is done here to avoid a wierd cyclic dependency / static initialization ordering problem involving the GrainId' Constants & Interner classes " is 154.
Long Statement,Orleans.Runtime,GrainId,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\IDs\GrainId.cs,ToFullString,The length of the statement  "                    "[GrainId: {0}' IdCategory: {1}' BaseTypeCode: {2} (x{3})' PrimaryKey: {4} (x{5})' UniformHashCode: {6} (0x{7' 8:X8}){8}]"' " is 123.
Long Statement,Orleans.Runtime,SiloAddress,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\IDs\SiloAddress.cs,CompareTo,The length of the statement  "            // and is also semantically meaningfull - older silos (with smaller Generation) will appear first in the comparison order. " is 122.
Long Statement,Orleans.Runtime,UniqueKey,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\IDs\UniqueKey.cs,GetUniformHashCode,The length of the statement  "            // Disabling this ReSharper warning; hashCache is a logically read-only variable' so accessing them in GetHashCode is safe. " is 123.
Long Statement,Orleans.Runtime,UniqueKey,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\IDs\UniqueKey.cs,ConvertToGuid,The length of the statement  "            return new Guid((UInt32)(N0 & 0xffffffff)' (UInt16)(N0 >> 32)' (UInt16)(N0 >> 48)' (byte)N1' (byte)(N1 >> 8)' (byte)(N1 >> 16)' (byte)(N1 >> 24)' (byte)(N1 >> 32)' (byte)(N1 >> 40)' (byte)(N1 >> 48)' (byte)(N1 >> 56)); " is 218.
Long Statement,Orleans.Runtime,GrainReferenceNotBoundException,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\Runtime\GrainReference.cs,CreateMessage,The length of the statement  "            return $"Attempted to use a GrainReference which has not been bound to the runtime: {grainReference.ToDetailedString()}." + " is 123.
Long Statement,Orleans.Runtime,GrainReferenceNotBoundException,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\Runtime\GrainReference.cs,CreateMessage,The length of the statement  "                   $" Use the {nameof(IGrainFactory)}.{nameof(IGrainFactory.BindGrainReference)} method to bind this reference to the runtime."; " is 125.
Long Statement,Orleans.Runtime,GrainReference,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\Runtime\GrainReference.cs,ToKeyString,The length of the statement  "                return String.Format("{0}={1} {2}={3}"' GRAIN_REFERENCE_STR' GrainId.ToParsableString()' OBSERVER_ID_STR' observerId.ToParsableString()); " is 137.
Long Statement,Orleans.Runtime,GrainReference,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\Runtime\GrainReference.cs,ToKeyString,The length of the statement  "                return String.Format("{0}={1} {2}={3}"' GRAIN_REFERENCE_STR' GrainId.ToParsableString()' SYSTEM_TARGET_STR' SystemTargetSilo.ToParsableString()); " is 145.
Long Statement,Orleans.Runtime,GrainReference,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\Runtime\GrainReference.cs,ToKeyString,The length of the statement  "                return String.Format("{0}={1} {2}={3}"' GRAIN_REFERENCE_STR' GrainId.ToParsableString()' GENERIC_ARGUMENTS_STR' genericArguments); " is 130.
Long Statement,Orleans.Runtime,GrainReference,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\Runtime\GrainReference.cs,FromKeyString,The length of the statement  "            if (string.IsNullOrWhiteSpace(key)) throw new ArgumentNullException("key"' "GrainReference.FromKeyString cannot parse null key"); " is 129.
Long Statement,Orleans.Runtime,KeyedServiceCollectionExtensions,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\Utils\IKeyedServiceCollection.cs,GetServiceByKey,The length of the statement  "            IKeyedServiceCollection<TKey' TService> collection = (IKeyedServiceCollection<TKey' TService>) services.GetService(typeof(IKeyedServiceCollection<TKey' TService>)); " is 164.
Long Statement,Orleans.CodeGeneration,GrainFactoryBase,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\CodeGeneration\GrainFactoryBase.cs,CheckGrainObserverParamInternal,The length of the statement  "                string errMsg = string.Format("IGrainObserver parameters must be GrainReference or Grain and cannot be type {0}. Did you forget to CreateObjectReference?"' grainObserver.GetType()); " is 181.
Magic Number,Orleans,JenkinsHash,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\IDs\JenkinsHash.cs,Mix,The following statement contains a magic number: a ^= (c >> 13);
Magic Number,Orleans,JenkinsHash,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\IDs\JenkinsHash.cs,Mix,The following statement contains a magic number: b ^= (a << 8);
Magic Number,Orleans,JenkinsHash,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\IDs\JenkinsHash.cs,Mix,The following statement contains a magic number: c ^= (b >> 13);
Magic Number,Orleans,JenkinsHash,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\IDs\JenkinsHash.cs,Mix,The following statement contains a magic number: a ^= (c >> 12);
Magic Number,Orleans,JenkinsHash,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\IDs\JenkinsHash.cs,Mix,The following statement contains a magic number: b ^= (a << 16);
Magic Number,Orleans,JenkinsHash,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\IDs\JenkinsHash.cs,Mix,The following statement contains a magic number: c ^= (b >> 5);
Magic Number,Orleans,JenkinsHash,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\IDs\JenkinsHash.cs,Mix,The following statement contains a magic number: a ^= (c >> 3);
Magic Number,Orleans,JenkinsHash,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\IDs\JenkinsHash.cs,Mix,The following statement contains a magic number: b ^= (a << 10);
Magic Number,Orleans,JenkinsHash,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\IDs\JenkinsHash.cs,Mix,The following statement contains a magic number: c ^= (b >> 15);
Magic Number,Orleans,JenkinsHash,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\IDs\JenkinsHash.cs,ComputeHash,The following statement contains a magic number: while (i + 12 <= len)              {                  a += (uint)data[i++] |                      ((uint)data[i++] << 8) |                      ((uint)data[i++] << 16) |                      ((uint)data[i++] << 24);                  b += (uint)data[i++] |                      ((uint)data[i++] << 8) |                      ((uint)data[i++] << 16) |                      ((uint)data[i++] << 24);                  c += (uint)data[i++] |                      ((uint)data[i++] << 8) |                      ((uint)data[i++] << 16) |                      ((uint)data[i++] << 24);                  Mix(ref a' ref b' ref c);              }
Magic Number,Orleans,JenkinsHash,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\IDs\JenkinsHash.cs,ComputeHash,The following statement contains a magic number: while (i + 12 <= len)              {                  a += (uint)data[i++] |                      ((uint)data[i++] << 8) |                      ((uint)data[i++] << 16) |                      ((uint)data[i++] << 24);                  b += (uint)data[i++] |                      ((uint)data[i++] << 8) |                      ((uint)data[i++] << 16) |                      ((uint)data[i++] << 24);                  c += (uint)data[i++] |                      ((uint)data[i++] << 8) |                      ((uint)data[i++] << 16) |                      ((uint)data[i++] << 24);                  Mix(ref a' ref b' ref c);              }
Magic Number,Orleans,JenkinsHash,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\IDs\JenkinsHash.cs,ComputeHash,The following statement contains a magic number: while (i + 12 <= len)              {                  a += (uint)data[i++] |                      ((uint)data[i++] << 8) |                      ((uint)data[i++] << 16) |                      ((uint)data[i++] << 24);                  b += (uint)data[i++] |                      ((uint)data[i++] << 8) |                      ((uint)data[i++] << 16) |                      ((uint)data[i++] << 24);                  c += (uint)data[i++] |                      ((uint)data[i++] << 8) |                      ((uint)data[i++] << 16) |                      ((uint)data[i++] << 24);                  Mix(ref a' ref b' ref c);              }
Magic Number,Orleans,JenkinsHash,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\IDs\JenkinsHash.cs,ComputeHash,The following statement contains a magic number: while (i + 12 <= len)              {                  a += (uint)data[i++] |                      ((uint)data[i++] << 8) |                      ((uint)data[i++] << 16) |                      ((uint)data[i++] << 24);                  b += (uint)data[i++] |                      ((uint)data[i++] << 8) |                      ((uint)data[i++] << 16) |                      ((uint)data[i++] << 24);                  c += (uint)data[i++] |                      ((uint)data[i++] << 8) |                      ((uint)data[i++] << 16) |                      ((uint)data[i++] << 24);                  Mix(ref a' ref b' ref c);              }
Magic Number,Orleans,JenkinsHash,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\IDs\JenkinsHash.cs,ComputeHash,The following statement contains a magic number: while (i + 12 <= len)              {                  a += (uint)data[i++] |                      ((uint)data[i++] << 8) |                      ((uint)data[i++] << 16) |                      ((uint)data[i++] << 24);                  b += (uint)data[i++] |                      ((uint)data[i++] << 8) |                      ((uint)data[i++] << 16) |                      ((uint)data[i++] << 24);                  c += (uint)data[i++] |                      ((uint)data[i++] << 8) |                      ((uint)data[i++] << 16) |                      ((uint)data[i++] << 24);                  Mix(ref a' ref b' ref c);              }
Magic Number,Orleans,JenkinsHash,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\IDs\JenkinsHash.cs,ComputeHash,The following statement contains a magic number: while (i + 12 <= len)              {                  a += (uint)data[i++] |                      ((uint)data[i++] << 8) |                      ((uint)data[i++] << 16) |                      ((uint)data[i++] << 24);                  b += (uint)data[i++] |                      ((uint)data[i++] << 8) |                      ((uint)data[i++] << 16) |                      ((uint)data[i++] << 24);                  c += (uint)data[i++] |                      ((uint)data[i++] << 8) |                      ((uint)data[i++] << 16) |                      ((uint)data[i++] << 24);                  Mix(ref a' ref b' ref c);              }
Magic Number,Orleans,JenkinsHash,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\IDs\JenkinsHash.cs,ComputeHash,The following statement contains a magic number: while (i + 12 <= len)              {                  a += (uint)data[i++] |                      ((uint)data[i++] << 8) |                      ((uint)data[i++] << 16) |                      ((uint)data[i++] << 24);                  b += (uint)data[i++] |                      ((uint)data[i++] << 8) |                      ((uint)data[i++] << 16) |                      ((uint)data[i++] << 24);                  c += (uint)data[i++] |                      ((uint)data[i++] << 8) |                      ((uint)data[i++] << 16) |                      ((uint)data[i++] << 24);                  Mix(ref a' ref b' ref c);              }
Magic Number,Orleans,JenkinsHash,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\IDs\JenkinsHash.cs,ComputeHash,The following statement contains a magic number: while (i + 12 <= len)              {                  a += (uint)data[i++] |                      ((uint)data[i++] << 8) |                      ((uint)data[i++] << 16) |                      ((uint)data[i++] << 24);                  b += (uint)data[i++] |                      ((uint)data[i++] << 8) |                      ((uint)data[i++] << 16) |                      ((uint)data[i++] << 24);                  c += (uint)data[i++] |                      ((uint)data[i++] << 8) |                      ((uint)data[i++] << 16) |                      ((uint)data[i++] << 24);                  Mix(ref a' ref b' ref c);              }
Magic Number,Orleans,JenkinsHash,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\IDs\JenkinsHash.cs,ComputeHash,The following statement contains a magic number: while (i + 12 <= len)              {                  a += (uint)data[i++] |                      ((uint)data[i++] << 8) |                      ((uint)data[i++] << 16) |                      ((uint)data[i++] << 24);                  b += (uint)data[i++] |                      ((uint)data[i++] << 8) |                      ((uint)data[i++] << 16) |                      ((uint)data[i++] << 24);                  c += (uint)data[i++] |                      ((uint)data[i++] << 8) |                      ((uint)data[i++] << 16) |                      ((uint)data[i++] << 24);                  Mix(ref a' ref b' ref c);              }
Magic Number,Orleans,JenkinsHash,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\IDs\JenkinsHash.cs,ComputeHash,The following statement contains a magic number: while (i + 12 <= len)              {                  a += (uint)data[i++] |                      ((uint)data[i++] << 8) |                      ((uint)data[i++] << 16) |                      ((uint)data[i++] << 24);                  b += (uint)data[i++] |                      ((uint)data[i++] << 8) |                      ((uint)data[i++] << 16) |                      ((uint)data[i++] << 24);                  c += (uint)data[i++] |                      ((uint)data[i++] << 8) |                      ((uint)data[i++] << 16) |                      ((uint)data[i++] << 24);                  Mix(ref a' ref b' ref c);              }
Magic Number,Orleans,JenkinsHash,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\IDs\JenkinsHash.cs,ComputeHash,The following statement contains a magic number: if (i < len)                  a += (uint)data[i++] << 8;
Magic Number,Orleans,JenkinsHash,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\IDs\JenkinsHash.cs,ComputeHash,The following statement contains a magic number: if (i < len)                  a += (uint)data[i++] << 16;
Magic Number,Orleans,JenkinsHash,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\IDs\JenkinsHash.cs,ComputeHash,The following statement contains a magic number: if (i < len)                  a += (uint)data[i++] << 24;
Magic Number,Orleans,JenkinsHash,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\IDs\JenkinsHash.cs,ComputeHash,The following statement contains a magic number: if (i < len)                  b += (uint)data[i++] << 8;
Magic Number,Orleans,JenkinsHash,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\IDs\JenkinsHash.cs,ComputeHash,The following statement contains a magic number: if (i < len)                  b += (uint)data[i++] << 16;
Magic Number,Orleans,JenkinsHash,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\IDs\JenkinsHash.cs,ComputeHash,The following statement contains a magic number: if (i < len)                  b += (uint)data[i++] << 24;
Magic Number,Orleans,JenkinsHash,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\IDs\JenkinsHash.cs,ComputeHash,The following statement contains a magic number: if (i < len)                  c += (uint)data[i++] << 8;
Magic Number,Orleans,JenkinsHash,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\IDs\JenkinsHash.cs,ComputeHash,The following statement contains a magic number: if (i < len)                  c += (uint)data[i++] << 16;
Magic Number,Orleans,JenkinsHash,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\IDs\JenkinsHash.cs,ComputeHash,The following statement contains a magic number: if (i < len)                  c += (uint)data[i++] << 24;
Magic Number,Orleans,JenkinsHash,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\IDs\JenkinsHash.cs,ComputeHash,The following statement contains a magic number: unchecked              {                  a += (uint)u1;                  b += (uint)((u1 ^ (uint)u1) >> 32);                  c += (uint)u2;                  Mix(ref a' ref b' ref c);                  a += (uint)((u2 ^ (uint)u2) >> 32);                  b += (uint)u3;                  c += (uint)((u3 ^ (uint)u3) >> 32);              }
Magic Number,Orleans,JenkinsHash,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\IDs\JenkinsHash.cs,ComputeHash,The following statement contains a magic number: unchecked              {                  a += (uint)u1;                  b += (uint)((u1 ^ (uint)u1) >> 32);                  c += (uint)u2;                  Mix(ref a' ref b' ref c);                  a += (uint)((u2 ^ (uint)u2) >> 32);                  b += (uint)u3;                  c += (uint)((u3 ^ (uint)u3) >> 32);              }
Magic Number,Orleans,JenkinsHash,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\IDs\JenkinsHash.cs,ComputeHash,The following statement contains a magic number: unchecked              {                  a += (uint)u1;                  b += (uint)((u1 ^ (uint)u1) >> 32);                  c += (uint)u2;                  Mix(ref a' ref b' ref c);                  a += (uint)((u2 ^ (uint)u2) >> 32);                  b += (uint)u3;                  c += (uint)((u3 ^ (uint)u3) >> 32);              }
Magic Number,Orleans,JenkinsHash,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\IDs\JenkinsHash.cs,ComputeHash,The following statement contains a magic number: c += 24;
Magic Number,Orleans.Runtime,ActivationId,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\IDs\ActivationId.cs,ToString,The following statement contains a magic number: string idString = Key.ToString().Substring(24' 8);
Magic Number,Orleans.Runtime,ActivationId,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\IDs\ActivationId.cs,ToString,The following statement contains a magic number: string idString = Key.ToString().Substring(24' 8);
Magic Number,Orleans.Runtime,GrainId,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\IDs\GrainId.cs,ToStringImpl,The following statement contains a magic number: if (!detailed)              {                  if (keyString.Length >= 48)                      idString = keyString.Substring(24' 8) + keyString.Substring(48);                  else                      idString = keyString.Substring(24' 8);              }
Magic Number,Orleans.Runtime,GrainId,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\IDs\GrainId.cs,ToStringImpl,The following statement contains a magic number: if (!detailed)              {                  if (keyString.Length >= 48)                      idString = keyString.Substring(24' 8) + keyString.Substring(48);                  else                      idString = keyString.Substring(24' 8);              }
Magic Number,Orleans.Runtime,GrainId,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\IDs\GrainId.cs,ToStringImpl,The following statement contains a magic number: if (!detailed)              {                  if (keyString.Length >= 48)                      idString = keyString.Substring(24' 8) + keyString.Substring(48);                  else                      idString = keyString.Substring(24' 8);              }
Magic Number,Orleans.Runtime,GrainId,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\IDs\GrainId.cs,ToStringImpl,The following statement contains a magic number: if (!detailed)              {                  if (keyString.Length >= 48)                      idString = keyString.Substring(24' 8) + keyString.Substring(48);                  else                      idString = keyString.Substring(24' 8);              }
Magic Number,Orleans.Runtime,GrainId,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\IDs\GrainId.cs,ToStringImpl,The following statement contains a magic number: if (!detailed)              {                  if (keyString.Length >= 48)                      idString = keyString.Substring(24' 8) + keyString.Substring(48);                  else                      idString = keyString.Substring(24' 8);              }
Magic Number,Orleans.Runtime,GrainId,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\IDs\GrainId.cs,ToStringImpl,The following statement contains a magic number: if (!detailed)              {                  if (keyString.Length >= 48)                      idString = keyString.Substring(24' 8) + keyString.Substring(48);                  else                      idString = keyString.Substring(24' 8);              }
Magic Number,Orleans.Runtime,GrainId,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\IDs\GrainId.cs,ToStringImpl,The following statement contains a magic number: switch (Category)              {                  case UniqueKey.Category.Grain:                  case UniqueKey.Category.KeyExtGrain:                      var typeString = TypeCode.ToString("X");                      if (!detailed) typeString = typeString.Substring(Math.Max(0' typeString.Length - 8));                      fullString = String.Format("*grn/{0}/{1}"' typeString' idString);                      break;                  case UniqueKey.Category.Client:                      fullString = "*cli/" + idString;                      break;                  case UniqueKey.Category.GeoClient:                      fullString = string.Format("*gcl/{0}/{1}"' Key.KeyExt' idString);                      break;                  case UniqueKey.Category.SystemTarget:  #if ABSTRACTIONS_TODO                      string explicitName = Constants.SystemTargetName(this);                      if (TypeCode != 0)                      {                          var typeStr = TypeCode.ToString("X");                          return String.Format("{0}/{1}/{2}"' explicitName' typeStr' idString);                      }                      fullString = explicitName;                      break;  #endif                  default:                      fullString = "???/" + idString;                      break;              }
Magic Number,Orleans.Runtime,SiloAddress,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\IDs\SiloAddress.cs,CalculateIdHash,The following statement contains a magic number: try              {                  byte[] data = Encoding.Unicode.GetBytes(text);                  byte[] result = sha.ComputeHash(data);                  for (int i = 0; i < result.Length; i += 4)                  {                      int tmp = (result[i] << 24) | (result[i + 1] << 16) | (result[i + 2] << 8) | (result[i + 3]);                      hash = hash ^ tmp;                  }              }              finally              {                  sha.Dispose();              }
Magic Number,Orleans.Runtime,SiloAddress,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\IDs\SiloAddress.cs,CalculateIdHash,The following statement contains a magic number: try              {                  byte[] data = Encoding.Unicode.GetBytes(text);                  byte[] result = sha.ComputeHash(data);                  for (int i = 0; i < result.Length; i += 4)                  {                      int tmp = (result[i] << 24) | (result[i + 1] << 16) | (result[i + 2] << 8) | (result[i + 3]);                      hash = hash ^ tmp;                  }              }              finally              {                  sha.Dispose();              }
Magic Number,Orleans.Runtime,SiloAddress,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\IDs\SiloAddress.cs,CalculateIdHash,The following statement contains a magic number: try              {                  byte[] data = Encoding.Unicode.GetBytes(text);                  byte[] result = sha.ComputeHash(data);                  for (int i = 0; i < result.Length; i += 4)                  {                      int tmp = (result[i] << 24) | (result[i + 1] << 16) | (result[i + 2] << 8) | (result[i + 3]);                      hash = hash ^ tmp;                  }              }              finally              {                  sha.Dispose();              }
Magic Number,Orleans.Runtime,SiloAddress,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\IDs\SiloAddress.cs,CalculateIdHash,The following statement contains a magic number: try              {                  byte[] data = Encoding.Unicode.GetBytes(text);                  byte[] result = sha.ComputeHash(data);                  for (int i = 0; i < result.Length; i += 4)                  {                      int tmp = (result[i] << 24) | (result[i + 1] << 16) | (result[i + 2] << 8) | (result[i + 3]);                      hash = hash ^ tmp;                  }              }              finally              {                  sha.Dispose();              }
Magic Number,Orleans.Runtime,SiloAddress,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\IDs\SiloAddress.cs,CalculateIdHash,The following statement contains a magic number: try              {                  byte[] data = Encoding.Unicode.GetBytes(text);                  byte[] result = sha.ComputeHash(data);                  for (int i = 0; i < result.Length; i += 4)                  {                      int tmp = (result[i] << 24) | (result[i + 1] << 16) | (result[i + 2] << 8) | (result[i + 3]);                      hash = hash ^ tmp;                  }              }              finally              {                  sha.Dispose();              }
Magic Number,Orleans.Runtime,SiloAddress,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\IDs\SiloAddress.cs,CalculateIdHash,The following statement contains a magic number: try              {                  byte[] data = Encoding.Unicode.GetBytes(text);                  byte[] result = sha.ComputeHash(data);                  for (int i = 0; i < result.Length; i += 4)                  {                      int tmp = (result[i] << 24) | (result[i + 1] << 16) | (result[i + 2] << 8) | (result[i + 3]);                      hash = hash ^ tmp;                  }              }              finally              {                  sha.Dispose();              }
Magic Number,Orleans.Runtime,SiloAddress,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\IDs\SiloAddress.cs,GetUniformHashCodesImpl,The following statement contains a magic number: var bytes = new byte[16 + sizeof(int) + sizeof(int) + sizeof(int)];
Magic Number,Orleans.Runtime,SiloAddress,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\IDs\SiloAddress.cs,GetUniformHashCodesImpl,The following statement contains a magic number: for (int i = 0; i < bytes.Length; i++)              {                  bytes[i] = 9;              }
Magic Number,Orleans.Runtime,SiloAddress,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\IDs\SiloAddress.cs,GetUniformHashCodesImpl,The following statement contains a magic number: if (this.Endpoint.AddressFamily == AddressFamily.InterNetwork) // IPv4              {                  for (int i = 0; i < 12; i++)                  {                      bytes[i] = 0;                  }                  Buffer.BlockCopy(this.Endpoint.Address.GetAddressBytes()' 0' bytes' 12' 4);              }              else // IPv6              {                  Buffer.BlockCopy(this.Endpoint.Address.GetAddressBytes()' 0' bytes' 0' 16);              }
Magic Number,Orleans.Runtime,SiloAddress,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\IDs\SiloAddress.cs,GetUniformHashCodesImpl,The following statement contains a magic number: if (this.Endpoint.AddressFamily == AddressFamily.InterNetwork) // IPv4              {                  for (int i = 0; i < 12; i++)                  {                      bytes[i] = 0;                  }                  Buffer.BlockCopy(this.Endpoint.Address.GetAddressBytes()' 0' bytes' 12' 4);              }              else // IPv6              {                  Buffer.BlockCopy(this.Endpoint.Address.GetAddressBytes()' 0' bytes' 0' 16);              }
Magic Number,Orleans.Runtime,SiloAddress,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\IDs\SiloAddress.cs,GetUniformHashCodesImpl,The following statement contains a magic number: if (this.Endpoint.AddressFamily == AddressFamily.InterNetwork) // IPv4              {                  for (int i = 0; i < 12; i++)                  {                      bytes[i] = 0;                  }                  Buffer.BlockCopy(this.Endpoint.Address.GetAddressBytes()' 0' bytes' 12' 4);              }              else // IPv6              {                  Buffer.BlockCopy(this.Endpoint.Address.GetAddressBytes()' 0' bytes' 0' 16);              }
Magic Number,Orleans.Runtime,SiloAddress,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\IDs\SiloAddress.cs,GetUniformHashCodesImpl,The following statement contains a magic number: if (this.Endpoint.AddressFamily == AddressFamily.InterNetwork) // IPv4              {                  for (int i = 0; i < 12; i++)                  {                      bytes[i] = 0;                  }                  Buffer.BlockCopy(this.Endpoint.Address.GetAddressBytes()' 0' bytes' 12' 4);              }              else // IPv6              {                  Buffer.BlockCopy(this.Endpoint.Address.GetAddressBytes()' 0' bytes' 0' 16);              }
Magic Number,Orleans.Runtime,SiloAddress,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\IDs\SiloAddress.cs,GetUniformHashCodesImpl,The following statement contains a magic number: var offset = 16;
Magic Number,Orleans.Runtime,UniqueKey,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\IDs\UniqueKey.cs,Parse,The following statement contains a magic number: if (Guid.TryParse(trimmed' out guid))                  return NewKey(guid);              else              {                  var fields = trimmed.Split(KeyExtSeparationChar' 2);                  var n0 = ulong.Parse(fields[0].Substring(0' 16)' NumberStyles.HexNumber);                  var n1 = ulong.Parse(fields[0].Substring(16' 16)' NumberStyles.HexNumber);                  var typeCodeData = ulong.Parse(fields[0].Substring(32' 16)' NumberStyles.HexNumber);                  string keyExt = null;                  switch (fields.Length)                  {                      default:                          throw new InvalidDataException("UniqueKey hex strings cannot contain more than one + separator.");                      case 1:                          break;                      case 2:                          if (fields[1] != "null")                          {                              keyExt = fields[1];                          }                          break;                  }                  return NewKey(n0' n1' typeCodeData' keyExt);              }
Magic Number,Orleans.Runtime,UniqueKey,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\IDs\UniqueKey.cs,Parse,The following statement contains a magic number: if (Guid.TryParse(trimmed' out guid))                  return NewKey(guid);              else              {                  var fields = trimmed.Split(KeyExtSeparationChar' 2);                  var n0 = ulong.Parse(fields[0].Substring(0' 16)' NumberStyles.HexNumber);                  var n1 = ulong.Parse(fields[0].Substring(16' 16)' NumberStyles.HexNumber);                  var typeCodeData = ulong.Parse(fields[0].Substring(32' 16)' NumberStyles.HexNumber);                  string keyExt = null;                  switch (fields.Length)                  {                      default:                          throw new InvalidDataException("UniqueKey hex strings cannot contain more than one + separator.");                      case 1:                          break;                      case 2:                          if (fields[1] != "null")                          {                              keyExt = fields[1];                          }                          break;                  }                  return NewKey(n0' n1' typeCodeData' keyExt);              }
Magic Number,Orleans.Runtime,UniqueKey,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\IDs\UniqueKey.cs,Parse,The following statement contains a magic number: if (Guid.TryParse(trimmed' out guid))                  return NewKey(guid);              else              {                  var fields = trimmed.Split(KeyExtSeparationChar' 2);                  var n0 = ulong.Parse(fields[0].Substring(0' 16)' NumberStyles.HexNumber);                  var n1 = ulong.Parse(fields[0].Substring(16' 16)' NumberStyles.HexNumber);                  var typeCodeData = ulong.Parse(fields[0].Substring(32' 16)' NumberStyles.HexNumber);                  string keyExt = null;                  switch (fields.Length)                  {                      default:                          throw new InvalidDataException("UniqueKey hex strings cannot contain more than one + separator.");                      case 1:                          break;                      case 2:                          if (fields[1] != "null")                          {                              keyExt = fields[1];                          }                          break;                  }                  return NewKey(n0' n1' typeCodeData' keyExt);              }
Magic Number,Orleans.Runtime,UniqueKey,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\IDs\UniqueKey.cs,Parse,The following statement contains a magic number: if (Guid.TryParse(trimmed' out guid))                  return NewKey(guid);              else              {                  var fields = trimmed.Split(KeyExtSeparationChar' 2);                  var n0 = ulong.Parse(fields[0].Substring(0' 16)' NumberStyles.HexNumber);                  var n1 = ulong.Parse(fields[0].Substring(16' 16)' NumberStyles.HexNumber);                  var typeCodeData = ulong.Parse(fields[0].Substring(32' 16)' NumberStyles.HexNumber);                  string keyExt = null;                  switch (fields.Length)                  {                      default:                          throw new InvalidDataException("UniqueKey hex strings cannot contain more than one + separator.");                      case 1:                          break;                      case 2:                          if (fields[1] != "null")                          {                              keyExt = fields[1];                          }                          break;                  }                  return NewKey(n0' n1' typeCodeData' keyExt);              }
Magic Number,Orleans.Runtime,UniqueKey,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\IDs\UniqueKey.cs,Parse,The following statement contains a magic number: if (Guid.TryParse(trimmed' out guid))                  return NewKey(guid);              else              {                  var fields = trimmed.Split(KeyExtSeparationChar' 2);                  var n0 = ulong.Parse(fields[0].Substring(0' 16)' NumberStyles.HexNumber);                  var n1 = ulong.Parse(fields[0].Substring(16' 16)' NumberStyles.HexNumber);                  var typeCodeData = ulong.Parse(fields[0].Substring(32' 16)' NumberStyles.HexNumber);                  string keyExt = null;                  switch (fields.Length)                  {                      default:                          throw new InvalidDataException("UniqueKey hex strings cannot contain more than one + separator.");                      case 1:                          break;                      case 2:                          if (fields[1] != "null")                          {                              keyExt = fields[1];                          }                          break;                  }                  return NewKey(n0' n1' typeCodeData' keyExt);              }
Magic Number,Orleans.Runtime,UniqueKey,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\IDs\UniqueKey.cs,Parse,The following statement contains a magic number: if (Guid.TryParse(trimmed' out guid))                  return NewKey(guid);              else              {                  var fields = trimmed.Split(KeyExtSeparationChar' 2);                  var n0 = ulong.Parse(fields[0].Substring(0' 16)' NumberStyles.HexNumber);                  var n1 = ulong.Parse(fields[0].Substring(16' 16)' NumberStyles.HexNumber);                  var typeCodeData = ulong.Parse(fields[0].Substring(32' 16)' NumberStyles.HexNumber);                  string keyExt = null;                  switch (fields.Length)                  {                      default:                          throw new InvalidDataException("UniqueKey hex strings cannot contain more than one + separator.");                      case 1:                          break;                      case 2:                          if (fields[1] != "null")                          {                              keyExt = fields[1];                          }                          break;                  }                  return NewKey(n0' n1' typeCodeData' keyExt);              }
Magic Number,Orleans.Runtime,UniqueKey,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\IDs\UniqueKey.cs,Parse,The following statement contains a magic number: if (Guid.TryParse(trimmed' out guid))                  return NewKey(guid);              else              {                  var fields = trimmed.Split(KeyExtSeparationChar' 2);                  var n0 = ulong.Parse(fields[0].Substring(0' 16)' NumberStyles.HexNumber);                  var n1 = ulong.Parse(fields[0].Substring(16' 16)' NumberStyles.HexNumber);                  var typeCodeData = ulong.Parse(fields[0].Substring(32' 16)' NumberStyles.HexNumber);                  string keyExt = null;                  switch (fields.Length)                  {                      default:                          throw new InvalidDataException("UniqueKey hex strings cannot contain more than one + separator.");                      case 1:                          break;                      case 2:                          if (fields[1] != "null")                          {                              keyExt = fields[1];                          }                          break;                  }                  return NewKey(n0' n1' typeCodeData' keyExt);              }
Magic Number,Orleans.Runtime,UniqueKey,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\IDs\UniqueKey.cs,NewKey,The following statement contains a magic number: var typeCodeData = ((ulong)category << 56) + ((ulong)typeData & 0x00FFFFFFFFFFFFFF);
Magic Number,Orleans.Runtime,UniqueKey,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\IDs\UniqueKey.cs,NewKey,The following statement contains a magic number: var n1 = BitConverter.ToUInt64(guidBytes' 8);
Magic Number,Orleans.Runtime,UniqueKey,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\IDs\UniqueKey.cs,NewSystemTargetKey,The following statement contains a magic number: var n1 = BitConverter.ToUInt64(guidBytes' 8);
Magic Number,Orleans.Runtime,UniqueKey,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\IDs\UniqueKey.cs,ToByteArray,The following statement contains a magic number: if (this.KeyExt != null)              {                  extBytes = Encoding.UTF8.GetBytes(KeyExt);                  // N0 + N1 + TypeCodeData + length(KeyExt in bytes) + KeyExt in bytes                  bytes = new byte[sizeof(ulong) * 3 + sizeof(int) + extBytes.Length];              }              else              {                  // N0 + N1 + TypeCodeData + length(-1)                  bytes = new byte[sizeof(ulong) * 3 + sizeof(int)];              }
Magic Number,Orleans.Runtime,UniqueKey,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\IDs\UniqueKey.cs,ToByteArray,The following statement contains a magic number: if (this.KeyExt != null)              {                  extBytes = Encoding.UTF8.GetBytes(KeyExt);                  // N0 + N1 + TypeCodeData + length(KeyExt in bytes) + KeyExt in bytes                  bytes = new byte[sizeof(ulong) * 3 + sizeof(int) + extBytes.Length];              }              else              {                  // N0 + N1 + TypeCodeData + length(-1)                  bytes = new byte[sizeof(ulong) * 3 + sizeof(int)];              }
Magic Number,Orleans.Runtime,UniqueKey,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\IDs\UniqueKey.cs,ConvertToGuid,The following statement contains a magic number: return new Guid((UInt32)(N0 & 0xffffffff)' (UInt16)(N0 >> 32)' (UInt16)(N0 >> 48)' (byte)N1' (byte)(N1 >> 8)' (byte)(N1 >> 16)' (byte)(N1 >> 24)' (byte)(N1 >> 32)' (byte)(N1 >> 40)' (byte)(N1 >> 48)' (byte)(N1 >> 56));
Magic Number,Orleans.Runtime,UniqueKey,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\IDs\UniqueKey.cs,ConvertToGuid,The following statement contains a magic number: return new Guid((UInt32)(N0 & 0xffffffff)' (UInt16)(N0 >> 32)' (UInt16)(N0 >> 48)' (byte)N1' (byte)(N1 >> 8)' (byte)(N1 >> 16)' (byte)(N1 >> 24)' (byte)(N1 >> 32)' (byte)(N1 >> 40)' (byte)(N1 >> 48)' (byte)(N1 >> 56));
Magic Number,Orleans.Runtime,UniqueKey,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\IDs\UniqueKey.cs,ConvertToGuid,The following statement contains a magic number: return new Guid((UInt32)(N0 & 0xffffffff)' (UInt16)(N0 >> 32)' (UInt16)(N0 >> 48)' (byte)N1' (byte)(N1 >> 8)' (byte)(N1 >> 16)' (byte)(N1 >> 24)' (byte)(N1 >> 32)' (byte)(N1 >> 40)' (byte)(N1 >> 48)' (byte)(N1 >> 56));
Magic Number,Orleans.Runtime,UniqueKey,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\IDs\UniqueKey.cs,ConvertToGuid,The following statement contains a magic number: return new Guid((UInt32)(N0 & 0xffffffff)' (UInt16)(N0 >> 32)' (UInt16)(N0 >> 48)' (byte)N1' (byte)(N1 >> 8)' (byte)(N1 >> 16)' (byte)(N1 >> 24)' (byte)(N1 >> 32)' (byte)(N1 >> 40)' (byte)(N1 >> 48)' (byte)(N1 >> 56));
Magic Number,Orleans.Runtime,UniqueKey,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\IDs\UniqueKey.cs,ConvertToGuid,The following statement contains a magic number: return new Guid((UInt32)(N0 & 0xffffffff)' (UInt16)(N0 >> 32)' (UInt16)(N0 >> 48)' (byte)N1' (byte)(N1 >> 8)' (byte)(N1 >> 16)' (byte)(N1 >> 24)' (byte)(N1 >> 32)' (byte)(N1 >> 40)' (byte)(N1 >> 48)' (byte)(N1 >> 56));
Magic Number,Orleans.Runtime,UniqueKey,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\IDs\UniqueKey.cs,ConvertToGuid,The following statement contains a magic number: return new Guid((UInt32)(N0 & 0xffffffff)' (UInt16)(N0 >> 32)' (UInt16)(N0 >> 48)' (byte)N1' (byte)(N1 >> 8)' (byte)(N1 >> 16)' (byte)(N1 >> 24)' (byte)(N1 >> 32)' (byte)(N1 >> 40)' (byte)(N1 >> 48)' (byte)(N1 >> 56));
Magic Number,Orleans.Runtime,UniqueKey,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\IDs\UniqueKey.cs,ConvertToGuid,The following statement contains a magic number: return new Guid((UInt32)(N0 & 0xffffffff)' (UInt16)(N0 >> 32)' (UInt16)(N0 >> 48)' (byte)N1' (byte)(N1 >> 8)' (byte)(N1 >> 16)' (byte)(N1 >> 24)' (byte)(N1 >> 32)' (byte)(N1 >> 40)' (byte)(N1 >> 48)' (byte)(N1 >> 56));
Magic Number,Orleans.Runtime,UniqueKey,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\IDs\UniqueKey.cs,ConvertToGuid,The following statement contains a magic number: return new Guid((UInt32)(N0 & 0xffffffff)' (UInt16)(N0 >> 32)' (UInt16)(N0 >> 48)' (byte)N1' (byte)(N1 >> 8)' (byte)(N1 >> 16)' (byte)(N1 >> 24)' (byte)(N1 >> 32)' (byte)(N1 >> 40)' (byte)(N1 >> 48)' (byte)(N1 >> 56));
Magic Number,Orleans.Runtime,UniqueKey,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\IDs\UniqueKey.cs,ConvertToGuid,The following statement contains a magic number: return new Guid((UInt32)(N0 & 0xffffffff)' (UInt16)(N0 >> 32)' (UInt16)(N0 >> 48)' (byte)N1' (byte)(N1 >> 8)' (byte)(N1 >> 16)' (byte)(N1 >> 24)' (byte)(N1 >> 32)' (byte)(N1 >> 40)' (byte)(N1 >> 48)' (byte)(N1 >> 56));
Magic Number,Orleans.Runtime,UniqueKey,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\IDs\UniqueKey.cs,GetCategory,The following statement contains a magic number: return (Category)((typeCodeData >> 56) & 0xFF);
Magic Number,Orleans.Core.Abstractions.Internal,Interner<K;T>,C:\repos\dotnet_orleans\src\Orleans.Core.Abstractions\Internal\Interner.cs,Interner,The following statement contains a magic number: int concurrencyLevel = Environment.ProcessorCount * 4;
