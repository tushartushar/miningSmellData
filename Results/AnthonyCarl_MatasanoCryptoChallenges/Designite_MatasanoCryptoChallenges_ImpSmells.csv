Implementation smell,Namespace,Class,File,Method,Description
Complex Method,MatasanoCryptoChallenges.Set1,Challenge1,C:\repos\AnthonyCarl_MatasanoCryptoChallenges\MatasanoCryptoChallenges\Set1\Challenge1.cs,ToBase64,Cyclomatic complexity of the method is 13
Complex Method,MatasanoCryptoChallenges.Set1,Challenge1,C:\repos\AnthonyCarl_MatasanoCryptoChallenges\MatasanoCryptoChallenges\Set1\Challenge1.cs,GetBytesFromCorrectLengthBase64,Cyclomatic complexity of the method is 10
Complex Method,MatasanoCryptoChallenges.Set1,Challenge5,C:\repos\AnthonyCarl_MatasanoCryptoChallenges\MatasanoCryptoChallenges\Set1\Challenge5.cs,RepeatingKeyXor,Cyclomatic complexity of the method is 9
Long Statement,MatasanoCryptoChallenges.Set1,Challenge1,C:\repos\AnthonyCarl_MatasanoCryptoChallenges\MatasanoCryptoChallenges\Set1\Challenge1.cs,ToBase64,The length of the statement  "		sb.Append (Base64Map [((bytes [byteFullChunkLength] & TwoLsbMask) << 4) | ((bytes [byteFullChunkLength + 1] & FourMsbMask) >> 4)]); " is 131.
Long Statement,MatasanoCryptoChallenges.Set1,Challenge1,C:\repos\AnthonyCarl_MatasanoCryptoChallenges\MatasanoCryptoChallenges\Set1\Challenge1.cs,GetBytesFromCorrectLengthBase64,The length of the statement  "	var base64PadCharCount = base64encoded [base64encoded.Length - 1] == Base64Pad ? (base64encoded [base64encoded.Length - 2] == Base64Pad ? 2 : 1) : 0; " is 149.
Long Statement,MatasanoCryptoChallenges.Set1,Challenge1,C:\repos\AnthonyCarl_MatasanoCryptoChallenges\MatasanoCryptoChallenges\Set1\Challenge1.cs,GetFirstByte,The length of the statement  "	return (byte)((Base64CharValueMap [base64encoded [chunkOffset]] << 2) | ((Base64CharValueMap [base64encoded [chunkOffset + 1]] >> 4))); " is 135.
Long Statement,MatasanoCryptoChallenges.Set1,Challenge1,C:\repos\AnthonyCarl_MatasanoCryptoChallenges\MatasanoCryptoChallenges\Set1\Challenge1.cs,GetSecondByte,The length of the statement  "	return (byte)((Base64CharValueMap [base64encoded [chunkOffset + 1]] << 4) | (Base64CharValueMap [base64encoded [chunkOffset + 2]] >> 2)); " is 137.
Long Statement,MatasanoCryptoChallenges.Set1,Challenge1,C:\repos\AnthonyCarl_MatasanoCryptoChallenges\MatasanoCryptoChallenges\Set1\Challenge1.cs,GetThirdByte,The length of the statement  "	return (byte)((Base64CharValueMap [base64encoded [chunkOffset + 2]] << 6) | Base64CharValueMap [base64encoded [chunkOffset + 3]]); " is 130.
Long Statement,MatasanoCryptoChallenges.Set1,Challenge1,C:\repos\AnthonyCarl_MatasanoCryptoChallenges\MatasanoCryptoChallenges\Set1\Challenge1.cs,ToByte,The length of the statement  "		throw new ArgumentOutOfRangeException ("twoHexCharsForSingleByte"' twoHexCharsForSingleByte.Length' "The hex value for the byte must consist of exactly two characters."); " is 170.
Long Statement,MatasanoCryptoChallenges.Set1,Challenge3,C:\repos\AnthonyCarl_MatasanoCryptoChallenges\MatasanoCryptoChallenges\Set1\Challenge3.cs,GetBestGuessSingleByteXorKey,The length of the statement  "	var bestGuess = Enumerable.Range (0' byte.MaxValue + 1).Select (x => GetResult (source' (byte)x)).Aggregate ((x' y) => x.WeightedValue > y.WeightedValue ? x : y); " is 162.
Long Statement,MatasanoCryptoChallenges.Set1,Challenge3Result,C:\repos\AnthonyCarl_MatasanoCryptoChallenges\MatasanoCryptoChallenges\Set1\Challenge3Result.cs,CalculateWeight,The length of the statement  "	var commonLetterWeight = EnglishCommonUpperLettersAscending.Select ((c' i) => decryptedMessage.Count (x => char.ToUpperInvariant (x) == c) * (i + 1) * CommonLetterFactor).Sum (); " is 178.
Long Statement,MatasanoCryptoChallenges.Set1,Challenge4,C:\repos\AnthonyCarl_MatasanoCryptoChallenges\MatasanoCryptoChallenges\Set1\Challenge4.cs,GetBestGuessSingleByteEncryptedHex,The length of the statement  "	var bestGuess = encryptedHexData.AsParallel ().Select (x => new Challenge4Result (x' Challenge3.GetBestGuessSingleByteXorKey (x))).Aggregate ((x' y) => x.WeightedValue > y.WeightedValue ? x : y); " is 195.
Magic Number,MatasanoCryptoChallenges.Set1,Challenge1,C:\repos\AnthonyCarl_MatasanoCryptoChallenges\MatasanoCryptoChallenges\Set1\Challenge1.cs,ByteHexToByteArray,The following statement contains a magic number: if (hex.Length % 2 != 0) {  	throw new ArgumentException ("Hex string length must be an even number.");  }  
Magic Number,MatasanoCryptoChallenges.Set1,Challenge1,C:\repos\AnthonyCarl_MatasanoCryptoChallenges\MatasanoCryptoChallenges\Set1\Challenge1.cs,ByteHexToByteArray,The following statement contains a magic number: using (var sr = new StringReader (hex)) {  	var buffer = new char[2];  	for (int i = 0; i < byteArray.Length; i++) {  		sr.Read (buffer' 0' 2);  		//In case using the framework Convert.ToByte() is considered "cheating"  		byteArray [i] = ToByte (buffer);  		//byteArray[i] = Convert.ToByte(new string(buffer)' 16);  	}  }  
Magic Number,MatasanoCryptoChallenges.Set1,Challenge1,C:\repos\AnthonyCarl_MatasanoCryptoChallenges\MatasanoCryptoChallenges\Set1\Challenge1.cs,ByteHexToByteArray,The following statement contains a magic number: using (var sr = new StringReader (hex)) {  	var buffer = new char[2];  	for (int i = 0; i < byteArray.Length; i++) {  		sr.Read (buffer' 0' 2);  		//In case using the framework Convert.ToByte() is considered "cheating"  		byteArray [i] = ToByte (buffer);  		//byteArray[i] = Convert.ToByte(new string(buffer)' 16);  	}  }  
Magic Number,MatasanoCryptoChallenges.Set1,Challenge1,C:\repos\AnthonyCarl_MatasanoCryptoChallenges\MatasanoCryptoChallenges\Set1\Challenge1.cs,ByteHexToByteArray,The following statement contains a magic number: for (int i = 0; i < byteArray.Length; i++) {  	sr.Read (buffer' 0' 2);  	//In case using the framework Convert.ToByte() is considered "cheating"  	byteArray [i] = ToByte (buffer);  	//byteArray[i] = Convert.ToByte(new string(buffer)' 16);  }  
Magic Number,MatasanoCryptoChallenges.Set1,Challenge1,C:\repos\AnthonyCarl_MatasanoCryptoChallenges\MatasanoCryptoChallenges\Set1\Challenge1.cs,ByteHexToByteArray,The following statement contains a magic number: sr.Read (buffer' 0' 2);  
Magic Number,MatasanoCryptoChallenges.Set1,Challenge1,C:\repos\AnthonyCarl_MatasanoCryptoChallenges\MatasanoCryptoChallenges\Set1\Challenge1.cs,ToBase64,The following statement contains a magic number: for (int i = 0; i < byteFullChunkLength; i += ByteChunkSize) {  	sb.Append (Base64Map [(bytes [i] & SixMsbMask) >> 2]);  	sb.Append (Base64Map [((bytes [i] & TwoLsbMask) << 4) | ((bytes [i + 1] & FourMsbMask) >> 4)]);  	sb.Append (Base64Map [((bytes [i + 1] & FourLsbMask) << 2) | ((bytes [i + 2] & TwoMsbMask) >> 6)]);  	sb.Append (Base64Map [(bytes [i + 2] & SixLsbMask)]);  }  
Magic Number,MatasanoCryptoChallenges.Set1,Challenge1,C:\repos\AnthonyCarl_MatasanoCryptoChallenges\MatasanoCryptoChallenges\Set1\Challenge1.cs,ToBase64,The following statement contains a magic number: for (int i = 0; i < byteFullChunkLength; i += ByteChunkSize) {  	sb.Append (Base64Map [(bytes [i] & SixMsbMask) >> 2]);  	sb.Append (Base64Map [((bytes [i] & TwoLsbMask) << 4) | ((bytes [i + 1] & FourMsbMask) >> 4)]);  	sb.Append (Base64Map [((bytes [i + 1] & FourLsbMask) << 2) | ((bytes [i + 2] & TwoMsbMask) >> 6)]);  	sb.Append (Base64Map [(bytes [i + 2] & SixLsbMask)]);  }  
Magic Number,MatasanoCryptoChallenges.Set1,Challenge1,C:\repos\AnthonyCarl_MatasanoCryptoChallenges\MatasanoCryptoChallenges\Set1\Challenge1.cs,ToBase64,The following statement contains a magic number: for (int i = 0; i < byteFullChunkLength; i += ByteChunkSize) {  	sb.Append (Base64Map [(bytes [i] & SixMsbMask) >> 2]);  	sb.Append (Base64Map [((bytes [i] & TwoLsbMask) << 4) | ((bytes [i + 1] & FourMsbMask) >> 4)]);  	sb.Append (Base64Map [((bytes [i + 1] & FourLsbMask) << 2) | ((bytes [i + 2] & TwoMsbMask) >> 6)]);  	sb.Append (Base64Map [(bytes [i + 2] & SixLsbMask)]);  }  
Magic Number,MatasanoCryptoChallenges.Set1,Challenge1,C:\repos\AnthonyCarl_MatasanoCryptoChallenges\MatasanoCryptoChallenges\Set1\Challenge1.cs,ToBase64,The following statement contains a magic number: for (int i = 0; i < byteFullChunkLength; i += ByteChunkSize) {  	sb.Append (Base64Map [(bytes [i] & SixMsbMask) >> 2]);  	sb.Append (Base64Map [((bytes [i] & TwoLsbMask) << 4) | ((bytes [i + 1] & FourMsbMask) >> 4)]);  	sb.Append (Base64Map [((bytes [i + 1] & FourLsbMask) << 2) | ((bytes [i + 2] & TwoMsbMask) >> 6)]);  	sb.Append (Base64Map [(bytes [i + 2] & SixLsbMask)]);  }  
Magic Number,MatasanoCryptoChallenges.Set1,Challenge1,C:\repos\AnthonyCarl_MatasanoCryptoChallenges\MatasanoCryptoChallenges\Set1\Challenge1.cs,ToBase64,The following statement contains a magic number: for (int i = 0; i < byteFullChunkLength; i += ByteChunkSize) {  	sb.Append (Base64Map [(bytes [i] & SixMsbMask) >> 2]);  	sb.Append (Base64Map [((bytes [i] & TwoLsbMask) << 4) | ((bytes [i + 1] & FourMsbMask) >> 4)]);  	sb.Append (Base64Map [((bytes [i + 1] & FourLsbMask) << 2) | ((bytes [i + 2] & TwoMsbMask) >> 6)]);  	sb.Append (Base64Map [(bytes [i + 2] & SixLsbMask)]);  }  
Magic Number,MatasanoCryptoChallenges.Set1,Challenge1,C:\repos\AnthonyCarl_MatasanoCryptoChallenges\MatasanoCryptoChallenges\Set1\Challenge1.cs,ToBase64,The following statement contains a magic number: for (int i = 0; i < byteFullChunkLength; i += ByteChunkSize) {  	sb.Append (Base64Map [(bytes [i] & SixMsbMask) >> 2]);  	sb.Append (Base64Map [((bytes [i] & TwoLsbMask) << 4) | ((bytes [i + 1] & FourMsbMask) >> 4)]);  	sb.Append (Base64Map [((bytes [i + 1] & FourLsbMask) << 2) | ((bytes [i + 2] & TwoMsbMask) >> 6)]);  	sb.Append (Base64Map [(bytes [i + 2] & SixLsbMask)]);  }  
Magic Number,MatasanoCryptoChallenges.Set1,Challenge1,C:\repos\AnthonyCarl_MatasanoCryptoChallenges\MatasanoCryptoChallenges\Set1\Challenge1.cs,ToBase64,The following statement contains a magic number: for (int i = 0; i < byteFullChunkLength; i += ByteChunkSize) {  	sb.Append (Base64Map [(bytes [i] & SixMsbMask) >> 2]);  	sb.Append (Base64Map [((bytes [i] & TwoLsbMask) << 4) | ((bytes [i + 1] & FourMsbMask) >> 4)]);  	sb.Append (Base64Map [((bytes [i + 1] & FourLsbMask) << 2) | ((bytes [i + 2] & TwoMsbMask) >> 6)]);  	sb.Append (Base64Map [(bytes [i + 2] & SixLsbMask)]);  }  
Magic Number,MatasanoCryptoChallenges.Set1,Challenge1,C:\repos\AnthonyCarl_MatasanoCryptoChallenges\MatasanoCryptoChallenges\Set1\Challenge1.cs,ToBase64,The following statement contains a magic number: sb.Append (Base64Map [(bytes [i] & SixMsbMask) >> 2]);  
Magic Number,MatasanoCryptoChallenges.Set1,Challenge1,C:\repos\AnthonyCarl_MatasanoCryptoChallenges\MatasanoCryptoChallenges\Set1\Challenge1.cs,ToBase64,The following statement contains a magic number: sb.Append (Base64Map [((bytes [i] & TwoLsbMask) << 4) | ((bytes [i + 1] & FourMsbMask) >> 4)]);  
Magic Number,MatasanoCryptoChallenges.Set1,Challenge1,C:\repos\AnthonyCarl_MatasanoCryptoChallenges\MatasanoCryptoChallenges\Set1\Challenge1.cs,ToBase64,The following statement contains a magic number: sb.Append (Base64Map [((bytes [i] & TwoLsbMask) << 4) | ((bytes [i + 1] & FourMsbMask) >> 4)]);  
Magic Number,MatasanoCryptoChallenges.Set1,Challenge1,C:\repos\AnthonyCarl_MatasanoCryptoChallenges\MatasanoCryptoChallenges\Set1\Challenge1.cs,ToBase64,The following statement contains a magic number: sb.Append (Base64Map [((bytes [i + 1] & FourLsbMask) << 2) | ((bytes [i + 2] & TwoMsbMask) >> 6)]);  
Magic Number,MatasanoCryptoChallenges.Set1,Challenge1,C:\repos\AnthonyCarl_MatasanoCryptoChallenges\MatasanoCryptoChallenges\Set1\Challenge1.cs,ToBase64,The following statement contains a magic number: sb.Append (Base64Map [((bytes [i + 1] & FourLsbMask) << 2) | ((bytes [i + 2] & TwoMsbMask) >> 6)]);  
Magic Number,MatasanoCryptoChallenges.Set1,Challenge1,C:\repos\AnthonyCarl_MatasanoCryptoChallenges\MatasanoCryptoChallenges\Set1\Challenge1.cs,ToBase64,The following statement contains a magic number: sb.Append (Base64Map [((bytes [i + 1] & FourLsbMask) << 2) | ((bytes [i + 2] & TwoMsbMask) >> 6)]);  
Magic Number,MatasanoCryptoChallenges.Set1,Challenge1,C:\repos\AnthonyCarl_MatasanoCryptoChallenges\MatasanoCryptoChallenges\Set1\Challenge1.cs,ToBase64,The following statement contains a magic number: sb.Append (Base64Map [(bytes [i + 2] & SixLsbMask)]);  
Magic Number,MatasanoCryptoChallenges.Set1,Challenge1,C:\repos\AnthonyCarl_MatasanoCryptoChallenges\MatasanoCryptoChallenges\Set1\Challenge1.cs,ToBase64,The following statement contains a magic number: switch (leftoverBytes) {  case 2:  	sb.Append (Base64Map [(bytes [byteFullChunkLength] & SixMsbMask) >> 2]);  	sb.Append (Base64Map [((bytes [byteFullChunkLength] & TwoLsbMask) << 4) | ((bytes [byteFullChunkLength + 1] & FourMsbMask) >> 4)]);  	sb.Append (Base64Map [(bytes [byteFullChunkLength + 1] & FourLsbMask) << 2]);  	sb.Append (Base64Pad);  	break;  case 1:  	sb.Append (Base64Map [(bytes [byteFullChunkLength] & SixMsbMask) >> 2]);  	sb.Append (Base64Map [(bytes [byteFullChunkLength] & TwoLsbMask) << 4]);  	sb.Append (Base64Pad);  	sb.Append (Base64Pad);  	break;  }  
Magic Number,MatasanoCryptoChallenges.Set1,Challenge1,C:\repos\AnthonyCarl_MatasanoCryptoChallenges\MatasanoCryptoChallenges\Set1\Challenge1.cs,ToBase64,The following statement contains a magic number: switch (leftoverBytes) {  case 2:  	sb.Append (Base64Map [(bytes [byteFullChunkLength] & SixMsbMask) >> 2]);  	sb.Append (Base64Map [((bytes [byteFullChunkLength] & TwoLsbMask) << 4) | ((bytes [byteFullChunkLength + 1] & FourMsbMask) >> 4)]);  	sb.Append (Base64Map [(bytes [byteFullChunkLength + 1] & FourLsbMask) << 2]);  	sb.Append (Base64Pad);  	break;  case 1:  	sb.Append (Base64Map [(bytes [byteFullChunkLength] & SixMsbMask) >> 2]);  	sb.Append (Base64Map [(bytes [byteFullChunkLength] & TwoLsbMask) << 4]);  	sb.Append (Base64Pad);  	sb.Append (Base64Pad);  	break;  }  
Magic Number,MatasanoCryptoChallenges.Set1,Challenge1,C:\repos\AnthonyCarl_MatasanoCryptoChallenges\MatasanoCryptoChallenges\Set1\Challenge1.cs,ToBase64,The following statement contains a magic number: switch (leftoverBytes) {  case 2:  	sb.Append (Base64Map [(bytes [byteFullChunkLength] & SixMsbMask) >> 2]);  	sb.Append (Base64Map [((bytes [byteFullChunkLength] & TwoLsbMask) << 4) | ((bytes [byteFullChunkLength + 1] & FourMsbMask) >> 4)]);  	sb.Append (Base64Map [(bytes [byteFullChunkLength + 1] & FourLsbMask) << 2]);  	sb.Append (Base64Pad);  	break;  case 1:  	sb.Append (Base64Map [(bytes [byteFullChunkLength] & SixMsbMask) >> 2]);  	sb.Append (Base64Map [(bytes [byteFullChunkLength] & TwoLsbMask) << 4]);  	sb.Append (Base64Pad);  	sb.Append (Base64Pad);  	break;  }  
Magic Number,MatasanoCryptoChallenges.Set1,Challenge1,C:\repos\AnthonyCarl_MatasanoCryptoChallenges\MatasanoCryptoChallenges\Set1\Challenge1.cs,ToBase64,The following statement contains a magic number: switch (leftoverBytes) {  case 2:  	sb.Append (Base64Map [(bytes [byteFullChunkLength] & SixMsbMask) >> 2]);  	sb.Append (Base64Map [((bytes [byteFullChunkLength] & TwoLsbMask) << 4) | ((bytes [byteFullChunkLength + 1] & FourMsbMask) >> 4)]);  	sb.Append (Base64Map [(bytes [byteFullChunkLength + 1] & FourLsbMask) << 2]);  	sb.Append (Base64Pad);  	break;  case 1:  	sb.Append (Base64Map [(bytes [byteFullChunkLength] & SixMsbMask) >> 2]);  	sb.Append (Base64Map [(bytes [byteFullChunkLength] & TwoLsbMask) << 4]);  	sb.Append (Base64Pad);  	sb.Append (Base64Pad);  	break;  }  
Magic Number,MatasanoCryptoChallenges.Set1,Challenge1,C:\repos\AnthonyCarl_MatasanoCryptoChallenges\MatasanoCryptoChallenges\Set1\Challenge1.cs,ToBase64,The following statement contains a magic number: switch (leftoverBytes) {  case 2:  	sb.Append (Base64Map [(bytes [byteFullChunkLength] & SixMsbMask) >> 2]);  	sb.Append (Base64Map [((bytes [byteFullChunkLength] & TwoLsbMask) << 4) | ((bytes [byteFullChunkLength + 1] & FourMsbMask) >> 4)]);  	sb.Append (Base64Map [(bytes [byteFullChunkLength + 1] & FourLsbMask) << 2]);  	sb.Append (Base64Pad);  	break;  case 1:  	sb.Append (Base64Map [(bytes [byteFullChunkLength] & SixMsbMask) >> 2]);  	sb.Append (Base64Map [(bytes [byteFullChunkLength] & TwoLsbMask) << 4]);  	sb.Append (Base64Pad);  	sb.Append (Base64Pad);  	break;  }  
Magic Number,MatasanoCryptoChallenges.Set1,Challenge1,C:\repos\AnthonyCarl_MatasanoCryptoChallenges\MatasanoCryptoChallenges\Set1\Challenge1.cs,ToBase64,The following statement contains a magic number: switch (leftoverBytes) {  case 2:  	sb.Append (Base64Map [(bytes [byteFullChunkLength] & SixMsbMask) >> 2]);  	sb.Append (Base64Map [((bytes [byteFullChunkLength] & TwoLsbMask) << 4) | ((bytes [byteFullChunkLength + 1] & FourMsbMask) >> 4)]);  	sb.Append (Base64Map [(bytes [byteFullChunkLength + 1] & FourLsbMask) << 2]);  	sb.Append (Base64Pad);  	break;  case 1:  	sb.Append (Base64Map [(bytes [byteFullChunkLength] & SixMsbMask) >> 2]);  	sb.Append (Base64Map [(bytes [byteFullChunkLength] & TwoLsbMask) << 4]);  	sb.Append (Base64Pad);  	sb.Append (Base64Pad);  	break;  }  
Magic Number,MatasanoCryptoChallenges.Set1,Challenge1,C:\repos\AnthonyCarl_MatasanoCryptoChallenges\MatasanoCryptoChallenges\Set1\Challenge1.cs,ToBase64,The following statement contains a magic number: switch (leftoverBytes) {  case 2:  	sb.Append (Base64Map [(bytes [byteFullChunkLength] & SixMsbMask) >> 2]);  	sb.Append (Base64Map [((bytes [byteFullChunkLength] & TwoLsbMask) << 4) | ((bytes [byteFullChunkLength + 1] & FourMsbMask) >> 4)]);  	sb.Append (Base64Map [(bytes [byteFullChunkLength + 1] & FourLsbMask) << 2]);  	sb.Append (Base64Pad);  	break;  case 1:  	sb.Append (Base64Map [(bytes [byteFullChunkLength] & SixMsbMask) >> 2]);  	sb.Append (Base64Map [(bytes [byteFullChunkLength] & TwoLsbMask) << 4]);  	sb.Append (Base64Pad);  	sb.Append (Base64Pad);  	break;  }  
Magic Number,MatasanoCryptoChallenges.Set1,Challenge1,C:\repos\AnthonyCarl_MatasanoCryptoChallenges\MatasanoCryptoChallenges\Set1\Challenge1.cs,ToBase64,The following statement contains a magic number: sb.Append (Base64Map [(bytes [byteFullChunkLength] & SixMsbMask) >> 2]);  
Magic Number,MatasanoCryptoChallenges.Set1,Challenge1,C:\repos\AnthonyCarl_MatasanoCryptoChallenges\MatasanoCryptoChallenges\Set1\Challenge1.cs,ToBase64,The following statement contains a magic number: sb.Append (Base64Map [((bytes [byteFullChunkLength] & TwoLsbMask) << 4) | ((bytes [byteFullChunkLength + 1] & FourMsbMask) >> 4)]);  
Magic Number,MatasanoCryptoChallenges.Set1,Challenge1,C:\repos\AnthonyCarl_MatasanoCryptoChallenges\MatasanoCryptoChallenges\Set1\Challenge1.cs,ToBase64,The following statement contains a magic number: sb.Append (Base64Map [((bytes [byteFullChunkLength] & TwoLsbMask) << 4) | ((bytes [byteFullChunkLength + 1] & FourMsbMask) >> 4)]);  
Magic Number,MatasanoCryptoChallenges.Set1,Challenge1,C:\repos\AnthonyCarl_MatasanoCryptoChallenges\MatasanoCryptoChallenges\Set1\Challenge1.cs,ToBase64,The following statement contains a magic number: sb.Append (Base64Map [(bytes [byteFullChunkLength + 1] & FourLsbMask) << 2]);  
Magic Number,MatasanoCryptoChallenges.Set1,Challenge1,C:\repos\AnthonyCarl_MatasanoCryptoChallenges\MatasanoCryptoChallenges\Set1\Challenge1.cs,ToBase64,The following statement contains a magic number: sb.Append (Base64Map [(bytes [byteFullChunkLength] & SixMsbMask) >> 2]);  
Magic Number,MatasanoCryptoChallenges.Set1,Challenge1,C:\repos\AnthonyCarl_MatasanoCryptoChallenges\MatasanoCryptoChallenges\Set1\Challenge1.cs,ToBase64,The following statement contains a magic number: sb.Append (Base64Map [(bytes [byteFullChunkLength] & TwoLsbMask) << 4]);  
Magic Number,MatasanoCryptoChallenges.Set1,Challenge1,C:\repos\AnthonyCarl_MatasanoCryptoChallenges\MatasanoCryptoChallenges\Set1\Challenge1.cs,GetBytesFromCorrectLengthBase64,The following statement contains a magic number: using (var ms = new MemoryStream (bytes)) {  	for (int i = 0; i < byteFullChunkLength; i += Base64ChunkSize) {  		ms.WriteByte (GetFirstByte (base64encoded' i));  		ms.WriteByte (GetSecondByte (base64encoded' i));  		ms.WriteByte (GetThirdByte (base64encoded' i));  	}  	switch (base64PadCharCount) {  	case 1:  		ms.WriteByte (GetFirstByte (base64encoded' byteFullChunkLength));  		ms.WriteByte (GetSecondByte (base64encoded' byteFullChunkLength));  		break;  	case 2:  		ms.WriteByte (GetFirstByte (base64encoded' byteFullChunkLength));  		break;  	}  	return ms.ToArray ();  }  
Magic Number,MatasanoCryptoChallenges.Set1,Challenge1,C:\repos\AnthonyCarl_MatasanoCryptoChallenges\MatasanoCryptoChallenges\Set1\Challenge1.cs,GetBytesFromCorrectLengthBase64,The following statement contains a magic number: switch (base64PadCharCount) {  case 1:  	ms.WriteByte (GetFirstByte (base64encoded' byteFullChunkLength));  	ms.WriteByte (GetSecondByte (base64encoded' byteFullChunkLength));  	break;  case 2:  	ms.WriteByte (GetFirstByte (base64encoded' byteFullChunkLength));  	break;  }  
Magic Number,MatasanoCryptoChallenges.Set1,Challenge1,C:\repos\AnthonyCarl_MatasanoCryptoChallenges\MatasanoCryptoChallenges\Set1\Challenge1.cs,GetFirstByte,The following statement contains a magic number: return (byte)((Base64CharValueMap [base64encoded [chunkOffset]] << 2) | ((Base64CharValueMap [base64encoded [chunkOffset + 1]] >> 4)));  
Magic Number,MatasanoCryptoChallenges.Set1,Challenge1,C:\repos\AnthonyCarl_MatasanoCryptoChallenges\MatasanoCryptoChallenges\Set1\Challenge1.cs,GetFirstByte,The following statement contains a magic number: return (byte)((Base64CharValueMap [base64encoded [chunkOffset]] << 2) | ((Base64CharValueMap [base64encoded [chunkOffset + 1]] >> 4)));  
Magic Number,MatasanoCryptoChallenges.Set1,Challenge1,C:\repos\AnthonyCarl_MatasanoCryptoChallenges\MatasanoCryptoChallenges\Set1\Challenge1.cs,GetSecondByte,The following statement contains a magic number: return (byte)((Base64CharValueMap [base64encoded [chunkOffset + 1]] << 4) | (Base64CharValueMap [base64encoded [chunkOffset + 2]] >> 2));  
Magic Number,MatasanoCryptoChallenges.Set1,Challenge1,C:\repos\AnthonyCarl_MatasanoCryptoChallenges\MatasanoCryptoChallenges\Set1\Challenge1.cs,GetSecondByte,The following statement contains a magic number: return (byte)((Base64CharValueMap [base64encoded [chunkOffset + 1]] << 4) | (Base64CharValueMap [base64encoded [chunkOffset + 2]] >> 2));  
Magic Number,MatasanoCryptoChallenges.Set1,Challenge1,C:\repos\AnthonyCarl_MatasanoCryptoChallenges\MatasanoCryptoChallenges\Set1\Challenge1.cs,GetSecondByte,The following statement contains a magic number: return (byte)((Base64CharValueMap [base64encoded [chunkOffset + 1]] << 4) | (Base64CharValueMap [base64encoded [chunkOffset + 2]] >> 2));  
Magic Number,MatasanoCryptoChallenges.Set1,Challenge1,C:\repos\AnthonyCarl_MatasanoCryptoChallenges\MatasanoCryptoChallenges\Set1\Challenge1.cs,GetThirdByte,The following statement contains a magic number: return (byte)((Base64CharValueMap [base64encoded [chunkOffset + 2]] << 6) | Base64CharValueMap [base64encoded [chunkOffset + 3]]);  
Magic Number,MatasanoCryptoChallenges.Set1,Challenge1,C:\repos\AnthonyCarl_MatasanoCryptoChallenges\MatasanoCryptoChallenges\Set1\Challenge1.cs,GetThirdByte,The following statement contains a magic number: return (byte)((Base64CharValueMap [base64encoded [chunkOffset + 2]] << 6) | Base64CharValueMap [base64encoded [chunkOffset + 3]]);  
Magic Number,MatasanoCryptoChallenges.Set1,Challenge1,C:\repos\AnthonyCarl_MatasanoCryptoChallenges\MatasanoCryptoChallenges\Set1\Challenge1.cs,GetThirdByte,The following statement contains a magic number: return (byte)((Base64CharValueMap [base64encoded [chunkOffset + 2]] << 6) | Base64CharValueMap [base64encoded [chunkOffset + 3]]);  
Magic Number,MatasanoCryptoChallenges.Set1,Challenge1,C:\repos\AnthonyCarl_MatasanoCryptoChallenges\MatasanoCryptoChallenges\Set1\Challenge1.cs,ToByte,The following statement contains a magic number: if (twoHexCharsForSingleByte.Length != 2) {  	throw new ArgumentOutOfRangeException ("twoHexCharsForSingleByte"' twoHexCharsForSingleByte.Length' "The hex value for the byte must consist of exactly two characters.");  }  
Magic Number,MatasanoCryptoChallenges.Set1,Challenge6,C:\repos\AnthonyCarl_MatasanoCryptoChallenges\MatasanoCryptoChallenges\Set1\Challenge6.cs,GenerateSetBitsCountMap,The following statement contains a magic number: for (byte currentByte = 0; currentByte < byte.MaxValue; currentByte++) {  	result [currentByte] = Enumerable.Range (0' 8).Count (j => IsBitSet (currentByte' j));  }  
Magic Number,MatasanoCryptoChallenges.Set1,Challenge6,C:\repos\AnthonyCarl_MatasanoCryptoChallenges\MatasanoCryptoChallenges\Set1\Challenge6.cs,GenerateSetBitsCountMap,The following statement contains a magic number: result [currentByte] = Enumerable.Range (0' 8).Count (j => IsBitSet (currentByte' j));  
Missing Default,MatasanoCryptoChallenges.Set1,Challenge1,C:\repos\AnthonyCarl_MatasanoCryptoChallenges\MatasanoCryptoChallenges\Set1\Challenge1.cs,ToBase64,The following switch statement is missing a default case: switch (leftoverBytes) {  case 2:  	sb.Append (Base64Map [(bytes [byteFullChunkLength] & SixMsbMask) >> 2]);  	sb.Append (Base64Map [((bytes [byteFullChunkLength] & TwoLsbMask) << 4) | ((bytes [byteFullChunkLength + 1] & FourMsbMask) >> 4)]);  	sb.Append (Base64Map [(bytes [byteFullChunkLength + 1] & FourLsbMask) << 2]);  	sb.Append (Base64Pad);  	break;  case 1:  	sb.Append (Base64Map [(bytes [byteFullChunkLength] & SixMsbMask) >> 2]);  	sb.Append (Base64Map [(bytes [byteFullChunkLength] & TwoLsbMask) << 4]);  	sb.Append (Base64Pad);  	sb.Append (Base64Pad);  	break;  }  
Missing Default,MatasanoCryptoChallenges.Set1,Challenge1,C:\repos\AnthonyCarl_MatasanoCryptoChallenges\MatasanoCryptoChallenges\Set1\Challenge1.cs,GetBytesFromCorrectLengthBase64,The following switch statement is missing a default case: switch (base64PadCharCount) {  case 1:  	ms.WriteByte (GetFirstByte (base64encoded' byteFullChunkLength));  	ms.WriteByte (GetSecondByte (base64encoded' byteFullChunkLength));  	break;  case 2:  	ms.WriteByte (GetFirstByte (base64encoded' byteFullChunkLength));  	break;  }  
