Implementation smell,Namespace,Class,File,Method,Description
Long Method,Amib.Threading,SmartThreadPool,F:\newReposMay17\amibar_SmartThreadPool\SmartThreadPool\SmartThreadPool.cs,ProcessQueuedItems,The method has 123 lines of code.
Complex Method,Amib.Threading.Internal,WorkItem,F:\newReposMay17\amibar_SmartThreadPool\SmartThreadPool\WorkItem.cs,IsValidStatesTransition,Cyclomatic complexity of the method is 12
Complex Method,Amib.Threading.Internal,WorkItem,F:\newReposMay17\amibar_SmartThreadPool\SmartThreadPool\WorkItem.cs,Execute,Cyclomatic complexity of the method is 11
Complex Method,Amib.Threading.Internal,WorkItem,F:\newReposMay17\amibar_SmartThreadPool\SmartThreadPool\WorkItem.cs,WaitAll,Cyclomatic complexity of the method is 8
Complex Method,Amib.Threading.Internal,WorkItem,F:\newReposMay17\amibar_SmartThreadPool\SmartThreadPool\WorkItem.cs,GetResult,Cyclomatic complexity of the method is 13
Complex Method,Amib.Threading,SmartThreadPool,F:\newReposMay17\amibar_SmartThreadPool\SmartThreadPool\SmartThreadPool.cs,ProcessQueuedItems,Cyclomatic complexity of the method is 10
Complex Method,Amib.Threading,SmartThreadPool,F:\newReposMay17\amibar_SmartThreadPool\SmartThreadPool\SmartThreadPool.cs,Shutdown,Cyclomatic complexity of the method is 11
Long Parameter List,Amib.Threading.Internal,WorkItemFactory,F:\newReposMay17\amibar_SmartThreadPool\SmartThreadPool\WorkItemFactory.cs,CreateWorkItem,The method has 5 parameters.
Long Parameter List,Amib.Threading.Internal,WorkItemFactory,F:\newReposMay17\amibar_SmartThreadPool\SmartThreadPool\WorkItemFactory.cs,CreateWorkItem,The method has 5 parameters.
Long Parameter List,Amib.Threading.Internal,WorkItemFactory,F:\newReposMay17\amibar_SmartThreadPool\SmartThreadPool\WorkItemFactory.cs,CreateWorkItem,The method has 5 parameters.
Long Parameter List,Amib.Threading.Internal,WorkItemFactory,F:\newReposMay17\amibar_SmartThreadPool\SmartThreadPool\WorkItemFactory.cs,CreateWorkItem,The method has 6 parameters.
Long Parameter List,Amib.Threading.Internal,WorkItemFactory,F:\newReposMay17\amibar_SmartThreadPool\SmartThreadPool\WorkItemFactory.cs,CreateWorkItem,The method has 6 parameters.
Long Parameter List,Amib.Threading.Internal,WorkItemFactory,F:\newReposMay17\amibar_SmartThreadPool\SmartThreadPool\WorkItemFactory.cs,CreateWorkItem,The method has 7 parameters.
Long Parameter List,Amib.Threading.Internal,WorkItemsGroupBase,F:\newReposMay17\amibar_SmartThreadPool\SmartThreadPool\WorkItemsGroupBase.cs,QueueWorkItem,The method has 5 parameters.
Long Parameter List,Amib.Threading.Internal,WorkItemsGroupBase,F:\newReposMay17\amibar_SmartThreadPool\SmartThreadPool\WorkItemsGroupBase.cs,QueueWorkItem,The method has 5 parameters.
Long Parameter List,Amib.Threading.Internal,WorkItemsGroupBase,F:\newReposMay17\amibar_SmartThreadPool\SmartThreadPool\WorkItemsGroupBase.cs,QueueWorkItem,The method has 6 parameters.
Long Parameter List,Amib.Threading.Internal,WorkItemsGroupBase,F:\newReposMay17\amibar_SmartThreadPool\SmartThreadPool\WorkItemsGroupBase.cs,QueueWorkItem,The method has 5 parameters.
Long Parameter List,Amib.Threading.Internal,WorkItemsGroupBase,F:\newReposMay17\amibar_SmartThreadPool\SmartThreadPool\WorkItemsGroupBase.cs,QueueWorkItem,The method has 6 parameters.
Long Parameter List,Amib.Threading,IWorkItemsGroup,F:\newReposMay17\amibar_SmartThreadPool\SmartThreadPool\Interfaces.cs,QueueWorkItem,The method has 5 parameters.
Long Parameter List,Amib.Threading,IWorkItemsGroup,F:\newReposMay17\amibar_SmartThreadPool\SmartThreadPool\Interfaces.cs,QueueWorkItem,The method has 5 parameters.
Long Parameter List,Amib.Threading,IWorkItemsGroup,F:\newReposMay17\amibar_SmartThreadPool\SmartThreadPool\Interfaces.cs,QueueWorkItem,The method has 6 parameters.
Long Parameter List,Amib.Threading,IWorkItemsGroup,F:\newReposMay17\amibar_SmartThreadPool\SmartThreadPool\Interfaces.cs,QueueWorkItem,The method has 5 parameters.
Long Parameter List,Amib.Threading,IWorkItemsGroup,F:\newReposMay17\amibar_SmartThreadPool\SmartThreadPool\Interfaces.cs,QueueWorkItem,The method has 6 parameters.
Long Identifier,Amib.Threading,SmartThreadPool,F:\newReposMay17\amibar_SmartThreadPool\SmartThreadPool\SmartThreadPool.cs,ProcessQueuedItems,The length of the parameter bInUseWorkerThreadsWasIncremented is 33.
Long Statement,Amib.Threading.Internal,CallerThreadContext,F:\newReposMay17\amibar_SmartThreadPool\SmartThreadPool\CallerThreadContext.cs,Capture,The length of the statement  "		callerThreadContext._callContext = (LogicalCallContext)getLogicalCallContextMethodInfo.Invoke (Thread.CurrentThread' null); " is 123.
Long Statement,Amib.Threading.Internal,STPPerformanceCounters,F:\newReposMay17\amibar_SmartThreadPool\SmartThreadPool\STPPerformanceCounter.cs,SetupCategory,The length of the statement  "		PerformanceCounterCategory.Create (_stpCategoryName' _stpCategoryHelp' PerformanceCounterCategoryType.MultiInstance' counters); " is 127.
Long Statement,Amib.Threading.Internal,STPInstancePerformanceCounters,F:\newReposMay17\amibar_SmartThreadPool\SmartThreadPool\STPPerformanceCounter.cs,SampleWorkItemsProcessTime,The length of the statement  "	GetCounter (STPPerformanceCounterType.AvgWorkItemProcessTime).IncrementBy ((long)workItemProcessTime.TotalMilliseconds); " is 120.
Long Statement,Amib.Threading.Internal,WorkItem,F:\newReposMay17\amibar_SmartThreadPool\SmartThreadPool\WorkItem.cs,Initialize,The length of the statement  "	_expirationTime = _workItemInfo.Timeout > 0 ? DateTime.UtcNow.Ticks + _workItemInfo.Timeout * TimeSpan.TicksPerMillisecond : long.MaxValue; " is 139.
Long Statement,Amib.Threading.Internal,WorkItem,F:\newReposMay17\amibar_SmartThreadPool\SmartThreadPool\WorkItem.cs,StartingWorkItem,The length of the statement  "			if ((_workItemInfo.PostExecuteWorkItemCallback != null) && ((_workItemInfo.CallToPostExecute & CallToPostExecute.WhenWorkItemCanceled) == CallToPostExecute.WhenWorkItemCanceled)) { " is 180.
Long Statement,Amib.Threading.Internal,WorkItemsGroupBase,F:\newReposMay17\amibar_SmartThreadPool\SmartThreadPool\WorkItemsGroupBase.cs,QueueWorkItem,The length of the statement  "	WorkItem workItem = WorkItemFactory.CreateWorkItem (this' WIGStartInfo' callback' state' postExecuteWorkItemCallback' workItemPriority); " is 136.
Long Statement,Amib.Threading.Internal,WorkItemsGroupBase,F:\newReposMay17\amibar_SmartThreadPool\SmartThreadPool\WorkItemsGroupBase.cs,QueueWorkItem,The length of the statement  "	WorkItem workItem = WorkItemFactory.CreateWorkItem (this' WIGStartInfo' callback' state' postExecuteWorkItemCallback' callToPostExecute); " is 137.
Long Statement,Amib.Threading.Internal,WorkItemsGroupBase,F:\newReposMay17\amibar_SmartThreadPool\SmartThreadPool\WorkItemsGroupBase.cs,QueueWorkItem,The length of the statement  "	WorkItem workItem = WorkItemFactory.CreateWorkItem (this' WIGStartInfo' callback' state' postExecuteWorkItemCallback' callToPostExecute' workItemPriority); " is 155.
Long Statement,Amib.Threading,SmartThreadPool,F:\newReposMay17\amibar_SmartThreadPool\SmartThreadPool\SmartThreadPool.cs,Initialize,The length of the statement  "                throw new NotSupportedException("Performance counters are not implemented for Compact Framework/Silverlight/Mono' instead use StpStartInfo.EnableLocalPerformanceCounters");" is 172.
Long Statement,Amib.Threading,SmartThreadPool,F:\newReposMay17\amibar_SmartThreadPool\SmartThreadPool\SmartThreadPool.cs,ValidateSTPStartInfo,The length of the statement  "		throw new ArgumentOutOfRangeException ("MinWorkerThreads' maxWorkerThreads"' "MaxWorkerThreads must be greater or equal to MinWorkerThreads"); " is 142.
Long Statement,Amib.Threading,SmartThreadPool,F:\newReposMay17\amibar_SmartThreadPool\SmartThreadPool\SmartThreadPool.cs,StartThreads,The length of the statement  "			Thread workerThread = _stpStartInfo.MaxStackSize.HasValue ? new Thread (ProcessQueuedItems' _stpStartInfo.MaxStackSize.Value) : new Thread (ProcessQueuedItems); " is 160.
Long Statement,Amib.Threading,SmartThreadPool,F:\newReposMay17\amibar_SmartThreadPool\SmartThreadPool\SmartThreadPool.cs,ValidateWaitForIdle,The length of the statement  "		throw new NotSupportedException ("WaitForIdle cannot be called from a thread on its SmartThreadPool' it causes a deadlock"); " is 124.
Long Statement,Amib.Threading,SmartThreadPool,F:\newReposMay17\amibar_SmartThreadPool\SmartThreadPool\SmartThreadPool.cs,ValidateWorkItemsGroupWaitForIdle,The length of the statement  "	if ((null != workItemsGroup) && (null != workItem) && CurrentThreadEntry.CurrentWorkItem.WasQueuedBy (workItemsGroup)) { " is 120.
Long Statement,Amib.Threading,SmartThreadPool,F:\newReposMay17\amibar_SmartThreadPool\SmartThreadPool\SmartThreadPool.cs,ValidateWorkItemsGroupWaitForIdle,The length of the statement  "		throw new NotSupportedException ("WaitForIdle cannot be called from a thread on its SmartThreadPool' it causes a deadlock"); " is 124.
Long Statement,Amib.Threading,SmartThreadPool,F:\newReposMay17\amibar_SmartThreadPool\SmartThreadPool\SmartThreadPool.cs,ValidateWorkItemsGroupWaitForIdleImpl,The length of the statement  "		throw new NotSupportedException ("WaitForIdle cannot be called from a thread on its SmartThreadPool' it causes a deadlock"); " is 124.
Empty Catch Block,Amib.Threading.Internal,WorkItem,F:\newReposMay17\amibar_SmartThreadPool\SmartThreadPool\WorkItem.cs,FireWorkItemCompleted,The method has an empty catch block.
Empty Catch Block,Amib.Threading.Internal,WorkItem,F:\newReposMay17\amibar_SmartThreadPool\SmartThreadPool\WorkItem.cs,FireWorkItemStarted,The method has an empty catch block.
Empty Catch Block,Amib.Threading.Internal,WorkItemsGroup,F:\newReposMay17\amibar_SmartThreadPool\SmartThreadPool\WorkItemsGroup.cs,FireOnIdleImpl,The method has an empty catch block.
Magic Number,Amib.Threading.Internal,WorkItem,F:\newReposMay17\amibar_SmartThreadPool\SmartThreadPool\WorkItem.cs,ExecuteWorkItem,The following statement contains a magic number: try {  	try {  		result = _callback (_state);  	} catch (Exception e) {  		// Save the exception so we can rethrow it later  		exception = e;  	}  	// Remove the value of the execution thread' so it will be impossible to cancel the work item'  	// since it is already completed.  	// Cancelling a work item that already completed may cause the abortion of the next work item!!!  	Thread executionThread = Interlocked.CompareExchange (ref _executingThread' null' _executingThread);  	if (null == executionThread) {  		// Oops! we are going to be aborted...' Wait here so we can catch the ThreadAbortException  		Thread.Sleep (60 * 1000);  		// If after 1 minute this thread was not aborted then let it continue working.  	}  } // We must treat the ThreadAbortException or else it will be stored in the exception variable  catch (ThreadAbortException tae) {  	tae.GetHashCode ();  	// Check if the work item was cancelled  	// If we got a ThreadAbortException and the STP is not shutting down' it means the   	// work items was cancelled.  	if (!SmartThreadPool.CurrentThreadEntry.AssociatedSmartThreadPool.IsShuttingdown) {  		#if !(_WINDOWS_CE) && !(_SILVERLIGHT) && !(WINDOWS_PHONE)  		Thread.ResetAbort ();  		#endif  	}  }  
Magic Number,Amib.Threading.Internal,WorkItem,F:\newReposMay17\amibar_SmartThreadPool\SmartThreadPool\WorkItem.cs,ExecuteWorkItem,The following statement contains a magic number: try {  	try {  		result = _callback (_state);  	} catch (Exception e) {  		// Save the exception so we can rethrow it later  		exception = e;  	}  	// Remove the value of the execution thread' so it will be impossible to cancel the work item'  	// since it is already completed.  	// Cancelling a work item that already completed may cause the abortion of the next work item!!!  	Thread executionThread = Interlocked.CompareExchange (ref _executingThread' null' _executingThread);  	if (null == executionThread) {  		// Oops! we are going to be aborted...' Wait here so we can catch the ThreadAbortException  		Thread.Sleep (60 * 1000);  		// If after 1 minute this thread was not aborted then let it continue working.  	}  } // We must treat the ThreadAbortException or else it will be stored in the exception variable  catch (ThreadAbortException tae) {  	tae.GetHashCode ();  	// Check if the work item was cancelled  	// If we got a ThreadAbortException and the STP is not shutting down' it means the   	// work items was cancelled.  	if (!SmartThreadPool.CurrentThreadEntry.AssociatedSmartThreadPool.IsShuttingdown) {  		#if !(_WINDOWS_CE) && !(_SILVERLIGHT) && !(WINDOWS_PHONE)  		Thread.ResetAbort ();  		#endif  	}  }  
Magic Number,Amib.Threading.Internal,WorkItem,F:\newReposMay17\amibar_SmartThreadPool\SmartThreadPool\WorkItem.cs,ExecuteWorkItem,The following statement contains a magic number: if (null == executionThread) {  	// Oops! we are going to be aborted...' Wait here so we can catch the ThreadAbortException  	Thread.Sleep (60 * 1000);  	// If after 1 minute this thread was not aborted then let it continue working.  }  
Magic Number,Amib.Threading.Internal,WorkItem,F:\newReposMay17\amibar_SmartThreadPool\SmartThreadPool\WorkItem.cs,ExecuteWorkItem,The following statement contains a magic number: if (null == executionThread) {  	// Oops! we are going to be aborted...' Wait here so we can catch the ThreadAbortException  	Thread.Sleep (60 * 1000);  	// If after 1 minute this thread was not aborted then let it continue working.  }  
Magic Number,Amib.Threading.Internal,WorkItem,F:\newReposMay17\amibar_SmartThreadPool\SmartThreadPool\WorkItem.cs,ExecuteWorkItem,The following statement contains a magic number: Thread.Sleep (60 * 1000);  
Magic Number,Amib.Threading.Internal,WorkItem,F:\newReposMay17\amibar_SmartThreadPool\SmartThreadPool\WorkItem.cs,ExecuteWorkItem,The following statement contains a magic number: Thread.Sleep (60 * 1000);  
Magic Number,Amib.Threading.Internal,WorkItem,F:\newReposMay17\amibar_SmartThreadPool\SmartThreadPool\WorkItem.cs,WaitAll,The following statement contains a magic number: if ((null == cancelWaitHandle) && (waitHandles.Length <= 64)) {  	success = STPEventWaitHandle.WaitAll (waitHandles' millisecondsTimeout' exitContext);  } else {  	success = true;  	int millisecondsLeft = millisecondsTimeout;  	Stopwatch stopwatch = Stopwatch.StartNew ();  	WaitHandle[] whs;  	if (null != cancelWaitHandle) {  		whs = new WaitHandle[] {  			null'  			cancelWaitHandle  		};  	} else {  		whs = new WaitHandle[] {  			null  		};  	}  	bool waitInfinitely = (Timeout.Infinite == millisecondsTimeout);  	// Iterate over the wait handles and wait for each one to complete.  	// We cannot use WaitHandle.WaitAll directly' because the cancelWaitHandle  	// won't affect it.  	// Each iteration we update the time left for the timeout.  	for (int i = 0; i < waitableResults.Length; ++i) {  		// WaitAny don't work with negative numbers  		if (!waitInfinitely && (millisecondsLeft < 0)) {  			success = false;  			break;  		}  		whs [0] = waitHandles [i];  		int result = STPEventWaitHandle.WaitAny (whs' millisecondsLeft' exitContext);  		if ((result > 0) || (STPEventWaitHandle.WaitTimeout == result)) {  			success = false;  			break;  		}  		if (!waitInfinitely) {  			// Update the time left to wait  			millisecondsLeft = millisecondsTimeout - (int)stopwatch.ElapsedMilliseconds;  		}  	}  }  
Missing Default,Amib.Threading.Internal,WorkItem,F:\newReposMay17\amibar_SmartThreadPool\SmartThreadPool\WorkItem.cs,Cancel,The following switch statement is missing a default case: switch (GetWorkItemState ()) {  case WorkItemState.Canceled:  	//Debug.WriteLine("Work item already canceled");  	if (abortExecution) {  		Thread executionThread = Interlocked.CompareExchange (ref _executingThread' null' _executingThread);  		if (null != executionThread) {  			executionThread.Abort ();  			// "Cancel"  			// No need to signalComplete' because we already cancelled this work item  			// so it already signaled its completion.  			//signalComplete = true;  		}  	}  	success = true;  	break;  case WorkItemState.Completed:  	//Debug.WriteLine("Work item cannot be canceled");  	break;  case WorkItemState.InProgress:  	if (abortExecution) {  		Thread executionThread = Interlocked.CompareExchange (ref _executingThread' null' _executingThread);  		if (null != executionThread) {  			executionThread.Abort ();  			// "Cancel"  			success = true;  			signalComplete = true;  		}  	} else {  		success = true;  		signalComplete = true;  	}  	break;  case WorkItemState.InQueue:  	// Signal to the wait for completion that the work  	// item has been completed (canceled). There is no  	// reason to wait for it to get out of the queue  	signalComplete = true;  	//Debug.WriteLine("Work item canceled");  	success = true;  	break;  }  
