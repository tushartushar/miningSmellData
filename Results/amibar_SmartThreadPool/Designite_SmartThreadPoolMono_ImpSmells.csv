Implementation smell,Namespace,Class,File,Method,Description
Long Method,Amib.Threading,SmartThreadPool,C:\repos\amibar_SmartThreadPool\SmartThreadPool\SmartThreadPool.cs,ProcessQueuedItems,The method has 146 lines of code.
Complex Method,Amib.Threading,SmartThreadPool,C:\repos\amibar_SmartThreadPool\SmartThreadPool\SmartThreadPool.cs,Shutdown,Cyclomatic complexity of the method is 9
Long Parameter List,Amib.Threading.Internal,WorkItemFactory,C:\repos\amibar_SmartThreadPool\SmartThreadPool\WorkItemFactory.cs,CreateWorkItem,The method has 5 parameters. Parameters: workItemsGroup' wigStartInfo' callback' state' workItemPriority
Long Parameter List,Amib.Threading.Internal,WorkItemFactory,C:\repos\amibar_SmartThreadPool\SmartThreadPool\WorkItemFactory.cs,CreateWorkItem,The method has 5 parameters. Parameters: workItemsGroup' wigStartInfo' workItemInfo' callback' state
Long Parameter List,Amib.Threading.Internal,WorkItemFactory,C:\repos\amibar_SmartThreadPool\SmartThreadPool\WorkItemFactory.cs,CreateWorkItem,The method has 5 parameters. Parameters: workItemsGroup' wigStartInfo' callback' state' postExecuteWorkItemCallback
Long Parameter List,Amib.Threading.Internal,WorkItemFactory,C:\repos\amibar_SmartThreadPool\SmartThreadPool\WorkItemFactory.cs,CreateWorkItem,The method has 6 parameters. Parameters: workItemsGroup' wigStartInfo' callback' state' postExecuteWorkItemCallback' workItemPriority
Long Parameter List,Amib.Threading.Internal,WorkItemFactory,C:\repos\amibar_SmartThreadPool\SmartThreadPool\WorkItemFactory.cs,CreateWorkItem,The method has 6 parameters. Parameters: workItemsGroup' wigStartInfo' callback' state' postExecuteWorkItemCallback' callToPostExecute
Long Parameter List,Amib.Threading.Internal,WorkItemFactory,C:\repos\amibar_SmartThreadPool\SmartThreadPool\WorkItemFactory.cs,CreateWorkItem,The method has 7 parameters. Parameters: workItemsGroup' wigStartInfo' callback' state' postExecuteWorkItemCallback' callToPostExecute' workItemPriority
Long Parameter List,Amib.Threading.Internal,WorkItemsGroupBase,C:\repos\amibar_SmartThreadPool\SmartThreadPool\WorkItemsGroupBase.cs,QueueWorkItem,The method has 5 parameters. Parameters: callback' state' postExecuteWorkItemCallback' callToPostExecute' workItemPriority
Long Parameter List,Amib.Threading.Internal,WorkItemsGroupBase,C:\repos\amibar_SmartThreadPool\SmartThreadPool\WorkItemsGroupBase.cs,QueueWorkItem,The method has 5 parameters. Parameters: action' arg1' arg2' arg3' priority
Long Parameter List,Amib.Threading.Internal,WorkItemsGroupBase,C:\repos\amibar_SmartThreadPool\SmartThreadPool\WorkItemsGroupBase.cs,QueueWorkItem,The method has 6 parameters. Parameters: action' arg1' arg2' arg3' arg4' priority
Long Parameter List,Amib.Threading.Internal,WorkItemsGroupBase,C:\repos\amibar_SmartThreadPool\SmartThreadPool\WorkItemsGroupBase.cs,QueueWorkItem,The method has 5 parameters. Parameters: func' arg1' arg2' arg3' priority
Long Parameter List,Amib.Threading.Internal,WorkItemsGroupBase,C:\repos\amibar_SmartThreadPool\SmartThreadPool\WorkItemsGroupBase.cs,QueueWorkItem,The method has 6 parameters. Parameters: func' arg1' arg2' arg3' arg4' priority
Long Parameter List,Amib.Threading,IWorkItemsGroup,C:\repos\amibar_SmartThreadPool\SmartThreadPool\Interfaces.cs,QueueWorkItem,The method has 5 parameters. Parameters: callback' state' postExecuteWorkItemCallback' callToPostExecute' workItemPriority
Long Parameter List,Amib.Threading,IWorkItemsGroup,C:\repos\amibar_SmartThreadPool\SmartThreadPool\Interfaces.cs,QueueWorkItem,The method has 5 parameters. Parameters: action' arg1' arg2' arg3' priority
Long Parameter List,Amib.Threading,IWorkItemsGroup,C:\repos\amibar_SmartThreadPool\SmartThreadPool\Interfaces.cs,QueueWorkItem,The method has 6 parameters. Parameters: action' arg1' arg2' arg3' arg4' priority
Long Parameter List,Amib.Threading,IWorkItemsGroup,C:\repos\amibar_SmartThreadPool\SmartThreadPool\Interfaces.cs,QueueWorkItem,The method has 5 parameters. Parameters: func' arg1' arg2' arg3' priority
Long Parameter List,Amib.Threading,IWorkItemsGroup,C:\repos\amibar_SmartThreadPool\SmartThreadPool\Interfaces.cs,QueueWorkItem,The method has 6 parameters. Parameters: func' arg1' arg2' arg3' arg4' priority
Long Identifier,Amib.Threading.Internal,CallerThreadContext,C:\repos\amibar_SmartThreadPool\SmartThreadPool\CallerThreadContext.cs,,The length of the parameter getLogicalCallContextMethodInfo is 31.
Long Identifier,Amib.Threading.Internal,CallerThreadContext,C:\repos\amibar_SmartThreadPool\SmartThreadPool\CallerThreadContext.cs,,The length of the parameter setLogicalCallContextMethodInfo is 31.
Long Identifier,Amib.Threading.Internal,STPInstancePerformanceCounters,C:\repos\amibar_SmartThreadPool\SmartThreadPool\STPPerformanceCounter.cs,,The length of the parameter _stpInstanceNullPerformanceCounter is 34.
Long Identifier,Amib.Threading,SmartThreadPool,C:\repos\amibar_SmartThreadPool\SmartThreadPool\SmartThreadPool.cs,ProcessQueuedItems,The length of the parameter bInUseWorkerThreadsWasIncremented is 33.
Long Identifier,Amib.Threading,SmartThreadPool,C:\repos\amibar_SmartThreadPool\SmartThreadPool\SmartThreadPool.cs,,The length of the parameter DefaultPostExecuteWorkItemCallback is 34.
Long Identifier,Amib.Threading,SmartThreadPool,C:\repos\amibar_SmartThreadPool\SmartThreadPool\SmartThreadPool.cs,,The length of the parameter DefaultPerformanceCounterInstanceName is 37.
Long Identifier,Amib.Threading,STPInstancePerformanceCounters,C:\repos\amibar_SmartThreadPool\SmartThreadPool\STPPerformanceCounter.cs,,The length of the parameter _stpInstanceNullPerformanceCounter is 34.
Long Identifier,Amib.Threading,STPStartInfo,C:\repos\amibar_SmartThreadPool\SmartThreadPool\STPStartInfo.cs,,The length of the parameter _performanceCounterInstanceName is 31.
Long Identifier,Amib.Threading,STPStartInfo,C:\repos\amibar_SmartThreadPool\SmartThreadPool\STPStartInfo.cs,,The length of the parameter _enableLocalPerformanceCounters is 31.
Long Statement,Amib.Threading.Internal,CallerThreadContext,C:\repos\amibar_SmartThreadPool\SmartThreadPool\CallerThreadContext.cs,Capture,The length of the statement  "				callerThreadContext._callContext = (LogicalCallContext)getLogicalCallContextMethodInfo.Invoke(Thread.CurrentThread' null); " is 122.
Long Statement,Amib.Threading.Internal,WorkItemsGroupBase,C:\repos\amibar_SmartThreadPool\SmartThreadPool\WorkItemsGroupBase.cs,QueueWorkItem,The length of the statement  "            WorkItem workItem = WorkItemFactory.CreateWorkItem(this' WIGStartInfo' callback' state' postExecuteWorkItemCallback' workItemPriority); " is 135.
Long Statement,Amib.Threading.Internal,WorkItemsGroupBase,C:\repos\amibar_SmartThreadPool\SmartThreadPool\WorkItemsGroupBase.cs,QueueWorkItem,The length of the statement  "            WorkItem workItem = WorkItemFactory.CreateWorkItem(this' WIGStartInfo' callback' state' postExecuteWorkItemCallback' callToPostExecute); " is 136.
Long Statement,Amib.Threading.Internal,WorkItemsGroupBase,C:\repos\amibar_SmartThreadPool\SmartThreadPool\WorkItemsGroupBase.cs,QueueWorkItem,The length of the statement  "            WorkItem workItem = WorkItemFactory.CreateWorkItem(this' WIGStartInfo' callback' state' postExecuteWorkItemCallback' callToPostExecute' workItemPriority); " is 154.
Long Statement,Amib.Threading,SmartThreadPool,C:\repos\amibar_SmartThreadPool\SmartThreadPool\SmartThreadPool.cs,Initialize,The length of the statement  "                throw new NotSupportedException("Performance counters are not implemented for Compact Framework/Silverlight/Mono' instead use StpStartInfo.EnableLocalPerformanceCounters"); " is 172.
Long Statement,Amib.Threading,SmartThreadPool,C:\repos\amibar_SmartThreadPool\SmartThreadPool\SmartThreadPool.cs,ValidateWorkItemsGroupWaitForIdle,The length of the statement  "				throw new NotSupportedException("WaitForIdle cannot be called from a thread on its SmartThreadPool' it causes a deadlock"); " is 123.
Long Statement,Amib.Threading,SmartThreadPool,C:\repos\amibar_SmartThreadPool\SmartThreadPool\SmartThreadPool.cs,ValidateWorkItemsGroupWaitForIdleImpl,The length of the statement  "				throw new NotSupportedException("WaitForIdle cannot be called from a thread on its SmartThreadPool' it causes a deadlock"); " is 123.
Long Statement,Amib.Threading,SmartThreadPool,C:\repos\amibar_SmartThreadPool\SmartThreadPool\SmartThreadPool.cs,Choice,The length of the statement  "                workItemsGroup.QueueWorkItem(() => { act(); Interlocked.CompareExchange(ref choiceIndex._index' value' -1); anActionCompleted.Set(); }); " is 136.
Empty Catch Block,Amib.Threading.Internal,WorkItem,C:\repos\amibar_SmartThreadPool\SmartThreadPool\WorkItem.WorkItemResult.cs,FireWorkItemCompleted,The method has an empty catch block.
Empty Catch Block,Amib.Threading.Internal,WorkItem,C:\repos\amibar_SmartThreadPool\SmartThreadPool\WorkItem.WorkItemResult.cs,FireWorkItemStarted,The method has an empty catch block.
Empty Catch Block,Amib.Threading.Internal,WorkItemsGroup,C:\repos\amibar_SmartThreadPool\SmartThreadPool\WorkItemsGroup.cs,FireOnIdleImpl,The method has an empty catch block.
Magic Number,Amib.Threading.Internal,WorkItem,C:\repos\amibar_SmartThreadPool\SmartThreadPool\WorkItem.WorkItemResult.cs,ExecuteWorkItem,The following statement contains a magic number: try              {                  try                  {                      result = _callback(_state);                  }                  catch (Exception e)                  {                      // Save the exception so we can rethrow it later                      exception = e;                  }                    // Remove the value of the execution thread' so it will be impossible to cancel the work item'                  // since it is already completed.                  // Cancelling a work item that already completed may cause the abortion of the next work item!!!                  Thread executionThread = Interlocked.CompareExchange(ref _executingThread' null' _executingThread);                    if (null == executionThread)                  {                      // Oops! we are going to be aborted...' Wait here so we can catch the ThreadAbortException                      Thread.Sleep(60 * 1000);                        // If after 1 minute this thread was not aborted then let it continue working.                  }              }              // We must treat the ThreadAbortException or else it will be stored in the exception variable              catch (ThreadAbortException tae)              {                  tae.GetHashCode();                  // Check if the work item was cancelled                  // If we got a ThreadAbortException and the STP is not shutting down' it means the                   // work items was cancelled.                  if (!SmartThreadPool.CurrentThreadEntry.AssociatedSmartThreadPool.IsShuttingdown)                  {  #if !(_WINDOWS_CE) && !(_SILVERLIGHT) && !(WINDOWS_PHONE)                      Thread.ResetAbort();  #endif                  }              }
Magic Number,Amib.Threading.Internal,WorkItem,C:\repos\amibar_SmartThreadPool\SmartThreadPool\WorkItem.WorkItemResult.cs,ExecuteWorkItem,The following statement contains a magic number: try              {                  try                  {                      result = _callback(_state);                  }                  catch (Exception e)                  {                      // Save the exception so we can rethrow it later                      exception = e;                  }                    // Remove the value of the execution thread' so it will be impossible to cancel the work item'                  // since it is already completed.                  // Cancelling a work item that already completed may cause the abortion of the next work item!!!                  Thread executionThread = Interlocked.CompareExchange(ref _executingThread' null' _executingThread);                    if (null == executionThread)                  {                      // Oops! we are going to be aborted...' Wait here so we can catch the ThreadAbortException                      Thread.Sleep(60 * 1000);                        // If after 1 minute this thread was not aborted then let it continue working.                  }              }              // We must treat the ThreadAbortException or else it will be stored in the exception variable              catch (ThreadAbortException tae)              {                  tae.GetHashCode();                  // Check if the work item was cancelled                  // If we got a ThreadAbortException and the STP is not shutting down' it means the                   // work items was cancelled.                  if (!SmartThreadPool.CurrentThreadEntry.AssociatedSmartThreadPool.IsShuttingdown)                  {  #if !(_WINDOWS_CE) && !(_SILVERLIGHT) && !(WINDOWS_PHONE)                      Thread.ResetAbort();  #endif                  }              }
Magic Number,Amib.Threading.Internal,WorkItem,C:\repos\amibar_SmartThreadPool\SmartThreadPool\WorkItem.WorkItemResult.cs,WaitAll,The following statement contains a magic number: if ((null == cancelWaitHandle) && (waitHandles.Length <= 64))              {                  success = STPEventWaitHandle.WaitAll(waitHandles' millisecondsTimeout' exitContext);              }              else              {                  success = true;                  int millisecondsLeft = millisecondsTimeout;                  Stopwatch stopwatch = Stopwatch.StartNew();                    WaitHandle[] whs;                  if (null != cancelWaitHandle)                  {                      whs = new WaitHandle[] { null' cancelWaitHandle };                  }                  else                  {                      whs = new WaitHandle[] { null };                  }                    bool waitInfinitely = (Timeout.Infinite == millisecondsTimeout);                  // Iterate over the wait handles and wait for each one to complete.                  // We cannot use WaitHandle.WaitAll directly' because the cancelWaitHandle                  // won't affect it.                  // Each iteration we update the time left for the timeout.                  for (int i = 0; i < waitableResults.Length; ++i)                  {                      // WaitAny don't work with negative numbers                      if (!waitInfinitely && (millisecondsLeft < 0))                      {                          success = false;                          break;                      }                        whs[0] = waitHandles[i];                      int result = STPEventWaitHandle.WaitAny(whs' millisecondsLeft' exitContext);                      if ((result > 0) || (STPEventWaitHandle.WaitTimeout == result))                      {                          success = false;                          break;                      }                        if (!waitInfinitely)                      {                          // Update the time left to wait                          millisecondsLeft = millisecondsTimeout - (int)stopwatch.ElapsedMilliseconds;                      }                  }              }
Missing Default,Amib.Threading.Internal,WorkItem,C:\repos\amibar_SmartThreadPool\SmartThreadPool\WorkItem.WorkItemResult.cs,Cancel,The following switch statement is missing a default case: switch (GetWorkItemState())                  {                      case WorkItemState.Canceled:                          //Debug.WriteLine("Work item already canceled");                          if (abortExecution)                          {                              Thread executionThread = Interlocked.CompareExchange(ref _executingThread' null' _executingThread);                              if (null != executionThread)                              {                                  executionThread.Abort(); // "Cancel"                                  // No need to signalComplete' because we already cancelled this work item                                  // so it already signaled its completion.                                  //signalComplete = true;                              }                          }                           success = true;                          break;                      case WorkItemState.Completed:                          //Debug.WriteLine("Work item cannot be canceled");                          break;                      case WorkItemState.InProgress:                          if (abortExecution)                          {                              Thread executionThread = Interlocked.CompareExchange(ref _executingThread' null' _executingThread);                              if (null != executionThread)                              {                                  executionThread.Abort(); // "Cancel"                                  success = true;                                  signalComplete = true;                              }                          }                          else                          {                              success = true;                              signalComplete = true;                          }                          break;                      case WorkItemState.InQueue:                          // Signal to the wait for completion that the work                          // item has been completed (canceled). There is no                          // reason to wait for it to get out of the queue                          signalComplete = true;                          //Debug.WriteLine("Work item canceled");                          success = true;                          break;                  }
