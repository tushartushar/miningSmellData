Implementation smell,Namespace,Class,File,Method,Description
Complex Method,DotSquish,Alpha,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Alpha.cs,CompressAlphaDxt5,Cyclomatic complexity of the method is 12
Complex Method,DotSquish,ClusterFit,C:\repos\Rogueadyn_SaintCoinach\DotSquish\ClusterFit.cs,ConstructOrdering,Cyclomatic complexity of the method is 9
Complex Method,DotSquish,ColourSet,C:\repos\Rogueadyn_SaintCoinach\DotSquish\ColourSet.cs,ColourSet,Cyclomatic complexity of the method is 8
Long Parameter List,DotSquish,Alpha,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Alpha.cs,WriteAlphaBlock,The method has 5 parameters. Parameters: alpha0' alpha1' indices' target' targetOffset
Long Parameter List,DotSquish,Alpha,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Alpha.cs,WriteAlphaBlock5,The method has 5 parameters. Parameters: alpha0' alpha1' indices' target' targetOffset
Long Parameter List,DotSquish,Alpha,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Alpha.cs,WriteAlphaBlock7,The method has 5 parameters. Parameters: alpha0' alpha1' indices' target' targetOffset
Long Parameter List,DotSquish,Squish,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Squish.cs,DecompressImage,The method has 5 parameters. Parameters: blocks' offset' width' height' flags
Long Parameter List,DotSquish,Squish,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Squish.cs,DecompressToBitmap,The method has 5 parameters. Parameters: blocks' offset' width' height' flags
Long Parameter List,DotSquish,Squish,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Squish.cs,CompressImage,The method has 5 parameters. Parameters: input' output' width' height' flags
Long Parameter List,DotSquish,Squish,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Squish.cs,DecompressImage,The method has 5 parameters. Parameters: input' output' width' height' flags
Long Statement,DotSquish,SquishOptionsExtensions,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Flags.cs,GetFit,The length of the statement  "            return (self & (SquishOptions.ColourIterativeClusterFit | SquishOptions.ColourClusterFit | SquishOptions.ColourRangeFit)); " is 122.
Magic Number,DotSquish,Alpha,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Alpha.cs,CompressAlphaDxt3,The following statement contains a magic number: for (int i = 0; i < 8; ++i) {                  // Qnatise down to 4 bits.                  var alpha1 = rgba[8 * i + 3] * (15f / 255f);                  var alpha2 = rgba[8 * i + 7] * (15f / 255f);                  var quant1 = FloatToInt(alpha1' 15);                  var quant2 = FloatToInt(alpha2' 15);                    // Set alpha to zero where masked.                  var bit1 = 1 << (2 * i);                  var bit2 = 1 << (2 * i + 1);                  if ((mask & bit1) == 0)                      quant1 = 0;                  if ((mask & bit2) == 0)                      quant2 = 0;                    // Pack into the byte.                  target[targetOffset + i] = (byte)(quant1 | (quant2 << 4));              }
Magic Number,DotSquish,Alpha,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Alpha.cs,CompressAlphaDxt3,The following statement contains a magic number: for (int i = 0; i < 8; ++i) {                  // Qnatise down to 4 bits.                  var alpha1 = rgba[8 * i + 3] * (15f / 255f);                  var alpha2 = rgba[8 * i + 7] * (15f / 255f);                  var quant1 = FloatToInt(alpha1' 15);                  var quant2 = FloatToInt(alpha2' 15);                    // Set alpha to zero where masked.                  var bit1 = 1 << (2 * i);                  var bit2 = 1 << (2 * i + 1);                  if ((mask & bit1) == 0)                      quant1 = 0;                  if ((mask & bit2) == 0)                      quant2 = 0;                    // Pack into the byte.                  target[targetOffset + i] = (byte)(quant1 | (quant2 << 4));              }
Magic Number,DotSquish,Alpha,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Alpha.cs,CompressAlphaDxt3,The following statement contains a magic number: for (int i = 0; i < 8; ++i) {                  // Qnatise down to 4 bits.                  var alpha1 = rgba[8 * i + 3] * (15f / 255f);                  var alpha2 = rgba[8 * i + 7] * (15f / 255f);                  var quant1 = FloatToInt(alpha1' 15);                  var quant2 = FloatToInt(alpha2' 15);                    // Set alpha to zero where masked.                  var bit1 = 1 << (2 * i);                  var bit2 = 1 << (2 * i + 1);                  if ((mask & bit1) == 0)                      quant1 = 0;                  if ((mask & bit2) == 0)                      quant2 = 0;                    // Pack into the byte.                  target[targetOffset + i] = (byte)(quant1 | (quant2 << 4));              }
Magic Number,DotSquish,Alpha,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Alpha.cs,CompressAlphaDxt3,The following statement contains a magic number: for (int i = 0; i < 8; ++i) {                  // Qnatise down to 4 bits.                  var alpha1 = rgba[8 * i + 3] * (15f / 255f);                  var alpha2 = rgba[8 * i + 7] * (15f / 255f);                  var quant1 = FloatToInt(alpha1' 15);                  var quant2 = FloatToInt(alpha2' 15);                    // Set alpha to zero where masked.                  var bit1 = 1 << (2 * i);                  var bit2 = 1 << (2 * i + 1);                  if ((mask & bit1) == 0)                      quant1 = 0;                  if ((mask & bit2) == 0)                      quant2 = 0;                    // Pack into the byte.                  target[targetOffset + i] = (byte)(quant1 | (quant2 << 4));              }
Magic Number,DotSquish,Alpha,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Alpha.cs,CompressAlphaDxt3,The following statement contains a magic number: for (int i = 0; i < 8; ++i) {                  // Qnatise down to 4 bits.                  var alpha1 = rgba[8 * i + 3] * (15f / 255f);                  var alpha2 = rgba[8 * i + 7] * (15f / 255f);                  var quant1 = FloatToInt(alpha1' 15);                  var quant2 = FloatToInt(alpha2' 15);                    // Set alpha to zero where masked.                  var bit1 = 1 << (2 * i);                  var bit2 = 1 << (2 * i + 1);                  if ((mask & bit1) == 0)                      quant1 = 0;                  if ((mask & bit2) == 0)                      quant2 = 0;                    // Pack into the byte.                  target[targetOffset + i] = (byte)(quant1 | (quant2 << 4));              }
Magic Number,DotSquish,Alpha,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Alpha.cs,CompressAlphaDxt3,The following statement contains a magic number: for (int i = 0; i < 8; ++i) {                  // Qnatise down to 4 bits.                  var alpha1 = rgba[8 * i + 3] * (15f / 255f);                  var alpha2 = rgba[8 * i + 7] * (15f / 255f);                  var quant1 = FloatToInt(alpha1' 15);                  var quant2 = FloatToInt(alpha2' 15);                    // Set alpha to zero where masked.                  var bit1 = 1 << (2 * i);                  var bit2 = 1 << (2 * i + 1);                  if ((mask & bit1) == 0)                      quant1 = 0;                  if ((mask & bit2) == 0)                      quant2 = 0;                    // Pack into the byte.                  target[targetOffset + i] = (byte)(quant1 | (quant2 << 4));              }
Magic Number,DotSquish,Alpha,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Alpha.cs,CompressAlphaDxt3,The following statement contains a magic number: for (int i = 0; i < 8; ++i) {                  // Qnatise down to 4 bits.                  var alpha1 = rgba[8 * i + 3] * (15f / 255f);                  var alpha2 = rgba[8 * i + 7] * (15f / 255f);                  var quant1 = FloatToInt(alpha1' 15);                  var quant2 = FloatToInt(alpha2' 15);                    // Set alpha to zero where masked.                  var bit1 = 1 << (2 * i);                  var bit2 = 1 << (2 * i + 1);                  if ((mask & bit1) == 0)                      quant1 = 0;                  if ((mask & bit2) == 0)                      quant2 = 0;                    // Pack into the byte.                  target[targetOffset + i] = (byte)(quant1 | (quant2 << 4));              }
Magic Number,DotSquish,Alpha,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Alpha.cs,CompressAlphaDxt3,The following statement contains a magic number: for (int i = 0; i < 8; ++i) {                  // Qnatise down to 4 bits.                  var alpha1 = rgba[8 * i + 3] * (15f / 255f);                  var alpha2 = rgba[8 * i + 7] * (15f / 255f);                  var quant1 = FloatToInt(alpha1' 15);                  var quant2 = FloatToInt(alpha2' 15);                    // Set alpha to zero where masked.                  var bit1 = 1 << (2 * i);                  var bit2 = 1 << (2 * i + 1);                  if ((mask & bit1) == 0)                      quant1 = 0;                  if ((mask & bit2) == 0)                      quant2 = 0;                    // Pack into the byte.                  target[targetOffset + i] = (byte)(quant1 | (quant2 << 4));              }
Magic Number,DotSquish,Alpha,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Alpha.cs,CompressAlphaDxt3,The following statement contains a magic number: for (int i = 0; i < 8; ++i) {                  // Qnatise down to 4 bits.                  var alpha1 = rgba[8 * i + 3] * (15f / 255f);                  var alpha2 = rgba[8 * i + 7] * (15f / 255f);                  var quant1 = FloatToInt(alpha1' 15);                  var quant2 = FloatToInt(alpha2' 15);                    // Set alpha to zero where masked.                  var bit1 = 1 << (2 * i);                  var bit2 = 1 << (2 * i + 1);                  if ((mask & bit1) == 0)                      quant1 = 0;                  if ((mask & bit2) == 0)                      quant2 = 0;                    // Pack into the byte.                  target[targetOffset + i] = (byte)(quant1 | (quant2 << 4));              }
Magic Number,DotSquish,Alpha,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Alpha.cs,CompressAlphaDxt3,The following statement contains a magic number: for (int i = 0; i < 8; ++i) {                  // Qnatise down to 4 bits.                  var alpha1 = rgba[8 * i + 3] * (15f / 255f);                  var alpha2 = rgba[8 * i + 7] * (15f / 255f);                  var quant1 = FloatToInt(alpha1' 15);                  var quant2 = FloatToInt(alpha2' 15);                    // Set alpha to zero where masked.                  var bit1 = 1 << (2 * i);                  var bit2 = 1 << (2 * i + 1);                  if ((mask & bit1) == 0)                      quant1 = 0;                  if ((mask & bit2) == 0)                      quant2 = 0;                    // Pack into the byte.                  target[targetOffset + i] = (byte)(quant1 | (quant2 << 4));              }
Magic Number,DotSquish,Alpha,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Alpha.cs,DecompressAlphaDxt3,The following statement contains a magic number: for (int i = 0; i < 8; ++i) {                  // Quantise down to 4 bits.                  var quant = block[blockOffset + i];                    // Unpack the values.                  var lo = quant & 0x0f;                  var hi = quant & 0xf0;                    // Convert back up to bytes.                  target[targetOffset + 8 * i + 3] = (byte)(lo | (lo << 4));                  target[targetOffset + 8 * i + 7] = (byte)(hi | (hi >> 4));              }
Magic Number,DotSquish,Alpha,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Alpha.cs,DecompressAlphaDxt3,The following statement contains a magic number: for (int i = 0; i < 8; ++i) {                  // Quantise down to 4 bits.                  var quant = block[blockOffset + i];                    // Unpack the values.                  var lo = quant & 0x0f;                  var hi = quant & 0xf0;                    // Convert back up to bytes.                  target[targetOffset + 8 * i + 3] = (byte)(lo | (lo << 4));                  target[targetOffset + 8 * i + 7] = (byte)(hi | (hi >> 4));              }
Magic Number,DotSquish,Alpha,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Alpha.cs,DecompressAlphaDxt3,The following statement contains a magic number: for (int i = 0; i < 8; ++i) {                  // Quantise down to 4 bits.                  var quant = block[blockOffset + i];                    // Unpack the values.                  var lo = quant & 0x0f;                  var hi = quant & 0xf0;                    // Convert back up to bytes.                  target[targetOffset + 8 * i + 3] = (byte)(lo | (lo << 4));                  target[targetOffset + 8 * i + 7] = (byte)(hi | (hi >> 4));              }
Magic Number,DotSquish,Alpha,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Alpha.cs,DecompressAlphaDxt3,The following statement contains a magic number: for (int i = 0; i < 8; ++i) {                  // Quantise down to 4 bits.                  var quant = block[blockOffset + i];                    // Unpack the values.                  var lo = quant & 0x0f;                  var hi = quant & 0xf0;                    // Convert back up to bytes.                  target[targetOffset + 8 * i + 3] = (byte)(lo | (lo << 4));                  target[targetOffset + 8 * i + 7] = (byte)(hi | (hi >> 4));              }
Magic Number,DotSquish,Alpha,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Alpha.cs,DecompressAlphaDxt3,The following statement contains a magic number: for (int i = 0; i < 8; ++i) {                  // Quantise down to 4 bits.                  var quant = block[blockOffset + i];                    // Unpack the values.                  var lo = quant & 0x0f;                  var hi = quant & 0xf0;                    // Convert back up to bytes.                  target[targetOffset + 8 * i + 3] = (byte)(lo | (lo << 4));                  target[targetOffset + 8 * i + 7] = (byte)(hi | (hi >> 4));              }
Magic Number,DotSquish,Alpha,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Alpha.cs,DecompressAlphaDxt3,The following statement contains a magic number: for (int i = 0; i < 8; ++i) {                  // Quantise down to 4 bits.                  var quant = block[blockOffset + i];                    // Unpack the values.                  var lo = quant & 0x0f;                  var hi = quant & 0xf0;                    // Convert back up to bytes.                  target[targetOffset + 8 * i + 3] = (byte)(lo | (lo << 4));                  target[targetOffset + 8 * i + 7] = (byte)(hi | (hi >> 4));              }
Magic Number,DotSquish,Alpha,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Alpha.cs,DecompressAlphaDxt3,The following statement contains a magic number: for (int i = 0; i < 8; ++i) {                  // Quantise down to 4 bits.                  var quant = block[blockOffset + i];                    // Unpack the values.                  var lo = quant & 0x0f;                  var hi = quant & 0xf0;                    // Convert back up to bytes.                  target[targetOffset + 8 * i + 3] = (byte)(lo | (lo << 4));                  target[targetOffset + 8 * i + 7] = (byte)(hi | (hi >> 4));              }
Magic Number,DotSquish,Alpha,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Alpha.cs,FixRange,The following statement contains a magic number: if (max - min < steps)                  max = Math.Min(min + steps' 255);
Magic Number,DotSquish,Alpha,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Alpha.cs,FitCodes,The following statement contains a magic number: indices = new byte[16];
Magic Number,DotSquish,Alpha,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Alpha.cs,FitCodes,The following statement contains a magic number: for (int i = 0; i < 16; ++i) {                  // Check this pixel is valid.                  var bit = 1 << i;                  if ((mask & bit) == 0) {                      // Use the first code.                      indices[i] = 0;                      continue;                  }                    // Find the least error and corresponding index.                  var value = rgba[4 * i + 3];                  var least = int.MaxValue;                  var index = 0;                  for (int j = 0; j < 8; ++j) {                      // Get the squared error from this code.                      var dist = ((int)value) - ((int)codes[j]);                      dist *= dist;                        // Compare with the best so far.                      if (dist < least) {                          least = dist;                          index = j;                      }                  }                    // Save this index and accumulate the error.                  indices[i] = (byte)index;                  err += least;              }
Magic Number,DotSquish,Alpha,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Alpha.cs,FitCodes,The following statement contains a magic number: for (int i = 0; i < 16; ++i) {                  // Check this pixel is valid.                  var bit = 1 << i;                  if ((mask & bit) == 0) {                      // Use the first code.                      indices[i] = 0;                      continue;                  }                    // Find the least error and corresponding index.                  var value = rgba[4 * i + 3];                  var least = int.MaxValue;                  var index = 0;                  for (int j = 0; j < 8; ++j) {                      // Get the squared error from this code.                      var dist = ((int)value) - ((int)codes[j]);                      dist *= dist;                        // Compare with the best so far.                      if (dist < least) {                          least = dist;                          index = j;                      }                  }                    // Save this index and accumulate the error.                  indices[i] = (byte)index;                  err += least;              }
Magic Number,DotSquish,Alpha,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Alpha.cs,FitCodes,The following statement contains a magic number: for (int i = 0; i < 16; ++i) {                  // Check this pixel is valid.                  var bit = 1 << i;                  if ((mask & bit) == 0) {                      // Use the first code.                      indices[i] = 0;                      continue;                  }                    // Find the least error and corresponding index.                  var value = rgba[4 * i + 3];                  var least = int.MaxValue;                  var index = 0;                  for (int j = 0; j < 8; ++j) {                      // Get the squared error from this code.                      var dist = ((int)value) - ((int)codes[j]);                      dist *= dist;                        // Compare with the best so far.                      if (dist < least) {                          least = dist;                          index = j;                      }                  }                    // Save this index and accumulate the error.                  indices[i] = (byte)index;                  err += least;              }
Magic Number,DotSquish,Alpha,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Alpha.cs,FitCodes,The following statement contains a magic number: for (int i = 0; i < 16; ++i) {                  // Check this pixel is valid.                  var bit = 1 << i;                  if ((mask & bit) == 0) {                      // Use the first code.                      indices[i] = 0;                      continue;                  }                    // Find the least error and corresponding index.                  var value = rgba[4 * i + 3];                  var least = int.MaxValue;                  var index = 0;                  for (int j = 0; j < 8; ++j) {                      // Get the squared error from this code.                      var dist = ((int)value) - ((int)codes[j]);                      dist *= dist;                        // Compare with the best so far.                      if (dist < least) {                          least = dist;                          index = j;                      }                  }                    // Save this index and accumulate the error.                  indices[i] = (byte)index;                  err += least;              }
Magic Number,DotSquish,Alpha,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Alpha.cs,WriteAlphaBlock,The following statement contains a magic number: var retOff = 2;
Magic Number,DotSquish,Alpha,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Alpha.cs,WriteAlphaBlock,The following statement contains a magic number: for (int i = 0; i < 2; ++i) {                  // Pack 8 3-bit values.                  var value = 0;                  for (int j = 0; j < 8; ++j) {                      var index = indices[indOff++];                      value |= (index << 3 * j);                  }                    // Store in 3 bytes                  for (int j = 0; j < 3; ++j) {                      var b = (value >> (8 * j)) & 0xFF;                      target[targetOffset + retOff++] = (byte)b;                  }              }
Magic Number,DotSquish,Alpha,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Alpha.cs,WriteAlphaBlock,The following statement contains a magic number: for (int i = 0; i < 2; ++i) {                  // Pack 8 3-bit values.                  var value = 0;                  for (int j = 0; j < 8; ++j) {                      var index = indices[indOff++];                      value |= (index << 3 * j);                  }                    // Store in 3 bytes                  for (int j = 0; j < 3; ++j) {                      var b = (value >> (8 * j)) & 0xFF;                      target[targetOffset + retOff++] = (byte)b;                  }              }
Magic Number,DotSquish,Alpha,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Alpha.cs,WriteAlphaBlock,The following statement contains a magic number: for (int i = 0; i < 2; ++i) {                  // Pack 8 3-bit values.                  var value = 0;                  for (int j = 0; j < 8; ++j) {                      var index = indices[indOff++];                      value |= (index << 3 * j);                  }                    // Store in 3 bytes                  for (int j = 0; j < 3; ++j) {                      var b = (value >> (8 * j)) & 0xFF;                      target[targetOffset + retOff++] = (byte)b;                  }              }
Magic Number,DotSquish,Alpha,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Alpha.cs,WriteAlphaBlock,The following statement contains a magic number: for (int i = 0; i < 2; ++i) {                  // Pack 8 3-bit values.                  var value = 0;                  for (int j = 0; j < 8; ++j) {                      var index = indices[indOff++];                      value |= (index << 3 * j);                  }                    // Store in 3 bytes                  for (int j = 0; j < 3; ++j) {                      var b = (value >> (8 * j)) & 0xFF;                      target[targetOffset + retOff++] = (byte)b;                  }              }
Magic Number,DotSquish,Alpha,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Alpha.cs,WriteAlphaBlock,The following statement contains a magic number: for (int i = 0; i < 2; ++i) {                  // Pack 8 3-bit values.                  var value = 0;                  for (int j = 0; j < 8; ++j) {                      var index = indices[indOff++];                      value |= (index << 3 * j);                  }                    // Store in 3 bytes                  for (int j = 0; j < 3; ++j) {                      var b = (value >> (8 * j)) & 0xFF;                      target[targetOffset + retOff++] = (byte)b;                  }              }
Magic Number,DotSquish,Alpha,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Alpha.cs,WriteAlphaBlock5,The following statement contains a magic number: if (alpha0 > alpha1) {                  var swapped = new byte[16];                  for (int i = 0; i < 16; ++i) {                      var index = indices[i];                      if (index == 0)                          swapped[i] = 1;                      else if (index == 1)                          swapped[i] = 0;                      else if (index <= 5)                          swapped[i] = (byte)(7 - index);                      else                          swapped[i] = index;                  }                    // Write the block.                  WriteAlphaBlock(alpha1' alpha0' swapped' target' targetOffset);              } else {                  // Write the block.                  WriteAlphaBlock(alpha0' alpha1' indices' target' targetOffset);              }
Magic Number,DotSquish,Alpha,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Alpha.cs,WriteAlphaBlock5,The following statement contains a magic number: if (alpha0 > alpha1) {                  var swapped = new byte[16];                  for (int i = 0; i < 16; ++i) {                      var index = indices[i];                      if (index == 0)                          swapped[i] = 1;                      else if (index == 1)                          swapped[i] = 0;                      else if (index <= 5)                          swapped[i] = (byte)(7 - index);                      else                          swapped[i] = index;                  }                    // Write the block.                  WriteAlphaBlock(alpha1' alpha0' swapped' target' targetOffset);              } else {                  // Write the block.                  WriteAlphaBlock(alpha0' alpha1' indices' target' targetOffset);              }
Magic Number,DotSquish,Alpha,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Alpha.cs,WriteAlphaBlock5,The following statement contains a magic number: if (alpha0 > alpha1) {                  var swapped = new byte[16];                  for (int i = 0; i < 16; ++i) {                      var index = indices[i];                      if (index == 0)                          swapped[i] = 1;                      else if (index == 1)                          swapped[i] = 0;                      else if (index <= 5)                          swapped[i] = (byte)(7 - index);                      else                          swapped[i] = index;                  }                    // Write the block.                  WriteAlphaBlock(alpha1' alpha0' swapped' target' targetOffset);              } else {                  // Write the block.                  WriteAlphaBlock(alpha0' alpha1' indices' target' targetOffset);              }
Magic Number,DotSquish,Alpha,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Alpha.cs,WriteAlphaBlock5,The following statement contains a magic number: if (alpha0 > alpha1) {                  var swapped = new byte[16];                  for (int i = 0; i < 16; ++i) {                      var index = indices[i];                      if (index == 0)                          swapped[i] = 1;                      else if (index == 1)                          swapped[i] = 0;                      else if (index <= 5)                          swapped[i] = (byte)(7 - index);                      else                          swapped[i] = index;                  }                    // Write the block.                  WriteAlphaBlock(alpha1' alpha0' swapped' target' targetOffset);              } else {                  // Write the block.                  WriteAlphaBlock(alpha0' alpha1' indices' target' targetOffset);              }
Magic Number,DotSquish,Alpha,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Alpha.cs,WriteAlphaBlock7,The following statement contains a magic number: if (alpha0 > alpha1) {                  var swapped = new byte[16];                  for (int i = 0; i < 16; ++i) {                      var index = indices[i];                      if (index == 0)                          swapped[i] = 1;                      else if (index == 1)                          swapped[i] = 0;                      else                          swapped[i] = (byte)(9 - index);                  }                    // Write the block.                  WriteAlphaBlock(alpha1' alpha0' swapped' target' targetOffset);              } else {                  // Write the block.                  WriteAlphaBlock(alpha0' alpha1' indices' target' targetOffset);              }
Magic Number,DotSquish,Alpha,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Alpha.cs,WriteAlphaBlock7,The following statement contains a magic number: if (alpha0 > alpha1) {                  var swapped = new byte[16];                  for (int i = 0; i < 16; ++i) {                      var index = indices[i];                      if (index == 0)                          swapped[i] = 1;                      else if (index == 1)                          swapped[i] = 0;                      else                          swapped[i] = (byte)(9 - index);                  }                    // Write the block.                  WriteAlphaBlock(alpha1' alpha0' swapped' target' targetOffset);              } else {                  // Write the block.                  WriteAlphaBlock(alpha0' alpha1' indices' target' targetOffset);              }
Magic Number,DotSquish,Alpha,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Alpha.cs,WriteAlphaBlock7,The following statement contains a magic number: if (alpha0 > alpha1) {                  var swapped = new byte[16];                  for (int i = 0; i < 16; ++i) {                      var index = indices[i];                      if (index == 0)                          swapped[i] = 1;                      else if (index == 1)                          swapped[i] = 0;                      else                          swapped[i] = (byte)(9 - index);                  }                    // Write the block.                  WriteAlphaBlock(alpha1' alpha0' swapped' target' targetOffset);              } else {                  // Write the block.                  WriteAlphaBlock(alpha0' alpha1' indices' target' targetOffset);              }
Magic Number,DotSquish,Alpha,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Alpha.cs,CompressAlphaDxt5,The following statement contains a magic number: int min5 = 255' max5 = 0;
Magic Number,DotSquish,Alpha,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Alpha.cs,CompressAlphaDxt5,The following statement contains a magic number: int min7 = 255' max7 = 0;
Magic Number,DotSquish,Alpha,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Alpha.cs,CompressAlphaDxt5,The following statement contains a magic number: for (int i = 0; i < 16; ++i) {                  // Check this pixel is valid.                  var bit = 1 << i;                  if ((mask & bit) == 0)                      continue;                    // Incorporate into the min/max.                  int value = rgba[4 * i + 3];                  if (value < min7)                      min7 = value;                  if (value > max7)                      max7 = value;                  if (value != 0 && value < min5)                      min5 = value;                  if (value != 255 && value > max5)                      max5 = value;              }
Magic Number,DotSquish,Alpha,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Alpha.cs,CompressAlphaDxt5,The following statement contains a magic number: for (int i = 0; i < 16; ++i) {                  // Check this pixel is valid.                  var bit = 1 << i;                  if ((mask & bit) == 0)                      continue;                    // Incorporate into the min/max.                  int value = rgba[4 * i + 3];                  if (value < min7)                      min7 = value;                  if (value > max7)                      max7 = value;                  if (value != 0 && value < min5)                      min5 = value;                  if (value != 255 && value > max5)                      max5 = value;              }
Magic Number,DotSquish,Alpha,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Alpha.cs,CompressAlphaDxt5,The following statement contains a magic number: for (int i = 0; i < 16; ++i) {                  // Check this pixel is valid.                  var bit = 1 << i;                  if ((mask & bit) == 0)                      continue;                    // Incorporate into the min/max.                  int value = rgba[4 * i + 3];                  if (value < min7)                      min7 = value;                  if (value > max7)                      max7 = value;                  if (value != 0 && value < min5)                      min5 = value;                  if (value != 255 && value > max5)                      max5 = value;              }
Magic Number,DotSquish,Alpha,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Alpha.cs,CompressAlphaDxt5,The following statement contains a magic number: for (int i = 0; i < 16; ++i) {                  // Check this pixel is valid.                  var bit = 1 << i;                  if ((mask & bit) == 0)                      continue;                    // Incorporate into the min/max.                  int value = rgba[4 * i + 3];                  if (value < min7)                      min7 = value;                  if (value > max7)                      max7 = value;                  if (value != 0 && value < min5)                      min5 = value;                  if (value != 255 && value > max5)                      max5 = value;              }
Magic Number,DotSquish,Alpha,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Alpha.cs,CompressAlphaDxt5,The following statement contains a magic number: FixRange(ref min5' ref max5' 5);
Magic Number,DotSquish,Alpha,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Alpha.cs,CompressAlphaDxt5,The following statement contains a magic number: FixRange(ref min7' ref max7' 7);
Magic Number,DotSquish,Alpha,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Alpha.cs,CompressAlphaDxt5,The following statement contains a magic number: var codes5 = new byte[8];
Magic Number,DotSquish,Alpha,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Alpha.cs,CompressAlphaDxt5,The following statement contains a magic number: for (int i = 1; i < 5; ++i)                  codes5[i + 1] = (byte)(((5 - i) * min5 + i * max5) / 5);
Magic Number,DotSquish,Alpha,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Alpha.cs,CompressAlphaDxt5,The following statement contains a magic number: for (int i = 1; i < 5; ++i)                  codes5[i + 1] = (byte)(((5 - i) * min5 + i * max5) / 5);
Magic Number,DotSquish,Alpha,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Alpha.cs,CompressAlphaDxt5,The following statement contains a magic number: for (int i = 1; i < 5; ++i)                  codes5[i + 1] = (byte)(((5 - i) * min5 + i * max5) / 5);
Magic Number,DotSquish,Alpha,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Alpha.cs,CompressAlphaDxt5,The following statement contains a magic number: codes5[6] = 0;
Magic Number,DotSquish,Alpha,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Alpha.cs,CompressAlphaDxt5,The following statement contains a magic number: codes5[7] = 255;
Magic Number,DotSquish,Alpha,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Alpha.cs,CompressAlphaDxt5,The following statement contains a magic number: codes5[7] = 255;
Magic Number,DotSquish,Alpha,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Alpha.cs,CompressAlphaDxt5,The following statement contains a magic number: var codes7 = new byte[8];
Magic Number,DotSquish,Alpha,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Alpha.cs,CompressAlphaDxt5,The following statement contains a magic number: for (int i = 1; i < 7; ++i)                  codes7[i + 1] = (byte)(((7 - i) * min7 + i * max7) / 7);
Magic Number,DotSquish,Alpha,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Alpha.cs,CompressAlphaDxt5,The following statement contains a magic number: for (int i = 1; i < 7; ++i)                  codes7[i + 1] = (byte)(((7 - i) * min7 + i * max7) / 7);
Magic Number,DotSquish,Alpha,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Alpha.cs,CompressAlphaDxt5,The following statement contains a magic number: for (int i = 1; i < 7; ++i)                  codes7[i + 1] = (byte)(((7 - i) * min7 + i * max7) / 7);
Magic Number,DotSquish,Alpha,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Alpha.cs,DecompressAlphaDxt5,The following statement contains a magic number: var codes = new byte[8];
Magic Number,DotSquish,Alpha,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Alpha.cs,DecompressAlphaDxt5,The following statement contains a magic number: if (alpha0 <= alpha1) {                  // Use the 5-alpha codebook.                  for (int i = 1; i < 5; ++i)                      codes[1 + i] = (byte)(((5 - i) * alpha0 + i * alpha1) / 5);                  codes[6] = 0;                  codes[7] = 255;              } else {                  // Use the 7-alpha codebook.                  for (int i = 1; i < 7; ++i)                      codes[1 + i] = (byte)(((7 - i) * alpha0 + i * alpha1) / 7);              }
Magic Number,DotSquish,Alpha,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Alpha.cs,DecompressAlphaDxt5,The following statement contains a magic number: if (alpha0 <= alpha1) {                  // Use the 5-alpha codebook.                  for (int i = 1; i < 5; ++i)                      codes[1 + i] = (byte)(((5 - i) * alpha0 + i * alpha1) / 5);                  codes[6] = 0;                  codes[7] = 255;              } else {                  // Use the 7-alpha codebook.                  for (int i = 1; i < 7; ++i)                      codes[1 + i] = (byte)(((7 - i) * alpha0 + i * alpha1) / 7);              }
Magic Number,DotSquish,Alpha,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Alpha.cs,DecompressAlphaDxt5,The following statement contains a magic number: if (alpha0 <= alpha1) {                  // Use the 5-alpha codebook.                  for (int i = 1; i < 5; ++i)                      codes[1 + i] = (byte)(((5 - i) * alpha0 + i * alpha1) / 5);                  codes[6] = 0;                  codes[7] = 255;              } else {                  // Use the 7-alpha codebook.                  for (int i = 1; i < 7; ++i)                      codes[1 + i] = (byte)(((7 - i) * alpha0 + i * alpha1) / 7);              }
Magic Number,DotSquish,Alpha,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Alpha.cs,DecompressAlphaDxt5,The following statement contains a magic number: if (alpha0 <= alpha1) {                  // Use the 5-alpha codebook.                  for (int i = 1; i < 5; ++i)                      codes[1 + i] = (byte)(((5 - i) * alpha0 + i * alpha1) / 5);                  codes[6] = 0;                  codes[7] = 255;              } else {                  // Use the 7-alpha codebook.                  for (int i = 1; i < 7; ++i)                      codes[1 + i] = (byte)(((7 - i) * alpha0 + i * alpha1) / 7);              }
Magic Number,DotSquish,Alpha,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Alpha.cs,DecompressAlphaDxt5,The following statement contains a magic number: if (alpha0 <= alpha1) {                  // Use the 5-alpha codebook.                  for (int i = 1; i < 5; ++i)                      codes[1 + i] = (byte)(((5 - i) * alpha0 + i * alpha1) / 5);                  codes[6] = 0;                  codes[7] = 255;              } else {                  // Use the 7-alpha codebook.                  for (int i = 1; i < 7; ++i)                      codes[1 + i] = (byte)(((7 - i) * alpha0 + i * alpha1) / 7);              }
Magic Number,DotSquish,Alpha,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Alpha.cs,DecompressAlphaDxt5,The following statement contains a magic number: if (alpha0 <= alpha1) {                  // Use the 5-alpha codebook.                  for (int i = 1; i < 5; ++i)                      codes[1 + i] = (byte)(((5 - i) * alpha0 + i * alpha1) / 5);                  codes[6] = 0;                  codes[7] = 255;              } else {                  // Use the 7-alpha codebook.                  for (int i = 1; i < 7; ++i)                      codes[1 + i] = (byte)(((7 - i) * alpha0 + i * alpha1) / 7);              }
Magic Number,DotSquish,Alpha,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Alpha.cs,DecompressAlphaDxt5,The following statement contains a magic number: if (alpha0 <= alpha1) {                  // Use the 5-alpha codebook.                  for (int i = 1; i < 5; ++i)                      codes[1 + i] = (byte)(((5 - i) * alpha0 + i * alpha1) / 5);                  codes[6] = 0;                  codes[7] = 255;              } else {                  // Use the 7-alpha codebook.                  for (int i = 1; i < 7; ++i)                      codes[1 + i] = (byte)(((7 - i) * alpha0 + i * alpha1) / 7);              }
Magic Number,DotSquish,Alpha,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Alpha.cs,DecompressAlphaDxt5,The following statement contains a magic number: if (alpha0 <= alpha1) {                  // Use the 5-alpha codebook.                  for (int i = 1; i < 5; ++i)                      codes[1 + i] = (byte)(((5 - i) * alpha0 + i * alpha1) / 5);                  codes[6] = 0;                  codes[7] = 255;              } else {                  // Use the 7-alpha codebook.                  for (int i = 1; i < 7; ++i)                      codes[1 + i] = (byte)(((7 - i) * alpha0 + i * alpha1) / 7);              }
Magic Number,DotSquish,Alpha,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Alpha.cs,DecompressAlphaDxt5,The following statement contains a magic number: if (alpha0 <= alpha1) {                  // Use the 5-alpha codebook.                  for (int i = 1; i < 5; ++i)                      codes[1 + i] = (byte)(((5 - i) * alpha0 + i * alpha1) / 5);                  codes[6] = 0;                  codes[7] = 255;              } else {                  // Use the 7-alpha codebook.                  for (int i = 1; i < 7; ++i)                      codes[1 + i] = (byte)(((7 - i) * alpha0 + i * alpha1) / 7);              }
Magic Number,DotSquish,Alpha,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Alpha.cs,DecompressAlphaDxt5,The following statement contains a magic number: var indices = new byte[16];
Magic Number,DotSquish,Alpha,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Alpha.cs,DecompressAlphaDxt5,The following statement contains a magic number: var blOff = 2;
Magic Number,DotSquish,Alpha,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Alpha.cs,DecompressAlphaDxt5,The following statement contains a magic number: for (int i = 0; i < 2; ++i) {                  // Grab 3 bytes                  int value = 0;                  for (int j = 0; j < 3; ++j) {                      var b = block[blockOffset + blOff++];                      value |= (b << 8 * j);                  }                    // Unpack 8 3-bit values from it                  for (int j = 0; j < 8; ++j) {                      var index = (value >> 3 * j) & 0x7;                      indices[indOff++] = (byte)index;                  }              }
Magic Number,DotSquish,Alpha,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Alpha.cs,DecompressAlphaDxt5,The following statement contains a magic number: for (int i = 0; i < 2; ++i) {                  // Grab 3 bytes                  int value = 0;                  for (int j = 0; j < 3; ++j) {                      var b = block[blockOffset + blOff++];                      value |= (b << 8 * j);                  }                    // Unpack 8 3-bit values from it                  for (int j = 0; j < 8; ++j) {                      var index = (value >> 3 * j) & 0x7;                      indices[indOff++] = (byte)index;                  }              }
Magic Number,DotSquish,Alpha,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Alpha.cs,DecompressAlphaDxt5,The following statement contains a magic number: for (int i = 0; i < 2; ++i) {                  // Grab 3 bytes                  int value = 0;                  for (int j = 0; j < 3; ++j) {                      var b = block[blockOffset + blOff++];                      value |= (b << 8 * j);                  }                    // Unpack 8 3-bit values from it                  for (int j = 0; j < 8; ++j) {                      var index = (value >> 3 * j) & 0x7;                      indices[indOff++] = (byte)index;                  }              }
Magic Number,DotSquish,Alpha,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Alpha.cs,DecompressAlphaDxt5,The following statement contains a magic number: for (int i = 0; i < 2; ++i) {                  // Grab 3 bytes                  int value = 0;                  for (int j = 0; j < 3; ++j) {                      var b = block[blockOffset + blOff++];                      value |= (b << 8 * j);                  }                    // Unpack 8 3-bit values from it                  for (int j = 0; j < 8; ++j) {                      var index = (value >> 3 * j) & 0x7;                      indices[indOff++] = (byte)index;                  }              }
Magic Number,DotSquish,Alpha,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Alpha.cs,DecompressAlphaDxt5,The following statement contains a magic number: for (int i = 0; i < 2; ++i) {                  // Grab 3 bytes                  int value = 0;                  for (int j = 0; j < 3; ++j) {                      var b = block[blockOffset + blOff++];                      value |= (b << 8 * j);                  }                    // Unpack 8 3-bit values from it                  for (int j = 0; j < 8; ++j) {                      var index = (value >> 3 * j) & 0x7;                      indices[indOff++] = (byte)index;                  }              }
Magic Number,DotSquish,Alpha,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Alpha.cs,DecompressAlphaDxt5,The following statement contains a magic number: for (int i = 0; i < 16; ++i)                  target[targetOffset + 4 * i + 3] = codes[indices[i]];
Magic Number,DotSquish,Alpha,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Alpha.cs,DecompressAlphaDxt5,The following statement contains a magic number: for (int i = 0; i < 16; ++i)                  target[targetOffset + 4 * i + 3] = codes[indices[i]];
Magic Number,DotSquish,Alpha,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Alpha.cs,DecompressAlphaDxt5,The following statement contains a magic number: for (int i = 0; i < 16; ++i)                  target[targetOffset + 4 * i + 3] = codes[indices[i]];
Magic Number,DotSquish,ClusterFit,C:\repos\Rogueadyn_SaintCoinach\DotSquish\ClusterFit.cs,ConstructOrdering,The following statement contains a magic number: var dps = new float[16];
Magic Number,DotSquish,ClusterFit,C:\repos\Rogueadyn_SaintCoinach\DotSquish\ClusterFit.cs,ConstructOrdering,The following statement contains a magic number: var ordOff = 16 * iteration;
Magic Number,DotSquish,ClusterFit,C:\repos\Rogueadyn_SaintCoinach\DotSquish\ClusterFit.cs,ConstructOrdering,The following statement contains a magic number: for (int it = 0; it < iteration; ++it) {                  var prevOff = 16 * it;                  var same = true;                  for (int i = 0; i < _Colours.Count; ++i) {                      if (_Order[ordOff + i] != _Order[prevOff + i]) {                          same = false;                          break;                      }                  }                  if (same)                      return false;              }
Magic Number,DotSquish,ClusterFit,C:\repos\Rogueadyn_SaintCoinach\DotSquish\ClusterFit.cs,Compress3,The following statement contains a magic number: var bestIndices = new byte[16];
Magic Number,DotSquish,ColourBlock,C:\repos\Rogueadyn_SaintCoinach\DotSquish\ColourBlock.cs,Unpack565,The following statement contains a magic number: var value = (int)packed[packedOffset] | ((int)packed[packedOffset + 1] << 8);
Magic Number,DotSquish,ColourBlock,C:\repos\Rogueadyn_SaintCoinach\DotSquish\ColourBlock.cs,Unpack565,The following statement contains a magic number: var red = (byte)((value >> 11) & 0x1F);
Magic Number,DotSquish,ColourBlock,C:\repos\Rogueadyn_SaintCoinach\DotSquish\ColourBlock.cs,Unpack565,The following statement contains a magic number: var green = (byte)((value >> 5) & 0x3F);
Magic Number,DotSquish,ColourBlock,C:\repos\Rogueadyn_SaintCoinach\DotSquish\ColourBlock.cs,Unpack565,The following statement contains a magic number: colour[colourOffset + 0] = (byte)((red << 3) | (red >> 2));
Magic Number,DotSquish,ColourBlock,C:\repos\Rogueadyn_SaintCoinach\DotSquish\ColourBlock.cs,Unpack565,The following statement contains a magic number: colour[colourOffset + 0] = (byte)((red << 3) | (red >> 2));
Magic Number,DotSquish,ColourBlock,C:\repos\Rogueadyn_SaintCoinach\DotSquish\ColourBlock.cs,Unpack565,The following statement contains a magic number: colour[colourOffset + 1] = (byte)((green << 2) | (green >> 4));
Magic Number,DotSquish,ColourBlock,C:\repos\Rogueadyn_SaintCoinach\DotSquish\ColourBlock.cs,Unpack565,The following statement contains a magic number: colour[colourOffset + 1] = (byte)((green << 2) | (green >> 4));
Magic Number,DotSquish,ColourBlock,C:\repos\Rogueadyn_SaintCoinach\DotSquish\ColourBlock.cs,Unpack565,The following statement contains a magic number: colour[colourOffset + 2] = (byte)((blue << 3) | (blue >> 2));
Magic Number,DotSquish,ColourBlock,C:\repos\Rogueadyn_SaintCoinach\DotSquish\ColourBlock.cs,Unpack565,The following statement contains a magic number: colour[colourOffset + 2] = (byte)((blue << 3) | (blue >> 2));
Magic Number,DotSquish,ColourBlock,C:\repos\Rogueadyn_SaintCoinach\DotSquish\ColourBlock.cs,Unpack565,The following statement contains a magic number: colour[colourOffset + 2] = (byte)((blue << 3) | (blue >> 2));
Magic Number,DotSquish,ColourBlock,C:\repos\Rogueadyn_SaintCoinach\DotSquish\ColourBlock.cs,Unpack565,The following statement contains a magic number: colour[colourOffset + 3] = 255;
Magic Number,DotSquish,ColourBlock,C:\repos\Rogueadyn_SaintCoinach\DotSquish\ColourBlock.cs,Unpack565,The following statement contains a magic number: colour[colourOffset + 3] = 255;
Magic Number,DotSquish,ColourBlock,C:\repos\Rogueadyn_SaintCoinach\DotSquish\ColourBlock.cs,DecompressColour,The following statement contains a magic number: var codes = new byte[16];
Magic Number,DotSquish,ColourBlock,C:\repos\Rogueadyn_SaintCoinach\DotSquish\ColourBlock.cs,DecompressColour,The following statement contains a magic number: var b = Unpack565(block' blockOffset + 2' codes' 4);
Magic Number,DotSquish,ColourBlock,C:\repos\Rogueadyn_SaintCoinach\DotSquish\ColourBlock.cs,DecompressColour,The following statement contains a magic number: var b = Unpack565(block' blockOffset + 2' codes' 4);
Magic Number,DotSquish,ColourBlock,C:\repos\Rogueadyn_SaintCoinach\DotSquish\ColourBlock.cs,DecompressColour,The following statement contains a magic number: for (int i = 0; i < 3; ++i) {                  var c = codes[i];                  var d = codes[4 + i];                    if (isDxt1 && a <= b) {                      codes[8 + i] = (byte)((c + d) / 2);                      codes[12 + i] = 0;                  } else {                      codes[8 + i] = (byte)(((2 * c) + d) / 3);                      codes[12 + i] = (byte)((c + (2 * d)) / 3);                  }              }
Magic Number,DotSquish,ColourBlock,C:\repos\Rogueadyn_SaintCoinach\DotSquish\ColourBlock.cs,DecompressColour,The following statement contains a magic number: for (int i = 0; i < 3; ++i) {                  var c = codes[i];                  var d = codes[4 + i];                    if (isDxt1 && a <= b) {                      codes[8 + i] = (byte)((c + d) / 2);                      codes[12 + i] = 0;                  } else {                      codes[8 + i] = (byte)(((2 * c) + d) / 3);                      codes[12 + i] = (byte)((c + (2 * d)) / 3);                  }              }
Magic Number,DotSquish,ColourBlock,C:\repos\Rogueadyn_SaintCoinach\DotSquish\ColourBlock.cs,DecompressColour,The following statement contains a magic number: for (int i = 0; i < 3; ++i) {                  var c = codes[i];                  var d = codes[4 + i];                    if (isDxt1 && a <= b) {                      codes[8 + i] = (byte)((c + d) / 2);                      codes[12 + i] = 0;                  } else {                      codes[8 + i] = (byte)(((2 * c) + d) / 3);                      codes[12 + i] = (byte)((c + (2 * d)) / 3);                  }              }
Magic Number,DotSquish,ColourBlock,C:\repos\Rogueadyn_SaintCoinach\DotSquish\ColourBlock.cs,DecompressColour,The following statement contains a magic number: for (int i = 0; i < 3; ++i) {                  var c = codes[i];                  var d = codes[4 + i];                    if (isDxt1 && a <= b) {                      codes[8 + i] = (byte)((c + d) / 2);                      codes[12 + i] = 0;                  } else {                      codes[8 + i] = (byte)(((2 * c) + d) / 3);                      codes[12 + i] = (byte)((c + (2 * d)) / 3);                  }              }
Magic Number,DotSquish,ColourBlock,C:\repos\Rogueadyn_SaintCoinach\DotSquish\ColourBlock.cs,DecompressColour,The following statement contains a magic number: for (int i = 0; i < 3; ++i) {                  var c = codes[i];                  var d = codes[4 + i];                    if (isDxt1 && a <= b) {                      codes[8 + i] = (byte)((c + d) / 2);                      codes[12 + i] = 0;                  } else {                      codes[8 + i] = (byte)(((2 * c) + d) / 3);                      codes[12 + i] = (byte)((c + (2 * d)) / 3);                  }              }
Magic Number,DotSquish,ColourBlock,C:\repos\Rogueadyn_SaintCoinach\DotSquish\ColourBlock.cs,DecompressColour,The following statement contains a magic number: for (int i = 0; i < 3; ++i) {                  var c = codes[i];                  var d = codes[4 + i];                    if (isDxt1 && a <= b) {                      codes[8 + i] = (byte)((c + d) / 2);                      codes[12 + i] = 0;                  } else {                      codes[8 + i] = (byte)(((2 * c) + d) / 3);                      codes[12 + i] = (byte)((c + (2 * d)) / 3);                  }              }
Magic Number,DotSquish,ColourBlock,C:\repos\Rogueadyn_SaintCoinach\DotSquish\ColourBlock.cs,DecompressColour,The following statement contains a magic number: for (int i = 0; i < 3; ++i) {                  var c = codes[i];                  var d = codes[4 + i];                    if (isDxt1 && a <= b) {                      codes[8 + i] = (byte)((c + d) / 2);                      codes[12 + i] = 0;                  } else {                      codes[8 + i] = (byte)(((2 * c) + d) / 3);                      codes[12 + i] = (byte)((c + (2 * d)) / 3);                  }              }
Magic Number,DotSquish,ColourBlock,C:\repos\Rogueadyn_SaintCoinach\DotSquish\ColourBlock.cs,DecompressColour,The following statement contains a magic number: for (int i = 0; i < 3; ++i) {                  var c = codes[i];                  var d = codes[4 + i];                    if (isDxt1 && a <= b) {                      codes[8 + i] = (byte)((c + d) / 2);                      codes[12 + i] = 0;                  } else {                      codes[8 + i] = (byte)(((2 * c) + d) / 3);                      codes[12 + i] = (byte)((c + (2 * d)) / 3);                  }              }
Magic Number,DotSquish,ColourBlock,C:\repos\Rogueadyn_SaintCoinach\DotSquish\ColourBlock.cs,DecompressColour,The following statement contains a magic number: for (int i = 0; i < 3; ++i) {                  var c = codes[i];                  var d = codes[4 + i];                    if (isDxt1 && a <= b) {                      codes[8 + i] = (byte)((c + d) / 2);                      codes[12 + i] = 0;                  } else {                      codes[8 + i] = (byte)(((2 * c) + d) / 3);                      codes[12 + i] = (byte)((c + (2 * d)) / 3);                  }              }
Magic Number,DotSquish,ColourBlock,C:\repos\Rogueadyn_SaintCoinach\DotSquish\ColourBlock.cs,DecompressColour,The following statement contains a magic number: for (int i = 0; i < 3; ++i) {                  var c = codes[i];                  var d = codes[4 + i];                    if (isDxt1 && a <= b) {                      codes[8 + i] = (byte)((c + d) / 2);                      codes[12 + i] = 0;                  } else {                      codes[8 + i] = (byte)(((2 * c) + d) / 3);                      codes[12 + i] = (byte)((c + (2 * d)) / 3);                  }              }
Magic Number,DotSquish,ColourBlock,C:\repos\Rogueadyn_SaintCoinach\DotSquish\ColourBlock.cs,DecompressColour,The following statement contains a magic number: for (int i = 0; i < 3; ++i) {                  var c = codes[i];                  var d = codes[4 + i];                    if (isDxt1 && a <= b) {                      codes[8 + i] = (byte)((c + d) / 2);                      codes[12 + i] = 0;                  } else {                      codes[8 + i] = (byte)(((2 * c) + d) / 3);                      codes[12 + i] = (byte)((c + (2 * d)) / 3);                  }              }
Magic Number,DotSquish,ColourBlock,C:\repos\Rogueadyn_SaintCoinach\DotSquish\ColourBlock.cs,DecompressColour,The following statement contains a magic number: codes[8 + 3] = 255;
Magic Number,DotSquish,ColourBlock,C:\repos\Rogueadyn_SaintCoinach\DotSquish\ColourBlock.cs,DecompressColour,The following statement contains a magic number: codes[8 + 3] = 255;
Magic Number,DotSquish,ColourBlock,C:\repos\Rogueadyn_SaintCoinach\DotSquish\ColourBlock.cs,DecompressColour,The following statement contains a magic number: codes[8 + 3] = 255;
Magic Number,DotSquish,ColourBlock,C:\repos\Rogueadyn_SaintCoinach\DotSquish\ColourBlock.cs,DecompressColour,The following statement contains a magic number: codes[12 + 3] = (byte)((isDxt1 && a <= b) ? 0 : 255);
Magic Number,DotSquish,ColourBlock,C:\repos\Rogueadyn_SaintCoinach\DotSquish\ColourBlock.cs,DecompressColour,The following statement contains a magic number: codes[12 + 3] = (byte)((isDxt1 && a <= b) ? 0 : 255);
Magic Number,DotSquish,ColourBlock,C:\repos\Rogueadyn_SaintCoinach\DotSquish\ColourBlock.cs,DecompressColour,The following statement contains a magic number: codes[12 + 3] = (byte)((isDxt1 && a <= b) ? 0 : 255);
Magic Number,DotSquish,ColourBlock,C:\repos\Rogueadyn_SaintCoinach\DotSquish\ColourBlock.cs,DecompressColour,The following statement contains a magic number: var indices = new byte[16];
Magic Number,DotSquish,ColourBlock,C:\repos\Rogueadyn_SaintCoinach\DotSquish\ColourBlock.cs,DecompressColour,The following statement contains a magic number: for (int i = 0; i < 4; i++) {                  var packed = block[blockOffset + 4 + i];                    indices[4 * i + 0] = (byte)(packed & 0x3);                  indices[4 * i + 1] = (byte)((packed >> 2) & 0x3);                  indices[4 * i + 2] = (byte)((packed >> 4) & 0x3);                  indices[4 * i + 3] = (byte)((packed >> 6) & 0x3);              }
Magic Number,DotSquish,ColourBlock,C:\repos\Rogueadyn_SaintCoinach\DotSquish\ColourBlock.cs,DecompressColour,The following statement contains a magic number: for (int i = 0; i < 4; i++) {                  var packed = block[blockOffset + 4 + i];                    indices[4 * i + 0] = (byte)(packed & 0x3);                  indices[4 * i + 1] = (byte)((packed >> 2) & 0x3);                  indices[4 * i + 2] = (byte)((packed >> 4) & 0x3);                  indices[4 * i + 3] = (byte)((packed >> 6) & 0x3);              }
Magic Number,DotSquish,ColourBlock,C:\repos\Rogueadyn_SaintCoinach\DotSquish\ColourBlock.cs,DecompressColour,The following statement contains a magic number: for (int i = 0; i < 4; i++) {                  var packed = block[blockOffset + 4 + i];                    indices[4 * i + 0] = (byte)(packed & 0x3);                  indices[4 * i + 1] = (byte)((packed >> 2) & 0x3);                  indices[4 * i + 2] = (byte)((packed >> 4) & 0x3);                  indices[4 * i + 3] = (byte)((packed >> 6) & 0x3);              }
Magic Number,DotSquish,ColourBlock,C:\repos\Rogueadyn_SaintCoinach\DotSquish\ColourBlock.cs,DecompressColour,The following statement contains a magic number: for (int i = 0; i < 4; i++) {                  var packed = block[blockOffset + 4 + i];                    indices[4 * i + 0] = (byte)(packed & 0x3);                  indices[4 * i + 1] = (byte)((packed >> 2) & 0x3);                  indices[4 * i + 2] = (byte)((packed >> 4) & 0x3);                  indices[4 * i + 3] = (byte)((packed >> 6) & 0x3);              }
Magic Number,DotSquish,ColourBlock,C:\repos\Rogueadyn_SaintCoinach\DotSquish\ColourBlock.cs,DecompressColour,The following statement contains a magic number: for (int i = 0; i < 4; i++) {                  var packed = block[blockOffset + 4 + i];                    indices[4 * i + 0] = (byte)(packed & 0x3);                  indices[4 * i + 1] = (byte)((packed >> 2) & 0x3);                  indices[4 * i + 2] = (byte)((packed >> 4) & 0x3);                  indices[4 * i + 3] = (byte)((packed >> 6) & 0x3);              }
Magic Number,DotSquish,ColourBlock,C:\repos\Rogueadyn_SaintCoinach\DotSquish\ColourBlock.cs,DecompressColour,The following statement contains a magic number: for (int i = 0; i < 4; i++) {                  var packed = block[blockOffset + 4 + i];                    indices[4 * i + 0] = (byte)(packed & 0x3);                  indices[4 * i + 1] = (byte)((packed >> 2) & 0x3);                  indices[4 * i + 2] = (byte)((packed >> 4) & 0x3);                  indices[4 * i + 3] = (byte)((packed >> 6) & 0x3);              }
Magic Number,DotSquish,ColourBlock,C:\repos\Rogueadyn_SaintCoinach\DotSquish\ColourBlock.cs,DecompressColour,The following statement contains a magic number: for (int i = 0; i < 4; i++) {                  var packed = block[blockOffset + 4 + i];                    indices[4 * i + 0] = (byte)(packed & 0x3);                  indices[4 * i + 1] = (byte)((packed >> 2) & 0x3);                  indices[4 * i + 2] = (byte)((packed >> 4) & 0x3);                  indices[4 * i + 3] = (byte)((packed >> 6) & 0x3);              }
Magic Number,DotSquish,ColourBlock,C:\repos\Rogueadyn_SaintCoinach\DotSquish\ColourBlock.cs,DecompressColour,The following statement contains a magic number: for (int i = 0; i < 4; i++) {                  var packed = block[blockOffset + 4 + i];                    indices[4 * i + 0] = (byte)(packed & 0x3);                  indices[4 * i + 1] = (byte)((packed >> 2) & 0x3);                  indices[4 * i + 2] = (byte)((packed >> 4) & 0x3);                  indices[4 * i + 3] = (byte)((packed >> 6) & 0x3);              }
Magic Number,DotSquish,ColourBlock,C:\repos\Rogueadyn_SaintCoinach\DotSquish\ColourBlock.cs,DecompressColour,The following statement contains a magic number: for (int i = 0; i < 4; i++) {                  var packed = block[blockOffset + 4 + i];                    indices[4 * i + 0] = (byte)(packed & 0x3);                  indices[4 * i + 1] = (byte)((packed >> 2) & 0x3);                  indices[4 * i + 2] = (byte)((packed >> 4) & 0x3);                  indices[4 * i + 3] = (byte)((packed >> 6) & 0x3);              }
Magic Number,DotSquish,ColourBlock,C:\repos\Rogueadyn_SaintCoinach\DotSquish\ColourBlock.cs,DecompressColour,The following statement contains a magic number: for (int i = 0; i < 4; i++) {                  var packed = block[blockOffset + 4 + i];                    indices[4 * i + 0] = (byte)(packed & 0x3);                  indices[4 * i + 1] = (byte)((packed >> 2) & 0x3);                  indices[4 * i + 2] = (byte)((packed >> 4) & 0x3);                  indices[4 * i + 3] = (byte)((packed >> 6) & 0x3);              }
Magic Number,DotSquish,ColourBlock,C:\repos\Rogueadyn_SaintCoinach\DotSquish\ColourBlock.cs,DecompressColour,The following statement contains a magic number: for (int i = 0; i < 4; i++) {                  var packed = block[blockOffset + 4 + i];                    indices[4 * i + 0] = (byte)(packed & 0x3);                  indices[4 * i + 1] = (byte)((packed >> 2) & 0x3);                  indices[4 * i + 2] = (byte)((packed >> 4) & 0x3);                  indices[4 * i + 3] = (byte)((packed >> 6) & 0x3);              }
Magic Number,DotSquish,ColourBlock,C:\repos\Rogueadyn_SaintCoinach\DotSquish\ColourBlock.cs,DecompressColour,The following statement contains a magic number: var rgba = new byte[4 * 16];
Magic Number,DotSquish,ColourBlock,C:\repos\Rogueadyn_SaintCoinach\DotSquish\ColourBlock.cs,DecompressColour,The following statement contains a magic number: var rgba = new byte[4 * 16];
Magic Number,DotSquish,ColourBlock,C:\repos\Rogueadyn_SaintCoinach\DotSquish\ColourBlock.cs,DecompressColour,The following statement contains a magic number: for (int i = 0; i < 16; ++i) {                  var offset = 4 * indices[i];                  for (int j = 0; j < 4; ++j)                      rgba[4 * i + j] = codes[offset + j];              }
Magic Number,DotSquish,ColourBlock,C:\repos\Rogueadyn_SaintCoinach\DotSquish\ColourBlock.cs,DecompressColour,The following statement contains a magic number: for (int i = 0; i < 16; ++i) {                  var offset = 4 * indices[i];                  for (int j = 0; j < 4; ++j)                      rgba[4 * i + j] = codes[offset + j];              }
Magic Number,DotSquish,ColourBlock,C:\repos\Rogueadyn_SaintCoinach\DotSquish\ColourBlock.cs,DecompressColour,The following statement contains a magic number: for (int i = 0; i < 16; ++i) {                  var offset = 4 * indices[i];                  for (int j = 0; j < 4; ++j)                      rgba[4 * i + j] = codes[offset + j];              }
Magic Number,DotSquish,ColourBlock,C:\repos\Rogueadyn_SaintCoinach\DotSquish\ColourBlock.cs,DecompressColour,The following statement contains a magic number: for (int i = 0; i < 16; ++i) {                  var offset = 4 * indices[i];                  for (int j = 0; j < 4; ++j)                      rgba[4 * i + j] = codes[offset + j];              }
Magic Number,DotSquish,ColourSet,C:\repos\Rogueadyn_SaintCoinach\DotSquish\ColourSet.cs,ColourSet,The following statement contains a magic number: for (int i = 0; i < 16; ++i) {                  // Check this pixel is enabled.                  int bit = 1 << i;                  if ((mask & bit) == 0) {                      this._Remap[i] = -1;                      continue;                  }                    // Check for transparent pixels when using DXT1.                  if (isDxt1 && rgba[4 * i + 3] < 128) {                      this._Remap[i] = -1;                      this._IsTransparent = true;                  }                    // Loop over previous points for a match.                  for (int j = 0; ; ++j) {                      // Allocate a new point.                      if (j == i) {                          // Normalise coordinates to [0'1].                          var x = rgba[4 * i] / 255f;                          var y = rgba[4 * i + 1] / 255f;                          var z = rgba[4 * i + 2] / 255f;                            // Ensure there is always a non-zero weight even for zero alpha.                          var w = (rgba[4 * i + 3] + 1) / 256f;                            // Add the point.                          this._Points[this._Count] = new Vector3(x' y' z);                          this._Weights[this._Count] = w;                          this._Remap[i] = this._Count;                            // Advance.                          ++this._Count;                          break;                      }                        // Check for a match.                      int oldBit = 1 << j;                      var match = ((mask & oldBit) != 0)                          && (rgba[4 * i] == rgba[4 * j])                          && (rgba[4 * i + 1] == rgba[4 * j + 1])                          && (rgba[4 * i + 3] == rgba[4 * j + 2])                          && (rgba[4 * j + 3] >= 128 || !isDxt1);                      if (match) {                          // Get index of the match.                          var index = this._Remap[j];                            // Ensure there is always a non-zero weight even for zero alpha.                          var w = (rgba[4 * i + 3] + 1) / 256f;                            // Map this point and increase the weight.                          this._Weights[index] += (weightByAlpha ? w : 1f);                          this._Remap[i] = index;                          break;                      }                  }              }
Magic Number,DotSquish,ColourSet,C:\repos\Rogueadyn_SaintCoinach\DotSquish\ColourSet.cs,ColourSet,The following statement contains a magic number: for (int i = 0; i < 16; ++i) {                  // Check this pixel is enabled.                  int bit = 1 << i;                  if ((mask & bit) == 0) {                      this._Remap[i] = -1;                      continue;                  }                    // Check for transparent pixels when using DXT1.                  if (isDxt1 && rgba[4 * i + 3] < 128) {                      this._Remap[i] = -1;                      this._IsTransparent = true;                  }                    // Loop over previous points for a match.                  for (int j = 0; ; ++j) {                      // Allocate a new point.                      if (j == i) {                          // Normalise coordinates to [0'1].                          var x = rgba[4 * i] / 255f;                          var y = rgba[4 * i + 1] / 255f;                          var z = rgba[4 * i + 2] / 255f;                            // Ensure there is always a non-zero weight even for zero alpha.                          var w = (rgba[4 * i + 3] + 1) / 256f;                            // Add the point.                          this._Points[this._Count] = new Vector3(x' y' z);                          this._Weights[this._Count] = w;                          this._Remap[i] = this._Count;                            // Advance.                          ++this._Count;                          break;                      }                        // Check for a match.                      int oldBit = 1 << j;                      var match = ((mask & oldBit) != 0)                          && (rgba[4 * i] == rgba[4 * j])                          && (rgba[4 * i + 1] == rgba[4 * j + 1])                          && (rgba[4 * i + 3] == rgba[4 * j + 2])                          && (rgba[4 * j + 3] >= 128 || !isDxt1);                      if (match) {                          // Get index of the match.                          var index = this._Remap[j];                            // Ensure there is always a non-zero weight even for zero alpha.                          var w = (rgba[4 * i + 3] + 1) / 256f;                            // Map this point and increase the weight.                          this._Weights[index] += (weightByAlpha ? w : 1f);                          this._Remap[i] = index;                          break;                      }                  }              }
Magic Number,DotSquish,ColourSet,C:\repos\Rogueadyn_SaintCoinach\DotSquish\ColourSet.cs,ColourSet,The following statement contains a magic number: for (int i = 0; i < 16; ++i) {                  // Check this pixel is enabled.                  int bit = 1 << i;                  if ((mask & bit) == 0) {                      this._Remap[i] = -1;                      continue;                  }                    // Check for transparent pixels when using DXT1.                  if (isDxt1 && rgba[4 * i + 3] < 128) {                      this._Remap[i] = -1;                      this._IsTransparent = true;                  }                    // Loop over previous points for a match.                  for (int j = 0; ; ++j) {                      // Allocate a new point.                      if (j == i) {                          // Normalise coordinates to [0'1].                          var x = rgba[4 * i] / 255f;                          var y = rgba[4 * i + 1] / 255f;                          var z = rgba[4 * i + 2] / 255f;                            // Ensure there is always a non-zero weight even for zero alpha.                          var w = (rgba[4 * i + 3] + 1) / 256f;                            // Add the point.                          this._Points[this._Count] = new Vector3(x' y' z);                          this._Weights[this._Count] = w;                          this._Remap[i] = this._Count;                            // Advance.                          ++this._Count;                          break;                      }                        // Check for a match.                      int oldBit = 1 << j;                      var match = ((mask & oldBit) != 0)                          && (rgba[4 * i] == rgba[4 * j])                          && (rgba[4 * i + 1] == rgba[4 * j + 1])                          && (rgba[4 * i + 3] == rgba[4 * j + 2])                          && (rgba[4 * j + 3] >= 128 || !isDxt1);                      if (match) {                          // Get index of the match.                          var index = this._Remap[j];                            // Ensure there is always a non-zero weight even for zero alpha.                          var w = (rgba[4 * i + 3] + 1) / 256f;                            // Map this point and increase the weight.                          this._Weights[index] += (weightByAlpha ? w : 1f);                          this._Remap[i] = index;                          break;                      }                  }              }
Magic Number,DotSquish,ColourSet,C:\repos\Rogueadyn_SaintCoinach\DotSquish\ColourSet.cs,ColourSet,The following statement contains a magic number: for (int i = 0; i < 16; ++i) {                  // Check this pixel is enabled.                  int bit = 1 << i;                  if ((mask & bit) == 0) {                      this._Remap[i] = -1;                      continue;                  }                    // Check for transparent pixels when using DXT1.                  if (isDxt1 && rgba[4 * i + 3] < 128) {                      this._Remap[i] = -1;                      this._IsTransparent = true;                  }                    // Loop over previous points for a match.                  for (int j = 0; ; ++j) {                      // Allocate a new point.                      if (j == i) {                          // Normalise coordinates to [0'1].                          var x = rgba[4 * i] / 255f;                          var y = rgba[4 * i + 1] / 255f;                          var z = rgba[4 * i + 2] / 255f;                            // Ensure there is always a non-zero weight even for zero alpha.                          var w = (rgba[4 * i + 3] + 1) / 256f;                            // Add the point.                          this._Points[this._Count] = new Vector3(x' y' z);                          this._Weights[this._Count] = w;                          this._Remap[i] = this._Count;                            // Advance.                          ++this._Count;                          break;                      }                        // Check for a match.                      int oldBit = 1 << j;                      var match = ((mask & oldBit) != 0)                          && (rgba[4 * i] == rgba[4 * j])                          && (rgba[4 * i + 1] == rgba[4 * j + 1])                          && (rgba[4 * i + 3] == rgba[4 * j + 2])                          && (rgba[4 * j + 3] >= 128 || !isDxt1);                      if (match) {                          // Get index of the match.                          var index = this._Remap[j];                            // Ensure there is always a non-zero weight even for zero alpha.                          var w = (rgba[4 * i + 3] + 1) / 256f;                            // Map this point and increase the weight.                          this._Weights[index] += (weightByAlpha ? w : 1f);                          this._Remap[i] = index;                          break;                      }                  }              }
Magic Number,DotSquish,ColourSet,C:\repos\Rogueadyn_SaintCoinach\DotSquish\ColourSet.cs,ColourSet,The following statement contains a magic number: for (int i = 0; i < 16; ++i) {                  // Check this pixel is enabled.                  int bit = 1 << i;                  if ((mask & bit) == 0) {                      this._Remap[i] = -1;                      continue;                  }                    // Check for transparent pixels when using DXT1.                  if (isDxt1 && rgba[4 * i + 3] < 128) {                      this._Remap[i] = -1;                      this._IsTransparent = true;                  }                    // Loop over previous points for a match.                  for (int j = 0; ; ++j) {                      // Allocate a new point.                      if (j == i) {                          // Normalise coordinates to [0'1].                          var x = rgba[4 * i] / 255f;                          var y = rgba[4 * i + 1] / 255f;                          var z = rgba[4 * i + 2] / 255f;                            // Ensure there is always a non-zero weight even for zero alpha.                          var w = (rgba[4 * i + 3] + 1) / 256f;                            // Add the point.                          this._Points[this._Count] = new Vector3(x' y' z);                          this._Weights[this._Count] = w;                          this._Remap[i] = this._Count;                            // Advance.                          ++this._Count;                          break;                      }                        // Check for a match.                      int oldBit = 1 << j;                      var match = ((mask & oldBit) != 0)                          && (rgba[4 * i] == rgba[4 * j])                          && (rgba[4 * i + 1] == rgba[4 * j + 1])                          && (rgba[4 * i + 3] == rgba[4 * j + 2])                          && (rgba[4 * j + 3] >= 128 || !isDxt1);                      if (match) {                          // Get index of the match.                          var index = this._Remap[j];                            // Ensure there is always a non-zero weight even for zero alpha.                          var w = (rgba[4 * i + 3] + 1) / 256f;                            // Map this point and increase the weight.                          this._Weights[index] += (weightByAlpha ? w : 1f);                          this._Remap[i] = index;                          break;                      }                  }              }
Magic Number,DotSquish,ColourSet,C:\repos\Rogueadyn_SaintCoinach\DotSquish\ColourSet.cs,ColourSet,The following statement contains a magic number: for (int i = 0; i < 16; ++i) {                  // Check this pixel is enabled.                  int bit = 1 << i;                  if ((mask & bit) == 0) {                      this._Remap[i] = -1;                      continue;                  }                    // Check for transparent pixels when using DXT1.                  if (isDxt1 && rgba[4 * i + 3] < 128) {                      this._Remap[i] = -1;                      this._IsTransparent = true;                  }                    // Loop over previous points for a match.                  for (int j = 0; ; ++j) {                      // Allocate a new point.                      if (j == i) {                          // Normalise coordinates to [0'1].                          var x = rgba[4 * i] / 255f;                          var y = rgba[4 * i + 1] / 255f;                          var z = rgba[4 * i + 2] / 255f;                            // Ensure there is always a non-zero weight even for zero alpha.                          var w = (rgba[4 * i + 3] + 1) / 256f;                            // Add the point.                          this._Points[this._Count] = new Vector3(x' y' z);                          this._Weights[this._Count] = w;                          this._Remap[i] = this._Count;                            // Advance.                          ++this._Count;                          break;                      }                        // Check for a match.                      int oldBit = 1 << j;                      var match = ((mask & oldBit) != 0)                          && (rgba[4 * i] == rgba[4 * j])                          && (rgba[4 * i + 1] == rgba[4 * j + 1])                          && (rgba[4 * i + 3] == rgba[4 * j + 2])                          && (rgba[4 * j + 3] >= 128 || !isDxt1);                      if (match) {                          // Get index of the match.                          var index = this._Remap[j];                            // Ensure there is always a non-zero weight even for zero alpha.                          var w = (rgba[4 * i + 3] + 1) / 256f;                            // Map this point and increase the weight.                          this._Weights[index] += (weightByAlpha ? w : 1f);                          this._Remap[i] = index;                          break;                      }                  }              }
Magic Number,DotSquish,ColourSet,C:\repos\Rogueadyn_SaintCoinach\DotSquish\ColourSet.cs,ColourSet,The following statement contains a magic number: for (int i = 0; i < 16; ++i) {                  // Check this pixel is enabled.                  int bit = 1 << i;                  if ((mask & bit) == 0) {                      this._Remap[i] = -1;                      continue;                  }                    // Check for transparent pixels when using DXT1.                  if (isDxt1 && rgba[4 * i + 3] < 128) {                      this._Remap[i] = -1;                      this._IsTransparent = true;                  }                    // Loop over previous points for a match.                  for (int j = 0; ; ++j) {                      // Allocate a new point.                      if (j == i) {                          // Normalise coordinates to [0'1].                          var x = rgba[4 * i] / 255f;                          var y = rgba[4 * i + 1] / 255f;                          var z = rgba[4 * i + 2] / 255f;                            // Ensure there is always a non-zero weight even for zero alpha.                          var w = (rgba[4 * i + 3] + 1) / 256f;                            // Add the point.                          this._Points[this._Count] = new Vector3(x' y' z);                          this._Weights[this._Count] = w;                          this._Remap[i] = this._Count;                            // Advance.                          ++this._Count;                          break;                      }                        // Check for a match.                      int oldBit = 1 << j;                      var match = ((mask & oldBit) != 0)                          && (rgba[4 * i] == rgba[4 * j])                          && (rgba[4 * i + 1] == rgba[4 * j + 1])                          && (rgba[4 * i + 3] == rgba[4 * j + 2])                          && (rgba[4 * j + 3] >= 128 || !isDxt1);                      if (match) {                          // Get index of the match.                          var index = this._Remap[j];                            // Ensure there is always a non-zero weight even for zero alpha.                          var w = (rgba[4 * i + 3] + 1) / 256f;                            // Map this point and increase the weight.                          this._Weights[index] += (weightByAlpha ? w : 1f);                          this._Remap[i] = index;                          break;                      }                  }              }
Magic Number,DotSquish,ColourSet,C:\repos\Rogueadyn_SaintCoinach\DotSquish\ColourSet.cs,ColourSet,The following statement contains a magic number: for (int i = 0; i < 16; ++i) {                  // Check this pixel is enabled.                  int bit = 1 << i;                  if ((mask & bit) == 0) {                      this._Remap[i] = -1;                      continue;                  }                    // Check for transparent pixels when using DXT1.                  if (isDxt1 && rgba[4 * i + 3] < 128) {                      this._Remap[i] = -1;                      this._IsTransparent = true;                  }                    // Loop over previous points for a match.                  for (int j = 0; ; ++j) {                      // Allocate a new point.                      if (j == i) {                          // Normalise coordinates to [0'1].                          var x = rgba[4 * i] / 255f;                          var y = rgba[4 * i + 1] / 255f;                          var z = rgba[4 * i + 2] / 255f;                            // Ensure there is always a non-zero weight even for zero alpha.                          var w = (rgba[4 * i + 3] + 1) / 256f;                            // Add the point.                          this._Points[this._Count] = new Vector3(x' y' z);                          this._Weights[this._Count] = w;                          this._Remap[i] = this._Count;                            // Advance.                          ++this._Count;                          break;                      }                        // Check for a match.                      int oldBit = 1 << j;                      var match = ((mask & oldBit) != 0)                          && (rgba[4 * i] == rgba[4 * j])                          && (rgba[4 * i + 1] == rgba[4 * j + 1])                          && (rgba[4 * i + 3] == rgba[4 * j + 2])                          && (rgba[4 * j + 3] >= 128 || !isDxt1);                      if (match) {                          // Get index of the match.                          var index = this._Remap[j];                            // Ensure there is always a non-zero weight even for zero alpha.                          var w = (rgba[4 * i + 3] + 1) / 256f;                            // Map this point and increase the weight.                          this._Weights[index] += (weightByAlpha ? w : 1f);                          this._Remap[i] = index;                          break;                      }                  }              }
Magic Number,DotSquish,ColourSet,C:\repos\Rogueadyn_SaintCoinach\DotSquish\ColourSet.cs,ColourSet,The following statement contains a magic number: for (int i = 0; i < 16; ++i) {                  // Check this pixel is enabled.                  int bit = 1 << i;                  if ((mask & bit) == 0) {                      this._Remap[i] = -1;                      continue;                  }                    // Check for transparent pixels when using DXT1.                  if (isDxt1 && rgba[4 * i + 3] < 128) {                      this._Remap[i] = -1;                      this._IsTransparent = true;                  }                    // Loop over previous points for a match.                  for (int j = 0; ; ++j) {                      // Allocate a new point.                      if (j == i) {                          // Normalise coordinates to [0'1].                          var x = rgba[4 * i] / 255f;                          var y = rgba[4 * i + 1] / 255f;                          var z = rgba[4 * i + 2] / 255f;                            // Ensure there is always a non-zero weight even for zero alpha.                          var w = (rgba[4 * i + 3] + 1) / 256f;                            // Add the point.                          this._Points[this._Count] = new Vector3(x' y' z);                          this._Weights[this._Count] = w;                          this._Remap[i] = this._Count;                            // Advance.                          ++this._Count;                          break;                      }                        // Check for a match.                      int oldBit = 1 << j;                      var match = ((mask & oldBit) != 0)                          && (rgba[4 * i] == rgba[4 * j])                          && (rgba[4 * i + 1] == rgba[4 * j + 1])                          && (rgba[4 * i + 3] == rgba[4 * j + 2])                          && (rgba[4 * j + 3] >= 128 || !isDxt1);                      if (match) {                          // Get index of the match.                          var index = this._Remap[j];                            // Ensure there is always a non-zero weight even for zero alpha.                          var w = (rgba[4 * i + 3] + 1) / 256f;                            // Map this point and increase the weight.                          this._Weights[index] += (weightByAlpha ? w : 1f);                          this._Remap[i] = index;                          break;                      }                  }              }
Magic Number,DotSquish,ColourSet,C:\repos\Rogueadyn_SaintCoinach\DotSquish\ColourSet.cs,ColourSet,The following statement contains a magic number: for (int i = 0; i < 16; ++i) {                  // Check this pixel is enabled.                  int bit = 1 << i;                  if ((mask & bit) == 0) {                      this._Remap[i] = -1;                      continue;                  }                    // Check for transparent pixels when using DXT1.                  if (isDxt1 && rgba[4 * i + 3] < 128) {                      this._Remap[i] = -1;                      this._IsTransparent = true;                  }                    // Loop over previous points for a match.                  for (int j = 0; ; ++j) {                      // Allocate a new point.                      if (j == i) {                          // Normalise coordinates to [0'1].                          var x = rgba[4 * i] / 255f;                          var y = rgba[4 * i + 1] / 255f;                          var z = rgba[4 * i + 2] / 255f;                            // Ensure there is always a non-zero weight even for zero alpha.                          var w = (rgba[4 * i + 3] + 1) / 256f;                            // Add the point.                          this._Points[this._Count] = new Vector3(x' y' z);                          this._Weights[this._Count] = w;                          this._Remap[i] = this._Count;                            // Advance.                          ++this._Count;                          break;                      }                        // Check for a match.                      int oldBit = 1 << j;                      var match = ((mask & oldBit) != 0)                          && (rgba[4 * i] == rgba[4 * j])                          && (rgba[4 * i + 1] == rgba[4 * j + 1])                          && (rgba[4 * i + 3] == rgba[4 * j + 2])                          && (rgba[4 * j + 3] >= 128 || !isDxt1);                      if (match) {                          // Get index of the match.                          var index = this._Remap[j];                            // Ensure there is always a non-zero weight even for zero alpha.                          var w = (rgba[4 * i + 3] + 1) / 256f;                            // Map this point and increase the weight.                          this._Weights[index] += (weightByAlpha ? w : 1f);                          this._Remap[i] = index;                          break;                      }                  }              }
Magic Number,DotSquish,ColourSet,C:\repos\Rogueadyn_SaintCoinach\DotSquish\ColourSet.cs,ColourSet,The following statement contains a magic number: for (int i = 0; i < 16; ++i) {                  // Check this pixel is enabled.                  int bit = 1 << i;                  if ((mask & bit) == 0) {                      this._Remap[i] = -1;                      continue;                  }                    // Check for transparent pixels when using DXT1.                  if (isDxt1 && rgba[4 * i + 3] < 128) {                      this._Remap[i] = -1;                      this._IsTransparent = true;                  }                    // Loop over previous points for a match.                  for (int j = 0; ; ++j) {                      // Allocate a new point.                      if (j == i) {                          // Normalise coordinates to [0'1].                          var x = rgba[4 * i] / 255f;                          var y = rgba[4 * i + 1] / 255f;                          var z = rgba[4 * i + 2] / 255f;                            // Ensure there is always a non-zero weight even for zero alpha.                          var w = (rgba[4 * i + 3] + 1) / 256f;                            // Add the point.                          this._Points[this._Count] = new Vector3(x' y' z);                          this._Weights[this._Count] = w;                          this._Remap[i] = this._Count;                            // Advance.                          ++this._Count;                          break;                      }                        // Check for a match.                      int oldBit = 1 << j;                      var match = ((mask & oldBit) != 0)                          && (rgba[4 * i] == rgba[4 * j])                          && (rgba[4 * i + 1] == rgba[4 * j + 1])                          && (rgba[4 * i + 3] == rgba[4 * j + 2])                          && (rgba[4 * j + 3] >= 128 || !isDxt1);                      if (match) {                          // Get index of the match.                          var index = this._Remap[j];                            // Ensure there is always a non-zero weight even for zero alpha.                          var w = (rgba[4 * i + 3] + 1) / 256f;                            // Map this point and increase the weight.                          this._Weights[index] += (weightByAlpha ? w : 1f);                          this._Remap[i] = index;                          break;                      }                  }              }
Magic Number,DotSquish,ColourSet,C:\repos\Rogueadyn_SaintCoinach\DotSquish\ColourSet.cs,ColourSet,The following statement contains a magic number: for (int i = 0; i < 16; ++i) {                  // Check this pixel is enabled.                  int bit = 1 << i;                  if ((mask & bit) == 0) {                      this._Remap[i] = -1;                      continue;                  }                    // Check for transparent pixels when using DXT1.                  if (isDxt1 && rgba[4 * i + 3] < 128) {                      this._Remap[i] = -1;                      this._IsTransparent = true;                  }                    // Loop over previous points for a match.                  for (int j = 0; ; ++j) {                      // Allocate a new point.                      if (j == i) {                          // Normalise coordinates to [0'1].                          var x = rgba[4 * i] / 255f;                          var y = rgba[4 * i + 1] / 255f;                          var z = rgba[4 * i + 2] / 255f;                            // Ensure there is always a non-zero weight even for zero alpha.                          var w = (rgba[4 * i + 3] + 1) / 256f;                            // Add the point.                          this._Points[this._Count] = new Vector3(x' y' z);                          this._Weights[this._Count] = w;                          this._Remap[i] = this._Count;                            // Advance.                          ++this._Count;                          break;                      }                        // Check for a match.                      int oldBit = 1 << j;                      var match = ((mask & oldBit) != 0)                          && (rgba[4 * i] == rgba[4 * j])                          && (rgba[4 * i + 1] == rgba[4 * j + 1])                          && (rgba[4 * i + 3] == rgba[4 * j + 2])                          && (rgba[4 * j + 3] >= 128 || !isDxt1);                      if (match) {                          // Get index of the match.                          var index = this._Remap[j];                            // Ensure there is always a non-zero weight even for zero alpha.                          var w = (rgba[4 * i + 3] + 1) / 256f;                            // Map this point and increase the weight.                          this._Weights[index] += (weightByAlpha ? w : 1f);                          this._Remap[i] = index;                          break;                      }                  }              }
Magic Number,DotSquish,ColourSet,C:\repos\Rogueadyn_SaintCoinach\DotSquish\ColourSet.cs,ColourSet,The following statement contains a magic number: for (int i = 0; i < 16; ++i) {                  // Check this pixel is enabled.                  int bit = 1 << i;                  if ((mask & bit) == 0) {                      this._Remap[i] = -1;                      continue;                  }                    // Check for transparent pixels when using DXT1.                  if (isDxt1 && rgba[4 * i + 3] < 128) {                      this._Remap[i] = -1;                      this._IsTransparent = true;                  }                    // Loop over previous points for a match.                  for (int j = 0; ; ++j) {                      // Allocate a new point.                      if (j == i) {                          // Normalise coordinates to [0'1].                          var x = rgba[4 * i] / 255f;                          var y = rgba[4 * i + 1] / 255f;                          var z = rgba[4 * i + 2] / 255f;                            // Ensure there is always a non-zero weight even for zero alpha.                          var w = (rgba[4 * i + 3] + 1) / 256f;                            // Add the point.                          this._Points[this._Count] = new Vector3(x' y' z);                          this._Weights[this._Count] = w;                          this._Remap[i] = this._Count;                            // Advance.                          ++this._Count;                          break;                      }                        // Check for a match.                      int oldBit = 1 << j;                      var match = ((mask & oldBit) != 0)                          && (rgba[4 * i] == rgba[4 * j])                          && (rgba[4 * i + 1] == rgba[4 * j + 1])                          && (rgba[4 * i + 3] == rgba[4 * j + 2])                          && (rgba[4 * j + 3] >= 128 || !isDxt1);                      if (match) {                          // Get index of the match.                          var index = this._Remap[j];                            // Ensure there is always a non-zero weight even for zero alpha.                          var w = (rgba[4 * i + 3] + 1) / 256f;                            // Map this point and increase the weight.                          this._Weights[index] += (weightByAlpha ? w : 1f);                          this._Remap[i] = index;                          break;                      }                  }              }
Magic Number,DotSquish,ColourSet,C:\repos\Rogueadyn_SaintCoinach\DotSquish\ColourSet.cs,ColourSet,The following statement contains a magic number: for (int i = 0; i < 16; ++i) {                  // Check this pixel is enabled.                  int bit = 1 << i;                  if ((mask & bit) == 0) {                      this._Remap[i] = -1;                      continue;                  }                    // Check for transparent pixels when using DXT1.                  if (isDxt1 && rgba[4 * i + 3] < 128) {                      this._Remap[i] = -1;                      this._IsTransparent = true;                  }                    // Loop over previous points for a match.                  for (int j = 0; ; ++j) {                      // Allocate a new point.                      if (j == i) {                          // Normalise coordinates to [0'1].                          var x = rgba[4 * i] / 255f;                          var y = rgba[4 * i + 1] / 255f;                          var z = rgba[4 * i + 2] / 255f;                            // Ensure there is always a non-zero weight even for zero alpha.                          var w = (rgba[4 * i + 3] + 1) / 256f;                            // Add the point.                          this._Points[this._Count] = new Vector3(x' y' z);                          this._Weights[this._Count] = w;                          this._Remap[i] = this._Count;                            // Advance.                          ++this._Count;                          break;                      }                        // Check for a match.                      int oldBit = 1 << j;                      var match = ((mask & oldBit) != 0)                          && (rgba[4 * i] == rgba[4 * j])                          && (rgba[4 * i + 1] == rgba[4 * j + 1])                          && (rgba[4 * i + 3] == rgba[4 * j + 2])                          && (rgba[4 * j + 3] >= 128 || !isDxt1);                      if (match) {                          // Get index of the match.                          var index = this._Remap[j];                            // Ensure there is always a non-zero weight even for zero alpha.                          var w = (rgba[4 * i + 3] + 1) / 256f;                            // Map this point and increase the weight.                          this._Weights[index] += (weightByAlpha ? w : 1f);                          this._Remap[i] = index;                          break;                      }                  }              }
Magic Number,DotSquish,ColourSet,C:\repos\Rogueadyn_SaintCoinach\DotSquish\ColourSet.cs,ColourSet,The following statement contains a magic number: for (int i = 0; i < 16; ++i) {                  // Check this pixel is enabled.                  int bit = 1 << i;                  if ((mask & bit) == 0) {                      this._Remap[i] = -1;                      continue;                  }                    // Check for transparent pixels when using DXT1.                  if (isDxt1 && rgba[4 * i + 3] < 128) {                      this._Remap[i] = -1;                      this._IsTransparent = true;                  }                    // Loop over previous points for a match.                  for (int j = 0; ; ++j) {                      // Allocate a new point.                      if (j == i) {                          // Normalise coordinates to [0'1].                          var x = rgba[4 * i] / 255f;                          var y = rgba[4 * i + 1] / 255f;                          var z = rgba[4 * i + 2] / 255f;                            // Ensure there is always a non-zero weight even for zero alpha.                          var w = (rgba[4 * i + 3] + 1) / 256f;                            // Add the point.                          this._Points[this._Count] = new Vector3(x' y' z);                          this._Weights[this._Count] = w;                          this._Remap[i] = this._Count;                            // Advance.                          ++this._Count;                          break;                      }                        // Check for a match.                      int oldBit = 1 << j;                      var match = ((mask & oldBit) != 0)                          && (rgba[4 * i] == rgba[4 * j])                          && (rgba[4 * i + 1] == rgba[4 * j + 1])                          && (rgba[4 * i + 3] == rgba[4 * j + 2])                          && (rgba[4 * j + 3] >= 128 || !isDxt1);                      if (match) {                          // Get index of the match.                          var index = this._Remap[j];                            // Ensure there is always a non-zero weight even for zero alpha.                          var w = (rgba[4 * i + 3] + 1) / 256f;                            // Map this point and increase the weight.                          this._Weights[index] += (weightByAlpha ? w : 1f);                          this._Remap[i] = index;                          break;                      }                  }              }
Magic Number,DotSquish,ColourSet,C:\repos\Rogueadyn_SaintCoinach\DotSquish\ColourSet.cs,ColourSet,The following statement contains a magic number: for (int i = 0; i < 16; ++i) {                  // Check this pixel is enabled.                  int bit = 1 << i;                  if ((mask & bit) == 0) {                      this._Remap[i] = -1;                      continue;                  }                    // Check for transparent pixels when using DXT1.                  if (isDxt1 && rgba[4 * i + 3] < 128) {                      this._Remap[i] = -1;                      this._IsTransparent = true;                  }                    // Loop over previous points for a match.                  for (int j = 0; ; ++j) {                      // Allocate a new point.                      if (j == i) {                          // Normalise coordinates to [0'1].                          var x = rgba[4 * i] / 255f;                          var y = rgba[4 * i + 1] / 255f;                          var z = rgba[4 * i + 2] / 255f;                            // Ensure there is always a non-zero weight even for zero alpha.                          var w = (rgba[4 * i + 3] + 1) / 256f;                            // Add the point.                          this._Points[this._Count] = new Vector3(x' y' z);                          this._Weights[this._Count] = w;                          this._Remap[i] = this._Count;                            // Advance.                          ++this._Count;                          break;                      }                        // Check for a match.                      int oldBit = 1 << j;                      var match = ((mask & oldBit) != 0)                          && (rgba[4 * i] == rgba[4 * j])                          && (rgba[4 * i + 1] == rgba[4 * j + 1])                          && (rgba[4 * i + 3] == rgba[4 * j + 2])                          && (rgba[4 * j + 3] >= 128 || !isDxt1);                      if (match) {                          // Get index of the match.                          var index = this._Remap[j];                            // Ensure there is always a non-zero weight even for zero alpha.                          var w = (rgba[4 * i + 3] + 1) / 256f;                            // Map this point and increase the weight.                          this._Weights[index] += (weightByAlpha ? w : 1f);                          this._Remap[i] = index;                          break;                      }                  }              }
Magic Number,DotSquish,ColourSet,C:\repos\Rogueadyn_SaintCoinach\DotSquish\ColourSet.cs,ColourSet,The following statement contains a magic number: for (int i = 0; i < 16; ++i) {                  // Check this pixel is enabled.                  int bit = 1 << i;                  if ((mask & bit) == 0) {                      this._Remap[i] = -1;                      continue;                  }                    // Check for transparent pixels when using DXT1.                  if (isDxt1 && rgba[4 * i + 3] < 128) {                      this._Remap[i] = -1;                      this._IsTransparent = true;                  }                    // Loop over previous points for a match.                  for (int j = 0; ; ++j) {                      // Allocate a new point.                      if (j == i) {                          // Normalise coordinates to [0'1].                          var x = rgba[4 * i] / 255f;                          var y = rgba[4 * i + 1] / 255f;                          var z = rgba[4 * i + 2] / 255f;                            // Ensure there is always a non-zero weight even for zero alpha.                          var w = (rgba[4 * i + 3] + 1) / 256f;                            // Add the point.                          this._Points[this._Count] = new Vector3(x' y' z);                          this._Weights[this._Count] = w;                          this._Remap[i] = this._Count;                            // Advance.                          ++this._Count;                          break;                      }                        // Check for a match.                      int oldBit = 1 << j;                      var match = ((mask & oldBit) != 0)                          && (rgba[4 * i] == rgba[4 * j])                          && (rgba[4 * i + 1] == rgba[4 * j + 1])                          && (rgba[4 * i + 3] == rgba[4 * j + 2])                          && (rgba[4 * j + 3] >= 128 || !isDxt1);                      if (match) {                          // Get index of the match.                          var index = this._Remap[j];                            // Ensure there is always a non-zero weight even for zero alpha.                          var w = (rgba[4 * i + 3] + 1) / 256f;                            // Map this point and increase the weight.                          this._Weights[index] += (weightByAlpha ? w : 1f);                          this._Remap[i] = index;                          break;                      }                  }              }
Magic Number,DotSquish,ColourSet,C:\repos\Rogueadyn_SaintCoinach\DotSquish\ColourSet.cs,ColourSet,The following statement contains a magic number: for (int i = 0; i < 16; ++i) {                  // Check this pixel is enabled.                  int bit = 1 << i;                  if ((mask & bit) == 0) {                      this._Remap[i] = -1;                      continue;                  }                    // Check for transparent pixels when using DXT1.                  if (isDxt1 && rgba[4 * i + 3] < 128) {                      this._Remap[i] = -1;                      this._IsTransparent = true;                  }                    // Loop over previous points for a match.                  for (int j = 0; ; ++j) {                      // Allocate a new point.                      if (j == i) {                          // Normalise coordinates to [0'1].                          var x = rgba[4 * i] / 255f;                          var y = rgba[4 * i + 1] / 255f;                          var z = rgba[4 * i + 2] / 255f;                            // Ensure there is always a non-zero weight even for zero alpha.                          var w = (rgba[4 * i + 3] + 1) / 256f;                            // Add the point.                          this._Points[this._Count] = new Vector3(x' y' z);                          this._Weights[this._Count] = w;                          this._Remap[i] = this._Count;                            // Advance.                          ++this._Count;                          break;                      }                        // Check for a match.                      int oldBit = 1 << j;                      var match = ((mask & oldBit) != 0)                          && (rgba[4 * i] == rgba[4 * j])                          && (rgba[4 * i + 1] == rgba[4 * j + 1])                          && (rgba[4 * i + 3] == rgba[4 * j + 2])                          && (rgba[4 * j + 3] >= 128 || !isDxt1);                      if (match) {                          // Get index of the match.                          var index = this._Remap[j];                            // Ensure there is always a non-zero weight even for zero alpha.                          var w = (rgba[4 * i + 3] + 1) / 256f;                            // Map this point and increase the weight.                          this._Weights[index] += (weightByAlpha ? w : 1f);                          this._Remap[i] = index;                          break;                      }                  }              }
Magic Number,DotSquish,ColourSet,C:\repos\Rogueadyn_SaintCoinach\DotSquish\ColourSet.cs,ColourSet,The following statement contains a magic number: for (int i = 0; i < 16; ++i) {                  // Check this pixel is enabled.                  int bit = 1 << i;                  if ((mask & bit) == 0) {                      this._Remap[i] = -1;                      continue;                  }                    // Check for transparent pixels when using DXT1.                  if (isDxt1 && rgba[4 * i + 3] < 128) {                      this._Remap[i] = -1;                      this._IsTransparent = true;                  }                    // Loop over previous points for a match.                  for (int j = 0; ; ++j) {                      // Allocate a new point.                      if (j == i) {                          // Normalise coordinates to [0'1].                          var x = rgba[4 * i] / 255f;                          var y = rgba[4 * i + 1] / 255f;                          var z = rgba[4 * i + 2] / 255f;                            // Ensure there is always a non-zero weight even for zero alpha.                          var w = (rgba[4 * i + 3] + 1) / 256f;                            // Add the point.                          this._Points[this._Count] = new Vector3(x' y' z);                          this._Weights[this._Count] = w;                          this._Remap[i] = this._Count;                            // Advance.                          ++this._Count;                          break;                      }                        // Check for a match.                      int oldBit = 1 << j;                      var match = ((mask & oldBit) != 0)                          && (rgba[4 * i] == rgba[4 * j])                          && (rgba[4 * i + 1] == rgba[4 * j + 1])                          && (rgba[4 * i + 3] == rgba[4 * j + 2])                          && (rgba[4 * j + 3] >= 128 || !isDxt1);                      if (match) {                          // Get index of the match.                          var index = this._Remap[j];                            // Ensure there is always a non-zero weight even for zero alpha.                          var w = (rgba[4 * i + 3] + 1) / 256f;                            // Map this point and increase the weight.                          this._Weights[index] += (weightByAlpha ? w : 1f);                          this._Remap[i] = index;                          break;                      }                  }              }
Magic Number,DotSquish,ColourSet,C:\repos\Rogueadyn_SaintCoinach\DotSquish\ColourSet.cs,ColourSet,The following statement contains a magic number: for (int i = 0; i < 16; ++i) {                  // Check this pixel is enabled.                  int bit = 1 << i;                  if ((mask & bit) == 0) {                      this._Remap[i] = -1;                      continue;                  }                    // Check for transparent pixels when using DXT1.                  if (isDxt1 && rgba[4 * i + 3] < 128) {                      this._Remap[i] = -1;                      this._IsTransparent = true;                  }                    // Loop over previous points for a match.                  for (int j = 0; ; ++j) {                      // Allocate a new point.                      if (j == i) {                          // Normalise coordinates to [0'1].                          var x = rgba[4 * i] / 255f;                          var y = rgba[4 * i + 1] / 255f;                          var z = rgba[4 * i + 2] / 255f;                            // Ensure there is always a non-zero weight even for zero alpha.                          var w = (rgba[4 * i + 3] + 1) / 256f;                            // Add the point.                          this._Points[this._Count] = new Vector3(x' y' z);                          this._Weights[this._Count] = w;                          this._Remap[i] = this._Count;                            // Advance.                          ++this._Count;                          break;                      }                        // Check for a match.                      int oldBit = 1 << j;                      var match = ((mask & oldBit) != 0)                          && (rgba[4 * i] == rgba[4 * j])                          && (rgba[4 * i + 1] == rgba[4 * j + 1])                          && (rgba[4 * i + 3] == rgba[4 * j + 2])                          && (rgba[4 * j + 3] >= 128 || !isDxt1);                      if (match) {                          // Get index of the match.                          var index = this._Remap[j];                            // Ensure there is always a non-zero weight even for zero alpha.                          var w = (rgba[4 * i + 3] + 1) / 256f;                            // Map this point and increase the weight.                          this._Weights[index] += (weightByAlpha ? w : 1f);                          this._Remap[i] = index;                          break;                      }                  }              }
Magic Number,DotSquish,ColourSet,C:\repos\Rogueadyn_SaintCoinach\DotSquish\ColourSet.cs,ColourSet,The following statement contains a magic number: for (int i = 0; i < 16; ++i) {                  // Check this pixel is enabled.                  int bit = 1 << i;                  if ((mask & bit) == 0) {                      this._Remap[i] = -1;                      continue;                  }                    // Check for transparent pixels when using DXT1.                  if (isDxt1 && rgba[4 * i + 3] < 128) {                      this._Remap[i] = -1;                      this._IsTransparent = true;                  }                    // Loop over previous points for a match.                  for (int j = 0; ; ++j) {                      // Allocate a new point.                      if (j == i) {                          // Normalise coordinates to [0'1].                          var x = rgba[4 * i] / 255f;                          var y = rgba[4 * i + 1] / 255f;                          var z = rgba[4 * i + 2] / 255f;                            // Ensure there is always a non-zero weight even for zero alpha.                          var w = (rgba[4 * i + 3] + 1) / 256f;                            // Add the point.                          this._Points[this._Count] = new Vector3(x' y' z);                          this._Weights[this._Count] = w;                          this._Remap[i] = this._Count;                            // Advance.                          ++this._Count;                          break;                      }                        // Check for a match.                      int oldBit = 1 << j;                      var match = ((mask & oldBit) != 0)                          && (rgba[4 * i] == rgba[4 * j])                          && (rgba[4 * i + 1] == rgba[4 * j + 1])                          && (rgba[4 * i + 3] == rgba[4 * j + 2])                          && (rgba[4 * j + 3] >= 128 || !isDxt1);                      if (match) {                          // Get index of the match.                          var index = this._Remap[j];                            // Ensure there is always a non-zero weight even for zero alpha.                          var w = (rgba[4 * i + 3] + 1) / 256f;                            // Map this point and increase the weight.                          this._Weights[index] += (weightByAlpha ? w : 1f);                          this._Remap[i] = index;                          break;                      }                  }              }
Magic Number,DotSquish,ColourSet,C:\repos\Rogueadyn_SaintCoinach\DotSquish\ColourSet.cs,ColourSet,The following statement contains a magic number: for (int i = 0; i < 16; ++i) {                  // Check this pixel is enabled.                  int bit = 1 << i;                  if ((mask & bit) == 0) {                      this._Remap[i] = -1;                      continue;                  }                    // Check for transparent pixels when using DXT1.                  if (isDxt1 && rgba[4 * i + 3] < 128) {                      this._Remap[i] = -1;                      this._IsTransparent = true;                  }                    // Loop over previous points for a match.                  for (int j = 0; ; ++j) {                      // Allocate a new point.                      if (j == i) {                          // Normalise coordinates to [0'1].                          var x = rgba[4 * i] / 255f;                          var y = rgba[4 * i + 1] / 255f;                          var z = rgba[4 * i + 2] / 255f;                            // Ensure there is always a non-zero weight even for zero alpha.                          var w = (rgba[4 * i + 3] + 1) / 256f;                            // Add the point.                          this._Points[this._Count] = new Vector3(x' y' z);                          this._Weights[this._Count] = w;                          this._Remap[i] = this._Count;                            // Advance.                          ++this._Count;                          break;                      }                        // Check for a match.                      int oldBit = 1 << j;                      var match = ((mask & oldBit) != 0)                          && (rgba[4 * i] == rgba[4 * j])                          && (rgba[4 * i + 1] == rgba[4 * j + 1])                          && (rgba[4 * i + 3] == rgba[4 * j + 2])                          && (rgba[4 * j + 3] >= 128 || !isDxt1);                      if (match) {                          // Get index of the match.                          var index = this._Remap[j];                            // Ensure there is always a non-zero weight even for zero alpha.                          var w = (rgba[4 * i + 3] + 1) / 256f;                            // Map this point and increase the weight.                          this._Weights[index] += (weightByAlpha ? w : 1f);                          this._Remap[i] = index;                          break;                      }                  }              }
Magic Number,DotSquish,ColourSet,C:\repos\Rogueadyn_SaintCoinach\DotSquish\ColourSet.cs,ColourSet,The following statement contains a magic number: for (int i = 0; i < 16; ++i) {                  // Check this pixel is enabled.                  int bit = 1 << i;                  if ((mask & bit) == 0) {                      this._Remap[i] = -1;                      continue;                  }                    // Check for transparent pixels when using DXT1.                  if (isDxt1 && rgba[4 * i + 3] < 128) {                      this._Remap[i] = -1;                      this._IsTransparent = true;                  }                    // Loop over previous points for a match.                  for (int j = 0; ; ++j) {                      // Allocate a new point.                      if (j == i) {                          // Normalise coordinates to [0'1].                          var x = rgba[4 * i] / 255f;                          var y = rgba[4 * i + 1] / 255f;                          var z = rgba[4 * i + 2] / 255f;                            // Ensure there is always a non-zero weight even for zero alpha.                          var w = (rgba[4 * i + 3] + 1) / 256f;                            // Add the point.                          this._Points[this._Count] = new Vector3(x' y' z);                          this._Weights[this._Count] = w;                          this._Remap[i] = this._Count;                            // Advance.                          ++this._Count;                          break;                      }                        // Check for a match.                      int oldBit = 1 << j;                      var match = ((mask & oldBit) != 0)                          && (rgba[4 * i] == rgba[4 * j])                          && (rgba[4 * i + 1] == rgba[4 * j + 1])                          && (rgba[4 * i + 3] == rgba[4 * j + 2])                          && (rgba[4 * j + 3] >= 128 || !isDxt1);                      if (match) {                          // Get index of the match.                          var index = this._Remap[j];                            // Ensure there is always a non-zero weight even for zero alpha.                          var w = (rgba[4 * i + 3] + 1) / 256f;                            // Map this point and increase the weight.                          this._Weights[index] += (weightByAlpha ? w : 1f);                          this._Remap[i] = index;                          break;                      }                  }              }
Magic Number,DotSquish,ColourSet,C:\repos\Rogueadyn_SaintCoinach\DotSquish\ColourSet.cs,RemapIndices,The following statement contains a magic number: for (int i = 0; i < 16; ++i) {                  var j = this._Remap[i];                  if (j == -1)                      target[i + targetOffset] = 3;                  else                      target[i + targetOffset] = source[j];              }
Magic Number,DotSquish,ColourSet,C:\repos\Rogueadyn_SaintCoinach\DotSquish\ColourSet.cs,RemapIndices,The following statement contains a magic number: for (int i = 0; i < 16; ++i) {                  var j = this._Remap[i];                  if (j == -1)                      target[i + targetOffset] = 3;                  else                      target[i + targetOffset] = source[j];              }
Magic Number,DotSquish,Sym3x3,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Maths.cs,Sym3x3,The following statement contains a magic number: for (int i = 0; i < 6; ++i)                  this._X[i] = s;
Magic Number,DotSquish,Sym3x3,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Maths.cs,ComputeWeightedCovariance,The following statement contains a magic number: for (int i = 0; i < n; ++i) {                  var a = points[i] - centroid;                  var b = weights[i] * a;                    covariance[0] += a.X * b.X;                  covariance[1] += a.X * b.Y;                  covariance[2] += a.X * b.Z;                  covariance[3] += a.Y * b.Y;                  covariance[4] += a.Y * b.Z;                  covariance[5] += a.Z * b.Z;              }
Magic Number,DotSquish,Sym3x3,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Maths.cs,ComputeWeightedCovariance,The following statement contains a magic number: for (int i = 0; i < n; ++i) {                  var a = points[i] - centroid;                  var b = weights[i] * a;                    covariance[0] += a.X * b.X;                  covariance[1] += a.X * b.Y;                  covariance[2] += a.X * b.Z;                  covariance[3] += a.Y * b.Y;                  covariance[4] += a.Y * b.Z;                  covariance[5] += a.Z * b.Z;              }
Magic Number,DotSquish,Sym3x3,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Maths.cs,ComputeWeightedCovariance,The following statement contains a magic number: for (int i = 0; i < n; ++i) {                  var a = points[i] - centroid;                  var b = weights[i] * a;                    covariance[0] += a.X * b.X;                  covariance[1] += a.X * b.Y;                  covariance[2] += a.X * b.Z;                  covariance[3] += a.Y * b.Y;                  covariance[4] += a.Y * b.Z;                  covariance[5] += a.Z * b.Z;              }
Magic Number,DotSquish,Sym3x3,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Maths.cs,ComputeWeightedCovariance,The following statement contains a magic number: for (int i = 0; i < n; ++i) {                  var a = points[i] - centroid;                  var b = weights[i] * a;                    covariance[0] += a.X * b.X;                  covariance[1] += a.X * b.Y;                  covariance[2] += a.X * b.Z;                  covariance[3] += a.Y * b.Y;                  covariance[4] += a.Y * b.Z;                  covariance[5] += a.Z * b.Z;              }
Magic Number,DotSquish,Sym3x3,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Maths.cs,GetMultiplicity1Evector,The following statement contains a magic number: m[2] = matrix[2];
Magic Number,DotSquish,Sym3x3,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Maths.cs,GetMultiplicity1Evector,The following statement contains a magic number: m[2] = matrix[2];
Magic Number,DotSquish,Sym3x3,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Maths.cs,GetMultiplicity1Evector,The following statement contains a magic number: m[3] = matrix[3] - evalue;
Magic Number,DotSquish,Sym3x3,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Maths.cs,GetMultiplicity1Evector,The following statement contains a magic number: m[3] = matrix[3] - evalue;
Magic Number,DotSquish,Sym3x3,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Maths.cs,GetMultiplicity1Evector,The following statement contains a magic number: m[4] = matrix[4];
Magic Number,DotSquish,Sym3x3,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Maths.cs,GetMultiplicity1Evector,The following statement contains a magic number: m[4] = matrix[4];
Magic Number,DotSquish,Sym3x3,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Maths.cs,GetMultiplicity1Evector,The following statement contains a magic number: m[5] = matrix[5] - evalue;
Magic Number,DotSquish,Sym3x3,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Maths.cs,GetMultiplicity1Evector,The following statement contains a magic number: m[5] = matrix[5] - evalue;
Magic Number,DotSquish,Sym3x3,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Maths.cs,GetMultiplicity1Evector,The following statement contains a magic number: u[0] = (m[3] * m[5]) - (m[4] * m[4]);
Magic Number,DotSquish,Sym3x3,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Maths.cs,GetMultiplicity1Evector,The following statement contains a magic number: u[0] = (m[3] * m[5]) - (m[4] * m[4]);
Magic Number,DotSquish,Sym3x3,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Maths.cs,GetMultiplicity1Evector,The following statement contains a magic number: u[0] = (m[3] * m[5]) - (m[4] * m[4]);
Magic Number,DotSquish,Sym3x3,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Maths.cs,GetMultiplicity1Evector,The following statement contains a magic number: u[0] = (m[3] * m[5]) - (m[4] * m[4]);
Magic Number,DotSquish,Sym3x3,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Maths.cs,GetMultiplicity1Evector,The following statement contains a magic number: u[1] = (m[2] * m[4]) - (m[1] * m[5]);
Magic Number,DotSquish,Sym3x3,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Maths.cs,GetMultiplicity1Evector,The following statement contains a magic number: u[1] = (m[2] * m[4]) - (m[1] * m[5]);
Magic Number,DotSquish,Sym3x3,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Maths.cs,GetMultiplicity1Evector,The following statement contains a magic number: u[1] = (m[2] * m[4]) - (m[1] * m[5]);
Magic Number,DotSquish,Sym3x3,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Maths.cs,GetMultiplicity1Evector,The following statement contains a magic number: u[2] = (m[1] * m[4]) - (m[2] * m[3]);
Magic Number,DotSquish,Sym3x3,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Maths.cs,GetMultiplicity1Evector,The following statement contains a magic number: u[2] = (m[1] * m[4]) - (m[2] * m[3]);
Magic Number,DotSquish,Sym3x3,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Maths.cs,GetMultiplicity1Evector,The following statement contains a magic number: u[2] = (m[1] * m[4]) - (m[2] * m[3]);
Magic Number,DotSquish,Sym3x3,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Maths.cs,GetMultiplicity1Evector,The following statement contains a magic number: u[2] = (m[1] * m[4]) - (m[2] * m[3]);
Magic Number,DotSquish,Sym3x3,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Maths.cs,GetMultiplicity1Evector,The following statement contains a magic number: u[3] = (m[0] * m[5]) - (m[2] * m[2]);
Magic Number,DotSquish,Sym3x3,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Maths.cs,GetMultiplicity1Evector,The following statement contains a magic number: u[3] = (m[0] * m[5]) - (m[2] * m[2]);
Magic Number,DotSquish,Sym3x3,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Maths.cs,GetMultiplicity1Evector,The following statement contains a magic number: u[3] = (m[0] * m[5]) - (m[2] * m[2]);
Magic Number,DotSquish,Sym3x3,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Maths.cs,GetMultiplicity1Evector,The following statement contains a magic number: u[3] = (m[0] * m[5]) - (m[2] * m[2]);
Magic Number,DotSquish,Sym3x3,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Maths.cs,GetMultiplicity1Evector,The following statement contains a magic number: u[4] = (m[1] * m[2]) - (m[4] * m[0]);
Magic Number,DotSquish,Sym3x3,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Maths.cs,GetMultiplicity1Evector,The following statement contains a magic number: u[4] = (m[1] * m[2]) - (m[4] * m[0]);
Magic Number,DotSquish,Sym3x3,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Maths.cs,GetMultiplicity1Evector,The following statement contains a magic number: u[4] = (m[1] * m[2]) - (m[4] * m[0]);
Magic Number,DotSquish,Sym3x3,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Maths.cs,GetMultiplicity1Evector,The following statement contains a magic number: u[5] = (m[0] * m[3]) - (m[1] * m[1]);
Magic Number,DotSquish,Sym3x3,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Maths.cs,GetMultiplicity1Evector,The following statement contains a magic number: u[5] = (m[0] * m[3]) - (m[1] * m[1]);
Magic Number,DotSquish,Sym3x3,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Maths.cs,GetMultiplicity1Evector,The following statement contains a magic number: for (int i = 1; i < 6; ++i) {                  var c = Math.Abs(u[i]);                  if (c > mc) {                      mc = c;                      mi = i;                  }              }
Magic Number,DotSquish,Sym3x3,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Maths.cs,GetMultiplicity1Evector,The following statement contains a magic number: switch (mi) {                  case 0:                      return new Vector3(u[0]' u[1]' u[2]);                  case 1:                  case 3:                      return new Vector3(u[1]' u[3]' u[4]);                  default:                      return new Vector3(u[2]' u[4]' u[5]);              }
Magic Number,DotSquish,Sym3x3,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Maths.cs,GetMultiplicity1Evector,The following statement contains a magic number: switch (mi) {                  case 0:                      return new Vector3(u[0]' u[1]' u[2]);                  case 1:                  case 3:                      return new Vector3(u[1]' u[3]' u[4]);                  default:                      return new Vector3(u[2]' u[4]' u[5]);              }
Magic Number,DotSquish,Sym3x3,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Maths.cs,GetMultiplicity1Evector,The following statement contains a magic number: switch (mi) {                  case 0:                      return new Vector3(u[0]' u[1]' u[2]);                  case 1:                  case 3:                      return new Vector3(u[1]' u[3]' u[4]);                  default:                      return new Vector3(u[2]' u[4]' u[5]);              }
Magic Number,DotSquish,Sym3x3,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Maths.cs,GetMultiplicity1Evector,The following statement contains a magic number: switch (mi) {                  case 0:                      return new Vector3(u[0]' u[1]' u[2]);                  case 1:                  case 3:                      return new Vector3(u[1]' u[3]' u[4]);                  default:                      return new Vector3(u[2]' u[4]' u[5]);              }
Magic Number,DotSquish,Sym3x3,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Maths.cs,GetMultiplicity1Evector,The following statement contains a magic number: switch (mi) {                  case 0:                      return new Vector3(u[0]' u[1]' u[2]);                  case 1:                  case 3:                      return new Vector3(u[1]' u[3]' u[4]);                  default:                      return new Vector3(u[2]' u[4]' u[5]);              }
Magic Number,DotSquish,Sym3x3,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Maths.cs,GetMultiplicity1Evector,The following statement contains a magic number: switch (mi) {                  case 0:                      return new Vector3(u[0]' u[1]' u[2]);                  case 1:                  case 3:                      return new Vector3(u[1]' u[3]' u[4]);                  default:                      return new Vector3(u[2]' u[4]' u[5]);              }
Magic Number,DotSquish,Sym3x3,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Maths.cs,GetMultiplicity1Evector,The following statement contains a magic number: switch (mi) {                  case 0:                      return new Vector3(u[0]' u[1]' u[2]);                  case 1:                  case 3:                      return new Vector3(u[1]' u[3]' u[4]);                  default:                      return new Vector3(u[2]' u[4]' u[5]);              }
Magic Number,DotSquish,Sym3x3,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Maths.cs,GetMultiplicity2Evector,The following statement contains a magic number: m[2] = matrix[2];
Magic Number,DotSquish,Sym3x3,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Maths.cs,GetMultiplicity2Evector,The following statement contains a magic number: m[2] = matrix[2];
Magic Number,DotSquish,Sym3x3,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Maths.cs,GetMultiplicity2Evector,The following statement contains a magic number: m[3] = matrix[3] - evalue;
Magic Number,DotSquish,Sym3x3,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Maths.cs,GetMultiplicity2Evector,The following statement contains a magic number: m[3] = matrix[3] - evalue;
Magic Number,DotSquish,Sym3x3,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Maths.cs,GetMultiplicity2Evector,The following statement contains a magic number: m[4] = matrix[4];
Magic Number,DotSquish,Sym3x3,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Maths.cs,GetMultiplicity2Evector,The following statement contains a magic number: m[4] = matrix[4];
Magic Number,DotSquish,Sym3x3,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Maths.cs,GetMultiplicity2Evector,The following statement contains a magic number: m[5] = matrix[5] - evalue;
Magic Number,DotSquish,Sym3x3,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Maths.cs,GetMultiplicity2Evector,The following statement contains a magic number: m[5] = matrix[5] - evalue;
Magic Number,DotSquish,Sym3x3,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Maths.cs,GetMultiplicity2Evector,The following statement contains a magic number: for (int i = 1; i < 6; ++i) {                  var c = Math.Abs(m[i]);                  if (c > mc) {                      mc = c;                      mi = i;                  }              }
Magic Number,DotSquish,Sym3x3,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Maths.cs,GetMultiplicity2Evector,The following statement contains a magic number: switch (mi) {                  case 0:                  case 1:                      return new Vector3(-m[1]' m[0]' 0.0f);                    case 2:                      return new Vector3(m[2]' 0.0f' -m[0]);                    case 3:                  case 4:                      return new Vector3(0.0f' -m[4]' m[3]);                    default:                      return new Vector3(0.0f' -m[5]' m[4]);              }
Magic Number,DotSquish,Sym3x3,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Maths.cs,GetMultiplicity2Evector,The following statement contains a magic number: switch (mi) {                  case 0:                  case 1:                      return new Vector3(-m[1]' m[0]' 0.0f);                    case 2:                      return new Vector3(m[2]' 0.0f' -m[0]);                    case 3:                  case 4:                      return new Vector3(0.0f' -m[4]' m[3]);                    default:                      return new Vector3(0.0f' -m[5]' m[4]);              }
Magic Number,DotSquish,Sym3x3,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Maths.cs,GetMultiplicity2Evector,The following statement contains a magic number: switch (mi) {                  case 0:                  case 1:                      return new Vector3(-m[1]' m[0]' 0.0f);                    case 2:                      return new Vector3(m[2]' 0.0f' -m[0]);                    case 3:                  case 4:                      return new Vector3(0.0f' -m[4]' m[3]);                    default:                      return new Vector3(0.0f' -m[5]' m[4]);              }
Magic Number,DotSquish,Sym3x3,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Maths.cs,GetMultiplicity2Evector,The following statement contains a magic number: switch (mi) {                  case 0:                  case 1:                      return new Vector3(-m[1]' m[0]' 0.0f);                    case 2:                      return new Vector3(m[2]' 0.0f' -m[0]);                    case 3:                  case 4:                      return new Vector3(0.0f' -m[4]' m[3]);                    default:                      return new Vector3(0.0f' -m[5]' m[4]);              }
Magic Number,DotSquish,Sym3x3,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Maths.cs,GetMultiplicity2Evector,The following statement contains a magic number: switch (mi) {                  case 0:                  case 1:                      return new Vector3(-m[1]' m[0]' 0.0f);                    case 2:                      return new Vector3(m[2]' 0.0f' -m[0]);                    case 3:                  case 4:                      return new Vector3(0.0f' -m[4]' m[3]);                    default:                      return new Vector3(0.0f' -m[5]' m[4]);              }
Magic Number,DotSquish,Sym3x3,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Maths.cs,GetMultiplicity2Evector,The following statement contains a magic number: switch (mi) {                  case 0:                  case 1:                      return new Vector3(-m[1]' m[0]' 0.0f);                    case 2:                      return new Vector3(m[2]' 0.0f' -m[0]);                    case 3:                  case 4:                      return new Vector3(0.0f' -m[4]' m[3]);                    default:                      return new Vector3(0.0f' -m[5]' m[4]);              }
Magic Number,DotSquish,Sym3x3,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Maths.cs,GetMultiplicity2Evector,The following statement contains a magic number: switch (mi) {                  case 0:                  case 1:                      return new Vector3(-m[1]' m[0]' 0.0f);                    case 2:                      return new Vector3(m[2]' 0.0f' -m[0]);                    case 3:                  case 4:                      return new Vector3(0.0f' -m[4]' m[3]);                    default:                      return new Vector3(0.0f' -m[5]' m[4]);              }
Magic Number,DotSquish,Sym3x3,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Maths.cs,GetMultiplicity2Evector,The following statement contains a magic number: switch (mi) {                  case 0:                  case 1:                      return new Vector3(-m[1]' m[0]' 0.0f);                    case 2:                      return new Vector3(m[2]' 0.0f' -m[0]);                    case 3:                  case 4:                      return new Vector3(0.0f' -m[4]' m[3]);                    default:                      return new Vector3(0.0f' -m[5]' m[4]);              }
Magic Number,DotSquish,Sym3x3,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Maths.cs,ComputePrincipledComponent,The following statement contains a magic number: var c0 =                  (matrix[0] * matrix[3] * matrix[5])                  + (matrix[1] * matrix[2] * matrix[4] * 2f)                  - (matrix[0] * matrix[4] * matrix[4])                  - (matrix[3] * matrix[2] * matrix[2])                  - (matrix[5] * matrix[1] * matrix[1]);
Magic Number,DotSquish,Sym3x3,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Maths.cs,ComputePrincipledComponent,The following statement contains a magic number: var c0 =                  (matrix[0] * matrix[3] * matrix[5])                  + (matrix[1] * matrix[2] * matrix[4] * 2f)                  - (matrix[0] * matrix[4] * matrix[4])                  - (matrix[3] * matrix[2] * matrix[2])                  - (matrix[5] * matrix[1] * matrix[1]);
Magic Number,DotSquish,Sym3x3,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Maths.cs,ComputePrincipledComponent,The following statement contains a magic number: var c0 =                  (matrix[0] * matrix[3] * matrix[5])                  + (matrix[1] * matrix[2] * matrix[4] * 2f)                  - (matrix[0] * matrix[4] * matrix[4])                  - (matrix[3] * matrix[2] * matrix[2])                  - (matrix[5] * matrix[1] * matrix[1]);
Magic Number,DotSquish,Sym3x3,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Maths.cs,ComputePrincipledComponent,The following statement contains a magic number: var c0 =                  (matrix[0] * matrix[3] * matrix[5])                  + (matrix[1] * matrix[2] * matrix[4] * 2f)                  - (matrix[0] * matrix[4] * matrix[4])                  - (matrix[3] * matrix[2] * matrix[2])                  - (matrix[5] * matrix[1] * matrix[1]);
Magic Number,DotSquish,Sym3x3,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Maths.cs,ComputePrincipledComponent,The following statement contains a magic number: var c0 =                  (matrix[0] * matrix[3] * matrix[5])                  + (matrix[1] * matrix[2] * matrix[4] * 2f)                  - (matrix[0] * matrix[4] * matrix[4])                  - (matrix[3] * matrix[2] * matrix[2])                  - (matrix[5] * matrix[1] * matrix[1]);
Magic Number,DotSquish,Sym3x3,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Maths.cs,ComputePrincipledComponent,The following statement contains a magic number: var c0 =                  (matrix[0] * matrix[3] * matrix[5])                  + (matrix[1] * matrix[2] * matrix[4] * 2f)                  - (matrix[0] * matrix[4] * matrix[4])                  - (matrix[3] * matrix[2] * matrix[2])                  - (matrix[5] * matrix[1] * matrix[1]);
Magic Number,DotSquish,Sym3x3,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Maths.cs,ComputePrincipledComponent,The following statement contains a magic number: var c0 =                  (matrix[0] * matrix[3] * matrix[5])                  + (matrix[1] * matrix[2] * matrix[4] * 2f)                  - (matrix[0] * matrix[4] * matrix[4])                  - (matrix[3] * matrix[2] * matrix[2])                  - (matrix[5] * matrix[1] * matrix[1]);
Magic Number,DotSquish,Sym3x3,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Maths.cs,ComputePrincipledComponent,The following statement contains a magic number: var c0 =                  (matrix[0] * matrix[3] * matrix[5])                  + (matrix[1] * matrix[2] * matrix[4] * 2f)                  - (matrix[0] * matrix[4] * matrix[4])                  - (matrix[3] * matrix[2] * matrix[2])                  - (matrix[5] * matrix[1] * matrix[1]);
Magic Number,DotSquish,Sym3x3,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Maths.cs,ComputePrincipledComponent,The following statement contains a magic number: var c0 =                  (matrix[0] * matrix[3] * matrix[5])                  + (matrix[1] * matrix[2] * matrix[4] * 2f)                  - (matrix[0] * matrix[4] * matrix[4])                  - (matrix[3] * matrix[2] * matrix[2])                  - (matrix[5] * matrix[1] * matrix[1]);
Magic Number,DotSquish,Sym3x3,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Maths.cs,ComputePrincipledComponent,The following statement contains a magic number: var c0 =                  (matrix[0] * matrix[3] * matrix[5])                  + (matrix[1] * matrix[2] * matrix[4] * 2f)                  - (matrix[0] * matrix[4] * matrix[4])                  - (matrix[3] * matrix[2] * matrix[2])                  - (matrix[5] * matrix[1] * matrix[1]);
Magic Number,DotSquish,Sym3x3,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Maths.cs,ComputePrincipledComponent,The following statement contains a magic number: var c1 =                  (matrix[0] * matrix[3])                  + (matrix[0] * matrix[5])                  + (matrix[3] * matrix[5])                  - (matrix[1] * matrix[1])                  - (matrix[2] * matrix[2])                  - (matrix[4] * matrix[4]);
Magic Number,DotSquish,Sym3x3,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Maths.cs,ComputePrincipledComponent,The following statement contains a magic number: var c1 =                  (matrix[0] * matrix[3])                  + (matrix[0] * matrix[5])                  + (matrix[3] * matrix[5])                  - (matrix[1] * matrix[1])                  - (matrix[2] * matrix[2])                  - (matrix[4] * matrix[4]);
Magic Number,DotSquish,Sym3x3,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Maths.cs,ComputePrincipledComponent,The following statement contains a magic number: var c1 =                  (matrix[0] * matrix[3])                  + (matrix[0] * matrix[5])                  + (matrix[3] * matrix[5])                  - (matrix[1] * matrix[1])                  - (matrix[2] * matrix[2])                  - (matrix[4] * matrix[4]);
Magic Number,DotSquish,Sym3x3,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Maths.cs,ComputePrincipledComponent,The following statement contains a magic number: var c1 =                  (matrix[0] * matrix[3])                  + (matrix[0] * matrix[5])                  + (matrix[3] * matrix[5])                  - (matrix[1] * matrix[1])                  - (matrix[2] * matrix[2])                  - (matrix[4] * matrix[4]);
Magic Number,DotSquish,Sym3x3,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Maths.cs,ComputePrincipledComponent,The following statement contains a magic number: var c1 =                  (matrix[0] * matrix[3])                  + (matrix[0] * matrix[5])                  + (matrix[3] * matrix[5])                  - (matrix[1] * matrix[1])                  - (matrix[2] * matrix[2])                  - (matrix[4] * matrix[4]);
Magic Number,DotSquish,Sym3x3,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Maths.cs,ComputePrincipledComponent,The following statement contains a magic number: var c1 =                  (matrix[0] * matrix[3])                  + (matrix[0] * matrix[5])                  + (matrix[3] * matrix[5])                  - (matrix[1] * matrix[1])                  - (matrix[2] * matrix[2])                  - (matrix[4] * matrix[4]);
Magic Number,DotSquish,Sym3x3,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Maths.cs,ComputePrincipledComponent,The following statement contains a magic number: var c1 =                  (matrix[0] * matrix[3])                  + (matrix[0] * matrix[5])                  + (matrix[3] * matrix[5])                  - (matrix[1] * matrix[1])                  - (matrix[2] * matrix[2])                  - (matrix[4] * matrix[4]);
Magic Number,DotSquish,Sym3x3,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Maths.cs,ComputePrincipledComponent,The following statement contains a magic number: var c1 =                  (matrix[0] * matrix[3])                  + (matrix[0] * matrix[5])                  + (matrix[3] * matrix[5])                  - (matrix[1] * matrix[1])                  - (matrix[2] * matrix[2])                  - (matrix[4] * matrix[4]);
Magic Number,DotSquish,Sym3x3,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Maths.cs,ComputePrincipledComponent,The following statement contains a magic number: var c2 = matrix[0] + matrix[3] + matrix[5];
Magic Number,DotSquish,Sym3x3,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Maths.cs,ComputePrincipledComponent,The following statement contains a magic number: var c2 = matrix[0] + matrix[3] + matrix[5];
Magic Number,DotSquish,Squish,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Squish.cs,GetStorageRequirements,The following statement contains a magic number: var blockCount = ((width + 3) / 4) * ((height + 3) / 4);
Magic Number,DotSquish,Squish,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Squish.cs,GetStorageRequirements,The following statement contains a magic number: var blockCount = ((width + 3) / 4) * ((height + 3) / 4);
Magic Number,DotSquish,Squish,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Squish.cs,GetStorageRequirements,The following statement contains a magic number: var blockCount = ((width + 3) / 4) * ((height + 3) / 4);
Magic Number,DotSquish,Squish,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Squish.cs,GetStorageRequirements,The following statement contains a magic number: var blockCount = ((width + 3) / 4) * ((height + 3) / 4);
Magic Number,DotSquish,Squish,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Squish.cs,GetStorageRequirements,The following statement contains a magic number: var blockSize = flags.HasFlag(SquishOptions.DXT1) ? 8 : 16;
Magic Number,DotSquish,Squish,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Squish.cs,GetStorageRequirements,The following statement contains a magic number: var blockSize = flags.HasFlag(SquishOptions.DXT1) ? 8 : 16;
Magic Number,DotSquish,Squish,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Squish.cs,DecompressBlock,The following statement contains a magic number: if ((flags & (SquishOptions.DXT3 | SquishOptions.DXT5)) != 0)                  colOff += 8;
Magic Number,DotSquish,Squish,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Squish.cs,DecompressImage,The following statement contains a magic number: var argb = new byte[4 * width * height];
Magic Number,DotSquish,Squish,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Squish.cs,DecompressImage,The following statement contains a magic number: var bytesPerBlock = flags.HasFlag(SquishOptions.DXT1) ? 8 : 16;
Magic Number,DotSquish,Squish,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Squish.cs,DecompressImage,The following statement contains a magic number: var bytesPerBlock = flags.HasFlag(SquishOptions.DXT1) ? 8 : 16;
Magic Number,DotSquish,Squish,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Squish.cs,DecompressImage,The following statement contains a magic number: for (int y = 0; y < height; y += 4) {                  for (int x = 0; x < width; x += 4) {                      // Decompress the block.                      var targetRgba = DecompressBlock(blocks' blockOffset' flags);                        // Write the decompressed pixels to the correct image locations.                      var sourcePixelOffset = 0;                      for (int py = 0; py < 4; ++py) {                          for (int px = 0; px < 4; ++px) {                              // Get the target location.                              var sx = x + px;                              var sy = y + py;                              if (sx < width && sy < height) {                                  var targetPixelOffset = 4 * ((width * sy) + sx);                                  // Copy the rgba value                                  argb[targetPixelOffset + 0] = targetRgba[sourcePixelOffset + 2];                                  argb[targetPixelOffset + 1] = targetRgba[sourcePixelOffset + 1];                                  argb[targetPixelOffset + 2] = targetRgba[sourcePixelOffset + 0];                                  argb[targetPixelOffset + 3] = targetRgba[sourcePixelOffset + 3];                              }                              sourcePixelOffset += 4;                          }                      }                        // advance                      blockOffset += bytesPerBlock;                  }              }
Magic Number,DotSquish,Squish,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Squish.cs,DecompressImage,The following statement contains a magic number: for (int y = 0; y < height; y += 4) {                  for (int x = 0; x < width; x += 4) {                      // Decompress the block.                      var targetRgba = DecompressBlock(blocks' blockOffset' flags);                        // Write the decompressed pixels to the correct image locations.                      var sourcePixelOffset = 0;                      for (int py = 0; py < 4; ++py) {                          for (int px = 0; px < 4; ++px) {                              // Get the target location.                              var sx = x + px;                              var sy = y + py;                              if (sx < width && sy < height) {                                  var targetPixelOffset = 4 * ((width * sy) + sx);                                  // Copy the rgba value                                  argb[targetPixelOffset + 0] = targetRgba[sourcePixelOffset + 2];                                  argb[targetPixelOffset + 1] = targetRgba[sourcePixelOffset + 1];                                  argb[targetPixelOffset + 2] = targetRgba[sourcePixelOffset + 0];                                  argb[targetPixelOffset + 3] = targetRgba[sourcePixelOffset + 3];                              }                              sourcePixelOffset += 4;                          }                      }                        // advance                      blockOffset += bytesPerBlock;                  }              }
Magic Number,DotSquish,Squish,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Squish.cs,DecompressImage,The following statement contains a magic number: for (int y = 0; y < height; y += 4) {                  for (int x = 0; x < width; x += 4) {                      // Decompress the block.                      var targetRgba = DecompressBlock(blocks' blockOffset' flags);                        // Write the decompressed pixels to the correct image locations.                      var sourcePixelOffset = 0;                      for (int py = 0; py < 4; ++py) {                          for (int px = 0; px < 4; ++px) {                              // Get the target location.                              var sx = x + px;                              var sy = y + py;                              if (sx < width && sy < height) {                                  var targetPixelOffset = 4 * ((width * sy) + sx);                                  // Copy the rgba value                                  argb[targetPixelOffset + 0] = targetRgba[sourcePixelOffset + 2];                                  argb[targetPixelOffset + 1] = targetRgba[sourcePixelOffset + 1];                                  argb[targetPixelOffset + 2] = targetRgba[sourcePixelOffset + 0];                                  argb[targetPixelOffset + 3] = targetRgba[sourcePixelOffset + 3];                              }                              sourcePixelOffset += 4;                          }                      }                        // advance                      blockOffset += bytesPerBlock;                  }              }
Magic Number,DotSquish,Squish,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Squish.cs,DecompressImage,The following statement contains a magic number: for (int y = 0; y < height; y += 4) {                  for (int x = 0; x < width; x += 4) {                      // Decompress the block.                      var targetRgba = DecompressBlock(blocks' blockOffset' flags);                        // Write the decompressed pixels to the correct image locations.                      var sourcePixelOffset = 0;                      for (int py = 0; py < 4; ++py) {                          for (int px = 0; px < 4; ++px) {                              // Get the target location.                              var sx = x + px;                              var sy = y + py;                              if (sx < width && sy < height) {                                  var targetPixelOffset = 4 * ((width * sy) + sx);                                  // Copy the rgba value                                  argb[targetPixelOffset + 0] = targetRgba[sourcePixelOffset + 2];                                  argb[targetPixelOffset + 1] = targetRgba[sourcePixelOffset + 1];                                  argb[targetPixelOffset + 2] = targetRgba[sourcePixelOffset + 0];                                  argb[targetPixelOffset + 3] = targetRgba[sourcePixelOffset + 3];                              }                              sourcePixelOffset += 4;                          }                      }                        // advance                      blockOffset += bytesPerBlock;                  }              }
Magic Number,DotSquish,Squish,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Squish.cs,DecompressImage,The following statement contains a magic number: for (int y = 0; y < height; y += 4) {                  for (int x = 0; x < width; x += 4) {                      // Decompress the block.                      var targetRgba = DecompressBlock(blocks' blockOffset' flags);                        // Write the decompressed pixels to the correct image locations.                      var sourcePixelOffset = 0;                      for (int py = 0; py < 4; ++py) {                          for (int px = 0; px < 4; ++px) {                              // Get the target location.                              var sx = x + px;                              var sy = y + py;                              if (sx < width && sy < height) {                                  var targetPixelOffset = 4 * ((width * sy) + sx);                                  // Copy the rgba value                                  argb[targetPixelOffset + 0] = targetRgba[sourcePixelOffset + 2];                                  argb[targetPixelOffset + 1] = targetRgba[sourcePixelOffset + 1];                                  argb[targetPixelOffset + 2] = targetRgba[sourcePixelOffset + 0];                                  argb[targetPixelOffset + 3] = targetRgba[sourcePixelOffset + 3];                              }                              sourcePixelOffset += 4;                          }                      }                        // advance                      blockOffset += bytesPerBlock;                  }              }
Magic Number,DotSquish,Squish,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Squish.cs,DecompressImage,The following statement contains a magic number: for (int y = 0; y < height; y += 4) {                  for (int x = 0; x < width; x += 4) {                      // Decompress the block.                      var targetRgba = DecompressBlock(blocks' blockOffset' flags);                        // Write the decompressed pixels to the correct image locations.                      var sourcePixelOffset = 0;                      for (int py = 0; py < 4; ++py) {                          for (int px = 0; px < 4; ++px) {                              // Get the target location.                              var sx = x + px;                              var sy = y + py;                              if (sx < width && sy < height) {                                  var targetPixelOffset = 4 * ((width * sy) + sx);                                  // Copy the rgba value                                  argb[targetPixelOffset + 0] = targetRgba[sourcePixelOffset + 2];                                  argb[targetPixelOffset + 1] = targetRgba[sourcePixelOffset + 1];                                  argb[targetPixelOffset + 2] = targetRgba[sourcePixelOffset + 0];                                  argb[targetPixelOffset + 3] = targetRgba[sourcePixelOffset + 3];                              }                              sourcePixelOffset += 4;                          }                      }                        // advance                      blockOffset += bytesPerBlock;                  }              }
Magic Number,DotSquish,Squish,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Squish.cs,DecompressImage,The following statement contains a magic number: for (int y = 0; y < height; y += 4) {                  for (int x = 0; x < width; x += 4) {                      // Decompress the block.                      var targetRgba = DecompressBlock(blocks' blockOffset' flags);                        // Write the decompressed pixels to the correct image locations.                      var sourcePixelOffset = 0;                      for (int py = 0; py < 4; ++py) {                          for (int px = 0; px < 4; ++px) {                              // Get the target location.                              var sx = x + px;                              var sy = y + py;                              if (sx < width && sy < height) {                                  var targetPixelOffset = 4 * ((width * sy) + sx);                                  // Copy the rgba value                                  argb[targetPixelOffset + 0] = targetRgba[sourcePixelOffset + 2];                                  argb[targetPixelOffset + 1] = targetRgba[sourcePixelOffset + 1];                                  argb[targetPixelOffset + 2] = targetRgba[sourcePixelOffset + 0];                                  argb[targetPixelOffset + 3] = targetRgba[sourcePixelOffset + 3];                              }                              sourcePixelOffset += 4;                          }                      }                        // advance                      blockOffset += bytesPerBlock;                  }              }
Magic Number,DotSquish,Squish,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Squish.cs,DecompressImage,The following statement contains a magic number: for (int y = 0; y < height; y += 4) {                  for (int x = 0; x < width; x += 4) {                      // Decompress the block.                      var targetRgba = DecompressBlock(blocks' blockOffset' flags);                        // Write the decompressed pixels to the correct image locations.                      var sourcePixelOffset = 0;                      for (int py = 0; py < 4; ++py) {                          for (int px = 0; px < 4; ++px) {                              // Get the target location.                              var sx = x + px;                              var sy = y + py;                              if (sx < width && sy < height) {                                  var targetPixelOffset = 4 * ((width * sy) + sx);                                  // Copy the rgba value                                  argb[targetPixelOffset + 0] = targetRgba[sourcePixelOffset + 2];                                  argb[targetPixelOffset + 1] = targetRgba[sourcePixelOffset + 1];                                  argb[targetPixelOffset + 2] = targetRgba[sourcePixelOffset + 0];                                  argb[targetPixelOffset + 3] = targetRgba[sourcePixelOffset + 3];                              }                              sourcePixelOffset += 4;                          }                      }                        // advance                      blockOffset += bytesPerBlock;                  }              }
Magic Number,DotSquish,Squish,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Squish.cs,DecompressImage,The following statement contains a magic number: for (int y = 0; y < height; y += 4) {                  for (int x = 0; x < width; x += 4) {                      // Decompress the block.                      var targetRgba = DecompressBlock(blocks' blockOffset' flags);                        // Write the decompressed pixels to the correct image locations.                      var sourcePixelOffset = 0;                      for (int py = 0; py < 4; ++py) {                          for (int px = 0; px < 4; ++px) {                              // Get the target location.                              var sx = x + px;                              var sy = y + py;                              if (sx < width && sy < height) {                                  var targetPixelOffset = 4 * ((width * sy) + sx);                                  // Copy the rgba value                                  argb[targetPixelOffset + 0] = targetRgba[sourcePixelOffset + 2];                                  argb[targetPixelOffset + 1] = targetRgba[sourcePixelOffset + 1];                                  argb[targetPixelOffset + 2] = targetRgba[sourcePixelOffset + 0];                                  argb[targetPixelOffset + 3] = targetRgba[sourcePixelOffset + 3];                              }                              sourcePixelOffset += 4;                          }                      }                        // advance                      blockOffset += bytesPerBlock;                  }              }
Magic Number,DotSquish,Squish,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Squish.cs,DecompressImage,The following statement contains a magic number: for (int y = 0; y < height; y += 4) {                  for (int x = 0; x < width; x += 4) {                      // Decompress the block.                      var targetRgba = DecompressBlock(blocks' blockOffset' flags);                        // Write the decompressed pixels to the correct image locations.                      var sourcePixelOffset = 0;                      for (int py = 0; py < 4; ++py) {                          for (int px = 0; px < 4; ++px) {                              // Get the target location.                              var sx = x + px;                              var sy = y + py;                              if (sx < width && sy < height) {                                  var targetPixelOffset = 4 * ((width * sy) + sx);                                  // Copy the rgba value                                  argb[targetPixelOffset + 0] = targetRgba[sourcePixelOffset + 2];                                  argb[targetPixelOffset + 1] = targetRgba[sourcePixelOffset + 1];                                  argb[targetPixelOffset + 2] = targetRgba[sourcePixelOffset + 0];                                  argb[targetPixelOffset + 3] = targetRgba[sourcePixelOffset + 3];                              }                              sourcePixelOffset += 4;                          }                      }                        // advance                      blockOffset += bytesPerBlock;                  }              }
Magic Number,DotSquish,Squish,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Squish.cs,DecompressToBitmap,The following statement contains a magic number: var fullBuffer = new byte[4 * width * height];
Magic Number,DotSquish,Squish,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Squish.cs,DecompressToBitmap,The following statement contains a magic number: var bytesPerBlock = flags.HasFlag(SquishOptions.DXT1) ? 8 : 16;
Magic Number,DotSquish,Squish,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Squish.cs,DecompressToBitmap,The following statement contains a magic number: var bytesPerBlock = flags.HasFlag(SquishOptions.DXT1) ? 8 : 16;
Magic Number,DotSquish,Squish,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Squish.cs,DecompressToBitmap,The following statement contains a magic number: for (int y = 0; y < height; y += 4) {                  for (int x = 0; x < width; x += 4) {                      // Decompress the block.                      var targetRgba = DecompressBlock(blocks' blockOffset' flags);                          // Write the decompressed pixels to the correct image locations.                      var sourcePixelOffset = 0;                      for (int py = 0; py < 4; ++py) {                          for (int px = 0; px < 4; ++px) {                              // Get the target location.                              var sx = x + px;                              var sy = y + py;                              if (sx < width && sy < height) {                                  var i = 4 * (sx + (sy * width));                                  fullBuffer[bufferOffset + i + 0] = targetRgba[sourcePixelOffset + 2];                                  fullBuffer[bufferOffset + i + 1] = targetRgba[sourcePixelOffset + 1];                                  fullBuffer[bufferOffset + i + 2] = targetRgba[sourcePixelOffset + 0];                                  fullBuffer[bufferOffset + i + 3] = targetRgba[sourcePixelOffset + 3];                              }                                sourcePixelOffset += 4; // Skip this pixel as it is outside the image.                          }                      }                        // advance                      blockOffset += bytesPerBlock;                  }              }
Magic Number,DotSquish,Squish,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Squish.cs,DecompressToBitmap,The following statement contains a magic number: for (int y = 0; y < height; y += 4) {                  for (int x = 0; x < width; x += 4) {                      // Decompress the block.                      var targetRgba = DecompressBlock(blocks' blockOffset' flags);                          // Write the decompressed pixels to the correct image locations.                      var sourcePixelOffset = 0;                      for (int py = 0; py < 4; ++py) {                          for (int px = 0; px < 4; ++px) {                              // Get the target location.                              var sx = x + px;                              var sy = y + py;                              if (sx < width && sy < height) {                                  var i = 4 * (sx + (sy * width));                                  fullBuffer[bufferOffset + i + 0] = targetRgba[sourcePixelOffset + 2];                                  fullBuffer[bufferOffset + i + 1] = targetRgba[sourcePixelOffset + 1];                                  fullBuffer[bufferOffset + i + 2] = targetRgba[sourcePixelOffset + 0];                                  fullBuffer[bufferOffset + i + 3] = targetRgba[sourcePixelOffset + 3];                              }                                sourcePixelOffset += 4; // Skip this pixel as it is outside the image.                          }                      }                        // advance                      blockOffset += bytesPerBlock;                  }              }
Magic Number,DotSquish,Squish,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Squish.cs,DecompressToBitmap,The following statement contains a magic number: for (int y = 0; y < height; y += 4) {                  for (int x = 0; x < width; x += 4) {                      // Decompress the block.                      var targetRgba = DecompressBlock(blocks' blockOffset' flags);                          // Write the decompressed pixels to the correct image locations.                      var sourcePixelOffset = 0;                      for (int py = 0; py < 4; ++py) {                          for (int px = 0; px < 4; ++px) {                              // Get the target location.                              var sx = x + px;                              var sy = y + py;                              if (sx < width && sy < height) {                                  var i = 4 * (sx + (sy * width));                                  fullBuffer[bufferOffset + i + 0] = targetRgba[sourcePixelOffset + 2];                                  fullBuffer[bufferOffset + i + 1] = targetRgba[sourcePixelOffset + 1];                                  fullBuffer[bufferOffset + i + 2] = targetRgba[sourcePixelOffset + 0];                                  fullBuffer[bufferOffset + i + 3] = targetRgba[sourcePixelOffset + 3];                              }                                sourcePixelOffset += 4; // Skip this pixel as it is outside the image.                          }                      }                        // advance                      blockOffset += bytesPerBlock;                  }              }
Magic Number,DotSquish,Squish,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Squish.cs,DecompressToBitmap,The following statement contains a magic number: for (int y = 0; y < height; y += 4) {                  for (int x = 0; x < width; x += 4) {                      // Decompress the block.                      var targetRgba = DecompressBlock(blocks' blockOffset' flags);                          // Write the decompressed pixels to the correct image locations.                      var sourcePixelOffset = 0;                      for (int py = 0; py < 4; ++py) {                          for (int px = 0; px < 4; ++px) {                              // Get the target location.                              var sx = x + px;                              var sy = y + py;                              if (sx < width && sy < height) {                                  var i = 4 * (sx + (sy * width));                                  fullBuffer[bufferOffset + i + 0] = targetRgba[sourcePixelOffset + 2];                                  fullBuffer[bufferOffset + i + 1] = targetRgba[sourcePixelOffset + 1];                                  fullBuffer[bufferOffset + i + 2] = targetRgba[sourcePixelOffset + 0];                                  fullBuffer[bufferOffset + i + 3] = targetRgba[sourcePixelOffset + 3];                              }                                sourcePixelOffset += 4; // Skip this pixel as it is outside the image.                          }                      }                        // advance                      blockOffset += bytesPerBlock;                  }              }
Magic Number,DotSquish,Squish,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Squish.cs,DecompressToBitmap,The following statement contains a magic number: for (int y = 0; y < height; y += 4) {                  for (int x = 0; x < width; x += 4) {                      // Decompress the block.                      var targetRgba = DecompressBlock(blocks' blockOffset' flags);                          // Write the decompressed pixels to the correct image locations.                      var sourcePixelOffset = 0;                      for (int py = 0; py < 4; ++py) {                          for (int px = 0; px < 4; ++px) {                              // Get the target location.                              var sx = x + px;                              var sy = y + py;                              if (sx < width && sy < height) {                                  var i = 4 * (sx + (sy * width));                                  fullBuffer[bufferOffset + i + 0] = targetRgba[sourcePixelOffset + 2];                                  fullBuffer[bufferOffset + i + 1] = targetRgba[sourcePixelOffset + 1];                                  fullBuffer[bufferOffset + i + 2] = targetRgba[sourcePixelOffset + 0];                                  fullBuffer[bufferOffset + i + 3] = targetRgba[sourcePixelOffset + 3];                              }                                sourcePixelOffset += 4; // Skip this pixel as it is outside the image.                          }                      }                        // advance                      blockOffset += bytesPerBlock;                  }              }
Magic Number,DotSquish,Squish,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Squish.cs,DecompressToBitmap,The following statement contains a magic number: for (int y = 0; y < height; y += 4) {                  for (int x = 0; x < width; x += 4) {                      // Decompress the block.                      var targetRgba = DecompressBlock(blocks' blockOffset' flags);                          // Write the decompressed pixels to the correct image locations.                      var sourcePixelOffset = 0;                      for (int py = 0; py < 4; ++py) {                          for (int px = 0; px < 4; ++px) {                              // Get the target location.                              var sx = x + px;                              var sy = y + py;                              if (sx < width && sy < height) {                                  var i = 4 * (sx + (sy * width));                                  fullBuffer[bufferOffset + i + 0] = targetRgba[sourcePixelOffset + 2];                                  fullBuffer[bufferOffset + i + 1] = targetRgba[sourcePixelOffset + 1];                                  fullBuffer[bufferOffset + i + 2] = targetRgba[sourcePixelOffset + 0];                                  fullBuffer[bufferOffset + i + 3] = targetRgba[sourcePixelOffset + 3];                              }                                sourcePixelOffset += 4; // Skip this pixel as it is outside the image.                          }                      }                        // advance                      blockOffset += bytesPerBlock;                  }              }
Magic Number,DotSquish,Squish,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Squish.cs,DecompressToBitmap,The following statement contains a magic number: for (int y = 0; y < height; y += 4) {                  for (int x = 0; x < width; x += 4) {                      // Decompress the block.                      var targetRgba = DecompressBlock(blocks' blockOffset' flags);                          // Write the decompressed pixels to the correct image locations.                      var sourcePixelOffset = 0;                      for (int py = 0; py < 4; ++py) {                          for (int px = 0; px < 4; ++px) {                              // Get the target location.                              var sx = x + px;                              var sy = y + py;                              if (sx < width && sy < height) {                                  var i = 4 * (sx + (sy * width));                                  fullBuffer[bufferOffset + i + 0] = targetRgba[sourcePixelOffset + 2];                                  fullBuffer[bufferOffset + i + 1] = targetRgba[sourcePixelOffset + 1];                                  fullBuffer[bufferOffset + i + 2] = targetRgba[sourcePixelOffset + 0];                                  fullBuffer[bufferOffset + i + 3] = targetRgba[sourcePixelOffset + 3];                              }                                sourcePixelOffset += 4; // Skip this pixel as it is outside the image.                          }                      }                        // advance                      blockOffset += bytesPerBlock;                  }              }
Magic Number,DotSquish,Squish,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Squish.cs,DecompressToBitmap,The following statement contains a magic number: for (int y = 0; y < height; y += 4) {                  for (int x = 0; x < width; x += 4) {                      // Decompress the block.                      var targetRgba = DecompressBlock(blocks' blockOffset' flags);                          // Write the decompressed pixels to the correct image locations.                      var sourcePixelOffset = 0;                      for (int py = 0; py < 4; ++py) {                          for (int px = 0; px < 4; ++px) {                              // Get the target location.                              var sx = x + px;                              var sy = y + py;                              if (sx < width && sy < height) {                                  var i = 4 * (sx + (sy * width));                                  fullBuffer[bufferOffset + i + 0] = targetRgba[sourcePixelOffset + 2];                                  fullBuffer[bufferOffset + i + 1] = targetRgba[sourcePixelOffset + 1];                                  fullBuffer[bufferOffset + i + 2] = targetRgba[sourcePixelOffset + 0];                                  fullBuffer[bufferOffset + i + 3] = targetRgba[sourcePixelOffset + 3];                              }                                sourcePixelOffset += 4; // Skip this pixel as it is outside the image.                          }                      }                        // advance                      blockOffset += bytesPerBlock;                  }              }
Magic Number,DotSquish,Squish,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Squish.cs,DecompressToBitmap,The following statement contains a magic number: for (int y = 0; y < height; y += 4) {                  for (int x = 0; x < width; x += 4) {                      // Decompress the block.                      var targetRgba = DecompressBlock(blocks' blockOffset' flags);                          // Write the decompressed pixels to the correct image locations.                      var sourcePixelOffset = 0;                      for (int py = 0; py < 4; ++py) {                          for (int px = 0; px < 4; ++px) {                              // Get the target location.                              var sx = x + px;                              var sy = y + py;                              if (sx < width && sy < height) {                                  var i = 4 * (sx + (sy * width));                                  fullBuffer[bufferOffset + i + 0] = targetRgba[sourcePixelOffset + 2];                                  fullBuffer[bufferOffset + i + 1] = targetRgba[sourcePixelOffset + 1];                                  fullBuffer[bufferOffset + i + 2] = targetRgba[sourcePixelOffset + 0];                                  fullBuffer[bufferOffset + i + 3] = targetRgba[sourcePixelOffset + 3];                              }                                sourcePixelOffset += 4; // Skip this pixel as it is outside the image.                          }                      }                        // advance                      blockOffset += bytesPerBlock;                  }              }
Magic Number,DotSquish,Squish,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Squish.cs,DecompressToBitmap,The following statement contains a magic number: for (int y = 0; y < height; y += 4) {                  for (int x = 0; x < width; x += 4) {                      // Decompress the block.                      var targetRgba = DecompressBlock(blocks' blockOffset' flags);                          // Write the decompressed pixels to the correct image locations.                      var sourcePixelOffset = 0;                      for (int py = 0; py < 4; ++py) {                          for (int px = 0; px < 4; ++px) {                              // Get the target location.                              var sx = x + px;                              var sy = y + py;                              if (sx < width && sy < height) {                                  var i = 4 * (sx + (sy * width));                                  fullBuffer[bufferOffset + i + 0] = targetRgba[sourcePixelOffset + 2];                                  fullBuffer[bufferOffset + i + 1] = targetRgba[sourcePixelOffset + 1];                                  fullBuffer[bufferOffset + i + 2] = targetRgba[sourcePixelOffset + 0];                                  fullBuffer[bufferOffset + i + 3] = targetRgba[sourcePixelOffset + 3];                              }                                sourcePixelOffset += 4; // Skip this pixel as it is outside the image.                          }                      }                        // advance                      blockOffset += bytesPerBlock;                  }              }
Magic Number,DotSquish,Squish,C:\repos\Rogueadyn_SaintCoinach\DotSquish\Squish.cs,DecompressToBitmap,The following statement contains a magic number: fixed (byte* p = fullBuffer) {                  var ptr = (IntPtr)p;                  var tempImage = new Bitmap(width' height' 4 * width' System.Drawing.Imaging.PixelFormat.Format32bppArgb' ptr);                  ret = new Bitmap(tempImage);              }
