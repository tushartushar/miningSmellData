Implementation smell,Namespace,Class,File,Method,Description
Long Method,YamlDotNet.Core,Emitter,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Emitter.cs,AnalyzeScalar,The method has 141 lines of code.
Long Method,YamlDotNet.Core,Parser,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Parser.cs,ParseNode,The method has 118 lines of code.
Long Method,YamlDotNet.Core,Scanner,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Scanner.cs,FetchNextToken,The method has 170 lines of code.
Long Method,YamlDotNet.Core,Scanner,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Scanner.cs,ScanBlockScalar,The method has 119 lines of code.
Long Method,YamlDotNet.Core,Scanner,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Scanner.cs,ScanFlowScalar,The method has 174 lines of code.
Long Method,YamlDotNet.Core,Scanner,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Scanner.cs,ScanPlainScalar,The method has 125 lines of code.
Long Method,YamlDotNet.Serialization.Utilities,TypeConverter,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Serialization\Utilities\TypeConverter.cs,ChangeType,The method has 112 lines of code.
Complex Method,YamlDotNet.Core,Emitter,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Emitter.cs,AnalyzeScalar,Cyclomatic complexity of the method is 23
Complex Method,YamlDotNet.Core,Emitter,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Emitter.cs,EmitDocumentStart,Cyclomatic complexity of the method is 12
Complex Method,YamlDotNet.Core,Emitter,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Emitter.cs,SelectScalarStyle,Cyclomatic complexity of the method is 13
Complex Method,YamlDotNet.Core,MergingParser,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\MergingParser.cs,MoveNext,Cyclomatic complexity of the method is 12
Complex Method,YamlDotNet.Core,Parser,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Parser.cs,ParseNode,Cyclomatic complexity of the method is 8
Complex Method,YamlDotNet.Core,Scanner,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Scanner.cs,FetchNextToken,Cyclomatic complexity of the method is 22
Complex Method,YamlDotNet.Core,Scanner,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Scanner.cs,ScanBlockScalar,Cyclomatic complexity of the method is 14
Complex Method,YamlDotNet.Core,Scanner,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Scanner.cs,ScanFlowScalar,Cyclomatic complexity of the method is 13
Complex Method,YamlDotNet.Core,Scanner,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Scanner.cs,ScanPlainScalar,Cyclomatic complexity of the method is 18
Complex Method,YamlDotNet.RepresentationModel,YamlMappingNode,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\RepresentationModel\YamlMappingNode.cs,ResolveAliases,Cyclomatic complexity of the method is 10
Complex Method,YamlDotNet.Serialization.Utilities,TypeConverter,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Serialization\Utilities\TypeConverter.cs,ChangeType,Cyclomatic complexity of the method is 19
Long Parameter List,YamlDotNet.Core.Events,DocumentStart,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Events\DocumentStart.cs,DocumentStart,The method has 5 parameters. Parameters: version' tags' isImplicit' start' end
Long Parameter List,YamlDotNet.Core.Events,MappingStart,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Events\MappingStart.cs,MappingStart,The method has 6 parameters. Parameters: anchor' tag' isImplicit' style' start' end
Long Parameter List,YamlDotNet.Core.Events,Scalar,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Events\Scalar.cs,Scalar,The method has 8 parameters. Parameters: anchor' tag' value' style' isPlainImplicit' isQuotedImplicit' start' end
Long Parameter List,YamlDotNet.Core.Events,Scalar,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Events\Scalar.cs,Scalar,The method has 6 parameters. Parameters: anchor' tag' value' style' isPlainImplicit' isQuotedImplicit
Long Parameter List,YamlDotNet.Core.Events,SequenceStart,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Events\SequenceStart.cs,SequenceStart,The method has 6 parameters. Parameters: anchor' tag' isImplicit' style' start' end
Long Identifier,YamlDotNet.Serialization.ObjectFactories,DefaultObjectFactory,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Serialization\ObjectFactories\DefaultObjectFactory.cs,,The length of the parameter defaultInterfaceImplementations is 31.
Long Identifier,YamlDotNet.Serialization.ObjectGraphTraversalStrategies,FullObjectGraphTraversalStrategy,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Serialization\ObjectGraphTraversalStrategies\FullObjectGraphTraversalStrategy.cs,,The length of the parameter traverseGenericDictionaryHelper is 31.
Long Statement,YamlDotNet.Core,Emitter,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Emitter.cs,AnalyzeVersionDirective,The length of the statement  "			if (versionDirective.Version.Major != Constants.MajorVersion || versionDirective.Version.Minor != Constants.MinorVersion) " is 121.
Long Statement,YamlDotNet.Core,LookAheadBuffer,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\LookAheadBuffer.cs,Skip,The length of the statement  "				throw new ArgumentOutOfRangeException("length"' "The length must be between 1 and the number of characters in the buffer. Use the Peek() and / or Cache() methods to fill the buffer."); " is 184.
Long Statement,YamlDotNet.Core,Parser,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Parser.cs,GetCurrentToken,The length of the statement  "						pendingEvents.Enqueue(new Events.Comment(commentToken.Value' commentToken.IsInline' commentToken.Start' commentToken.End)); " is 123.
Long Statement,YamlDotNet.Core,Parser,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Parser.cs,ParseDocumentStart,The length of the statement  "			if (isImplicit && !(GetCurrentToken() is VersionDirective || GetCurrentToken() is TagDirective || GetCurrentToken() is DocumentStart || GetCurrentToken() is StreamEnd)) " is 168.
Long Statement,YamlDotNet.Core,Parser,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Parser.cs,ParseNode,The length of the statement  "					ParsingEvent evt = new Events.Scalar(anchorName' tagName' scalar.Value' scalar.Style' isPlainImplicit' isQuotedImplicit' start' scalar.End); " is 140.
Long Statement,YamlDotNet.Core,Parser,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Parser.cs,ParseNode,The length of the statement  "					return new Events.Scalar(anchorName' tagName' string.Empty' ScalarStyle.Plain' isImplicit' false' start' GetCurrentToken().End); " is 128.
Long Statement,YamlDotNet.Core,Parser,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Parser.cs,ParseNode,The length of the statement  "				throw new SemanticErrorException(current.Start' current.End' "While parsing a node' did not find expected node content."); " is 122.
Long Statement,YamlDotNet.Core,Parser,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Parser.cs,ParseBlockSequenceEntry,The length of the statement  "				throw new SemanticErrorException(current.Start' current.End' "While parsing a block collection' did not find expected '-' indicator."); " is 135.
Long Statement,YamlDotNet.Core,Parser,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Parser.cs,ParseIndentlessSequenceEntry,The length of the statement  "				if (!(GetCurrentToken() is BlockEntry || GetCurrentToken() is Key || GetCurrentToken() is Value || GetCurrentToken() is BlockEnd)) " is 130.
Long Statement,YamlDotNet.Core,Parser,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Parser.cs,ParseBlockMappingKey,The length of the statement  "				throw new SemanticErrorException(current.Start' current.End' "While parsing a block mapping' did not find expected key."); " is 122.
Long Statement,YamlDotNet.Core,Parser,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Parser.cs,ParseFlowSequenceEntry,The length of the statement  "						throw new SemanticErrorException(current.Start' current.End' "While parsing a flow sequence' did not find expected ''' or ']'."); " is 129.
Long Statement,YamlDotNet.Core,Parser,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Parser.cs,ParseFlowMappingKey,The length of the statement  "						throw new SemanticErrorException(current.Start' current.End' "While parsing a flow mapping'  did not find expected ''' or '}'."); " is 129.
Long Statement,YamlDotNet.Core,Scanner,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Scanner.cs,FetchNextToken,The length of the statement  "			throw new SyntaxErrorException(mark' mark' "While scanning for the next token' find character that cannot start any token."); " is 125.
Long Statement,YamlDotNet.Core,Scanner,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Scanner.cs,ScanDirective,The length of the statement  "				throw new SyntaxErrorException(start' cursor.Mark()' "While scanning a directive' did not find expected comment or line break."); " is 129.
Long Statement,YamlDotNet.Core,Scanner,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Scanner.cs,ScanAnchor,The length of the statement  "				throw new SyntaxErrorException(start' cursor.Mark()' "While scanning an anchor or alias' did not find expected alphabetic or numeric character."); " is 146.
Long Statement,YamlDotNet.Core,Scanner,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Scanner.cs,ScanTag,The length of the statement  "				throw new SyntaxErrorException(start' cursor.Mark()' "While scanning a tag' did not find expected whitespace or line break."); " is 126.
Long Statement,YamlDotNet.Core,Scanner,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Scanner.cs,ScanBlockScalar,The length of the statement  "						throw new SyntaxErrorException(start' cursor.Mark()' "While scanning a block scalar' find an intendation indicator equal to 0."); " is 129.
Long Statement,YamlDotNet.Core,Scanner,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Scanner.cs,ScanBlockScalar,The length of the statement  "					throw new SyntaxErrorException(start' cursor.Mark()' "While scanning a block scalar' find an intendation indicator equal to 0."); " is 129.
Long Statement,YamlDotNet.Core,Scanner,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Scanner.cs,ScanBlockScalar,The length of the statement  "				throw new SyntaxErrorException(start' cursor.Mark()' "While scanning a block scalar' did not find expected comment or line break."); " is 132.
Long Statement,YamlDotNet.Core,Scanner,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Scanner.cs,ScanBlockScalarBreaks,The length of the statement  "					throw new SyntaxErrorException(start' cursor.Mark()' "While scanning a block scalar' find a tab character where an intendation space is expected."); " is 148.
Long Statement,YamlDotNet.Core,Scanner,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Scanner.cs,ScanFlowScalar,The length of the statement  "					throw new SyntaxErrorException(start' cursor.Mark()' "While scanning a quoted scalar' find unexpected document indicator."); " is 124.
Long Statement,YamlDotNet.Core,Scanner,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Scanner.cs,ScanFlowScalar,The length of the statement  "									throw new SyntaxErrorException(start' cursor.Mark()' "While parsing a quoted scalar' did not find expected hexdecimal number."); " is 128.
Long Statement,YamlDotNet.Core,Scanner,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Scanner.cs,ScanFlowScalar,The length of the statement  "								throw new SyntaxErrorException(start' cursor.Mark()' "While parsing a quoted scalar' find invalid Unicode character escape code."); " is 131.
Long Statement,YamlDotNet.Core,Scanner,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Scanner.cs,ScanPlainScalar,The length of the statement  "							throw new SyntaxErrorException(start' cursor.Mark()' "While scanning a plain scalar' find a tab character that violate intendation."); " is 134.
Long Statement,YamlDotNet.Core,Scanner,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Scanner.cs,ScanDirectiveName,The length of the statement  "				throw new SyntaxErrorException(start' cursor.Mark()' "While scanning a directive' could not find expected directive name."); " is 124.
Long Statement,YamlDotNet.Core,Scanner,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Scanner.cs,ScanDirectiveName,The length of the statement  "				throw new SyntaxErrorException(start' cursor.Mark()' "While scanning a directive' find unexpected non-alphabetical character."); " is 128.
Long Statement,YamlDotNet.Core,Scanner,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Scanner.cs,ScanVersionDirectiveValue,The length of the statement  "				throw new SyntaxErrorException(start' cursor.Mark()' "While scanning a %YAML directive' did not find expected digit or '.' character."); " is 136.
Long Statement,YamlDotNet.Core,Scanner,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Scanner.cs,ScanTagDirectiveValue,The length of the statement  "				throw new SyntaxErrorException(start' cursor.Mark()' "While scanning a %TAG directive' did not find expected whitespace."); " is 123.
Long Statement,YamlDotNet.Core,Scanner,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Scanner.cs,ScanTagDirectiveValue,The length of the statement  "				throw new SyntaxErrorException(start' cursor.Mark()' "While scanning a %TAG directive' did not find expected whitespace or line break."); " is 137.
Long Statement,YamlDotNet.Core,Scanner,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Scanner.cs,ScanVersionDirectiveNumber,The length of the statement  "					throw new SyntaxErrorException(start' cursor.Mark()' "While scanning a %YAML directive' find extremely long version number."); " is 126.
Long Statement,YamlDotNet.Core,Scanner,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Scanner.cs,ScanVersionDirectiveNumber,The length of the statement  "				throw new SyntaxErrorException(start' cursor.Mark()' "While scanning a %YAML directive' did not find expected version number."); " is 128.
Long Statement,YamlDotNet.Core,Scanner,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Scanner.cs,SaveSimpleKey,The length of the statement  "			Debug.Assert(simpleKeyAllowed || !isRequired' "Can't require a simple key and disallow it at the same time.");    // Impossible. " is 128.
Long Statement,YamlDotNet,ReflectionExtensions,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Helpers\Portability.cs,HasDefaultConstructor,The length of the statement  "            return type.IsValueType || type.GetConstructor(BindingFlags.Public | BindingFlags.Instance' null' Type.EmptyTypes' null) != null; " is 129.
Long Statement,YamlDotNet.RepresentationModel,DocumentLoadingState,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\RepresentationModel\DocumentLoadingState.cs,AddAnchor,The length of the statement  "				throw new DuplicateAnchorException(node.Start' node.End' string.Format(CultureInfo.InvariantCulture' "The anchor '{0}' already exists"' node.Anchor)); " is 150.
Long Statement,YamlDotNet.RepresentationModel,DocumentLoadingState,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\RepresentationModel\DocumentLoadingState.cs,GetNode,The length of the statement  "				throw new AnchorNotFoundException(start' end' string.Format(CultureInfo.InvariantCulture' "The anchor '{0}' does not exists"' anchor)); " is 135.
Long Statement,YamlDotNet.RepresentationModel,YamlNode,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\RepresentationModel\YamlNode.cs,Equals,The length of the statement  "			// Do not use the anchor in the equality comparison because that would prevent anchored nodes from being found in dictionaries. " is 127.
Long Statement,YamlDotNet.Serialization.EventEmitters,JsonEventEmitter,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Serialization\EventEmitters\JsonEventEmitter.cs,Emit,The length of the statement  "					throw new NotSupportedException(string.Format(CultureInfo.InvariantCulture' "TypeCode.{0} is not supported."' typeCode)); " is 121.
Long Statement,YamlDotNet.Serialization.EventEmitters,TypeAssigningEventEmitter,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Serialization\EventEmitters\TypeAssigningEventEmitter.cs,Emit,The length of the statement  "					throw new NotSupportedException(string.Format(CultureInfo.InvariantCulture' "TypeCode.{0} is not supported."' typeCode)); " is 121.
Long Statement,YamlDotNet.Serialization.EventEmitters,WriterEventEmitter,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Serialization\EventEmitters\WriterEventEmitter.cs,Emit,The length of the statement  "			emitter.Emit(new Scalar(eventInfo.Anchor' eventInfo.Tag' eventInfo.RenderedValue' eventInfo.Style' eventInfo.IsPlainImplicit' eventInfo.IsQuotedImplicit)); " is 155.
Long Statement,YamlDotNet.Serialization.NodeDeserializers,ArrayNodeDeserializer,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Serialization\NodeDeserializers\ArrayNodeDeserializer.cs,Deserialize,The length of the statement  "			value = _deserializeHelper.Invoke(new[] { expectedType.GetElementType() }' reader' expectedType' nestedObjectDeserializer); " is 123.
Long Statement,YamlDotNet.Serialization.NodeDeserializers,GenericDictionaryNodeDeserializer,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Serialization\NodeDeserializers\GenericDictionaryNodeDeserializer.cs,Deserialize,The length of the statement  "			deserializeHelperMethod.Invoke(iDictionary.GetGenericArguments()' reader' expectedType' nestedObjectDeserializer' value); " is 121.
Long Statement,YamlDotNet.Serialization.ObjectGraphTraversalStrategies,FullObjectGraphTraversalStrategy,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Serialization\ObjectGraphTraversalStrategies\FullObjectGraphTraversalStrategy.cs,Traverse,The length of the statement  "					throw new NotSupportedException(string.Format(CultureInfo.InvariantCulture' "TypeCode.{0} is not supported."' typeCode)); " is 121.
Long Statement,YamlDotNet.Serialization.ObjectGraphTraversalStrategies,RoundtripObjectGraphTraversalStrategy,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Serialization\ObjectGraphTraversalStrategies\RoundtripObjectGraphTraversalStrategy.cs,TraverseProperties,The length of the statement  "				throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture' "Type '{0}' cannot be deserialized because it does not have a default constructor or a type converter."' value.Type)); " is 198.
Long Statement,YamlDotNet.Serialization.TypeInspectors,TypeInspectorSkeleton,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Serialization\TypeInspectors\TypeInspectorSkeleton.cs,GetProperty,The length of the statement  "							"Multiple properties with the name/alias '{0}' already exists on type '{1}'' maybe you're misusing YamlAlias or maybe you are using the wrong naming convention? The matching properties are: {2}"' " is 195.
Long Statement,YamlDotNet.Serialization.Utilities,StringExtensions,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Serialization\Utilities\StringExtensions.cs,ToCamelOrPascalCase,The length of the statement  "			var text = Regex.Replace(str' "([_\\-])(?<char>[a-z])"' match => match.Groups["char"].Value.ToUpperInvariant()' RegexOptions.IgnoreCase); " is 137.
Long Statement,YamlDotNet.Serialization.Utilities,StringExtensions,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Serialization\Utilities\StringExtensions.cs,FromCamelCase,The length of the statement  "			str = Regex.Replace(str.ToCamelCase()' "(?<char>[A-Z])"' match => separator + match.Groups["char"].Value.ToLowerInvariant()); " is 125.
Long Statement,YamlDotNet.Serialization.ValueDeserializers,NodeValueDeserializer,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Serialization\ValueDeserializers\NodeValueDeserializer.cs,DeserializeValue,The length of the statement  "				if (deserializer.Deserialize(reader' nodeType' (r' t) => nestedObjectDeserializer.DeserializeValue(r' t' state' nestedObjectDeserializer)' out value)) " is 150.
Complex Conditional,YamlDotNet.Core,Emitter,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Emitter.cs,AnalyzeScalar,The conditional expression  "leadingSpace || leadingBreak || trailingSpace || trailingBreak"  is complex.
Complex Conditional,YamlDotNet.Core,Emitter,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Emitter.cs,EmitDocumentStart,The conditional expression  "!isFirst && !isDocumentEndWritten && (documentStart.Version != null || documentTagDirectives.Count > 0)"  is complex.
Complex Conditional,YamlDotNet.Core,Emitter,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Emitter.cs,SelectScalarStyle,The conditional expression  "(flowLevel != 0 && !scalarData.isFlowPlainAllowed) || (flowLevel == 0 && !scalarData.isBlockPlainAllowed)"  is complex.
Complex Conditional,YamlDotNet.Core,Emitter,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Emitter.cs,WritePlainScalar,The conditional expression  "allowBreaks && !previousSpace && column > bestWidth && index + 1 < value.Length && value[index + 1] != ' '"  is complex.
Complex Conditional,YamlDotNet.Core,Emitter,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Emitter.cs,WriteSingleQuotedScalar,The conditional expression  "allowBreaks && !previousSpace && column > bestWidth && index != 0 && index + 1 < value.Length &&  						value[index + 1] != ' '"  is complex.
Complex Conditional,YamlDotNet.Core,Emitter,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Emitter.cs,WriteDoubleQuotedScalar,The conditional expression  "!IsPrintable(character) || IsBreak(character) || character == '"' || character == '\\'"  is complex.
Complex Conditional,YamlDotNet.Core,Emitter,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Emitter.cs,WriteDoubleQuotedScalar,The conditional expression  "allowBreaks && !previousSpace && column > bestWidth && index > 0 && index + 1 < value.Length"  is complex.
Complex Conditional,YamlDotNet.Core,Emitter,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Emitter.cs,WriteFoldedScalar,The conditional expression  "!previousBreak && character == ' ' && i + 1 < value.Length && value[i + 1] != ' ' && column > bestWidth"  is complex.
Complex Conditional,YamlDotNet.Core,Emitter,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Emitter.cs,EmitSequenceStart,The conditional expression  "flowLevel != 0 || isCanonical || sequenceStart.Style == SequenceStyle.Flow || CheckEmptySequence()"  is complex.
Complex Conditional,YamlDotNet.Core,Emitter,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Emitter.cs,EmitMappingStart,The conditional expression  "flowLevel != 0 || isCanonical || mappingStart.Style == MappingStyle.Flow || CheckEmptyMapping()"  is complex.
Complex Conditional,YamlDotNet.Core,Emitter,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Emitter.cs,WriteIndent,The conditional expression  "!isIndentation || column > currentIndent || (column == currentIndent && !isWhitespace)"  is complex.
Complex Conditional,YamlDotNet.Core,Parser,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Parser.cs,ParseDocumentStart,The conditional expression  "isImplicit && !(GetCurrentToken() is VersionDirective || GetCurrentToken() is TagDirective || GetCurrentToken() is DocumentStart || GetCurrentToken() is StreamEnd)"  is complex.
Complex Conditional,YamlDotNet.Core,Parser,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Parser.cs,ParseDocumentContent,The conditional expression  "GetCurrentToken() is VersionDirective ||  			    GetCurrentToken() is TagDirective ||  			    GetCurrentToken() is DocumentStart ||  			    GetCurrentToken() is DocumentEnd ||  			    GetCurrentToken() is StreamEnd"  is complex.
Complex Conditional,YamlDotNet.Core,Parser,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Parser.cs,ParseIndentlessSequenceEntry,The conditional expression  "!(GetCurrentToken() is BlockEntry || GetCurrentToken() is Key || GetCurrentToken() is Value || GetCurrentToken() is BlockEnd)"  is complex.
Complex Conditional,YamlDotNet.Core,Scanner,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Scanner.cs,ScanBlockScalar,The conditional expression  "!isLiteral && StartsWith(leadingBreak' '\n') && !leadingBlank && !trailingBlank"  is complex.
Complex Conditional,YamlDotNet.Core,Scanner,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Scanner.cs,ScanPlainScalar,The conditional expression  "(analyzer.Check(':') && analyzer.IsWhiteBreakOrZero(1)) || (flowLevel > 0 && analyzer.Check("':?[]{}"))"  is complex.
Magic Number,YamlDotNet.Core,CharacterAnalyzer<TBuffer>,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\CharacterAnalyzer.cs,AsHex,The following statement contains a magic number: if (character <= 'F')  			{  				return character - 'A' + 10;  			}
Magic Number,YamlDotNet.Core,CharacterAnalyzer<TBuffer>,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\CharacterAnalyzer.cs,AsHex,The following statement contains a magic number: return character - 'a' + 10;
Magic Number,YamlDotNet.Core,Emitter,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Emitter.cs,Emitter,The following statement contains a magic number: if (bestWidth <= bestIndent * 2)  			{  				throw new ArgumentOutOfRangeException("bestWidth"' "The bestWidth parameter must be greater than bestIndent * 2.");  			}
Magic Number,YamlDotNet.Core,Emitter,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Emitter.cs,NeedMoreEvents,The following statement contains a magic number: switch (events.Peek().Type)  			{  				case EventType.DocumentStart:  					accumulate = 1;  					break;    				case EventType.SequenceStart:  					accumulate = 2;  					break;    				case EventType.MappingStart:  					accumulate = 3;  					break;    				default:  					return false;  			}
Magic Number,YamlDotNet.Core,Emitter,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Emitter.cs,NeedMoreEvents,The following statement contains a magic number: switch (events.Peek().Type)  			{  				case EventType.DocumentStart:  					accumulate = 1;  					break;    				case EventType.SequenceStart:  					accumulate = 2;  					break;    				case EventType.MappingStart:  					accumulate = 3;  					break;    				default:  					return false;  			}
Magic Number,YamlDotNet.Core,Emitter,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Emitter.cs,CheckEmptyDocument,The following statement contains a magic number: foreach (var parsingEvent in events)  			{  				index++;  				if (index == 2)  				{  					var scalar = parsingEvent as Scalar;  					if (scalar != null)  					{  						return string.IsNullOrEmpty(scalar.Value);  					}  					break;  				}  			}
Magic Number,YamlDotNet.Core,Emitter,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Emitter.cs,CheckEmptySequence,The following statement contains a magic number: if (events.Count < 2)  			{  				return false;  			}
Magic Number,YamlDotNet.Core,Emitter,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Emitter.cs,CheckEmptyMapping,The following statement contains a magic number: if (events.Count < 2)  			{  				return false;  			}
Magic Number,YamlDotNet.Core,Emitter,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Emitter.cs,WriteBlockScalarHints,The following statement contains a magic number: if (value.Length == 0 || !analyzer.IsBreak(value.Length - 1))  			{  				chompHint = "-";  			}  			else if (value.Length >= 2 && analyzer.IsBreak(value.Length - 2))  			{  				chompHint = "+";  				isOpenEnded = true;  			}
Magic Number,YamlDotNet.Core,Emitter,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Emitter.cs,WriteBlockScalarHints,The following statement contains a magic number: if (value.Length == 0 || !analyzer.IsBreak(value.Length - 1))  			{  				chompHint = "-";  			}  			else if (value.Length >= 2 && analyzer.IsBreak(value.Length - 2))  			{  				chompHint = "+";  				isOpenEnded = true;  			}
Magic Number,YamlDotNet.Core,MergingParser,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\MergingParser.cs,MoveNext,The following statement contains a magic number: if (_currentIndex < 0)  			{  				while (_innerParser.MoveNext())  				{  					_allEvents.Add(_innerParser.Current);  				}    				for (int i = _allEvents.Count - 2; i >= 0; --i)  				{  					var merge = _allEvents[i] as Scalar;  					if (merge != null && merge.Value == "<<")  					{  						var anchorAlias = _allEvents[i + 1] as AnchorAlias;  						if (anchorAlias != null)  						{  							var mergedEvents = GetMappingEvents(anchorAlias.Value);  							_allEvents.RemoveRange(i' 2);  							_allEvents.InsertRange(i' mergedEvents);  							continue;  						}    						var sequence = _allEvents[i + 1] as SequenceStart;  						if (sequence != null)  						{  							var mergedEvents = new List<IEnumerable<ParsingEvent>>();  							var sequenceEndFound = false;  							for (var itemIndex = i + 2; itemIndex < _allEvents.Count; ++itemIndex)  							{  								anchorAlias = _allEvents[itemIndex] as AnchorAlias;  								if (anchorAlias != null)  								{  									mergedEvents.Add(GetMappingEvents(anchorAlias.Value));  									continue;  								}    								if (_allEvents[itemIndex] is SequenceEnd)  								{  									_allEvents.RemoveRange(i' itemIndex - i + 1);  									_allEvents.InsertRange(i' mergedEvents.SelectMany(e => e));  									sequenceEndFound = true;  									break;  								}  							}    							if (sequenceEndFound)  							{  								continue;  							}  						}    						throw new SemanticErrorException(merge.Start' merge.End' "Unrecognized merge key pattern");  					}  				}  			}
Magic Number,YamlDotNet.Core,MergingParser,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\MergingParser.cs,MoveNext,The following statement contains a magic number: if (_currentIndex < 0)  			{  				while (_innerParser.MoveNext())  				{  					_allEvents.Add(_innerParser.Current);  				}    				for (int i = _allEvents.Count - 2; i >= 0; --i)  				{  					var merge = _allEvents[i] as Scalar;  					if (merge != null && merge.Value == "<<")  					{  						var anchorAlias = _allEvents[i + 1] as AnchorAlias;  						if (anchorAlias != null)  						{  							var mergedEvents = GetMappingEvents(anchorAlias.Value);  							_allEvents.RemoveRange(i' 2);  							_allEvents.InsertRange(i' mergedEvents);  							continue;  						}    						var sequence = _allEvents[i + 1] as SequenceStart;  						if (sequence != null)  						{  							var mergedEvents = new List<IEnumerable<ParsingEvent>>();  							var sequenceEndFound = false;  							for (var itemIndex = i + 2; itemIndex < _allEvents.Count; ++itemIndex)  							{  								anchorAlias = _allEvents[itemIndex] as AnchorAlias;  								if (anchorAlias != null)  								{  									mergedEvents.Add(GetMappingEvents(anchorAlias.Value));  									continue;  								}    								if (_allEvents[itemIndex] is SequenceEnd)  								{  									_allEvents.RemoveRange(i' itemIndex - i + 1);  									_allEvents.InsertRange(i' mergedEvents.SelectMany(e => e));  									sequenceEndFound = true;  									break;  								}  							}    							if (sequenceEndFound)  							{  								continue;  							}  						}    						throw new SemanticErrorException(merge.Start' merge.End' "Unrecognized merge key pattern");  					}  				}  			}
Magic Number,YamlDotNet.Core,MergingParser,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\MergingParser.cs,MoveNext,The following statement contains a magic number: if (_currentIndex < 0)  			{  				while (_innerParser.MoveNext())  				{  					_allEvents.Add(_innerParser.Current);  				}    				for (int i = _allEvents.Count - 2; i >= 0; --i)  				{  					var merge = _allEvents[i] as Scalar;  					if (merge != null && merge.Value == "<<")  					{  						var anchorAlias = _allEvents[i + 1] as AnchorAlias;  						if (anchorAlias != null)  						{  							var mergedEvents = GetMappingEvents(anchorAlias.Value);  							_allEvents.RemoveRange(i' 2);  							_allEvents.InsertRange(i' mergedEvents);  							continue;  						}    						var sequence = _allEvents[i + 1] as SequenceStart;  						if (sequence != null)  						{  							var mergedEvents = new List<IEnumerable<ParsingEvent>>();  							var sequenceEndFound = false;  							for (var itemIndex = i + 2; itemIndex < _allEvents.Count; ++itemIndex)  							{  								anchorAlias = _allEvents[itemIndex] as AnchorAlias;  								if (anchorAlias != null)  								{  									mergedEvents.Add(GetMappingEvents(anchorAlias.Value));  									continue;  								}    								if (_allEvents[itemIndex] is SequenceEnd)  								{  									_allEvents.RemoveRange(i' itemIndex - i + 1);  									_allEvents.InsertRange(i' mergedEvents.SelectMany(e => e));  									sequenceEndFound = true;  									break;  								}  							}    							if (sequenceEndFound)  							{  								continue;  							}  						}    						throw new SemanticErrorException(merge.Start' merge.End' "Unrecognized merge key pattern");  					}  				}  			}
Magic Number,YamlDotNet.Core,Scanner,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Scanner.cs,StaleSimpleKeys,The following statement contains a magic number: foreach(var key in simpleKeys)  			{    				// The specification requires that a simple key    				//  - is limited to a single line'  				//  - is shorter than 1024 characters.      				if (key.IsPossible && (key.Line < cursor.Line || key.Index + 1024 < cursor.Index))  				{    					// Check if the potential simple key to be removed is required.    					if (key.IsRequired)  					{  						var mark = cursor.Mark();  						throw new SyntaxErrorException(mark' mark' "While scanning a simple key' could not find expected ':'.");  					}    					key.IsPossible = false;  				}  			}
Magic Number,YamlDotNet.Core,Scanner,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Scanner.cs,FetchNextToken,The following statement contains a magic number: analyzer.Buffer.Cache(4);
Magic Number,YamlDotNet.Core,Scanner,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Scanner.cs,FetchNextToken,The following statement contains a magic number: bool isDocumentStart =  				cursor.LineOffset == 0 &&  				analyzer.Check('-'' 0) &&  				analyzer.Check('-'' 1) &&  				analyzer.Check('-'' 2) &&  				analyzer.IsWhiteBreakOrZero(3);
Magic Number,YamlDotNet.Core,Scanner,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Scanner.cs,FetchNextToken,The following statement contains a magic number: bool isDocumentStart =  				cursor.LineOffset == 0 &&  				analyzer.Check('-'' 0) &&  				analyzer.Check('-'' 1) &&  				analyzer.Check('-'' 2) &&  				analyzer.IsWhiteBreakOrZero(3);
Magic Number,YamlDotNet.Core,Scanner,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Scanner.cs,FetchNextToken,The following statement contains a magic number: bool isDocumentEnd =  				cursor.LineOffset == 0 &&  				analyzer.Check('.'' 0) &&  				analyzer.Check('.'' 1) &&  				analyzer.Check('.'' 2) &&  				analyzer.IsWhiteBreakOrZero(3);
Magic Number,YamlDotNet.Core,Scanner,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Scanner.cs,FetchNextToken,The following statement contains a magic number: bool isDocumentEnd =  				cursor.LineOffset == 0 &&  				analyzer.Check('.'' 0) &&  				analyzer.Check('.'' 1) &&  				analyzer.Check('.'' 2) &&  				analyzer.IsWhiteBreakOrZero(3);
Magic Number,YamlDotNet.Core,Scanner,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Scanner.cs,IsDocumentIndicator,The following statement contains a magic number: if (cursor.LineOffset == 0 && analyzer.IsWhiteBreakOrZero(3))  			{  				bool isDocumentStart = analyzer.Check('-'' 0) && analyzer.Check('-'' 1) && analyzer.Check('-'' 2);  				bool isDocumentEnd = analyzer.Check('.'' 0) && analyzer.Check('.'' 1) && analyzer.Check('.'' 2);    				return isDocumentStart || isDocumentEnd;  			}  			else  			{  				return false;  			}
Magic Number,YamlDotNet.Core,Scanner,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Scanner.cs,IsDocumentIndicator,The following statement contains a magic number: if (cursor.LineOffset == 0 && analyzer.IsWhiteBreakOrZero(3))  			{  				bool isDocumentStart = analyzer.Check('-'' 0) && analyzer.Check('-'' 1) && analyzer.Check('-'' 2);  				bool isDocumentEnd = analyzer.Check('.'' 0) && analyzer.Check('.'' 1) && analyzer.Check('.'' 2);    				return isDocumentStart || isDocumentEnd;  			}  			else  			{  				return false;  			}
Magic Number,YamlDotNet.Core,Scanner,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Scanner.cs,IsDocumentIndicator,The following statement contains a magic number: if (cursor.LineOffset == 0 && analyzer.IsWhiteBreakOrZero(3))  			{  				bool isDocumentStart = analyzer.Check('-'' 0) && analyzer.Check('-'' 1) && analyzer.Check('-'' 2);  				bool isDocumentEnd = analyzer.Check('.'' 0) && analyzer.Check('.'' 1) && analyzer.Check('.'' 2);    				return isDocumentStart || isDocumentEnd;  			}  			else  			{  				return false;  			}
Magic Number,YamlDotNet.Core,Scanner,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Scanner.cs,SkipLine,The following statement contains a magic number: if (analyzer.IsCrLf())  			{  				cursor.SkipLineByOffset(2);  				analyzer.Buffer.Skip(2);  			}  			else if (analyzer.IsBreak())  			{  				cursor.SkipLineByOffset(1);  				analyzer.Buffer.Skip(1);  			}  			else if (!analyzer.IsZero())  			{  				throw new InvalidOperationException("Not at a break.");  			}
Magic Number,YamlDotNet.Core,Scanner,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Scanner.cs,SkipLine,The following statement contains a magic number: if (analyzer.IsCrLf())  			{  				cursor.SkipLineByOffset(2);  				analyzer.Buffer.Skip(2);  			}  			else if (analyzer.IsBreak())  			{  				cursor.SkipLineByOffset(1);  				analyzer.Buffer.Skip(1);  			}  			else if (!analyzer.IsZero())  			{  				throw new InvalidOperationException("Not at a break.");  			}
Magic Number,YamlDotNet.Core,Scanner,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Scanner.cs,ScanFlowScalar,The following statement contains a magic number: for (; ;)  			{  				// Check that there are no document indicators at the beginning of the line.    				if (IsDocumentIndicator())  				{  					throw new SyntaxErrorException(start' cursor.Mark()' "While scanning a quoted scalar' find unexpected document indicator.");  				}    				// Check for EOF.    				if (analyzer.IsZero())  				{  					throw new SyntaxErrorException(start' cursor.Mark()' "While scanning a quoted scalar' find unexpected end of stream.");  				}    				// Consume non-blank characters.    				bool hasLeadingBlanks = false;    				while (!analyzer.IsWhiteBreakOrZero())  				{  					// Check for an escaped single quote.    					if (isSingleQuoted && analyzer.Check('\''' 0) && analyzer.Check('\''' 1))  					{  						value.Append('\'');  						Skip();  						Skip();  					}    					// Check for the right quote.    					else if (analyzer.Check(isSingleQuoted ? '\'' : '"'))  					{  						break;  					}    					// Check for an escaped line break.    					else if (!isSingleQuoted && analyzer.Check('\\') && analyzer.IsBreak(1))  					{  						Skip();  						SkipLine();  						hasLeadingBlanks = true;  						break;  					}    					// Check for an escape sequence.    					else if (!isSingleQuoted && analyzer.Check('\\'))  					{  						int codeLength = 0;    						// Check the escape character.    						char escapeCharacter = analyzer.Peek(1);  						switch (escapeCharacter)  						{  							case 'x':  								codeLength = 2;  								break;    							case 'u':  								codeLength = 4;  								break;    							case 'U':  								codeLength = 8;  								break;    							default:  								char unescapedCharacter;  								if (simpleEscapeCodes.TryGetValue(escapeCharacter' out unescapedCharacter))  								{  									value.Append(unescapedCharacter);  								}  								else  								{  									throw new SyntaxErrorException(start' cursor.Mark()' "While parsing a quoted scalar' find unknown escape character.");  								}  								break;  						}    						Skip();  						Skip();    						// Consume an arbitrary escape code.    						if (codeLength > 0)  						{  							uint character = 0;    							// Scan the character value.    							for (int k = 0; k < codeLength; ++k)  							{  								if (!analyzer.IsHex(k))  								{  									throw new SyntaxErrorException(start' cursor.Mark()' "While parsing a quoted scalar' did not find expected hexdecimal number.");  								}  								character = (uint)((character << 4) + analyzer.AsHex(k));  							}    							// Check the value and write the character.    							if ((character >= 0xD800 && character <= 0xDFFF) || character > 0x10FFFF)  							{  								throw new SyntaxErrorException(start' cursor.Mark()' "While parsing a quoted scalar' find invalid Unicode character escape code.");  							}    							value.Append((char)character);    							// Advance the pointer.    							for (int k = 0; k < codeLength; ++k)  							{  								Skip();  							}  						}  					}  					else  					{  						// It is a non-escaped non-blank character.    						value.Append(ReadCurrentCharacter());  					}  				}    				// Check if we are at the end of the scalar.    				if (analyzer.Check(isSingleQuoted ? '\'' : '"'))  					break;    				// Consume blank characters.    				while (analyzer.IsWhite() || analyzer.IsBreak())  				{  					if (analyzer.IsWhite())  					{  						// Consume a space or a tab character.    						if (!hasLeadingBlanks)  						{  							whitespaces.Append(ReadCurrentCharacter());  						}  						else  						{  							Skip();  						}  					}  					else  					{  						// Check if it is a first line break.    						if (!hasLeadingBlanks)  						{  							whitespaces.Length = 0;  							leadingBreak.Append(ReadLine());  							hasLeadingBlanks = true;  						}  						else  						{  							trailingBreaks.Append(ReadLine());  						}  					}  				}    				// Join the whitespaces or fold line breaks.    				if (hasLeadingBlanks)  				{  					// Do we need to fold line breaks?    					if (StartsWith(leadingBreak' '\n'))  					{  						if (trailingBreaks.Length == 0)  						{  							value.Append(' ');  						}  						else  						{  							value.Append(trailingBreaks.ToString());  						}  					}  					else  					{  						value.Append(leadingBreak.ToString());  						value.Append(trailingBreaks.ToString());  					}  					leadingBreak.Length = 0;  					trailingBreaks.Length = 0;  				}  				else  				{  					value.Append(whitespaces.ToString());  					whitespaces.Length = 0;  				}  			}
Magic Number,YamlDotNet.Core,Scanner,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Scanner.cs,ScanFlowScalar,The following statement contains a magic number: for (; ;)  			{  				// Check that there are no document indicators at the beginning of the line.    				if (IsDocumentIndicator())  				{  					throw new SyntaxErrorException(start' cursor.Mark()' "While scanning a quoted scalar' find unexpected document indicator.");  				}    				// Check for EOF.    				if (analyzer.IsZero())  				{  					throw new SyntaxErrorException(start' cursor.Mark()' "While scanning a quoted scalar' find unexpected end of stream.");  				}    				// Consume non-blank characters.    				bool hasLeadingBlanks = false;    				while (!analyzer.IsWhiteBreakOrZero())  				{  					// Check for an escaped single quote.    					if (isSingleQuoted && analyzer.Check('\''' 0) && analyzer.Check('\''' 1))  					{  						value.Append('\'');  						Skip();  						Skip();  					}    					// Check for the right quote.    					else if (analyzer.Check(isSingleQuoted ? '\'' : '"'))  					{  						break;  					}    					// Check for an escaped line break.    					else if (!isSingleQuoted && analyzer.Check('\\') && analyzer.IsBreak(1))  					{  						Skip();  						SkipLine();  						hasLeadingBlanks = true;  						break;  					}    					// Check for an escape sequence.    					else if (!isSingleQuoted && analyzer.Check('\\'))  					{  						int codeLength = 0;    						// Check the escape character.    						char escapeCharacter = analyzer.Peek(1);  						switch (escapeCharacter)  						{  							case 'x':  								codeLength = 2;  								break;    							case 'u':  								codeLength = 4;  								break;    							case 'U':  								codeLength = 8;  								break;    							default:  								char unescapedCharacter;  								if (simpleEscapeCodes.TryGetValue(escapeCharacter' out unescapedCharacter))  								{  									value.Append(unescapedCharacter);  								}  								else  								{  									throw new SyntaxErrorException(start' cursor.Mark()' "While parsing a quoted scalar' find unknown escape character.");  								}  								break;  						}    						Skip();  						Skip();    						// Consume an arbitrary escape code.    						if (codeLength > 0)  						{  							uint character = 0;    							// Scan the character value.    							for (int k = 0; k < codeLength; ++k)  							{  								if (!analyzer.IsHex(k))  								{  									throw new SyntaxErrorException(start' cursor.Mark()' "While parsing a quoted scalar' did not find expected hexdecimal number.");  								}  								character = (uint)((character << 4) + analyzer.AsHex(k));  							}    							// Check the value and write the character.    							if ((character >= 0xD800 && character <= 0xDFFF) || character > 0x10FFFF)  							{  								throw new SyntaxErrorException(start' cursor.Mark()' "While parsing a quoted scalar' find invalid Unicode character escape code.");  							}    							value.Append((char)character);    							// Advance the pointer.    							for (int k = 0; k < codeLength; ++k)  							{  								Skip();  							}  						}  					}  					else  					{  						// It is a non-escaped non-blank character.    						value.Append(ReadCurrentCharacter());  					}  				}    				// Check if we are at the end of the scalar.    				if (analyzer.Check(isSingleQuoted ? '\'' : '"'))  					break;    				// Consume blank characters.    				while (analyzer.IsWhite() || analyzer.IsBreak())  				{  					if (analyzer.IsWhite())  					{  						// Consume a space or a tab character.    						if (!hasLeadingBlanks)  						{  							whitespaces.Append(ReadCurrentCharacter());  						}  						else  						{  							Skip();  						}  					}  					else  					{  						// Check if it is a first line break.    						if (!hasLeadingBlanks)  						{  							whitespaces.Length = 0;  							leadingBreak.Append(ReadLine());  							hasLeadingBlanks = true;  						}  						else  						{  							trailingBreaks.Append(ReadLine());  						}  					}  				}    				// Join the whitespaces or fold line breaks.    				if (hasLeadingBlanks)  				{  					// Do we need to fold line breaks?    					if (StartsWith(leadingBreak' '\n'))  					{  						if (trailingBreaks.Length == 0)  						{  							value.Append(' ');  						}  						else  						{  							value.Append(trailingBreaks.ToString());  						}  					}  					else  					{  						value.Append(leadingBreak.ToString());  						value.Append(trailingBreaks.ToString());  					}  					leadingBreak.Length = 0;  					trailingBreaks.Length = 0;  				}  				else  				{  					value.Append(whitespaces.ToString());  					whitespaces.Length = 0;  				}  			}
Magic Number,YamlDotNet.Core,Scanner,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Scanner.cs,ScanFlowScalar,The following statement contains a magic number: for (; ;)  			{  				// Check that there are no document indicators at the beginning of the line.    				if (IsDocumentIndicator())  				{  					throw new SyntaxErrorException(start' cursor.Mark()' "While scanning a quoted scalar' find unexpected document indicator.");  				}    				// Check for EOF.    				if (analyzer.IsZero())  				{  					throw new SyntaxErrorException(start' cursor.Mark()' "While scanning a quoted scalar' find unexpected end of stream.");  				}    				// Consume non-blank characters.    				bool hasLeadingBlanks = false;    				while (!analyzer.IsWhiteBreakOrZero())  				{  					// Check for an escaped single quote.    					if (isSingleQuoted && analyzer.Check('\''' 0) && analyzer.Check('\''' 1))  					{  						value.Append('\'');  						Skip();  						Skip();  					}    					// Check for the right quote.    					else if (analyzer.Check(isSingleQuoted ? '\'' : '"'))  					{  						break;  					}    					// Check for an escaped line break.    					else if (!isSingleQuoted && analyzer.Check('\\') && analyzer.IsBreak(1))  					{  						Skip();  						SkipLine();  						hasLeadingBlanks = true;  						break;  					}    					// Check for an escape sequence.    					else if (!isSingleQuoted && analyzer.Check('\\'))  					{  						int codeLength = 0;    						// Check the escape character.    						char escapeCharacter = analyzer.Peek(1);  						switch (escapeCharacter)  						{  							case 'x':  								codeLength = 2;  								break;    							case 'u':  								codeLength = 4;  								break;    							case 'U':  								codeLength = 8;  								break;    							default:  								char unescapedCharacter;  								if (simpleEscapeCodes.TryGetValue(escapeCharacter' out unescapedCharacter))  								{  									value.Append(unescapedCharacter);  								}  								else  								{  									throw new SyntaxErrorException(start' cursor.Mark()' "While parsing a quoted scalar' find unknown escape character.");  								}  								break;  						}    						Skip();  						Skip();    						// Consume an arbitrary escape code.    						if (codeLength > 0)  						{  							uint character = 0;    							// Scan the character value.    							for (int k = 0; k < codeLength; ++k)  							{  								if (!analyzer.IsHex(k))  								{  									throw new SyntaxErrorException(start' cursor.Mark()' "While parsing a quoted scalar' did not find expected hexdecimal number.");  								}  								character = (uint)((character << 4) + analyzer.AsHex(k));  							}    							// Check the value and write the character.    							if ((character >= 0xD800 && character <= 0xDFFF) || character > 0x10FFFF)  							{  								throw new SyntaxErrorException(start' cursor.Mark()' "While parsing a quoted scalar' find invalid Unicode character escape code.");  							}    							value.Append((char)character);    							// Advance the pointer.    							for (int k = 0; k < codeLength; ++k)  							{  								Skip();  							}  						}  					}  					else  					{  						// It is a non-escaped non-blank character.    						value.Append(ReadCurrentCharacter());  					}  				}    				// Check if we are at the end of the scalar.    				if (analyzer.Check(isSingleQuoted ? '\'' : '"'))  					break;    				// Consume blank characters.    				while (analyzer.IsWhite() || analyzer.IsBreak())  				{  					if (analyzer.IsWhite())  					{  						// Consume a space or a tab character.    						if (!hasLeadingBlanks)  						{  							whitespaces.Append(ReadCurrentCharacter());  						}  						else  						{  							Skip();  						}  					}  					else  					{  						// Check if it is a first line break.    						if (!hasLeadingBlanks)  						{  							whitespaces.Length = 0;  							leadingBreak.Append(ReadLine());  							hasLeadingBlanks = true;  						}  						else  						{  							trailingBreaks.Append(ReadLine());  						}  					}  				}    				// Join the whitespaces or fold line breaks.    				if (hasLeadingBlanks)  				{  					// Do we need to fold line breaks?    					if (StartsWith(leadingBreak' '\n'))  					{  						if (trailingBreaks.Length == 0)  						{  							value.Append(' ');  						}  						else  						{  							value.Append(trailingBreaks.ToString());  						}  					}  					else  					{  						value.Append(leadingBreak.ToString());  						value.Append(trailingBreaks.ToString());  					}  					leadingBreak.Length = 0;  					trailingBreaks.Length = 0;  				}  				else  				{  					value.Append(whitespaces.ToString());  					whitespaces.Length = 0;  				}  			}
Magic Number,YamlDotNet.Core,Scanner,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Scanner.cs,ScanFlowScalar,The following statement contains a magic number: for (; ;)  			{  				// Check that there are no document indicators at the beginning of the line.    				if (IsDocumentIndicator())  				{  					throw new SyntaxErrorException(start' cursor.Mark()' "While scanning a quoted scalar' find unexpected document indicator.");  				}    				// Check for EOF.    				if (analyzer.IsZero())  				{  					throw new SyntaxErrorException(start' cursor.Mark()' "While scanning a quoted scalar' find unexpected end of stream.");  				}    				// Consume non-blank characters.    				bool hasLeadingBlanks = false;    				while (!analyzer.IsWhiteBreakOrZero())  				{  					// Check for an escaped single quote.    					if (isSingleQuoted && analyzer.Check('\''' 0) && analyzer.Check('\''' 1))  					{  						value.Append('\'');  						Skip();  						Skip();  					}    					// Check for the right quote.    					else if (analyzer.Check(isSingleQuoted ? '\'' : '"'))  					{  						break;  					}    					// Check for an escaped line break.    					else if (!isSingleQuoted && analyzer.Check('\\') && analyzer.IsBreak(1))  					{  						Skip();  						SkipLine();  						hasLeadingBlanks = true;  						break;  					}    					// Check for an escape sequence.    					else if (!isSingleQuoted && analyzer.Check('\\'))  					{  						int codeLength = 0;    						// Check the escape character.    						char escapeCharacter = analyzer.Peek(1);  						switch (escapeCharacter)  						{  							case 'x':  								codeLength = 2;  								break;    							case 'u':  								codeLength = 4;  								break;    							case 'U':  								codeLength = 8;  								break;    							default:  								char unescapedCharacter;  								if (simpleEscapeCodes.TryGetValue(escapeCharacter' out unescapedCharacter))  								{  									value.Append(unescapedCharacter);  								}  								else  								{  									throw new SyntaxErrorException(start' cursor.Mark()' "While parsing a quoted scalar' find unknown escape character.");  								}  								break;  						}    						Skip();  						Skip();    						// Consume an arbitrary escape code.    						if (codeLength > 0)  						{  							uint character = 0;    							// Scan the character value.    							for (int k = 0; k < codeLength; ++k)  							{  								if (!analyzer.IsHex(k))  								{  									throw new SyntaxErrorException(start' cursor.Mark()' "While parsing a quoted scalar' did not find expected hexdecimal number.");  								}  								character = (uint)((character << 4) + analyzer.AsHex(k));  							}    							// Check the value and write the character.    							if ((character >= 0xD800 && character <= 0xDFFF) || character > 0x10FFFF)  							{  								throw new SyntaxErrorException(start' cursor.Mark()' "While parsing a quoted scalar' find invalid Unicode character escape code.");  							}    							value.Append((char)character);    							// Advance the pointer.    							for (int k = 0; k < codeLength; ++k)  							{  								Skip();  							}  						}  					}  					else  					{  						// It is a non-escaped non-blank character.    						value.Append(ReadCurrentCharacter());  					}  				}    				// Check if we are at the end of the scalar.    				if (analyzer.Check(isSingleQuoted ? '\'' : '"'))  					break;    				// Consume blank characters.    				while (analyzer.IsWhite() || analyzer.IsBreak())  				{  					if (analyzer.IsWhite())  					{  						// Consume a space or a tab character.    						if (!hasLeadingBlanks)  						{  							whitespaces.Append(ReadCurrentCharacter());  						}  						else  						{  							Skip();  						}  					}  					else  					{  						// Check if it is a first line break.    						if (!hasLeadingBlanks)  						{  							whitespaces.Length = 0;  							leadingBreak.Append(ReadLine());  							hasLeadingBlanks = true;  						}  						else  						{  							trailingBreaks.Append(ReadLine());  						}  					}  				}    				// Join the whitespaces or fold line breaks.    				if (hasLeadingBlanks)  				{  					// Do we need to fold line breaks?    					if (StartsWith(leadingBreak' '\n'))  					{  						if (trailingBreaks.Length == 0)  						{  							value.Append(' ');  						}  						else  						{  							value.Append(trailingBreaks.ToString());  						}  					}  					else  					{  						value.Append(leadingBreak.ToString());  						value.Append(trailingBreaks.ToString());  					}  					leadingBreak.Length = 0;  					trailingBreaks.Length = 0;  				}  				else  				{  					value.Append(whitespaces.ToString());  					whitespaces.Length = 0;  				}  			}
Magic Number,YamlDotNet.Core,Scanner,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Scanner.cs,ScanUriEscapes,The following statement contains a magic number: do  			{  				// Check for a URI-escaped octet.    				if (!(analyzer.Check('%') && analyzer.IsHex(1) && analyzer.IsHex(2)))  				{  					throw new SyntaxErrorException(start' cursor.Mark()' "While parsing a tag' did not find URI escaped octet.");  				}    				// Get the octet.    				int octet = (analyzer.AsHex(1) << 4) + analyzer.AsHex(2);    				// If it is the leading octet' determine the length of the UTF-8 sequence.    				if (width == 0)  				{  					width = (octet & 0x80) == 0x00 ? 1 :  							(octet & 0xE0) == 0xC0 ? 2 :  							(octet & 0xF0) == 0xE0 ? 3 :  							(octet & 0xF8) == 0xF0 ? 4 : 0;    					if (width == 0)  					{  						throw new SyntaxErrorException(start' cursor.Mark()' "While parsing a tag' find an incorrect leading UTF-8 octet.");  					}  				}  				else  				{  					// Check if the trailing octet is correct.    					if ((octet & 0xC0) != 0x80)  					{  						throw new SyntaxErrorException(start' cursor.Mark()' "While parsing a tag' find an incorrect trailing UTF-8 octet.");  					}  				}    				// Copy the octet and move the pointers.    				charBytes.Add((byte)octet);    				Skip();  				Skip();  				Skip();  			}  			while (--width > 0);
Magic Number,YamlDotNet.Core,Scanner,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Scanner.cs,ScanUriEscapes,The following statement contains a magic number: do  			{  				// Check for a URI-escaped octet.    				if (!(analyzer.Check('%') && analyzer.IsHex(1) && analyzer.IsHex(2)))  				{  					throw new SyntaxErrorException(start' cursor.Mark()' "While parsing a tag' did not find URI escaped octet.");  				}    				// Get the octet.    				int octet = (analyzer.AsHex(1) << 4) + analyzer.AsHex(2);    				// If it is the leading octet' determine the length of the UTF-8 sequence.    				if (width == 0)  				{  					width = (octet & 0x80) == 0x00 ? 1 :  							(octet & 0xE0) == 0xC0 ? 2 :  							(octet & 0xF0) == 0xE0 ? 3 :  							(octet & 0xF8) == 0xF0 ? 4 : 0;    					if (width == 0)  					{  						throw new SyntaxErrorException(start' cursor.Mark()' "While parsing a tag' find an incorrect leading UTF-8 octet.");  					}  				}  				else  				{  					// Check if the trailing octet is correct.    					if ((octet & 0xC0) != 0x80)  					{  						throw new SyntaxErrorException(start' cursor.Mark()' "While parsing a tag' find an incorrect trailing UTF-8 octet.");  					}  				}    				// Copy the octet and move the pointers.    				charBytes.Add((byte)octet);    				Skip();  				Skip();  				Skip();  			}  			while (--width > 0);
Magic Number,YamlDotNet.Core,Scanner,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Scanner.cs,ScanUriEscapes,The following statement contains a magic number: do  			{  				// Check for a URI-escaped octet.    				if (!(analyzer.Check('%') && analyzer.IsHex(1) && analyzer.IsHex(2)))  				{  					throw new SyntaxErrorException(start' cursor.Mark()' "While parsing a tag' did not find URI escaped octet.");  				}    				// Get the octet.    				int octet = (analyzer.AsHex(1) << 4) + analyzer.AsHex(2);    				// If it is the leading octet' determine the length of the UTF-8 sequence.    				if (width == 0)  				{  					width = (octet & 0x80) == 0x00 ? 1 :  							(octet & 0xE0) == 0xC0 ? 2 :  							(octet & 0xF0) == 0xE0 ? 3 :  							(octet & 0xF8) == 0xF0 ? 4 : 0;    					if (width == 0)  					{  						throw new SyntaxErrorException(start' cursor.Mark()' "While parsing a tag' find an incorrect leading UTF-8 octet.");  					}  				}  				else  				{  					// Check if the trailing octet is correct.    					if ((octet & 0xC0) != 0x80)  					{  						throw new SyntaxErrorException(start' cursor.Mark()' "While parsing a tag' find an incorrect trailing UTF-8 octet.");  					}  				}    				// Copy the octet and move the pointers.    				charBytes.Add((byte)octet);    				Skip();  				Skip();  				Skip();  			}  			while (--width > 0);
Magic Number,YamlDotNet.Core,Scanner,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Scanner.cs,ScanUriEscapes,The following statement contains a magic number: do  			{  				// Check for a URI-escaped octet.    				if (!(analyzer.Check('%') && analyzer.IsHex(1) && analyzer.IsHex(2)))  				{  					throw new SyntaxErrorException(start' cursor.Mark()' "While parsing a tag' did not find URI escaped octet.");  				}    				// Get the octet.    				int octet = (analyzer.AsHex(1) << 4) + analyzer.AsHex(2);    				// If it is the leading octet' determine the length of the UTF-8 sequence.    				if (width == 0)  				{  					width = (octet & 0x80) == 0x00 ? 1 :  							(octet & 0xE0) == 0xC0 ? 2 :  							(octet & 0xF0) == 0xE0 ? 3 :  							(octet & 0xF8) == 0xF0 ? 4 : 0;    					if (width == 0)  					{  						throw new SyntaxErrorException(start' cursor.Mark()' "While parsing a tag' find an incorrect leading UTF-8 octet.");  					}  				}  				else  				{  					// Check if the trailing octet is correct.    					if ((octet & 0xC0) != 0x80)  					{  						throw new SyntaxErrorException(start' cursor.Mark()' "While parsing a tag' find an incorrect trailing UTF-8 octet.");  					}  				}    				// Copy the octet and move the pointers.    				charBytes.Add((byte)octet);    				Skip();  				Skip();  				Skip();  			}  			while (--width > 0);
Magic Number,YamlDotNet.Core,Scanner,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Scanner.cs,ScanUriEscapes,The following statement contains a magic number: do  			{  				// Check for a URI-escaped octet.    				if (!(analyzer.Check('%') && analyzer.IsHex(1) && analyzer.IsHex(2)))  				{  					throw new SyntaxErrorException(start' cursor.Mark()' "While parsing a tag' did not find URI escaped octet.");  				}    				// Get the octet.    				int octet = (analyzer.AsHex(1) << 4) + analyzer.AsHex(2);    				// If it is the leading octet' determine the length of the UTF-8 sequence.    				if (width == 0)  				{  					width = (octet & 0x80) == 0x00 ? 1 :  							(octet & 0xE0) == 0xC0 ? 2 :  							(octet & 0xF0) == 0xE0 ? 3 :  							(octet & 0xF8) == 0xF0 ? 4 : 0;    					if (width == 0)  					{  						throw new SyntaxErrorException(start' cursor.Mark()' "While parsing a tag' find an incorrect leading UTF-8 octet.");  					}  				}  				else  				{  					// Check if the trailing octet is correct.    					if ((octet & 0xC0) != 0x80)  					{  						throw new SyntaxErrorException(start' cursor.Mark()' "While parsing a tag' find an incorrect trailing UTF-8 octet.");  					}  				}    				// Copy the octet and move the pointers.    				charBytes.Add((byte)octet);    				Skip();  				Skip();  				Skip();  			}  			while (--width > 0);
Magic Number,YamlDotNet.Core,Scanner,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Scanner.cs,ScanUriEscapes,The following statement contains a magic number: do  			{  				// Check for a URI-escaped octet.    				if (!(analyzer.Check('%') && analyzer.IsHex(1) && analyzer.IsHex(2)))  				{  					throw new SyntaxErrorException(start' cursor.Mark()' "While parsing a tag' did not find URI escaped octet.");  				}    				// Get the octet.    				int octet = (analyzer.AsHex(1) << 4) + analyzer.AsHex(2);    				// If it is the leading octet' determine the length of the UTF-8 sequence.    				if (width == 0)  				{  					width = (octet & 0x80) == 0x00 ? 1 :  							(octet & 0xE0) == 0xC0 ? 2 :  							(octet & 0xF0) == 0xE0 ? 3 :  							(octet & 0xF8) == 0xF0 ? 4 : 0;    					if (width == 0)  					{  						throw new SyntaxErrorException(start' cursor.Mark()' "While parsing a tag' find an incorrect leading UTF-8 octet.");  					}  				}  				else  				{  					// Check if the trailing octet is correct.    					if ((octet & 0xC0) != 0x80)  					{  						throw new SyntaxErrorException(start' cursor.Mark()' "While parsing a tag' find an incorrect trailing UTF-8 octet.");  					}  				}    				// Copy the octet and move the pointers.    				charBytes.Add((byte)octet);    				Skip();  				Skip();  				Skip();  			}  			while (--width > 0);
Magic Number,YamlDotNet.Core,Scanner,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Scanner.cs,ScanVersionDirectiveNumber,The following statement contains a magic number: while (analyzer.IsDigit())  			{  				// Check if the number is too long.    				if (++length > MaxVersionNumberLength)  				{  					throw new SyntaxErrorException(start' cursor.Mark()' "While scanning a %YAML directive' find extremely long version number.");  				}    				value = value * 10 + analyzer.AsDigit();    				Skip();  			}
Magic Number,YamlDotNet.RepresentationModel,YamlMappingNode,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\RepresentationModel\YamlMappingNode.cs,ToString,The following statement contains a magic number: foreach (var child in children)  			{  				if (text.Length > 2)  				{  					text.Append("' ");  				}  				text.Append("{ ").Append(child.Key).Append("' ").Append(child.Value).Append(" }");  			}
Magic Number,YamlDotNet.RepresentationModel,YamlNode,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\RepresentationModel\YamlNode.cs,CombineHashCodes,The following statement contains a magic number: return unchecked(((h1 << 5) + h1) ^ h2);
Magic Number,YamlDotNet.RepresentationModel,YamlSequenceNode,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\RepresentationModel\YamlSequenceNode.cs,ToString,The following statement contains a magic number: foreach (var child in children)  			{  				if(text.Length > 2)  				{  					text.Append("' ");  				}  				text.Append(child);  			}
Magic Number,YamlDotNet.Serialization,Serializer,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Serialization\Serializer.cs,CreateTraversalStrategy,The following statement contains a magic number: if (IsOptionSet(SerializationOptions.Roundtrip))  			{  				return new RoundtripObjectGraphTraversalStrategy(this' typeDescriptor' typeResolver' 50);  			}  			else  			{  				return new FullObjectGraphTraversalStrategy(this' typeDescriptor' typeResolver' 50);  			}
Magic Number,YamlDotNet.Serialization,Serializer,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Serialization\Serializer.cs,CreateTraversalStrategy,The following statement contains a magic number: if (IsOptionSet(SerializationOptions.Roundtrip))  			{  				return new RoundtripObjectGraphTraversalStrategy(this' typeDescriptor' typeResolver' 50);  			}  			else  			{  				return new FullObjectGraphTraversalStrategy(this' typeDescriptor' typeResolver' 50);  			}
Missing Default,YamlDotNet.Core,Emitter,C:\repos\Rogueadyn_SaintCoinach\YamlDotNet\Core\Emitter.cs,NeedMoreEvents,The following switch statement is missing a default case: switch (evt.Type)  				{  					case EventType.DocumentStart:  					case EventType.SequenceStart:  					case EventType.MappingStart:  						++level;  						break;    					case EventType.DocumentEnd:  					case EventType.SequenceEnd:  					case EventType.MappingEnd:  						--level;  						break;  				}
