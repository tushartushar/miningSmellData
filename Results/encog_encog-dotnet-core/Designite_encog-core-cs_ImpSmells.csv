Implementation smell,Namespace,Class,File,Method,Description
Long Method,Encog.App.Analyst.Analyze,PerformAnalysis,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Analyze\PerformAnalysis.cs,Process,The method has 114 lines of code.
Long Method,Encog.App.Analyst.Report,AnalystReport,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Report\AnalystReport.cs,ProduceReport,The method has 118 lines of code.
Long Method,Encog.App.Analyst.Script,ScriptLoad,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Script\ScriptLoad.cs,ProcessSubSection,The method has 114 lines of code.
Long Method,Encog.App.Analyst.Wizard,AnalystWizard,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,DetermineTargetField,The method has 104 lines of code.
Long Method,Encog.App.Analyst.Wizard,AnalystWizard,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,GenerateBayesian,The method has 113 lines of code.
Long Method,Encog.MathUtil.LIBSVM,Solver,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,Solve,The method has 221 lines of code.
Long Method,Encog.MathUtil.LIBSVM,svm,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,sigmoid_train,The method has 110 lines of code.
Long Method,Encog.MathUtil.LIBSVM,svm,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_train,The method has 234 lines of code.
Long Method,Encog.MathUtil.LIBSVM,svm,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_load_model,The method has 134 lines of code.
Long Method,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Tred2,The method has 126 lines of code.
Long Method,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Tql2,The method has 115 lines of code.
Long Method,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The method has 472 lines of code.
Long Method,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The method has 473 lines of code.
Long Method,Encog.ML.Data.Market.Loader,CSVFormLoader,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The method has 178 lines of code.
Long Method,Encog.ML.Factory.Method,SVMFactory,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Factory\Method\SVMFactory.cs,Create,The method has 101 lines of code.
Long Method,Encog.ML.Prg,PersistPrgPopulation,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Prg\PersistPrgPopulation.cs,Read,The method has 146 lines of code.
Long Method,Encog.Neural.NEAT,PersistNEATPopulation,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The method has 142 lines of code.
Long Method,Encog.Neural.NEAT.Training.Opp,NEATCrossover,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\Training\Opp\NEATCrossover.cs,PerformOperation,The method has 111 lines of code.
Long Method,Encog.Neural.Networks.Training.NM,NelderMeadTraining,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\NM\NelderMeadTraining.cs,Iteration,The method has 297 lines of code.
Long Method,Encog.Neural.Networks.Training.PNN,DeriveMinimum,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\PNN\DeriveMinimum.cs,Calculate,The method has 172 lines of code.
Long Method,Encog.Neural.Networks.Training.PNN,GlobalMinimumSearch,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\PNN\GlobalMinimumSearch.cs,Brentmin,The method has 171 lines of code.
Long Method,Encog.Neural.Networks.Training.PNN,GlobalMinimumSearch,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\PNN\GlobalMinimumSearch.cs,FindBestRange,The method has 194 lines of code.
Long Method,Encog.Neural.Networks.Training.PNN,TrainBasicPNN,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\PNN\TrainBasicPNN.cs,CalculateError,The method has 127 lines of code.
Long Method,Encog.Neural.Networks.Training.PNN,TrainBasicPNN,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\PNN\TrainBasicPNN.cs,ComputeDeriv,The method has 209 lines of code.
Long Method,Encog.Neural.Networks.Training.Propagation.SCG,ScaledConjugateGradient,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\Propagation\SCG\ScaledConjugateGradient.cs,Iteration,The method has 128 lines of code.
Long Method,Encog.Neural.Rbf,PersistRBFNetwork,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\RBF\PersistRBFNetwork.cs,Read,The method has 119 lines of code.
Long Method,Encog.Neural.RBF.Training,SVD,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\RBF\Training\SVD.cs,Svdcmp,The method has 231 lines of code.
Long Method,Encog.Persist,EncogReadHelper,C:\repos\encog_encog-dotnet-core\encog-core-cs\Persist\EncogReadHelper.cs,ReadNextSection,The method has 100 lines of code.
Complex Method,Encog.App.Analyst.CSV,EvaluateRawCSV,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\CSV\EvaluateRawCSV.cs,AnalystPrepareOutputFile,Cyclomatic complexity of the method is 8
Complex Method,Encog.App.Analyst.CSV,AnalystEvaluateCSV,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\CSV\AnalystEvaluateCSV.cs,Process,Cyclomatic complexity of the method is 11
Complex Method,Encog.App.Analyst.CSV,AnalystEvaluateRawCSV,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\CSV\AnalystEvaluateRawCSV.cs,AnalystPrepareOutputFile,Cyclomatic complexity of the method is 9
Complex Method,Encog.App.Analyst.Analyze,AnalyzedField,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Analyze\AnalyzedField.cs,Analyze1,Cyclomatic complexity of the method is 8
Complex Method,Encog.App.Analyst.Analyze,PerformAnalysis,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Analyze\PerformAnalysis.cs,Process,Cyclomatic complexity of the method is 25
Complex Method,Encog.App.Analyst.CSV.Basic,BasicCachedFile,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\CSV\Basic\BasicCachedFile.cs,AttemptResolveName,Cyclomatic complexity of the method is 8
Complex Method,Encog.App.Analyst.Script,ScriptLoad,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Script\ScriptLoad.cs,HandleDataClasses,Cyclomatic complexity of the method is 10
Complex Method,Encog.App.Analyst.Wizard,AnalystWizard,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,DetermineTargetField,Cyclomatic complexity of the method is 15
Complex Method,Encog.App.Analyst.Wizard,AnalystWizard,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,ExpandTimeSlices,Cyclomatic complexity of the method is 12
Complex Method,Encog.App.Analyst.Wizard,AnalystWizard,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,GenerateBayesian,Cyclomatic complexity of the method is 11
Complex Method,Encog.App.Analyst.Wizard,AnalystWizard,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,GenerateFilenames,Cyclomatic complexity of the method is 8
Complex Method,Encog.App.Analyst.Wizard,AnalystWizard,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,GenerateTasks,Cyclomatic complexity of the method is 11
Complex Method,Encog.App.Generate,EncogCodeGeneration,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Generate\EncogCodeGeneration.cs,Generate,Cyclomatic complexity of the method is 8
Complex Method,Encog.App.Quant.Indicators,ProcessIndicators,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Quant\Indicators\ProcessIndicators.cs,WriteCSV,Cyclomatic complexity of the method is 9
Complex Method,Encog.App.Quant.Loader.OpenQuant,DataArray,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Quant\Loader\OpenQuant\BarSeries.cs,GetIndex,Cyclomatic complexity of the method is 8
Complex Method,Encog.Bot.Browse,Browser,C:\repos\encog_encog-dotnet-core\encog-core-cs\Bot\Browse\Browser.cs,Navigate,Cyclomatic complexity of the method is 8
Complex Method,Encog.Bot.Browse,LoadWebPage,C:\repos\encog_encog-dotnet-core\encog-core-cs\Bot\Browse\LoadWebPage.cs,LoadContents,Cyclomatic complexity of the method is 10
Complex Method,Encog.MathUtil,Equilateral,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Equilateral.cs,Equilat,Cyclomatic complexity of the method is 9
Complex Method,Encog.MathUtil.LIBSVM,Cache,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,swap_index,Cyclomatic complexity of the method is 10
Complex Method,Encog.MathUtil.LIBSVM,Solver,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,Solve,Cyclomatic complexity of the method is 29
Complex Method,Encog.MathUtil.LIBSVM,Solver,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,select_working_set,Cyclomatic complexity of the method is 8
Complex Method,Encog.MathUtil.LIBSVM,Solver,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,do_shrinking,Cyclomatic complexity of the method is 11
Complex Method,Encog.MathUtil.LIBSVM,Solver_NU,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,select_working_set,Cyclomatic complexity of the method is 9
Complex Method,Encog.MathUtil.LIBSVM,Solver_NU,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,do_shrinking,Cyclomatic complexity of the method is 17
Complex Method,Encog.MathUtil.LIBSVM,svm,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,sigmoid_train,Cyclomatic complexity of the method is 15
Complex Method,Encog.MathUtil.LIBSVM,svm,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,multiclass_probability,Cyclomatic complexity of the method is 13
Complex Method,Encog.MathUtil.LIBSVM,svm,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_binary_svc_probability,Cyclomatic complexity of the method is 10
Complex Method,Encog.MathUtil.LIBSVM,svm,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_cross_validation,Cyclomatic complexity of the method is 8
Complex Method,Encog.MathUtil.LIBSVM,svm,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_save_model,Cyclomatic complexity of the method is 16
Complex Method,Encog.MathUtil.LIBSVM,svm,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_load_model,Cyclomatic complexity of the method is 10
Complex Method,Encog.MathUtil.LIBSVM,svm,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_check_parameter,Cyclomatic complexity of the method is 23
Complex Method,Encog.MathUtil.Matrices.Decomposition,CholeskyDecomposition,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\CholeskyDecomposition.cs,Solve,Cyclomatic complexity of the method is 9
Complex Method,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Tred2,Cyclomatic complexity of the method is 14
Complex Method,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Tql2,Cyclomatic complexity of the method is 11
Complex Method,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Orthes,Cyclomatic complexity of the method is 20
Complex Method,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,Cyclomatic complexity of the method is 21
Complex Method,Encog.MathUtil.Matrices.Decomposition,LUDecomposition,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\LUDecomposition.cs,LUDecomposition,Cyclomatic complexity of the method is 12
Complex Method,Encog.MathUtil.Matrices.Decomposition,LUDecomposition,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\LUDecomposition.cs,Solve,Cyclomatic complexity of the method is 10
Complex Method,Encog.MathUtil.Matrices.Decomposition,LUDecomposition,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\LUDecomposition.cs,Solve,Cyclomatic complexity of the method is 9
Complex Method,Encog.MathUtil.Matrices.Decomposition,LUDecomposition,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\LUDecomposition.cs,Inverse,Cyclomatic complexity of the method is 10
Complex Method,Encog.MathUtil.Matrices.Decomposition,QRDecomposition,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\QRDecomposition.cs,QRDecomposition,Cyclomatic complexity of the method is 9
Complex Method,Encog.MathUtil.Matrices.Decomposition,QRDecomposition,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\QRDecomposition.cs,Solve,Cyclomatic complexity of the method is 11
Complex Method,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,Cyclomatic complexity of the method is 52
Complex Method,Encog.MathUtil.Randomize,RandomChoice,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\RandomChoice.cs,Generate,Cyclomatic complexity of the method is 9
Complex Method,Encog.ML.Bayesian,BayesianNetwork,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Bayesian\BayesianNetwork.cs,IsCondIndependent,Cyclomatic complexity of the method is 9
Complex Method,Encog.ML.Bayesian,PersistBayes,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Bayesian\PersistBayes.cs,Read,Cyclomatic complexity of the method is 10
Complex Method,Encog.ML.Bayesian,PersistBayes,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Bayesian\PersistBayes.cs,Save,Cyclomatic complexity of the method is 12
Complex Method,Encog.ML.Bayesian.Parse,ParseProbability,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Bayesian\Parse\ParseProbability.cs,AddEvents,Cyclomatic complexity of the method is 14
Complex Method,Encog.ML.Data.Versatile,VersatileMLDataSet,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Versatile\VersatileMLDataSet.cs,Analyze,Cyclomatic complexity of the method is 10
Complex Method,Encog.ML.EA.Species,ThresholdSpeciation,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\EA\Species\ThresholdSpeciation.cs,SpeciateAndCalculateSpawnLevels,Cyclomatic complexity of the method is 10
Complex Method,Encog.ML.EA.Train,BasicEA,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\EA\Train\BasicEA.cs,Iteration,Cyclomatic complexity of the method is 12
Complex Method,Encog.ML.HMM.Alog,ViterbiCalculator,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\HMM\Alog\ViterbiCalculator.cs,ViterbiCalculator,Cyclomatic complexity of the method is 8
Complex Method,Encog.ML.HMM.Distributions,ContinousDistribution,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\HMM\Distributions\ContinousDistribution.cs,Fit,Cyclomatic complexity of the method is 8
Complex Method,Encog.ML.HMM.Train.BW,BaseBaumWelch,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\HMM\Train\BW\BaseBaumWelch.cs,Iteration,Cyclomatic complexity of the method is 16
Complex Method,Encog.ML.HMM.Train.KMeans,TrainKMeans,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\HMM\Train\KMeans\TrainKMeans.cs,LearnTransition,Cyclomatic complexity of the method is 10
Complex Method,Encog.Neural.CPN,CPNNetwork,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\CPN\CPN.cs,ComputeInstar,Cyclomatic complexity of the method is 8
Complex Method,Encog.Neural.Freeform,FreeformNetwork,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Freeform\FreeformNetwork.cs,FreeformNetwork,Cyclomatic complexity of the method is 8
Complex Method,Encog.Neural.HyperNEAT,HyperNEATCODEC,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\HyperNEAT\HyperNEATCODEC.cs,Decode,Cyclomatic complexity of the method is 10
Complex Method,Encog.Neural.NEAT.Training.Opp,NEATCrossover,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\Training\Opp\NEATCrossover.cs,PerformOperation,Cyclomatic complexity of the method is 9
Complex Method,Encog.Neural.Networks.Structure,AnalyzeNetwork,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Structure\AnalyzeNetwork.cs,AnalyzeNetwork,Cyclomatic complexity of the method is 10
Complex Method,Encog.Neural.Networks.Training.NM,NelderMeadTraining,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\NM\NelderMeadTraining.cs,Iteration,Cyclomatic complexity of the method is 27
Complex Method,Encog.Neural.Networks.Training.PNN,DeriveMinimum,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\PNN\DeriveMinimum.cs,Calculate,Cyclomatic complexity of the method is 27
Complex Method,Encog.Neural.Networks.Training.PNN,GlobalMinimumSearch,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\PNN\GlobalMinimumSearch.cs,Brentmin,Cyclomatic complexity of the method is 14
Complex Method,Encog.Neural.Networks.Training.PNN,GlobalMinimumSearch,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\PNN\GlobalMinimumSearch.cs,FindBestRange,Cyclomatic complexity of the method is 14
Complex Method,Encog.Neural.Networks.Training.PNN,TrainBasicPNN,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\PNN\TrainBasicPNN.cs,CalculateError,Cyclomatic complexity of the method is 13
Complex Method,Encog.Neural.Networks.Training.PNN,TrainBasicPNN,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\PNN\TrainBasicPNN.cs,ComputeDeriv,Cyclomatic complexity of the method is 25
Complex Method,Encog.Neural.Networks.Training.Propagation.SCG,ScaledConjugateGradient,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\Propagation\SCG\ScaledConjugateGradient.cs,Iteration,Cyclomatic complexity of the method is 13
Complex Method,Encog.Neural.PNN,BasicPNN,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\PNN\BasicPNN.cs,Compute,Cyclomatic complexity of the method is 12
Complex Method,Encog.Neural.Pnn,PersistBasicPNN,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\PNN\PersistBasicPNN.cs,Read,Cyclomatic complexity of the method is 9
Complex Method,Encog.Neural.Prune,PruneIncremental,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Prune\PruneIncremental.cs,PerformJobUnit,Cyclomatic complexity of the method is 10
Complex Method,Encog.Neural.Prune,PruneIncremental,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Prune\PruneIncremental.cs,UpdateBest,Cyclomatic complexity of the method is 8
Complex Method,Encog.Neural.Prune,PruneSelective,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Prune\PruneSelective.cs,IncreaseNeuronCount,Cyclomatic complexity of the method is 10
Complex Method,Encog.Neural.Prune,PruneSelective,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Prune\PruneSelective.cs,Prune,Cyclomatic complexity of the method is 9
Complex Method,Encog.Neural.RBF.Training,SVD,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\RBF\Training\SVD.cs,Svdfit,Cyclomatic complexity of the method is 10
Complex Method,Encog.Neural.RBF.Training,SVD,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\RBF\Training\SVD.cs,Svdcmp,Cyclomatic complexity of the method is 51
Complex Method,Encog.Parse.Expression.Common,ParseCommonExpression,C:\repos\encog_encog-dotnet-core\encog-core-cs\Parse\Expression\Common\ParseCommonExpression.cs,HandleNumeric,Cyclomatic complexity of the method is 11
Complex Method,Encog.Parse.Expression.EPL,ParseEPL,C:\repos\encog_encog-dotnet-core\encog-core-cs\Parse\Expression\EPL\ParseEPL.cs,Parse,Cyclomatic complexity of the method is 9
Complex Method,Encog.ML.SVM.Training,SVMSearchTrain,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\SVM\Training\SVMSearchTrain.cs,Iteration,Cyclomatic complexity of the method is 8
Complex Method,Encog.Plugin.SystemPlugin,SystemActivationPlugin,C:\repos\encog_encog-dotnet-core\encog-core-cs\Plugin\SystemPlugin\SystemActivationPlugin.cs,AllocateAF,Cyclomatic complexity of the method is 13
Complex Method,Encog.Plugin.SystemPlugin,SystemMethodsPlugin,C:\repos\encog_encog-dotnet-core\encog-core-cs\Plugin\SystemPlugin\SystemMethodsPlugin.cs,CreateMethod,Cyclomatic complexity of the method is 9
Complex Method,Encog.Util.KMeans,KMeansUtil<TK>,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\KMeans\KMeansUtil.cs,InitRandomClusters,Cyclomatic complexity of the method is 8
Complex Method,Encog.Util.Normalize,DataNormalization,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Normalize\DataNormalization.cs,BuildForNetworkInput,Cyclomatic complexity of the method is 10
Complex Method,Encog.Parse.Tags.Read,ReadTags,C:\repos\encog_encog-dotnet-core\encog-core-cs\Parse\Tags\Read\ReadTags.cs,ParseTag,Cyclomatic complexity of the method is 15
Complex Method,Encog.Parse.Tags.Read,ReadTags,C:\repos\encog_encog-dotnet-core\encog-core-cs\Parse\Tags\Read\ReadTags.cs,PeekEndTag,Cyclomatic complexity of the method is 8
Complex Method,Encog.Util.DownSample,RGBDownsample,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\DownSample\RGBDownsample.cs,FindBounds,Cyclomatic complexity of the method is 9
Complex Method,Encog.Util.HTTP,URLUtility,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\HTTP\URLUtility.cs,ConvertFilename,Cyclomatic complexity of the method is 8
Long Parameter List,Encog.App.Analyst.CSV.Normalize,AnalystNormalizeCSV,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\CSV\Normalize\AnalystNormalizeCSV.cs,ExtractFields,The method has 5 parameters. Parameters: analyst' headers' csv' outputLength' skipOutput
Long Parameter List,Encog.App.Analyst.Script.Normalize,AnalystField,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Script\Normalize\AnalystField.cs,AnalystField,The method has 6 parameters. Parameters: theAction' theName' ahigh' alow' nhigh' nlow
Long Parameter List,Encog.App.Analyst.Script.Normalize,AnalystField,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Script\Normalize\AnalystField.cs,MakeClass,The method has 5 parameters. Parameters: theAction' classFrom' classTo' high' low
Long Parameter List,Encog.App.Analyst.Wizard,AnalystWizard,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,Wizard,The method has 5 parameters. Parameters: url' saveFile' analyzeFile' b' format
Long Parameter List,Encog.App.Analyst.Wizard,AnalystWizard,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,WizardRealTime,The method has 6 parameters. Parameters: sourceData' csvFile' backwardWindow' forwardWindow' prediction' predictField
Long Parameter List,Encog.App.Quant.Loader.OpenQuant.Data,Bar,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Quant\Loader\OpenQuant\Bar.cs,Bar,The method has 10 parameters. Parameters: barType' size' beginTime' endTime' open' high' low' close' volume' openInt
Long Parameter List,Encog.App.Quant.Loader.OpenQuant.Data,Bar,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Quant\Loader\OpenQuant\Bar.cs,Bar,The method has 5 parameters. Parameters: size' open' high' low' close
Long Parameter List,Encog.App.Quant.Loader.OpenQuant,OpenQuantLoader,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Quant\Loader\OpenQuant\OpenQuantLoader.cs,OpenquantDataLoader,The method has 5 parameters. Parameters: instrument' dtfrom' dtto' bartype' barsize
Long Parameter List,Encog.App.Quant.Loader.OpenQuant,LoaderTypes,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Quant\Loader\OpenQuant\OpenQuantLoader.cs,LoaderTypes,The method has 5 parameters. Parameters: instrument' StartingDate' ToDate' Type' SizeOfBars
Long Parameter List,Encog.App.Quant.Loader.Yahoo,YahooDownload,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Quant\Loader\Yahoo\YahooDownload.cs,LoadAllData,The method has 5 parameters. Parameters: ticker' output' outputFormat' from' to
Long Parameter List,Encog.Bot,BotUtil,C:\repos\encog_encog-dotnet-core\encog-core-cs\Bot\BotUtil.cs,ExtractFromIndex,The method has 5 parameters. Parameters: str' token1' token2' index' occurence
Long Parameter List,Encog.MathUtil.LIBSVM,Solver,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,Solve,The method has 10 parameters. Parameters: l' Q' b_' y_' alpha_' Cp' Cn' eps' si' shrinking
Long Parameter List,Encog.MathUtil.LIBSVM,Solver_NU,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,Solve,The method has 10 parameters. Parameters: l' Q' b' y' alpha' Cp' Cn' eps' si' shrinking
Long Parameter List,Encog.MathUtil.LIBSVM,svm,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,solve_c_svc,The method has 6 parameters. Parameters: prob' param' alpha' si' Cp' Cn
Long Parameter List,Encog.MathUtil.LIBSVM,svm,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_binary_svc_probability,The method has 5 parameters. Parameters: prob' param' Cp' Cn' probAB
Long Parameter List,Encog.MathUtil.Matrices,Matrix,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Matrix.cs,SetMatrix,The method has 5 parameters. Parameters: i0' i1' j0' j1' x
Long Parameter List,Encog.MathUtil.Matrices.Hessian,HessianFD,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Hessian\HessianFD.cs,ComputeDerivative,The method has 6 parameters. Parameters: inputData' outputNeuron' weight' stepSize' networkOutput' row
Long Parameter List,Encog.ML.Bayesian,BayesianNetwork,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Bayesian\BayesianNetwork.cs,IsCondIndependent,The method has 5 parameters. Parameters: previousHead' a' goal' searched' given
Long Parameter List,Encog.ML.Bayesian.Training,TrainBayesian,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Bayesian\Training\TrainBayesian.cs,TrainBayesian,The method has 6 parameters. Parameters: theNetwork' theData' theMaximumParents' theInit' theSearch' theEstimator
Long Parameter List,Encog.ML.Bayesian.Training.Search.k2,SearchK2,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Bayesian\Training\Search\k2\SearchK2.cs,CalculateN,The method has 5 parameters. Parameters: network' e' parents' parentInstance' desiredValue
Long Parameter List,Encog.ML.Data.Buffer.CODEC,CSVDataCODEC,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Buffer\CODEC\CSVDataCODEC.cs,CSVDataCODEC,The method has 6 parameters. Parameters: file' format' headers' inputCount' idealCount' significance
Long Parameter List,Encog.ML.Data.Dynamic,SlidingWindowMLDataProvider,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Dynamic\Providers\SlidingWindowMLDataProvider.cs,SlidingWindowMLDataProvider,The method has 5 parameters. Parameters: list' windowSize' windowOffset' stepSize' gap
Long Parameter List,Encog.ML.Data.Image,ImageMLData,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Image\ImageMLData.cs,Downsample,The method has 6 parameters. Parameters: downsampler' findBounds' height' width' hi' lo
Long Parameter List,Encog.ML.Data.Market.Loader,CSVFinal,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFinal.cs,ReadAndCallLoader,The method has 5 parameters. Parameters: symbol' neededTypes' from' to' File
Long Parameter List,Encog.ML.Data.Market.Loader,CSVLoader,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVLoader.cs,ReadAndCallLoader,The method has 5 parameters. Parameters: symbol' neededTypes' from' to' File
Long Parameter List,Encog.ML.Data.Market,MarketDataDescription,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\MarketDataDescription.cs,MarketDataDescription,The method has 6 parameters. Parameters: ticker' dataType' type' activationFunction' input' predict
Long Parameter List,Encog.ML.Data.Market,MarketDataDescription,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\MarketDataDescription.cs,MarketDataDescription,The method has 5 parameters. Parameters: ticker' dataType' type' input' predict
Long Parameter List,Encog.ML.Data.Specific,CSVMLDataSet,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Specific\CSVMLDataSet.cs,CSVMLDataSet,The method has 6 parameters. Parameters: filename' inputSize' idealSize' headers' format' expectSignificance
Long Parameter List,Encog.ML.Data.Temporal,TemporalDataDescription,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Temporal\TemporalDataDescription.cs,TemporalDataDescription,The method has 6 parameters. Parameters: activationFunction' low' high' type' input' predict
Long Parameter List,Encog.ML.Data.Versatile,NormalizationHelper,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Versatile\NormalizationHelper.cs,NormalizeToVector,The method has 5 parameters. Parameters: colDef' outputColumn' output' isInput' value
Long Parameter List,Encog.ML.Data.Versatile.Normalizers.Strategy,BasicNormalizationStrategy,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Versatile\Normalizers\Strategy\BasicNormalizationStrategy.cs,NormalizeColumn,The method has 5 parameters. Parameters: colDef' isInput' value' outputData' outputColumn
Long Parameter List,Encog.ML.Data.Versatile.Normalizers.Strategy,BasicNormalizationStrategy,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Versatile\Normalizers\Strategy\BasicNormalizationStrategy.cs,NormalizeColumn,The method has 5 parameters. Parameters: colDef' isInput' value' outputData' outputColumn
Long Parameter List,Encog.ML.Data.Versatile.Normalizers.Strategy,INormalizationStrategy,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Versatile\Normalizers\Strategy\INormalizationStrategy.cs,NormalizeColumn,The method has 5 parameters. Parameters: colDef' isInput' value' outpuData' outputColumn
Long Parameter List,Encog.ML.Data.Versatile.Normalizers.Strategy,INormalizationStrategy,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Versatile\Normalizers\Strategy\INormalizationStrategy.cs,NormalizeColumn,The method has 5 parameters. Parameters: colDef' isInput' value' outpuData' outputColumn
Long Parameter List,Encog.ML.EA.Opp,CompoundOperator,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\EA\Opp\CompoundOperator.cs,PerformOperation,The method has 5 parameters. Parameters: rnd' parents' parentIndex' offspring' offspringIndex
Long Parameter List,Encog.ML.EA.Opp,IEvolutionaryOperator,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\EA\Opp\IEvolutionaryOperator.cs,PerformOperation,The method has 5 parameters. Parameters: rnd' parents' parentIndex' offspring' offspringIndex
Long Parameter List,Encog.ML.EA.Score.Multi,ParallelScore,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\EA\Score\Multi\ParallelScore.cs,ParallelScore,The method has 5 parameters. Parameters: thePopulation' theCODEC' theAdjusters' theScoreFunction' theThreadCount
Long Parameter List,Encog.ML.Genetic.Crossover,Splice,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Genetic\Crossover\Splice.cs,PerformOperation,The method has 5 parameters. Parameters: rnd' parents' parentIndex' offspring' offspringIndex
Long Parameter List,Encog.ML.Genetic.Crossover,SpliceNoRepeat,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Genetic\Crossover\SpliceNoRepeat.cs,PerformOperation,The method has 5 parameters. Parameters: rnd' parents' parentIndex' offspring' offspringIndex
Long Parameter List,Encog.ML.Genetic.Mutate,MutatePerturb,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Genetic\Mutate\MutatePerturb.cs,PerformOperation,The method has 5 parameters. Parameters: rnd' parents' parentIndex' offspring' offspringIndex
Long Parameter List,Encog.ML.Genetic.Mutate,MutateShuffle,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Genetic\Mutate\MutateShuffle.cs,PerformOperation,The method has 5 parameters. Parameters: rnd' parents' parentIndex' offspring' offspringIndex
Long Parameter List,Encog.ML.Model,EncogModel,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Model\EncogModel.cs,SelectMethod,The method has 5 parameters. Parameters: dataset' methodType' methodArgs' trainingType' trainingArgs
Long Parameter List,Encog.ML.Prg.Ext,BasicTemplate,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Prg\Ext\BasicTemplate.cs,BasicTemplate,The method has 8 parameters. Parameters: thePrecedence' theSignature' theType' isVariable' theDataSize' theEvaluate' theIsPossibleReturnType' theRandomize
Long Parameter List,Encog.ML.Prg.Ext,BasicTemplate,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Prg\Ext\BasicTemplate.cs,Randomize,The method has 5 parameters. Parameters: rnd' desiredType' actual' minValue' maxValue
Long Parameter List,Encog.ML.Prg.Ext,IProgramExtensionTemplate,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Prg\Ext\IProgramExtensionTemplate.cs,Randomize,The method has 5 parameters. Parameters: rnd' desiredType' actual' minValue' maxValue
Long Parameter List,Encog.ML.Prg.Generator,AbstractPrgGenerator,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Prg\Generator\AbstractPrgGenerator.cs,CreateRandomNode,The method has 6 parameters. Parameters: rnd' program' depthRemaining' types' includeTerminal' includeFunction
Long Parameter List,Encog.ML.Prg.Opp,ConstMutation,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Prg\Opp\ConstMutation.cs,PerformOperation,The method has 5 parameters. Parameters: rnd' parents' parentIndex' offspring' offspringIndex
Long Parameter List,Encog.ML.Prg.Opp,SubtreeCrossover,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Prg\Opp\SubtreeCrossover.cs,PerformOperation,The method has 5 parameters. Parameters: rnd' parents' parentIndex' offspring' offspringIndex
Long Parameter List,Encog.ML.Prg.Opp,SubtreeMutation,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Prg\Opp\SubtreeMutation.cs,PerformOperation,The method has 5 parameters. Parameters: rnd' parents' parentIndex' offspring' offspringIndex
Long Parameter List,Encog.ML.Prg.Opp,SubtreeMutation,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Prg\Opp\SubtreeMutation.cs,FindNode,The method has 5 parameters. Parameters: rnd' result' parentNode' types' globalIndex
Long Parameter List,Encog.ML.Train.Strategy,EarlyStoppingStrategy,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Train\Strategy\EarlyStoppingStrategy.cs,EarlyStoppingStrategy,The method has 5 parameters. Parameters: theValidationSet' theTestSet' theStripLength' theAlpha' theMinEfficiency
Long Parameter List,Encog.Neural.Error,ATanErrorFunction,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Error\ATanErrorFunction.cs,CalculateError,The method has 8 parameters. Parameters: af' b' a' ideal' actual' error' derivShift' significance
Long Parameter List,Encog.Neural.Error,CrossEntropyErrorFunction,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Error\CrossEntropyErrorFunction.cs,CalculateError,The method has 8 parameters. Parameters: af' b' a' ideal' actual' error' derivShift' significance
Long Parameter List,Encog.Neural.Error,IErrorFunction,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Error\IErrorFunction.cs,CalculateError,The method has 8 parameters. Parameters: af' b' a' ideal' actual' error' derivShift' significance
Long Parameter List,Encog.Neural.Error,LinearErrorFunction,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Error\LinearErrorFunction.cs,CalculateError,The method has 8 parameters. Parameters: af' b' a' ideal' actual' error' derivShift' significance
Long Parameter List,Encog.Neural.Error,OutputErrorFunction,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Error\OutputErrorFunction.cs,CalculateError,The method has 8 parameters. Parameters: af' b' a' ideal' actual' error' derivShift' significance
Long Parameter List,Encog.Neural.Flat,FlatNetwork,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Flat\FlatNetwork.cs,FlatNetwork,The method has 5 parameters. Parameters: input' hidden1' hidden2' output' tanh
Long Parameter List,Encog.Neural.Freeform,FreeformNetwork,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Freeform\FreeformNetwork.cs,CreateFeedforward,The method has 5 parameters. Parameters: input' hidden1' hidden2' output' af
Long Parameter List,Encog.Neural.Freeform,FreeformNetwork,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Freeform\FreeformNetwork.cs,ConnectLayers,The method has 5 parameters. Parameters: source' target' theActivationFunction' biasActivation' isRecurrent
Long Parameter List,Encog.Neural.HyperNEAT,FactorHyperNEATGenome,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\HyperNEAT\FactorHyperNEATGenome.cs,Factor,The method has 5 parameters. Parameters: rnd' pop' inputCount' outputCount' connectionDensity
Long Parameter List,Encog.Neural.HyperNEAT,HyperNEATGenome,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\HyperNEAT\HyperNEATGenome.cs,HyperNEATGenome,The method has 5 parameters. Parameters: rnd' pop' inputCount' outputCount' connectionDensity
Long Parameter List,Encog.Neural.NEAT,FactorNEATGenome,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\FactorNEATGenome.cs,Factor,The method has 5 parameters. Parameters: rnd' pop' inputCount' outputCount' connectionDensity
Long Parameter List,Encog.Neural.NEAT,INEATGenomeFactory,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\INEATGenomeFactory.cs,Factor,The method has 5 parameters. Parameters: rnd' pop' inputCount' outputCount' connectionDensity
Long Parameter List,Encog.Neural.NEAT.Training,NEATGenome,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\Training\NEATGenome.cs,NEATGenome,The method has 5 parameters. Parameters: rnd' pop' inputCount' outputCount' connectionDensity
Long Parameter List,Encog.Neural.NEAT.Training,NEATLinkGene,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\Training\NEATLinkGene.cs,NEATLinkGene,The method has 5 parameters. Parameters: fromNeuronId' toNeuronId' enabled' innovationId' weight
Long Parameter List,Encog.Neural.NEAT.Training.Opp,NEATCrossover,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\Training\Opp\NEATCrossover.cs,PerformOperation,The method has 5 parameters. Parameters: rnd' parents' parentIndex' offspring' offspringIndex
Long Parameter List,Encog.Neural.NEAT.Training.Opp,NEATMutateAddLink,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\Training\Opp\NEATMutateAddLink.cs,PerformOperation,The method has 5 parameters. Parameters: rnd' parents' parentIndex' offspring' offspringIndex
Long Parameter List,Encog.Neural.NEAT.Training.Opp,NEATMutateAddNode,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\Training\Opp\NEATMutateAddNode.cs,PerformOperation,The method has 5 parameters. Parameters: rnd' parents' parentIndex' offspring' offspringIndex
Long Parameter List,Encog.Neural.NEAT.Training.Opp,NEATMutateRemoveLink,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\Training\Opp\NEATMutateRemoveLink.cs,PerformOperation,The method has 5 parameters. Parameters: rnd' parents' parentIndex' offspring' offspringIndex
Long Parameter List,Encog.Neural.NEAT.Training.Opp,NEATMutateWeights,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\Training\Opp\NEATMutateWeights.cs,PerformOperation,The method has 5 parameters. Parameters: rnd' parents' parentIndex' offspring' offspringIndex
Long Parameter List,Encog.Neural.NEAT.Training.Opp,NEATMutation,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\Training\Opp\NEATMutation.cs,PerformOperation,The method has 5 parameters. Parameters: rnd' parents' parentIndex' offspring' offspringIndex
Long Parameter List,Encog.Neural.Networks.Training.Anneal,NeuralSimulatedAnnealing,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\Anneal\NeuralSimulatedAnnealing.cs,NeuralSimulatedAnnealing,The method has 5 parameters. Parameters: network' calculateScore' startTemp' stopTemp' cycles
Long Parameter List,Encog.Neural.Networks.Training.PNN,DeriveMinimum,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\PNN\DeriveMinimum.cs,Calculate,The method has 13 parameters. Parameters: maxIterations' maxError' eps' tol' network' n' x' ystart' bs' direc' g' h' deriv2
Long Parameter List,Encog.Neural.Networks.Training.PNN,DeriveMinimum,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\PNN\DeriveMinimum.cs,FindNewDir,The method has 5 parameters. Parameters: n' gam' g' h' grad
Long Parameter List,Encog.Neural.Networks.Training.PNN,GlobalMinimumSearch,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\PNN\GlobalMinimumSearch.cs,Brentmin,The method has 6 parameters. Parameters: maxIterations' maxError' eps' tol' network' y
Long Parameter List,Encog.Neural.Networks.Training.PNN,GlobalMinimumSearch,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\PNN\GlobalMinimumSearch.cs,FindBestRange,The method has 6 parameters. Parameters: low' high' numberOfPoints' useLog' minError' network
Long Parameter List,Encog.Neural.Networks.Training.Propagation,GradientWorker,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\Propagation\GradientWorker.cs,GradientWorker,The method has 7 parameters. Parameters: theNetwork' theOwner' theTraining' theLow' theHigh' theFlatSpots' ef
Long Parameter List,Encog.Neural.Prune,PruneIncremental,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Prune\PruneIncremental.cs,PruneIncremental,The method has 6 parameters. Parameters: training' pattern' iterations' weightTries' numTopResults' report
Long Parameter List,Encog.Neural.Prune,PruneSelective,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Prune\PruneSelective.cs,RandomizeNeuron,The method has 7 parameters. Parameters: targetLayer' neuron' useRange' low' high' usePercent' percent
Long Parameter List,Encog.Neural.RBF,RBFNetwork,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\RBF\RBFNetwork.cs,SetRBFCentersAndWidthsEqualSpacing,The method has 5 parameters. Parameters: minPosition' maxPosition' t' volumeNeuronRBFWidth' useWideEdgeRBFs
Long Parameter List,Encog.Neural.RBF.Training,SVD,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\RBF\Training\SVD.cs,Svdbksb,The method has 5 parameters. Parameters: u' w' v' b' x
Long Parameter List,Encog.Neural.SOM.Training.Neighborhood,BasicTrainSOM,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\SOM\Training\Neighborhood\BasicTrainSOM.cs,SetAutoDecay,The method has 5 parameters. Parameters: plannedIterations' startRate' endRate' startRadius' endRadius
Long Parameter List,Encog.Plugin.SystemPlugin,SystemLoggingPlugin,C:\repos\encog_encog-dotnet-core\encog-core-cs\Plugin\SystemPlugin\SystemLoggingPlugin.cs,CalculateGradient,The method has 10 parameters. Parameters: gradients' layerOutput' weights' layerDelta' af' index' fromLayerIndex' fromLayerSize' toLayerIndex' toLayerSize
Long Parameter List,Encog.Plugin.SystemPlugin,SystemLoggingPlugin,C:\repos\encog_encog-dotnet-core\encog-core-cs\Plugin\SystemPlugin\SystemLoggingPlugin.cs,CalculateLayer,The method has 7 parameters. Parameters: weights' layerOutput' startIndex' outputIndex' outputSize' inputIndex' inputSize
Long Parameter List,Encog.Util.Arrayutil,NormalizedField,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Arrayutil\NormalizedField.cs,NormalizedField,The method has 6 parameters. Parameters: theAction' theName' ahigh' alow' nhigh' nlow
Long Parameter List,Encog.Util.Arrayutil,NormalizedField,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Arrayutil\NormalizedField.cs,MakeClass,The method has 5 parameters. Parameters: theAction' classFrom' classTo' high' low
Long Parameter List,Encog.Util.Banchmark,EncoderTrainingFactory,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Banchmark\EncoderTrainingFactory.cs,GenerateTraining,The method has 6 parameters. Parameters: inputCount' compl' inputMin' inputMax' outputMin' outputMax
Long Parameter List,Encog.Util.Banchmark,RandomTrainingFactory,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Banchmark\RandomTrainingFactory.cs,Generate,The method has 6 parameters. Parameters: seed' count' inputCount' idealCount' min' max
Long Parameter List,Encog.Util.Banchmark,RandomTrainingFactory,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Banchmark\RandomTrainingFactory.cs,Generate,The method has 5 parameters. Parameters: training' seed' count' min' max
Long Parameter List,Encog.Util,EngineArray,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\EngineArray.cs,ArrayCopy,The method has 5 parameters. Parameters: source' sourceIndex' output' targetIndex' size
Long Parameter List,Encog.Util,EngineArray,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\EngineArray.cs,ArrayCopy,The method has 5 parameters. Parameters: source' sourcePos' target' targetPos' length
Long Parameter List,Encog.Util,EngineArray,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\EngineArray.cs,ArrayCopy,The method has 5 parameters. Parameters: source' sourcePos' target' targetPos' length
Long Parameter List,Encog.Util.Normalize.Output,BasicOutputField,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Normalize\Output\BasicOutputField.cs,Calculate,The method has 5 parameters. Parameters: value' min' max' hi' lo
Long Parameter List,Encog.Util.Simple,TrainingSetUtil,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\TrainingSetUtil.cs,LoadCSVTOMemory,The method has 5 parameters. Parameters: format' filename' headers' inputSize' idealSize
Long Parameter List,Encog.Util.Simple,EncogUtility,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\EncogUtility.cs,ConvertCSV2Binary,The method has 7 parameters. Parameters: csvFile' format' binFile' inputCount' outputCount' headers' expectSignificance
Long Parameter List,Encog.Util.Simple,EncogUtility,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\EncogUtility.cs,ConvertCSV2Binary,The method has 6 parameters. Parameters: csvFile' format' binFile' input' ideal' headers
Long Parameter List,Encog.Util.Simple,EncogUtility,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\EncogUtility.cs,LoadCSV2Memory,The method has 6 parameters. Parameters: filename' input' ideal' headers' format' expectSignificance
Long Parameter List,Encog.Util.Simple,EncogUtility,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\EncogUtility.cs,SimpleFeedForward,The method has 5 parameters. Parameters: input' hidden1' hidden2' output' tanh
Long Identifier,Encog.ML.EA.Score.Adjust,ComplexityAdjustedScore,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\EA\Score\Adjust\ComplexityAdjustedScore.cs,ComplexityAdjustedScore,The length of the parameter theComplexityPentaltyFullThreshold is 34.
Long Identifier,Encog.ML.Factory,MLTrainFactory,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Factory\MLTrainFactory.cs,,The length of the parameter PropertyBayesianRegularization is 30.
Long Statement,Encog.App.Generate.Generators.JS,GenerateEncogJavaScript,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Generate\Generators\JS\GenerateEncogJavaScript.cs,GenerateClass,The length of the statement  "                "<noscript>Your browser does not support JavaScript! Note: if you are trying to view this in Encog Workbench' right-click file and choose \"Open as Text\".</noscript>"); " is 169.
Long Statement,Encog.MathUtil.LIBSVM,SVC_Q,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,get_Q,The length of the statement  "                    //UPGRADE_WARNING: Data types in Visual C# might be different.  Verify the accuracy of narrowing conversions. 'ms-help://MS.VSCC.2003/commoner/redir/redirect.htm?keyword="jlca1042_3"' " is 183.
Long Statement,Encog.MathUtil.LIBSVM,ONE_CLASS_Q,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,get_Q,The length of the statement  "                    //UPGRADE_WARNING: Data types in Visual C# might be different.  Verify the accuracy of narrowing conversions. 'ms-help://MS.VSCC.2003/commoner/redir/redirect.htm?keyword="jlca1042_3"' " is 183.
Long Statement,Encog.MathUtil.LIBSVM,SVR_Q,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,get_Q,The length of the statement  "                    //UPGRADE_WARNING: Data types in Visual C# might be different.  Verify the accuracy of narrowing conversions. 'ms-help://MS.VSCC.2003/commoner/redir/redirect.htm?keyword="jlca1042_3"' " is 183.
Long Statement,Encog.MathUtil.LIBSVM,svm,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,solve_one_class,The length of the statement  "            //UPGRADE_WARNING: Data types in Visual C# might be different.  Verify the accuracy of narrowing conversions. 'ms-help://MS.VSCC.2003/commoner/redir/redirect.htm?keyword="jlca1042_3"' " is 183.
Long Statement,Encog.MathUtil.LIBSVM,svm,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_binary_svc_probability,The length of the statement  "                //UPGRADE_WARNING: Data types in Visual C# might be different.  Verify the accuracy of narrowing conversions. 'ms-help://MS.VSCC.2003/commoner/redir/redirect.htm?keyword="jlca1042_3"' " is 183.
Long Statement,Encog.MathUtil.LIBSVM,svm,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_svr_probability,The length of the statement  "                "Prob. model for test data: target value = predicted value + z'\nz: Laplace distribution e^(-|z|/sigma)/(2sigma)'sigma=" + " is 122.
Long Statement,Encog.MathUtil.LIBSVM,svm,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_train,The length of the statement  "                    //UPGRADE_WARNING: Data types in Visual C# might be different.  Verify the accuracy of narrowing conversions. 'ms-help://MS.VSCC.2003/commoner/redir/redirect.htm?keyword="jlca1042_3"' " is 183.
Long Statement,Encog.MathUtil.LIBSVM,svm,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_cross_validation,The length of the statement  "                //UPGRADE_WARNING: Data types in Visual C# might be different.  Verify the accuracy of narrowing conversions. 'ms-help://MS.VSCC.2003/commoner/redir/redirect.htm?keyword="jlca1042_3"' " is 183.
Long Statement,Encog.MathUtil.LIBSVM,svm,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_check_parameter,The length of the statement  "                    //UPGRADE_WARNING: Data types in Visual C# might be different.  Verify the accuracy of narrowing conversions. 'ms-help://MS.VSCC.2003/commoner/redir/redirect.htm?keyword="jlca1042_3"' " is 183.
Long Statement,Encog.MathUtil.LIBSVM,svm_parameter,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm_parameter.cs,Clone,The length of the statement  "                //UPGRADE_NOTE: Exception 'java.lang.CloneNotSupportedException' was converted to 'System.Exception' which has different behavior. 'ms-help://MS.VSCC.2003/commoner/redir/redirect.htm?keyword="jlca1100_3"' " is 204.
Long Statement,Encog.MathUtil.Matrices,MatrixMath,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\MatrixMath.cs,Multiply,The length of the statement  "                    "To use ordinary matrix multiplication the number of columns on the first matrix must mat the number of rows on the second."); " is 126.
Long Statement,Encog.MathUtil.Randomize.Generate,MersenneTwisterGenerateRandom,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\MersenneTwisterGenerateRandom.cs,SetSeed,The length of the statement  "                _stateVector[i] = (uint)((_stateVector[i] ^ ((_stateVector[i - 1] ^ (_stateVector[i - 1] >> 30)) * 1664525U)) + array[j] + j); " is 126.
Long Statement,Encog.ML.Data.Market.Loader,CSVFinal,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFinal.cs,ReadAndCallLoader,The length of the statement  "                //In case we want to use a different date format...and have used the SetDateFormat method' our DateFormat must then not be null.. " is 129.
Long Statement,Encog.ML.EA.Score.Multi,ParallelScore,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\EA\Score\Multi\ParallelScore.cs,Process,The length of the statement  "            IList<ParallelScoreTask> tasks = (from species in _population.Species from genome in species.Members select new ParallelScoreTask(genome' this)).ToList(); " is 154.
Long Statement,Encog.ML.EA.Species,ThresholdSpeciation,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\EA\Species\ThresholdSpeciation.cs,SpeciateAndCalculateSpawnLevels,The length of the statement  "            double totalSpeciesScore = speciesCollection.Sum(species => species.CalculateShare(_owner.ScoreFunction.ShouldMinimize' maxScore)); " is 131.
Long Statement,Encog.ML.Prg,EncogProgramContext,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Prg\EncogProgramContext.cs,GetMaxEnumType,The length of the statement  "            r = (from mapping in _definedVariables where mapping.VariableType == EPLValueType.EnumType select mapping.EnumType).Concat(new[] {r}).Max(); " is 140.
Long Statement,Encog.ML.Prg.Ext,FunctionFactory,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Prg\Ext\FunctionFactory.cs,FindFunction,The length of the statement  "            return _opcodes.Where(opcode => opcode.NodeType == NodeType.Function).FirstOrDefault(opcode => opcode.Name.Equals(name)); " is 121.
Long Statement,Encog.ML.Prg.Ext,FunctionFactory,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Prg\Ext\FunctionFactory.cs,FindOperatorExact,The length of the statement  "            return _opcodes.Where(opcode => opcode.NodeType == NodeType.OperatorLeft || opcode.NodeType == NodeType.OperatorRight).FirstOrDefault(opcode => opcode.Name.Equals(str)); " is 169.
Long Statement,Encog.Neural.Freeform,FreeformNetwork,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Freeform\FreeformNetwork.cs,CreateContext,The length of the statement  "                    "A layer cannot have a context layer connected if there are no other outbound connections from the source layer.  Please connect the source layer somewhere else first."); " is 170.
Long Statement,Encog.Neural.Networks.Training.PSO,NeuralPSO,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\PSO\NeuralPSO.cs,IsScoreBetter,The length of the statement  "            return ((m_calculateScore.ShouldMinimize && (score1 < score2)) || ((!m_calculateScore.ShouldMinimize) && (score1 > score2))); " is 125.
Long Statement,Encog.Util.NetworkUtil,TrainerHelper,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\NetworkUtil\TrainerHelper.cs,MakeDataSet,The length of the statement  "            set = new BasicMLDataSet((double[][])FirstList.ToArray(typeof(double[]))' (double[][])outputsar.ToArray(typeof(double[]))); " is 123.
Complex Conditional,Encog.MathUtil.LIBSVM,svm,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_predict_probability,The conditional expression  "(model.param.svm_type == svm_parameter.C_SVC || model.param.svm_type == svm_parameter.NU_SVC) &&                  model.probA != null && model.probB != null"  is complex.
Complex Conditional,Encog.MathUtil.LIBSVM,svm,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_check_parameter,The conditional expression  "svm_type != svm_parameter.C_SVC && svm_type != svm_parameter.NU_SVC &&                  svm_type != svm_parameter.ONE_CLASS && svm_type != svm_parameter.EPSILON_SVR &&                  svm_type != svm_parameter.NU_SVR"  is complex.
Complex Conditional,Encog.MathUtil.LIBSVM,svm,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_check_parameter,The conditional expression  "kernel_type != svm_parameter.LINEAR && kernel_type != svm_parameter.POLY &&                  kernel_type != svm_parameter.RBF && kernel_type != svm_parameter.SIGMOID"  is complex.
Complex Conditional,Encog.MathUtil.LIBSVM,svm,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_check_probability_model,The conditional expression  "((model.param.svm_type == svm_parameter.C_SVC || model.param.svm_type == svm_parameter.NU_SVC) &&                   model.probA != null && model.probB != null) ||                  ((model.param.svm_type == svm_parameter.EPSILON_SVR || model.param.svm_type == svm_parameter.NU_SVR) &&                   model.probA != null)"  is complex.
Complex Conditional,Encog.ML.EA.Population,BasicPopulation,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\EA\Population\BasicPopulation.cs,PurgeInvalidGenomes,The conditional expression  "double.IsInfinity(genome.Score)                          || double.IsInfinity(genome.AdjustedScore)                          || double.IsNaN(genome.Score)                          || double.IsNaN(genome.AdjustedScore)"  is complex.
Complex Conditional,Encog.Parse.Expression.Common,ParseCommonExpression,C:\repos\encog_encog-dotnet-core\encog-core-cs\Parse\Expression\Common\ParseCommonExpression.cs,functionQueue,The conditional expression  "this.functionStack.Count != 0                      && this.functionStack.Peek().NodeType != NodeType.None                      && ((f.NodeType == NodeType.OperatorLeft && f                              .Precedence >= this.functionStack.Peek()                              .Precedence) || f.Precedence > this.functionStack                              .Peek().Precedence)"  is complex.
Complex Conditional,Encog.Parse.Tags.Read,ReadTags,C:\repos\encog_encog-dotnet-core\encog-core-cs\Parse\Tags\Read\ReadTags.cs,ParseAttributeName,The conditional expression  "!char.IsWhiteSpace((char) _source.Peek())                         && (_source.Peek() != '=')                         && (_source.Peek() != '>')                         && (_source.Peek() != -1)"  is complex.
Virtual Method Call from Constructor,Encog.ML.Data.Basic,BasicMLDataSet,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Basic\BasicMLDataSet.cs,BasicMLDataSet,The constructor "BasicMLDataSet" calls a virtual method "Add".
Virtual Method Call from Constructor,Encog.ML.Data.Basic,BasicMLDataSet,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Basic\BasicMLDataSet.cs,BasicMLDataSet,The constructor "BasicMLDataSet" calls a virtual method "Add".
Virtual Method Call from Constructor,Encog.Neural.Networks.Training.Propagation.Back,Backpropagation,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\Propagation\Back\Backpropagation.cs,Backpropagation,The constructor "Backpropagation" calls a virtual method "AddStrategy".
Virtual Method Call from Constructor,Encog.Neural.Networks.Training.Propagation.Back,Backpropagation,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\Propagation\Back\Backpropagation.cs,Backpropagation,The constructor "Backpropagation" calls a virtual method "AddStrategy".
Empty Catch Block,Encog.Cloud.Indicator.Server,IndicatorLink,C:\repos\encog_encog-dotnet-core\encog-core-cs\Cloud\Indicator\Server\IndicatorLink.cs,Close,The method has an empty catch block.
Empty Catch Block,Encog.ML.Bayesian.Parse,ParsedEvent,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Bayesian\Parse\ParsedEvent.cs,ResolveValue,The method has an empty catch block.
Magic Number,Encog.App.Analyst.Commands,CmdSet,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Commands\CmdSet.cs,ExecuteCommand,The following statement contains a magic number: String name = cols[2];
Magic Number,Encog.App.Analyst.Commands,CmdTrain,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Commands\CmdTrain.cs,ObtainCross,The following statement contains a magic number: if (cross.ToLower().StartsWith("kfold:"))              {                  String str = cross.Substring(6);                  try                  {                      return Int32.Parse(str);                  }                  catch (FormatException)                  {                      throw new AnalystError("Invalid kfold :" + str);                  }              }
Magic Number,Encog.App.Analyst.Analyze,AnalyzedField,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Analyze\AnalyzedField.cs,FinalizeField,The following statement contains a magic number: if (Math.Abs(Max - Min) < EncogFramework.DefaultDoubleEqual)              {                  result.Min = Min - 0.0001;                  result.Max = Min + 0.0001;              }
Magic Number,Encog.App.Analyst.Analyze,AnalyzedField,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Analyze\AnalyzedField.cs,FinalizeField,The following statement contains a magic number: if (Math.Abs(Max - Min) < EncogFramework.DefaultDoubleEqual)              {                  result.Min = Min - 0.0001;                  result.Max = Min + 0.0001;              }
Magic Number,Encog.App.Analyst.CSV.Basic,LoadedRow,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\CSV\Basic\LoadedRow.cs,LoadedRow,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  _data[i] = format.Format(data[i]' 5);              }
Magic Number,Encog.App.Analyst.CSV.Basic,LoadedRow,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\CSV\Basic\LoadedRow.cs,LoadedRow,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  _data[i] = format.Format(data[i]' 5);              }
Magic Number,Encog.App.Analyst.CSV.Segregate,SegregateCSV,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\CSV\Segregate\SegregateCSV.cs,BalanceTargets,The following statement contains a magic number: foreach (SegregateTargetPercent p  in  _targets)              {                  SegregateTargetPercent stp = p;                    // assign a number of records to this                  double percent = stp.Percent/100.0;                  var c = (int) (RecordCount*percent);                  stp.NumberRemaining = c;                    // track the smallest group                  if ((smallestItem == null)                      || (smallestItem.Percent > stp.Percent))                  {                      smallestItem = stp;                  }                    numberAssigned += c;              }
Magic Number,Encog.App.Analyst.CSV.Segregate,SegregateCSV,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\CSV\Segregate\SegregateCSV.cs,Validate,The following statement contains a magic number: if (_targets.Count < 2)              {                  throw new QuantError(                      "There must be at least two segregation targets.");              }
Magic Number,Encog.App.Analyst.Missing,NegateMissing,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Missing\NegateMissing.cs,HandleMissing,The following statement contains a magic number: double n = stat.NormalizedHigh - (stat.NormalizedHigh - stat.NormalizedLow/2);
Magic Number,Encog.App.Analyst.Script,ScriptLoad,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Script\ScriptLoad.cs,HandleDataClasses,The following statement contains a magic number: foreach (String line in section.Lines)              {                  if (!first)                  {                      IList<String> cols = EncogFileSection.SplitColumns(line);                        if (cols.Count < ColumnFour)                      {                          throw new AnalystError("Invalid data class: " + line);                      }                        String field = cols[0];                      String code = cols[1];                      String name = cols[2];                      int count = Int32.Parse(cols[3]);                        DataField df = _script.FindDataField(field);                        if (df == null)                      {                          throw new AnalystError(                              "Attempting to add class to unknown field: " + name);                      }                        List<AnalystClassItem> classItems;                        if (!map.ContainsKey(field))                      {                          classItems = new List<AnalystClassItem>();                          map[field] = classItems;                      }                      else                      {                          classItems = map[field];                      }                        classItems.Add(new AnalystClassItem(code' name' count));                  }                  else                  {                      first = false;                  }              }
Magic Number,Encog.App.Analyst.Script,ScriptLoad,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Script\ScriptLoad.cs,HandleDataClasses,The following statement contains a magic number: foreach (String line in section.Lines)              {                  if (!first)                  {                      IList<String> cols = EncogFileSection.SplitColumns(line);                        if (cols.Count < ColumnFour)                      {                          throw new AnalystError("Invalid data class: " + line);                      }                        String field = cols[0];                      String code = cols[1];                      String name = cols[2];                      int count = Int32.Parse(cols[3]);                        DataField df = _script.FindDataField(field);                        if (df == null)                      {                          throw new AnalystError(                              "Attempting to add class to unknown field: " + name);                      }                        List<AnalystClassItem> classItems;                        if (!map.ContainsKey(field))                      {                          classItems = new List<AnalystClassItem>();                          map[field] = classItems;                      }                      else                      {                          classItems = map[field];                      }                        classItems.Add(new AnalystClassItem(code' name' count));                  }                  else                  {                      first = false;                  }              }
Magic Number,Encog.App.Analyst.Script,ScriptLoad,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Script\ScriptLoad.cs,HandleDataStats,The following statement contains a magic number: foreach (String line in section.Lines)              {                  if (!first)                  {                      IList<String> cols = EncogFileSection.SplitColumns(line);                      String name = cols[0];                      bool isclass = Int32.Parse(cols[1]) > 0;                      bool iscomplete = Int32.Parse(cols[2]) > 0;                      bool isint = Int32.Parse(cols[ColumnThree]) > 0;                      bool isreal = Int32.Parse(cols[ColumnFour]) > 0;                      double amax = CSVFormat.EgFormat.Parse(cols[5]);                      double amin = CSVFormat.EgFormat.Parse(cols[6]);                      double mean = CSVFormat.EgFormat.Parse(cols[7]);                      double sdev = CSVFormat.EgFormat.Parse(cols[8]);                      String source = "";                        // source was added in Encog 3.2' so it might not be there                      if (cols.Count > 9)                      {                          source = cols[9];                      }                        var df = new DataField(name)                          {                              Class = isclass'                              Complete = iscomplete'                              Integer = isint'                              Real = isreal'                              Max = amax'                              Min = amin'                              Mean = mean'                              StandardDeviation = sdev'                              Source = source                          };                      dfs.Add(df);                  }                  else                  {                      first = false;                  }              }
Magic Number,Encog.App.Analyst.Script,ScriptLoad,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Script\ScriptLoad.cs,HandleDataStats,The following statement contains a magic number: foreach (String line in section.Lines)              {                  if (!first)                  {                      IList<String> cols = EncogFileSection.SplitColumns(line);                      String name = cols[0];                      bool isclass = Int32.Parse(cols[1]) > 0;                      bool iscomplete = Int32.Parse(cols[2]) > 0;                      bool isint = Int32.Parse(cols[ColumnThree]) > 0;                      bool isreal = Int32.Parse(cols[ColumnFour]) > 0;                      double amax = CSVFormat.EgFormat.Parse(cols[5]);                      double amin = CSVFormat.EgFormat.Parse(cols[6]);                      double mean = CSVFormat.EgFormat.Parse(cols[7]);                      double sdev = CSVFormat.EgFormat.Parse(cols[8]);                      String source = "";                        // source was added in Encog 3.2' so it might not be there                      if (cols.Count > 9)                      {                          source = cols[9];                      }                        var df = new DataField(name)                          {                              Class = isclass'                              Complete = iscomplete'                              Integer = isint'                              Real = isreal'                              Max = amax'                              Min = amin'                              Mean = mean'                              StandardDeviation = sdev'                              Source = source                          };                      dfs.Add(df);                  }                  else                  {                      first = false;                  }              }
Magic Number,Encog.App.Analyst.Script,ScriptLoad,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Script\ScriptLoad.cs,HandleDataStats,The following statement contains a magic number: foreach (String line in section.Lines)              {                  if (!first)                  {                      IList<String> cols = EncogFileSection.SplitColumns(line);                      String name = cols[0];                      bool isclass = Int32.Parse(cols[1]) > 0;                      bool iscomplete = Int32.Parse(cols[2]) > 0;                      bool isint = Int32.Parse(cols[ColumnThree]) > 0;                      bool isreal = Int32.Parse(cols[ColumnFour]) > 0;                      double amax = CSVFormat.EgFormat.Parse(cols[5]);                      double amin = CSVFormat.EgFormat.Parse(cols[6]);                      double mean = CSVFormat.EgFormat.Parse(cols[7]);                      double sdev = CSVFormat.EgFormat.Parse(cols[8]);                      String source = "";                        // source was added in Encog 3.2' so it might not be there                      if (cols.Count > 9)                      {                          source = cols[9];                      }                        var df = new DataField(name)                          {                              Class = isclass'                              Complete = iscomplete'                              Integer = isint'                              Real = isreal'                              Max = amax'                              Min = amin'                              Mean = mean'                              StandardDeviation = sdev'                              Source = source                          };                      dfs.Add(df);                  }                  else                  {                      first = false;                  }              }
Magic Number,Encog.App.Analyst.Script,ScriptLoad,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Script\ScriptLoad.cs,HandleDataStats,The following statement contains a magic number: foreach (String line in section.Lines)              {                  if (!first)                  {                      IList<String> cols = EncogFileSection.SplitColumns(line);                      String name = cols[0];                      bool isclass = Int32.Parse(cols[1]) > 0;                      bool iscomplete = Int32.Parse(cols[2]) > 0;                      bool isint = Int32.Parse(cols[ColumnThree]) > 0;                      bool isreal = Int32.Parse(cols[ColumnFour]) > 0;                      double amax = CSVFormat.EgFormat.Parse(cols[5]);                      double amin = CSVFormat.EgFormat.Parse(cols[6]);                      double mean = CSVFormat.EgFormat.Parse(cols[7]);                      double sdev = CSVFormat.EgFormat.Parse(cols[8]);                      String source = "";                        // source was added in Encog 3.2' so it might not be there                      if (cols.Count > 9)                      {                          source = cols[9];                      }                        var df = new DataField(name)                          {                              Class = isclass'                              Complete = iscomplete'                              Integer = isint'                              Real = isreal'                              Max = amax'                              Min = amin'                              Mean = mean'                              StandardDeviation = sdev'                              Source = source                          };                      dfs.Add(df);                  }                  else                  {                      first = false;                  }              }
Magic Number,Encog.App.Analyst.Script,ScriptLoad,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Script\ScriptLoad.cs,HandleDataStats,The following statement contains a magic number: foreach (String line in section.Lines)              {                  if (!first)                  {                      IList<String> cols = EncogFileSection.SplitColumns(line);                      String name = cols[0];                      bool isclass = Int32.Parse(cols[1]) > 0;                      bool iscomplete = Int32.Parse(cols[2]) > 0;                      bool isint = Int32.Parse(cols[ColumnThree]) > 0;                      bool isreal = Int32.Parse(cols[ColumnFour]) > 0;                      double amax = CSVFormat.EgFormat.Parse(cols[5]);                      double amin = CSVFormat.EgFormat.Parse(cols[6]);                      double mean = CSVFormat.EgFormat.Parse(cols[7]);                      double sdev = CSVFormat.EgFormat.Parse(cols[8]);                      String source = "";                        // source was added in Encog 3.2' so it might not be there                      if (cols.Count > 9)                      {                          source = cols[9];                      }                        var df = new DataField(name)                          {                              Class = isclass'                              Complete = iscomplete'                              Integer = isint'                              Real = isreal'                              Max = amax'                              Min = amin'                              Mean = mean'                              StandardDeviation = sdev'                              Source = source                          };                      dfs.Add(df);                  }                  else                  {                      first = false;                  }              }
Magic Number,Encog.App.Analyst.Script,ScriptLoad,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Script\ScriptLoad.cs,HandleDataStats,The following statement contains a magic number: foreach (String line in section.Lines)              {                  if (!first)                  {                      IList<String> cols = EncogFileSection.SplitColumns(line);                      String name = cols[0];                      bool isclass = Int32.Parse(cols[1]) > 0;                      bool iscomplete = Int32.Parse(cols[2]) > 0;                      bool isint = Int32.Parse(cols[ColumnThree]) > 0;                      bool isreal = Int32.Parse(cols[ColumnFour]) > 0;                      double amax = CSVFormat.EgFormat.Parse(cols[5]);                      double amin = CSVFormat.EgFormat.Parse(cols[6]);                      double mean = CSVFormat.EgFormat.Parse(cols[7]);                      double sdev = CSVFormat.EgFormat.Parse(cols[8]);                      String source = "";                        // source was added in Encog 3.2' so it might not be there                      if (cols.Count > 9)                      {                          source = cols[9];                      }                        var df = new DataField(name)                          {                              Class = isclass'                              Complete = iscomplete'                              Integer = isint'                              Real = isreal'                              Max = amax'                              Min = amin'                              Mean = mean'                              StandardDeviation = sdev'                              Source = source                          };                      dfs.Add(df);                  }                  else                  {                      first = false;                  }              }
Magic Number,Encog.App.Analyst.Script,ScriptLoad,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Script\ScriptLoad.cs,HandleDataStats,The following statement contains a magic number: foreach (String line in section.Lines)              {                  if (!first)                  {                      IList<String> cols = EncogFileSection.SplitColumns(line);                      String name = cols[0];                      bool isclass = Int32.Parse(cols[1]) > 0;                      bool iscomplete = Int32.Parse(cols[2]) > 0;                      bool isint = Int32.Parse(cols[ColumnThree]) > 0;                      bool isreal = Int32.Parse(cols[ColumnFour]) > 0;                      double amax = CSVFormat.EgFormat.Parse(cols[5]);                      double amin = CSVFormat.EgFormat.Parse(cols[6]);                      double mean = CSVFormat.EgFormat.Parse(cols[7]);                      double sdev = CSVFormat.EgFormat.Parse(cols[8]);                      String source = "";                        // source was added in Encog 3.2' so it might not be there                      if (cols.Count > 9)                      {                          source = cols[9];                      }                        var df = new DataField(name)                          {                              Class = isclass'                              Complete = iscomplete'                              Integer = isint'                              Real = isreal'                              Max = amax'                              Min = amin'                              Mean = mean'                              StandardDeviation = sdev'                              Source = source                          };                      dfs.Add(df);                  }                  else                  {                      first = false;                  }              }
Magic Number,Encog.App.Analyst.Script,ScriptLoad,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Script\ScriptLoad.cs,HandleNormalizeRange,The following statement contains a magic number: foreach (String line in section.Lines)              {                  if (!first)                  {                      IList<String> cols = EncogFileSection.SplitColumns(line);                      String name = cols[0];                      bool isOutput = cols[1].ToLower()                                             .Equals("output");                      int timeSlice = Int32.Parse(cols[2]);                      String action = cols[3];                      double high = CSVFormat.EgFormat.Parse(cols[4]);                      double low = CSVFormat.EgFormat.Parse(cols[5]);                        NormalizationAction des;                      if (action.Equals("range"))                      {                          des = NormalizationAction.Normalize;                      }                      else if (action.Equals("ignore"))                      {                          des = NormalizationAction.Ignore;                      }                      else if (action.Equals("pass"))                      {                          des = NormalizationAction.PassThrough;                      }                      else if (action.Equals("equilateral"))                      {                          des = NormalizationAction.Equilateral;                      }                      else if (action.Equals("single"))                      {                          des = NormalizationAction.SingleField;                      }                      else if (action.Equals("oneof"))                      {                          des = NormalizationAction.OneOf;                      }                      else                      {                          throw new AnalystError("Unknown field type:" + action);                      }                        var nf = new AnalystField(name' des' high' low) {TimeSlice = timeSlice' Output = isOutput};                      _script.Normalize.NormalizedFields.Add(nf);                  }                  else                  {                      first = false;                  }              }
Magic Number,Encog.App.Analyst.Script,ScriptLoad,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Script\ScriptLoad.cs,HandleNormalizeRange,The following statement contains a magic number: foreach (String line in section.Lines)              {                  if (!first)                  {                      IList<String> cols = EncogFileSection.SplitColumns(line);                      String name = cols[0];                      bool isOutput = cols[1].ToLower()                                             .Equals("output");                      int timeSlice = Int32.Parse(cols[2]);                      String action = cols[3];                      double high = CSVFormat.EgFormat.Parse(cols[4]);                      double low = CSVFormat.EgFormat.Parse(cols[5]);                        NormalizationAction des;                      if (action.Equals("range"))                      {                          des = NormalizationAction.Normalize;                      }                      else if (action.Equals("ignore"))                      {                          des = NormalizationAction.Ignore;                      }                      else if (action.Equals("pass"))                      {                          des = NormalizationAction.PassThrough;                      }                      else if (action.Equals("equilateral"))                      {                          des = NormalizationAction.Equilateral;                      }                      else if (action.Equals("single"))                      {                          des = NormalizationAction.SingleField;                      }                      else if (action.Equals("oneof"))                      {                          des = NormalizationAction.OneOf;                      }                      else                      {                          throw new AnalystError("Unknown field type:" + action);                      }                        var nf = new AnalystField(name' des' high' low) {TimeSlice = timeSlice' Output = isOutput};                      _script.Normalize.NormalizedFields.Add(nf);                  }                  else                  {                      first = false;                  }              }
Magic Number,Encog.App.Analyst.Script,ScriptLoad,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Script\ScriptLoad.cs,HandleNormalizeRange,The following statement contains a magic number: foreach (String line in section.Lines)              {                  if (!first)                  {                      IList<String> cols = EncogFileSection.SplitColumns(line);                      String name = cols[0];                      bool isOutput = cols[1].ToLower()                                             .Equals("output");                      int timeSlice = Int32.Parse(cols[2]);                      String action = cols[3];                      double high = CSVFormat.EgFormat.Parse(cols[4]);                      double low = CSVFormat.EgFormat.Parse(cols[5]);                        NormalizationAction des;                      if (action.Equals("range"))                      {                          des = NormalizationAction.Normalize;                      }                      else if (action.Equals("ignore"))                      {                          des = NormalizationAction.Ignore;                      }                      else if (action.Equals("pass"))                      {                          des = NormalizationAction.PassThrough;                      }                      else if (action.Equals("equilateral"))                      {                          des = NormalizationAction.Equilateral;                      }                      else if (action.Equals("single"))                      {                          des = NormalizationAction.SingleField;                      }                      else if (action.Equals("oneof"))                      {                          des = NormalizationAction.OneOf;                      }                      else                      {                          throw new AnalystError("Unknown field type:" + action);                      }                        var nf = new AnalystField(name' des' high' low) {TimeSlice = timeSlice' Output = isOutput};                      _script.Normalize.NormalizedFields.Add(nf);                  }                  else                  {                      first = false;                  }              }
Magic Number,Encog.App.Analyst.Script,ScriptLoad,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Script\ScriptLoad.cs,HandleNormalizeRange,The following statement contains a magic number: foreach (String line in section.Lines)              {                  if (!first)                  {                      IList<String> cols = EncogFileSection.SplitColumns(line);                      String name = cols[0];                      bool isOutput = cols[1].ToLower()                                             .Equals("output");                      int timeSlice = Int32.Parse(cols[2]);                      String action = cols[3];                      double high = CSVFormat.EgFormat.Parse(cols[4]);                      double low = CSVFormat.EgFormat.Parse(cols[5]);                        NormalizationAction des;                      if (action.Equals("range"))                      {                          des = NormalizationAction.Normalize;                      }                      else if (action.Equals("ignore"))                      {                          des = NormalizationAction.Ignore;                      }                      else if (action.Equals("pass"))                      {                          des = NormalizationAction.PassThrough;                      }                      else if (action.Equals("equilateral"))                      {                          des = NormalizationAction.Equilateral;                      }                      else if (action.Equals("single"))                      {                          des = NormalizationAction.SingleField;                      }                      else if (action.Equals("oneof"))                      {                          des = NormalizationAction.OneOf;                      }                      else                      {                          throw new AnalystError("Unknown field type:" + action);                      }                        var nf = new AnalystField(name' des' high' low) {TimeSlice = timeSlice' Output = isOutput};                      _script.Normalize.NormalizedFields.Add(nf);                  }                  else                  {                      first = false;                  }              }
Magic Number,Encog.App.Analyst.Script.Normalize,AnalystField,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Script\Normalize\AnalystField.cs,DeNormalize,The following statement contains a magic number: if (Double.IsNaN(result))              {                  return ((NormalizedHigh - NormalizedLow)/2) + NormalizedLow;              }
Magic Number,Encog.App.Analyst.Script.Normalize,AnalystField,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Script\Normalize\AnalystField.cs,Normalize,The following statement contains a magic number: if (Double.IsNaN(result))              {                  return ((NormalizedHigh - NormalizedLow)/2) + NormalizedLow;              }
Magic Number,Encog.App.Analyst.Script.Prop,PropertyConstraints,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Script\Prop\PropertyConstraints.cs,PropertyConstraints,The following statement contains a magic number: try              {                  Stream mask0 = ResourceLoader.CreateStream("Encog.Resources.analyst.csv");                  var csv = new ReadCSV(mask0' false' CSVFormat.EgFormat);                    while (csv.Next())                  {                      String sectionStr = csv.Get(0);                      String nameStr = csv.Get(1);                      String typeStr = csv.Get(2);                        // determine type                      PropertyType t;                      if ("boolean".Equals(typeStr' StringComparison.InvariantCultureIgnoreCase))                      {                          t = PropertyType.TypeBoolean;                      }                      else if ("real".Equals(typeStr' StringComparison.InvariantCultureIgnoreCase))                      {                          t = PropertyType.TypeDouble;                      }                      else if ("format".Equals(typeStr' StringComparison.InvariantCultureIgnoreCase))                      {                          t = PropertyType.TypeFormat;                      }                      else if ("int".Equals(typeStr' StringComparison.InvariantCultureIgnoreCase))                      {                          t = PropertyType.TypeInteger;                      }                      else if ("list-string".Equals(typeStr' StringComparison.InvariantCultureIgnoreCase))                      {                          t = PropertyType.TypeListString;                      }                      else if ("string".Equals(typeStr' StringComparison.InvariantCultureIgnoreCase))                      {                          t = PropertyType.TypeString;                      }                      else                      {                          throw new AnalystError("Unknown type constraint: "                                                 + typeStr);                      }                        var entry = new PropertyEntry(t' nameStr'                                                    sectionStr);                      List<PropertyEntry> list;                        if (_data.ContainsKey(sectionStr))                      {                          list = _data[sectionStr];                      }                      else                      {                          list = new List<PropertyEntry>();                          _data[sectionStr] = list;                      }                        list.Add(entry);                  }                    csv.Close();                  mask0.Close();              }              catch (IOException e)              {                  throw new EncogError(e);              }
Magic Number,Encog.App.Analyst.Script.Prop,PropertyConstraints,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Script\Prop\PropertyConstraints.cs,FindEntry,The following statement contains a magic number: String name = cols[2];
Magic Number,Encog.App.Analyst.Wizard,AnalystWizard,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,DetermineTargetField,The following statement contains a magic number: if (_taskCluster)              {                  if ((TargetField == null)                      || (_goal != AnalystGoal.Classification))                  {                      _script.Properties.SetProperty(                          ScriptProperties.ClusterConfigClusters' 2);                  }                  else                  {                      DataField tf = _script.FindDataField(TargetField.Name);                      _script.Properties.SetProperty(                          ScriptProperties.ClusterConfigClusters'                          tf.ClassMembers.Count);                  }              }
Magic Number,Encog.App.Analyst.Wizard,AnalystWizard,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,GenerateBayesian,The following statement contains a magic number: foreach (DataField field in _analyst.Script.Fields)              {                  a.Append("P(");                  a.Append(field.Name);                    // handle actual class members                  if (field.ClassMembers.Count > 0)                  {                      a.Append("[");                      bool first = true;                      foreach (AnalystClassItem item in field.ClassMembers)                      {                          if (!first)                          {                              a.Append("'");                          }                          a.Append(item.Code);                          first = false;                      }                        // append a "fake" member' if there is only one                      if (field.ClassMembers.Count == 1)                      {                          a.Append("'Other0");                      }                        a.Append("]");                  }                  else                  {                      a.Append("[");                      // handle ranges                      double size = Math.Abs(field.Max - field.Min);                      double per = size/segment;                        if (size < EncogFramework.DefaultDoubleEqual)                      {                          double low = field.Min - 0.0001;                          double hi = field.Min + 0.0001;                          a.Append("BELOW: " + (low - 100) + " to " + hi + "'");                          a.Append("Type0: " + low + " to " + hi + "'");                          a.Append("ABOVE: " + hi + " to " + (hi + 100));                      }                      else                      {                          bool first = true;                          for (int i = 0; i < segment; i++)                          {                              if (!first)                              {                                  a.Append("'");                              }                              double low = field.Min + (per*i);                              double hi = i == (segment - 1)                                              ? (field.Max)                                              : (low + per);                              a.Append("Type");                              a.Append(i);                              a.Append(":");                              a.Append(CSVFormat.EgFormat.Format(low' 16));                              a.Append(" to ");                              a.Append(CSVFormat.EgFormat.Format(hi' 16));                              first = false;                          }                      }                      a.Append("]");                  }                    a.Append(") ");              }
Magic Number,Encog.App.Analyst.Wizard,AnalystWizard,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,GenerateBayesian,The following statement contains a magic number: foreach (DataField field in _analyst.Script.Fields)              {                  a.Append("P(");                  a.Append(field.Name);                    // handle actual class members                  if (field.ClassMembers.Count > 0)                  {                      a.Append("[");                      bool first = true;                      foreach (AnalystClassItem item in field.ClassMembers)                      {                          if (!first)                          {                              a.Append("'");                          }                          a.Append(item.Code);                          first = false;                      }                        // append a "fake" member' if there is only one                      if (field.ClassMembers.Count == 1)                      {                          a.Append("'Other0");                      }                        a.Append("]");                  }                  else                  {                      a.Append("[");                      // handle ranges                      double size = Math.Abs(field.Max - field.Min);                      double per = size/segment;                        if (size < EncogFramework.DefaultDoubleEqual)                      {                          double low = field.Min - 0.0001;                          double hi = field.Min + 0.0001;                          a.Append("BELOW: " + (low - 100) + " to " + hi + "'");                          a.Append("Type0: " + low + " to " + hi + "'");                          a.Append("ABOVE: " + hi + " to " + (hi + 100));                      }                      else                      {                          bool first = true;                          for (int i = 0; i < segment; i++)                          {                              if (!first)                              {                                  a.Append("'");                              }                              double low = field.Min + (per*i);                              double hi = i == (segment - 1)                                              ? (field.Max)                                              : (low + per);                              a.Append("Type");                              a.Append(i);                              a.Append(":");                              a.Append(CSVFormat.EgFormat.Format(low' 16));                              a.Append(" to ");                              a.Append(CSVFormat.EgFormat.Format(hi' 16));                              first = false;                          }                      }                      a.Append("]");                  }                    a.Append(") ");              }
Magic Number,Encog.App.Analyst.Wizard,AnalystWizard,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,GenerateBayesian,The following statement contains a magic number: foreach (DataField field in _analyst.Script.Fields)              {                  a.Append("P(");                  a.Append(field.Name);                    // handle actual class members                  if (field.ClassMembers.Count > 0)                  {                      a.Append("[");                      bool first = true;                      foreach (AnalystClassItem item in field.ClassMembers)                      {                          if (!first)                          {                              a.Append("'");                          }                          a.Append(item.Code);                          first = false;                      }                        // append a "fake" member' if there is only one                      if (field.ClassMembers.Count == 1)                      {                          a.Append("'Other0");                      }                        a.Append("]");                  }                  else                  {                      a.Append("[");                      // handle ranges                      double size = Math.Abs(field.Max - field.Min);                      double per = size/segment;                        if (size < EncogFramework.DefaultDoubleEqual)                      {                          double low = field.Min - 0.0001;                          double hi = field.Min + 0.0001;                          a.Append("BELOW: " + (low - 100) + " to " + hi + "'");                          a.Append("Type0: " + low + " to " + hi + "'");                          a.Append("ABOVE: " + hi + " to " + (hi + 100));                      }                      else                      {                          bool first = true;                          for (int i = 0; i < segment; i++)                          {                              if (!first)                              {                                  a.Append("'");                              }                              double low = field.Min + (per*i);                              double hi = i == (segment - 1)                                              ? (field.Max)                                              : (low + per);                              a.Append("Type");                              a.Append(i);                              a.Append(":");                              a.Append(CSVFormat.EgFormat.Format(low' 16));                              a.Append(" to ");                              a.Append(CSVFormat.EgFormat.Format(hi' 16));                              first = false;                          }                      }                      a.Append("]");                  }                    a.Append(") ");              }
Magic Number,Encog.App.Analyst.Wizard,AnalystWizard,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,GenerateBayesian,The following statement contains a magic number: foreach (DataField field in _analyst.Script.Fields)              {                  a.Append("P(");                  a.Append(field.Name);                    // handle actual class members                  if (field.ClassMembers.Count > 0)                  {                      a.Append("[");                      bool first = true;                      foreach (AnalystClassItem item in field.ClassMembers)                      {                          if (!first)                          {                              a.Append("'");                          }                          a.Append(item.Code);                          first = false;                      }                        // append a "fake" member' if there is only one                      if (field.ClassMembers.Count == 1)                      {                          a.Append("'Other0");                      }                        a.Append("]");                  }                  else                  {                      a.Append("[");                      // handle ranges                      double size = Math.Abs(field.Max - field.Min);                      double per = size/segment;                        if (size < EncogFramework.DefaultDoubleEqual)                      {                          double low = field.Min - 0.0001;                          double hi = field.Min + 0.0001;                          a.Append("BELOW: " + (low - 100) + " to " + hi + "'");                          a.Append("Type0: " + low + " to " + hi + "'");                          a.Append("ABOVE: " + hi + " to " + (hi + 100));                      }                      else                      {                          bool first = true;                          for (int i = 0; i < segment; i++)                          {                              if (!first)                              {                                  a.Append("'");                              }                              double low = field.Min + (per*i);                              double hi = i == (segment - 1)                                              ? (field.Max)                                              : (low + per);                              a.Append("Type");                              a.Append(i);                              a.Append(":");                              a.Append(CSVFormat.EgFormat.Format(low' 16));                              a.Append(" to ");                              a.Append(CSVFormat.EgFormat.Format(hi' 16));                              first = false;                          }                      }                      a.Append("]");                  }                    a.Append(") ");              }
Magic Number,Encog.App.Analyst.Wizard,AnalystWizard,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,GenerateBayesian,The following statement contains a magic number: foreach (DataField field in _analyst.Script.Fields)              {                  a.Append("P(");                  a.Append(field.Name);                    // handle actual class members                  if (field.ClassMembers.Count > 0)                  {                      a.Append("[");                      bool first = true;                      foreach (AnalystClassItem item in field.ClassMembers)                      {                          if (!first)                          {                              a.Append("'");                          }                          a.Append(item.Code);                          first = false;                      }                        // append a "fake" member' if there is only one                      if (field.ClassMembers.Count == 1)                      {                          a.Append("'Other0");                      }                        a.Append("]");                  }                  else                  {                      a.Append("[");                      // handle ranges                      double size = Math.Abs(field.Max - field.Min);                      double per = size/segment;                        if (size < EncogFramework.DefaultDoubleEqual)                      {                          double low = field.Min - 0.0001;                          double hi = field.Min + 0.0001;                          a.Append("BELOW: " + (low - 100) + " to " + hi + "'");                          a.Append("Type0: " + low + " to " + hi + "'");                          a.Append("ABOVE: " + hi + " to " + (hi + 100));                      }                      else                      {                          bool first = true;                          for (int i = 0; i < segment; i++)                          {                              if (!first)                              {                                  a.Append("'");                              }                              double low = field.Min + (per*i);                              double hi = i == (segment - 1)                                              ? (field.Max)                                              : (low + per);                              a.Append("Type");                              a.Append(i);                              a.Append(":");                              a.Append(CSVFormat.EgFormat.Format(low' 16));                              a.Append(" to ");                              a.Append(CSVFormat.EgFormat.Format(hi' 16));                              first = false;                          }                      }                      a.Append("]");                  }                    a.Append(") ");              }
Magic Number,Encog.App.Analyst.Wizard,AnalystWizard,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,GenerateBayesian,The following statement contains a magic number: foreach (DataField field in _analyst.Script.Fields)              {                  a.Append("P(");                  a.Append(field.Name);                    // handle actual class members                  if (field.ClassMembers.Count > 0)                  {                      a.Append("[");                      bool first = true;                      foreach (AnalystClassItem item in field.ClassMembers)                      {                          if (!first)                          {                              a.Append("'");                          }                          a.Append(item.Code);                          first = false;                      }                        // append a "fake" member' if there is only one                      if (field.ClassMembers.Count == 1)                      {                          a.Append("'Other0");                      }                        a.Append("]");                  }                  else                  {                      a.Append("[");                      // handle ranges                      double size = Math.Abs(field.Max - field.Min);                      double per = size/segment;                        if (size < EncogFramework.DefaultDoubleEqual)                      {                          double low = field.Min - 0.0001;                          double hi = field.Min + 0.0001;                          a.Append("BELOW: " + (low - 100) + " to " + hi + "'");                          a.Append("Type0: " + low + " to " + hi + "'");                          a.Append("ABOVE: " + hi + " to " + (hi + 100));                      }                      else                      {                          bool first = true;                          for (int i = 0; i < segment; i++)                          {                              if (!first)                              {                                  a.Append("'");                              }                              double low = field.Min + (per*i);                              double hi = i == (segment - 1)                                              ? (field.Max)                                              : (low + per);                              a.Append("Type");                              a.Append(i);                              a.Append(":");                              a.Append(CSVFormat.EgFormat.Format(low' 16));                              a.Append(" to ");                              a.Append(CSVFormat.EgFormat.Format(hi' 16));                              first = false;                          }                      }                      a.Append("]");                  }                    a.Append(") ");              }
Magic Number,Encog.App.Analyst.Wizard,AnalystWizard,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,generateEPL,The following statement contains a magic number: if (inputColumns > 26)              {                  throw new EncogError("More than 26 input variables is not supported for EPL.");              }              else if (inputColumns <= 3)              {                  var temp = new StringBuilder();                  for (int i = 0; i < inputColumns; i++)                  {                      if (temp.Length > 0)                      {                          temp.Append(''');                      }                      temp.Append((char) ('x' + i));                  }                  vars = temp.ToString();              }              else              {                  var temp = new StringBuilder();                  for (int i = 0; i < inputColumns; i++)                  {                      if (temp.Length > 0)                      {                          temp.Append(''');                      }                      temp.Append((char) ('a' + i));                  }                  vars = temp.ToString();              }
Magic Number,Encog.App.Analyst.Wizard,AnalystWizard,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,generateEPL,The following statement contains a magic number: if (inputColumns > 26)              {                  throw new EncogError("More than 26 input variables is not supported for EPL.");              }              else if (inputColumns <= 3)              {                  var temp = new StringBuilder();                  for (int i = 0; i < inputColumns; i++)                  {                      if (temp.Length > 0)                      {                          temp.Append(''');                      }                      temp.Append((char) ('x' + i));                  }                  vars = temp.ToString();              }              else              {                  var temp = new StringBuilder();                  for (int i = 0; i < inputColumns; i++)                  {                      if (temp.Length > 0)                      {                          temp.Append(''');                      }                      temp.Append((char) ('a' + i));                  }                  vars = temp.ToString();              }
Magic Number,Encog.App.Analyst.Wizard,AnalystWizard,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,GenerateNormalizedFields,The following statement contains a magic number: for (int i = 0; i < _script.Fields.Length; i++)              {                  DataField f = dataFields[i];                    NormalizationAction action;                  bool isLast = i == _script.Fields.Length - 1;                      if (_methodType == WizardMethodType.BayesianNetwork)                  {                      AnalystField af;                      if (f.Class)                      {                          af = new AnalystField(f.Name'                                                NormalizationAction.SingleField' 0' 0);                      }                      else                      {                          af = new AnalystField(f.Name'                                                NormalizationAction.PassThrough' 0' 0);                      }                      norm.Add(af);                  }                  else if ((f.Integer || f.Real) && !f.Class)                  {                      action = NormalizationAction.Normalize;                      AnalystField af = _range == NormalizeRange.NegOne2One                                            ? new AnalystField(f.Name' action' 1' -1)                                            : new AnalystField(f.Name' action' 1' 0);                      norm.Add(af);                      af.ActualHigh = f.Max;                      af.ActualLow = f.Min;                  }                  else if (f.Class)                  {                      if (isLast && _directClassification)                      {                          action = NormalizationAction.SingleField;                      }                      else if (f.ClassMembers.Count > 2)                      {                          action = NormalizationAction.Equilateral;                      }                      else                      {                          action = NormalizationAction.OneOf;                      }                        norm.Add(_range == NormalizeRange.NegOne2One                                   ? new AnalystField(f.Name' action' 1' -1)                                   : new AnalystField(f.Name' action' 1' 0));                  }                  else                  {                      action = NormalizationAction.Ignore;                      norm.Add(new AnalystField(action' f.Name));                  }              }
Magic Number,Encog.App.Analyst.Wizard,AnalystWizard,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,GenerateSegregate,The following statement contains a magic number: if (_taskSegregate)              {                  var array = new AnalystSegregateTarget[2];                  array[0] = new AnalystSegregateTarget(FileTrain'                                                        DefaultTrainPercent);                  array[1] = new AnalystSegregateTarget(FileEval'                                                        DefaultEvalPercent);                  _script.Segregate.SegregateTargets = array;              }              else              {                  var array = new AnalystSegregateTarget[0];                  _script.Segregate.SegregateTargets = array;              }
Magic Number,Encog.App.Analyst.Wizard,AnalystWizard,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,WizardRealTime,The following statement contains a magic number: MaxError = 0.05;
Magic Number,Encog.App.Analyst.Wizard,AnalystWizard,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,GenerateSourceData,The following statement contains a magic number: foreach (SourceElement element in sourceData)              {                  var df = new DataField(element.Name);                  df.Source = element.Source;                  df.Integer = false;                  df.Class = false;                  df.Max = 100000;                  df.Mean = 0;                  df.Min = -100000;                  df.StandardDeviation = 0;                  fields[index++] = df;              }
Magic Number,Encog.App.Analyst.Wizard,AnalystWizard,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,GenerateSourceData,The following statement contains a magic number: foreach (SourceElement element in sourceData)              {                  var df = new DataField(element.Name);                  df.Source = element.Source;                  df.Integer = false;                  df.Class = false;                  df.Max = 100000;                  df.Mean = 0;                  df.Min = -100000;                  df.StandardDeviation = 0;                  fields[index++] = df;              }
Magic Number,Encog.App.Analyst.Wizard,AnalystWizard,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,GenerateSourceData,The following statement contains a magic number: df2.Max = 100000;
Magic Number,Encog.App.Analyst.Wizard,AnalystWizard,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,GenerateSourceData,The following statement contains a magic number: df2.Min = -100000;
Magic Number,Encog.App.Finance.Indicators,TechnicalIndicators,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Finance\Indicators\Finance.cs,Avg,The following statement contains a magic number: return (a + b)/2;
Magic Number,Encog.App.Generate.Generators,AbstractTemplateGenerator,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Generate\Generators\AbstractTemplateGenerator.cs,Generate,The following statement contains a magic number: using (var reader = new StringReader(fileContent))              {                  string line;                  while ((line = reader.ReadLine()) != null)                  {                      if (line.StartsWith("~~"))                      {                          ProcessToken(line.Substring(2).Trim());                      }                      else                      {                          contents.Append(line);                          contents.Append("\n");                      }                  }              }
Magic Number,Encog.App.Generate.Generators,AbstractTemplateGenerator,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Generate\Generators\AbstractTemplateGenerator.cs,CreateActivations,The following statement contains a magic number: for (int i = 0; i < flat.ActivationFunctions.Length; i++)              {                  IActivationFunction af = flat.ActivationFunctions[i];                    if (af is ActivationLinear)                  {                      result[i] = 0;                  }                  else if (af is ActivationTANH)                  {                      result[i] = 1;                  }                  if (af is ActivationSigmoid)                  {                      result[i] = 2;                  }                  if (af is ActivationElliottSymmetric)                  {                      result[i] = 3;                  }                  if (af is ActivationElliott)                  {                      result[i] = 4;                  }              }
Magic Number,Encog.App.Generate.Generators,AbstractTemplateGenerator,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Generate\Generators\AbstractTemplateGenerator.cs,CreateActivations,The following statement contains a magic number: for (int i = 0; i < flat.ActivationFunctions.Length; i++)              {                  IActivationFunction af = flat.ActivationFunctions[i];                    if (af is ActivationLinear)                  {                      result[i] = 0;                  }                  else if (af is ActivationTANH)                  {                      result[i] = 1;                  }                  if (af is ActivationSigmoid)                  {                      result[i] = 2;                  }                  if (af is ActivationElliottSymmetric)                  {                      result[i] = 3;                  }                  if (af is ActivationElliott)                  {                      result[i] = 4;                  }              }
Magic Number,Encog.App.Generate.Generators,AbstractTemplateGenerator,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Generate\Generators\AbstractTemplateGenerator.cs,CreateActivations,The following statement contains a magic number: for (int i = 0; i < flat.ActivationFunctions.Length; i++)              {                  IActivationFunction af = flat.ActivationFunctions[i];                    if (af is ActivationLinear)                  {                      result[i] = 0;                  }                  else if (af is ActivationTANH)                  {                      result[i] = 1;                  }                  if (af is ActivationSigmoid)                  {                      result[i] = 2;                  }                  if (af is ActivationElliottSymmetric)                  {                      result[i] = 3;                  }                  if (af is ActivationElliott)                  {                      result[i] = 4;                  }              }
Magic Number,Encog.App.Generate.Generators,AbstractTemplateGenerator,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Generate\Generators\AbstractTemplateGenerator.cs,ToBrokenList,The following statement contains a magic number: for (int i = 0; i < data.Length; i++)              {                  if (i != 0)                  {                      result.Append(''');                  }                    lineCount++;                  if (lineCount > 10)                  {                      result.Append("\n");                      lineCount = 0;                  }                  result.Append(CSVFormat.EgFormat.Format(data[i]'                                                          EncogFramework.DefaultPrecision));              }
Magic Number,Encog.App.Generate.Generators,AbstractTemplateGenerator,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Generate\Generators\AbstractTemplateGenerator.cs,ToBrokenList,The following statement contains a magic number: for (int i = 0; i < data.Length; i++)              {                  if (i != 0)                  {                      result.Append(''');                  }                    lineCount++;                  if (lineCount > 10)                  {                      result.Append("\n");                      lineCount = 0;                  }                  result.Append("" + data[i]);              }
Magic Number,Encog.App.Generate.Generators.CS,GenerateCS,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Generate\Generators\CS\GenerateCS.cs,GenerateArrayInit,The following statement contains a magic number: for (int i = 0; i < a.Length; i++)              {                  line.Append(CSVFormat.EgFormat.Format(a[i]'                                                        EncogFramework.DefaultPrecision));                  if (i < (a.Length - 1))                  {                      line.Append("'");                  }                    lineCount++;                  if (lineCount >= 10)                  {                      AddLine(line.ToString());                      line.Length = 0;                      lineCount = 0;                  }              }
Magic Number,Encog.App.Generate.Generators.Java,GenerateEncogJava,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Generate\Generators\Java\GenerateEncogJava.cs,GenerateArrayInit,The following statement contains a magic number: for (int i = 0; i < a.Length; i++)              {                  line.Append(CSVFormat.EgFormat.Format(a[i]'                                                        EncogFramework.DefaultPrecision));                  if (i < (a.Length - 1))                  {                      line.Append("'");                  }                    lineCount++;                  if (lineCount >= 10)                  {                      AddLine(line.ToString());                      line.Length = 0;                      lineCount = 0;                  }              }
Magic Number,Encog.App.Generate.Generators.JS,GenerateEncogJavaScript,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Generate\Generators\JS\GenerateEncogJavaScript.cs,GenerateArrayInit,The following statement contains a magic number: for (int i = 0; i < a.Length; i++)              {                  line.Append(CSVFormat.EgFormat.Format(a[i]'                                                        EncogFramework.DefaultPrecision));                  if (i < (a.Length - 1))                  {                      line.Append("'");                  }                    lineCount++;                  if (lineCount >= 10)                  {                      AddLine(line.ToString());                      line.Length = 0;                      lineCount = 0;                  }              }
Magic Number,Encog.App.Generate.Generators.MQL4,GenerateMQL4,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Generate\Generators\MQL4\GenerateMQL4.cs,ProcessCalc,The following statement contains a magic number: IndentLevel = 2;
Magic Number,Encog.App.Generate.Generators.MQL4,GenerateMQL4,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Generate\Generators\MQL4\GenerateMQL4.cs,ProcessCalc,The following statement contains a magic number: IndentLevel = 2;
Magic Number,Encog.App.Generate.Generators.MQL4,GenerateMQL4,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Generate\Generators\MQL4\GenerateMQL4.cs,ProcessMainBlock,The following statement contains a magic number: IndentLevel = 2;
Magic Number,Encog.App.Generate.Generators.MQL4,GenerateMQL4,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Generate\Generators\MQL4\GenerateMQL4.cs,ProcessObtain,The following statement contains a magic number: IndentLevel = 3;
Magic Number,Encog.App.Generate.Generators.NinjaScript,GenerateNinjaScript,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Generate\Generators\NinjaScript\GenerateNinjaScript.cs,ProcessMainBlock,The following statement contains a magic number: IndentLevel = 2;
Magic Number,Encog.App.Generate.Generators.NinjaScript,GenerateNinjaScript,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Generate\Generators\NinjaScript\GenerateNinjaScript.cs,ProcessCalc,The following statement contains a magic number: IndentLevel = 2;
Magic Number,Encog.App.Generate.Generators.NinjaScript,GenerateNinjaScript,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Generate\Generators\NinjaScript\GenerateNinjaScript.cs,ProcessCalc,The following statement contains a magic number: IndentLevel = 2;
Magic Number,Encog.App.Generate.Generators.NinjaScript,GenerateNinjaScript,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Generate\Generators\NinjaScript\GenerateNinjaScript.cs,ProcessObtain,The following statement contains a magic number: IndentLevel = 3;
Magic Number,Encog.App.Quant.Loader.OpenQuant,DataArray,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Quant\Loader\OpenQuant\BarSeries.cs,GetIndex,The following statement contains a magic number: if (num2 != ticks)              {                  num4 = index1 + ((int) ((index2 - index1)*((num3 - ticks)/(num2 - ticks))));              }              else              {                  num4 = (index1 + index2)/2;              }
Magic Number,Encog.App.Quant.Loader.Yahoo,YahooDownload,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Quant\Loader\Yahoo\YahooDownload.cs,YahooDownload,The following statement contains a magic number: Precision = 10;
Magic Number,Encog.App.Quant.Ninja,NinjaStreamWriter,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Quant\Ninja\NinjaStreamWriter.cs,NinjaStreamWriter,The following statement contains a magic number: Percision = 10;
Magic Number,Encog.Bot.Browse,Browser,C:\repos\encog_encog-dotnet-core\encog-core-cs\Bot\Browse\Browser.cs,Navigate,The following statement contains a magic number: try              {  #if logging                  if (logger.IsInfoEnabled)                  {                      logger.Info("Posting a form");                  }  #endif                  Stream istream;                  Stream ostream;                  Uri targetURL;                  WebRequest http = null;                    if (form.Method == Form.FormMethod.Get)                  {                      ostream = new MemoryStream();                  }                  else                  {                      http = WebRequest.Create(form.Action.Url);                      http.Timeout = 30000;                      http.ContentType = "application/x-www-form-urlencoded";                      http.Method = "POST";                      ostream = http.GetRequestStream();                  }                    // add the parameters if present                  var formData = new FormUtility(ostream' null);                  foreach (DocumentRange dr in form.Elements)                  {                      if (dr is FormElement)                      {                          var element = (FormElement) dr;                          if ((element == submit) || element.AutoSend)                          {                              String name = element.Name;                              String value = element.Value;                              if (name != null)                              {                                  if (value == null)                                  {                                      value = "";                                  }                                  formData.Add(name' value);                              }                          }                      }                  }                    // now execute the command                  if (form.Method == Form.FormMethod.Get)                  {                      String action = form.Action.Url.ToString();                      ostream.Close();                      action += "?";                      action += ostream.ToString();                      targetURL = new Uri(action);                      http = WebRequest.Create(targetURL);                      var response = (HttpWebResponse) http.GetResponse();                      istream = response.GetResponseStream();                  }                  else                  {                      targetURL = form.Action.Url;                      ostream.Close();                      var response = (HttpWebResponse) http.GetResponse();                      istream = response.GetResponseStream();                  }                    Navigate(targetURL' istream);                  istream.Close();              }              catch (IOException e)              {                  throw new BrowseError(e);              }
Magic Number,Encog.Cloud.Indicator.Basic,DownloadIndicator,C:\repos\encog_encog-dotnet-core\encog-core-cs\Cloud\Indicator\Basic\DownloadIndicator.cs,NotifyPacket,The following statement contains a magic number: if (string.Compare(packet.Command' IndicatorLink.PacketBar' true) == 0)              {                  String security = packet.Args[1];                  long when = long.Parse(packet.Args[0]);                  String key = security.ToLower();                  InstrumentHolder holder;                    if (_data.ContainsKey(key))                  {                      holder = _data[key];                  }                  else                  {                      holder = new InstrumentHolder();                      _data[key] = holder;                  }                    if (holder.Record(when' 2' packet.Args))                  {                      _rowsDownloaded++;                  }              }
Magic Number,Encog.Cloud.Indicator.Server,IndicatorLink,C:\repos\encog_encog-dotnet-core\encog-core-cs\Cloud\Indicator\Server\IndicatorLink.cs,ReadNextBlock,The following statement contains a magic number: var buffer = new byte[1024];
Magic Number,Encog.Cloud.Indicator.Server,IndicatorLink,C:\repos\encog_encog-dotnet-core\encog-core-cs\Cloud\Indicator\Server\IndicatorLink.cs,ReadPacket,The following statement contains a magic number: try              {                  var line = new StringBuilder();                    for (;;)                  {                      char ch = ReadNextChar();                        if (ch != '\n' && ch != '\r')                      {                          line.Append(ch);                      }                      else                      {                          break;                      }                  }                    IList<String> list = _parseLine.Parse(line.ToString());                  _packets++;                    if (list.Count > 0)                  {                      list[0] = list[0].ToUpper();                  }                    EncogLogging.Log(EncogLogging.LevelDebug' "Received Packet: " + line);                  return new IndicatorPacket(list);              }              catch (SocketException ex)              {                  // was it just a timeout?                  if (ex.ErrorCode == 10060)                  {                      return null;                  }                  throw new IndicatorError(ex);              }
Magic Number,Encog.Cloud.Indicator.Server,IndicatorLink,C:\repos\encog_encog-dotnet-core\encog-core-cs\Cloud\Indicator\Server\IndicatorLink.cs,InitConnection,The following statement contains a magic number: var args = new String[2];
Magic Number,Encog.Cloud.Indicator.Server,IndicatorServer,C:\repos\encog_encog-dotnet-core\encog-core-cs\Cloud\Indicator\Server\IndicatorServer.cs,Run,The following statement contains a magic number: try              {                  _running = true;                  _listenSocket.Listen(5);                  while (_running)                  {                      try                      {                          EncogLogging.Log(EncogLogging.LevelDebug' "Begin listen");                          Socket connectionSocket = _listenSocket.Accept();                          EncogLogging.Log(EncogLogging.LevelDebug' "Connection from: " + connectionSocket.RemoteEndPoint);                          var link = new IndicatorLink(this' connectionSocket);                          NotifyListenersConnections(link' true);                          var hc = new HandleClient(this' link);                          _connections.Add(hc);                          var t = new Thread(hc.Run);                          t.Start();                      }                      catch (SocketException)                      {                          // just accept timing out                          Thread.Sleep(100);                      }                      catch (IOException ex)                      {                          throw new IndicatorError(ex);                      }                  }                    try                  {                      _listenSocket.Close();                  }                  catch (IOException ex)                  {                      throw new IndicatorError(ex);                  }              }              finally              {                  _running = false;              }
Magic Number,Encog.Cloud.Indicator.Server,IndicatorServer,C:\repos\encog_encog-dotnet-core\encog-core-cs\Cloud\Indicator\Server\IndicatorServer.cs,Run,The following statement contains a magic number: try              {                  _running = true;                  _listenSocket.Listen(5);                  while (_running)                  {                      try                      {                          EncogLogging.Log(EncogLogging.LevelDebug' "Begin listen");                          Socket connectionSocket = _listenSocket.Accept();                          EncogLogging.Log(EncogLogging.LevelDebug' "Connection from: " + connectionSocket.RemoteEndPoint);                          var link = new IndicatorLink(this' connectionSocket);                          NotifyListenersConnections(link' true);                          var hc = new HandleClient(this' link);                          _connections.Add(hc);                          var t = new Thread(hc.Run);                          t.Start();                      }                      catch (SocketException)                      {                          // just accept timing out                          Thread.Sleep(100);                      }                      catch (IOException ex)                      {                          throw new IndicatorError(ex);                      }                  }                    try                  {                      _listenSocket.Close();                  }                  catch (IOException ex)                  {                      throw new IndicatorError(ex);                  }              }              finally              {                  _running = false;              }
Magic Number,Encog.Cloud.Indicator.Server,IndicatorServer,C:\repos\encog_encog-dotnet-core\encog-core-cs\Cloud\Indicator\Server\IndicatorServer.cs,WaitForIndicatorCompletion,The following statement contains a magic number: while (_connections.Count == 0)              {                  Thread.Sleep(1000);              }
Magic Number,Encog.Cloud.Indicator.Server,IndicatorServer,C:\repos\encog_encog-dotnet-core\encog-core-cs\Cloud\Indicator\Server\IndicatorServer.cs,WaitForIndicatorCompletion,The following statement contains a magic number: while (_connections.Count != 0)              {                  Thread.Sleep(1000);              }
Magic Number,Encog.Cloud.Indicator.Server,IndicatorServer,C:\repos\encog_encog-dotnet-core\encog-core-cs\Cloud\Indicator\Server\IndicatorServer.cs,WaitForShutdown,The following statement contains a magic number: while (_running)              {                  Thread.Sleep(1000);              }
Magic Number,Encog.Engine.Network.Activation,ActivationClippedLinear,C:\repos\encog_encog-dotnet-core\encog-core-cs\Engine\Network\Activation\ActivationClippedLinear.cs,ActivationFunction,The following statement contains a magic number: for (int i = start; i < start + size; i++)              {                  d[i] = (2.0 / (1.0 + Math.Exp(-4.9 * d[i]))) - 1.0;              }
Magic Number,Encog.Engine.Network.Activation,ActivationClippedLinear,C:\repos\encog_encog-dotnet-core\encog-core-cs\Engine\Network\Activation\ActivationClippedLinear.cs,ActivationFunction,The following statement contains a magic number: for (int i = start; i < start + size; i++)              {                  d[i] = (2.0 / (1.0 + Math.Exp(-4.9 * d[i]))) - 1.0;              }
Magic Number,Encog.Engine.Network.Activation,ActivationElliott,C:\repos\encog_encog-dotnet-core\encog-core-cs\Engine\Network\Activation\ActivationElliott.cs,ActivationFunction,The following statement contains a magic number: for (int i = start; i < start + size; i++)              {                  double s = _p[0];                  x[i] = ((x[i]*s)/2)/(1 + Math.Abs(x[i]*s)) + 0.5;              }
Magic Number,Encog.Engine.Network.Activation,ActivationElliott,C:\repos\encog_encog-dotnet-core\encog-core-cs\Engine\Network\Activation\ActivationElliott.cs,ActivationFunction,The following statement contains a magic number: for (int i = start; i < start + size; i++)              {                  double s = _p[0];                  x[i] = ((x[i]*s)/2)/(1 + Math.Abs(x[i]*s)) + 0.5;              }
Magic Number,Encog.Engine.Network.Activation,ActivationElliott,C:\repos\encog_encog-dotnet-core\encog-core-cs\Engine\Network\Activation\ActivationElliott.cs,DerivativeFunction,The following statement contains a magic number: return s/(2.0*(1.0 + Math.Abs(b*s))*(1 + Math.Abs(b*s)));
Magic Number,Encog.Engine.Network.Activation,ActivationGaussian,C:\repos\encog_encog-dotnet-core\encog-core-cs\Engine\Network\Activation\ActivationGaussian.cs,ActivationFunction,The following statement contains a magic number: for (int i = start; i < start + size; i++)              {                  x[i] = BoundMath.Exp(-Math.Pow(2.5 * x[i]' 2.0));              }
Magic Number,Encog.Engine.Network.Activation,ActivationGaussian,C:\repos\encog_encog-dotnet-core\encog-core-cs\Engine\Network\Activation\ActivationGaussian.cs,ActivationFunction,The following statement contains a magic number: for (int i = start; i < start + size; i++)              {                  x[i] = BoundMath.Exp(-Math.Pow(2.5 * x[i]' 2.0));              }
Magic Number,Encog.Engine.Network.Activation,ActivationGaussian,C:\repos\encog_encog-dotnet-core\encog-core-cs\Engine\Network\Activation\ActivationGaussian.cs,DerivativeFunction,The following statement contains a magic number: return Math.Exp(Math.Pow(2.5 * b' 2.0) * 12.5 * b);
Magic Number,Encog.Engine.Network.Activation,ActivationGaussian,C:\repos\encog_encog-dotnet-core\encog-core-cs\Engine\Network\Activation\ActivationGaussian.cs,DerivativeFunction,The following statement contains a magic number: return Math.Exp(Math.Pow(2.5 * b' 2.0) * 12.5 * b);
Magic Number,Encog.Engine.Network.Activation,ActivationGaussian,C:\repos\encog_encog-dotnet-core\encog-core-cs\Engine\Network\Activation\ActivationGaussian.cs,DerivativeFunction,The following statement contains a magic number: return Math.Exp(Math.Pow(2.5 * b' 2.0) * 12.5 * b);
Magic Number,Encog.Engine.Network.Activation,ActivationRamp,C:\repos\encog_encog-dotnet-core\encog-core-cs\Engine\Network\Activation\ActivationRamp.cs,ActivationRamp,The following statement contains a magic number: _paras = new double[4];
Magic Number,Encog.Engine.Network.Activation,ActivationReLU,C:\repos\encog_encog-dotnet-core\encog-core-cs\Engine\Network\Activation\ActivationReLU.cs,ActivationReLU,The following statement contains a magic number: _params = new double[2];
Magic Number,Encog.Engine.Network.Activation,ActivationSIN,C:\repos\encog_encog-dotnet-core\encog-core-cs\Engine\Network\Activation\ActivationSIN.cs,ActivationFunction,The following statement contains a magic number: for (int i = start; i < start + size; i++)              {                  x[i] = BoundMath.Sin(2.0 * x[i]);              }
Magic Number,Encog.Engine.Network.Activation,ActivationSIN,C:\repos\encog_encog-dotnet-core\encog-core-cs\Engine\Network\Activation\ActivationSIN.cs,DerivativeFunction,The following statement contains a magic number: return BoundMath.Cos(2.0 * b);
Magic Number,Encog.Engine.Network.Activation,ActivationSteepenedSigmoid,C:\repos\encog_encog-dotnet-core\encog-core-cs\Engine\Network\Activation\ActivationSteepenedSigmoid.cs,ActivationFunction,The following statement contains a magic number: for (int i = start; i < start + size; i++)              {                  x[i] = 1.0 / (1.0 + Math.Exp(-4.9 * x[i]));              }
Magic Number,Encog.Engine.Network.Activation,ActivationSteepenedSigmoid,C:\repos\encog_encog-dotnet-core\encog-core-cs\Engine\Network\Activation\ActivationSteepenedSigmoid.cs,DerivativeFunction,The following statement contains a magic number: double s = Math.Exp(-4.9 * a);
Magic Number,Encog.Engine.Network.Activation,ActivationSteepenedSigmoid,C:\repos\encog_encog-dotnet-core\encog-core-cs\Engine\Network\Activation\ActivationSteepenedSigmoid.cs,DerivativeFunction,The following statement contains a magic number: return Math.Pow(s * 4.9 / (1 + s)' 2);
Magic Number,Encog.Engine.Network.Activation,ActivationSteepenedSigmoid,C:\repos\encog_encog-dotnet-core\encog-core-cs\Engine\Network\Activation\ActivationSteepenedSigmoid.cs,DerivativeFunction,The following statement contains a magic number: return Math.Pow(s * 4.9 / (1 + s)' 2);
Magic Number,Encog.Engine.Network.Activation,ActivationStep,C:\repos\encog_encog-dotnet-core\encog-core-cs\Engine\Network\Activation\ActivationStep.cs,ActivationStep,The following statement contains a magic number: _paras = new double[3];
Magic Number,Encog.Engine.Network.Activation,ActivationTANH,C:\repos\encog_encog-dotnet-core\encog-core-cs\Engine\Network\Activation\ActivationTANH.cs,ActivationFunction,The following statement contains a magic number: for (int i = start; i < start + size; i++)              {                  x[i] = 2.0 / (1.0 + BoundMath.Exp(-2.0 * x[i])) - 1.0; //3x faster than Math.Tanh(x[i]);              }
Magic Number,Encog.Engine.Network.Activation,ActivationTANH,C:\repos\encog_encog-dotnet-core\encog-core-cs\Engine\Network\Activation\ActivationTANH.cs,ActivationFunction,The following statement contains a magic number: for (int i = start; i < start + size; i++)              {                  x[i] = 2.0 / (1.0 + BoundMath.Exp(-2.0 * x[i])) - 1.0; //3x faster than Math.Tanh(x[i]);              }
Magic Number,Encog.MathUtil,ComplexNumber,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\ComplexNumber.cs,Sqrt,The following statement contains a magic number: double theta = Arg()/2;
Magic Number,Encog.MathUtil,ComplexNumber,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\ComplexNumber.cs,Cosh,The following statement contains a magic number: return (Math.Exp(theta) + Math.Exp(-theta))/2;
Magic Number,Encog.MathUtil,ComplexNumber,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\ComplexNumber.cs,Sinh,The following statement contains a magic number: return (Math.Exp(theta) - Math.Exp(-theta))/2;
Magic Number,Encog.MathUtil,ComplexNumber,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\ComplexNumber.cs,ToString,The following statement contains a magic number: if (_y == 0)              {                  return Format.FormatDouble(_x' 4);              }
Magic Number,Encog.MathUtil,EncogMath,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\EncogMath.cs,Deg2Rad,The following statement contains a magic number: return deg*(Math.PI/180.0);
Magic Number,Encog.MathUtil,EncogMath,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\EncogMath.cs,Rad2Deg,The following statement contains a magic number: return rad*(180.0/Math.PI);
Magic Number,Encog.MathUtil,NumericRange,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\NumericRange.cs,ToString,The following statement contains a magic number: result.Append(Format.FormatDouble(_low' 5));
Magic Number,Encog.MathUtil,NumericRange,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\NumericRange.cs,ToString,The following statement contains a magic number: result.Append(Format.FormatDouble(_high' 5));
Magic Number,Encog.MathUtil,NumericRange,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\NumericRange.cs,ToString,The following statement contains a magic number: result.Append(Format.FormatDouble(_mean' 5));
Magic Number,Encog.MathUtil,NumericRange,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\NumericRange.cs,ToString,The following statement contains a magic number: result.Append(Format.FormatDouble(_rms' 5));
Magic Number,Encog.MathUtil,NumericRange,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\NumericRange.cs,ToString,The following statement contains a magic number: result.Append(Format.FormatDouble(_standardDeviation' 5));
Magic Number,Encog.MathUtil,VectorAlgebra,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\VectorAlgebra.cs,Randomise,The following statement contains a magic number: Randomise(v' 0.1);
Magic Number,Encog.MathUtil,VectorAlgebra,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\VectorAlgebra.cs,Randomise,The following statement contains a magic number: for (int i = 0; i < v.Length; i++)              {                  v[i] = (2 * rand.NextDouble() - 1) * maxValue;              }
Magic Number,Encog.MathUtil,Equilateral,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Equilateral.cs,Equilat,The following statement contains a magic number: for (int k = 2; k < n; k++)              {                  // scale the matrix so far                  double r = k;                  double f = Math.Sqrt(r*r - 1.0)/r;                  for (int i = 0; i < k; i++)                  {                      for (int j = 0; j < k - 1; j++)                      {                          result[i][j] *= f;                      }                  }                    r = -1.0/r;                  for (int i = 0; i < k; i++)                  {                      result[i][k - 1] = r;                  }                    for (int i = 0; i < k - 1; i++)                  {                      result[k][i] = 0.0;                  }                  result[k][k - 1] = 1.0;              }
Magic Number,Encog.MathUtil.Error,ErrorCalculation,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Error\ErrorCalculation.cs,CalculateSSE,The following statement contains a magic number: return _globalError / 2;
Magic Number,Encog.MathUtil.LIBSVM,Cache,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,Cache,The following statement contains a magic number: size /= 4;
Magic Number,Encog.MathUtil.LIBSVM,Cache,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,Cache,The following statement contains a magic number: size -= l*(16/4);
Magic Number,Encog.MathUtil.LIBSVM,Cache,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,Cache,The following statement contains a magic number: size -= l*(16/4);
Magic Number,Encog.MathUtil.LIBSVM,Kernel,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,tanh,The following statement contains a magic number: return 1.0 - 2.0/(e*e + 1);
Magic Number,Encog.MathUtil.LIBSVM,Kernel,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,kernel_function,The following statement contains a magic number: switch (kernel_type)              {                  case svm_parameter.LINEAR:                      return dot(x[i]' x[j]);                    case svm_parameter.POLY:                      return Math.Pow(gamma*dot(x[i]' x[j]) + coef0' degree);                    case svm_parameter.RBF:                      return Math.Exp((- gamma)*(x_square[i] + x_square[j] - 2*dot(x[i]' x[j])));                    case svm_parameter.SIGMOID:                      return tanh(gamma*dot(x[i]' x[j]) + coef0);                    default:                      return 0; // java              }
Magic Number,Encog.MathUtil.LIBSVM,Solver,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,Solve,The following statement contains a magic number: int counter = Math.Min(l' 1000) + 1;
Magic Number,Encog.MathUtil.LIBSVM,Solver,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,Solve,The following statement contains a magic number: var working_set = new int[2];
Magic Number,Encog.MathUtil.LIBSVM,Solver,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,Solve,The following statement contains a magic number: while (true)              {                  // max iterations?                  if (iter > 10000)                      break;                  // show progress and do shrinking                    if (--counter == 0)                  {                      counter = Math.Min(l' 1000);                      if (shrinking != 0)                          do_shrinking();                      //Console.Error.Write(".");                  }                    if (select_working_set(working_set) != 0)                  {                      // reconstruct the whole gradient                      reconstruct_gradient();                      // reset active set size and check                      active_size = l;                      //Console.Error.Write("*");                      if (select_working_set(working_set) != 0)                          break;                      else                          counter = 1; // do shrinking next iteration                  }                    int i = working_set[0];                  int j = working_set[1];                    ++iter;                    // update alpha[i] and alpha[j]' handle bounds carefully                    float[] Q_i = Q.get_Q(i' active_size);                  float[] Q_j = Q.get_Q(j' active_size);                    double C_i = get_C(i);                  double C_j = get_C(j);                    double old_alpha_i = alpha[i];                  double old_alpha_j = alpha[j];                    if (y[i] != y[j])                  {                      double delta = (- G[i] - G[j])/Math.Max(Q_i[i] + Q_j[j] + 2*Q_i[j]' 0);                      double diff = alpha[i] - alpha[j];                      alpha[i] += delta;                      alpha[j] += delta;                        if (diff > 0)                      {                          if (alpha[j] < 0)                          {                              alpha[j] = 0;                              alpha[i] = diff;                          }                      }                      else                      {                          if (alpha[i] < 0)                          {                              alpha[i] = 0;                              alpha[j] = - diff;                          }                      }                      if (diff > C_i - C_j)                      {                          if (alpha[i] > C_i)                          {                              alpha[i] = C_i;                              alpha[j] = C_i - diff;                          }                      }                      else                      {                          if (alpha[j] > C_j)                          {                              alpha[j] = C_j;                              alpha[i] = C_j + diff;                          }                      }                  }                  else                  {                      double delta = (G[i] - G[j])/Math.Max(Q_i[i] + Q_j[j] - 2*Q_i[j]' 0);                      double sum = alpha[i] + alpha[j];                      alpha[i] -= delta;                      alpha[j] += delta;                      if (sum > C_i)                      {                          if (alpha[i] > C_i)                          {                              alpha[i] = C_i;                              alpha[j] = sum - C_i;                          }                      }                      else                      {                          if (alpha[j] < 0)                          {                              alpha[j] = 0;                              alpha[i] = sum;                          }                      }                      if (sum > C_j)                      {                          if (alpha[j] > C_j)                          {                              alpha[j] = C_j;                              alpha[i] = sum - C_j;                          }                      }                      else                      {                          if (alpha[i] < 0)                          {                              alpha[i] = 0;                              alpha[j] = sum;                          }                      }                  }                    // update G                    double delta_alpha_i = alpha[i] - old_alpha_i;                  double delta_alpha_j = alpha[j] - old_alpha_j;                    for (int k = 0; k < active_size; k++)                  {                      G[k] += Q_i[k]*delta_alpha_i + Q_j[k]*delta_alpha_j;                  }                    // update alpha_status and G_bar                    {                      bool ui = is_upper_bound(i);                      bool uj = is_upper_bound(j);                      update_alpha_status(i);                      update_alpha_status(j);                      int k;                      if (ui != is_upper_bound(i))                      {                          Q_i = Q.get_Q(i' l);                          if (ui)                              for (k = 0; k < l; k++)                                  G_bar[k] -= C_i*Q_i[k];                          else                              for (k = 0; k < l; k++)                                  G_bar[k] += C_i*Q_i[k];                      }                        if (uj != is_upper_bound(j))                      {                          Q_j = Q.get_Q(j' l);                          if (uj)                              for (k = 0; k < l; k++)                                  G_bar[k] -= C_j*Q_j[k];                          else                              for (k = 0; k < l; k++)                                  G_bar[k] += C_j*Q_j[k];                      }                  }              }
Magic Number,Encog.MathUtil.LIBSVM,Solver,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,Solve,The following statement contains a magic number: while (true)              {                  // max iterations?                  if (iter > 10000)                      break;                  // show progress and do shrinking                    if (--counter == 0)                  {                      counter = Math.Min(l' 1000);                      if (shrinking != 0)                          do_shrinking();                      //Console.Error.Write(".");                  }                    if (select_working_set(working_set) != 0)                  {                      // reconstruct the whole gradient                      reconstruct_gradient();                      // reset active set size and check                      active_size = l;                      //Console.Error.Write("*");                      if (select_working_set(working_set) != 0)                          break;                      else                          counter = 1; // do shrinking next iteration                  }                    int i = working_set[0];                  int j = working_set[1];                    ++iter;                    // update alpha[i] and alpha[j]' handle bounds carefully                    float[] Q_i = Q.get_Q(i' active_size);                  float[] Q_j = Q.get_Q(j' active_size);                    double C_i = get_C(i);                  double C_j = get_C(j);                    double old_alpha_i = alpha[i];                  double old_alpha_j = alpha[j];                    if (y[i] != y[j])                  {                      double delta = (- G[i] - G[j])/Math.Max(Q_i[i] + Q_j[j] + 2*Q_i[j]' 0);                      double diff = alpha[i] - alpha[j];                      alpha[i] += delta;                      alpha[j] += delta;                        if (diff > 0)                      {                          if (alpha[j] < 0)                          {                              alpha[j] = 0;                              alpha[i] = diff;                          }                      }                      else                      {                          if (alpha[i] < 0)                          {                              alpha[i] = 0;                              alpha[j] = - diff;                          }                      }                      if (diff > C_i - C_j)                      {                          if (alpha[i] > C_i)                          {                              alpha[i] = C_i;                              alpha[j] = C_i - diff;                          }                      }                      else                      {                          if (alpha[j] > C_j)                          {                              alpha[j] = C_j;                              alpha[i] = C_j + diff;                          }                      }                  }                  else                  {                      double delta = (G[i] - G[j])/Math.Max(Q_i[i] + Q_j[j] - 2*Q_i[j]' 0);                      double sum = alpha[i] + alpha[j];                      alpha[i] -= delta;                      alpha[j] += delta;                      if (sum > C_i)                      {                          if (alpha[i] > C_i)                          {                              alpha[i] = C_i;                              alpha[j] = sum - C_i;                          }                      }                      else                      {                          if (alpha[j] < 0)                          {                              alpha[j] = 0;                              alpha[i] = sum;                          }                      }                      if (sum > C_j)                      {                          if (alpha[j] > C_j)                          {                              alpha[j] = C_j;                              alpha[i] = sum - C_j;                          }                      }                      else                      {                          if (alpha[i] < 0)                          {                              alpha[i] = 0;                              alpha[j] = sum;                          }                      }                  }                    // update G                    double delta_alpha_i = alpha[i] - old_alpha_i;                  double delta_alpha_j = alpha[j] - old_alpha_j;                    for (int k = 0; k < active_size; k++)                  {                      G[k] += Q_i[k]*delta_alpha_i + Q_j[k]*delta_alpha_j;                  }                    // update alpha_status and G_bar                    {                      bool ui = is_upper_bound(i);                      bool uj = is_upper_bound(j);                      update_alpha_status(i);                      update_alpha_status(j);                      int k;                      if (ui != is_upper_bound(i))                      {                          Q_i = Q.get_Q(i' l);                          if (ui)                              for (k = 0; k < l; k++)                                  G_bar[k] -= C_i*Q_i[k];                          else                              for (k = 0; k < l; k++)                                  G_bar[k] += C_i*Q_i[k];                      }                        if (uj != is_upper_bound(j))                      {                          Q_j = Q.get_Q(j' l);                          if (uj)                              for (k = 0; k < l; k++)                                  G_bar[k] -= C_j*Q_j[k];                          else                              for (k = 0; k < l; k++)                                  G_bar[k] += C_j*Q_j[k];                      }                  }              }
Magic Number,Encog.MathUtil.LIBSVM,Solver,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,Solve,The following statement contains a magic number: while (true)              {                  // max iterations?                  if (iter > 10000)                      break;                  // show progress and do shrinking                    if (--counter == 0)                  {                      counter = Math.Min(l' 1000);                      if (shrinking != 0)                          do_shrinking();                      //Console.Error.Write(".");                  }                    if (select_working_set(working_set) != 0)                  {                      // reconstruct the whole gradient                      reconstruct_gradient();                      // reset active set size and check                      active_size = l;                      //Console.Error.Write("*");                      if (select_working_set(working_set) != 0)                          break;                      else                          counter = 1; // do shrinking next iteration                  }                    int i = working_set[0];                  int j = working_set[1];                    ++iter;                    // update alpha[i] and alpha[j]' handle bounds carefully                    float[] Q_i = Q.get_Q(i' active_size);                  float[] Q_j = Q.get_Q(j' active_size);                    double C_i = get_C(i);                  double C_j = get_C(j);                    double old_alpha_i = alpha[i];                  double old_alpha_j = alpha[j];                    if (y[i] != y[j])                  {                      double delta = (- G[i] - G[j])/Math.Max(Q_i[i] + Q_j[j] + 2*Q_i[j]' 0);                      double diff = alpha[i] - alpha[j];                      alpha[i] += delta;                      alpha[j] += delta;                        if (diff > 0)                      {                          if (alpha[j] < 0)                          {                              alpha[j] = 0;                              alpha[i] = diff;                          }                      }                      else                      {                          if (alpha[i] < 0)                          {                              alpha[i] = 0;                              alpha[j] = - diff;                          }                      }                      if (diff > C_i - C_j)                      {                          if (alpha[i] > C_i)                          {                              alpha[i] = C_i;                              alpha[j] = C_i - diff;                          }                      }                      else                      {                          if (alpha[j] > C_j)                          {                              alpha[j] = C_j;                              alpha[i] = C_j + diff;                          }                      }                  }                  else                  {                      double delta = (G[i] - G[j])/Math.Max(Q_i[i] + Q_j[j] - 2*Q_i[j]' 0);                      double sum = alpha[i] + alpha[j];                      alpha[i] -= delta;                      alpha[j] += delta;                      if (sum > C_i)                      {                          if (alpha[i] > C_i)                          {                              alpha[i] = C_i;                              alpha[j] = sum - C_i;                          }                      }                      else                      {                          if (alpha[j] < 0)                          {                              alpha[j] = 0;                              alpha[i] = sum;                          }                      }                      if (sum > C_j)                      {                          if (alpha[j] > C_j)                          {                              alpha[j] = C_j;                              alpha[i] = sum - C_j;                          }                      }                      else                      {                          if (alpha[i] < 0)                          {                              alpha[i] = 0;                              alpha[j] = sum;                          }                      }                  }                    // update G                    double delta_alpha_i = alpha[i] - old_alpha_i;                  double delta_alpha_j = alpha[j] - old_alpha_j;                    for (int k = 0; k < active_size; k++)                  {                      G[k] += Q_i[k]*delta_alpha_i + Q_j[k]*delta_alpha_j;                  }                    // update alpha_status and G_bar                    {                      bool ui = is_upper_bound(i);                      bool uj = is_upper_bound(j);                      update_alpha_status(i);                      update_alpha_status(j);                      int k;                      if (ui != is_upper_bound(i))                      {                          Q_i = Q.get_Q(i' l);                          if (ui)                              for (k = 0; k < l; k++)                                  G_bar[k] -= C_i*Q_i[k];                          else                              for (k = 0; k < l; k++)                                  G_bar[k] += C_i*Q_i[k];                      }                        if (uj != is_upper_bound(j))                      {                          Q_j = Q.get_Q(j' l);                          if (uj)                              for (k = 0; k < l; k++)                                  G_bar[k] -= C_j*Q_j[k];                          else                              for (k = 0; k < l; k++)                                  G_bar[k] += C_j*Q_j[k];                      }                  }              }
Magic Number,Encog.MathUtil.LIBSVM,Solver,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,Solve,The following statement contains a magic number: while (true)              {                  // max iterations?                  if (iter > 10000)                      break;                  // show progress and do shrinking                    if (--counter == 0)                  {                      counter = Math.Min(l' 1000);                      if (shrinking != 0)                          do_shrinking();                      //Console.Error.Write(".");                  }                    if (select_working_set(working_set) != 0)                  {                      // reconstruct the whole gradient                      reconstruct_gradient();                      // reset active set size and check                      active_size = l;                      //Console.Error.Write("*");                      if (select_working_set(working_set) != 0)                          break;                      else                          counter = 1; // do shrinking next iteration                  }                    int i = working_set[0];                  int j = working_set[1];                    ++iter;                    // update alpha[i] and alpha[j]' handle bounds carefully                    float[] Q_i = Q.get_Q(i' active_size);                  float[] Q_j = Q.get_Q(j' active_size);                    double C_i = get_C(i);                  double C_j = get_C(j);                    double old_alpha_i = alpha[i];                  double old_alpha_j = alpha[j];                    if (y[i] != y[j])                  {                      double delta = (- G[i] - G[j])/Math.Max(Q_i[i] + Q_j[j] + 2*Q_i[j]' 0);                      double diff = alpha[i] - alpha[j];                      alpha[i] += delta;                      alpha[j] += delta;                        if (diff > 0)                      {                          if (alpha[j] < 0)                          {                              alpha[j] = 0;                              alpha[i] = diff;                          }                      }                      else                      {                          if (alpha[i] < 0)                          {                              alpha[i] = 0;                              alpha[j] = - diff;                          }                      }                      if (diff > C_i - C_j)                      {                          if (alpha[i] > C_i)                          {                              alpha[i] = C_i;                              alpha[j] = C_i - diff;                          }                      }                      else                      {                          if (alpha[j] > C_j)                          {                              alpha[j] = C_j;                              alpha[i] = C_j + diff;                          }                      }                  }                  else                  {                      double delta = (G[i] - G[j])/Math.Max(Q_i[i] + Q_j[j] - 2*Q_i[j]' 0);                      double sum = alpha[i] + alpha[j];                      alpha[i] -= delta;                      alpha[j] += delta;                      if (sum > C_i)                      {                          if (alpha[i] > C_i)                          {                              alpha[i] = C_i;                              alpha[j] = sum - C_i;                          }                      }                      else                      {                          if (alpha[j] < 0)                          {                              alpha[j] = 0;                              alpha[i] = sum;                          }                      }                      if (sum > C_j)                      {                          if (alpha[j] > C_j)                          {                              alpha[j] = C_j;                              alpha[i] = sum - C_j;                          }                      }                      else                      {                          if (alpha[i] < 0)                          {                              alpha[i] = 0;                              alpha[j] = sum;                          }                      }                  }                    // update G                    double delta_alpha_i = alpha[i] - old_alpha_i;                  double delta_alpha_j = alpha[j] - old_alpha_j;                    for (int k = 0; k < active_size; k++)                  {                      G[k] += Q_i[k]*delta_alpha_i + Q_j[k]*delta_alpha_j;                  }                    // update alpha_status and G_bar                    {                      bool ui = is_upper_bound(i);                      bool uj = is_upper_bound(j);                      update_alpha_status(i);                      update_alpha_status(j);                      int k;                      if (ui != is_upper_bound(i))                      {                          Q_i = Q.get_Q(i' l);                          if (ui)                              for (k = 0; k < l; k++)                                  G_bar[k] -= C_i*Q_i[k];                          else                              for (k = 0; k < l; k++)                                  G_bar[k] += C_i*Q_i[k];                      }                        if (uj != is_upper_bound(j))                      {                          Q_j = Q.get_Q(j' l);                          if (uj)                              for (k = 0; k < l; k++)                                  G_bar[k] -= C_j*Q_j[k];                          else                              for (k = 0; k < l; k++)                                  G_bar[k] += C_j*Q_j[k];                      }                  }              }
Magic Number,Encog.MathUtil.LIBSVM,Solver,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,Solve,The following statement contains a magic number: {                  double v = 0;                  int i;                  for (i = 0; i < l; i++)                      v += alpha[i]*(G[i] + b[i]);                    si.obj = v/2;              }
Magic Number,Encog.MathUtil.LIBSVM,Solver,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,do_shrinking,The following statement contains a magic number: var working_set = new int[2];
Magic Number,Encog.MathUtil.LIBSVM,Solver,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,do_shrinking,The following statement contains a magic number: if (unshrinked || - (Gm1 + Gm2) > eps*10)                  return;
Magic Number,Encog.MathUtil.LIBSVM,Solver,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,calculate_rho,The following statement contains a magic number: if (nr_free > 0)                  r = sum_free/nr_free;              else                  r = (ub + lb)/2;
Magic Number,Encog.MathUtil.LIBSVM,Solver_NU,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,do_shrinking,The following statement contains a magic number: if (unshrinked || Math.Max(- (Gm1 + Gm2)' - (Gm3 + Gm4)) > eps*10)                  return;
Magic Number,Encog.MathUtil.LIBSVM,Solver_NU,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,calculate_rho,The following statement contains a magic number: if (nr_free1 > 0)                  r1 = sum_free1/nr_free1;              else                  r1 = (ub1 + lb1)/2;
Magic Number,Encog.MathUtil.LIBSVM,Solver_NU,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,calculate_rho,The following statement contains a magic number: if (nr_free2 > 0)                  r2 = sum_free2/nr_free2;              else                  r2 = (ub2 + lb2)/2;
Magic Number,Encog.MathUtil.LIBSVM,Solver_NU,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,calculate_rho,The following statement contains a magic number: si.r = (r1 + r2)/2;
Magic Number,Encog.MathUtil.LIBSVM,Solver_NU,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,calculate_rho,The following statement contains a magic number: return (r1 - r2)/2;
Magic Number,Encog.MathUtil.LIBSVM,SVC_Q,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,SVC_Q,The following statement contains a magic number: cache = new Cache(prob.l' (int) (param.cache_size*(1 << 20)));
Magic Number,Encog.MathUtil.LIBSVM,ONE_CLASS_Q,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,ONE_CLASS_Q,The following statement contains a magic number: cache = new Cache(prob.l' (int) (param.cache_size*(1 << 20)));
Magic Number,Encog.MathUtil.LIBSVM,SVR_Q,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,SVR_Q,The following statement contains a magic number: cache = new Cache(l' (int) (param.cache_size*(1 << 20)));
Magic Number,Encog.MathUtil.LIBSVM,SVR_Q,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,SVR_Q,The following statement contains a magic number: sign = new sbyte[2*l];
Magic Number,Encog.MathUtil.LIBSVM,SVR_Q,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,SVR_Q,The following statement contains a magic number: index = new int[2*l];
Magic Number,Encog.MathUtil.LIBSVM,SVR_Q,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,SVR_Q,The following statement contains a magic number: buffer = new float[2][];
Magic Number,Encog.MathUtil.LIBSVM,SVR_Q,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,SVR_Q,The following statement contains a magic number: for (int i = 0; i < 2; i++)              {                  buffer[i] = new float[2*l];              }
Magic Number,Encog.MathUtil.LIBSVM,SVR_Q,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,SVR_Q,The following statement contains a magic number: for (int i = 0; i < 2; i++)              {                  buffer[i] = new float[2*l];              }
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,solve_nu_svc,The following statement contains a magic number: double sum_pos = nu*l/2;
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,solve_nu_svc,The following statement contains a magic number: double sum_neg = nu*l/2;
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,solve_epsilon_svr,The following statement contains a magic number: var alpha2 = new double[2*l];
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,solve_epsilon_svr,The following statement contains a magic number: var linear_term = new double[2*l];
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,solve_epsilon_svr,The following statement contains a magic number: var y = new sbyte[2*l];
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,solve_epsilon_svr,The following statement contains a magic number: s.Solve(2*l' new SVR_Q(prob' param)' linear_term' y' alpha2' param.C' param.C' param.eps' si'                      param.shrinking);
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,solve_nu_svr,The following statement contains a magic number: var alpha2 = new double[2*l];
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,solve_nu_svr,The following statement contains a magic number: var linear_term = new double[2*l];
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,solve_nu_svr,The following statement contains a magic number: var y = new sbyte[2*l];
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,solve_nu_svr,The following statement contains a magic number: double sum = C*param.nu*l/2;
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,solve_nu_svr,The following statement contains a magic number: s.Solve(2*l' new SVR_Q(prob' param)' linear_term' y' alpha2' C' C' param.eps' si' param.shrinking);
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,sigmoid_train,The following statement contains a magic number: int max_iter = 100;
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,sigmoid_train,The following statement contains a magic number: double min_step = 1e-10;
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,sigmoid_train,The following statement contains a magic number: double sigma = 1e-3;
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,sigmoid_train,The following statement contains a magic number: double eps = 1e-5;
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,sigmoid_train,The following statement contains a magic number: double hiTarget = (prior1 + 1.0)/(prior1 + 2.0);
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,sigmoid_train,The following statement contains a magic number: double loTarget = 1/(prior0 + 2.0);
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,sigmoid_train,The following statement contains a magic number: for (iter = 0; iter < max_iter; iter++)              {                  // Update Gradient and Hessian (use H' = H + sigma I)                  h11 = sigma; // numerically ensures strict PD                  h22 = sigma;                  h21 = 0.0;                  g1 = 0.0;                  g2 = 0.0;                  for (i = 0; i < l; i++)                  {                      fApB = dec_values[i]*A + B;                      if (fApB >= 0)                      {                          p = Math.Exp(- fApB)/(1.0 + Math.Exp(- fApB));                          q = 1.0/(1.0 + Math.Exp(- fApB));                      }                      else                      {                          p = 1.0/(1.0 + Math.Exp(fApB));                          q = Math.Exp(fApB)/(1.0 + Math.Exp(fApB));                      }                      d2 = p*q;                      h11 += dec_values[i]*dec_values[i]*d2;                      h22 += d2;                      h21 += dec_values[i]*d2;                      d1 = t[i] - p;                      g1 += dec_values[i]*d1;                      g2 += d1;                  }                    // Stopping Criteria                  if (Math.Abs(g1) < eps && Math.Abs(g2) < eps)                      break;                    // Finding Newton direction: -inv(H') * g                  det = h11*h22 - h21*h21;                  dA = (- (h22*g1 - h21*g2))/det;                  dB = (- ((- h21)*g1 + h11*g2))/det;                  gd = g1*dA + g2*dB;                      stepsize = 1; // Line Search                  while (stepsize >= min_step)                  {                      newA = A + stepsize*dA;                      newB = B + stepsize*dB;                        // New function value                      newf = 0.0;                      for (i = 0; i < l; i++)                      {                          fApB = dec_values[i]*newA + newB;                          if (fApB >= 0)                              newf += t[i]*fApB + Math.Log(1 + Math.Exp(- fApB));                          else                              newf += (t[i] - 1)*fApB + Math.Log(1 + Math.Exp(fApB));                      }                      // Check sufficient decrease                      if (newf < fval + 0.0001*stepsize*gd)                      {                          A = newA;                          B = newB;                          fval = newf;                          break;                      }                      else                          stepsize = stepsize/2.0;                  }                    if (stepsize < min_step)                  {                      //Console.Error.Write("Line search fails in two-class probability estimates\n");                      break;                  }              }
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,sigmoid_train,The following statement contains a magic number: for (iter = 0; iter < max_iter; iter++)              {                  // Update Gradient and Hessian (use H' = H + sigma I)                  h11 = sigma; // numerically ensures strict PD                  h22 = sigma;                  h21 = 0.0;                  g1 = 0.0;                  g2 = 0.0;                  for (i = 0; i < l; i++)                  {                      fApB = dec_values[i]*A + B;                      if (fApB >= 0)                      {                          p = Math.Exp(- fApB)/(1.0 + Math.Exp(- fApB));                          q = 1.0/(1.0 + Math.Exp(- fApB));                      }                      else                      {                          p = 1.0/(1.0 + Math.Exp(fApB));                          q = Math.Exp(fApB)/(1.0 + Math.Exp(fApB));                      }                      d2 = p*q;                      h11 += dec_values[i]*dec_values[i]*d2;                      h22 += d2;                      h21 += dec_values[i]*d2;                      d1 = t[i] - p;                      g1 += dec_values[i]*d1;                      g2 += d1;                  }                    // Stopping Criteria                  if (Math.Abs(g1) < eps && Math.Abs(g2) < eps)                      break;                    // Finding Newton direction: -inv(H') * g                  det = h11*h22 - h21*h21;                  dA = (- (h22*g1 - h21*g2))/det;                  dB = (- ((- h21)*g1 + h11*g2))/det;                  gd = g1*dA + g2*dB;                      stepsize = 1; // Line Search                  while (stepsize >= min_step)                  {                      newA = A + stepsize*dA;                      newB = B + stepsize*dB;                        // New function value                      newf = 0.0;                      for (i = 0; i < l; i++)                      {                          fApB = dec_values[i]*newA + newB;                          if (fApB >= 0)                              newf += t[i]*fApB + Math.Log(1 + Math.Exp(- fApB));                          else                              newf += (t[i] - 1)*fApB + Math.Log(1 + Math.Exp(fApB));                      }                      // Check sufficient decrease                      if (newf < fval + 0.0001*stepsize*gd)                      {                          A = newA;                          B = newB;                          fval = newf;                          break;                      }                      else                          stepsize = stepsize/2.0;                  }                    if (stepsize < min_step)                  {                      //Console.Error.Write("Line search fails in two-class probability estimates\n");                      break;                  }              }
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,multiclass_probability,The following statement contains a magic number: int iter = 0' max_iter = 100;
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,multiclass_probability,The following statement contains a magic number: double pQp' eps = 0.001;
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,multiclass_probability,The following statement contains a magic number: for (iter = 0; iter < max_iter; iter++)              {                  // stopping condition' recalculate QP'pQP for numerical accuracy                  pQp = 0;                  for (t = 0; t < k; t++)                  {                      Qp[t] = 0;                      for (int j = 0; j < k; j++)                          Qp[t] += Q[t][j]*p[j];                      pQp += p[t]*Qp[t];                  }                  double max_error = 0;                  for (t = 0; t < k; t++)                  {                      double error = Math.Abs(Qp[t] - pQp);                      if (error > max_error)                          max_error = error;                  }                  if (max_error < eps)                      break;                    for (t = 0; t < k; t++)                  {                      double diff = (- Qp[t] + pQp)/Q[t][t];                      p[t] += diff;                      pQp = (pQp + diff*(diff*Q[t][t] + 2*Qp[t]))/(1 + diff)/(1 + diff);                      for (int j = 0; j < k; j++)                      {                          Qp[j] = (Qp[j] + diff*Q[t][j])/(1 + diff);                          p[j] /= (1 + diff);                      }                  }              }
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_binary_svc_probability,The following statement contains a magic number: int nr_fold = 5;
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_binary_svc_probability,The following statement contains a magic number: for (i = 0; i < nr_fold; i++)              {                  int begin = i*prob.l/nr_fold;                  int end = (i + 1)*prob.l/nr_fold;                  int j' k;                  var subprob = new svm_problem();                    subprob.l = prob.l - (end - begin);                  subprob.x = new svm_node[subprob.l][];                  subprob.y = new double[subprob.l];                    k = 0;                  for (j = 0; j < begin; j++)                  {                      subprob.x[k] = prob.x[perm[j]];                      subprob.y[k] = prob.y[perm[j]];                      ++k;                  }                  for (j = end; j < prob.l; j++)                  {                      subprob.x[k] = prob.x[perm[j]];                      subprob.y[k] = prob.y[perm[j]];                      ++k;                  }                  int p_count = 0' n_count = 0;                  for (j = 0; j < k; j++)                      if (subprob.y[j] > 0)                          p_count++;                      else                          n_count++;                    if (p_count == 0 && n_count == 0)                      for (j = begin; j < end; j++)                          dec_values[perm[j]] = 0;                  else if (p_count > 0 && n_count == 0)                      for (j = begin; j < end; j++)                          dec_values[perm[j]] = 1;                  else if (p_count == 0 && n_count > 0)                      for (j = begin; j < end; j++)                          dec_values[perm[j]] = - 1;                  else                  {                      var subparam = (svm_parameter) param.Clone();                      subparam.probability = 0;                      subparam.C = 1.0;                      subparam.nr_weight = 2;                      subparam.weight_label = new int[2];                      subparam.weight = new double[2];                      subparam.weight_label[0] = + 1;                      subparam.weight_label[1] = - 1;                      subparam.weight[0] = Cp;                      subparam.weight[1] = Cn;                      svm_model submodel = svm_train(subprob' subparam);                      for (j = begin; j < end; j++)                      {                          var dec_value = new double[1];                          svm_predict_values(submodel' prob.x[perm[j]]' dec_value);                          dec_values[perm[j]] = dec_value[0];                          // ensure +1 -1 order; reason not using CV subroutine                          dec_values[perm[j]] *= submodel.label[0];                      }                  }              }
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_binary_svc_probability,The following statement contains a magic number: for (i = 0; i < nr_fold; i++)              {                  int begin = i*prob.l/nr_fold;                  int end = (i + 1)*prob.l/nr_fold;                  int j' k;                  var subprob = new svm_problem();                    subprob.l = prob.l - (end - begin);                  subprob.x = new svm_node[subprob.l][];                  subprob.y = new double[subprob.l];                    k = 0;                  for (j = 0; j < begin; j++)                  {                      subprob.x[k] = prob.x[perm[j]];                      subprob.y[k] = prob.y[perm[j]];                      ++k;                  }                  for (j = end; j < prob.l; j++)                  {                      subprob.x[k] = prob.x[perm[j]];                      subprob.y[k] = prob.y[perm[j]];                      ++k;                  }                  int p_count = 0' n_count = 0;                  for (j = 0; j < k; j++)                      if (subprob.y[j] > 0)                          p_count++;                      else                          n_count++;                    if (p_count == 0 && n_count == 0)                      for (j = begin; j < end; j++)                          dec_values[perm[j]] = 0;                  else if (p_count > 0 && n_count == 0)                      for (j = begin; j < end; j++)                          dec_values[perm[j]] = 1;                  else if (p_count == 0 && n_count > 0)                      for (j = begin; j < end; j++)                          dec_values[perm[j]] = - 1;                  else                  {                      var subparam = (svm_parameter) param.Clone();                      subparam.probability = 0;                      subparam.C = 1.0;                      subparam.nr_weight = 2;                      subparam.weight_label = new int[2];                      subparam.weight = new double[2];                      subparam.weight_label[0] = + 1;                      subparam.weight_label[1] = - 1;                      subparam.weight[0] = Cp;                      subparam.weight[1] = Cn;                      svm_model submodel = svm_train(subprob' subparam);                      for (j = begin; j < end; j++)                      {                          var dec_value = new double[1];                          svm_predict_values(submodel' prob.x[perm[j]]' dec_value);                          dec_values[perm[j]] = dec_value[0];                          // ensure +1 -1 order; reason not using CV subroutine                          dec_values[perm[j]] *= submodel.label[0];                      }                  }              }
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_binary_svc_probability,The following statement contains a magic number: for (i = 0; i < nr_fold; i++)              {                  int begin = i*prob.l/nr_fold;                  int end = (i + 1)*prob.l/nr_fold;                  int j' k;                  var subprob = new svm_problem();                    subprob.l = prob.l - (end - begin);                  subprob.x = new svm_node[subprob.l][];                  subprob.y = new double[subprob.l];                    k = 0;                  for (j = 0; j < begin; j++)                  {                      subprob.x[k] = prob.x[perm[j]];                      subprob.y[k] = prob.y[perm[j]];                      ++k;                  }                  for (j = end; j < prob.l; j++)                  {                      subprob.x[k] = prob.x[perm[j]];                      subprob.y[k] = prob.y[perm[j]];                      ++k;                  }                  int p_count = 0' n_count = 0;                  for (j = 0; j < k; j++)                      if (subprob.y[j] > 0)                          p_count++;                      else                          n_count++;                    if (p_count == 0 && n_count == 0)                      for (j = begin; j < end; j++)                          dec_values[perm[j]] = 0;                  else if (p_count > 0 && n_count == 0)                      for (j = begin; j < end; j++)                          dec_values[perm[j]] = 1;                  else if (p_count == 0 && n_count > 0)                      for (j = begin; j < end; j++)                          dec_values[perm[j]] = - 1;                  else                  {                      var subparam = (svm_parameter) param.Clone();                      subparam.probability = 0;                      subparam.C = 1.0;                      subparam.nr_weight = 2;                      subparam.weight_label = new int[2];                      subparam.weight = new double[2];                      subparam.weight_label[0] = + 1;                      subparam.weight_label[1] = - 1;                      subparam.weight[0] = Cp;                      subparam.weight[1] = Cn;                      svm_model submodel = svm_train(subprob' subparam);                      for (j = begin; j < end; j++)                      {                          var dec_value = new double[1];                          svm_predict_values(submodel' prob.x[perm[j]]' dec_value);                          dec_values[perm[j]] = dec_value[0];                          // ensure +1 -1 order; reason not using CV subroutine                          dec_values[perm[j]] *= submodel.label[0];                      }                  }              }
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_svr_probability,The following statement contains a magic number: int nr_fold = 5;
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_svr_probability,The following statement contains a magic number: double std = Math.Sqrt(2*mae*mae);
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_svr_probability,The following statement contains a magic number: for (i = 0; i < prob.l; i++)                  if (Math.Abs(ymv[i]) > 5*std)                      count = count + 1;                  else                      mae += Math.Abs(ymv[i]);
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_train,The following statement contains a magic number: if (param.svm_type == svm_parameter.ONE_CLASS || param.svm_type == svm_parameter.EPSILON_SVR ||                  param.svm_type == svm_parameter.NU_SVR)              {                  // regression or one-class-svm                  model.nr_class = 2;                  model.label = null;                  model.nSV = null;                  model.probA = null;                  model.probB = null;                  model.sv_coef = new double[1][];                    if (param.probability == 1 &&                      (param.svm_type == svm_parameter.EPSILON_SVR || param.svm_type == svm_parameter.NU_SVR))                  {                      model.probA = new double[1];                      model.probA[0] = svm_svr_probability(prob' param);                  }                    decision_function f = svm_train_one(prob' param' 0' 0);                  model.rho = new double[1];                  model.rho[0] = f.rho;                    int nSV = 0;                  int i;                  for (i = 0; i < prob.l; i++)                      if (Math.Abs(f.alpha[i]) > 0)                          ++nSV;                  model.l = nSV;                  model.SV = new svm_node[nSV][];                  model.sv_coef[0] = new double[nSV];                  int j = 0;                  for (i = 0; i < prob.l; i++)                      if (Math.Abs(f.alpha[i]) > 0)                      {                          model.SV[j] = prob.x[i];                          model.sv_coef[0][j] = f.alpha[i];                          ++j;                      }              }              else              {                  // classification                  // find out the number of classes                  int l = prob.l;                  int max_nr_class = 16;                  int nr_class = 0;                  var label = new int[max_nr_class];                  var count = new int[max_nr_class];                  var index = new int[l];                    int i;                  for (i = 0; i < l; i++)                  {                      //UPGRADE_WARNING: Data types in Visual C# might be different.  Verify the accuracy of narrowing conversions. 'ms-help://MS.VSCC.2003/commoner/redir/redirect.htm?keyword="jlca1042_3"'                      var this_label = (int) prob.y[i];                      int j;                      for (j = 0; j < nr_class; j++)                          if (this_label == label[j])                          {                              ++count[j];                              break;                          }                      index[i] = j;                      if (j == nr_class)                      {                          if (nr_class == max_nr_class)                          {                              max_nr_class *= 2;                              var new_data = new int[max_nr_class];                              Array.Copy(label' 0' new_data' 0' label.Length);                              label = new_data;                                new_data = new int[max_nr_class];                              Array.Copy(count' 0' new_data' 0' count.Length);                              count = new_data;                          }                          label[nr_class] = this_label;                          count[nr_class] = 1;                          ++nr_class;                      }                  }                    // group training data of the same class                    var start = new int[nr_class];                  start[0] = 0;                  for (i = 1; i < nr_class; i++)                      start[i] = start[i - 1] + count[i - 1];                    var x = new svm_node[l][];                    for (i = 0; i < l; i++)                  {                      x[start[index[i]]] = prob.x[i];                      ++start[index[i]];                  }                    start[0] = 0;                  for (i = 1; i < nr_class; i++)                      start[i] = start[i - 1] + count[i - 1];                    // calculate weighted C                    var weighted_C = new double[nr_class];                  for (i = 0; i < nr_class; i++)                      weighted_C[i] = param.C;                  for (i = 0; i < param.nr_weight; i++)                  {                      int j;                      for (j = 0; j < nr_class; j++)                          if (param.weight_label[i] == label[j])                              break;                      if (j == nr_class) ;                      /*Console.Error.Write("warning: class label " + param.weight_label[i] +                                          " specified in weight is not found\n");*/                      else                          weighted_C[j] *= param.weight[i];                  }                    // train k*(k-1)/2 models                    var nonzero = new bool[l];                  for (i = 0; i < l; i++)                      nonzero[i] = false;                  var f = new decision_function[nr_class*(nr_class - 1)/2];                    double[] probA = null' probB = null;                  if (param.probability == 1)                  {                      probA = new double[nr_class*(nr_class - 1)/2];                      probB = new double[nr_class*(nr_class - 1)/2];                  }                    int p = 0;                  for (i = 0; i < nr_class; i++)                      for (int j = i + 1; j < nr_class; j++)                      {                          var sub_prob = new svm_problem();                          int si = start[i]' sj = start[j];                          int ci = count[i]' cj = count[j];                          sub_prob.l = ci + cj;                          sub_prob.x = new svm_node[sub_prob.l][];                          sub_prob.y = new double[sub_prob.l];                          int k;                          for (k = 0; k < ci; k++)                          {                              sub_prob.x[k] = x[si + k];                              sub_prob.y[k] = + 1;                          }                          for (k = 0; k < cj; k++)                          {                              sub_prob.x[ci + k] = x[sj + k];                              sub_prob.y[ci + k] = - 1;                          }                            if (param.probability == 1)                          {                              var probAB = new double[2];                              svm_binary_svc_probability(sub_prob' param' weighted_C[i]' weighted_C[j]' probAB);                              probA[p] = probAB[0];                              probB[p] = probAB[1];                          }                            f[p] = svm_train_one(sub_prob' param' weighted_C[i]' weighted_C[j]);                          for (k = 0; k < ci; k++)                              if (!nonzero[si + k] && Math.Abs(f[p].alpha[k]) > 0)                                  nonzero[si + k] = true;                          for (k = 0; k < cj; k++)                              if (!nonzero[sj + k] && Math.Abs(f[p].alpha[ci + k]) > 0)                                  nonzero[sj + k] = true;                          ++p;                      }                    // build output                    model.nr_class = nr_class;                    model.label = new int[nr_class];                  for (i = 0; i < nr_class; i++)                      model.label[i] = label[i];                    model.rho = new double[nr_class*(nr_class - 1)/2];                  for (i = 0; i < nr_class*(nr_class - 1)/2; i++)                      model.rho[i] = f[i].rho;                    if (param.probability == 1)                  {                      model.probA = new double[nr_class*(nr_class - 1)/2];                      model.probB = new double[nr_class*(nr_class - 1)/2];                      for (i = 0; i < nr_class*(nr_class - 1)/2; i++)                      {                          model.probA[i] = probA[i];                          model.probB[i] = probB[i];                      }                  }                  else                  {                      model.probA = null;                      model.probB = null;                  }                    int nnz = 0;                  var nz_count = new int[nr_class];                  model.nSV = new int[nr_class];                  for (i = 0; i < nr_class; i++)                  {                      int nSV = 0;                      for (int j = 0; j < count[i]; j++)                          if (nonzero[start[i] + j])                          {                              ++nSV;                              ++nnz;                          }                      model.nSV[i] = nSV;                      nz_count[i] = nSV;                  }                    //Console.Out.Write("Total nSV = " + nnz + "\n");                    model.l = nnz;                  model.SV = new svm_node[nnz][];                  p = 0;                  for (i = 0; i < l; i++)                      if (nonzero[i])                          model.SV[p++] = x[i];                    var nz_start = new int[nr_class];                  nz_start[0] = 0;                  for (i = 1; i < nr_class; i++)                      nz_start[i] = nz_start[i - 1] + nz_count[i - 1];                    model.sv_coef = new double[nr_class - 1][];                  for (i = 0; i < nr_class - 1; i++)                      model.sv_coef[i] = new double[nnz];                    p = 0;                  for (i = 0; i < nr_class; i++)                      for (int j = i + 1; j < nr_class; j++)                      {                          // classifier (i'j): coefficients with                          // i are in sv_coef[j-1][nz_start[i]...]'                          // j are in sv_coef[i][nz_start[j]...]                            int si = start[i];                          int sj = start[j];                          int ci = count[i];                          int cj = count[j];                            int q = nz_start[i];                          int k;                          for (k = 0; k < ci; k++)                              if (nonzero[si + k])                                  model.sv_coef[j - 1][q++] = f[p].alpha[k];                          q = nz_start[j];                          for (k = 0; k < cj; k++)                              if (nonzero[sj + k])                                  model.sv_coef[i][q++] = f[p].alpha[ci + k];                          ++p;                      }              }
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_train,The following statement contains a magic number: if (param.svm_type == svm_parameter.ONE_CLASS || param.svm_type == svm_parameter.EPSILON_SVR ||                  param.svm_type == svm_parameter.NU_SVR)              {                  // regression or one-class-svm                  model.nr_class = 2;                  model.label = null;                  model.nSV = null;                  model.probA = null;                  model.probB = null;                  model.sv_coef = new double[1][];                    if (param.probability == 1 &&                      (param.svm_type == svm_parameter.EPSILON_SVR || param.svm_type == svm_parameter.NU_SVR))                  {                      model.probA = new double[1];                      model.probA[0] = svm_svr_probability(prob' param);                  }                    decision_function f = svm_train_one(prob' param' 0' 0);                  model.rho = new double[1];                  model.rho[0] = f.rho;                    int nSV = 0;                  int i;                  for (i = 0; i < prob.l; i++)                      if (Math.Abs(f.alpha[i]) > 0)                          ++nSV;                  model.l = nSV;                  model.SV = new svm_node[nSV][];                  model.sv_coef[0] = new double[nSV];                  int j = 0;                  for (i = 0; i < prob.l; i++)                      if (Math.Abs(f.alpha[i]) > 0)                      {                          model.SV[j] = prob.x[i];                          model.sv_coef[0][j] = f.alpha[i];                          ++j;                      }              }              else              {                  // classification                  // find out the number of classes                  int l = prob.l;                  int max_nr_class = 16;                  int nr_class = 0;                  var label = new int[max_nr_class];                  var count = new int[max_nr_class];                  var index = new int[l];                    int i;                  for (i = 0; i < l; i++)                  {                      //UPGRADE_WARNING: Data types in Visual C# might be different.  Verify the accuracy of narrowing conversions. 'ms-help://MS.VSCC.2003/commoner/redir/redirect.htm?keyword="jlca1042_3"'                      var this_label = (int) prob.y[i];                      int j;                      for (j = 0; j < nr_class; j++)                          if (this_label == label[j])                          {                              ++count[j];                              break;                          }                      index[i] = j;                      if (j == nr_class)                      {                          if (nr_class == max_nr_class)                          {                              max_nr_class *= 2;                              var new_data = new int[max_nr_class];                              Array.Copy(label' 0' new_data' 0' label.Length);                              label = new_data;                                new_data = new int[max_nr_class];                              Array.Copy(count' 0' new_data' 0' count.Length);                              count = new_data;                          }                          label[nr_class] = this_label;                          count[nr_class] = 1;                          ++nr_class;                      }                  }                    // group training data of the same class                    var start = new int[nr_class];                  start[0] = 0;                  for (i = 1; i < nr_class; i++)                      start[i] = start[i - 1] + count[i - 1];                    var x = new svm_node[l][];                    for (i = 0; i < l; i++)                  {                      x[start[index[i]]] = prob.x[i];                      ++start[index[i]];                  }                    start[0] = 0;                  for (i = 1; i < nr_class; i++)                      start[i] = start[i - 1] + count[i - 1];                    // calculate weighted C                    var weighted_C = new double[nr_class];                  for (i = 0; i < nr_class; i++)                      weighted_C[i] = param.C;                  for (i = 0; i < param.nr_weight; i++)                  {                      int j;                      for (j = 0; j < nr_class; j++)                          if (param.weight_label[i] == label[j])                              break;                      if (j == nr_class) ;                      /*Console.Error.Write("warning: class label " + param.weight_label[i] +                                          " specified in weight is not found\n");*/                      else                          weighted_C[j] *= param.weight[i];                  }                    // train k*(k-1)/2 models                    var nonzero = new bool[l];                  for (i = 0; i < l; i++)                      nonzero[i] = false;                  var f = new decision_function[nr_class*(nr_class - 1)/2];                    double[] probA = null' probB = null;                  if (param.probability == 1)                  {                      probA = new double[nr_class*(nr_class - 1)/2];                      probB = new double[nr_class*(nr_class - 1)/2];                  }                    int p = 0;                  for (i = 0; i < nr_class; i++)                      for (int j = i + 1; j < nr_class; j++)                      {                          var sub_prob = new svm_problem();                          int si = start[i]' sj = start[j];                          int ci = count[i]' cj = count[j];                          sub_prob.l = ci + cj;                          sub_prob.x = new svm_node[sub_prob.l][];                          sub_prob.y = new double[sub_prob.l];                          int k;                          for (k = 0; k < ci; k++)                          {                              sub_prob.x[k] = x[si + k];                              sub_prob.y[k] = + 1;                          }                          for (k = 0; k < cj; k++)                          {                              sub_prob.x[ci + k] = x[sj + k];                              sub_prob.y[ci + k] = - 1;                          }                            if (param.probability == 1)                          {                              var probAB = new double[2];                              svm_binary_svc_probability(sub_prob' param' weighted_C[i]' weighted_C[j]' probAB);                              probA[p] = probAB[0];                              probB[p] = probAB[1];                          }                            f[p] = svm_train_one(sub_prob' param' weighted_C[i]' weighted_C[j]);                          for (k = 0; k < ci; k++)                              if (!nonzero[si + k] && Math.Abs(f[p].alpha[k]) > 0)                                  nonzero[si + k] = true;                          for (k = 0; k < cj; k++)                              if (!nonzero[sj + k] && Math.Abs(f[p].alpha[ci + k]) > 0)                                  nonzero[sj + k] = true;                          ++p;                      }                    // build output                    model.nr_class = nr_class;                    model.label = new int[nr_class];                  for (i = 0; i < nr_class; i++)                      model.label[i] = label[i];                    model.rho = new double[nr_class*(nr_class - 1)/2];                  for (i = 0; i < nr_class*(nr_class - 1)/2; i++)                      model.rho[i] = f[i].rho;                    if (param.probability == 1)                  {                      model.probA = new double[nr_class*(nr_class - 1)/2];                      model.probB = new double[nr_class*(nr_class - 1)/2];                      for (i = 0; i < nr_class*(nr_class - 1)/2; i++)                      {                          model.probA[i] = probA[i];                          model.probB[i] = probB[i];                      }                  }                  else                  {                      model.probA = null;                      model.probB = null;                  }                    int nnz = 0;                  var nz_count = new int[nr_class];                  model.nSV = new int[nr_class];                  for (i = 0; i < nr_class; i++)                  {                      int nSV = 0;                      for (int j = 0; j < count[i]; j++)                          if (nonzero[start[i] + j])                          {                              ++nSV;                              ++nnz;                          }                      model.nSV[i] = nSV;                      nz_count[i] = nSV;                  }                    //Console.Out.Write("Total nSV = " + nnz + "\n");                    model.l = nnz;                  model.SV = new svm_node[nnz][];                  p = 0;                  for (i = 0; i < l; i++)                      if (nonzero[i])                          model.SV[p++] = x[i];                    var nz_start = new int[nr_class];                  nz_start[0] = 0;                  for (i = 1; i < nr_class; i++)                      nz_start[i] = nz_start[i - 1] + nz_count[i - 1];                    model.sv_coef = new double[nr_class - 1][];                  for (i = 0; i < nr_class - 1; i++)                      model.sv_coef[i] = new double[nnz];                    p = 0;                  for (i = 0; i < nr_class; i++)                      for (int j = i + 1; j < nr_class; j++)                      {                          // classifier (i'j): coefficients with                          // i are in sv_coef[j-1][nz_start[i]...]'                          // j are in sv_coef[i][nz_start[j]...]                            int si = start[i];                          int sj = start[j];                          int ci = count[i];                          int cj = count[j];                            int q = nz_start[i];                          int k;                          for (k = 0; k < ci; k++)                              if (nonzero[si + k])                                  model.sv_coef[j - 1][q++] = f[p].alpha[k];                          q = nz_start[j];                          for (k = 0; k < cj; k++)                              if (nonzero[sj + k])                                  model.sv_coef[i][q++] = f[p].alpha[ci + k];                          ++p;                      }              }
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_train,The following statement contains a magic number: if (param.svm_type == svm_parameter.ONE_CLASS || param.svm_type == svm_parameter.EPSILON_SVR ||                  param.svm_type == svm_parameter.NU_SVR)              {                  // regression or one-class-svm                  model.nr_class = 2;                  model.label = null;                  model.nSV = null;                  model.probA = null;                  model.probB = null;                  model.sv_coef = new double[1][];                    if (param.probability == 1 &&                      (param.svm_type == svm_parameter.EPSILON_SVR || param.svm_type == svm_parameter.NU_SVR))                  {                      model.probA = new double[1];                      model.probA[0] = svm_svr_probability(prob' param);                  }                    decision_function f = svm_train_one(prob' param' 0' 0);                  model.rho = new double[1];                  model.rho[0] = f.rho;                    int nSV = 0;                  int i;                  for (i = 0; i < prob.l; i++)                      if (Math.Abs(f.alpha[i]) > 0)                          ++nSV;                  model.l = nSV;                  model.SV = new svm_node[nSV][];                  model.sv_coef[0] = new double[nSV];                  int j = 0;                  for (i = 0; i < prob.l; i++)                      if (Math.Abs(f.alpha[i]) > 0)                      {                          model.SV[j] = prob.x[i];                          model.sv_coef[0][j] = f.alpha[i];                          ++j;                      }              }              else              {                  // classification                  // find out the number of classes                  int l = prob.l;                  int max_nr_class = 16;                  int nr_class = 0;                  var label = new int[max_nr_class];                  var count = new int[max_nr_class];                  var index = new int[l];                    int i;                  for (i = 0; i < l; i++)                  {                      //UPGRADE_WARNING: Data types in Visual C# might be different.  Verify the accuracy of narrowing conversions. 'ms-help://MS.VSCC.2003/commoner/redir/redirect.htm?keyword="jlca1042_3"'                      var this_label = (int) prob.y[i];                      int j;                      for (j = 0; j < nr_class; j++)                          if (this_label == label[j])                          {                              ++count[j];                              break;                          }                      index[i] = j;                      if (j == nr_class)                      {                          if (nr_class == max_nr_class)                          {                              max_nr_class *= 2;                              var new_data = new int[max_nr_class];                              Array.Copy(label' 0' new_data' 0' label.Length);                              label = new_data;                                new_data = new int[max_nr_class];                              Array.Copy(count' 0' new_data' 0' count.Length);                              count = new_data;                          }                          label[nr_class] = this_label;                          count[nr_class] = 1;                          ++nr_class;                      }                  }                    // group training data of the same class                    var start = new int[nr_class];                  start[0] = 0;                  for (i = 1; i < nr_class; i++)                      start[i] = start[i - 1] + count[i - 1];                    var x = new svm_node[l][];                    for (i = 0; i < l; i++)                  {                      x[start[index[i]]] = prob.x[i];                      ++start[index[i]];                  }                    start[0] = 0;                  for (i = 1; i < nr_class; i++)                      start[i] = start[i - 1] + count[i - 1];                    // calculate weighted C                    var weighted_C = new double[nr_class];                  for (i = 0; i < nr_class; i++)                      weighted_C[i] = param.C;                  for (i = 0; i < param.nr_weight; i++)                  {                      int j;                      for (j = 0; j < nr_class; j++)                          if (param.weight_label[i] == label[j])                              break;                      if (j == nr_class) ;                      /*Console.Error.Write("warning: class label " + param.weight_label[i] +                                          " specified in weight is not found\n");*/                      else                          weighted_C[j] *= param.weight[i];                  }                    // train k*(k-1)/2 models                    var nonzero = new bool[l];                  for (i = 0; i < l; i++)                      nonzero[i] = false;                  var f = new decision_function[nr_class*(nr_class - 1)/2];                    double[] probA = null' probB = null;                  if (param.probability == 1)                  {                      probA = new double[nr_class*(nr_class - 1)/2];                      probB = new double[nr_class*(nr_class - 1)/2];                  }                    int p = 0;                  for (i = 0; i < nr_class; i++)                      for (int j = i + 1; j < nr_class; j++)                      {                          var sub_prob = new svm_problem();                          int si = start[i]' sj = start[j];                          int ci = count[i]' cj = count[j];                          sub_prob.l = ci + cj;                          sub_prob.x = new svm_node[sub_prob.l][];                          sub_prob.y = new double[sub_prob.l];                          int k;                          for (k = 0; k < ci; k++)                          {                              sub_prob.x[k] = x[si + k];                              sub_prob.y[k] = + 1;                          }                          for (k = 0; k < cj; k++)                          {                              sub_prob.x[ci + k] = x[sj + k];                              sub_prob.y[ci + k] = - 1;                          }                            if (param.probability == 1)                          {                              var probAB = new double[2];                              svm_binary_svc_probability(sub_prob' param' weighted_C[i]' weighted_C[j]' probAB);                              probA[p] = probAB[0];                              probB[p] = probAB[1];                          }                            f[p] = svm_train_one(sub_prob' param' weighted_C[i]' weighted_C[j]);                          for (k = 0; k < ci; k++)                              if (!nonzero[si + k] && Math.Abs(f[p].alpha[k]) > 0)                                  nonzero[si + k] = true;                          for (k = 0; k < cj; k++)                              if (!nonzero[sj + k] && Math.Abs(f[p].alpha[ci + k]) > 0)                                  nonzero[sj + k] = true;                          ++p;                      }                    // build output                    model.nr_class = nr_class;                    model.label = new int[nr_class];                  for (i = 0; i < nr_class; i++)                      model.label[i] = label[i];                    model.rho = new double[nr_class*(nr_class - 1)/2];                  for (i = 0; i < nr_class*(nr_class - 1)/2; i++)                      model.rho[i] = f[i].rho;                    if (param.probability == 1)                  {                      model.probA = new double[nr_class*(nr_class - 1)/2];                      model.probB = new double[nr_class*(nr_class - 1)/2];                      for (i = 0; i < nr_class*(nr_class - 1)/2; i++)                      {                          model.probA[i] = probA[i];                          model.probB[i] = probB[i];                      }                  }                  else                  {                      model.probA = null;                      model.probB = null;                  }                    int nnz = 0;                  var nz_count = new int[nr_class];                  model.nSV = new int[nr_class];                  for (i = 0; i < nr_class; i++)                  {                      int nSV = 0;                      for (int j = 0; j < count[i]; j++)                          if (nonzero[start[i] + j])                          {                              ++nSV;                              ++nnz;                          }                      model.nSV[i] = nSV;                      nz_count[i] = nSV;                  }                    //Console.Out.Write("Total nSV = " + nnz + "\n");                    model.l = nnz;                  model.SV = new svm_node[nnz][];                  p = 0;                  for (i = 0; i < l; i++)                      if (nonzero[i])                          model.SV[p++] = x[i];                    var nz_start = new int[nr_class];                  nz_start[0] = 0;                  for (i = 1; i < nr_class; i++)                      nz_start[i] = nz_start[i - 1] + nz_count[i - 1];                    model.sv_coef = new double[nr_class - 1][];                  for (i = 0; i < nr_class - 1; i++)                      model.sv_coef[i] = new double[nnz];                    p = 0;                  for (i = 0; i < nr_class; i++)                      for (int j = i + 1; j < nr_class; j++)                      {                          // classifier (i'j): coefficients with                          // i are in sv_coef[j-1][nz_start[i]...]'                          // j are in sv_coef[i][nz_start[j]...]                            int si = start[i];                          int sj = start[j];                          int ci = count[i];                          int cj = count[j];                            int q = nz_start[i];                          int k;                          for (k = 0; k < ci; k++)                              if (nonzero[si + k])                                  model.sv_coef[j - 1][q++] = f[p].alpha[k];                          q = nz_start[j];                          for (k = 0; k < cj; k++)                              if (nonzero[sj + k])                                  model.sv_coef[i][q++] = f[p].alpha[ci + k];                          ++p;                      }              }
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_train,The following statement contains a magic number: if (param.svm_type == svm_parameter.ONE_CLASS || param.svm_type == svm_parameter.EPSILON_SVR ||                  param.svm_type == svm_parameter.NU_SVR)              {                  // regression or one-class-svm                  model.nr_class = 2;                  model.label = null;                  model.nSV = null;                  model.probA = null;                  model.probB = null;                  model.sv_coef = new double[1][];                    if (param.probability == 1 &&                      (param.svm_type == svm_parameter.EPSILON_SVR || param.svm_type == svm_parameter.NU_SVR))                  {                      model.probA = new double[1];                      model.probA[0] = svm_svr_probability(prob' param);                  }                    decision_function f = svm_train_one(prob' param' 0' 0);                  model.rho = new double[1];                  model.rho[0] = f.rho;                    int nSV = 0;                  int i;                  for (i = 0; i < prob.l; i++)                      if (Math.Abs(f.alpha[i]) > 0)                          ++nSV;                  model.l = nSV;                  model.SV = new svm_node[nSV][];                  model.sv_coef[0] = new double[nSV];                  int j = 0;                  for (i = 0; i < prob.l; i++)                      if (Math.Abs(f.alpha[i]) > 0)                      {                          model.SV[j] = prob.x[i];                          model.sv_coef[0][j] = f.alpha[i];                          ++j;                      }              }              else              {                  // classification                  // find out the number of classes                  int l = prob.l;                  int max_nr_class = 16;                  int nr_class = 0;                  var label = new int[max_nr_class];                  var count = new int[max_nr_class];                  var index = new int[l];                    int i;                  for (i = 0; i < l; i++)                  {                      //UPGRADE_WARNING: Data types in Visual C# might be different.  Verify the accuracy of narrowing conversions. 'ms-help://MS.VSCC.2003/commoner/redir/redirect.htm?keyword="jlca1042_3"'                      var this_label = (int) prob.y[i];                      int j;                      for (j = 0; j < nr_class; j++)                          if (this_label == label[j])                          {                              ++count[j];                              break;                          }                      index[i] = j;                      if (j == nr_class)                      {                          if (nr_class == max_nr_class)                          {                              max_nr_class *= 2;                              var new_data = new int[max_nr_class];                              Array.Copy(label' 0' new_data' 0' label.Length);                              label = new_data;                                new_data = new int[max_nr_class];                              Array.Copy(count' 0' new_data' 0' count.Length);                              count = new_data;                          }                          label[nr_class] = this_label;                          count[nr_class] = 1;                          ++nr_class;                      }                  }                    // group training data of the same class                    var start = new int[nr_class];                  start[0] = 0;                  for (i = 1; i < nr_class; i++)                      start[i] = start[i - 1] + count[i - 1];                    var x = new svm_node[l][];                    for (i = 0; i < l; i++)                  {                      x[start[index[i]]] = prob.x[i];                      ++start[index[i]];                  }                    start[0] = 0;                  for (i = 1; i < nr_class; i++)                      start[i] = start[i - 1] + count[i - 1];                    // calculate weighted C                    var weighted_C = new double[nr_class];                  for (i = 0; i < nr_class; i++)                      weighted_C[i] = param.C;                  for (i = 0; i < param.nr_weight; i++)                  {                      int j;                      for (j = 0; j < nr_class; j++)                          if (param.weight_label[i] == label[j])                              break;                      if (j == nr_class) ;                      /*Console.Error.Write("warning: class label " + param.weight_label[i] +                                          " specified in weight is not found\n");*/                      else                          weighted_C[j] *= param.weight[i];                  }                    // train k*(k-1)/2 models                    var nonzero = new bool[l];                  for (i = 0; i < l; i++)                      nonzero[i] = false;                  var f = new decision_function[nr_class*(nr_class - 1)/2];                    double[] probA = null' probB = null;                  if (param.probability == 1)                  {                      probA = new double[nr_class*(nr_class - 1)/2];                      probB = new double[nr_class*(nr_class - 1)/2];                  }                    int p = 0;                  for (i = 0; i < nr_class; i++)                      for (int j = i + 1; j < nr_class; j++)                      {                          var sub_prob = new svm_problem();                          int si = start[i]' sj = start[j];                          int ci = count[i]' cj = count[j];                          sub_prob.l = ci + cj;                          sub_prob.x = new svm_node[sub_prob.l][];                          sub_prob.y = new double[sub_prob.l];                          int k;                          for (k = 0; k < ci; k++)                          {                              sub_prob.x[k] = x[si + k];                              sub_prob.y[k] = + 1;                          }                          for (k = 0; k < cj; k++)                          {                              sub_prob.x[ci + k] = x[sj + k];                              sub_prob.y[ci + k] = - 1;                          }                            if (param.probability == 1)                          {                              var probAB = new double[2];                              svm_binary_svc_probability(sub_prob' param' weighted_C[i]' weighted_C[j]' probAB);                              probA[p] = probAB[0];                              probB[p] = probAB[1];                          }                            f[p] = svm_train_one(sub_prob' param' weighted_C[i]' weighted_C[j]);                          for (k = 0; k < ci; k++)                              if (!nonzero[si + k] && Math.Abs(f[p].alpha[k]) > 0)                                  nonzero[si + k] = true;                          for (k = 0; k < cj; k++)                              if (!nonzero[sj + k] && Math.Abs(f[p].alpha[ci + k]) > 0)                                  nonzero[sj + k] = true;                          ++p;                      }                    // build output                    model.nr_class = nr_class;                    model.label = new int[nr_class];                  for (i = 0; i < nr_class; i++)                      model.label[i] = label[i];                    model.rho = new double[nr_class*(nr_class - 1)/2];                  for (i = 0; i < nr_class*(nr_class - 1)/2; i++)                      model.rho[i] = f[i].rho;                    if (param.probability == 1)                  {                      model.probA = new double[nr_class*(nr_class - 1)/2];                      model.probB = new double[nr_class*(nr_class - 1)/2];                      for (i = 0; i < nr_class*(nr_class - 1)/2; i++)                      {                          model.probA[i] = probA[i];                          model.probB[i] = probB[i];                      }                  }                  else                  {                      model.probA = null;                      model.probB = null;                  }                    int nnz = 0;                  var nz_count = new int[nr_class];                  model.nSV = new int[nr_class];                  for (i = 0; i < nr_class; i++)                  {                      int nSV = 0;                      for (int j = 0; j < count[i]; j++)                          if (nonzero[start[i] + j])                          {                              ++nSV;                              ++nnz;                          }                      model.nSV[i] = nSV;                      nz_count[i] = nSV;                  }                    //Console.Out.Write("Total nSV = " + nnz + "\n");                    model.l = nnz;                  model.SV = new svm_node[nnz][];                  p = 0;                  for (i = 0; i < l; i++)                      if (nonzero[i])                          model.SV[p++] = x[i];                    var nz_start = new int[nr_class];                  nz_start[0] = 0;                  for (i = 1; i < nr_class; i++)                      nz_start[i] = nz_start[i - 1] + nz_count[i - 1];                    model.sv_coef = new double[nr_class - 1][];                  for (i = 0; i < nr_class - 1; i++)                      model.sv_coef[i] = new double[nnz];                    p = 0;                  for (i = 0; i < nr_class; i++)                      for (int j = i + 1; j < nr_class; j++)                      {                          // classifier (i'j): coefficients with                          // i are in sv_coef[j-1][nz_start[i]...]'                          // j are in sv_coef[i][nz_start[j]...]                            int si = start[i];                          int sj = start[j];                          int ci = count[i];                          int cj = count[j];                            int q = nz_start[i];                          int k;                          for (k = 0; k < ci; k++)                              if (nonzero[si + k])                                  model.sv_coef[j - 1][q++] = f[p].alpha[k];                          q = nz_start[j];                          for (k = 0; k < cj; k++)                              if (nonzero[sj + k])                                  model.sv_coef[i][q++] = f[p].alpha[ci + k];                          ++p;                      }              }
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_train,The following statement contains a magic number: if (param.svm_type == svm_parameter.ONE_CLASS || param.svm_type == svm_parameter.EPSILON_SVR ||                  param.svm_type == svm_parameter.NU_SVR)              {                  // regression or one-class-svm                  model.nr_class = 2;                  model.label = null;                  model.nSV = null;                  model.probA = null;                  model.probB = null;                  model.sv_coef = new double[1][];                    if (param.probability == 1 &&                      (param.svm_type == svm_parameter.EPSILON_SVR || param.svm_type == svm_parameter.NU_SVR))                  {                      model.probA = new double[1];                      model.probA[0] = svm_svr_probability(prob' param);                  }                    decision_function f = svm_train_one(prob' param' 0' 0);                  model.rho = new double[1];                  model.rho[0] = f.rho;                    int nSV = 0;                  int i;                  for (i = 0; i < prob.l; i++)                      if (Math.Abs(f.alpha[i]) > 0)                          ++nSV;                  model.l = nSV;                  model.SV = new svm_node[nSV][];                  model.sv_coef[0] = new double[nSV];                  int j = 0;                  for (i = 0; i < prob.l; i++)                      if (Math.Abs(f.alpha[i]) > 0)                      {                          model.SV[j] = prob.x[i];                          model.sv_coef[0][j] = f.alpha[i];                          ++j;                      }              }              else              {                  // classification                  // find out the number of classes                  int l = prob.l;                  int max_nr_class = 16;                  int nr_class = 0;                  var label = new int[max_nr_class];                  var count = new int[max_nr_class];                  var index = new int[l];                    int i;                  for (i = 0; i < l; i++)                  {                      //UPGRADE_WARNING: Data types in Visual C# might be different.  Verify the accuracy of narrowing conversions. 'ms-help://MS.VSCC.2003/commoner/redir/redirect.htm?keyword="jlca1042_3"'                      var this_label = (int) prob.y[i];                      int j;                      for (j = 0; j < nr_class; j++)                          if (this_label == label[j])                          {                              ++count[j];                              break;                          }                      index[i] = j;                      if (j == nr_class)                      {                          if (nr_class == max_nr_class)                          {                              max_nr_class *= 2;                              var new_data = new int[max_nr_class];                              Array.Copy(label' 0' new_data' 0' label.Length);                              label = new_data;                                new_data = new int[max_nr_class];                              Array.Copy(count' 0' new_data' 0' count.Length);                              count = new_data;                          }                          label[nr_class] = this_label;                          count[nr_class] = 1;                          ++nr_class;                      }                  }                    // group training data of the same class                    var start = new int[nr_class];                  start[0] = 0;                  for (i = 1; i < nr_class; i++)                      start[i] = start[i - 1] + count[i - 1];                    var x = new svm_node[l][];                    for (i = 0; i < l; i++)                  {                      x[start[index[i]]] = prob.x[i];                      ++start[index[i]];                  }                    start[0] = 0;                  for (i = 1; i < nr_class; i++)                      start[i] = start[i - 1] + count[i - 1];                    // calculate weighted C                    var weighted_C = new double[nr_class];                  for (i = 0; i < nr_class; i++)                      weighted_C[i] = param.C;                  for (i = 0; i < param.nr_weight; i++)                  {                      int j;                      for (j = 0; j < nr_class; j++)                          if (param.weight_label[i] == label[j])                              break;                      if (j == nr_class) ;                      /*Console.Error.Write("warning: class label " + param.weight_label[i] +                                          " specified in weight is not found\n");*/                      else                          weighted_C[j] *= param.weight[i];                  }                    // train k*(k-1)/2 models                    var nonzero = new bool[l];                  for (i = 0; i < l; i++)                      nonzero[i] = false;                  var f = new decision_function[nr_class*(nr_class - 1)/2];                    double[] probA = null' probB = null;                  if (param.probability == 1)                  {                      probA = new double[nr_class*(nr_class - 1)/2];                      probB = new double[nr_class*(nr_class - 1)/2];                  }                    int p = 0;                  for (i = 0; i < nr_class; i++)                      for (int j = i + 1; j < nr_class; j++)                      {                          var sub_prob = new svm_problem();                          int si = start[i]' sj = start[j];                          int ci = count[i]' cj = count[j];                          sub_prob.l = ci + cj;                          sub_prob.x = new svm_node[sub_prob.l][];                          sub_prob.y = new double[sub_prob.l];                          int k;                          for (k = 0; k < ci; k++)                          {                              sub_prob.x[k] = x[si + k];                              sub_prob.y[k] = + 1;                          }                          for (k = 0; k < cj; k++)                          {                              sub_prob.x[ci + k] = x[sj + k];                              sub_prob.y[ci + k] = - 1;                          }                            if (param.probability == 1)                          {                              var probAB = new double[2];                              svm_binary_svc_probability(sub_prob' param' weighted_C[i]' weighted_C[j]' probAB);                              probA[p] = probAB[0];                              probB[p] = probAB[1];                          }                            f[p] = svm_train_one(sub_prob' param' weighted_C[i]' weighted_C[j]);                          for (k = 0; k < ci; k++)                              if (!nonzero[si + k] && Math.Abs(f[p].alpha[k]) > 0)                                  nonzero[si + k] = true;                          for (k = 0; k < cj; k++)                              if (!nonzero[sj + k] && Math.Abs(f[p].alpha[ci + k]) > 0)                                  nonzero[sj + k] = true;                          ++p;                      }                    // build output                    model.nr_class = nr_class;                    model.label = new int[nr_class];                  for (i = 0; i < nr_class; i++)                      model.label[i] = label[i];                    model.rho = new double[nr_class*(nr_class - 1)/2];                  for (i = 0; i < nr_class*(nr_class - 1)/2; i++)                      model.rho[i] = f[i].rho;                    if (param.probability == 1)                  {                      model.probA = new double[nr_class*(nr_class - 1)/2];                      model.probB = new double[nr_class*(nr_class - 1)/2];                      for (i = 0; i < nr_class*(nr_class - 1)/2; i++)                      {                          model.probA[i] = probA[i];                          model.probB[i] = probB[i];                      }                  }                  else                  {                      model.probA = null;                      model.probB = null;                  }                    int nnz = 0;                  var nz_count = new int[nr_class];                  model.nSV = new int[nr_class];                  for (i = 0; i < nr_class; i++)                  {                      int nSV = 0;                      for (int j = 0; j < count[i]; j++)                          if (nonzero[start[i] + j])                          {                              ++nSV;                              ++nnz;                          }                      model.nSV[i] = nSV;                      nz_count[i] = nSV;                  }                    //Console.Out.Write("Total nSV = " + nnz + "\n");                    model.l = nnz;                  model.SV = new svm_node[nnz][];                  p = 0;                  for (i = 0; i < l; i++)                      if (nonzero[i])                          model.SV[p++] = x[i];                    var nz_start = new int[nr_class];                  nz_start[0] = 0;                  for (i = 1; i < nr_class; i++)                      nz_start[i] = nz_start[i - 1] + nz_count[i - 1];                    model.sv_coef = new double[nr_class - 1][];                  for (i = 0; i < nr_class - 1; i++)                      model.sv_coef[i] = new double[nnz];                    p = 0;                  for (i = 0; i < nr_class; i++)                      for (int j = i + 1; j < nr_class; j++)                      {                          // classifier (i'j): coefficients with                          // i are in sv_coef[j-1][nz_start[i]...]'                          // j are in sv_coef[i][nz_start[j]...]                            int si = start[i];                          int sj = start[j];                          int ci = count[i];                          int cj = count[j];                            int q = nz_start[i];                          int k;                          for (k = 0; k < ci; k++)                              if (nonzero[si + k])                                  model.sv_coef[j - 1][q++] = f[p].alpha[k];                          q = nz_start[j];                          for (k = 0; k < cj; k++)                              if (nonzero[sj + k])                                  model.sv_coef[i][q++] = f[p].alpha[ci + k];                          ++p;                      }              }
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_train,The following statement contains a magic number: if (param.svm_type == svm_parameter.ONE_CLASS || param.svm_type == svm_parameter.EPSILON_SVR ||                  param.svm_type == svm_parameter.NU_SVR)              {                  // regression or one-class-svm                  model.nr_class = 2;                  model.label = null;                  model.nSV = null;                  model.probA = null;                  model.probB = null;                  model.sv_coef = new double[1][];                    if (param.probability == 1 &&                      (param.svm_type == svm_parameter.EPSILON_SVR || param.svm_type == svm_parameter.NU_SVR))                  {                      model.probA = new double[1];                      model.probA[0] = svm_svr_probability(prob' param);                  }                    decision_function f = svm_train_one(prob' param' 0' 0);                  model.rho = new double[1];                  model.rho[0] = f.rho;                    int nSV = 0;                  int i;                  for (i = 0; i < prob.l; i++)                      if (Math.Abs(f.alpha[i]) > 0)                          ++nSV;                  model.l = nSV;                  model.SV = new svm_node[nSV][];                  model.sv_coef[0] = new double[nSV];                  int j = 0;                  for (i = 0; i < prob.l; i++)                      if (Math.Abs(f.alpha[i]) > 0)                      {                          model.SV[j] = prob.x[i];                          model.sv_coef[0][j] = f.alpha[i];                          ++j;                      }              }              else              {                  // classification                  // find out the number of classes                  int l = prob.l;                  int max_nr_class = 16;                  int nr_class = 0;                  var label = new int[max_nr_class];                  var count = new int[max_nr_class];                  var index = new int[l];                    int i;                  for (i = 0; i < l; i++)                  {                      //UPGRADE_WARNING: Data types in Visual C# might be different.  Verify the accuracy of narrowing conversions. 'ms-help://MS.VSCC.2003/commoner/redir/redirect.htm?keyword="jlca1042_3"'                      var this_label = (int) prob.y[i];                      int j;                      for (j = 0; j < nr_class; j++)                          if (this_label == label[j])                          {                              ++count[j];                              break;                          }                      index[i] = j;                      if (j == nr_class)                      {                          if (nr_class == max_nr_class)                          {                              max_nr_class *= 2;                              var new_data = new int[max_nr_class];                              Array.Copy(label' 0' new_data' 0' label.Length);                              label = new_data;                                new_data = new int[max_nr_class];                              Array.Copy(count' 0' new_data' 0' count.Length);                              count = new_data;                          }                          label[nr_class] = this_label;                          count[nr_class] = 1;                          ++nr_class;                      }                  }                    // group training data of the same class                    var start = new int[nr_class];                  start[0] = 0;                  for (i = 1; i < nr_class; i++)                      start[i] = start[i - 1] + count[i - 1];                    var x = new svm_node[l][];                    for (i = 0; i < l; i++)                  {                      x[start[index[i]]] = prob.x[i];                      ++start[index[i]];                  }                    start[0] = 0;                  for (i = 1; i < nr_class; i++)                      start[i] = start[i - 1] + count[i - 1];                    // calculate weighted C                    var weighted_C = new double[nr_class];                  for (i = 0; i < nr_class; i++)                      weighted_C[i] = param.C;                  for (i = 0; i < param.nr_weight; i++)                  {                      int j;                      for (j = 0; j < nr_class; j++)                          if (param.weight_label[i] == label[j])                              break;                      if (j == nr_class) ;                      /*Console.Error.Write("warning: class label " + param.weight_label[i] +                                          " specified in weight is not found\n");*/                      else                          weighted_C[j] *= param.weight[i];                  }                    // train k*(k-1)/2 models                    var nonzero = new bool[l];                  for (i = 0; i < l; i++)                      nonzero[i] = false;                  var f = new decision_function[nr_class*(nr_class - 1)/2];                    double[] probA = null' probB = null;                  if (param.probability == 1)                  {                      probA = new double[nr_class*(nr_class - 1)/2];                      probB = new double[nr_class*(nr_class - 1)/2];                  }                    int p = 0;                  for (i = 0; i < nr_class; i++)                      for (int j = i + 1; j < nr_class; j++)                      {                          var sub_prob = new svm_problem();                          int si = start[i]' sj = start[j];                          int ci = count[i]' cj = count[j];                          sub_prob.l = ci + cj;                          sub_prob.x = new svm_node[sub_prob.l][];                          sub_prob.y = new double[sub_prob.l];                          int k;                          for (k = 0; k < ci; k++)                          {                              sub_prob.x[k] = x[si + k];                              sub_prob.y[k] = + 1;                          }                          for (k = 0; k < cj; k++)                          {                              sub_prob.x[ci + k] = x[sj + k];                              sub_prob.y[ci + k] = - 1;                          }                            if (param.probability == 1)                          {                              var probAB = new double[2];                              svm_binary_svc_probability(sub_prob' param' weighted_C[i]' weighted_C[j]' probAB);                              probA[p] = probAB[0];                              probB[p] = probAB[1];                          }                            f[p] = svm_train_one(sub_prob' param' weighted_C[i]' weighted_C[j]);                          for (k = 0; k < ci; k++)                              if (!nonzero[si + k] && Math.Abs(f[p].alpha[k]) > 0)                                  nonzero[si + k] = true;                          for (k = 0; k < cj; k++)                              if (!nonzero[sj + k] && Math.Abs(f[p].alpha[ci + k]) > 0)                                  nonzero[sj + k] = true;                          ++p;                      }                    // build output                    model.nr_class = nr_class;                    model.label = new int[nr_class];                  for (i = 0; i < nr_class; i++)                      model.label[i] = label[i];                    model.rho = new double[nr_class*(nr_class - 1)/2];                  for (i = 0; i < nr_class*(nr_class - 1)/2; i++)                      model.rho[i] = f[i].rho;                    if (param.probability == 1)                  {                      model.probA = new double[nr_class*(nr_class - 1)/2];                      model.probB = new double[nr_class*(nr_class - 1)/2];                      for (i = 0; i < nr_class*(nr_class - 1)/2; i++)                      {                          model.probA[i] = probA[i];                          model.probB[i] = probB[i];                      }                  }                  else                  {                      model.probA = null;                      model.probB = null;                  }                    int nnz = 0;                  var nz_count = new int[nr_class];                  model.nSV = new int[nr_class];                  for (i = 0; i < nr_class; i++)                  {                      int nSV = 0;                      for (int j = 0; j < count[i]; j++)                          if (nonzero[start[i] + j])                          {                              ++nSV;                              ++nnz;                          }                      model.nSV[i] = nSV;                      nz_count[i] = nSV;                  }                    //Console.Out.Write("Total nSV = " + nnz + "\n");                    model.l = nnz;                  model.SV = new svm_node[nnz][];                  p = 0;                  for (i = 0; i < l; i++)                      if (nonzero[i])                          model.SV[p++] = x[i];                    var nz_start = new int[nr_class];                  nz_start[0] = 0;                  for (i = 1; i < nr_class; i++)                      nz_start[i] = nz_start[i - 1] + nz_count[i - 1];                    model.sv_coef = new double[nr_class - 1][];                  for (i = 0; i < nr_class - 1; i++)                      model.sv_coef[i] = new double[nnz];                    p = 0;                  for (i = 0; i < nr_class; i++)                      for (int j = i + 1; j < nr_class; j++)                      {                          // classifier (i'j): coefficients with                          // i are in sv_coef[j-1][nz_start[i]...]'                          // j are in sv_coef[i][nz_start[j]...]                            int si = start[i];                          int sj = start[j];                          int ci = count[i];                          int cj = count[j];                            int q = nz_start[i];                          int k;                          for (k = 0; k < ci; k++)                              if (nonzero[si + k])                                  model.sv_coef[j - 1][q++] = f[p].alpha[k];                          q = nz_start[j];                          for (k = 0; k < cj; k++)                              if (nonzero[sj + k])                                  model.sv_coef[i][q++] = f[p].alpha[ci + k];                          ++p;                      }              }
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_train,The following statement contains a magic number: if (param.svm_type == svm_parameter.ONE_CLASS || param.svm_type == svm_parameter.EPSILON_SVR ||                  param.svm_type == svm_parameter.NU_SVR)              {                  // regression or one-class-svm                  model.nr_class = 2;                  model.label = null;                  model.nSV = null;                  model.probA = null;                  model.probB = null;                  model.sv_coef = new double[1][];                    if (param.probability == 1 &&                      (param.svm_type == svm_parameter.EPSILON_SVR || param.svm_type == svm_parameter.NU_SVR))                  {                      model.probA = new double[1];                      model.probA[0] = svm_svr_probability(prob' param);                  }                    decision_function f = svm_train_one(prob' param' 0' 0);                  model.rho = new double[1];                  model.rho[0] = f.rho;                    int nSV = 0;                  int i;                  for (i = 0; i < prob.l; i++)                      if (Math.Abs(f.alpha[i]) > 0)                          ++nSV;                  model.l = nSV;                  model.SV = new svm_node[nSV][];                  model.sv_coef[0] = new double[nSV];                  int j = 0;                  for (i = 0; i < prob.l; i++)                      if (Math.Abs(f.alpha[i]) > 0)                      {                          model.SV[j] = prob.x[i];                          model.sv_coef[0][j] = f.alpha[i];                          ++j;                      }              }              else              {                  // classification                  // find out the number of classes                  int l = prob.l;                  int max_nr_class = 16;                  int nr_class = 0;                  var label = new int[max_nr_class];                  var count = new int[max_nr_class];                  var index = new int[l];                    int i;                  for (i = 0; i < l; i++)                  {                      //UPGRADE_WARNING: Data types in Visual C# might be different.  Verify the accuracy of narrowing conversions. 'ms-help://MS.VSCC.2003/commoner/redir/redirect.htm?keyword="jlca1042_3"'                      var this_label = (int) prob.y[i];                      int j;                      for (j = 0; j < nr_class; j++)                          if (this_label == label[j])                          {                              ++count[j];                              break;                          }                      index[i] = j;                      if (j == nr_class)                      {                          if (nr_class == max_nr_class)                          {                              max_nr_class *= 2;                              var new_data = new int[max_nr_class];                              Array.Copy(label' 0' new_data' 0' label.Length);                              label = new_data;                                new_data = new int[max_nr_class];                              Array.Copy(count' 0' new_data' 0' count.Length);                              count = new_data;                          }                          label[nr_class] = this_label;                          count[nr_class] = 1;                          ++nr_class;                      }                  }                    // group training data of the same class                    var start = new int[nr_class];                  start[0] = 0;                  for (i = 1; i < nr_class; i++)                      start[i] = start[i - 1] + count[i - 1];                    var x = new svm_node[l][];                    for (i = 0; i < l; i++)                  {                      x[start[index[i]]] = prob.x[i];                      ++start[index[i]];                  }                    start[0] = 0;                  for (i = 1; i < nr_class; i++)                      start[i] = start[i - 1] + count[i - 1];                    // calculate weighted C                    var weighted_C = new double[nr_class];                  for (i = 0; i < nr_class; i++)                      weighted_C[i] = param.C;                  for (i = 0; i < param.nr_weight; i++)                  {                      int j;                      for (j = 0; j < nr_class; j++)                          if (param.weight_label[i] == label[j])                              break;                      if (j == nr_class) ;                      /*Console.Error.Write("warning: class label " + param.weight_label[i] +                                          " specified in weight is not found\n");*/                      else                          weighted_C[j] *= param.weight[i];                  }                    // train k*(k-1)/2 models                    var nonzero = new bool[l];                  for (i = 0; i < l; i++)                      nonzero[i] = false;                  var f = new decision_function[nr_class*(nr_class - 1)/2];                    double[] probA = null' probB = null;                  if (param.probability == 1)                  {                      probA = new double[nr_class*(nr_class - 1)/2];                      probB = new double[nr_class*(nr_class - 1)/2];                  }                    int p = 0;                  for (i = 0; i < nr_class; i++)                      for (int j = i + 1; j < nr_class; j++)                      {                          var sub_prob = new svm_problem();                          int si = start[i]' sj = start[j];                          int ci = count[i]' cj = count[j];                          sub_prob.l = ci + cj;                          sub_prob.x = new svm_node[sub_prob.l][];                          sub_prob.y = new double[sub_prob.l];                          int k;                          for (k = 0; k < ci; k++)                          {                              sub_prob.x[k] = x[si + k];                              sub_prob.y[k] = + 1;                          }                          for (k = 0; k < cj; k++)                          {                              sub_prob.x[ci + k] = x[sj + k];                              sub_prob.y[ci + k] = - 1;                          }                            if (param.probability == 1)                          {                              var probAB = new double[2];                              svm_binary_svc_probability(sub_prob' param' weighted_C[i]' weighted_C[j]' probAB);                              probA[p] = probAB[0];                              probB[p] = probAB[1];                          }                            f[p] = svm_train_one(sub_prob' param' weighted_C[i]' weighted_C[j]);                          for (k = 0; k < ci; k++)                              if (!nonzero[si + k] && Math.Abs(f[p].alpha[k]) > 0)                                  nonzero[si + k] = true;                          for (k = 0; k < cj; k++)                              if (!nonzero[sj + k] && Math.Abs(f[p].alpha[ci + k]) > 0)                                  nonzero[sj + k] = true;                          ++p;                      }                    // build output                    model.nr_class = nr_class;                    model.label = new int[nr_class];                  for (i = 0; i < nr_class; i++)                      model.label[i] = label[i];                    model.rho = new double[nr_class*(nr_class - 1)/2];                  for (i = 0; i < nr_class*(nr_class - 1)/2; i++)                      model.rho[i] = f[i].rho;                    if (param.probability == 1)                  {                      model.probA = new double[nr_class*(nr_class - 1)/2];                      model.probB = new double[nr_class*(nr_class - 1)/2];                      for (i = 0; i < nr_class*(nr_class - 1)/2; i++)                      {                          model.probA[i] = probA[i];                          model.probB[i] = probB[i];                      }                  }                  else                  {                      model.probA = null;                      model.probB = null;                  }                    int nnz = 0;                  var nz_count = new int[nr_class];                  model.nSV = new int[nr_class];                  for (i = 0; i < nr_class; i++)                  {                      int nSV = 0;                      for (int j = 0; j < count[i]; j++)                          if (nonzero[start[i] + j])                          {                              ++nSV;                              ++nnz;                          }                      model.nSV[i] = nSV;                      nz_count[i] = nSV;                  }                    //Console.Out.Write("Total nSV = " + nnz + "\n");                    model.l = nnz;                  model.SV = new svm_node[nnz][];                  p = 0;                  for (i = 0; i < l; i++)                      if (nonzero[i])                          model.SV[p++] = x[i];                    var nz_start = new int[nr_class];                  nz_start[0] = 0;                  for (i = 1; i < nr_class; i++)                      nz_start[i] = nz_start[i - 1] + nz_count[i - 1];                    model.sv_coef = new double[nr_class - 1][];                  for (i = 0; i < nr_class - 1; i++)                      model.sv_coef[i] = new double[nnz];                    p = 0;                  for (i = 0; i < nr_class; i++)                      for (int j = i + 1; j < nr_class; j++)                      {                          // classifier (i'j): coefficients with                          // i are in sv_coef[j-1][nz_start[i]...]'                          // j are in sv_coef[i][nz_start[j]...]                            int si = start[i];                          int sj = start[j];                          int ci = count[i];                          int cj = count[j];                            int q = nz_start[i];                          int k;                          for (k = 0; k < ci; k++)                              if (nonzero[si + k])                                  model.sv_coef[j - 1][q++] = f[p].alpha[k];                          q = nz_start[j];                          for (k = 0; k < cj; k++)                              if (nonzero[sj + k])                                  model.sv_coef[i][q++] = f[p].alpha[ci + k];                          ++p;                      }              }
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_train,The following statement contains a magic number: if (param.svm_type == svm_parameter.ONE_CLASS || param.svm_type == svm_parameter.EPSILON_SVR ||                  param.svm_type == svm_parameter.NU_SVR)              {                  // regression or one-class-svm                  model.nr_class = 2;                  model.label = null;                  model.nSV = null;                  model.probA = null;                  model.probB = null;                  model.sv_coef = new double[1][];                    if (param.probability == 1 &&                      (param.svm_type == svm_parameter.EPSILON_SVR || param.svm_type == svm_parameter.NU_SVR))                  {                      model.probA = new double[1];                      model.probA[0] = svm_svr_probability(prob' param);                  }                    decision_function f = svm_train_one(prob' param' 0' 0);                  model.rho = new double[1];                  model.rho[0] = f.rho;                    int nSV = 0;                  int i;                  for (i = 0; i < prob.l; i++)                      if (Math.Abs(f.alpha[i]) > 0)                          ++nSV;                  model.l = nSV;                  model.SV = new svm_node[nSV][];                  model.sv_coef[0] = new double[nSV];                  int j = 0;                  for (i = 0; i < prob.l; i++)                      if (Math.Abs(f.alpha[i]) > 0)                      {                          model.SV[j] = prob.x[i];                          model.sv_coef[0][j] = f.alpha[i];                          ++j;                      }              }              else              {                  // classification                  // find out the number of classes                  int l = prob.l;                  int max_nr_class = 16;                  int nr_class = 0;                  var label = new int[max_nr_class];                  var count = new int[max_nr_class];                  var index = new int[l];                    int i;                  for (i = 0; i < l; i++)                  {                      //UPGRADE_WARNING: Data types in Visual C# might be different.  Verify the accuracy of narrowing conversions. 'ms-help://MS.VSCC.2003/commoner/redir/redirect.htm?keyword="jlca1042_3"'                      var this_label = (int) prob.y[i];                      int j;                      for (j = 0; j < nr_class; j++)                          if (this_label == label[j])                          {                              ++count[j];                              break;                          }                      index[i] = j;                      if (j == nr_class)                      {                          if (nr_class == max_nr_class)                          {                              max_nr_class *= 2;                              var new_data = new int[max_nr_class];                              Array.Copy(label' 0' new_data' 0' label.Length);                              label = new_data;                                new_data = new int[max_nr_class];                              Array.Copy(count' 0' new_data' 0' count.Length);                              count = new_data;                          }                          label[nr_class] = this_label;                          count[nr_class] = 1;                          ++nr_class;                      }                  }                    // group training data of the same class                    var start = new int[nr_class];                  start[0] = 0;                  for (i = 1; i < nr_class; i++)                      start[i] = start[i - 1] + count[i - 1];                    var x = new svm_node[l][];                    for (i = 0; i < l; i++)                  {                      x[start[index[i]]] = prob.x[i];                      ++start[index[i]];                  }                    start[0] = 0;                  for (i = 1; i < nr_class; i++)                      start[i] = start[i - 1] + count[i - 1];                    // calculate weighted C                    var weighted_C = new double[nr_class];                  for (i = 0; i < nr_class; i++)                      weighted_C[i] = param.C;                  for (i = 0; i < param.nr_weight; i++)                  {                      int j;                      for (j = 0; j < nr_class; j++)                          if (param.weight_label[i] == label[j])                              break;                      if (j == nr_class) ;                      /*Console.Error.Write("warning: class label " + param.weight_label[i] +                                          " specified in weight is not found\n");*/                      else                          weighted_C[j] *= param.weight[i];                  }                    // train k*(k-1)/2 models                    var nonzero = new bool[l];                  for (i = 0; i < l; i++)                      nonzero[i] = false;                  var f = new decision_function[nr_class*(nr_class - 1)/2];                    double[] probA = null' probB = null;                  if (param.probability == 1)                  {                      probA = new double[nr_class*(nr_class - 1)/2];                      probB = new double[nr_class*(nr_class - 1)/2];                  }                    int p = 0;                  for (i = 0; i < nr_class; i++)                      for (int j = i + 1; j < nr_class; j++)                      {                          var sub_prob = new svm_problem();                          int si = start[i]' sj = start[j];                          int ci = count[i]' cj = count[j];                          sub_prob.l = ci + cj;                          sub_prob.x = new svm_node[sub_prob.l][];                          sub_prob.y = new double[sub_prob.l];                          int k;                          for (k = 0; k < ci; k++)                          {                              sub_prob.x[k] = x[si + k];                              sub_prob.y[k] = + 1;                          }                          for (k = 0; k < cj; k++)                          {                              sub_prob.x[ci + k] = x[sj + k];                              sub_prob.y[ci + k] = - 1;                          }                            if (param.probability == 1)                          {                              var probAB = new double[2];                              svm_binary_svc_probability(sub_prob' param' weighted_C[i]' weighted_C[j]' probAB);                              probA[p] = probAB[0];                              probB[p] = probAB[1];                          }                            f[p] = svm_train_one(sub_prob' param' weighted_C[i]' weighted_C[j]);                          for (k = 0; k < ci; k++)                              if (!nonzero[si + k] && Math.Abs(f[p].alpha[k]) > 0)                                  nonzero[si + k] = true;                          for (k = 0; k < cj; k++)                              if (!nonzero[sj + k] && Math.Abs(f[p].alpha[ci + k]) > 0)                                  nonzero[sj + k] = true;                          ++p;                      }                    // build output                    model.nr_class = nr_class;                    model.label = new int[nr_class];                  for (i = 0; i < nr_class; i++)                      model.label[i] = label[i];                    model.rho = new double[nr_class*(nr_class - 1)/2];                  for (i = 0; i < nr_class*(nr_class - 1)/2; i++)                      model.rho[i] = f[i].rho;                    if (param.probability == 1)                  {                      model.probA = new double[nr_class*(nr_class - 1)/2];                      model.probB = new double[nr_class*(nr_class - 1)/2];                      for (i = 0; i < nr_class*(nr_class - 1)/2; i++)                      {                          model.probA[i] = probA[i];                          model.probB[i] = probB[i];                      }                  }                  else                  {                      model.probA = null;                      model.probB = null;                  }                    int nnz = 0;                  var nz_count = new int[nr_class];                  model.nSV = new int[nr_class];                  for (i = 0; i < nr_class; i++)                  {                      int nSV = 0;                      for (int j = 0; j < count[i]; j++)                          if (nonzero[start[i] + j])                          {                              ++nSV;                              ++nnz;                          }                      model.nSV[i] = nSV;                      nz_count[i] = nSV;                  }                    //Console.Out.Write("Total nSV = " + nnz + "\n");                    model.l = nnz;                  model.SV = new svm_node[nnz][];                  p = 0;                  for (i = 0; i < l; i++)                      if (nonzero[i])                          model.SV[p++] = x[i];                    var nz_start = new int[nr_class];                  nz_start[0] = 0;                  for (i = 1; i < nr_class; i++)                      nz_start[i] = nz_start[i - 1] + nz_count[i - 1];                    model.sv_coef = new double[nr_class - 1][];                  for (i = 0; i < nr_class - 1; i++)                      model.sv_coef[i] = new double[nnz];                    p = 0;                  for (i = 0; i < nr_class; i++)                      for (int j = i + 1; j < nr_class; j++)                      {                          // classifier (i'j): coefficients with                          // i are in sv_coef[j-1][nz_start[i]...]'                          // j are in sv_coef[i][nz_start[j]...]                            int si = start[i];                          int sj = start[j];                          int ci = count[i];                          int cj = count[j];                            int q = nz_start[i];                          int k;                          for (k = 0; k < ci; k++)                              if (nonzero[si + k])                                  model.sv_coef[j - 1][q++] = f[p].alpha[k];                          q = nz_start[j];                          for (k = 0; k < cj; k++)                              if (nonzero[sj + k])                                  model.sv_coef[i][q++] = f[p].alpha[ci + k];                          ++p;                      }              }
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_train,The following statement contains a magic number: if (param.svm_type == svm_parameter.ONE_CLASS || param.svm_type == svm_parameter.EPSILON_SVR ||                  param.svm_type == svm_parameter.NU_SVR)              {                  // regression or one-class-svm                  model.nr_class = 2;                  model.label = null;                  model.nSV = null;                  model.probA = null;                  model.probB = null;                  model.sv_coef = new double[1][];                    if (param.probability == 1 &&                      (param.svm_type == svm_parameter.EPSILON_SVR || param.svm_type == svm_parameter.NU_SVR))                  {                      model.probA = new double[1];                      model.probA[0] = svm_svr_probability(prob' param);                  }                    decision_function f = svm_train_one(prob' param' 0' 0);                  model.rho = new double[1];                  model.rho[0] = f.rho;                    int nSV = 0;                  int i;                  for (i = 0; i < prob.l; i++)                      if (Math.Abs(f.alpha[i]) > 0)                          ++nSV;                  model.l = nSV;                  model.SV = new svm_node[nSV][];                  model.sv_coef[0] = new double[nSV];                  int j = 0;                  for (i = 0; i < prob.l; i++)                      if (Math.Abs(f.alpha[i]) > 0)                      {                          model.SV[j] = prob.x[i];                          model.sv_coef[0][j] = f.alpha[i];                          ++j;                      }              }              else              {                  // classification                  // find out the number of classes                  int l = prob.l;                  int max_nr_class = 16;                  int nr_class = 0;                  var label = new int[max_nr_class];                  var count = new int[max_nr_class];                  var index = new int[l];                    int i;                  for (i = 0; i < l; i++)                  {                      //UPGRADE_WARNING: Data types in Visual C# might be different.  Verify the accuracy of narrowing conversions. 'ms-help://MS.VSCC.2003/commoner/redir/redirect.htm?keyword="jlca1042_3"'                      var this_label = (int) prob.y[i];                      int j;                      for (j = 0; j < nr_class; j++)                          if (this_label == label[j])                          {                              ++count[j];                              break;                          }                      index[i] = j;                      if (j == nr_class)                      {                          if (nr_class == max_nr_class)                          {                              max_nr_class *= 2;                              var new_data = new int[max_nr_class];                              Array.Copy(label' 0' new_data' 0' label.Length);                              label = new_data;                                new_data = new int[max_nr_class];                              Array.Copy(count' 0' new_data' 0' count.Length);                              count = new_data;                          }                          label[nr_class] = this_label;                          count[nr_class] = 1;                          ++nr_class;                      }                  }                    // group training data of the same class                    var start = new int[nr_class];                  start[0] = 0;                  for (i = 1; i < nr_class; i++)                      start[i] = start[i - 1] + count[i - 1];                    var x = new svm_node[l][];                    for (i = 0; i < l; i++)                  {                      x[start[index[i]]] = prob.x[i];                      ++start[index[i]];                  }                    start[0] = 0;                  for (i = 1; i < nr_class; i++)                      start[i] = start[i - 1] + count[i - 1];                    // calculate weighted C                    var weighted_C = new double[nr_class];                  for (i = 0; i < nr_class; i++)                      weighted_C[i] = param.C;                  for (i = 0; i < param.nr_weight; i++)                  {                      int j;                      for (j = 0; j < nr_class; j++)                          if (param.weight_label[i] == label[j])                              break;                      if (j == nr_class) ;                      /*Console.Error.Write("warning: class label " + param.weight_label[i] +                                          " specified in weight is not found\n");*/                      else                          weighted_C[j] *= param.weight[i];                  }                    // train k*(k-1)/2 models                    var nonzero = new bool[l];                  for (i = 0; i < l; i++)                      nonzero[i] = false;                  var f = new decision_function[nr_class*(nr_class - 1)/2];                    double[] probA = null' probB = null;                  if (param.probability == 1)                  {                      probA = new double[nr_class*(nr_class - 1)/2];                      probB = new double[nr_class*(nr_class - 1)/2];                  }                    int p = 0;                  for (i = 0; i < nr_class; i++)                      for (int j = i + 1; j < nr_class; j++)                      {                          var sub_prob = new svm_problem();                          int si = start[i]' sj = start[j];                          int ci = count[i]' cj = count[j];                          sub_prob.l = ci + cj;                          sub_prob.x = new svm_node[sub_prob.l][];                          sub_prob.y = new double[sub_prob.l];                          int k;                          for (k = 0; k < ci; k++)                          {                              sub_prob.x[k] = x[si + k];                              sub_prob.y[k] = + 1;                          }                          for (k = 0; k < cj; k++)                          {                              sub_prob.x[ci + k] = x[sj + k];                              sub_prob.y[ci + k] = - 1;                          }                            if (param.probability == 1)                          {                              var probAB = new double[2];                              svm_binary_svc_probability(sub_prob' param' weighted_C[i]' weighted_C[j]' probAB);                              probA[p] = probAB[0];                              probB[p] = probAB[1];                          }                            f[p] = svm_train_one(sub_prob' param' weighted_C[i]' weighted_C[j]);                          for (k = 0; k < ci; k++)                              if (!nonzero[si + k] && Math.Abs(f[p].alpha[k]) > 0)                                  nonzero[si + k] = true;                          for (k = 0; k < cj; k++)                              if (!nonzero[sj + k] && Math.Abs(f[p].alpha[ci + k]) > 0)                                  nonzero[sj + k] = true;                          ++p;                      }                    // build output                    model.nr_class = nr_class;                    model.label = new int[nr_class];                  for (i = 0; i < nr_class; i++)                      model.label[i] = label[i];                    model.rho = new double[nr_class*(nr_class - 1)/2];                  for (i = 0; i < nr_class*(nr_class - 1)/2; i++)                      model.rho[i] = f[i].rho;                    if (param.probability == 1)                  {                      model.probA = new double[nr_class*(nr_class - 1)/2];                      model.probB = new double[nr_class*(nr_class - 1)/2];                      for (i = 0; i < nr_class*(nr_class - 1)/2; i++)                      {                          model.probA[i] = probA[i];                          model.probB[i] = probB[i];                      }                  }                  else                  {                      model.probA = null;                      model.probB = null;                  }                    int nnz = 0;                  var nz_count = new int[nr_class];                  model.nSV = new int[nr_class];                  for (i = 0; i < nr_class; i++)                  {                      int nSV = 0;                      for (int j = 0; j < count[i]; j++)                          if (nonzero[start[i] + j])                          {                              ++nSV;                              ++nnz;                          }                      model.nSV[i] = nSV;                      nz_count[i] = nSV;                  }                    //Console.Out.Write("Total nSV = " + nnz + "\n");                    model.l = nnz;                  model.SV = new svm_node[nnz][];                  p = 0;                  for (i = 0; i < l; i++)                      if (nonzero[i])                          model.SV[p++] = x[i];                    var nz_start = new int[nr_class];                  nz_start[0] = 0;                  for (i = 1; i < nr_class; i++)                      nz_start[i] = nz_start[i - 1] + nz_count[i - 1];                    model.sv_coef = new double[nr_class - 1][];                  for (i = 0; i < nr_class - 1; i++)                      model.sv_coef[i] = new double[nnz];                    p = 0;                  for (i = 0; i < nr_class; i++)                      for (int j = i + 1; j < nr_class; j++)                      {                          // classifier (i'j): coefficients with                          // i are in sv_coef[j-1][nz_start[i]...]'                          // j are in sv_coef[i][nz_start[j]...]                            int si = start[i];                          int sj = start[j];                          int ci = count[i];                          int cj = count[j];                            int q = nz_start[i];                          int k;                          for (k = 0; k < ci; k++)                              if (nonzero[si + k])                                  model.sv_coef[j - 1][q++] = f[p].alpha[k];                          q = nz_start[j];                          for (k = 0; k < cj; k++)                              if (nonzero[sj + k])                                  model.sv_coef[i][q++] = f[p].alpha[ci + k];                          ++p;                      }              }
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_train,The following statement contains a magic number: if (param.svm_type == svm_parameter.ONE_CLASS || param.svm_type == svm_parameter.EPSILON_SVR ||                  param.svm_type == svm_parameter.NU_SVR)              {                  // regression or one-class-svm                  model.nr_class = 2;                  model.label = null;                  model.nSV = null;                  model.probA = null;                  model.probB = null;                  model.sv_coef = new double[1][];                    if (param.probability == 1 &&                      (param.svm_type == svm_parameter.EPSILON_SVR || param.svm_type == svm_parameter.NU_SVR))                  {                      model.probA = new double[1];                      model.probA[0] = svm_svr_probability(prob' param);                  }                    decision_function f = svm_train_one(prob' param' 0' 0);                  model.rho = new double[1];                  model.rho[0] = f.rho;                    int nSV = 0;                  int i;                  for (i = 0; i < prob.l; i++)                      if (Math.Abs(f.alpha[i]) > 0)                          ++nSV;                  model.l = nSV;                  model.SV = new svm_node[nSV][];                  model.sv_coef[0] = new double[nSV];                  int j = 0;                  for (i = 0; i < prob.l; i++)                      if (Math.Abs(f.alpha[i]) > 0)                      {                          model.SV[j] = prob.x[i];                          model.sv_coef[0][j] = f.alpha[i];                          ++j;                      }              }              else              {                  // classification                  // find out the number of classes                  int l = prob.l;                  int max_nr_class = 16;                  int nr_class = 0;                  var label = new int[max_nr_class];                  var count = new int[max_nr_class];                  var index = new int[l];                    int i;                  for (i = 0; i < l; i++)                  {                      //UPGRADE_WARNING: Data types in Visual C# might be different.  Verify the accuracy of narrowing conversions. 'ms-help://MS.VSCC.2003/commoner/redir/redirect.htm?keyword="jlca1042_3"'                      var this_label = (int) prob.y[i];                      int j;                      for (j = 0; j < nr_class; j++)                          if (this_label == label[j])                          {                              ++count[j];                              break;                          }                      index[i] = j;                      if (j == nr_class)                      {                          if (nr_class == max_nr_class)                          {                              max_nr_class *= 2;                              var new_data = new int[max_nr_class];                              Array.Copy(label' 0' new_data' 0' label.Length);                              label = new_data;                                new_data = new int[max_nr_class];                              Array.Copy(count' 0' new_data' 0' count.Length);                              count = new_data;                          }                          label[nr_class] = this_label;                          count[nr_class] = 1;                          ++nr_class;                      }                  }                    // group training data of the same class                    var start = new int[nr_class];                  start[0] = 0;                  for (i = 1; i < nr_class; i++)                      start[i] = start[i - 1] + count[i - 1];                    var x = new svm_node[l][];                    for (i = 0; i < l; i++)                  {                      x[start[index[i]]] = prob.x[i];                      ++start[index[i]];                  }                    start[0] = 0;                  for (i = 1; i < nr_class; i++)                      start[i] = start[i - 1] + count[i - 1];                    // calculate weighted C                    var weighted_C = new double[nr_class];                  for (i = 0; i < nr_class; i++)                      weighted_C[i] = param.C;                  for (i = 0; i < param.nr_weight; i++)                  {                      int j;                      for (j = 0; j < nr_class; j++)                          if (param.weight_label[i] == label[j])                              break;                      if (j == nr_class) ;                      /*Console.Error.Write("warning: class label " + param.weight_label[i] +                                          " specified in weight is not found\n");*/                      else                          weighted_C[j] *= param.weight[i];                  }                    // train k*(k-1)/2 models                    var nonzero = new bool[l];                  for (i = 0; i < l; i++)                      nonzero[i] = false;                  var f = new decision_function[nr_class*(nr_class - 1)/2];                    double[] probA = null' probB = null;                  if (param.probability == 1)                  {                      probA = new double[nr_class*(nr_class - 1)/2];                      probB = new double[nr_class*(nr_class - 1)/2];                  }                    int p = 0;                  for (i = 0; i < nr_class; i++)                      for (int j = i + 1; j < nr_class; j++)                      {                          var sub_prob = new svm_problem();                          int si = start[i]' sj = start[j];                          int ci = count[i]' cj = count[j];                          sub_prob.l = ci + cj;                          sub_prob.x = new svm_node[sub_prob.l][];                          sub_prob.y = new double[sub_prob.l];                          int k;                          for (k = 0; k < ci; k++)                          {                              sub_prob.x[k] = x[si + k];                              sub_prob.y[k] = + 1;                          }                          for (k = 0; k < cj; k++)                          {                              sub_prob.x[ci + k] = x[sj + k];                              sub_prob.y[ci + k] = - 1;                          }                            if (param.probability == 1)                          {                              var probAB = new double[2];                              svm_binary_svc_probability(sub_prob' param' weighted_C[i]' weighted_C[j]' probAB);                              probA[p] = probAB[0];                              probB[p] = probAB[1];                          }                            f[p] = svm_train_one(sub_prob' param' weighted_C[i]' weighted_C[j]);                          for (k = 0; k < ci; k++)                              if (!nonzero[si + k] && Math.Abs(f[p].alpha[k]) > 0)                                  nonzero[si + k] = true;                          for (k = 0; k < cj; k++)                              if (!nonzero[sj + k] && Math.Abs(f[p].alpha[ci + k]) > 0)                                  nonzero[sj + k] = true;                          ++p;                      }                    // build output                    model.nr_class = nr_class;                    model.label = new int[nr_class];                  for (i = 0; i < nr_class; i++)                      model.label[i] = label[i];                    model.rho = new double[nr_class*(nr_class - 1)/2];                  for (i = 0; i < nr_class*(nr_class - 1)/2; i++)                      model.rho[i] = f[i].rho;                    if (param.probability == 1)                  {                      model.probA = new double[nr_class*(nr_class - 1)/2];                      model.probB = new double[nr_class*(nr_class - 1)/2];                      for (i = 0; i < nr_class*(nr_class - 1)/2; i++)                      {                          model.probA[i] = probA[i];                          model.probB[i] = probB[i];                      }                  }                  else                  {                      model.probA = null;                      model.probB = null;                  }                    int nnz = 0;                  var nz_count = new int[nr_class];                  model.nSV = new int[nr_class];                  for (i = 0; i < nr_class; i++)                  {                      int nSV = 0;                      for (int j = 0; j < count[i]; j++)                          if (nonzero[start[i] + j])                          {                              ++nSV;                              ++nnz;                          }                      model.nSV[i] = nSV;                      nz_count[i] = nSV;                  }                    //Console.Out.Write("Total nSV = " + nnz + "\n");                    model.l = nnz;                  model.SV = new svm_node[nnz][];                  p = 0;                  for (i = 0; i < l; i++)                      if (nonzero[i])                          model.SV[p++] = x[i];                    var nz_start = new int[nr_class];                  nz_start[0] = 0;                  for (i = 1; i < nr_class; i++)                      nz_start[i] = nz_start[i - 1] + nz_count[i - 1];                    model.sv_coef = new double[nr_class - 1][];                  for (i = 0; i < nr_class - 1; i++)                      model.sv_coef[i] = new double[nnz];                    p = 0;                  for (i = 0; i < nr_class; i++)                      for (int j = i + 1; j < nr_class; j++)                      {                          // classifier (i'j): coefficients with                          // i are in sv_coef[j-1][nz_start[i]...]'                          // j are in sv_coef[i][nz_start[j]...]                            int si = start[i];                          int sj = start[j];                          int ci = count[i];                          int cj = count[j];                            int q = nz_start[i];                          int k;                          for (k = 0; k < ci; k++)                              if (nonzero[si + k])                                  model.sv_coef[j - 1][q++] = f[p].alpha[k];                          q = nz_start[j];                          for (k = 0; k < cj; k++)                              if (nonzero[sj + k])                                  model.sv_coef[i][q++] = f[p].alpha[ci + k];                          ++p;                      }              }
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_train,The following statement contains a magic number: if (param.svm_type == svm_parameter.ONE_CLASS || param.svm_type == svm_parameter.EPSILON_SVR ||                  param.svm_type == svm_parameter.NU_SVR)              {                  // regression or one-class-svm                  model.nr_class = 2;                  model.label = null;                  model.nSV = null;                  model.probA = null;                  model.probB = null;                  model.sv_coef = new double[1][];                    if (param.probability == 1 &&                      (param.svm_type == svm_parameter.EPSILON_SVR || param.svm_type == svm_parameter.NU_SVR))                  {                      model.probA = new double[1];                      model.probA[0] = svm_svr_probability(prob' param);                  }                    decision_function f = svm_train_one(prob' param' 0' 0);                  model.rho = new double[1];                  model.rho[0] = f.rho;                    int nSV = 0;                  int i;                  for (i = 0; i < prob.l; i++)                      if (Math.Abs(f.alpha[i]) > 0)                          ++nSV;                  model.l = nSV;                  model.SV = new svm_node[nSV][];                  model.sv_coef[0] = new double[nSV];                  int j = 0;                  for (i = 0; i < prob.l; i++)                      if (Math.Abs(f.alpha[i]) > 0)                      {                          model.SV[j] = prob.x[i];                          model.sv_coef[0][j] = f.alpha[i];                          ++j;                      }              }              else              {                  // classification                  // find out the number of classes                  int l = prob.l;                  int max_nr_class = 16;                  int nr_class = 0;                  var label = new int[max_nr_class];                  var count = new int[max_nr_class];                  var index = new int[l];                    int i;                  for (i = 0; i < l; i++)                  {                      //UPGRADE_WARNING: Data types in Visual C# might be different.  Verify the accuracy of narrowing conversions. 'ms-help://MS.VSCC.2003/commoner/redir/redirect.htm?keyword="jlca1042_3"'                      var this_label = (int) prob.y[i];                      int j;                      for (j = 0; j < nr_class; j++)                          if (this_label == label[j])                          {                              ++count[j];                              break;                          }                      index[i] = j;                      if (j == nr_class)                      {                          if (nr_class == max_nr_class)                          {                              max_nr_class *= 2;                              var new_data = new int[max_nr_class];                              Array.Copy(label' 0' new_data' 0' label.Length);                              label = new_data;                                new_data = new int[max_nr_class];                              Array.Copy(count' 0' new_data' 0' count.Length);                              count = new_data;                          }                          label[nr_class] = this_label;                          count[nr_class] = 1;                          ++nr_class;                      }                  }                    // group training data of the same class                    var start = new int[nr_class];                  start[0] = 0;                  for (i = 1; i < nr_class; i++)                      start[i] = start[i - 1] + count[i - 1];                    var x = new svm_node[l][];                    for (i = 0; i < l; i++)                  {                      x[start[index[i]]] = prob.x[i];                      ++start[index[i]];                  }                    start[0] = 0;                  for (i = 1; i < nr_class; i++)                      start[i] = start[i - 1] + count[i - 1];                    // calculate weighted C                    var weighted_C = new double[nr_class];                  for (i = 0; i < nr_class; i++)                      weighted_C[i] = param.C;                  for (i = 0; i < param.nr_weight; i++)                  {                      int j;                      for (j = 0; j < nr_class; j++)                          if (param.weight_label[i] == label[j])                              break;                      if (j == nr_class) ;                      /*Console.Error.Write("warning: class label " + param.weight_label[i] +                                          " specified in weight is not found\n");*/                      else                          weighted_C[j] *= param.weight[i];                  }                    // train k*(k-1)/2 models                    var nonzero = new bool[l];                  for (i = 0; i < l; i++)                      nonzero[i] = false;                  var f = new decision_function[nr_class*(nr_class - 1)/2];                    double[] probA = null' probB = null;                  if (param.probability == 1)                  {                      probA = new double[nr_class*(nr_class - 1)/2];                      probB = new double[nr_class*(nr_class - 1)/2];                  }                    int p = 0;                  for (i = 0; i < nr_class; i++)                      for (int j = i + 1; j < nr_class; j++)                      {                          var sub_prob = new svm_problem();                          int si = start[i]' sj = start[j];                          int ci = count[i]' cj = count[j];                          sub_prob.l = ci + cj;                          sub_prob.x = new svm_node[sub_prob.l][];                          sub_prob.y = new double[sub_prob.l];                          int k;                          for (k = 0; k < ci; k++)                          {                              sub_prob.x[k] = x[si + k];                              sub_prob.y[k] = + 1;                          }                          for (k = 0; k < cj; k++)                          {                              sub_prob.x[ci + k] = x[sj + k];                              sub_prob.y[ci + k] = - 1;                          }                            if (param.probability == 1)                          {                              var probAB = new double[2];                              svm_binary_svc_probability(sub_prob' param' weighted_C[i]' weighted_C[j]' probAB);                              probA[p] = probAB[0];                              probB[p] = probAB[1];                          }                            f[p] = svm_train_one(sub_prob' param' weighted_C[i]' weighted_C[j]);                          for (k = 0; k < ci; k++)                              if (!nonzero[si + k] && Math.Abs(f[p].alpha[k]) > 0)                                  nonzero[si + k] = true;                          for (k = 0; k < cj; k++)                              if (!nonzero[sj + k] && Math.Abs(f[p].alpha[ci + k]) > 0)                                  nonzero[sj + k] = true;                          ++p;                      }                    // build output                    model.nr_class = nr_class;                    model.label = new int[nr_class];                  for (i = 0; i < nr_class; i++)                      model.label[i] = label[i];                    model.rho = new double[nr_class*(nr_class - 1)/2];                  for (i = 0; i < nr_class*(nr_class - 1)/2; i++)                      model.rho[i] = f[i].rho;                    if (param.probability == 1)                  {                      model.probA = new double[nr_class*(nr_class - 1)/2];                      model.probB = new double[nr_class*(nr_class - 1)/2];                      for (i = 0; i < nr_class*(nr_class - 1)/2; i++)                      {                          model.probA[i] = probA[i];                          model.probB[i] = probB[i];                      }                  }                  else                  {                      model.probA = null;                      model.probB = null;                  }                    int nnz = 0;                  var nz_count = new int[nr_class];                  model.nSV = new int[nr_class];                  for (i = 0; i < nr_class; i++)                  {                      int nSV = 0;                      for (int j = 0; j < count[i]; j++)                          if (nonzero[start[i] + j])                          {                              ++nSV;                              ++nnz;                          }                      model.nSV[i] = nSV;                      nz_count[i] = nSV;                  }                    //Console.Out.Write("Total nSV = " + nnz + "\n");                    model.l = nnz;                  model.SV = new svm_node[nnz][];                  p = 0;                  for (i = 0; i < l; i++)                      if (nonzero[i])                          model.SV[p++] = x[i];                    var nz_start = new int[nr_class];                  nz_start[0] = 0;                  for (i = 1; i < nr_class; i++)                      nz_start[i] = nz_start[i - 1] + nz_count[i - 1];                    model.sv_coef = new double[nr_class - 1][];                  for (i = 0; i < nr_class - 1; i++)                      model.sv_coef[i] = new double[nnz];                    p = 0;                  for (i = 0; i < nr_class; i++)                      for (int j = i + 1; j < nr_class; j++)                      {                          // classifier (i'j): coefficients with                          // i are in sv_coef[j-1][nz_start[i]...]'                          // j are in sv_coef[i][nz_start[j]...]                            int si = start[i];                          int sj = start[j];                          int ci = count[i];                          int cj = count[j];                            int q = nz_start[i];                          int k;                          for (k = 0; k < ci; k++)                              if (nonzero[si + k])                                  model.sv_coef[j - 1][q++] = f[p].alpha[k];                          q = nz_start[j];                          for (k = 0; k < cj; k++)                              if (nonzero[sj + k])                                  model.sv_coef[i][q++] = f[p].alpha[ci + k];                          ++p;                      }              }
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_train,The following statement contains a magic number: if (param.svm_type == svm_parameter.ONE_CLASS || param.svm_type == svm_parameter.EPSILON_SVR ||                  param.svm_type == svm_parameter.NU_SVR)              {                  // regression or one-class-svm                  model.nr_class = 2;                  model.label = null;                  model.nSV = null;                  model.probA = null;                  model.probB = null;                  model.sv_coef = new double[1][];                    if (param.probability == 1 &&                      (param.svm_type == svm_parameter.EPSILON_SVR || param.svm_type == svm_parameter.NU_SVR))                  {                      model.probA = new double[1];                      model.probA[0] = svm_svr_probability(prob' param);                  }                    decision_function f = svm_train_one(prob' param' 0' 0);                  model.rho = new double[1];                  model.rho[0] = f.rho;                    int nSV = 0;                  int i;                  for (i = 0; i < prob.l; i++)                      if (Math.Abs(f.alpha[i]) > 0)                          ++nSV;                  model.l = nSV;                  model.SV = new svm_node[nSV][];                  model.sv_coef[0] = new double[nSV];                  int j = 0;                  for (i = 0; i < prob.l; i++)                      if (Math.Abs(f.alpha[i]) > 0)                      {                          model.SV[j] = prob.x[i];                          model.sv_coef[0][j] = f.alpha[i];                          ++j;                      }              }              else              {                  // classification                  // find out the number of classes                  int l = prob.l;                  int max_nr_class = 16;                  int nr_class = 0;                  var label = new int[max_nr_class];                  var count = new int[max_nr_class];                  var index = new int[l];                    int i;                  for (i = 0; i < l; i++)                  {                      //UPGRADE_WARNING: Data types in Visual C# might be different.  Verify the accuracy of narrowing conversions. 'ms-help://MS.VSCC.2003/commoner/redir/redirect.htm?keyword="jlca1042_3"'                      var this_label = (int) prob.y[i];                      int j;                      for (j = 0; j < nr_class; j++)                          if (this_label == label[j])                          {                              ++count[j];                              break;                          }                      index[i] = j;                      if (j == nr_class)                      {                          if (nr_class == max_nr_class)                          {                              max_nr_class *= 2;                              var new_data = new int[max_nr_class];                              Array.Copy(label' 0' new_data' 0' label.Length);                              label = new_data;                                new_data = new int[max_nr_class];                              Array.Copy(count' 0' new_data' 0' count.Length);                              count = new_data;                          }                          label[nr_class] = this_label;                          count[nr_class] = 1;                          ++nr_class;                      }                  }                    // group training data of the same class                    var start = new int[nr_class];                  start[0] = 0;                  for (i = 1; i < nr_class; i++)                      start[i] = start[i - 1] + count[i - 1];                    var x = new svm_node[l][];                    for (i = 0; i < l; i++)                  {                      x[start[index[i]]] = prob.x[i];                      ++start[index[i]];                  }                    start[0] = 0;                  for (i = 1; i < nr_class; i++)                      start[i] = start[i - 1] + count[i - 1];                    // calculate weighted C                    var weighted_C = new double[nr_class];                  for (i = 0; i < nr_class; i++)                      weighted_C[i] = param.C;                  for (i = 0; i < param.nr_weight; i++)                  {                      int j;                      for (j = 0; j < nr_class; j++)                          if (param.weight_label[i] == label[j])                              break;                      if (j == nr_class) ;                      /*Console.Error.Write("warning: class label " + param.weight_label[i] +                                          " specified in weight is not found\n");*/                      else                          weighted_C[j] *= param.weight[i];                  }                    // train k*(k-1)/2 models                    var nonzero = new bool[l];                  for (i = 0; i < l; i++)                      nonzero[i] = false;                  var f = new decision_function[nr_class*(nr_class - 1)/2];                    double[] probA = null' probB = null;                  if (param.probability == 1)                  {                      probA = new double[nr_class*(nr_class - 1)/2];                      probB = new double[nr_class*(nr_class - 1)/2];                  }                    int p = 0;                  for (i = 0; i < nr_class; i++)                      for (int j = i + 1; j < nr_class; j++)                      {                          var sub_prob = new svm_problem();                          int si = start[i]' sj = start[j];                          int ci = count[i]' cj = count[j];                          sub_prob.l = ci + cj;                          sub_prob.x = new svm_node[sub_prob.l][];                          sub_prob.y = new double[sub_prob.l];                          int k;                          for (k = 0; k < ci; k++)                          {                              sub_prob.x[k] = x[si + k];                              sub_prob.y[k] = + 1;                          }                          for (k = 0; k < cj; k++)                          {                              sub_prob.x[ci + k] = x[sj + k];                              sub_prob.y[ci + k] = - 1;                          }                            if (param.probability == 1)                          {                              var probAB = new double[2];                              svm_binary_svc_probability(sub_prob' param' weighted_C[i]' weighted_C[j]' probAB);                              probA[p] = probAB[0];                              probB[p] = probAB[1];                          }                            f[p] = svm_train_one(sub_prob' param' weighted_C[i]' weighted_C[j]);                          for (k = 0; k < ci; k++)                              if (!nonzero[si + k] && Math.Abs(f[p].alpha[k]) > 0)                                  nonzero[si + k] = true;                          for (k = 0; k < cj; k++)                              if (!nonzero[sj + k] && Math.Abs(f[p].alpha[ci + k]) > 0)                                  nonzero[sj + k] = true;                          ++p;                      }                    // build output                    model.nr_class = nr_class;                    model.label = new int[nr_class];                  for (i = 0; i < nr_class; i++)                      model.label[i] = label[i];                    model.rho = new double[nr_class*(nr_class - 1)/2];                  for (i = 0; i < nr_class*(nr_class - 1)/2; i++)                      model.rho[i] = f[i].rho;                    if (param.probability == 1)                  {                      model.probA = new double[nr_class*(nr_class - 1)/2];                      model.probB = new double[nr_class*(nr_class - 1)/2];                      for (i = 0; i < nr_class*(nr_class - 1)/2; i++)                      {                          model.probA[i] = probA[i];                          model.probB[i] = probB[i];                      }                  }                  else                  {                      model.probA = null;                      model.probB = null;                  }                    int nnz = 0;                  var nz_count = new int[nr_class];                  model.nSV = new int[nr_class];                  for (i = 0; i < nr_class; i++)                  {                      int nSV = 0;                      for (int j = 0; j < count[i]; j++)                          if (nonzero[start[i] + j])                          {                              ++nSV;                              ++nnz;                          }                      model.nSV[i] = nSV;                      nz_count[i] = nSV;                  }                    //Console.Out.Write("Total nSV = " + nnz + "\n");                    model.l = nnz;                  model.SV = new svm_node[nnz][];                  p = 0;                  for (i = 0; i < l; i++)                      if (nonzero[i])                          model.SV[p++] = x[i];                    var nz_start = new int[nr_class];                  nz_start[0] = 0;                  for (i = 1; i < nr_class; i++)                      nz_start[i] = nz_start[i - 1] + nz_count[i - 1];                    model.sv_coef = new double[nr_class - 1][];                  for (i = 0; i < nr_class - 1; i++)                      model.sv_coef[i] = new double[nnz];                    p = 0;                  for (i = 0; i < nr_class; i++)                      for (int j = i + 1; j < nr_class; j++)                      {                          // classifier (i'j): coefficients with                          // i are in sv_coef[j-1][nz_start[i]...]'                          // j are in sv_coef[i][nz_start[j]...]                            int si = start[i];                          int sj = start[j];                          int ci = count[i];                          int cj = count[j];                            int q = nz_start[i];                          int k;                          for (k = 0; k < ci; k++)                              if (nonzero[si + k])                                  model.sv_coef[j - 1][q++] = f[p].alpha[k];                          q = nz_start[j];                          for (k = 0; k < cj; k++)                              if (nonzero[sj + k])                                  model.sv_coef[i][q++] = f[p].alpha[ci + k];                          ++p;                      }              }
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_predict,The following statement contains a magic number: if (model.param.svm_type == svm_parameter.ONE_CLASS || model.param.svm_type == svm_parameter.EPSILON_SVR ||                  model.param.svm_type == svm_parameter.NU_SVR)              {                  var res = new double[1];                  svm_predict_values(model' x' res);                    if (model.param.svm_type == svm_parameter.ONE_CLASS)                      return (res[0] > 0) ? 1 : - 1;                  else                      return res[0];              }              else              {                  int i;                  int nr_class = model.nr_class;                  var dec_values = new double[nr_class*(nr_class - 1)/2];                  svm_predict_values(model' x' dec_values);                    var vote = new int[nr_class];                  for (i = 0; i < nr_class; i++)                      vote[i] = 0;                  int pos = 0;                  for (i = 0; i < nr_class; i++)                      for (int j = i + 1; j < nr_class; j++)                      {                          if (dec_values[pos++] > 0)                              ++vote[i];                          else                              ++vote[j];                      }                    int vote_max_idx = 0;                  for (i = 1; i < nr_class; i++)                      if (vote[i] > vote[vote_max_idx])                          vote_max_idx = i;                  return model.label[vote_max_idx];              }
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_predict_probability,The following statement contains a magic number: if ((model.param.svm_type == svm_parameter.C_SVC || model.param.svm_type == svm_parameter.NU_SVC) &&                  model.probA != null && model.probB != null)              {                  int i;                  int nr_class = model.nr_class;                  var dec_values = new double[nr_class*(nr_class - 1)/2];                  svm_predict_values(model' x' dec_values);                    double min_prob = 1e-7;                  var tmpArray = new double[nr_class][];                  for (int i2 = 0; i2 < nr_class; i2++)                  {                      tmpArray[i2] = new double[nr_class];                  }                  double[][] pairwise_prob = tmpArray;                    int k = 0;                  for (i = 0; i < nr_class; i++)                      for (int j = i + 1; j < nr_class; j++)                      {                          pairwise_prob[i][j] =                              Math.Min(                                  Math.Max(sigmoid_predict(dec_values[k]' model.probA[k]' model.probB[k])' min_prob)'                                  1 - min_prob);                          pairwise_prob[j][i] = 1 - pairwise_prob[i][j];                          k++;                      }                  multiclass_probability(nr_class' pairwise_prob' prob_estimates);                    int prob_max_idx = 0;                  for (i = 1; i < nr_class; i++)                      if (prob_estimates[i] > prob_estimates[prob_max_idx])                          prob_max_idx = i;                  return model.label[prob_max_idx];              }              else                  return svm_predict(model' x);
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_predict_probability,The following statement contains a magic number: if ((model.param.svm_type == svm_parameter.C_SVC || model.param.svm_type == svm_parameter.NU_SVC) &&                  model.probA != null && model.probB != null)              {                  int i;                  int nr_class = model.nr_class;                  var dec_values = new double[nr_class*(nr_class - 1)/2];                  svm_predict_values(model' x' dec_values);                    double min_prob = 1e-7;                  var tmpArray = new double[nr_class][];                  for (int i2 = 0; i2 < nr_class; i2++)                  {                      tmpArray[i2] = new double[nr_class];                  }                  double[][] pairwise_prob = tmpArray;                    int k = 0;                  for (i = 0; i < nr_class; i++)                      for (int j = i + 1; j < nr_class; j++)                      {                          pairwise_prob[i][j] =                              Math.Min(                                  Math.Max(sigmoid_predict(dec_values[k]' model.probA[k]' model.probB[k])' min_prob)'                                  1 - min_prob);                          pairwise_prob[j][i] = 1 - pairwise_prob[i][j];                          k++;                      }                  multiclass_probability(nr_class' pairwise_prob' prob_estimates);                    int prob_max_idx = 0;                  for (i = 1; i < nr_class; i++)                      if (prob_estimates[i] > prob_estimates[prob_max_idx])                          prob_max_idx = i;                  return model.label[prob_max_idx];              }              else                  return svm_predict(model' x);
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_save_model,The following statement contains a magic number: {                  fp.Write("rho");                  for (int i = 0; i < nr_class*(nr_class - 1)/2; i++)                      fp.Write(" " + model.rho[i]);                  fp.Write("\n");              }
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_save_model,The following statement contains a magic number: if (model.probA != null)                  // regression has probA only              {                  fp.Write("probA");                  for (int i = 0; i < nr_class*(nr_class - 1)/2; i++)                      fp.Write(" " + model.probA[i]);                  fp.Write("\n");              }
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_save_model,The following statement contains a magic number: if (model.probB != null)              {                  fp.Write("probB");                  for (int i = 0; i < nr_class*(nr_class - 1)/2; i++)                      fp.Write(" " + model.probB[i]);                  fp.Write("\n");              }
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_load_model,The following statement contains a magic number: while (true)              {                  String cmd = fp.ReadLine();                  String arg = cmd.Substring(cmd.IndexOf(' ') + 1);                    if (cmd.StartsWith("svm_type"))                  {                      int i;                      for (i = 0; i < svm_type_table.Length; i++)                      {                          if (arg.IndexOf(svm_type_table[i]) != -1)                          {                              param.svm_type = i;                              break;                          }                      }                      if (i == svm_type_table.Length)                      {                          //Console.Error.Write("unknown svm type.\n");                          return null;                      }                  }                  else if (cmd.StartsWith("kernel_type"))                  {                      int i;                      for (i = 0; i < kernel_type_table.Length; i++)                      {                          if (arg.IndexOf(kernel_type_table[i]) != -1)                          {                              param.kernel_type = i;                              break;                          }                      }                      if (i == kernel_type_table.Length)                      {                          //Console.Error.Write("unknown kernel function.\n");                          return null;                      }                  }                  else if (cmd.StartsWith("degree"))                      param.degree = atof(arg);                  else if (cmd.StartsWith("gamma"))                      param.gamma = atof(arg);                  else if (cmd.StartsWith("coef0"))                      param.coef0 = atof(arg);                  else if (cmd.StartsWith("nr_class"))                      model.nr_class = atoi(arg);                  else if (cmd.StartsWith("total_sv"))                      model.l = atoi(arg);                  else if (cmd.StartsWith("rho"))                  {                      int n = model.nr_class*(model.nr_class - 1)/2;                      model.rho = new double[n];                      var st = new SupportClass.Tokenizer(arg);                      for (int i = 0; i < n; i++)                          model.rho[i] = atof(st.NextToken());                  }                  else if (cmd.StartsWith("label"))                  {                      int n = model.nr_class;                      model.label = new int[n];                      var st = new SupportClass.Tokenizer(arg);                      for (int i = 0; i < n; i++)                          model.label[i] = atoi(st.NextToken());                  }                  else if (cmd.StartsWith("probA"))                  {                      int n = model.nr_class*(model.nr_class - 1)/2;                      model.probA = new double[n];                      var st = new SupportClass.Tokenizer(arg);                      for (int i = 0; i < n; i++)                          model.probA[i] = atof(st.NextToken());                  }                  else if (cmd.StartsWith("probB"))                  {                      int n = model.nr_class*(model.nr_class - 1)/2;                      model.probB = new double[n];                      var st = new SupportClass.Tokenizer(arg);                      for (int i = 0; i < n; i++)                          model.probB[i] = atof(st.NextToken());                  }                  else if (cmd.StartsWith("nr_sv"))                  {                      int n = model.nr_class;                      model.nSV = new int[n];                      var st = new SupportClass.Tokenizer(arg);                      for (int i = 0; i < n; i++)                          model.nSV[i] = atoi(st.NextToken());                  }                  else if (cmd.StartsWith("SV"))                  {                      break;                  }                  else                  {                      //Console.Error.Write("unknown text in model file\n");                      return null;                  }              }
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_load_model,The following statement contains a magic number: while (true)              {                  String cmd = fp.ReadLine();                  String arg = cmd.Substring(cmd.IndexOf(' ') + 1);                    if (cmd.StartsWith("svm_type"))                  {                      int i;                      for (i = 0; i < svm_type_table.Length; i++)                      {                          if (arg.IndexOf(svm_type_table[i]) != -1)                          {                              param.svm_type = i;                              break;                          }                      }                      if (i == svm_type_table.Length)                      {                          //Console.Error.Write("unknown svm type.\n");                          return null;                      }                  }                  else if (cmd.StartsWith("kernel_type"))                  {                      int i;                      for (i = 0; i < kernel_type_table.Length; i++)                      {                          if (arg.IndexOf(kernel_type_table[i]) != -1)                          {                              param.kernel_type = i;                              break;                          }                      }                      if (i == kernel_type_table.Length)                      {                          //Console.Error.Write("unknown kernel function.\n");                          return null;                      }                  }                  else if (cmd.StartsWith("degree"))                      param.degree = atof(arg);                  else if (cmd.StartsWith("gamma"))                      param.gamma = atof(arg);                  else if (cmd.StartsWith("coef0"))                      param.coef0 = atof(arg);                  else if (cmd.StartsWith("nr_class"))                      model.nr_class = atoi(arg);                  else if (cmd.StartsWith("total_sv"))                      model.l = atoi(arg);                  else if (cmd.StartsWith("rho"))                  {                      int n = model.nr_class*(model.nr_class - 1)/2;                      model.rho = new double[n];                      var st = new SupportClass.Tokenizer(arg);                      for (int i = 0; i < n; i++)                          model.rho[i] = atof(st.NextToken());                  }                  else if (cmd.StartsWith("label"))                  {                      int n = model.nr_class;                      model.label = new int[n];                      var st = new SupportClass.Tokenizer(arg);                      for (int i = 0; i < n; i++)                          model.label[i] = atoi(st.NextToken());                  }                  else if (cmd.StartsWith("probA"))                  {                      int n = model.nr_class*(model.nr_class - 1)/2;                      model.probA = new double[n];                      var st = new SupportClass.Tokenizer(arg);                      for (int i = 0; i < n; i++)                          model.probA[i] = atof(st.NextToken());                  }                  else if (cmd.StartsWith("probB"))                  {                      int n = model.nr_class*(model.nr_class - 1)/2;                      model.probB = new double[n];                      var st = new SupportClass.Tokenizer(arg);                      for (int i = 0; i < n; i++)                          model.probB[i] = atof(st.NextToken());                  }                  else if (cmd.StartsWith("nr_sv"))                  {                      int n = model.nr_class;                      model.nSV = new int[n];                      var st = new SupportClass.Tokenizer(arg);                      for (int i = 0; i < n; i++)                          model.nSV[i] = atoi(st.NextToken());                  }                  else if (cmd.StartsWith("SV"))                  {                      break;                  }                  else                  {                      //Console.Error.Write("unknown text in model file\n");                      return null;                  }              }
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_load_model,The following statement contains a magic number: while (true)              {                  String cmd = fp.ReadLine();                  String arg = cmd.Substring(cmd.IndexOf(' ') + 1);                    if (cmd.StartsWith("svm_type"))                  {                      int i;                      for (i = 0; i < svm_type_table.Length; i++)                      {                          if (arg.IndexOf(svm_type_table[i]) != -1)                          {                              param.svm_type = i;                              break;                          }                      }                      if (i == svm_type_table.Length)                      {                          //Console.Error.Write("unknown svm type.\n");                          return null;                      }                  }                  else if (cmd.StartsWith("kernel_type"))                  {                      int i;                      for (i = 0; i < kernel_type_table.Length; i++)                      {                          if (arg.IndexOf(kernel_type_table[i]) != -1)                          {                              param.kernel_type = i;                              break;                          }                      }                      if (i == kernel_type_table.Length)                      {                          //Console.Error.Write("unknown kernel function.\n");                          return null;                      }                  }                  else if (cmd.StartsWith("degree"))                      param.degree = atof(arg);                  else if (cmd.StartsWith("gamma"))                      param.gamma = atof(arg);                  else if (cmd.StartsWith("coef0"))                      param.coef0 = atof(arg);                  else if (cmd.StartsWith("nr_class"))                      model.nr_class = atoi(arg);                  else if (cmd.StartsWith("total_sv"))                      model.l = atoi(arg);                  else if (cmd.StartsWith("rho"))                  {                      int n = model.nr_class*(model.nr_class - 1)/2;                      model.rho = new double[n];                      var st = new SupportClass.Tokenizer(arg);                      for (int i = 0; i < n; i++)                          model.rho[i] = atof(st.NextToken());                  }                  else if (cmd.StartsWith("label"))                  {                      int n = model.nr_class;                      model.label = new int[n];                      var st = new SupportClass.Tokenizer(arg);                      for (int i = 0; i < n; i++)                          model.label[i] = atoi(st.NextToken());                  }                  else if (cmd.StartsWith("probA"))                  {                      int n = model.nr_class*(model.nr_class - 1)/2;                      model.probA = new double[n];                      var st = new SupportClass.Tokenizer(arg);                      for (int i = 0; i < n; i++)                          model.probA[i] = atof(st.NextToken());                  }                  else if (cmd.StartsWith("probB"))                  {                      int n = model.nr_class*(model.nr_class - 1)/2;                      model.probB = new double[n];                      var st = new SupportClass.Tokenizer(arg);                      for (int i = 0; i < n; i++)                          model.probB[i] = atof(st.NextToken());                  }                  else if (cmd.StartsWith("nr_sv"))                  {                      int n = model.nr_class;                      model.nSV = new int[n];                      var st = new SupportClass.Tokenizer(arg);                      for (int i = 0; i < n; i++)                          model.nSV[i] = atoi(st.NextToken());                  }                  else if (cmd.StartsWith("SV"))                  {                      break;                  }                  else                  {                      //Console.Error.Write("unknown text in model file\n");                      return null;                  }              }
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_load_model,The following statement contains a magic number: for (int i = 0; i < l; i++)              {                  String line = fp.ReadLine();                  var st = new SupportClass.Tokenizer(line' " \t\n\r\f:");                    for (int k = 0; k < m; k++)                      model.sv_coef[k][i] = atof(st.NextToken());                  int n = st.Count/2;                  model.SV[i] = new svm_node[n];                  for (int j = 0; j < n; j++)                  {                      model.SV[i][j] = new svm_node();                      model.SV[i][j].index = atoi(st.NextToken());                      model.SV[i][j].value_Renamed = atof(st.NextToken());                  }              }
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_check_parameter,The following statement contains a magic number: if (svm_type == svm_parameter.NU_SVC)              {                  int l = prob.l;                  int max_nr_class = 16;                  int nr_class = 0;                  var label = new int[max_nr_class];                  var count = new int[max_nr_class];                    int i;                  for (i = 0; i < l; i++)                  {                      //UPGRADE_WARNING: Data types in Visual C# might be different.  Verify the accuracy of narrowing conversions. 'ms-help://MS.VSCC.2003/commoner/redir/redirect.htm?keyword="jlca1042_3"'                      var this_label = (int) prob.y[i];                      int j;                      for (j = 0; j < nr_class; j++)                          if (this_label == label[j])                          {                              ++count[j];                              break;                          }                        if (j == nr_class)                      {                          if (nr_class == max_nr_class)                          {                              max_nr_class *= 2;                              var new_data = new int[max_nr_class];                              Array.Copy(label' 0' new_data' 0' label.Length);                              label = new_data;                                new_data = new int[max_nr_class];                              Array.Copy(count' 0' new_data' 0' count.Length);                              count = new_data;                          }                          label[nr_class] = this_label;                          count[nr_class] = 1;                          ++nr_class;                      }                  }                    for (i = 0; i < nr_class; i++)                  {                      int n1 = count[i];                      for (int j = i + 1; j < nr_class; j++)                      {                          int n2 = count[j];                          if (param.nu*(n1 + n2)/2 > Math.Min(n1' n2))                              return "specified nu is infeasible";                      }                  }              }
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_check_parameter,The following statement contains a magic number: if (svm_type == svm_parameter.NU_SVC)              {                  int l = prob.l;                  int max_nr_class = 16;                  int nr_class = 0;                  var label = new int[max_nr_class];                  var count = new int[max_nr_class];                    int i;                  for (i = 0; i < l; i++)                  {                      //UPGRADE_WARNING: Data types in Visual C# might be different.  Verify the accuracy of narrowing conversions. 'ms-help://MS.VSCC.2003/commoner/redir/redirect.htm?keyword="jlca1042_3"'                      var this_label = (int) prob.y[i];                      int j;                      for (j = 0; j < nr_class; j++)                          if (this_label == label[j])                          {                              ++count[j];                              break;                          }                        if (j == nr_class)                      {                          if (nr_class == max_nr_class)                          {                              max_nr_class *= 2;                              var new_data = new int[max_nr_class];                              Array.Copy(label' 0' new_data' 0' label.Length);                              label = new_data;                                new_data = new int[max_nr_class];                              Array.Copy(count' 0' new_data' 0' count.Length);                              count = new_data;                          }                          label[nr_class] = this_label;                          count[nr_class] = 1;                          ++nr_class;                      }                  }                    for (i = 0; i < nr_class; i++)                  {                      int n1 = count[i];                      for (int j = i + 1; j < nr_class; j++)                      {                          int n2 = count[j];                          if (param.nu*(n1 + n2)/2 > Math.Min(n1' n2))                              return "specified nu is infeasible";                      }                  }              }
Magic Number,Encog.MathUtil.LIBSVM,svm,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_check_parameter,The following statement contains a magic number: if (svm_type == svm_parameter.NU_SVC)              {                  int l = prob.l;                  int max_nr_class = 16;                  int nr_class = 0;                  var label = new int[max_nr_class];                  var count = new int[max_nr_class];                    int i;                  for (i = 0; i < l; i++)                  {                      //UPGRADE_WARNING: Data types in Visual C# might be different.  Verify the accuracy of narrowing conversions. 'ms-help://MS.VSCC.2003/commoner/redir/redirect.htm?keyword="jlca1042_3"'                      var this_label = (int) prob.y[i];                      int j;                      for (j = 0; j < nr_class; j++)                          if (this_label == label[j])                          {                              ++count[j];                              break;                          }                        if (j == nr_class)                      {                          if (nr_class == max_nr_class)                          {                              max_nr_class *= 2;                              var new_data = new int[max_nr_class];                              Array.Copy(label' 0' new_data' 0' label.Length);                              label = new_data;                                new_data = new int[max_nr_class];                              Array.Copy(count' 0' new_data' 0' count.Length);                              count = new_data;                          }                          label[nr_class] = this_label;                          count[nr_class] = 1;                          ++nr_class;                      }                  }                    for (i = 0; i < nr_class; i++)                  {                      int n1 = count[i];                      for (int j = i + 1; j < nr_class; j++)                      {                          int n2 = count[j];                          if (param.nu*(n1 + n2)/2 > Math.Min(n1' n2))                              return "specified nu is infeasible";                      }                  }              }
Magic Number,Encog.MathUtil.Matrices,BiPolarUtil,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\BiPolarUtil.cs,ToBinary,The following statement contains a magic number: return (d + 1)/2.0;
Magic Number,Encog.MathUtil.Matrices,BiPolarUtil,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\BiPolarUtil.cs,ToBiPolar,The following statement contains a magic number: return (2*NormalizeBinary(d)) - 1;
Magic Number,Encog.MathUtil.Matrices,Matrix,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Matrix.cs,Equals,The following statement contains a magic number: if (other is Matrix)                  return equals((Matrix) other' 10);              else                  return false;
Magic Number,Encog.MathUtil.Matrices,Matrix,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Matrix.cs,equals,The following statement contains a magic number: double test = Math.Pow(10.0' precision);
Magic Number,Encog.MathUtil.Matrices,Matrix,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Matrix.cs,equals,The following statement contains a magic number: precision = (int) Math.Pow(10' precision);
Magic Number,Encog.MathUtil.Matrices,MatrixMath,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\MatrixMath.cs,VectorLength,The following statement contains a magic number: for (int i = 0; i < v.Length; i++)              {                  rtn += Math.Pow(v[i]' 2);              }
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Tql2,The following statement contains a magic number: double eps = Math.Pow(2.0' -52.0);
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Tql2,The following statement contains a magic number: double eps = Math.Pow(2.0' -52.0);
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Tql2,The following statement contains a magic number: for (int l = 0; l < n; l++)              {                  // Find small subdiagonal element                    tst1 = Math.Max(tst1' Math.Abs(d[l]) + Math.Abs(e[l]));                  int m = l;                  while (m < n)                  {                      if (Math.Abs(e[m]) <= eps*tst1)                      {                          break;                      }                      m++;                  }                    // If m == l' d[l] is an eigenvalue'                  // otherwise' iterate.                    if (m > l)                  {                      int iter = 0;                      do                      {                          iter = iter + 1; // (Could check iteration count here.)                            // Compute implicit shift                            double g = d[l];                          double p = (d[l + 1] - g)/(2.0*e[l]);                          double r = EncogMath.Hypot(p' 1.0);                          if (p < 0)                          {                              r = -r;                          }                          d[l] = e[l]/(p + r);                          d[l + 1] = e[l]*(p + r);                          double dl1 = d[l + 1];                          double h = g - d[l];                          for (int i = l + 2; i < n; i++)                          {                              d[i] -= h;                          }                          f = f + h;                            // Implicit QL transformation.                            p = d[m];                          double c = 1.0;                          double c2 = c;                          double c3 = c;                          double el1 = e[l + 1];                          double s = 0.0;                          double s2 = 0.0;                          for (int i = m - 1; i >= l; i--)                          {                              c3 = c2;                              c2 = c;                              s2 = s;                              g = c*e[i];                              h = c*p;                              r = EncogMath.Hypot(p' e[i]);                              e[i + 1] = s*r;                              s = e[i]/r;                              c = p/r;                              p = c*d[i] - s*g;                              d[i + 1] = h + s*(c*g + s*d[i]);                                // Accumulate transformation.                                for (int k = 0; k < n; k++)                              {                                  h = v[k][i + 1];                                  v[k][i + 1] = s*v[k][i] + c*h;                                  v[k][i] = c*v[k][i] - s*h;                              }                          }                          p = -s*s2*c3*el1*e[l]/dl1;                          e[l] = s*p;                          d[l] = c*p;                            // Check for convergence.                      } while (Math.Abs(e[l]) > eps*tst1);                  }                  d[l] = d[l] + f;                  e[l] = 0.0;              }
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Tql2,The following statement contains a magic number: for (int l = 0; l < n; l++)              {                  // Find small subdiagonal element                    tst1 = Math.Max(tst1' Math.Abs(d[l]) + Math.Abs(e[l]));                  int m = l;                  while (m < n)                  {                      if (Math.Abs(e[m]) <= eps*tst1)                      {                          break;                      }                      m++;                  }                    // If m == l' d[l] is an eigenvalue'                  // otherwise' iterate.                    if (m > l)                  {                      int iter = 0;                      do                      {                          iter = iter + 1; // (Could check iteration count here.)                            // Compute implicit shift                            double g = d[l];                          double p = (d[l + 1] - g)/(2.0*e[l]);                          double r = EncogMath.Hypot(p' 1.0);                          if (p < 0)                          {                              r = -r;                          }                          d[l] = e[l]/(p + r);                          d[l + 1] = e[l]*(p + r);                          double dl1 = d[l + 1];                          double h = g - d[l];                          for (int i = l + 2; i < n; i++)                          {                              d[i] -= h;                          }                          f = f + h;                            // Implicit QL transformation.                            p = d[m];                          double c = 1.0;                          double c2 = c;                          double c3 = c;                          double el1 = e[l + 1];                          double s = 0.0;                          double s2 = 0.0;                          for (int i = m - 1; i >= l; i--)                          {                              c3 = c2;                              c2 = c;                              s2 = s;                              g = c*e[i];                              h = c*p;                              r = EncogMath.Hypot(p' e[i]);                              e[i + 1] = s*r;                              s = e[i]/r;                              c = p/r;                              p = c*d[i] - s*g;                              d[i + 1] = h + s*(c*g + s*d[i]);                                // Accumulate transformation.                                for (int k = 0; k < n; k++)                              {                                  h = v[k][i + 1];                                  v[k][i + 1] = s*v[k][i] + c*h;                                  v[k][i] = c*v[k][i] - s*h;                              }                          }                          p = -s*s2*c3*el1*e[l]/dl1;                          e[l] = s*p;                          d[l] = c*p;                            // Check for convergence.                      } while (Math.Abs(e[l]) > eps*tst1);                  }                  d[l] = d[l] + f;                  e[l] = 0.0;              }
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: double eps = Math.Pow(2.0' -52.0);
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: double eps = Math.Pow(2.0' -52.0);
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: while (n >= low)              {                  // Look for single small sub-diagonal element                    int l = n;                  while (l > low)                  {                      s = Math.Abs(h[l - 1][l - 1]) + Math.Abs(h[l][l]);                      if (s == 0.0)                      {                          s = norm;                      }                      if (Math.Abs(h[l][l - 1]) < eps*s)                      {                          break;                      }                      l--;                  }                    // Check for convergence                  // One root found                    if (l == n)                  {                      h[n][n] = h[n][n] + exshift;                      d[n] = h[n][n];                      e[n] = 0.0;                      n--;                      iter = 0;                        // Two roots found                  }                  else if (l == n - 1)                  {                      w = h[n][n - 1]*h[n - 1][n];                      p = (h[n - 1][n - 1] - h[n][n])/2.0;                      q = p*p + w;                      z = Math.Sqrt(Math.Abs(q));                      h[n][n] = h[n][n] + exshift;                      h[n - 1][n - 1] = h[n - 1][n - 1] + exshift;                      x = h[n][n];                        // Real pair                        if (q >= 0)                      {                          if (p >= 0)                          {                              z = p + z;                          }                          else                          {                              z = p - z;                          }                          d[n - 1] = x + z;                          d[n] = d[n - 1];                          if (z != 0.0)                          {                              d[n] = x - w/z;                          }                          e[n - 1] = 0.0;                          e[n] = 0.0;                          x = h[n][n - 1];                          s = Math.Abs(x) + Math.Abs(z);                          p = x/s;                          q = z/s;                          r = Math.Sqrt(p*p + q*q);                          p = p/r;                          q = q/r;                            // Row modification                            for (int j = n - 1; j < nn; j++)                          {                              z = h[n - 1][j];                              h[n - 1][j] = q*z + p*h[n][j];                              h[n][j] = q*h[n][j] - p*z;                          }                            // Column modification                            for (int i = 0; i <= n; i++)                          {                              z = h[i][n - 1];                              h[i][n - 1] = q*z + p*h[i][n];                              h[i][n] = q*h[i][n] - p*z;                          }                            // Accumulate transformations                            for (int i = low; i <= high; i++)                          {                              z = v[i][n - 1];                              v[i][n - 1] = q*z + p*v[i][n];                              v[i][n] = q*v[i][n] - p*z;                          }                            // Complex pair                      }                      else                      {                          d[n - 1] = x + p;                          d[n] = x + p;                          e[n - 1] = z;                          e[n] = -z;                      }                      n = n - 2;                      iter = 0;                        // No convergence yet                  }                  else                  {                      // Form shift                        x = h[n][n];                      y = 0.0;                      w = 0.0;                      if (l < n)                      {                          y = h[n - 1][n - 1];                          w = h[n][n - 1]*h[n - 1][n];                      }                        // Wilkinson's original ad hoc shift                        if (iter == 10)                      {                          exshift += x;                          for (int i = low; i <= n; i++)                          {                              h[i][i] -= x;                          }                          s = Math.Abs(h[n][n - 1]) + Math.Abs(h[n - 1][n - 2]);                          x = y = 0.75*s;                          w = -0.4375*s*s;                      }                        // MATLAB's new ad hoc shift                        if (iter == 30)                      {                          s = (y - x)/2.0;                          s = s*s + w;                          if (s > 0)                          {                              s = Math.Sqrt(s);                              if (y < x)                              {                                  s = -s;                              }                              s = x - w/((y - x)/2.0 + s);                              for (int i = low; i <= n; i++)                              {                                  h[i][i] -= s;                              }                              exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1; // (Could check iteration count here.)                        // Look for two consecutive small sub-diagonal elements                        int m = n - 2;                      while (m >= l)                      {                          z = h[m][m];                          r = x - z;                          s = y - z;                          p = (r*s - w)/h[m + 1][m] + h[m][m + 1];                          q = h[m + 1][m + 1] - z - r - s;                          r = h[m + 2][m + 1];                          s = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                          p = p/s;                          q = q/s;                          r = r/s;                          if (m == l)                          {                              break;                          }                          if (Math.Abs(h[m][m - 1])*(Math.Abs(q) + Math.Abs(r)) < eps                              *(Math.Abs(p)*(Math.Abs(h[m - 1][m - 1])                                             + Math.Abs(z) + Math.Abs(h[m + 1][m + 1]))))                          {                              break;                          }                          m--;                      }                        for (int i = m + 2; i <= n; i++)                      {                          h[i][i - 2] = 0.0;                          if (i > m + 2)                          {                              h[i][i - 3] = 0.0;                          }                      }                        // Double QR step involving rows l:n and columns m:n                        for (int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                          if (k != m)                          {                              p = h[k][k - 1];                              q = h[k + 1][k - 1];                              r = (notlast ? h[k + 2][k - 1] : 0.0);                              x = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                              if (x != 0.0)                              {                                  p = p/x;                                  q = q/x;                                  r = r/x;                              }                          }                          if (x == 0.0)                          {                              break;                          }                          s = Math.Sqrt(p*p + q*q + r*r);                          if (p < 0)                          {                              s = -s;                          }                          if (s != 0)                          {                              if (k != m)                              {                                  h[k][k - 1] = -s*x;                              }                              else if (l != m)                              {                                  h[k][k - 1] = -h[k][k - 1];                              }                              p = p + s;                              x = p/s;                              y = q/s;                              z = r/s;                              q = q/p;                              r = r/p;                                // Row modification                                for (int j = k; j < nn; j++)                              {                                  p = h[k][j] + q*h[k + 1][j];                                  if (notlast)                                  {                                      p = p + r*h[k + 2][j];                                      h[k + 2][j] = h[k + 2][j] - p*z;                                  }                                  h[k][j] = h[k][j] - p*x;                                  h[k + 1][j] = h[k + 1][j] - p*y;                              }                                // Column modification                                for (int i = 0; i <= Math.Min(n' k + 3); i++)                              {                                  p = x*h[i][k] + y*h[i][k + 1];                                  if (notlast)                                  {                                      p = p + z*h[i][k + 2];                                      h[i][k + 2] = h[i][k + 2] - p*r;                                  }                                  h[i][k] = h[i][k] - p;                                  h[i][k + 1] = h[i][k + 1] - p*q;                              }                                // Accumulate transformations                                for (int i = low; i <= high; i++)                              {                                  p = x*v[i][k] + y*v[i][k + 1];                                  if (notlast)                                  {                                      p = p + z*v[i][k + 2];                                      v[i][k + 2] = v[i][k + 2] - p*r;                                  }                                  v[i][k] = v[i][k] - p;                                  v[i][k + 1] = v[i][k + 1] - p*q;                              }                          } // (s != 0)                      } // k loop                  } // check convergence              }
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: while (n >= low)              {                  // Look for single small sub-diagonal element                    int l = n;                  while (l > low)                  {                      s = Math.Abs(h[l - 1][l - 1]) + Math.Abs(h[l][l]);                      if (s == 0.0)                      {                          s = norm;                      }                      if (Math.Abs(h[l][l - 1]) < eps*s)                      {                          break;                      }                      l--;                  }                    // Check for convergence                  // One root found                    if (l == n)                  {                      h[n][n] = h[n][n] + exshift;                      d[n] = h[n][n];                      e[n] = 0.0;                      n--;                      iter = 0;                        // Two roots found                  }                  else if (l == n - 1)                  {                      w = h[n][n - 1]*h[n - 1][n];                      p = (h[n - 1][n - 1] - h[n][n])/2.0;                      q = p*p + w;                      z = Math.Sqrt(Math.Abs(q));                      h[n][n] = h[n][n] + exshift;                      h[n - 1][n - 1] = h[n - 1][n - 1] + exshift;                      x = h[n][n];                        // Real pair                        if (q >= 0)                      {                          if (p >= 0)                          {                              z = p + z;                          }                          else                          {                              z = p - z;                          }                          d[n - 1] = x + z;                          d[n] = d[n - 1];                          if (z != 0.0)                          {                              d[n] = x - w/z;                          }                          e[n - 1] = 0.0;                          e[n] = 0.0;                          x = h[n][n - 1];                          s = Math.Abs(x) + Math.Abs(z);                          p = x/s;                          q = z/s;                          r = Math.Sqrt(p*p + q*q);                          p = p/r;                          q = q/r;                            // Row modification                            for (int j = n - 1; j < nn; j++)                          {                              z = h[n - 1][j];                              h[n - 1][j] = q*z + p*h[n][j];                              h[n][j] = q*h[n][j] - p*z;                          }                            // Column modification                            for (int i = 0; i <= n; i++)                          {                              z = h[i][n - 1];                              h[i][n - 1] = q*z + p*h[i][n];                              h[i][n] = q*h[i][n] - p*z;                          }                            // Accumulate transformations                            for (int i = low; i <= high; i++)                          {                              z = v[i][n - 1];                              v[i][n - 1] = q*z + p*v[i][n];                              v[i][n] = q*v[i][n] - p*z;                          }                            // Complex pair                      }                      else                      {                          d[n - 1] = x + p;                          d[n] = x + p;                          e[n - 1] = z;                          e[n] = -z;                      }                      n = n - 2;                      iter = 0;                        // No convergence yet                  }                  else                  {                      // Form shift                        x = h[n][n];                      y = 0.0;                      w = 0.0;                      if (l < n)                      {                          y = h[n - 1][n - 1];                          w = h[n][n - 1]*h[n - 1][n];                      }                        // Wilkinson's original ad hoc shift                        if (iter == 10)                      {                          exshift += x;                          for (int i = low; i <= n; i++)                          {                              h[i][i] -= x;                          }                          s = Math.Abs(h[n][n - 1]) + Math.Abs(h[n - 1][n - 2]);                          x = y = 0.75*s;                          w = -0.4375*s*s;                      }                        // MATLAB's new ad hoc shift                        if (iter == 30)                      {                          s = (y - x)/2.0;                          s = s*s + w;                          if (s > 0)                          {                              s = Math.Sqrt(s);                              if (y < x)                              {                                  s = -s;                              }                              s = x - w/((y - x)/2.0 + s);                              for (int i = low; i <= n; i++)                              {                                  h[i][i] -= s;                              }                              exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1; // (Could check iteration count here.)                        // Look for two consecutive small sub-diagonal elements                        int m = n - 2;                      while (m >= l)                      {                          z = h[m][m];                          r = x - z;                          s = y - z;                          p = (r*s - w)/h[m + 1][m] + h[m][m + 1];                          q = h[m + 1][m + 1] - z - r - s;                          r = h[m + 2][m + 1];                          s = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                          p = p/s;                          q = q/s;                          r = r/s;                          if (m == l)                          {                              break;                          }                          if (Math.Abs(h[m][m - 1])*(Math.Abs(q) + Math.Abs(r)) < eps                              *(Math.Abs(p)*(Math.Abs(h[m - 1][m - 1])                                             + Math.Abs(z) + Math.Abs(h[m + 1][m + 1]))))                          {                              break;                          }                          m--;                      }                        for (int i = m + 2; i <= n; i++)                      {                          h[i][i - 2] = 0.0;                          if (i > m + 2)                          {                              h[i][i - 3] = 0.0;                          }                      }                        // Double QR step involving rows l:n and columns m:n                        for (int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                          if (k != m)                          {                              p = h[k][k - 1];                              q = h[k + 1][k - 1];                              r = (notlast ? h[k + 2][k - 1] : 0.0);                              x = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                              if (x != 0.0)                              {                                  p = p/x;                                  q = q/x;                                  r = r/x;                              }                          }                          if (x == 0.0)                          {                              break;                          }                          s = Math.Sqrt(p*p + q*q + r*r);                          if (p < 0)                          {                              s = -s;                          }                          if (s != 0)                          {                              if (k != m)                              {                                  h[k][k - 1] = -s*x;                              }                              else if (l != m)                              {                                  h[k][k - 1] = -h[k][k - 1];                              }                              p = p + s;                              x = p/s;                              y = q/s;                              z = r/s;                              q = q/p;                              r = r/p;                                // Row modification                                for (int j = k; j < nn; j++)                              {                                  p = h[k][j] + q*h[k + 1][j];                                  if (notlast)                                  {                                      p = p + r*h[k + 2][j];                                      h[k + 2][j] = h[k + 2][j] - p*z;                                  }                                  h[k][j] = h[k][j] - p*x;                                  h[k + 1][j] = h[k + 1][j] - p*y;                              }                                // Column modification                                for (int i = 0; i <= Math.Min(n' k + 3); i++)                              {                                  p = x*h[i][k] + y*h[i][k + 1];                                  if (notlast)                                  {                                      p = p + z*h[i][k + 2];                                      h[i][k + 2] = h[i][k + 2] - p*r;                                  }                                  h[i][k] = h[i][k] - p;                                  h[i][k + 1] = h[i][k + 1] - p*q;                              }                                // Accumulate transformations                                for (int i = low; i <= high; i++)                              {                                  p = x*v[i][k] + y*v[i][k + 1];                                  if (notlast)                                  {                                      p = p + z*v[i][k + 2];                                      v[i][k + 2] = v[i][k + 2] - p*r;                                  }                                  v[i][k] = v[i][k] - p;                                  v[i][k + 1] = v[i][k + 1] - p*q;                              }                          } // (s != 0)                      } // k loop                  } // check convergence              }
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: while (n >= low)              {                  // Look for single small sub-diagonal element                    int l = n;                  while (l > low)                  {                      s = Math.Abs(h[l - 1][l - 1]) + Math.Abs(h[l][l]);                      if (s == 0.0)                      {                          s = norm;                      }                      if (Math.Abs(h[l][l - 1]) < eps*s)                      {                          break;                      }                      l--;                  }                    // Check for convergence                  // One root found                    if (l == n)                  {                      h[n][n] = h[n][n] + exshift;                      d[n] = h[n][n];                      e[n] = 0.0;                      n--;                      iter = 0;                        // Two roots found                  }                  else if (l == n - 1)                  {                      w = h[n][n - 1]*h[n - 1][n];                      p = (h[n - 1][n - 1] - h[n][n])/2.0;                      q = p*p + w;                      z = Math.Sqrt(Math.Abs(q));                      h[n][n] = h[n][n] + exshift;                      h[n - 1][n - 1] = h[n - 1][n - 1] + exshift;                      x = h[n][n];                        // Real pair                        if (q >= 0)                      {                          if (p >= 0)                          {                              z = p + z;                          }                          else                          {                              z = p - z;                          }                          d[n - 1] = x + z;                          d[n] = d[n - 1];                          if (z != 0.0)                          {                              d[n] = x - w/z;                          }                          e[n - 1] = 0.0;                          e[n] = 0.0;                          x = h[n][n - 1];                          s = Math.Abs(x) + Math.Abs(z);                          p = x/s;                          q = z/s;                          r = Math.Sqrt(p*p + q*q);                          p = p/r;                          q = q/r;                            // Row modification                            for (int j = n - 1; j < nn; j++)                          {                              z = h[n - 1][j];                              h[n - 1][j] = q*z + p*h[n][j];                              h[n][j] = q*h[n][j] - p*z;                          }                            // Column modification                            for (int i = 0; i <= n; i++)                          {                              z = h[i][n - 1];                              h[i][n - 1] = q*z + p*h[i][n];                              h[i][n] = q*h[i][n] - p*z;                          }                            // Accumulate transformations                            for (int i = low; i <= high; i++)                          {                              z = v[i][n - 1];                              v[i][n - 1] = q*z + p*v[i][n];                              v[i][n] = q*v[i][n] - p*z;                          }                            // Complex pair                      }                      else                      {                          d[n - 1] = x + p;                          d[n] = x + p;                          e[n - 1] = z;                          e[n] = -z;                      }                      n = n - 2;                      iter = 0;                        // No convergence yet                  }                  else                  {                      // Form shift                        x = h[n][n];                      y = 0.0;                      w = 0.0;                      if (l < n)                      {                          y = h[n - 1][n - 1];                          w = h[n][n - 1]*h[n - 1][n];                      }                        // Wilkinson's original ad hoc shift                        if (iter == 10)                      {                          exshift += x;                          for (int i = low; i <= n; i++)                          {                              h[i][i] -= x;                          }                          s = Math.Abs(h[n][n - 1]) + Math.Abs(h[n - 1][n - 2]);                          x = y = 0.75*s;                          w = -0.4375*s*s;                      }                        // MATLAB's new ad hoc shift                        if (iter == 30)                      {                          s = (y - x)/2.0;                          s = s*s + w;                          if (s > 0)                          {                              s = Math.Sqrt(s);                              if (y < x)                              {                                  s = -s;                              }                              s = x - w/((y - x)/2.0 + s);                              for (int i = low; i <= n; i++)                              {                                  h[i][i] -= s;                              }                              exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1; // (Could check iteration count here.)                        // Look for two consecutive small sub-diagonal elements                        int m = n - 2;                      while (m >= l)                      {                          z = h[m][m];                          r = x - z;                          s = y - z;                          p = (r*s - w)/h[m + 1][m] + h[m][m + 1];                          q = h[m + 1][m + 1] - z - r - s;                          r = h[m + 2][m + 1];                          s = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                          p = p/s;                          q = q/s;                          r = r/s;                          if (m == l)                          {                              break;                          }                          if (Math.Abs(h[m][m - 1])*(Math.Abs(q) + Math.Abs(r)) < eps                              *(Math.Abs(p)*(Math.Abs(h[m - 1][m - 1])                                             + Math.Abs(z) + Math.Abs(h[m + 1][m + 1]))))                          {                              break;                          }                          m--;                      }                        for (int i = m + 2; i <= n; i++)                      {                          h[i][i - 2] = 0.0;                          if (i > m + 2)                          {                              h[i][i - 3] = 0.0;                          }                      }                        // Double QR step involving rows l:n and columns m:n                        for (int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                          if (k != m)                          {                              p = h[k][k - 1];                              q = h[k + 1][k - 1];                              r = (notlast ? h[k + 2][k - 1] : 0.0);                              x = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                              if (x != 0.0)                              {                                  p = p/x;                                  q = q/x;                                  r = r/x;                              }                          }                          if (x == 0.0)                          {                              break;                          }                          s = Math.Sqrt(p*p + q*q + r*r);                          if (p < 0)                          {                              s = -s;                          }                          if (s != 0)                          {                              if (k != m)                              {                                  h[k][k - 1] = -s*x;                              }                              else if (l != m)                              {                                  h[k][k - 1] = -h[k][k - 1];                              }                              p = p + s;                              x = p/s;                              y = q/s;                              z = r/s;                              q = q/p;                              r = r/p;                                // Row modification                                for (int j = k; j < nn; j++)                              {                                  p = h[k][j] + q*h[k + 1][j];                                  if (notlast)                                  {                                      p = p + r*h[k + 2][j];                                      h[k + 2][j] = h[k + 2][j] - p*z;                                  }                                  h[k][j] = h[k][j] - p*x;                                  h[k + 1][j] = h[k + 1][j] - p*y;                              }                                // Column modification                                for (int i = 0; i <= Math.Min(n' k + 3); i++)                              {                                  p = x*h[i][k] + y*h[i][k + 1];                                  if (notlast)                                  {                                      p = p + z*h[i][k + 2];                                      h[i][k + 2] = h[i][k + 2] - p*r;                                  }                                  h[i][k] = h[i][k] - p;                                  h[i][k + 1] = h[i][k + 1] - p*q;                              }                                // Accumulate transformations                                for (int i = low; i <= high; i++)                              {                                  p = x*v[i][k] + y*v[i][k + 1];                                  if (notlast)                                  {                                      p = p + z*v[i][k + 2];                                      v[i][k + 2] = v[i][k + 2] - p*r;                                  }                                  v[i][k] = v[i][k] - p;                                  v[i][k + 1] = v[i][k + 1] - p*q;                              }                          } // (s != 0)                      } // k loop                  } // check convergence              }
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: while (n >= low)              {                  // Look for single small sub-diagonal element                    int l = n;                  while (l > low)                  {                      s = Math.Abs(h[l - 1][l - 1]) + Math.Abs(h[l][l]);                      if (s == 0.0)                      {                          s = norm;                      }                      if (Math.Abs(h[l][l - 1]) < eps*s)                      {                          break;                      }                      l--;                  }                    // Check for convergence                  // One root found                    if (l == n)                  {                      h[n][n] = h[n][n] + exshift;                      d[n] = h[n][n];                      e[n] = 0.0;                      n--;                      iter = 0;                        // Two roots found                  }                  else if (l == n - 1)                  {                      w = h[n][n - 1]*h[n - 1][n];                      p = (h[n - 1][n - 1] - h[n][n])/2.0;                      q = p*p + w;                      z = Math.Sqrt(Math.Abs(q));                      h[n][n] = h[n][n] + exshift;                      h[n - 1][n - 1] = h[n - 1][n - 1] + exshift;                      x = h[n][n];                        // Real pair                        if (q >= 0)                      {                          if (p >= 0)                          {                              z = p + z;                          }                          else                          {                              z = p - z;                          }                          d[n - 1] = x + z;                          d[n] = d[n - 1];                          if (z != 0.0)                          {                              d[n] = x - w/z;                          }                          e[n - 1] = 0.0;                          e[n] = 0.0;                          x = h[n][n - 1];                          s = Math.Abs(x) + Math.Abs(z);                          p = x/s;                          q = z/s;                          r = Math.Sqrt(p*p + q*q);                          p = p/r;                          q = q/r;                            // Row modification                            for (int j = n - 1; j < nn; j++)                          {                              z = h[n - 1][j];                              h[n - 1][j] = q*z + p*h[n][j];                              h[n][j] = q*h[n][j] - p*z;                          }                            // Column modification                            for (int i = 0; i <= n; i++)                          {                              z = h[i][n - 1];                              h[i][n - 1] = q*z + p*h[i][n];                              h[i][n] = q*h[i][n] - p*z;                          }                            // Accumulate transformations                            for (int i = low; i <= high; i++)                          {                              z = v[i][n - 1];                              v[i][n - 1] = q*z + p*v[i][n];                              v[i][n] = q*v[i][n] - p*z;                          }                            // Complex pair                      }                      else                      {                          d[n - 1] = x + p;                          d[n] = x + p;                          e[n - 1] = z;                          e[n] = -z;                      }                      n = n - 2;                      iter = 0;                        // No convergence yet                  }                  else                  {                      // Form shift                        x = h[n][n];                      y = 0.0;                      w = 0.0;                      if (l < n)                      {                          y = h[n - 1][n - 1];                          w = h[n][n - 1]*h[n - 1][n];                      }                        // Wilkinson's original ad hoc shift                        if (iter == 10)                      {                          exshift += x;                          for (int i = low; i <= n; i++)                          {                              h[i][i] -= x;                          }                          s = Math.Abs(h[n][n - 1]) + Math.Abs(h[n - 1][n - 2]);                          x = y = 0.75*s;                          w = -0.4375*s*s;                      }                        // MATLAB's new ad hoc shift                        if (iter == 30)                      {                          s = (y - x)/2.0;                          s = s*s + w;                          if (s > 0)                          {                              s = Math.Sqrt(s);                              if (y < x)                              {                                  s = -s;                              }                              s = x - w/((y - x)/2.0 + s);                              for (int i = low; i <= n; i++)                              {                                  h[i][i] -= s;                              }                              exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1; // (Could check iteration count here.)                        // Look for two consecutive small sub-diagonal elements                        int m = n - 2;                      while (m >= l)                      {                          z = h[m][m];                          r = x - z;                          s = y - z;                          p = (r*s - w)/h[m + 1][m] + h[m][m + 1];                          q = h[m + 1][m + 1] - z - r - s;                          r = h[m + 2][m + 1];                          s = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                          p = p/s;                          q = q/s;                          r = r/s;                          if (m == l)                          {                              break;                          }                          if (Math.Abs(h[m][m - 1])*(Math.Abs(q) + Math.Abs(r)) < eps                              *(Math.Abs(p)*(Math.Abs(h[m - 1][m - 1])                                             + Math.Abs(z) + Math.Abs(h[m + 1][m + 1]))))                          {                              break;                          }                          m--;                      }                        for (int i = m + 2; i <= n; i++)                      {                          h[i][i - 2] = 0.0;                          if (i > m + 2)                          {                              h[i][i - 3] = 0.0;                          }                      }                        // Double QR step involving rows l:n and columns m:n                        for (int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                          if (k != m)                          {                              p = h[k][k - 1];                              q = h[k + 1][k - 1];                              r = (notlast ? h[k + 2][k - 1] : 0.0);                              x = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                              if (x != 0.0)                              {                                  p = p/x;                                  q = q/x;                                  r = r/x;                              }                          }                          if (x == 0.0)                          {                              break;                          }                          s = Math.Sqrt(p*p + q*q + r*r);                          if (p < 0)                          {                              s = -s;                          }                          if (s != 0)                          {                              if (k != m)                              {                                  h[k][k - 1] = -s*x;                              }                              else if (l != m)                              {                                  h[k][k - 1] = -h[k][k - 1];                              }                              p = p + s;                              x = p/s;                              y = q/s;                              z = r/s;                              q = q/p;                              r = r/p;                                // Row modification                                for (int j = k; j < nn; j++)                              {                                  p = h[k][j] + q*h[k + 1][j];                                  if (notlast)                                  {                                      p = p + r*h[k + 2][j];                                      h[k + 2][j] = h[k + 2][j] - p*z;                                  }                                  h[k][j] = h[k][j] - p*x;                                  h[k + 1][j] = h[k + 1][j] - p*y;                              }                                // Column modification                                for (int i = 0; i <= Math.Min(n' k + 3); i++)                              {                                  p = x*h[i][k] + y*h[i][k + 1];                                  if (notlast)                                  {                                      p = p + z*h[i][k + 2];                                      h[i][k + 2] = h[i][k + 2] - p*r;                                  }                                  h[i][k] = h[i][k] - p;                                  h[i][k + 1] = h[i][k + 1] - p*q;                              }                                // Accumulate transformations                                for (int i = low; i <= high; i++)                              {                                  p = x*v[i][k] + y*v[i][k + 1];                                  if (notlast)                                  {                                      p = p + z*v[i][k + 2];                                      v[i][k + 2] = v[i][k + 2] - p*r;                                  }                                  v[i][k] = v[i][k] - p;                                  v[i][k + 1] = v[i][k + 1] - p*q;                              }                          } // (s != 0)                      } // k loop                  } // check convergence              }
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: while (n >= low)              {                  // Look for single small sub-diagonal element                    int l = n;                  while (l > low)                  {                      s = Math.Abs(h[l - 1][l - 1]) + Math.Abs(h[l][l]);                      if (s == 0.0)                      {                          s = norm;                      }                      if (Math.Abs(h[l][l - 1]) < eps*s)                      {                          break;                      }                      l--;                  }                    // Check for convergence                  // One root found                    if (l == n)                  {                      h[n][n] = h[n][n] + exshift;                      d[n] = h[n][n];                      e[n] = 0.0;                      n--;                      iter = 0;                        // Two roots found                  }                  else if (l == n - 1)                  {                      w = h[n][n - 1]*h[n - 1][n];                      p = (h[n - 1][n - 1] - h[n][n])/2.0;                      q = p*p + w;                      z = Math.Sqrt(Math.Abs(q));                      h[n][n] = h[n][n] + exshift;                      h[n - 1][n - 1] = h[n - 1][n - 1] + exshift;                      x = h[n][n];                        // Real pair                        if (q >= 0)                      {                          if (p >= 0)                          {                              z = p + z;                          }                          else                          {                              z = p - z;                          }                          d[n - 1] = x + z;                          d[n] = d[n - 1];                          if (z != 0.0)                          {                              d[n] = x - w/z;                          }                          e[n - 1] = 0.0;                          e[n] = 0.0;                          x = h[n][n - 1];                          s = Math.Abs(x) + Math.Abs(z);                          p = x/s;                          q = z/s;                          r = Math.Sqrt(p*p + q*q);                          p = p/r;                          q = q/r;                            // Row modification                            for (int j = n - 1; j < nn; j++)                          {                              z = h[n - 1][j];                              h[n - 1][j] = q*z + p*h[n][j];                              h[n][j] = q*h[n][j] - p*z;                          }                            // Column modification                            for (int i = 0; i <= n; i++)                          {                              z = h[i][n - 1];                              h[i][n - 1] = q*z + p*h[i][n];                              h[i][n] = q*h[i][n] - p*z;                          }                            // Accumulate transformations                            for (int i = low; i <= high; i++)                          {                              z = v[i][n - 1];                              v[i][n - 1] = q*z + p*v[i][n];                              v[i][n] = q*v[i][n] - p*z;                          }                            // Complex pair                      }                      else                      {                          d[n - 1] = x + p;                          d[n] = x + p;                          e[n - 1] = z;                          e[n] = -z;                      }                      n = n - 2;                      iter = 0;                        // No convergence yet                  }                  else                  {                      // Form shift                        x = h[n][n];                      y = 0.0;                      w = 0.0;                      if (l < n)                      {                          y = h[n - 1][n - 1];                          w = h[n][n - 1]*h[n - 1][n];                      }                        // Wilkinson's original ad hoc shift                        if (iter == 10)                      {                          exshift += x;                          for (int i = low; i <= n; i++)                          {                              h[i][i] -= x;                          }                          s = Math.Abs(h[n][n - 1]) + Math.Abs(h[n - 1][n - 2]);                          x = y = 0.75*s;                          w = -0.4375*s*s;                      }                        // MATLAB's new ad hoc shift                        if (iter == 30)                      {                          s = (y - x)/2.0;                          s = s*s + w;                          if (s > 0)                          {                              s = Math.Sqrt(s);                              if (y < x)                              {                                  s = -s;                              }                              s = x - w/((y - x)/2.0 + s);                              for (int i = low; i <= n; i++)                              {                                  h[i][i] -= s;                              }                              exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1; // (Could check iteration count here.)                        // Look for two consecutive small sub-diagonal elements                        int m = n - 2;                      while (m >= l)                      {                          z = h[m][m];                          r = x - z;                          s = y - z;                          p = (r*s - w)/h[m + 1][m] + h[m][m + 1];                          q = h[m + 1][m + 1] - z - r - s;                          r = h[m + 2][m + 1];                          s = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                          p = p/s;                          q = q/s;                          r = r/s;                          if (m == l)                          {                              break;                          }                          if (Math.Abs(h[m][m - 1])*(Math.Abs(q) + Math.Abs(r)) < eps                              *(Math.Abs(p)*(Math.Abs(h[m - 1][m - 1])                                             + Math.Abs(z) + Math.Abs(h[m + 1][m + 1]))))                          {                              break;                          }                          m--;                      }                        for (int i = m + 2; i <= n; i++)                      {                          h[i][i - 2] = 0.0;                          if (i > m + 2)                          {                              h[i][i - 3] = 0.0;                          }                      }                        // Double QR step involving rows l:n and columns m:n                        for (int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                          if (k != m)                          {                              p = h[k][k - 1];                              q = h[k + 1][k - 1];                              r = (notlast ? h[k + 2][k - 1] : 0.0);                              x = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                              if (x != 0.0)                              {                                  p = p/x;                                  q = q/x;                                  r = r/x;                              }                          }                          if (x == 0.0)                          {                              break;                          }                          s = Math.Sqrt(p*p + q*q + r*r);                          if (p < 0)                          {                              s = -s;                          }                          if (s != 0)                          {                              if (k != m)                              {                                  h[k][k - 1] = -s*x;                              }                              else if (l != m)                              {                                  h[k][k - 1] = -h[k][k - 1];                              }                              p = p + s;                              x = p/s;                              y = q/s;                              z = r/s;                              q = q/p;                              r = r/p;                                // Row modification                                for (int j = k; j < nn; j++)                              {                                  p = h[k][j] + q*h[k + 1][j];                                  if (notlast)                                  {                                      p = p + r*h[k + 2][j];                                      h[k + 2][j] = h[k + 2][j] - p*z;                                  }                                  h[k][j] = h[k][j] - p*x;                                  h[k + 1][j] = h[k + 1][j] - p*y;                              }                                // Column modification                                for (int i = 0; i <= Math.Min(n' k + 3); i++)                              {                                  p = x*h[i][k] + y*h[i][k + 1];                                  if (notlast)                                  {                                      p = p + z*h[i][k + 2];                                      h[i][k + 2] = h[i][k + 2] - p*r;                                  }                                  h[i][k] = h[i][k] - p;                                  h[i][k + 1] = h[i][k + 1] - p*q;                              }                                // Accumulate transformations                                for (int i = low; i <= high; i++)                              {                                  p = x*v[i][k] + y*v[i][k + 1];                                  if (notlast)                                  {                                      p = p + z*v[i][k + 2];                                      v[i][k + 2] = v[i][k + 2] - p*r;                                  }                                  v[i][k] = v[i][k] - p;                                  v[i][k + 1] = v[i][k + 1] - p*q;                              }                          } // (s != 0)                      } // k loop                  } // check convergence              }
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: while (n >= low)              {                  // Look for single small sub-diagonal element                    int l = n;                  while (l > low)                  {                      s = Math.Abs(h[l - 1][l - 1]) + Math.Abs(h[l][l]);                      if (s == 0.0)                      {                          s = norm;                      }                      if (Math.Abs(h[l][l - 1]) < eps*s)                      {                          break;                      }                      l--;                  }                    // Check for convergence                  // One root found                    if (l == n)                  {                      h[n][n] = h[n][n] + exshift;                      d[n] = h[n][n];                      e[n] = 0.0;                      n--;                      iter = 0;                        // Two roots found                  }                  else if (l == n - 1)                  {                      w = h[n][n - 1]*h[n - 1][n];                      p = (h[n - 1][n - 1] - h[n][n])/2.0;                      q = p*p + w;                      z = Math.Sqrt(Math.Abs(q));                      h[n][n] = h[n][n] + exshift;                      h[n - 1][n - 1] = h[n - 1][n - 1] + exshift;                      x = h[n][n];                        // Real pair                        if (q >= 0)                      {                          if (p >= 0)                          {                              z = p + z;                          }                          else                          {                              z = p - z;                          }                          d[n - 1] = x + z;                          d[n] = d[n - 1];                          if (z != 0.0)                          {                              d[n] = x - w/z;                          }                          e[n - 1] = 0.0;                          e[n] = 0.0;                          x = h[n][n - 1];                          s = Math.Abs(x) + Math.Abs(z);                          p = x/s;                          q = z/s;                          r = Math.Sqrt(p*p + q*q);                          p = p/r;                          q = q/r;                            // Row modification                            for (int j = n - 1; j < nn; j++)                          {                              z = h[n - 1][j];                              h[n - 1][j] = q*z + p*h[n][j];                              h[n][j] = q*h[n][j] - p*z;                          }                            // Column modification                            for (int i = 0; i <= n; i++)                          {                              z = h[i][n - 1];                              h[i][n - 1] = q*z + p*h[i][n];                              h[i][n] = q*h[i][n] - p*z;                          }                            // Accumulate transformations                            for (int i = low; i <= high; i++)                          {                              z = v[i][n - 1];                              v[i][n - 1] = q*z + p*v[i][n];                              v[i][n] = q*v[i][n] - p*z;                          }                            // Complex pair                      }                      else                      {                          d[n - 1] = x + p;                          d[n] = x + p;                          e[n - 1] = z;                          e[n] = -z;                      }                      n = n - 2;                      iter = 0;                        // No convergence yet                  }                  else                  {                      // Form shift                        x = h[n][n];                      y = 0.0;                      w = 0.0;                      if (l < n)                      {                          y = h[n - 1][n - 1];                          w = h[n][n - 1]*h[n - 1][n];                      }                        // Wilkinson's original ad hoc shift                        if (iter == 10)                      {                          exshift += x;                          for (int i = low; i <= n; i++)                          {                              h[i][i] -= x;                          }                          s = Math.Abs(h[n][n - 1]) + Math.Abs(h[n - 1][n - 2]);                          x = y = 0.75*s;                          w = -0.4375*s*s;                      }                        // MATLAB's new ad hoc shift                        if (iter == 30)                      {                          s = (y - x)/2.0;                          s = s*s + w;                          if (s > 0)                          {                              s = Math.Sqrt(s);                              if (y < x)                              {                                  s = -s;                              }                              s = x - w/((y - x)/2.0 + s);                              for (int i = low; i <= n; i++)                              {                                  h[i][i] -= s;                              }                              exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1; // (Could check iteration count here.)                        // Look for two consecutive small sub-diagonal elements                        int m = n - 2;                      while (m >= l)                      {                          z = h[m][m];                          r = x - z;                          s = y - z;                          p = (r*s - w)/h[m + 1][m] + h[m][m + 1];                          q = h[m + 1][m + 1] - z - r - s;                          r = h[m + 2][m + 1];                          s = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                          p = p/s;                          q = q/s;                          r = r/s;                          if (m == l)                          {                              break;                          }                          if (Math.Abs(h[m][m - 1])*(Math.Abs(q) + Math.Abs(r)) < eps                              *(Math.Abs(p)*(Math.Abs(h[m - 1][m - 1])                                             + Math.Abs(z) + Math.Abs(h[m + 1][m + 1]))))                          {                              break;                          }                          m--;                      }                        for (int i = m + 2; i <= n; i++)                      {                          h[i][i - 2] = 0.0;                          if (i > m + 2)                          {                              h[i][i - 3] = 0.0;                          }                      }                        // Double QR step involving rows l:n and columns m:n                        for (int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                          if (k != m)                          {                              p = h[k][k - 1];                              q = h[k + 1][k - 1];                              r = (notlast ? h[k + 2][k - 1] : 0.0);                              x = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                              if (x != 0.0)                              {                                  p = p/x;                                  q = q/x;                                  r = r/x;                              }                          }                          if (x == 0.0)                          {                              break;                          }                          s = Math.Sqrt(p*p + q*q + r*r);                          if (p < 0)                          {                              s = -s;                          }                          if (s != 0)                          {                              if (k != m)                              {                                  h[k][k - 1] = -s*x;                              }                              else if (l != m)                              {                                  h[k][k - 1] = -h[k][k - 1];                              }                              p = p + s;                              x = p/s;                              y = q/s;                              z = r/s;                              q = q/p;                              r = r/p;                                // Row modification                                for (int j = k; j < nn; j++)                              {                                  p = h[k][j] + q*h[k + 1][j];                                  if (notlast)                                  {                                      p = p + r*h[k + 2][j];                                      h[k + 2][j] = h[k + 2][j] - p*z;                                  }                                  h[k][j] = h[k][j] - p*x;                                  h[k + 1][j] = h[k + 1][j] - p*y;                              }                                // Column modification                                for (int i = 0; i <= Math.Min(n' k + 3); i++)                              {                                  p = x*h[i][k] + y*h[i][k + 1];                                  if (notlast)                                  {                                      p = p + z*h[i][k + 2];                                      h[i][k + 2] = h[i][k + 2] - p*r;                                  }                                  h[i][k] = h[i][k] - p;                                  h[i][k + 1] = h[i][k + 1] - p*q;                              }                                // Accumulate transformations                                for (int i = low; i <= high; i++)                              {                                  p = x*v[i][k] + y*v[i][k + 1];                                  if (notlast)                                  {                                      p = p + z*v[i][k + 2];                                      v[i][k + 2] = v[i][k + 2] - p*r;                                  }                                  v[i][k] = v[i][k] - p;                                  v[i][k + 1] = v[i][k + 1] - p*q;                              }                          } // (s != 0)                      } // k loop                  } // check convergence              }
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: while (n >= low)              {                  // Look for single small sub-diagonal element                    int l = n;                  while (l > low)                  {                      s = Math.Abs(h[l - 1][l - 1]) + Math.Abs(h[l][l]);                      if (s == 0.0)                      {                          s = norm;                      }                      if (Math.Abs(h[l][l - 1]) < eps*s)                      {                          break;                      }                      l--;                  }                    // Check for convergence                  // One root found                    if (l == n)                  {                      h[n][n] = h[n][n] + exshift;                      d[n] = h[n][n];                      e[n] = 0.0;                      n--;                      iter = 0;                        // Two roots found                  }                  else if (l == n - 1)                  {                      w = h[n][n - 1]*h[n - 1][n];                      p = (h[n - 1][n - 1] - h[n][n])/2.0;                      q = p*p + w;                      z = Math.Sqrt(Math.Abs(q));                      h[n][n] = h[n][n] + exshift;                      h[n - 1][n - 1] = h[n - 1][n - 1] + exshift;                      x = h[n][n];                        // Real pair                        if (q >= 0)                      {                          if (p >= 0)                          {                              z = p + z;                          }                          else                          {                              z = p - z;                          }                          d[n - 1] = x + z;                          d[n] = d[n - 1];                          if (z != 0.0)                          {                              d[n] = x - w/z;                          }                          e[n - 1] = 0.0;                          e[n] = 0.0;                          x = h[n][n - 1];                          s = Math.Abs(x) + Math.Abs(z);                          p = x/s;                          q = z/s;                          r = Math.Sqrt(p*p + q*q);                          p = p/r;                          q = q/r;                            // Row modification                            for (int j = n - 1; j < nn; j++)                          {                              z = h[n - 1][j];                              h[n - 1][j] = q*z + p*h[n][j];                              h[n][j] = q*h[n][j] - p*z;                          }                            // Column modification                            for (int i = 0; i <= n; i++)                          {                              z = h[i][n - 1];                              h[i][n - 1] = q*z + p*h[i][n];                              h[i][n] = q*h[i][n] - p*z;                          }                            // Accumulate transformations                            for (int i = low; i <= high; i++)                          {                              z = v[i][n - 1];                              v[i][n - 1] = q*z + p*v[i][n];                              v[i][n] = q*v[i][n] - p*z;                          }                            // Complex pair                      }                      else                      {                          d[n - 1] = x + p;                          d[n] = x + p;                          e[n - 1] = z;                          e[n] = -z;                      }                      n = n - 2;                      iter = 0;                        // No convergence yet                  }                  else                  {                      // Form shift                        x = h[n][n];                      y = 0.0;                      w = 0.0;                      if (l < n)                      {                          y = h[n - 1][n - 1];                          w = h[n][n - 1]*h[n - 1][n];                      }                        // Wilkinson's original ad hoc shift                        if (iter == 10)                      {                          exshift += x;                          for (int i = low; i <= n; i++)                          {                              h[i][i] -= x;                          }                          s = Math.Abs(h[n][n - 1]) + Math.Abs(h[n - 1][n - 2]);                          x = y = 0.75*s;                          w = -0.4375*s*s;                      }                        // MATLAB's new ad hoc shift                        if (iter == 30)                      {                          s = (y - x)/2.0;                          s = s*s + w;                          if (s > 0)                          {                              s = Math.Sqrt(s);                              if (y < x)                              {                                  s = -s;                              }                              s = x - w/((y - x)/2.0 + s);                              for (int i = low; i <= n; i++)                              {                                  h[i][i] -= s;                              }                              exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1; // (Could check iteration count here.)                        // Look for two consecutive small sub-diagonal elements                        int m = n - 2;                      while (m >= l)                      {                          z = h[m][m];                          r = x - z;                          s = y - z;                          p = (r*s - w)/h[m + 1][m] + h[m][m + 1];                          q = h[m + 1][m + 1] - z - r - s;                          r = h[m + 2][m + 1];                          s = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                          p = p/s;                          q = q/s;                          r = r/s;                          if (m == l)                          {                              break;                          }                          if (Math.Abs(h[m][m - 1])*(Math.Abs(q) + Math.Abs(r)) < eps                              *(Math.Abs(p)*(Math.Abs(h[m - 1][m - 1])                                             + Math.Abs(z) + Math.Abs(h[m + 1][m + 1]))))                          {                              break;                          }                          m--;                      }                        for (int i = m + 2; i <= n; i++)                      {                          h[i][i - 2] = 0.0;                          if (i > m + 2)                          {                              h[i][i - 3] = 0.0;                          }                      }                        // Double QR step involving rows l:n and columns m:n                        for (int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                          if (k != m)                          {                              p = h[k][k - 1];                              q = h[k + 1][k - 1];                              r = (notlast ? h[k + 2][k - 1] : 0.0);                              x = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                              if (x != 0.0)                              {                                  p = p/x;                                  q = q/x;                                  r = r/x;                              }                          }                          if (x == 0.0)                          {                              break;                          }                          s = Math.Sqrt(p*p + q*q + r*r);                          if (p < 0)                          {                              s = -s;                          }                          if (s != 0)                          {                              if (k != m)                              {                                  h[k][k - 1] = -s*x;                              }                              else if (l != m)                              {                                  h[k][k - 1] = -h[k][k - 1];                              }                              p = p + s;                              x = p/s;                              y = q/s;                              z = r/s;                              q = q/p;                              r = r/p;                                // Row modification                                for (int j = k; j < nn; j++)                              {                                  p = h[k][j] + q*h[k + 1][j];                                  if (notlast)                                  {                                      p = p + r*h[k + 2][j];                                      h[k + 2][j] = h[k + 2][j] - p*z;                                  }                                  h[k][j] = h[k][j] - p*x;                                  h[k + 1][j] = h[k + 1][j] - p*y;                              }                                // Column modification                                for (int i = 0; i <= Math.Min(n' k + 3); i++)                              {                                  p = x*h[i][k] + y*h[i][k + 1];                                  if (notlast)                                  {                                      p = p + z*h[i][k + 2];                                      h[i][k + 2] = h[i][k + 2] - p*r;                                  }                                  h[i][k] = h[i][k] - p;                                  h[i][k + 1] = h[i][k + 1] - p*q;                              }                                // Accumulate transformations                                for (int i = low; i <= high; i++)                              {                                  p = x*v[i][k] + y*v[i][k + 1];                                  if (notlast)                                  {                                      p = p + z*v[i][k + 2];                                      v[i][k + 2] = v[i][k + 2] - p*r;                                  }                                  v[i][k] = v[i][k] - p;                                  v[i][k + 1] = v[i][k + 1] - p*q;                              }                          } // (s != 0)                      } // k loop                  } // check convergence              }
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: while (n >= low)              {                  // Look for single small sub-diagonal element                    int l = n;                  while (l > low)                  {                      s = Math.Abs(h[l - 1][l - 1]) + Math.Abs(h[l][l]);                      if (s == 0.0)                      {                          s = norm;                      }                      if (Math.Abs(h[l][l - 1]) < eps*s)                      {                          break;                      }                      l--;                  }                    // Check for convergence                  // One root found                    if (l == n)                  {                      h[n][n] = h[n][n] + exshift;                      d[n] = h[n][n];                      e[n] = 0.0;                      n--;                      iter = 0;                        // Two roots found                  }                  else if (l == n - 1)                  {                      w = h[n][n - 1]*h[n - 1][n];                      p = (h[n - 1][n - 1] - h[n][n])/2.0;                      q = p*p + w;                      z = Math.Sqrt(Math.Abs(q));                      h[n][n] = h[n][n] + exshift;                      h[n - 1][n - 1] = h[n - 1][n - 1] + exshift;                      x = h[n][n];                        // Real pair                        if (q >= 0)                      {                          if (p >= 0)                          {                              z = p + z;                          }                          else                          {                              z = p - z;                          }                          d[n - 1] = x + z;                          d[n] = d[n - 1];                          if (z != 0.0)                          {                              d[n] = x - w/z;                          }                          e[n - 1] = 0.0;                          e[n] = 0.0;                          x = h[n][n - 1];                          s = Math.Abs(x) + Math.Abs(z);                          p = x/s;                          q = z/s;                          r = Math.Sqrt(p*p + q*q);                          p = p/r;                          q = q/r;                            // Row modification                            for (int j = n - 1; j < nn; j++)                          {                              z = h[n - 1][j];                              h[n - 1][j] = q*z + p*h[n][j];                              h[n][j] = q*h[n][j] - p*z;                          }                            // Column modification                            for (int i = 0; i <= n; i++)                          {                              z = h[i][n - 1];                              h[i][n - 1] = q*z + p*h[i][n];                              h[i][n] = q*h[i][n] - p*z;                          }                            // Accumulate transformations                            for (int i = low; i <= high; i++)                          {                              z = v[i][n - 1];                              v[i][n - 1] = q*z + p*v[i][n];                              v[i][n] = q*v[i][n] - p*z;                          }                            // Complex pair                      }                      else                      {                          d[n - 1] = x + p;                          d[n] = x + p;                          e[n - 1] = z;                          e[n] = -z;                      }                      n = n - 2;                      iter = 0;                        // No convergence yet                  }                  else                  {                      // Form shift                        x = h[n][n];                      y = 0.0;                      w = 0.0;                      if (l < n)                      {                          y = h[n - 1][n - 1];                          w = h[n][n - 1]*h[n - 1][n];                      }                        // Wilkinson's original ad hoc shift                        if (iter == 10)                      {                          exshift += x;                          for (int i = low; i <= n; i++)                          {                              h[i][i] -= x;                          }                          s = Math.Abs(h[n][n - 1]) + Math.Abs(h[n - 1][n - 2]);                          x = y = 0.75*s;                          w = -0.4375*s*s;                      }                        // MATLAB's new ad hoc shift                        if (iter == 30)                      {                          s = (y - x)/2.0;                          s = s*s + w;                          if (s > 0)                          {                              s = Math.Sqrt(s);                              if (y < x)                              {                                  s = -s;                              }                              s = x - w/((y - x)/2.0 + s);                              for (int i = low; i <= n; i++)                              {                                  h[i][i] -= s;                              }                              exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1; // (Could check iteration count here.)                        // Look for two consecutive small sub-diagonal elements                        int m = n - 2;                      while (m >= l)                      {                          z = h[m][m];                          r = x - z;                          s = y - z;                          p = (r*s - w)/h[m + 1][m] + h[m][m + 1];                          q = h[m + 1][m + 1] - z - r - s;                          r = h[m + 2][m + 1];                          s = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                          p = p/s;                          q = q/s;                          r = r/s;                          if (m == l)                          {                              break;                          }                          if (Math.Abs(h[m][m - 1])*(Math.Abs(q) + Math.Abs(r)) < eps                              *(Math.Abs(p)*(Math.Abs(h[m - 1][m - 1])                                             + Math.Abs(z) + Math.Abs(h[m + 1][m + 1]))))                          {                              break;                          }                          m--;                      }                        for (int i = m + 2; i <= n; i++)                      {                          h[i][i - 2] = 0.0;                          if (i > m + 2)                          {                              h[i][i - 3] = 0.0;                          }                      }                        // Double QR step involving rows l:n and columns m:n                        for (int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                          if (k != m)                          {                              p = h[k][k - 1];                              q = h[k + 1][k - 1];                              r = (notlast ? h[k + 2][k - 1] : 0.0);                              x = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                              if (x != 0.0)                              {                                  p = p/x;                                  q = q/x;                                  r = r/x;                              }                          }                          if (x == 0.0)                          {                              break;                          }                          s = Math.Sqrt(p*p + q*q + r*r);                          if (p < 0)                          {                              s = -s;                          }                          if (s != 0)                          {                              if (k != m)                              {                                  h[k][k - 1] = -s*x;                              }                              else if (l != m)                              {                                  h[k][k - 1] = -h[k][k - 1];                              }                              p = p + s;                              x = p/s;                              y = q/s;                              z = r/s;                              q = q/p;                              r = r/p;                                // Row modification                                for (int j = k; j < nn; j++)                              {                                  p = h[k][j] + q*h[k + 1][j];                                  if (notlast)                                  {                                      p = p + r*h[k + 2][j];                                      h[k + 2][j] = h[k + 2][j] - p*z;                                  }                                  h[k][j] = h[k][j] - p*x;                                  h[k + 1][j] = h[k + 1][j] - p*y;                              }                                // Column modification                                for (int i = 0; i <= Math.Min(n' k + 3); i++)                              {                                  p = x*h[i][k] + y*h[i][k + 1];                                  if (notlast)                                  {                                      p = p + z*h[i][k + 2];                                      h[i][k + 2] = h[i][k + 2] - p*r;                                  }                                  h[i][k] = h[i][k] - p;                                  h[i][k + 1] = h[i][k + 1] - p*q;                              }                                // Accumulate transformations                                for (int i = low; i <= high; i++)                              {                                  p = x*v[i][k] + y*v[i][k + 1];                                  if (notlast)                                  {                                      p = p + z*v[i][k + 2];                                      v[i][k + 2] = v[i][k + 2] - p*r;                                  }                                  v[i][k] = v[i][k] - p;                                  v[i][k + 1] = v[i][k + 1] - p*q;                              }                          } // (s != 0)                      } // k loop                  } // check convergence              }
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: while (n >= low)              {                  // Look for single small sub-diagonal element                    int l = n;                  while (l > low)                  {                      s = Math.Abs(h[l - 1][l - 1]) + Math.Abs(h[l][l]);                      if (s == 0.0)                      {                          s = norm;                      }                      if (Math.Abs(h[l][l - 1]) < eps*s)                      {                          break;                      }                      l--;                  }                    // Check for convergence                  // One root found                    if (l == n)                  {                      h[n][n] = h[n][n] + exshift;                      d[n] = h[n][n];                      e[n] = 0.0;                      n--;                      iter = 0;                        // Two roots found                  }                  else if (l == n - 1)                  {                      w = h[n][n - 1]*h[n - 1][n];                      p = (h[n - 1][n - 1] - h[n][n])/2.0;                      q = p*p + w;                      z = Math.Sqrt(Math.Abs(q));                      h[n][n] = h[n][n] + exshift;                      h[n - 1][n - 1] = h[n - 1][n - 1] + exshift;                      x = h[n][n];                        // Real pair                        if (q >= 0)                      {                          if (p >= 0)                          {                              z = p + z;                          }                          else                          {                              z = p - z;                          }                          d[n - 1] = x + z;                          d[n] = d[n - 1];                          if (z != 0.0)                          {                              d[n] = x - w/z;                          }                          e[n - 1] = 0.0;                          e[n] = 0.0;                          x = h[n][n - 1];                          s = Math.Abs(x) + Math.Abs(z);                          p = x/s;                          q = z/s;                          r = Math.Sqrt(p*p + q*q);                          p = p/r;                          q = q/r;                            // Row modification                            for (int j = n - 1; j < nn; j++)                          {                              z = h[n - 1][j];                              h[n - 1][j] = q*z + p*h[n][j];                              h[n][j] = q*h[n][j] - p*z;                          }                            // Column modification                            for (int i = 0; i <= n; i++)                          {                              z = h[i][n - 1];                              h[i][n - 1] = q*z + p*h[i][n];                              h[i][n] = q*h[i][n] - p*z;                          }                            // Accumulate transformations                            for (int i = low; i <= high; i++)                          {                              z = v[i][n - 1];                              v[i][n - 1] = q*z + p*v[i][n];                              v[i][n] = q*v[i][n] - p*z;                          }                            // Complex pair                      }                      else                      {                          d[n - 1] = x + p;                          d[n] = x + p;                          e[n - 1] = z;                          e[n] = -z;                      }                      n = n - 2;                      iter = 0;                        // No convergence yet                  }                  else                  {                      // Form shift                        x = h[n][n];                      y = 0.0;                      w = 0.0;                      if (l < n)                      {                          y = h[n - 1][n - 1];                          w = h[n][n - 1]*h[n - 1][n];                      }                        // Wilkinson's original ad hoc shift                        if (iter == 10)                      {                          exshift += x;                          for (int i = low; i <= n; i++)                          {                              h[i][i] -= x;                          }                          s = Math.Abs(h[n][n - 1]) + Math.Abs(h[n - 1][n - 2]);                          x = y = 0.75*s;                          w = -0.4375*s*s;                      }                        // MATLAB's new ad hoc shift                        if (iter == 30)                      {                          s = (y - x)/2.0;                          s = s*s + w;                          if (s > 0)                          {                              s = Math.Sqrt(s);                              if (y < x)                              {                                  s = -s;                              }                              s = x - w/((y - x)/2.0 + s);                              for (int i = low; i <= n; i++)                              {                                  h[i][i] -= s;                              }                              exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1; // (Could check iteration count here.)                        // Look for two consecutive small sub-diagonal elements                        int m = n - 2;                      while (m >= l)                      {                          z = h[m][m];                          r = x - z;                          s = y - z;                          p = (r*s - w)/h[m + 1][m] + h[m][m + 1];                          q = h[m + 1][m + 1] - z - r - s;                          r = h[m + 2][m + 1];                          s = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                          p = p/s;                          q = q/s;                          r = r/s;                          if (m == l)                          {                              break;                          }                          if (Math.Abs(h[m][m - 1])*(Math.Abs(q) + Math.Abs(r)) < eps                              *(Math.Abs(p)*(Math.Abs(h[m - 1][m - 1])                                             + Math.Abs(z) + Math.Abs(h[m + 1][m + 1]))))                          {                              break;                          }                          m--;                      }                        for (int i = m + 2; i <= n; i++)                      {                          h[i][i - 2] = 0.0;                          if (i > m + 2)                          {                              h[i][i - 3] = 0.0;                          }                      }                        // Double QR step involving rows l:n and columns m:n                        for (int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                          if (k != m)                          {                              p = h[k][k - 1];                              q = h[k + 1][k - 1];                              r = (notlast ? h[k + 2][k - 1] : 0.0);                              x = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                              if (x != 0.0)                              {                                  p = p/x;                                  q = q/x;                                  r = r/x;                              }                          }                          if (x == 0.0)                          {                              break;                          }                          s = Math.Sqrt(p*p + q*q + r*r);                          if (p < 0)                          {                              s = -s;                          }                          if (s != 0)                          {                              if (k != m)                              {                                  h[k][k - 1] = -s*x;                              }                              else if (l != m)                              {                                  h[k][k - 1] = -h[k][k - 1];                              }                              p = p + s;                              x = p/s;                              y = q/s;                              z = r/s;                              q = q/p;                              r = r/p;                                // Row modification                                for (int j = k; j < nn; j++)                              {                                  p = h[k][j] + q*h[k + 1][j];                                  if (notlast)                                  {                                      p = p + r*h[k + 2][j];                                      h[k + 2][j] = h[k + 2][j] - p*z;                                  }                                  h[k][j] = h[k][j] - p*x;                                  h[k + 1][j] = h[k + 1][j] - p*y;                              }                                // Column modification                                for (int i = 0; i <= Math.Min(n' k + 3); i++)                              {                                  p = x*h[i][k] + y*h[i][k + 1];                                  if (notlast)                                  {                                      p = p + z*h[i][k + 2];                                      h[i][k + 2] = h[i][k + 2] - p*r;                                  }                                  h[i][k] = h[i][k] - p;                                  h[i][k + 1] = h[i][k + 1] - p*q;                              }                                // Accumulate transformations                                for (int i = low; i <= high; i++)                              {                                  p = x*v[i][k] + y*v[i][k + 1];                                  if (notlast)                                  {                                      p = p + z*v[i][k + 2];                                      v[i][k + 2] = v[i][k + 2] - p*r;                                  }                                  v[i][k] = v[i][k] - p;                                  v[i][k + 1] = v[i][k + 1] - p*q;                              }                          } // (s != 0)                      } // k loop                  } // check convergence              }
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: while (n >= low)              {                  // Look for single small sub-diagonal element                    int l = n;                  while (l > low)                  {                      s = Math.Abs(h[l - 1][l - 1]) + Math.Abs(h[l][l]);                      if (s == 0.0)                      {                          s = norm;                      }                      if (Math.Abs(h[l][l - 1]) < eps*s)                      {                          break;                      }                      l--;                  }                    // Check for convergence                  // One root found                    if (l == n)                  {                      h[n][n] = h[n][n] + exshift;                      d[n] = h[n][n];                      e[n] = 0.0;                      n--;                      iter = 0;                        // Two roots found                  }                  else if (l == n - 1)                  {                      w = h[n][n - 1]*h[n - 1][n];                      p = (h[n - 1][n - 1] - h[n][n])/2.0;                      q = p*p + w;                      z = Math.Sqrt(Math.Abs(q));                      h[n][n] = h[n][n] + exshift;                      h[n - 1][n - 1] = h[n - 1][n - 1] + exshift;                      x = h[n][n];                        // Real pair                        if (q >= 0)                      {                          if (p >= 0)                          {                              z = p + z;                          }                          else                          {                              z = p - z;                          }                          d[n - 1] = x + z;                          d[n] = d[n - 1];                          if (z != 0.0)                          {                              d[n] = x - w/z;                          }                          e[n - 1] = 0.0;                          e[n] = 0.0;                          x = h[n][n - 1];                          s = Math.Abs(x) + Math.Abs(z);                          p = x/s;                          q = z/s;                          r = Math.Sqrt(p*p + q*q);                          p = p/r;                          q = q/r;                            // Row modification                            for (int j = n - 1; j < nn; j++)                          {                              z = h[n - 1][j];                              h[n - 1][j] = q*z + p*h[n][j];                              h[n][j] = q*h[n][j] - p*z;                          }                            // Column modification                            for (int i = 0; i <= n; i++)                          {                              z = h[i][n - 1];                              h[i][n - 1] = q*z + p*h[i][n];                              h[i][n] = q*h[i][n] - p*z;                          }                            // Accumulate transformations                            for (int i = low; i <= high; i++)                          {                              z = v[i][n - 1];                              v[i][n - 1] = q*z + p*v[i][n];                              v[i][n] = q*v[i][n] - p*z;                          }                            // Complex pair                      }                      else                      {                          d[n - 1] = x + p;                          d[n] = x + p;                          e[n - 1] = z;                          e[n] = -z;                      }                      n = n - 2;                      iter = 0;                        // No convergence yet                  }                  else                  {                      // Form shift                        x = h[n][n];                      y = 0.0;                      w = 0.0;                      if (l < n)                      {                          y = h[n - 1][n - 1];                          w = h[n][n - 1]*h[n - 1][n];                      }                        // Wilkinson's original ad hoc shift                        if (iter == 10)                      {                          exshift += x;                          for (int i = low; i <= n; i++)                          {                              h[i][i] -= x;                          }                          s = Math.Abs(h[n][n - 1]) + Math.Abs(h[n - 1][n - 2]);                          x = y = 0.75*s;                          w = -0.4375*s*s;                      }                        // MATLAB's new ad hoc shift                        if (iter == 30)                      {                          s = (y - x)/2.0;                          s = s*s + w;                          if (s > 0)                          {                              s = Math.Sqrt(s);                              if (y < x)                              {                                  s = -s;                              }                              s = x - w/((y - x)/2.0 + s);                              for (int i = low; i <= n; i++)                              {                                  h[i][i] -= s;                              }                              exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1; // (Could check iteration count here.)                        // Look for two consecutive small sub-diagonal elements                        int m = n - 2;                      while (m >= l)                      {                          z = h[m][m];                          r = x - z;                          s = y - z;                          p = (r*s - w)/h[m + 1][m] + h[m][m + 1];                          q = h[m + 1][m + 1] - z - r - s;                          r = h[m + 2][m + 1];                          s = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                          p = p/s;                          q = q/s;                          r = r/s;                          if (m == l)                          {                              break;                          }                          if (Math.Abs(h[m][m - 1])*(Math.Abs(q) + Math.Abs(r)) < eps                              *(Math.Abs(p)*(Math.Abs(h[m - 1][m - 1])                                             + Math.Abs(z) + Math.Abs(h[m + 1][m + 1]))))                          {                              break;                          }                          m--;                      }                        for (int i = m + 2; i <= n; i++)                      {                          h[i][i - 2] = 0.0;                          if (i > m + 2)                          {                              h[i][i - 3] = 0.0;                          }                      }                        // Double QR step involving rows l:n and columns m:n                        for (int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                          if (k != m)                          {                              p = h[k][k - 1];                              q = h[k + 1][k - 1];                              r = (notlast ? h[k + 2][k - 1] : 0.0);                              x = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                              if (x != 0.0)                              {                                  p = p/x;                                  q = q/x;                                  r = r/x;                              }                          }                          if (x == 0.0)                          {                              break;                          }                          s = Math.Sqrt(p*p + q*q + r*r);                          if (p < 0)                          {                              s = -s;                          }                          if (s != 0)                          {                              if (k != m)                              {                                  h[k][k - 1] = -s*x;                              }                              else if (l != m)                              {                                  h[k][k - 1] = -h[k][k - 1];                              }                              p = p + s;                              x = p/s;                              y = q/s;                              z = r/s;                              q = q/p;                              r = r/p;                                // Row modification                                for (int j = k; j < nn; j++)                              {                                  p = h[k][j] + q*h[k + 1][j];                                  if (notlast)                                  {                                      p = p + r*h[k + 2][j];                                      h[k + 2][j] = h[k + 2][j] - p*z;                                  }                                  h[k][j] = h[k][j] - p*x;                                  h[k + 1][j] = h[k + 1][j] - p*y;                              }                                // Column modification                                for (int i = 0; i <= Math.Min(n' k + 3); i++)                              {                                  p = x*h[i][k] + y*h[i][k + 1];                                  if (notlast)                                  {                                      p = p + z*h[i][k + 2];                                      h[i][k + 2] = h[i][k + 2] - p*r;                                  }                                  h[i][k] = h[i][k] - p;                                  h[i][k + 1] = h[i][k + 1] - p*q;                              }                                // Accumulate transformations                                for (int i = low; i <= high; i++)                              {                                  p = x*v[i][k] + y*v[i][k + 1];                                  if (notlast)                                  {                                      p = p + z*v[i][k + 2];                                      v[i][k + 2] = v[i][k + 2] - p*r;                                  }                                  v[i][k] = v[i][k] - p;                                  v[i][k + 1] = v[i][k + 1] - p*q;                              }                          } // (s != 0)                      } // k loop                  } // check convergence              }
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: while (n >= low)              {                  // Look for single small sub-diagonal element                    int l = n;                  while (l > low)                  {                      s = Math.Abs(h[l - 1][l - 1]) + Math.Abs(h[l][l]);                      if (s == 0.0)                      {                          s = norm;                      }                      if (Math.Abs(h[l][l - 1]) < eps*s)                      {                          break;                      }                      l--;                  }                    // Check for convergence                  // One root found                    if (l == n)                  {                      h[n][n] = h[n][n] + exshift;                      d[n] = h[n][n];                      e[n] = 0.0;                      n--;                      iter = 0;                        // Two roots found                  }                  else if (l == n - 1)                  {                      w = h[n][n - 1]*h[n - 1][n];                      p = (h[n - 1][n - 1] - h[n][n])/2.0;                      q = p*p + w;                      z = Math.Sqrt(Math.Abs(q));                      h[n][n] = h[n][n] + exshift;                      h[n - 1][n - 1] = h[n - 1][n - 1] + exshift;                      x = h[n][n];                        // Real pair                        if (q >= 0)                      {                          if (p >= 0)                          {                              z = p + z;                          }                          else                          {                              z = p - z;                          }                          d[n - 1] = x + z;                          d[n] = d[n - 1];                          if (z != 0.0)                          {                              d[n] = x - w/z;                          }                          e[n - 1] = 0.0;                          e[n] = 0.0;                          x = h[n][n - 1];                          s = Math.Abs(x) + Math.Abs(z);                          p = x/s;                          q = z/s;                          r = Math.Sqrt(p*p + q*q);                          p = p/r;                          q = q/r;                            // Row modification                            for (int j = n - 1; j < nn; j++)                          {                              z = h[n - 1][j];                              h[n - 1][j] = q*z + p*h[n][j];                              h[n][j] = q*h[n][j] - p*z;                          }                            // Column modification                            for (int i = 0; i <= n; i++)                          {                              z = h[i][n - 1];                              h[i][n - 1] = q*z + p*h[i][n];                              h[i][n] = q*h[i][n] - p*z;                          }                            // Accumulate transformations                            for (int i = low; i <= high; i++)                          {                              z = v[i][n - 1];                              v[i][n - 1] = q*z + p*v[i][n];                              v[i][n] = q*v[i][n] - p*z;                          }                            // Complex pair                      }                      else                      {                          d[n - 1] = x + p;                          d[n] = x + p;                          e[n - 1] = z;                          e[n] = -z;                      }                      n = n - 2;                      iter = 0;                        // No convergence yet                  }                  else                  {                      // Form shift                        x = h[n][n];                      y = 0.0;                      w = 0.0;                      if (l < n)                      {                          y = h[n - 1][n - 1];                          w = h[n][n - 1]*h[n - 1][n];                      }                        // Wilkinson's original ad hoc shift                        if (iter == 10)                      {                          exshift += x;                          for (int i = low; i <= n; i++)                          {                              h[i][i] -= x;                          }                          s = Math.Abs(h[n][n - 1]) + Math.Abs(h[n - 1][n - 2]);                          x = y = 0.75*s;                          w = -0.4375*s*s;                      }                        // MATLAB's new ad hoc shift                        if (iter == 30)                      {                          s = (y - x)/2.0;                          s = s*s + w;                          if (s > 0)                          {                              s = Math.Sqrt(s);                              if (y < x)                              {                                  s = -s;                              }                              s = x - w/((y - x)/2.0 + s);                              for (int i = low; i <= n; i++)                              {                                  h[i][i] -= s;                              }                              exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1; // (Could check iteration count here.)                        // Look for two consecutive small sub-diagonal elements                        int m = n - 2;                      while (m >= l)                      {                          z = h[m][m];                          r = x - z;                          s = y - z;                          p = (r*s - w)/h[m + 1][m] + h[m][m + 1];                          q = h[m + 1][m + 1] - z - r - s;                          r = h[m + 2][m + 1];                          s = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                          p = p/s;                          q = q/s;                          r = r/s;                          if (m == l)                          {                              break;                          }                          if (Math.Abs(h[m][m - 1])*(Math.Abs(q) + Math.Abs(r)) < eps                              *(Math.Abs(p)*(Math.Abs(h[m - 1][m - 1])                                             + Math.Abs(z) + Math.Abs(h[m + 1][m + 1]))))                          {                              break;                          }                          m--;                      }                        for (int i = m + 2; i <= n; i++)                      {                          h[i][i - 2] = 0.0;                          if (i > m + 2)                          {                              h[i][i - 3] = 0.0;                          }                      }                        // Double QR step involving rows l:n and columns m:n                        for (int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                          if (k != m)                          {                              p = h[k][k - 1];                              q = h[k + 1][k - 1];                              r = (notlast ? h[k + 2][k - 1] : 0.0);                              x = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                              if (x != 0.0)                              {                                  p = p/x;                                  q = q/x;                                  r = r/x;                              }                          }                          if (x == 0.0)                          {                              break;                          }                          s = Math.Sqrt(p*p + q*q + r*r);                          if (p < 0)                          {                              s = -s;                          }                          if (s != 0)                          {                              if (k != m)                              {                                  h[k][k - 1] = -s*x;                              }                              else if (l != m)                              {                                  h[k][k - 1] = -h[k][k - 1];                              }                              p = p + s;                              x = p/s;                              y = q/s;                              z = r/s;                              q = q/p;                              r = r/p;                                // Row modification                                for (int j = k; j < nn; j++)                              {                                  p = h[k][j] + q*h[k + 1][j];                                  if (notlast)                                  {                                      p = p + r*h[k + 2][j];                                      h[k + 2][j] = h[k + 2][j] - p*z;                                  }                                  h[k][j] = h[k][j] - p*x;                                  h[k + 1][j] = h[k + 1][j] - p*y;                              }                                // Column modification                                for (int i = 0; i <= Math.Min(n' k + 3); i++)                              {                                  p = x*h[i][k] + y*h[i][k + 1];                                  if (notlast)                                  {                                      p = p + z*h[i][k + 2];                                      h[i][k + 2] = h[i][k + 2] - p*r;                                  }                                  h[i][k] = h[i][k] - p;                                  h[i][k + 1] = h[i][k + 1] - p*q;                              }                                // Accumulate transformations                                for (int i = low; i <= high; i++)                              {                                  p = x*v[i][k] + y*v[i][k + 1];                                  if (notlast)                                  {                                      p = p + z*v[i][k + 2];                                      v[i][k + 2] = v[i][k + 2] - p*r;                                  }                                  v[i][k] = v[i][k] - p;                                  v[i][k + 1] = v[i][k + 1] - p*q;                              }                          } // (s != 0)                      } // k loop                  } // check convergence              }
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: while (n >= low)              {                  // Look for single small sub-diagonal element                    int l = n;                  while (l > low)                  {                      s = Math.Abs(h[l - 1][l - 1]) + Math.Abs(h[l][l]);                      if (s == 0.0)                      {                          s = norm;                      }                      if (Math.Abs(h[l][l - 1]) < eps*s)                      {                          break;                      }                      l--;                  }                    // Check for convergence                  // One root found                    if (l == n)                  {                      h[n][n] = h[n][n] + exshift;                      d[n] = h[n][n];                      e[n] = 0.0;                      n--;                      iter = 0;                        // Two roots found                  }                  else if (l == n - 1)                  {                      w = h[n][n - 1]*h[n - 1][n];                      p = (h[n - 1][n - 1] - h[n][n])/2.0;                      q = p*p + w;                      z = Math.Sqrt(Math.Abs(q));                      h[n][n] = h[n][n] + exshift;                      h[n - 1][n - 1] = h[n - 1][n - 1] + exshift;                      x = h[n][n];                        // Real pair                        if (q >= 0)                      {                          if (p >= 0)                          {                              z = p + z;                          }                          else                          {                              z = p - z;                          }                          d[n - 1] = x + z;                          d[n] = d[n - 1];                          if (z != 0.0)                          {                              d[n] = x - w/z;                          }                          e[n - 1] = 0.0;                          e[n] = 0.0;                          x = h[n][n - 1];                          s = Math.Abs(x) + Math.Abs(z);                          p = x/s;                          q = z/s;                          r = Math.Sqrt(p*p + q*q);                          p = p/r;                          q = q/r;                            // Row modification                            for (int j = n - 1; j < nn; j++)                          {                              z = h[n - 1][j];                              h[n - 1][j] = q*z + p*h[n][j];                              h[n][j] = q*h[n][j] - p*z;                          }                            // Column modification                            for (int i = 0; i <= n; i++)                          {                              z = h[i][n - 1];                              h[i][n - 1] = q*z + p*h[i][n];                              h[i][n] = q*h[i][n] - p*z;                          }                            // Accumulate transformations                            for (int i = low; i <= high; i++)                          {                              z = v[i][n - 1];                              v[i][n - 1] = q*z + p*v[i][n];                              v[i][n] = q*v[i][n] - p*z;                          }                            // Complex pair                      }                      else                      {                          d[n - 1] = x + p;                          d[n] = x + p;                          e[n - 1] = z;                          e[n] = -z;                      }                      n = n - 2;                      iter = 0;                        // No convergence yet                  }                  else                  {                      // Form shift                        x = h[n][n];                      y = 0.0;                      w = 0.0;                      if (l < n)                      {                          y = h[n - 1][n - 1];                          w = h[n][n - 1]*h[n - 1][n];                      }                        // Wilkinson's original ad hoc shift                        if (iter == 10)                      {                          exshift += x;                          for (int i = low; i <= n; i++)                          {                              h[i][i] -= x;                          }                          s = Math.Abs(h[n][n - 1]) + Math.Abs(h[n - 1][n - 2]);                          x = y = 0.75*s;                          w = -0.4375*s*s;                      }                        // MATLAB's new ad hoc shift                        if (iter == 30)                      {                          s = (y - x)/2.0;                          s = s*s + w;                          if (s > 0)                          {                              s = Math.Sqrt(s);                              if (y < x)                              {                                  s = -s;                              }                              s = x - w/((y - x)/2.0 + s);                              for (int i = low; i <= n; i++)                              {                                  h[i][i] -= s;                              }                              exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1; // (Could check iteration count here.)                        // Look for two consecutive small sub-diagonal elements                        int m = n - 2;                      while (m >= l)                      {                          z = h[m][m];                          r = x - z;                          s = y - z;                          p = (r*s - w)/h[m + 1][m] + h[m][m + 1];                          q = h[m + 1][m + 1] - z - r - s;                          r = h[m + 2][m + 1];                          s = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                          p = p/s;                          q = q/s;                          r = r/s;                          if (m == l)                          {                              break;                          }                          if (Math.Abs(h[m][m - 1])*(Math.Abs(q) + Math.Abs(r)) < eps                              *(Math.Abs(p)*(Math.Abs(h[m - 1][m - 1])                                             + Math.Abs(z) + Math.Abs(h[m + 1][m + 1]))))                          {                              break;                          }                          m--;                      }                        for (int i = m + 2; i <= n; i++)                      {                          h[i][i - 2] = 0.0;                          if (i > m + 2)                          {                              h[i][i - 3] = 0.0;                          }                      }                        // Double QR step involving rows l:n and columns m:n                        for (int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                          if (k != m)                          {                              p = h[k][k - 1];                              q = h[k + 1][k - 1];                              r = (notlast ? h[k + 2][k - 1] : 0.0);                              x = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                              if (x != 0.0)                              {                                  p = p/x;                                  q = q/x;                                  r = r/x;                              }                          }                          if (x == 0.0)                          {                              break;                          }                          s = Math.Sqrt(p*p + q*q + r*r);                          if (p < 0)                          {                              s = -s;                          }                          if (s != 0)                          {                              if (k != m)                              {                                  h[k][k - 1] = -s*x;                              }                              else if (l != m)                              {                                  h[k][k - 1] = -h[k][k - 1];                              }                              p = p + s;                              x = p/s;                              y = q/s;                              z = r/s;                              q = q/p;                              r = r/p;                                // Row modification                                for (int j = k; j < nn; j++)                              {                                  p = h[k][j] + q*h[k + 1][j];                                  if (notlast)                                  {                                      p = p + r*h[k + 2][j];                                      h[k + 2][j] = h[k + 2][j] - p*z;                                  }                                  h[k][j] = h[k][j] - p*x;                                  h[k + 1][j] = h[k + 1][j] - p*y;                              }                                // Column modification                                for (int i = 0; i <= Math.Min(n' k + 3); i++)                              {                                  p = x*h[i][k] + y*h[i][k + 1];                                  if (notlast)                                  {                                      p = p + z*h[i][k + 2];                                      h[i][k + 2] = h[i][k + 2] - p*r;                                  }                                  h[i][k] = h[i][k] - p;                                  h[i][k + 1] = h[i][k + 1] - p*q;                              }                                // Accumulate transformations                                for (int i = low; i <= high; i++)                              {                                  p = x*v[i][k] + y*v[i][k + 1];                                  if (notlast)                                  {                                      p = p + z*v[i][k + 2];                                      v[i][k + 2] = v[i][k + 2] - p*r;                                  }                                  v[i][k] = v[i][k] - p;                                  v[i][k + 1] = v[i][k + 1] - p*q;                              }                          } // (s != 0)                      } // k loop                  } // check convergence              }
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: while (n >= low)              {                  // Look for single small sub-diagonal element                    int l = n;                  while (l > low)                  {                      s = Math.Abs(h[l - 1][l - 1]) + Math.Abs(h[l][l]);                      if (s == 0.0)                      {                          s = norm;                      }                      if (Math.Abs(h[l][l - 1]) < eps*s)                      {                          break;                      }                      l--;                  }                    // Check for convergence                  // One root found                    if (l == n)                  {                      h[n][n] = h[n][n] + exshift;                      d[n] = h[n][n];                      e[n] = 0.0;                      n--;                      iter = 0;                        // Two roots found                  }                  else if (l == n - 1)                  {                      w = h[n][n - 1]*h[n - 1][n];                      p = (h[n - 1][n - 1] - h[n][n])/2.0;                      q = p*p + w;                      z = Math.Sqrt(Math.Abs(q));                      h[n][n] = h[n][n] + exshift;                      h[n - 1][n - 1] = h[n - 1][n - 1] + exshift;                      x = h[n][n];                        // Real pair                        if (q >= 0)                      {                          if (p >= 0)                          {                              z = p + z;                          }                          else                          {                              z = p - z;                          }                          d[n - 1] = x + z;                          d[n] = d[n - 1];                          if (z != 0.0)                          {                              d[n] = x - w/z;                          }                          e[n - 1] = 0.0;                          e[n] = 0.0;                          x = h[n][n - 1];                          s = Math.Abs(x) + Math.Abs(z);                          p = x/s;                          q = z/s;                          r = Math.Sqrt(p*p + q*q);                          p = p/r;                          q = q/r;                            // Row modification                            for (int j = n - 1; j < nn; j++)                          {                              z = h[n - 1][j];                              h[n - 1][j] = q*z + p*h[n][j];                              h[n][j] = q*h[n][j] - p*z;                          }                            // Column modification                            for (int i = 0; i <= n; i++)                          {                              z = h[i][n - 1];                              h[i][n - 1] = q*z + p*h[i][n];                              h[i][n] = q*h[i][n] - p*z;                          }                            // Accumulate transformations                            for (int i = low; i <= high; i++)                          {                              z = v[i][n - 1];                              v[i][n - 1] = q*z + p*v[i][n];                              v[i][n] = q*v[i][n] - p*z;                          }                            // Complex pair                      }                      else                      {                          d[n - 1] = x + p;                          d[n] = x + p;                          e[n - 1] = z;                          e[n] = -z;                      }                      n = n - 2;                      iter = 0;                        // No convergence yet                  }                  else                  {                      // Form shift                        x = h[n][n];                      y = 0.0;                      w = 0.0;                      if (l < n)                      {                          y = h[n - 1][n - 1];                          w = h[n][n - 1]*h[n - 1][n];                      }                        // Wilkinson's original ad hoc shift                        if (iter == 10)                      {                          exshift += x;                          for (int i = low; i <= n; i++)                          {                              h[i][i] -= x;                          }                          s = Math.Abs(h[n][n - 1]) + Math.Abs(h[n - 1][n - 2]);                          x = y = 0.75*s;                          w = -0.4375*s*s;                      }                        // MATLAB's new ad hoc shift                        if (iter == 30)                      {                          s = (y - x)/2.0;                          s = s*s + w;                          if (s > 0)                          {                              s = Math.Sqrt(s);                              if (y < x)                              {                                  s = -s;                              }                              s = x - w/((y - x)/2.0 + s);                              for (int i = low; i <= n; i++)                              {                                  h[i][i] -= s;                              }                              exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1; // (Could check iteration count here.)                        // Look for two consecutive small sub-diagonal elements                        int m = n - 2;                      while (m >= l)                      {                          z = h[m][m];                          r = x - z;                          s = y - z;                          p = (r*s - w)/h[m + 1][m] + h[m][m + 1];                          q = h[m + 1][m + 1] - z - r - s;                          r = h[m + 2][m + 1];                          s = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                          p = p/s;                          q = q/s;                          r = r/s;                          if (m == l)                          {                              break;                          }                          if (Math.Abs(h[m][m - 1])*(Math.Abs(q) + Math.Abs(r)) < eps                              *(Math.Abs(p)*(Math.Abs(h[m - 1][m - 1])                                             + Math.Abs(z) + Math.Abs(h[m + 1][m + 1]))))                          {                              break;                          }                          m--;                      }                        for (int i = m + 2; i <= n; i++)                      {                          h[i][i - 2] = 0.0;                          if (i > m + 2)                          {                              h[i][i - 3] = 0.0;                          }                      }                        // Double QR step involving rows l:n and columns m:n                        for (int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                          if (k != m)                          {                              p = h[k][k - 1];                              q = h[k + 1][k - 1];                              r = (notlast ? h[k + 2][k - 1] : 0.0);                              x = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                              if (x != 0.0)                              {                                  p = p/x;                                  q = q/x;                                  r = r/x;                              }                          }                          if (x == 0.0)                          {                              break;                          }                          s = Math.Sqrt(p*p + q*q + r*r);                          if (p < 0)                          {                              s = -s;                          }                          if (s != 0)                          {                              if (k != m)                              {                                  h[k][k - 1] = -s*x;                              }                              else if (l != m)                              {                                  h[k][k - 1] = -h[k][k - 1];                              }                              p = p + s;                              x = p/s;                              y = q/s;                              z = r/s;                              q = q/p;                              r = r/p;                                // Row modification                                for (int j = k; j < nn; j++)                              {                                  p = h[k][j] + q*h[k + 1][j];                                  if (notlast)                                  {                                      p = p + r*h[k + 2][j];                                      h[k + 2][j] = h[k + 2][j] - p*z;                                  }                                  h[k][j] = h[k][j] - p*x;                                  h[k + 1][j] = h[k + 1][j] - p*y;                              }                                // Column modification                                for (int i = 0; i <= Math.Min(n' k + 3); i++)                              {                                  p = x*h[i][k] + y*h[i][k + 1];                                  if (notlast)                                  {                                      p = p + z*h[i][k + 2];                                      h[i][k + 2] = h[i][k + 2] - p*r;                                  }                                  h[i][k] = h[i][k] - p;                                  h[i][k + 1] = h[i][k + 1] - p*q;                              }                                // Accumulate transformations                                for (int i = low; i <= high; i++)                              {                                  p = x*v[i][k] + y*v[i][k + 1];                                  if (notlast)                                  {                                      p = p + z*v[i][k + 2];                                      v[i][k + 2] = v[i][k + 2] - p*r;                                  }                                  v[i][k] = v[i][k] - p;                                  v[i][k + 1] = v[i][k + 1] - p*q;                              }                          } // (s != 0)                      } // k loop                  } // check convergence              }
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: while (n >= low)              {                  // Look for single small sub-diagonal element                    int l = n;                  while (l > low)                  {                      s = Math.Abs(h[l - 1][l - 1]) + Math.Abs(h[l][l]);                      if (s == 0.0)                      {                          s = norm;                      }                      if (Math.Abs(h[l][l - 1]) < eps*s)                      {                          break;                      }                      l--;                  }                    // Check for convergence                  // One root found                    if (l == n)                  {                      h[n][n] = h[n][n] + exshift;                      d[n] = h[n][n];                      e[n] = 0.0;                      n--;                      iter = 0;                        // Two roots found                  }                  else if (l == n - 1)                  {                      w = h[n][n - 1]*h[n - 1][n];                      p = (h[n - 1][n - 1] - h[n][n])/2.0;                      q = p*p + w;                      z = Math.Sqrt(Math.Abs(q));                      h[n][n] = h[n][n] + exshift;                      h[n - 1][n - 1] = h[n - 1][n - 1] + exshift;                      x = h[n][n];                        // Real pair                        if (q >= 0)                      {                          if (p >= 0)                          {                              z = p + z;                          }                          else                          {                              z = p - z;                          }                          d[n - 1] = x + z;                          d[n] = d[n - 1];                          if (z != 0.0)                          {                              d[n] = x - w/z;                          }                          e[n - 1] = 0.0;                          e[n] = 0.0;                          x = h[n][n - 1];                          s = Math.Abs(x) + Math.Abs(z);                          p = x/s;                          q = z/s;                          r = Math.Sqrt(p*p + q*q);                          p = p/r;                          q = q/r;                            // Row modification                            for (int j = n - 1; j < nn; j++)                          {                              z = h[n - 1][j];                              h[n - 1][j] = q*z + p*h[n][j];                              h[n][j] = q*h[n][j] - p*z;                          }                            // Column modification                            for (int i = 0; i <= n; i++)                          {                              z = h[i][n - 1];                              h[i][n - 1] = q*z + p*h[i][n];                              h[i][n] = q*h[i][n] - p*z;                          }                            // Accumulate transformations                            for (int i = low; i <= high; i++)                          {                              z = v[i][n - 1];                              v[i][n - 1] = q*z + p*v[i][n];                              v[i][n] = q*v[i][n] - p*z;                          }                            // Complex pair                      }                      else                      {                          d[n - 1] = x + p;                          d[n] = x + p;                          e[n - 1] = z;                          e[n] = -z;                      }                      n = n - 2;                      iter = 0;                        // No convergence yet                  }                  else                  {                      // Form shift                        x = h[n][n];                      y = 0.0;                      w = 0.0;                      if (l < n)                      {                          y = h[n - 1][n - 1];                          w = h[n][n - 1]*h[n - 1][n];                      }                        // Wilkinson's original ad hoc shift                        if (iter == 10)                      {                          exshift += x;                          for (int i = low; i <= n; i++)                          {                              h[i][i] -= x;                          }                          s = Math.Abs(h[n][n - 1]) + Math.Abs(h[n - 1][n - 2]);                          x = y = 0.75*s;                          w = -0.4375*s*s;                      }                        // MATLAB's new ad hoc shift                        if (iter == 30)                      {                          s = (y - x)/2.0;                          s = s*s + w;                          if (s > 0)                          {                              s = Math.Sqrt(s);                              if (y < x)                              {                                  s = -s;                              }                              s = x - w/((y - x)/2.0 + s);                              for (int i = low; i <= n; i++)                              {                                  h[i][i] -= s;                              }                              exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1; // (Could check iteration count here.)                        // Look for two consecutive small sub-diagonal elements                        int m = n - 2;                      while (m >= l)                      {                          z = h[m][m];                          r = x - z;                          s = y - z;                          p = (r*s - w)/h[m + 1][m] + h[m][m + 1];                          q = h[m + 1][m + 1] - z - r - s;                          r = h[m + 2][m + 1];                          s = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                          p = p/s;                          q = q/s;                          r = r/s;                          if (m == l)                          {                              break;                          }                          if (Math.Abs(h[m][m - 1])*(Math.Abs(q) + Math.Abs(r)) < eps                              *(Math.Abs(p)*(Math.Abs(h[m - 1][m - 1])                                             + Math.Abs(z) + Math.Abs(h[m + 1][m + 1]))))                          {                              break;                          }                          m--;                      }                        for (int i = m + 2; i <= n; i++)                      {                          h[i][i - 2] = 0.0;                          if (i > m + 2)                          {                              h[i][i - 3] = 0.0;                          }                      }                        // Double QR step involving rows l:n and columns m:n                        for (int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                          if (k != m)                          {                              p = h[k][k - 1];                              q = h[k + 1][k - 1];                              r = (notlast ? h[k + 2][k - 1] : 0.0);                              x = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                              if (x != 0.0)                              {                                  p = p/x;                                  q = q/x;                                  r = r/x;                              }                          }                          if (x == 0.0)                          {                              break;                          }                          s = Math.Sqrt(p*p + q*q + r*r);                          if (p < 0)                          {                              s = -s;                          }                          if (s != 0)                          {                              if (k != m)                              {                                  h[k][k - 1] = -s*x;                              }                              else if (l != m)                              {                                  h[k][k - 1] = -h[k][k - 1];                              }                              p = p + s;                              x = p/s;                              y = q/s;                              z = r/s;                              q = q/p;                              r = r/p;                                // Row modification                                for (int j = k; j < nn; j++)                              {                                  p = h[k][j] + q*h[k + 1][j];                                  if (notlast)                                  {                                      p = p + r*h[k + 2][j];                                      h[k + 2][j] = h[k + 2][j] - p*z;                                  }                                  h[k][j] = h[k][j] - p*x;                                  h[k + 1][j] = h[k + 1][j] - p*y;                              }                                // Column modification                                for (int i = 0; i <= Math.Min(n' k + 3); i++)                              {                                  p = x*h[i][k] + y*h[i][k + 1];                                  if (notlast)                                  {                                      p = p + z*h[i][k + 2];                                      h[i][k + 2] = h[i][k + 2] - p*r;                                  }                                  h[i][k] = h[i][k] - p;                                  h[i][k + 1] = h[i][k + 1] - p*q;                              }                                // Accumulate transformations                                for (int i = low; i <= high; i++)                              {                                  p = x*v[i][k] + y*v[i][k + 1];                                  if (notlast)                                  {                                      p = p + z*v[i][k + 2];                                      v[i][k + 2] = v[i][k + 2] - p*r;                                  }                                  v[i][k] = v[i][k] - p;                                  v[i][k + 1] = v[i][k + 1] - p*q;                              }                          } // (s != 0)                      } // k loop                  } // check convergence              }
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: while (n >= low)              {                  // Look for single small sub-diagonal element                    int l = n;                  while (l > low)                  {                      s = Math.Abs(h[l - 1][l - 1]) + Math.Abs(h[l][l]);                      if (s == 0.0)                      {                          s = norm;                      }                      if (Math.Abs(h[l][l - 1]) < eps*s)                      {                          break;                      }                      l--;                  }                    // Check for convergence                  // One root found                    if (l == n)                  {                      h[n][n] = h[n][n] + exshift;                      d[n] = h[n][n];                      e[n] = 0.0;                      n--;                      iter = 0;                        // Two roots found                  }                  else if (l == n - 1)                  {                      w = h[n][n - 1]*h[n - 1][n];                      p = (h[n - 1][n - 1] - h[n][n])/2.0;                      q = p*p + w;                      z = Math.Sqrt(Math.Abs(q));                      h[n][n] = h[n][n] + exshift;                      h[n - 1][n - 1] = h[n - 1][n - 1] + exshift;                      x = h[n][n];                        // Real pair                        if (q >= 0)                      {                          if (p >= 0)                          {                              z = p + z;                          }                          else                          {                              z = p - z;                          }                          d[n - 1] = x + z;                          d[n] = d[n - 1];                          if (z != 0.0)                          {                              d[n] = x - w/z;                          }                          e[n - 1] = 0.0;                          e[n] = 0.0;                          x = h[n][n - 1];                          s = Math.Abs(x) + Math.Abs(z);                          p = x/s;                          q = z/s;                          r = Math.Sqrt(p*p + q*q);                          p = p/r;                          q = q/r;                            // Row modification                            for (int j = n - 1; j < nn; j++)                          {                              z = h[n - 1][j];                              h[n - 1][j] = q*z + p*h[n][j];                              h[n][j] = q*h[n][j] - p*z;                          }                            // Column modification                            for (int i = 0; i <= n; i++)                          {                              z = h[i][n - 1];                              h[i][n - 1] = q*z + p*h[i][n];                              h[i][n] = q*h[i][n] - p*z;                          }                            // Accumulate transformations                            for (int i = low; i <= high; i++)                          {                              z = v[i][n - 1];                              v[i][n - 1] = q*z + p*v[i][n];                              v[i][n] = q*v[i][n] - p*z;                          }                            // Complex pair                      }                      else                      {                          d[n - 1] = x + p;                          d[n] = x + p;                          e[n - 1] = z;                          e[n] = -z;                      }                      n = n - 2;                      iter = 0;                        // No convergence yet                  }                  else                  {                      // Form shift                        x = h[n][n];                      y = 0.0;                      w = 0.0;                      if (l < n)                      {                          y = h[n - 1][n - 1];                          w = h[n][n - 1]*h[n - 1][n];                      }                        // Wilkinson's original ad hoc shift                        if (iter == 10)                      {                          exshift += x;                          for (int i = low; i <= n; i++)                          {                              h[i][i] -= x;                          }                          s = Math.Abs(h[n][n - 1]) + Math.Abs(h[n - 1][n - 2]);                          x = y = 0.75*s;                          w = -0.4375*s*s;                      }                        // MATLAB's new ad hoc shift                        if (iter == 30)                      {                          s = (y - x)/2.0;                          s = s*s + w;                          if (s > 0)                          {                              s = Math.Sqrt(s);                              if (y < x)                              {                                  s = -s;                              }                              s = x - w/((y - x)/2.0 + s);                              for (int i = low; i <= n; i++)                              {                                  h[i][i] -= s;                              }                              exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1; // (Could check iteration count here.)                        // Look for two consecutive small sub-diagonal elements                        int m = n - 2;                      while (m >= l)                      {                          z = h[m][m];                          r = x - z;                          s = y - z;                          p = (r*s - w)/h[m + 1][m] + h[m][m + 1];                          q = h[m + 1][m + 1] - z - r - s;                          r = h[m + 2][m + 1];                          s = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                          p = p/s;                          q = q/s;                          r = r/s;                          if (m == l)                          {                              break;                          }                          if (Math.Abs(h[m][m - 1])*(Math.Abs(q) + Math.Abs(r)) < eps                              *(Math.Abs(p)*(Math.Abs(h[m - 1][m - 1])                                             + Math.Abs(z) + Math.Abs(h[m + 1][m + 1]))))                          {                              break;                          }                          m--;                      }                        for (int i = m + 2; i <= n; i++)                      {                          h[i][i - 2] = 0.0;                          if (i > m + 2)                          {                              h[i][i - 3] = 0.0;                          }                      }                        // Double QR step involving rows l:n and columns m:n                        for (int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                          if (k != m)                          {                              p = h[k][k - 1];                              q = h[k + 1][k - 1];                              r = (notlast ? h[k + 2][k - 1] : 0.0);                              x = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                              if (x != 0.0)                              {                                  p = p/x;                                  q = q/x;                                  r = r/x;                              }                          }                          if (x == 0.0)                          {                              break;                          }                          s = Math.Sqrt(p*p + q*q + r*r);                          if (p < 0)                          {                              s = -s;                          }                          if (s != 0)                          {                              if (k != m)                              {                                  h[k][k - 1] = -s*x;                              }                              else if (l != m)                              {                                  h[k][k - 1] = -h[k][k - 1];                              }                              p = p + s;                              x = p/s;                              y = q/s;                              z = r/s;                              q = q/p;                              r = r/p;                                // Row modification                                for (int j = k; j < nn; j++)                              {                                  p = h[k][j] + q*h[k + 1][j];                                  if (notlast)                                  {                                      p = p + r*h[k + 2][j];                                      h[k + 2][j] = h[k + 2][j] - p*z;                                  }                                  h[k][j] = h[k][j] - p*x;                                  h[k + 1][j] = h[k + 1][j] - p*y;                              }                                // Column modification                                for (int i = 0; i <= Math.Min(n' k + 3); i++)                              {                                  p = x*h[i][k] + y*h[i][k + 1];                                  if (notlast)                                  {                                      p = p + z*h[i][k + 2];                                      h[i][k + 2] = h[i][k + 2] - p*r;                                  }                                  h[i][k] = h[i][k] - p;                                  h[i][k + 1] = h[i][k + 1] - p*q;                              }                                // Accumulate transformations                                for (int i = low; i <= high; i++)                              {                                  p = x*v[i][k] + y*v[i][k + 1];                                  if (notlast)                                  {                                      p = p + z*v[i][k + 2];                                      v[i][k + 2] = v[i][k + 2] - p*r;                                  }                                  v[i][k] = v[i][k] - p;                                  v[i][k + 1] = v[i][k + 1] - p*q;                              }                          } // (s != 0)                      } // k loop                  } // check convergence              }
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: while (n >= low)              {                  // Look for single small sub-diagonal element                    int l = n;                  while (l > low)                  {                      s = Math.Abs(h[l - 1][l - 1]) + Math.Abs(h[l][l]);                      if (s == 0.0)                      {                          s = norm;                      }                      if (Math.Abs(h[l][l - 1]) < eps*s)                      {                          break;                      }                      l--;                  }                    // Check for convergence                  // One root found                    if (l == n)                  {                      h[n][n] = h[n][n] + exshift;                      d[n] = h[n][n];                      e[n] = 0.0;                      n--;                      iter = 0;                        // Two roots found                  }                  else if (l == n - 1)                  {                      w = h[n][n - 1]*h[n - 1][n];                      p = (h[n - 1][n - 1] - h[n][n])/2.0;                      q = p*p + w;                      z = Math.Sqrt(Math.Abs(q));                      h[n][n] = h[n][n] + exshift;                      h[n - 1][n - 1] = h[n - 1][n - 1] + exshift;                      x = h[n][n];                        // Real pair                        if (q >= 0)                      {                          if (p >= 0)                          {                              z = p + z;                          }                          else                          {                              z = p - z;                          }                          d[n - 1] = x + z;                          d[n] = d[n - 1];                          if (z != 0.0)                          {                              d[n] = x - w/z;                          }                          e[n - 1] = 0.0;                          e[n] = 0.0;                          x = h[n][n - 1];                          s = Math.Abs(x) + Math.Abs(z);                          p = x/s;                          q = z/s;                          r = Math.Sqrt(p*p + q*q);                          p = p/r;                          q = q/r;                            // Row modification                            for (int j = n - 1; j < nn; j++)                          {                              z = h[n - 1][j];                              h[n - 1][j] = q*z + p*h[n][j];                              h[n][j] = q*h[n][j] - p*z;                          }                            // Column modification                            for (int i = 0; i <= n; i++)                          {                              z = h[i][n - 1];                              h[i][n - 1] = q*z + p*h[i][n];                              h[i][n] = q*h[i][n] - p*z;                          }                            // Accumulate transformations                            for (int i = low; i <= high; i++)                          {                              z = v[i][n - 1];                              v[i][n - 1] = q*z + p*v[i][n];                              v[i][n] = q*v[i][n] - p*z;                          }                            // Complex pair                      }                      else                      {                          d[n - 1] = x + p;                          d[n] = x + p;                          e[n - 1] = z;                          e[n] = -z;                      }                      n = n - 2;                      iter = 0;                        // No convergence yet                  }                  else                  {                      // Form shift                        x = h[n][n];                      y = 0.0;                      w = 0.0;                      if (l < n)                      {                          y = h[n - 1][n - 1];                          w = h[n][n - 1]*h[n - 1][n];                      }                        // Wilkinson's original ad hoc shift                        if (iter == 10)                      {                          exshift += x;                          for (int i = low; i <= n; i++)                          {                              h[i][i] -= x;                          }                          s = Math.Abs(h[n][n - 1]) + Math.Abs(h[n - 1][n - 2]);                          x = y = 0.75*s;                          w = -0.4375*s*s;                      }                        // MATLAB's new ad hoc shift                        if (iter == 30)                      {                          s = (y - x)/2.0;                          s = s*s + w;                          if (s > 0)                          {                              s = Math.Sqrt(s);                              if (y < x)                              {                                  s = -s;                              }                              s = x - w/((y - x)/2.0 + s);                              for (int i = low; i <= n; i++)                              {                                  h[i][i] -= s;                              }                              exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1; // (Could check iteration count here.)                        // Look for two consecutive small sub-diagonal elements                        int m = n - 2;                      while (m >= l)                      {                          z = h[m][m];                          r = x - z;                          s = y - z;                          p = (r*s - w)/h[m + 1][m] + h[m][m + 1];                          q = h[m + 1][m + 1] - z - r - s;                          r = h[m + 2][m + 1];                          s = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                          p = p/s;                          q = q/s;                          r = r/s;                          if (m == l)                          {                              break;                          }                          if (Math.Abs(h[m][m - 1])*(Math.Abs(q) + Math.Abs(r)) < eps                              *(Math.Abs(p)*(Math.Abs(h[m - 1][m - 1])                                             + Math.Abs(z) + Math.Abs(h[m + 1][m + 1]))))                          {                              break;                          }                          m--;                      }                        for (int i = m + 2; i <= n; i++)                      {                          h[i][i - 2] = 0.0;                          if (i > m + 2)                          {                              h[i][i - 3] = 0.0;                          }                      }                        // Double QR step involving rows l:n and columns m:n                        for (int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                          if (k != m)                          {                              p = h[k][k - 1];                              q = h[k + 1][k - 1];                              r = (notlast ? h[k + 2][k - 1] : 0.0);                              x = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                              if (x != 0.0)                              {                                  p = p/x;                                  q = q/x;                                  r = r/x;                              }                          }                          if (x == 0.0)                          {                              break;                          }                          s = Math.Sqrt(p*p + q*q + r*r);                          if (p < 0)                          {                              s = -s;                          }                          if (s != 0)                          {                              if (k != m)                              {                                  h[k][k - 1] = -s*x;                              }                              else if (l != m)                              {                                  h[k][k - 1] = -h[k][k - 1];                              }                              p = p + s;                              x = p/s;                              y = q/s;                              z = r/s;                              q = q/p;                              r = r/p;                                // Row modification                                for (int j = k; j < nn; j++)                              {                                  p = h[k][j] + q*h[k + 1][j];                                  if (notlast)                                  {                                      p = p + r*h[k + 2][j];                                      h[k + 2][j] = h[k + 2][j] - p*z;                                  }                                  h[k][j] = h[k][j] - p*x;                                  h[k + 1][j] = h[k + 1][j] - p*y;                              }                                // Column modification                                for (int i = 0; i <= Math.Min(n' k + 3); i++)                              {                                  p = x*h[i][k] + y*h[i][k + 1];                                  if (notlast)                                  {                                      p = p + z*h[i][k + 2];                                      h[i][k + 2] = h[i][k + 2] - p*r;                                  }                                  h[i][k] = h[i][k] - p;                                  h[i][k + 1] = h[i][k + 1] - p*q;                              }                                // Accumulate transformations                                for (int i = low; i <= high; i++)                              {                                  p = x*v[i][k] + y*v[i][k + 1];                                  if (notlast)                                  {                                      p = p + z*v[i][k + 2];                                      v[i][k + 2] = v[i][k + 2] - p*r;                                  }                                  v[i][k] = v[i][k] - p;                                  v[i][k + 1] = v[i][k + 1] - p*q;                              }                          } // (s != 0)                      } // k loop                  } // check convergence              }
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: while (n >= low)              {                  // Look for single small sub-diagonal element                    int l = n;                  while (l > low)                  {                      s = Math.Abs(h[l - 1][l - 1]) + Math.Abs(h[l][l]);                      if (s == 0.0)                      {                          s = norm;                      }                      if (Math.Abs(h[l][l - 1]) < eps*s)                      {                          break;                      }                      l--;                  }                    // Check for convergence                  // One root found                    if (l == n)                  {                      h[n][n] = h[n][n] + exshift;                      d[n] = h[n][n];                      e[n] = 0.0;                      n--;                      iter = 0;                        // Two roots found                  }                  else if (l == n - 1)                  {                      w = h[n][n - 1]*h[n - 1][n];                      p = (h[n - 1][n - 1] - h[n][n])/2.0;                      q = p*p + w;                      z = Math.Sqrt(Math.Abs(q));                      h[n][n] = h[n][n] + exshift;                      h[n - 1][n - 1] = h[n - 1][n - 1] + exshift;                      x = h[n][n];                        // Real pair                        if (q >= 0)                      {                          if (p >= 0)                          {                              z = p + z;                          }                          else                          {                              z = p - z;                          }                          d[n - 1] = x + z;                          d[n] = d[n - 1];                          if (z != 0.0)                          {                              d[n] = x - w/z;                          }                          e[n - 1] = 0.0;                          e[n] = 0.0;                          x = h[n][n - 1];                          s = Math.Abs(x) + Math.Abs(z);                          p = x/s;                          q = z/s;                          r = Math.Sqrt(p*p + q*q);                          p = p/r;                          q = q/r;                            // Row modification                            for (int j = n - 1; j < nn; j++)                          {                              z = h[n - 1][j];                              h[n - 1][j] = q*z + p*h[n][j];                              h[n][j] = q*h[n][j] - p*z;                          }                            // Column modification                            for (int i = 0; i <= n; i++)                          {                              z = h[i][n - 1];                              h[i][n - 1] = q*z + p*h[i][n];                              h[i][n] = q*h[i][n] - p*z;                          }                            // Accumulate transformations                            for (int i = low; i <= high; i++)                          {                              z = v[i][n - 1];                              v[i][n - 1] = q*z + p*v[i][n];                              v[i][n] = q*v[i][n] - p*z;                          }                            // Complex pair                      }                      else                      {                          d[n - 1] = x + p;                          d[n] = x + p;                          e[n - 1] = z;                          e[n] = -z;                      }                      n = n - 2;                      iter = 0;                        // No convergence yet                  }                  else                  {                      // Form shift                        x = h[n][n];                      y = 0.0;                      w = 0.0;                      if (l < n)                      {                          y = h[n - 1][n - 1];                          w = h[n][n - 1]*h[n - 1][n];                      }                        // Wilkinson's original ad hoc shift                        if (iter == 10)                      {                          exshift += x;                          for (int i = low; i <= n; i++)                          {                              h[i][i] -= x;                          }                          s = Math.Abs(h[n][n - 1]) + Math.Abs(h[n - 1][n - 2]);                          x = y = 0.75*s;                          w = -0.4375*s*s;                      }                        // MATLAB's new ad hoc shift                        if (iter == 30)                      {                          s = (y - x)/2.0;                          s = s*s + w;                          if (s > 0)                          {                              s = Math.Sqrt(s);                              if (y < x)                              {                                  s = -s;                              }                              s = x - w/((y - x)/2.0 + s);                              for (int i = low; i <= n; i++)                              {                                  h[i][i] -= s;                              }                              exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1; // (Could check iteration count here.)                        // Look for two consecutive small sub-diagonal elements                        int m = n - 2;                      while (m >= l)                      {                          z = h[m][m];                          r = x - z;                          s = y - z;                          p = (r*s - w)/h[m + 1][m] + h[m][m + 1];                          q = h[m + 1][m + 1] - z - r - s;                          r = h[m + 2][m + 1];                          s = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                          p = p/s;                          q = q/s;                          r = r/s;                          if (m == l)                          {                              break;                          }                          if (Math.Abs(h[m][m - 1])*(Math.Abs(q) + Math.Abs(r)) < eps                              *(Math.Abs(p)*(Math.Abs(h[m - 1][m - 1])                                             + Math.Abs(z) + Math.Abs(h[m + 1][m + 1]))))                          {                              break;                          }                          m--;                      }                        for (int i = m + 2; i <= n; i++)                      {                          h[i][i - 2] = 0.0;                          if (i > m + 2)                          {                              h[i][i - 3] = 0.0;                          }                      }                        // Double QR step involving rows l:n and columns m:n                        for (int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                          if (k != m)                          {                              p = h[k][k - 1];                              q = h[k + 1][k - 1];                              r = (notlast ? h[k + 2][k - 1] : 0.0);                              x = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                              if (x != 0.0)                              {                                  p = p/x;                                  q = q/x;                                  r = r/x;                              }                          }                          if (x == 0.0)                          {                              break;                          }                          s = Math.Sqrt(p*p + q*q + r*r);                          if (p < 0)                          {                              s = -s;                          }                          if (s != 0)                          {                              if (k != m)                              {                                  h[k][k - 1] = -s*x;                              }                              else if (l != m)                              {                                  h[k][k - 1] = -h[k][k - 1];                              }                              p = p + s;                              x = p/s;                              y = q/s;                              z = r/s;                              q = q/p;                              r = r/p;                                // Row modification                                for (int j = k; j < nn; j++)                              {                                  p = h[k][j] + q*h[k + 1][j];                                  if (notlast)                                  {                                      p = p + r*h[k + 2][j];                                      h[k + 2][j] = h[k + 2][j] - p*z;                                  }                                  h[k][j] = h[k][j] - p*x;                                  h[k + 1][j] = h[k + 1][j] - p*y;                              }                                // Column modification                                for (int i = 0; i <= Math.Min(n' k + 3); i++)                              {                                  p = x*h[i][k] + y*h[i][k + 1];                                  if (notlast)                                  {                                      p = p + z*h[i][k + 2];                                      h[i][k + 2] = h[i][k + 2] - p*r;                                  }                                  h[i][k] = h[i][k] - p;                                  h[i][k + 1] = h[i][k + 1] - p*q;                              }                                // Accumulate transformations                                for (int i = low; i <= high; i++)                              {                                  p = x*v[i][k] + y*v[i][k + 1];                                  if (notlast)                                  {                                      p = p + z*v[i][k + 2];                                      v[i][k + 2] = v[i][k + 2] - p*r;                                  }                                  v[i][k] = v[i][k] - p;                                  v[i][k + 1] = v[i][k + 1] - p*q;                              }                          } // (s != 0)                      } // k loop                  } // check convergence              }
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: while (n >= low)              {                  // Look for single small sub-diagonal element                    int l = n;                  while (l > low)                  {                      s = Math.Abs(h[l - 1][l - 1]) + Math.Abs(h[l][l]);                      if (s == 0.0)                      {                          s = norm;                      }                      if (Math.Abs(h[l][l - 1]) < eps*s)                      {                          break;                      }                      l--;                  }                    // Check for convergence                  // One root found                    if (l == n)                  {                      h[n][n] = h[n][n] + exshift;                      d[n] = h[n][n];                      e[n] = 0.0;                      n--;                      iter = 0;                        // Two roots found                  }                  else if (l == n - 1)                  {                      w = h[n][n - 1]*h[n - 1][n];                      p = (h[n - 1][n - 1] - h[n][n])/2.0;                      q = p*p + w;                      z = Math.Sqrt(Math.Abs(q));                      h[n][n] = h[n][n] + exshift;                      h[n - 1][n - 1] = h[n - 1][n - 1] + exshift;                      x = h[n][n];                        // Real pair                        if (q >= 0)                      {                          if (p >= 0)                          {                              z = p + z;                          }                          else                          {                              z = p - z;                          }                          d[n - 1] = x + z;                          d[n] = d[n - 1];                          if (z != 0.0)                          {                              d[n] = x - w/z;                          }                          e[n - 1] = 0.0;                          e[n] = 0.0;                          x = h[n][n - 1];                          s = Math.Abs(x) + Math.Abs(z);                          p = x/s;                          q = z/s;                          r = Math.Sqrt(p*p + q*q);                          p = p/r;                          q = q/r;                            // Row modification                            for (int j = n - 1; j < nn; j++)                          {                              z = h[n - 1][j];                              h[n - 1][j] = q*z + p*h[n][j];                              h[n][j] = q*h[n][j] - p*z;                          }                            // Column modification                            for (int i = 0; i <= n; i++)                          {                              z = h[i][n - 1];                              h[i][n - 1] = q*z + p*h[i][n];                              h[i][n] = q*h[i][n] - p*z;                          }                            // Accumulate transformations                            for (int i = low; i <= high; i++)                          {                              z = v[i][n - 1];                              v[i][n - 1] = q*z + p*v[i][n];                              v[i][n] = q*v[i][n] - p*z;                          }                            // Complex pair                      }                      else                      {                          d[n - 1] = x + p;                          d[n] = x + p;                          e[n - 1] = z;                          e[n] = -z;                      }                      n = n - 2;                      iter = 0;                        // No convergence yet                  }                  else                  {                      // Form shift                        x = h[n][n];                      y = 0.0;                      w = 0.0;                      if (l < n)                      {                          y = h[n - 1][n - 1];                          w = h[n][n - 1]*h[n - 1][n];                      }                        // Wilkinson's original ad hoc shift                        if (iter == 10)                      {                          exshift += x;                          for (int i = low; i <= n; i++)                          {                              h[i][i] -= x;                          }                          s = Math.Abs(h[n][n - 1]) + Math.Abs(h[n - 1][n - 2]);                          x = y = 0.75*s;                          w = -0.4375*s*s;                      }                        // MATLAB's new ad hoc shift                        if (iter == 30)                      {                          s = (y - x)/2.0;                          s = s*s + w;                          if (s > 0)                          {                              s = Math.Sqrt(s);                              if (y < x)                              {                                  s = -s;                              }                              s = x - w/((y - x)/2.0 + s);                              for (int i = low; i <= n; i++)                              {                                  h[i][i] -= s;                              }                              exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1; // (Could check iteration count here.)                        // Look for two consecutive small sub-diagonal elements                        int m = n - 2;                      while (m >= l)                      {                          z = h[m][m];                          r = x - z;                          s = y - z;                          p = (r*s - w)/h[m + 1][m] + h[m][m + 1];                          q = h[m + 1][m + 1] - z - r - s;                          r = h[m + 2][m + 1];                          s = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                          p = p/s;                          q = q/s;                          r = r/s;                          if (m == l)                          {                              break;                          }                          if (Math.Abs(h[m][m - 1])*(Math.Abs(q) + Math.Abs(r)) < eps                              *(Math.Abs(p)*(Math.Abs(h[m - 1][m - 1])                                             + Math.Abs(z) + Math.Abs(h[m + 1][m + 1]))))                          {                              break;                          }                          m--;                      }                        for (int i = m + 2; i <= n; i++)                      {                          h[i][i - 2] = 0.0;                          if (i > m + 2)                          {                              h[i][i - 3] = 0.0;                          }                      }                        // Double QR step involving rows l:n and columns m:n                        for (int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                          if (k != m)                          {                              p = h[k][k - 1];                              q = h[k + 1][k - 1];                              r = (notlast ? h[k + 2][k - 1] : 0.0);                              x = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                              if (x != 0.0)                              {                                  p = p/x;                                  q = q/x;                                  r = r/x;                              }                          }                          if (x == 0.0)                          {                              break;                          }                          s = Math.Sqrt(p*p + q*q + r*r);                          if (p < 0)                          {                              s = -s;                          }                          if (s != 0)                          {                              if (k != m)                              {                                  h[k][k - 1] = -s*x;                              }                              else if (l != m)                              {                                  h[k][k - 1] = -h[k][k - 1];                              }                              p = p + s;                              x = p/s;                              y = q/s;                              z = r/s;                              q = q/p;                              r = r/p;                                // Row modification                                for (int j = k; j < nn; j++)                              {                                  p = h[k][j] + q*h[k + 1][j];                                  if (notlast)                                  {                                      p = p + r*h[k + 2][j];                                      h[k + 2][j] = h[k + 2][j] - p*z;                                  }                                  h[k][j] = h[k][j] - p*x;                                  h[k + 1][j] = h[k + 1][j] - p*y;                              }                                // Column modification                                for (int i = 0; i <= Math.Min(n' k + 3); i++)                              {                                  p = x*h[i][k] + y*h[i][k + 1];                                  if (notlast)                                  {                                      p = p + z*h[i][k + 2];                                      h[i][k + 2] = h[i][k + 2] - p*r;                                  }                                  h[i][k] = h[i][k] - p;                                  h[i][k + 1] = h[i][k + 1] - p*q;                              }                                // Accumulate transformations                                for (int i = low; i <= high; i++)                              {                                  p = x*v[i][k] + y*v[i][k + 1];                                  if (notlast)                                  {                                      p = p + z*v[i][k + 2];                                      v[i][k + 2] = v[i][k + 2] - p*r;                                  }                                  v[i][k] = v[i][k] - p;                                  v[i][k + 1] = v[i][k + 1] - p*q;                              }                          } // (s != 0)                      } // k loop                  } // check convergence              }
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: while (n >= low)              {                  // Look for single small sub-diagonal element                    int l = n;                  while (l > low)                  {                      s = Math.Abs(h[l - 1][l - 1]) + Math.Abs(h[l][l]);                      if (s == 0.0)                      {                          s = norm;                      }                      if (Math.Abs(h[l][l - 1]) < eps*s)                      {                          break;                      }                      l--;                  }                    // Check for convergence                  // One root found                    if (l == n)                  {                      h[n][n] = h[n][n] + exshift;                      d[n] = h[n][n];                      e[n] = 0.0;                      n--;                      iter = 0;                        // Two roots found                  }                  else if (l == n - 1)                  {                      w = h[n][n - 1]*h[n - 1][n];                      p = (h[n - 1][n - 1] - h[n][n])/2.0;                      q = p*p + w;                      z = Math.Sqrt(Math.Abs(q));                      h[n][n] = h[n][n] + exshift;                      h[n - 1][n - 1] = h[n - 1][n - 1] + exshift;                      x = h[n][n];                        // Real pair                        if (q >= 0)                      {                          if (p >= 0)                          {                              z = p + z;                          }                          else                          {                              z = p - z;                          }                          d[n - 1] = x + z;                          d[n] = d[n - 1];                          if (z != 0.0)                          {                              d[n] = x - w/z;                          }                          e[n - 1] = 0.0;                          e[n] = 0.0;                          x = h[n][n - 1];                          s = Math.Abs(x) + Math.Abs(z);                          p = x/s;                          q = z/s;                          r = Math.Sqrt(p*p + q*q);                          p = p/r;                          q = q/r;                            // Row modification                            for (int j = n - 1; j < nn; j++)                          {                              z = h[n - 1][j];                              h[n - 1][j] = q*z + p*h[n][j];                              h[n][j] = q*h[n][j] - p*z;                          }                            // Column modification                            for (int i = 0; i <= n; i++)                          {                              z = h[i][n - 1];                              h[i][n - 1] = q*z + p*h[i][n];                              h[i][n] = q*h[i][n] - p*z;                          }                            // Accumulate transformations                            for (int i = low; i <= high; i++)                          {                              z = v[i][n - 1];                              v[i][n - 1] = q*z + p*v[i][n];                              v[i][n] = q*v[i][n] - p*z;                          }                            // Complex pair                      }                      else                      {                          d[n - 1] = x + p;                          d[n] = x + p;                          e[n - 1] = z;                          e[n] = -z;                      }                      n = n - 2;                      iter = 0;                        // No convergence yet                  }                  else                  {                      // Form shift                        x = h[n][n];                      y = 0.0;                      w = 0.0;                      if (l < n)                      {                          y = h[n - 1][n - 1];                          w = h[n][n - 1]*h[n - 1][n];                      }                        // Wilkinson's original ad hoc shift                        if (iter == 10)                      {                          exshift += x;                          for (int i = low; i <= n; i++)                          {                              h[i][i] -= x;                          }                          s = Math.Abs(h[n][n - 1]) + Math.Abs(h[n - 1][n - 2]);                          x = y = 0.75*s;                          w = -0.4375*s*s;                      }                        // MATLAB's new ad hoc shift                        if (iter == 30)                      {                          s = (y - x)/2.0;                          s = s*s + w;                          if (s > 0)                          {                              s = Math.Sqrt(s);                              if (y < x)                              {                                  s = -s;                              }                              s = x - w/((y - x)/2.0 + s);                              for (int i = low; i <= n; i++)                              {                                  h[i][i] -= s;                              }                              exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1; // (Could check iteration count here.)                        // Look for two consecutive small sub-diagonal elements                        int m = n - 2;                      while (m >= l)                      {                          z = h[m][m];                          r = x - z;                          s = y - z;                          p = (r*s - w)/h[m + 1][m] + h[m][m + 1];                          q = h[m + 1][m + 1] - z - r - s;                          r = h[m + 2][m + 1];                          s = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                          p = p/s;                          q = q/s;                          r = r/s;                          if (m == l)                          {                              break;                          }                          if (Math.Abs(h[m][m - 1])*(Math.Abs(q) + Math.Abs(r)) < eps                              *(Math.Abs(p)*(Math.Abs(h[m - 1][m - 1])                                             + Math.Abs(z) + Math.Abs(h[m + 1][m + 1]))))                          {                              break;                          }                          m--;                      }                        for (int i = m + 2; i <= n; i++)                      {                          h[i][i - 2] = 0.0;                          if (i > m + 2)                          {                              h[i][i - 3] = 0.0;                          }                      }                        // Double QR step involving rows l:n and columns m:n                        for (int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                          if (k != m)                          {                              p = h[k][k - 1];                              q = h[k + 1][k - 1];                              r = (notlast ? h[k + 2][k - 1] : 0.0);                              x = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                              if (x != 0.0)                              {                                  p = p/x;                                  q = q/x;                                  r = r/x;                              }                          }                          if (x == 0.0)                          {                              break;                          }                          s = Math.Sqrt(p*p + q*q + r*r);                          if (p < 0)                          {                              s = -s;                          }                          if (s != 0)                          {                              if (k != m)                              {                                  h[k][k - 1] = -s*x;                              }                              else if (l != m)                              {                                  h[k][k - 1] = -h[k][k - 1];                              }                              p = p + s;                              x = p/s;                              y = q/s;                              z = r/s;                              q = q/p;                              r = r/p;                                // Row modification                                for (int j = k; j < nn; j++)                              {                                  p = h[k][j] + q*h[k + 1][j];                                  if (notlast)                                  {                                      p = p + r*h[k + 2][j];                                      h[k + 2][j] = h[k + 2][j] - p*z;                                  }                                  h[k][j] = h[k][j] - p*x;                                  h[k + 1][j] = h[k + 1][j] - p*y;                              }                                // Column modification                                for (int i = 0; i <= Math.Min(n' k + 3); i++)                              {                                  p = x*h[i][k] + y*h[i][k + 1];                                  if (notlast)                                  {                                      p = p + z*h[i][k + 2];                                      h[i][k + 2] = h[i][k + 2] - p*r;                                  }                                  h[i][k] = h[i][k] - p;                                  h[i][k + 1] = h[i][k + 1] - p*q;                              }                                // Accumulate transformations                                for (int i = low; i <= high; i++)                              {                                  p = x*v[i][k] + y*v[i][k + 1];                                  if (notlast)                                  {                                      p = p + z*v[i][k + 2];                                      v[i][k + 2] = v[i][k + 2] - p*r;                                  }                                  v[i][k] = v[i][k] - p;                                  v[i][k + 1] = v[i][k + 1] - p*q;                              }                          } // (s != 0)                      } // k loop                  } // check convergence              }
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: while (n >= low)              {                  // Look for single small sub-diagonal element                    int l = n;                  while (l > low)                  {                      s = Math.Abs(h[l - 1][l - 1]) + Math.Abs(h[l][l]);                      if (s == 0.0)                      {                          s = norm;                      }                      if (Math.Abs(h[l][l - 1]) < eps*s)                      {                          break;                      }                      l--;                  }                    // Check for convergence                  // One root found                    if (l == n)                  {                      h[n][n] = h[n][n] + exshift;                      d[n] = h[n][n];                      e[n] = 0.0;                      n--;                      iter = 0;                        // Two roots found                  }                  else if (l == n - 1)                  {                      w = h[n][n - 1]*h[n - 1][n];                      p = (h[n - 1][n - 1] - h[n][n])/2.0;                      q = p*p + w;                      z = Math.Sqrt(Math.Abs(q));                      h[n][n] = h[n][n] + exshift;                      h[n - 1][n - 1] = h[n - 1][n - 1] + exshift;                      x = h[n][n];                        // Real pair                        if (q >= 0)                      {                          if (p >= 0)                          {                              z = p + z;                          }                          else                          {                              z = p - z;                          }                          d[n - 1] = x + z;                          d[n] = d[n - 1];                          if (z != 0.0)                          {                              d[n] = x - w/z;                          }                          e[n - 1] = 0.0;                          e[n] = 0.0;                          x = h[n][n - 1];                          s = Math.Abs(x) + Math.Abs(z);                          p = x/s;                          q = z/s;                          r = Math.Sqrt(p*p + q*q);                          p = p/r;                          q = q/r;                            // Row modification                            for (int j = n - 1; j < nn; j++)                          {                              z = h[n - 1][j];                              h[n - 1][j] = q*z + p*h[n][j];                              h[n][j] = q*h[n][j] - p*z;                          }                            // Column modification                            for (int i = 0; i <= n; i++)                          {                              z = h[i][n - 1];                              h[i][n - 1] = q*z + p*h[i][n];                              h[i][n] = q*h[i][n] - p*z;                          }                            // Accumulate transformations                            for (int i = low; i <= high; i++)                          {                              z = v[i][n - 1];                              v[i][n - 1] = q*z + p*v[i][n];                              v[i][n] = q*v[i][n] - p*z;                          }                            // Complex pair                      }                      else                      {                          d[n - 1] = x + p;                          d[n] = x + p;                          e[n - 1] = z;                          e[n] = -z;                      }                      n = n - 2;                      iter = 0;                        // No convergence yet                  }                  else                  {                      // Form shift                        x = h[n][n];                      y = 0.0;                      w = 0.0;                      if (l < n)                      {                          y = h[n - 1][n - 1];                          w = h[n][n - 1]*h[n - 1][n];                      }                        // Wilkinson's original ad hoc shift                        if (iter == 10)                      {                          exshift += x;                          for (int i = low; i <= n; i++)                          {                              h[i][i] -= x;                          }                          s = Math.Abs(h[n][n - 1]) + Math.Abs(h[n - 1][n - 2]);                          x = y = 0.75*s;                          w = -0.4375*s*s;                      }                        // MATLAB's new ad hoc shift                        if (iter == 30)                      {                          s = (y - x)/2.0;                          s = s*s + w;                          if (s > 0)                          {                              s = Math.Sqrt(s);                              if (y < x)                              {                                  s = -s;                              }                              s = x - w/((y - x)/2.0 + s);                              for (int i = low; i <= n; i++)                              {                                  h[i][i] -= s;                              }                              exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1; // (Could check iteration count here.)                        // Look for two consecutive small sub-diagonal elements                        int m = n - 2;                      while (m >= l)                      {                          z = h[m][m];                          r = x - z;                          s = y - z;                          p = (r*s - w)/h[m + 1][m] + h[m][m + 1];                          q = h[m + 1][m + 1] - z - r - s;                          r = h[m + 2][m + 1];                          s = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                          p = p/s;                          q = q/s;                          r = r/s;                          if (m == l)                          {                              break;                          }                          if (Math.Abs(h[m][m - 1])*(Math.Abs(q) + Math.Abs(r)) < eps                              *(Math.Abs(p)*(Math.Abs(h[m - 1][m - 1])                                             + Math.Abs(z) + Math.Abs(h[m + 1][m + 1]))))                          {                              break;                          }                          m--;                      }                        for (int i = m + 2; i <= n; i++)                      {                          h[i][i - 2] = 0.0;                          if (i > m + 2)                          {                              h[i][i - 3] = 0.0;                          }                      }                        // Double QR step involving rows l:n and columns m:n                        for (int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                          if (k != m)                          {                              p = h[k][k - 1];                              q = h[k + 1][k - 1];                              r = (notlast ? h[k + 2][k - 1] : 0.0);                              x = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                              if (x != 0.0)                              {                                  p = p/x;                                  q = q/x;                                  r = r/x;                              }                          }                          if (x == 0.0)                          {                              break;                          }                          s = Math.Sqrt(p*p + q*q + r*r);                          if (p < 0)                          {                              s = -s;                          }                          if (s != 0)                          {                              if (k != m)                              {                                  h[k][k - 1] = -s*x;                              }                              else if (l != m)                              {                                  h[k][k - 1] = -h[k][k - 1];                              }                              p = p + s;                              x = p/s;                              y = q/s;                              z = r/s;                              q = q/p;                              r = r/p;                                // Row modification                                for (int j = k; j < nn; j++)                              {                                  p = h[k][j] + q*h[k + 1][j];                                  if (notlast)                                  {                                      p = p + r*h[k + 2][j];                                      h[k + 2][j] = h[k + 2][j] - p*z;                                  }                                  h[k][j] = h[k][j] - p*x;                                  h[k + 1][j] = h[k + 1][j] - p*y;                              }                                // Column modification                                for (int i = 0; i <= Math.Min(n' k + 3); i++)                              {                                  p = x*h[i][k] + y*h[i][k + 1];                                  if (notlast)                                  {                                      p = p + z*h[i][k + 2];                                      h[i][k + 2] = h[i][k + 2] - p*r;                                  }                                  h[i][k] = h[i][k] - p;                                  h[i][k + 1] = h[i][k + 1] - p*q;                              }                                // Accumulate transformations                                for (int i = low; i <= high; i++)                              {                                  p = x*v[i][k] + y*v[i][k + 1];                                  if (notlast)                                  {                                      p = p + z*v[i][k + 2];                                      v[i][k + 2] = v[i][k + 2] - p*r;                                  }                                  v[i][k] = v[i][k] - p;                                  v[i][k + 1] = v[i][k + 1] - p*q;                              }                          } // (s != 0)                      } // k loop                  } // check convergence              }
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: while (n >= low)              {                  // Look for single small sub-diagonal element                    int l = n;                  while (l > low)                  {                      s = Math.Abs(h[l - 1][l - 1]) + Math.Abs(h[l][l]);                      if (s == 0.0)                      {                          s = norm;                      }                      if (Math.Abs(h[l][l - 1]) < eps*s)                      {                          break;                      }                      l--;                  }                    // Check for convergence                  // One root found                    if (l == n)                  {                      h[n][n] = h[n][n] + exshift;                      d[n] = h[n][n];                      e[n] = 0.0;                      n--;                      iter = 0;                        // Two roots found                  }                  else if (l == n - 1)                  {                      w = h[n][n - 1]*h[n - 1][n];                      p = (h[n - 1][n - 1] - h[n][n])/2.0;                      q = p*p + w;                      z = Math.Sqrt(Math.Abs(q));                      h[n][n] = h[n][n] + exshift;                      h[n - 1][n - 1] = h[n - 1][n - 1] + exshift;                      x = h[n][n];                        // Real pair                        if (q >= 0)                      {                          if (p >= 0)                          {                              z = p + z;                          }                          else                          {                              z = p - z;                          }                          d[n - 1] = x + z;                          d[n] = d[n - 1];                          if (z != 0.0)                          {                              d[n] = x - w/z;                          }                          e[n - 1] = 0.0;                          e[n] = 0.0;                          x = h[n][n - 1];                          s = Math.Abs(x) + Math.Abs(z);                          p = x/s;                          q = z/s;                          r = Math.Sqrt(p*p + q*q);                          p = p/r;                          q = q/r;                            // Row modification                            for (int j = n - 1; j < nn; j++)                          {                              z = h[n - 1][j];                              h[n - 1][j] = q*z + p*h[n][j];                              h[n][j] = q*h[n][j] - p*z;                          }                            // Column modification                            for (int i = 0; i <= n; i++)                          {                              z = h[i][n - 1];                              h[i][n - 1] = q*z + p*h[i][n];                              h[i][n] = q*h[i][n] - p*z;                          }                            // Accumulate transformations                            for (int i = low; i <= high; i++)                          {                              z = v[i][n - 1];                              v[i][n - 1] = q*z + p*v[i][n];                              v[i][n] = q*v[i][n] - p*z;                          }                            // Complex pair                      }                      else                      {                          d[n - 1] = x + p;                          d[n] = x + p;                          e[n - 1] = z;                          e[n] = -z;                      }                      n = n - 2;                      iter = 0;                        // No convergence yet                  }                  else                  {                      // Form shift                        x = h[n][n];                      y = 0.0;                      w = 0.0;                      if (l < n)                      {                          y = h[n - 1][n - 1];                          w = h[n][n - 1]*h[n - 1][n];                      }                        // Wilkinson's original ad hoc shift                        if (iter == 10)                      {                          exshift += x;                          for (int i = low; i <= n; i++)                          {                              h[i][i] -= x;                          }                          s = Math.Abs(h[n][n - 1]) + Math.Abs(h[n - 1][n - 2]);                          x = y = 0.75*s;                          w = -0.4375*s*s;                      }                        // MATLAB's new ad hoc shift                        if (iter == 30)                      {                          s = (y - x)/2.0;                          s = s*s + w;                          if (s > 0)                          {                              s = Math.Sqrt(s);                              if (y < x)                              {                                  s = -s;                              }                              s = x - w/((y - x)/2.0 + s);                              for (int i = low; i <= n; i++)                              {                                  h[i][i] -= s;                              }                              exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1; // (Could check iteration count here.)                        // Look for two consecutive small sub-diagonal elements                        int m = n - 2;                      while (m >= l)                      {                          z = h[m][m];                          r = x - z;                          s = y - z;                          p = (r*s - w)/h[m + 1][m] + h[m][m + 1];                          q = h[m + 1][m + 1] - z - r - s;                          r = h[m + 2][m + 1];                          s = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                          p = p/s;                          q = q/s;                          r = r/s;                          if (m == l)                          {                              break;                          }                          if (Math.Abs(h[m][m - 1])*(Math.Abs(q) + Math.Abs(r)) < eps                              *(Math.Abs(p)*(Math.Abs(h[m - 1][m - 1])                                             + Math.Abs(z) + Math.Abs(h[m + 1][m + 1]))))                          {                              break;                          }                          m--;                      }                        for (int i = m + 2; i <= n; i++)                      {                          h[i][i - 2] = 0.0;                          if (i > m + 2)                          {                              h[i][i - 3] = 0.0;                          }                      }                        // Double QR step involving rows l:n and columns m:n                        for (int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                          if (k != m)                          {                              p = h[k][k - 1];                              q = h[k + 1][k - 1];                              r = (notlast ? h[k + 2][k - 1] : 0.0);                              x = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                              if (x != 0.0)                              {                                  p = p/x;                                  q = q/x;                                  r = r/x;                              }                          }                          if (x == 0.0)                          {                              break;                          }                          s = Math.Sqrt(p*p + q*q + r*r);                          if (p < 0)                          {                              s = -s;                          }                          if (s != 0)                          {                              if (k != m)                              {                                  h[k][k - 1] = -s*x;                              }                              else if (l != m)                              {                                  h[k][k - 1] = -h[k][k - 1];                              }                              p = p + s;                              x = p/s;                              y = q/s;                              z = r/s;                              q = q/p;                              r = r/p;                                // Row modification                                for (int j = k; j < nn; j++)                              {                                  p = h[k][j] + q*h[k + 1][j];                                  if (notlast)                                  {                                      p = p + r*h[k + 2][j];                                      h[k + 2][j] = h[k + 2][j] - p*z;                                  }                                  h[k][j] = h[k][j] - p*x;                                  h[k + 1][j] = h[k + 1][j] - p*y;                              }                                // Column modification                                for (int i = 0; i <= Math.Min(n' k + 3); i++)                              {                                  p = x*h[i][k] + y*h[i][k + 1];                                  if (notlast)                                  {                                      p = p + z*h[i][k + 2];                                      h[i][k + 2] = h[i][k + 2] - p*r;                                  }                                  h[i][k] = h[i][k] - p;                                  h[i][k + 1] = h[i][k + 1] - p*q;                              }                                // Accumulate transformations                                for (int i = low; i <= high; i++)                              {                                  p = x*v[i][k] + y*v[i][k + 1];                                  if (notlast)                                  {                                      p = p + z*v[i][k + 2];                                      v[i][k + 2] = v[i][k + 2] - p*r;                                  }                                  v[i][k] = v[i][k] - p;                                  v[i][k + 1] = v[i][k + 1] - p*q;                              }                          } // (s != 0)                      } // k loop                  } // check convergence              }
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: while (n >= low)              {                  // Look for single small sub-diagonal element                    int l = n;                  while (l > low)                  {                      s = Math.Abs(h[l - 1][l - 1]) + Math.Abs(h[l][l]);                      if (s == 0.0)                      {                          s = norm;                      }                      if (Math.Abs(h[l][l - 1]) < eps*s)                      {                          break;                      }                      l--;                  }                    // Check for convergence                  // One root found                    if (l == n)                  {                      h[n][n] = h[n][n] + exshift;                      d[n] = h[n][n];                      e[n] = 0.0;                      n--;                      iter = 0;                        // Two roots found                  }                  else if (l == n - 1)                  {                      w = h[n][n - 1]*h[n - 1][n];                      p = (h[n - 1][n - 1] - h[n][n])/2.0;                      q = p*p + w;                      z = Math.Sqrt(Math.Abs(q));                      h[n][n] = h[n][n] + exshift;                      h[n - 1][n - 1] = h[n - 1][n - 1] + exshift;                      x = h[n][n];                        // Real pair                        if (q >= 0)                      {                          if (p >= 0)                          {                              z = p + z;                          }                          else                          {                              z = p - z;                          }                          d[n - 1] = x + z;                          d[n] = d[n - 1];                          if (z != 0.0)                          {                              d[n] = x - w/z;                          }                          e[n - 1] = 0.0;                          e[n] = 0.0;                          x = h[n][n - 1];                          s = Math.Abs(x) + Math.Abs(z);                          p = x/s;                          q = z/s;                          r = Math.Sqrt(p*p + q*q);                          p = p/r;                          q = q/r;                            // Row modification                            for (int j = n - 1; j < nn; j++)                          {                              z = h[n - 1][j];                              h[n - 1][j] = q*z + p*h[n][j];                              h[n][j] = q*h[n][j] - p*z;                          }                            // Column modification                            for (int i = 0; i <= n; i++)                          {                              z = h[i][n - 1];                              h[i][n - 1] = q*z + p*h[i][n];                              h[i][n] = q*h[i][n] - p*z;                          }                            // Accumulate transformations                            for (int i = low; i <= high; i++)                          {                              z = v[i][n - 1];                              v[i][n - 1] = q*z + p*v[i][n];                              v[i][n] = q*v[i][n] - p*z;                          }                            // Complex pair                      }                      else                      {                          d[n - 1] = x + p;                          d[n] = x + p;                          e[n - 1] = z;                          e[n] = -z;                      }                      n = n - 2;                      iter = 0;                        // No convergence yet                  }                  else                  {                      // Form shift                        x = h[n][n];                      y = 0.0;                      w = 0.0;                      if (l < n)                      {                          y = h[n - 1][n - 1];                          w = h[n][n - 1]*h[n - 1][n];                      }                        // Wilkinson's original ad hoc shift                        if (iter == 10)                      {                          exshift += x;                          for (int i = low; i <= n; i++)                          {                              h[i][i] -= x;                          }                          s = Math.Abs(h[n][n - 1]) + Math.Abs(h[n - 1][n - 2]);                          x = y = 0.75*s;                          w = -0.4375*s*s;                      }                        // MATLAB's new ad hoc shift                        if (iter == 30)                      {                          s = (y - x)/2.0;                          s = s*s + w;                          if (s > 0)                          {                              s = Math.Sqrt(s);                              if (y < x)                              {                                  s = -s;                              }                              s = x - w/((y - x)/2.0 + s);                              for (int i = low; i <= n; i++)                              {                                  h[i][i] -= s;                              }                              exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1; // (Could check iteration count here.)                        // Look for two consecutive small sub-diagonal elements                        int m = n - 2;                      while (m >= l)                      {                          z = h[m][m];                          r = x - z;                          s = y - z;                          p = (r*s - w)/h[m + 1][m] + h[m][m + 1];                          q = h[m + 1][m + 1] - z - r - s;                          r = h[m + 2][m + 1];                          s = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                          p = p/s;                          q = q/s;                          r = r/s;                          if (m == l)                          {                              break;                          }                          if (Math.Abs(h[m][m - 1])*(Math.Abs(q) + Math.Abs(r)) < eps                              *(Math.Abs(p)*(Math.Abs(h[m - 1][m - 1])                                             + Math.Abs(z) + Math.Abs(h[m + 1][m + 1]))))                          {                              break;                          }                          m--;                      }                        for (int i = m + 2; i <= n; i++)                      {                          h[i][i - 2] = 0.0;                          if (i > m + 2)                          {                              h[i][i - 3] = 0.0;                          }                      }                        // Double QR step involving rows l:n and columns m:n                        for (int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                          if (k != m)                          {                              p = h[k][k - 1];                              q = h[k + 1][k - 1];                              r = (notlast ? h[k + 2][k - 1] : 0.0);                              x = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                              if (x != 0.0)                              {                                  p = p/x;                                  q = q/x;                                  r = r/x;                              }                          }                          if (x == 0.0)                          {                              break;                          }                          s = Math.Sqrt(p*p + q*q + r*r);                          if (p < 0)                          {                              s = -s;                          }                          if (s != 0)                          {                              if (k != m)                              {                                  h[k][k - 1] = -s*x;                              }                              else if (l != m)                              {                                  h[k][k - 1] = -h[k][k - 1];                              }                              p = p + s;                              x = p/s;                              y = q/s;                              z = r/s;                              q = q/p;                              r = r/p;                                // Row modification                                for (int j = k; j < nn; j++)                              {                                  p = h[k][j] + q*h[k + 1][j];                                  if (notlast)                                  {                                      p = p + r*h[k + 2][j];                                      h[k + 2][j] = h[k + 2][j] - p*z;                                  }                                  h[k][j] = h[k][j] - p*x;                                  h[k + 1][j] = h[k + 1][j] - p*y;                              }                                // Column modification                                for (int i = 0; i <= Math.Min(n' k + 3); i++)                              {                                  p = x*h[i][k] + y*h[i][k + 1];                                  if (notlast)                                  {                                      p = p + z*h[i][k + 2];                                      h[i][k + 2] = h[i][k + 2] - p*r;                                  }                                  h[i][k] = h[i][k] - p;                                  h[i][k + 1] = h[i][k + 1] - p*q;                              }                                // Accumulate transformations                                for (int i = low; i <= high; i++)                              {                                  p = x*v[i][k] + y*v[i][k + 1];                                  if (notlast)                                  {                                      p = p + z*v[i][k + 2];                                      v[i][k + 2] = v[i][k + 2] - p*r;                                  }                                  v[i][k] = v[i][k] - p;                                  v[i][k + 1] = v[i][k + 1] - p*q;                              }                          } // (s != 0)                      } // k loop                  } // check convergence              }
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: while (n >= low)              {                  // Look for single small sub-diagonal element                    int l = n;                  while (l > low)                  {                      s = Math.Abs(h[l - 1][l - 1]) + Math.Abs(h[l][l]);                      if (s == 0.0)                      {                          s = norm;                      }                      if (Math.Abs(h[l][l - 1]) < eps*s)                      {                          break;                      }                      l--;                  }                    // Check for convergence                  // One root found                    if (l == n)                  {                      h[n][n] = h[n][n] + exshift;                      d[n] = h[n][n];                      e[n] = 0.0;                      n--;                      iter = 0;                        // Two roots found                  }                  else if (l == n - 1)                  {                      w = h[n][n - 1]*h[n - 1][n];                      p = (h[n - 1][n - 1] - h[n][n])/2.0;                      q = p*p + w;                      z = Math.Sqrt(Math.Abs(q));                      h[n][n] = h[n][n] + exshift;                      h[n - 1][n - 1] = h[n - 1][n - 1] + exshift;                      x = h[n][n];                        // Real pair                        if (q >= 0)                      {                          if (p >= 0)                          {                              z = p + z;                          }                          else                          {                              z = p - z;                          }                          d[n - 1] = x + z;                          d[n] = d[n - 1];                          if (z != 0.0)                          {                              d[n] = x - w/z;                          }                          e[n - 1] = 0.0;                          e[n] = 0.0;                          x = h[n][n - 1];                          s = Math.Abs(x) + Math.Abs(z);                          p = x/s;                          q = z/s;                          r = Math.Sqrt(p*p + q*q);                          p = p/r;                          q = q/r;                            // Row modification                            for (int j = n - 1; j < nn; j++)                          {                              z = h[n - 1][j];                              h[n - 1][j] = q*z + p*h[n][j];                              h[n][j] = q*h[n][j] - p*z;                          }                            // Column modification                            for (int i = 0; i <= n; i++)                          {                              z = h[i][n - 1];                              h[i][n - 1] = q*z + p*h[i][n];                              h[i][n] = q*h[i][n] - p*z;                          }                            // Accumulate transformations                            for (int i = low; i <= high; i++)                          {                              z = v[i][n - 1];                              v[i][n - 1] = q*z + p*v[i][n];                              v[i][n] = q*v[i][n] - p*z;                          }                            // Complex pair                      }                      else                      {                          d[n - 1] = x + p;                          d[n] = x + p;                          e[n - 1] = z;                          e[n] = -z;                      }                      n = n - 2;                      iter = 0;                        // No convergence yet                  }                  else                  {                      // Form shift                        x = h[n][n];                      y = 0.0;                      w = 0.0;                      if (l < n)                      {                          y = h[n - 1][n - 1];                          w = h[n][n - 1]*h[n - 1][n];                      }                        // Wilkinson's original ad hoc shift                        if (iter == 10)                      {                          exshift += x;                          for (int i = low; i <= n; i++)                          {                              h[i][i] -= x;                          }                          s = Math.Abs(h[n][n - 1]) + Math.Abs(h[n - 1][n - 2]);                          x = y = 0.75*s;                          w = -0.4375*s*s;                      }                        // MATLAB's new ad hoc shift                        if (iter == 30)                      {                          s = (y - x)/2.0;                          s = s*s + w;                          if (s > 0)                          {                              s = Math.Sqrt(s);                              if (y < x)                              {                                  s = -s;                              }                              s = x - w/((y - x)/2.0 + s);                              for (int i = low; i <= n; i++)                              {                                  h[i][i] -= s;                              }                              exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1; // (Could check iteration count here.)                        // Look for two consecutive small sub-diagonal elements                        int m = n - 2;                      while (m >= l)                      {                          z = h[m][m];                          r = x - z;                          s = y - z;                          p = (r*s - w)/h[m + 1][m] + h[m][m + 1];                          q = h[m + 1][m + 1] - z - r - s;                          r = h[m + 2][m + 1];                          s = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                          p = p/s;                          q = q/s;                          r = r/s;                          if (m == l)                          {                              break;                          }                          if (Math.Abs(h[m][m - 1])*(Math.Abs(q) + Math.Abs(r)) < eps                              *(Math.Abs(p)*(Math.Abs(h[m - 1][m - 1])                                             + Math.Abs(z) + Math.Abs(h[m + 1][m + 1]))))                          {                              break;                          }                          m--;                      }                        for (int i = m + 2; i <= n; i++)                      {                          h[i][i - 2] = 0.0;                          if (i > m + 2)                          {                              h[i][i - 3] = 0.0;                          }                      }                        // Double QR step involving rows l:n and columns m:n                        for (int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                          if (k != m)                          {                              p = h[k][k - 1];                              q = h[k + 1][k - 1];                              r = (notlast ? h[k + 2][k - 1] : 0.0);                              x = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                              if (x != 0.0)                              {                                  p = p/x;                                  q = q/x;                                  r = r/x;                              }                          }                          if (x == 0.0)                          {                              break;                          }                          s = Math.Sqrt(p*p + q*q + r*r);                          if (p < 0)                          {                              s = -s;                          }                          if (s != 0)                          {                              if (k != m)                              {                                  h[k][k - 1] = -s*x;                              }                              else if (l != m)                              {                                  h[k][k - 1] = -h[k][k - 1];                              }                              p = p + s;                              x = p/s;                              y = q/s;                              z = r/s;                              q = q/p;                              r = r/p;                                // Row modification                                for (int j = k; j < nn; j++)                              {                                  p = h[k][j] + q*h[k + 1][j];                                  if (notlast)                                  {                                      p = p + r*h[k + 2][j];                                      h[k + 2][j] = h[k + 2][j] - p*z;                                  }                                  h[k][j] = h[k][j] - p*x;                                  h[k + 1][j] = h[k + 1][j] - p*y;                              }                                // Column modification                                for (int i = 0; i <= Math.Min(n' k + 3); i++)                              {                                  p = x*h[i][k] + y*h[i][k + 1];                                  if (notlast)                                  {                                      p = p + z*h[i][k + 2];                                      h[i][k + 2] = h[i][k + 2] - p*r;                                  }                                  h[i][k] = h[i][k] - p;                                  h[i][k + 1] = h[i][k + 1] - p*q;                              }                                // Accumulate transformations                                for (int i = low; i <= high; i++)                              {                                  p = x*v[i][k] + y*v[i][k + 1];                                  if (notlast)                                  {                                      p = p + z*v[i][k + 2];                                      v[i][k + 2] = v[i][k + 2] - p*r;                                  }                                  v[i][k] = v[i][k] - p;                                  v[i][k + 1] = v[i][k + 1] - p*q;                              }                          } // (s != 0)                      } // k loop                  } // check convergence              }
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: while (n >= low)              {                  // Look for single small sub-diagonal element                    int l = n;                  while (l > low)                  {                      s = Math.Abs(h[l - 1][l - 1]) + Math.Abs(h[l][l]);                      if (s == 0.0)                      {                          s = norm;                      }                      if (Math.Abs(h[l][l - 1]) < eps*s)                      {                          break;                      }                      l--;                  }                    // Check for convergence                  // One root found                    if (l == n)                  {                      h[n][n] = h[n][n] + exshift;                      d[n] = h[n][n];                      e[n] = 0.0;                      n--;                      iter = 0;                        // Two roots found                  }                  else if (l == n - 1)                  {                      w = h[n][n - 1]*h[n - 1][n];                      p = (h[n - 1][n - 1] - h[n][n])/2.0;                      q = p*p + w;                      z = Math.Sqrt(Math.Abs(q));                      h[n][n] = h[n][n] + exshift;                      h[n - 1][n - 1] = h[n - 1][n - 1] + exshift;                      x = h[n][n];                        // Real pair                        if (q >= 0)                      {                          if (p >= 0)                          {                              z = p + z;                          }                          else                          {                              z = p - z;                          }                          d[n - 1] = x + z;                          d[n] = d[n - 1];                          if (z != 0.0)                          {                              d[n] = x - w/z;                          }                          e[n - 1] = 0.0;                          e[n] = 0.0;                          x = h[n][n - 1];                          s = Math.Abs(x) + Math.Abs(z);                          p = x/s;                          q = z/s;                          r = Math.Sqrt(p*p + q*q);                          p = p/r;                          q = q/r;                            // Row modification                            for (int j = n - 1; j < nn; j++)                          {                              z = h[n - 1][j];                              h[n - 1][j] = q*z + p*h[n][j];                              h[n][j] = q*h[n][j] - p*z;                          }                            // Column modification                            for (int i = 0; i <= n; i++)                          {                              z = h[i][n - 1];                              h[i][n - 1] = q*z + p*h[i][n];                              h[i][n] = q*h[i][n] - p*z;                          }                            // Accumulate transformations                            for (int i = low; i <= high; i++)                          {                              z = v[i][n - 1];                              v[i][n - 1] = q*z + p*v[i][n];                              v[i][n] = q*v[i][n] - p*z;                          }                            // Complex pair                      }                      else                      {                          d[n - 1] = x + p;                          d[n] = x + p;                          e[n - 1] = z;                          e[n] = -z;                      }                      n = n - 2;                      iter = 0;                        // No convergence yet                  }                  else                  {                      // Form shift                        x = h[n][n];                      y = 0.0;                      w = 0.0;                      if (l < n)                      {                          y = h[n - 1][n - 1];                          w = h[n][n - 1]*h[n - 1][n];                      }                        // Wilkinson's original ad hoc shift                        if (iter == 10)                      {                          exshift += x;                          for (int i = low; i <= n; i++)                          {                              h[i][i] -= x;                          }                          s = Math.Abs(h[n][n - 1]) + Math.Abs(h[n - 1][n - 2]);                          x = y = 0.75*s;                          w = -0.4375*s*s;                      }                        // MATLAB's new ad hoc shift                        if (iter == 30)                      {                          s = (y - x)/2.0;                          s = s*s + w;                          if (s > 0)                          {                              s = Math.Sqrt(s);                              if (y < x)                              {                                  s = -s;                              }                              s = x - w/((y - x)/2.0 + s);                              for (int i = low; i <= n; i++)                              {                                  h[i][i] -= s;                              }                              exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1; // (Could check iteration count here.)                        // Look for two consecutive small sub-diagonal elements                        int m = n - 2;                      while (m >= l)                      {                          z = h[m][m];                          r = x - z;                          s = y - z;                          p = (r*s - w)/h[m + 1][m] + h[m][m + 1];                          q = h[m + 1][m + 1] - z - r - s;                          r = h[m + 2][m + 1];                          s = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                          p = p/s;                          q = q/s;                          r = r/s;                          if (m == l)                          {                              break;                          }                          if (Math.Abs(h[m][m - 1])*(Math.Abs(q) + Math.Abs(r)) < eps                              *(Math.Abs(p)*(Math.Abs(h[m - 1][m - 1])                                             + Math.Abs(z) + Math.Abs(h[m + 1][m + 1]))))                          {                              break;                          }                          m--;                      }                        for (int i = m + 2; i <= n; i++)                      {                          h[i][i - 2] = 0.0;                          if (i > m + 2)                          {                              h[i][i - 3] = 0.0;                          }                      }                        // Double QR step involving rows l:n and columns m:n                        for (int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                          if (k != m)                          {                              p = h[k][k - 1];                              q = h[k + 1][k - 1];                              r = (notlast ? h[k + 2][k - 1] : 0.0);                              x = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                              if (x != 0.0)                              {                                  p = p/x;                                  q = q/x;                                  r = r/x;                              }                          }                          if (x == 0.0)                          {                              break;                          }                          s = Math.Sqrt(p*p + q*q + r*r);                          if (p < 0)                          {                              s = -s;                          }                          if (s != 0)                          {                              if (k != m)                              {                                  h[k][k - 1] = -s*x;                              }                              else if (l != m)                              {                                  h[k][k - 1] = -h[k][k - 1];                              }                              p = p + s;                              x = p/s;                              y = q/s;                              z = r/s;                              q = q/p;                              r = r/p;                                // Row modification                                for (int j = k; j < nn; j++)                              {                                  p = h[k][j] + q*h[k + 1][j];                                  if (notlast)                                  {                                      p = p + r*h[k + 2][j];                                      h[k + 2][j] = h[k + 2][j] - p*z;                                  }                                  h[k][j] = h[k][j] - p*x;                                  h[k + 1][j] = h[k + 1][j] - p*y;                              }                                // Column modification                                for (int i = 0; i <= Math.Min(n' k + 3); i++)                              {                                  p = x*h[i][k] + y*h[i][k + 1];                                  if (notlast)                                  {                                      p = p + z*h[i][k + 2];                                      h[i][k + 2] = h[i][k + 2] - p*r;                                  }                                  h[i][k] = h[i][k] - p;                                  h[i][k + 1] = h[i][k + 1] - p*q;                              }                                // Accumulate transformations                                for (int i = low; i <= high; i++)                              {                                  p = x*v[i][k] + y*v[i][k + 1];                                  if (notlast)                                  {                                      p = p + z*v[i][k + 2];                                      v[i][k + 2] = v[i][k + 2] - p*r;                                  }                                  v[i][k] = v[i][k] - p;                                  v[i][k + 1] = v[i][k + 1] - p*q;                              }                          } // (s != 0)                      } // k loop                  } // check convergence              }
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: while (n >= low)              {                  // Look for single small sub-diagonal element                    int l = n;                  while (l > low)                  {                      s = Math.Abs(h[l - 1][l - 1]) + Math.Abs(h[l][l]);                      if (s == 0.0)                      {                          s = norm;                      }                      if (Math.Abs(h[l][l - 1]) < eps*s)                      {                          break;                      }                      l--;                  }                    // Check for convergence                  // One root found                    if (l == n)                  {                      h[n][n] = h[n][n] + exshift;                      d[n] = h[n][n];                      e[n] = 0.0;                      n--;                      iter = 0;                        // Two roots found                  }                  else if (l == n - 1)                  {                      w = h[n][n - 1]*h[n - 1][n];                      p = (h[n - 1][n - 1] - h[n][n])/2.0;                      q = p*p + w;                      z = Math.Sqrt(Math.Abs(q));                      h[n][n] = h[n][n] + exshift;                      h[n - 1][n - 1] = h[n - 1][n - 1] + exshift;                      x = h[n][n];                        // Real pair                        if (q >= 0)                      {                          if (p >= 0)                          {                              z = p + z;                          }                          else                          {                              z = p - z;                          }                          d[n - 1] = x + z;                          d[n] = d[n - 1];                          if (z != 0.0)                          {                              d[n] = x - w/z;                          }                          e[n - 1] = 0.0;                          e[n] = 0.0;                          x = h[n][n - 1];                          s = Math.Abs(x) + Math.Abs(z);                          p = x/s;                          q = z/s;                          r = Math.Sqrt(p*p + q*q);                          p = p/r;                          q = q/r;                            // Row modification                            for (int j = n - 1; j < nn; j++)                          {                              z = h[n - 1][j];                              h[n - 1][j] = q*z + p*h[n][j];                              h[n][j] = q*h[n][j] - p*z;                          }                            // Column modification                            for (int i = 0; i <= n; i++)                          {                              z = h[i][n - 1];                              h[i][n - 1] = q*z + p*h[i][n];                              h[i][n] = q*h[i][n] - p*z;                          }                            // Accumulate transformations                            for (int i = low; i <= high; i++)                          {                              z = v[i][n - 1];                              v[i][n - 1] = q*z + p*v[i][n];                              v[i][n] = q*v[i][n] - p*z;                          }                            // Complex pair                      }                      else                      {                          d[n - 1] = x + p;                          d[n] = x + p;                          e[n - 1] = z;                          e[n] = -z;                      }                      n = n - 2;                      iter = 0;                        // No convergence yet                  }                  else                  {                      // Form shift                        x = h[n][n];                      y = 0.0;                      w = 0.0;                      if (l < n)                      {                          y = h[n - 1][n - 1];                          w = h[n][n - 1]*h[n - 1][n];                      }                        // Wilkinson's original ad hoc shift                        if (iter == 10)                      {                          exshift += x;                          for (int i = low; i <= n; i++)                          {                              h[i][i] -= x;                          }                          s = Math.Abs(h[n][n - 1]) + Math.Abs(h[n - 1][n - 2]);                          x = y = 0.75*s;                          w = -0.4375*s*s;                      }                        // MATLAB's new ad hoc shift                        if (iter == 30)                      {                          s = (y - x)/2.0;                          s = s*s + w;                          if (s > 0)                          {                              s = Math.Sqrt(s);                              if (y < x)                              {                                  s = -s;                              }                              s = x - w/((y - x)/2.0 + s);                              for (int i = low; i <= n; i++)                              {                                  h[i][i] -= s;                              }                              exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1; // (Could check iteration count here.)                        // Look for two consecutive small sub-diagonal elements                        int m = n - 2;                      while (m >= l)                      {                          z = h[m][m];                          r = x - z;                          s = y - z;                          p = (r*s - w)/h[m + 1][m] + h[m][m + 1];                          q = h[m + 1][m + 1] - z - r - s;                          r = h[m + 2][m + 1];                          s = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                          p = p/s;                          q = q/s;                          r = r/s;                          if (m == l)                          {                              break;                          }                          if (Math.Abs(h[m][m - 1])*(Math.Abs(q) + Math.Abs(r)) < eps                              *(Math.Abs(p)*(Math.Abs(h[m - 1][m - 1])                                             + Math.Abs(z) + Math.Abs(h[m + 1][m + 1]))))                          {                              break;                          }                          m--;                      }                        for (int i = m + 2; i <= n; i++)                      {                          h[i][i - 2] = 0.0;                          if (i > m + 2)                          {                              h[i][i - 3] = 0.0;                          }                      }                        // Double QR step involving rows l:n and columns m:n                        for (int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                          if (k != m)                          {                              p = h[k][k - 1];                              q = h[k + 1][k - 1];                              r = (notlast ? h[k + 2][k - 1] : 0.0);                              x = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                              if (x != 0.0)                              {                                  p = p/x;                                  q = q/x;                                  r = r/x;                              }                          }                          if (x == 0.0)                          {                              break;                          }                          s = Math.Sqrt(p*p + q*q + r*r);                          if (p < 0)                          {                              s = -s;                          }                          if (s != 0)                          {                              if (k != m)                              {                                  h[k][k - 1] = -s*x;                              }                              else if (l != m)                              {                                  h[k][k - 1] = -h[k][k - 1];                              }                              p = p + s;                              x = p/s;                              y = q/s;                              z = r/s;                              q = q/p;                              r = r/p;                                // Row modification                                for (int j = k; j < nn; j++)                              {                                  p = h[k][j] + q*h[k + 1][j];                                  if (notlast)                                  {                                      p = p + r*h[k + 2][j];                                      h[k + 2][j] = h[k + 2][j] - p*z;                                  }                                  h[k][j] = h[k][j] - p*x;                                  h[k + 1][j] = h[k + 1][j] - p*y;                              }                                // Column modification                                for (int i = 0; i <= Math.Min(n' k + 3); i++)                              {                                  p = x*h[i][k] + y*h[i][k + 1];                                  if (notlast)                                  {                                      p = p + z*h[i][k + 2];                                      h[i][k + 2] = h[i][k + 2] - p*r;                                  }                                  h[i][k] = h[i][k] - p;                                  h[i][k + 1] = h[i][k + 1] - p*q;                              }                                // Accumulate transformations                                for (int i = low; i <= high; i++)                              {                                  p = x*v[i][k] + y*v[i][k + 1];                                  if (notlast)                                  {                                      p = p + z*v[i][k + 2];                                      v[i][k + 2] = v[i][k + 2] - p*r;                                  }                                  v[i][k] = v[i][k] - p;                                  v[i][k + 1] = v[i][k + 1] - p*q;                              }                          } // (s != 0)                      } // k loop                  } // check convergence              }
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: while (n >= low)              {                  // Look for single small sub-diagonal element                    int l = n;                  while (l > low)                  {                      s = Math.Abs(h[l - 1][l - 1]) + Math.Abs(h[l][l]);                      if (s == 0.0)                      {                          s = norm;                      }                      if (Math.Abs(h[l][l - 1]) < eps*s)                      {                          break;                      }                      l--;                  }                    // Check for convergence                  // One root found                    if (l == n)                  {                      h[n][n] = h[n][n] + exshift;                      d[n] = h[n][n];                      e[n] = 0.0;                      n--;                      iter = 0;                        // Two roots found                  }                  else if (l == n - 1)                  {                      w = h[n][n - 1]*h[n - 1][n];                      p = (h[n - 1][n - 1] - h[n][n])/2.0;                      q = p*p + w;                      z = Math.Sqrt(Math.Abs(q));                      h[n][n] = h[n][n] + exshift;                      h[n - 1][n - 1] = h[n - 1][n - 1] + exshift;                      x = h[n][n];                        // Real pair                        if (q >= 0)                      {                          if (p >= 0)                          {                              z = p + z;                          }                          else                          {                              z = p - z;                          }                          d[n - 1] = x + z;                          d[n] = d[n - 1];                          if (z != 0.0)                          {                              d[n] = x - w/z;                          }                          e[n - 1] = 0.0;                          e[n] = 0.0;                          x = h[n][n - 1];                          s = Math.Abs(x) + Math.Abs(z);                          p = x/s;                          q = z/s;                          r = Math.Sqrt(p*p + q*q);                          p = p/r;                          q = q/r;                            // Row modification                            for (int j = n - 1; j < nn; j++)                          {                              z = h[n - 1][j];                              h[n - 1][j] = q*z + p*h[n][j];                              h[n][j] = q*h[n][j] - p*z;                          }                            // Column modification                            for (int i = 0; i <= n; i++)                          {                              z = h[i][n - 1];                              h[i][n - 1] = q*z + p*h[i][n];                              h[i][n] = q*h[i][n] - p*z;                          }                            // Accumulate transformations                            for (int i = low; i <= high; i++)                          {                              z = v[i][n - 1];                              v[i][n - 1] = q*z + p*v[i][n];                              v[i][n] = q*v[i][n] - p*z;                          }                            // Complex pair                      }                      else                      {                          d[n - 1] = x + p;                          d[n] = x + p;                          e[n - 1] = z;                          e[n] = -z;                      }                      n = n - 2;                      iter = 0;                        // No convergence yet                  }                  else                  {                      // Form shift                        x = h[n][n];                      y = 0.0;                      w = 0.0;                      if (l < n)                      {                          y = h[n - 1][n - 1];                          w = h[n][n - 1]*h[n - 1][n];                      }                        // Wilkinson's original ad hoc shift                        if (iter == 10)                      {                          exshift += x;                          for (int i = low; i <= n; i++)                          {                              h[i][i] -= x;                          }                          s = Math.Abs(h[n][n - 1]) + Math.Abs(h[n - 1][n - 2]);                          x = y = 0.75*s;                          w = -0.4375*s*s;                      }                        // MATLAB's new ad hoc shift                        if (iter == 30)                      {                          s = (y - x)/2.0;                          s = s*s + w;                          if (s > 0)                          {                              s = Math.Sqrt(s);                              if (y < x)                              {                                  s = -s;                              }                              s = x - w/((y - x)/2.0 + s);                              for (int i = low; i <= n; i++)                              {                                  h[i][i] -= s;                              }                              exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1; // (Could check iteration count here.)                        // Look for two consecutive small sub-diagonal elements                        int m = n - 2;                      while (m >= l)                      {                          z = h[m][m];                          r = x - z;                          s = y - z;                          p = (r*s - w)/h[m + 1][m] + h[m][m + 1];                          q = h[m + 1][m + 1] - z - r - s;                          r = h[m + 2][m + 1];                          s = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                          p = p/s;                          q = q/s;                          r = r/s;                          if (m == l)                          {                              break;                          }                          if (Math.Abs(h[m][m - 1])*(Math.Abs(q) + Math.Abs(r)) < eps                              *(Math.Abs(p)*(Math.Abs(h[m - 1][m - 1])                                             + Math.Abs(z) + Math.Abs(h[m + 1][m + 1]))))                          {                              break;                          }                          m--;                      }                        for (int i = m + 2; i <= n; i++)                      {                          h[i][i - 2] = 0.0;                          if (i > m + 2)                          {                              h[i][i - 3] = 0.0;                          }                      }                        // Double QR step involving rows l:n and columns m:n                        for (int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                          if (k != m)                          {                              p = h[k][k - 1];                              q = h[k + 1][k - 1];                              r = (notlast ? h[k + 2][k - 1] : 0.0);                              x = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                              if (x != 0.0)                              {                                  p = p/x;                                  q = q/x;                                  r = r/x;                              }                          }                          if (x == 0.0)                          {                              break;                          }                          s = Math.Sqrt(p*p + q*q + r*r);                          if (p < 0)                          {                              s = -s;                          }                          if (s != 0)                          {                              if (k != m)                              {                                  h[k][k - 1] = -s*x;                              }                              else if (l != m)                              {                                  h[k][k - 1] = -h[k][k - 1];                              }                              p = p + s;                              x = p/s;                              y = q/s;                              z = r/s;                              q = q/p;                              r = r/p;                                // Row modification                                for (int j = k; j < nn; j++)                              {                                  p = h[k][j] + q*h[k + 1][j];                                  if (notlast)                                  {                                      p = p + r*h[k + 2][j];                                      h[k + 2][j] = h[k + 2][j] - p*z;                                  }                                  h[k][j] = h[k][j] - p*x;                                  h[k + 1][j] = h[k + 1][j] - p*y;                              }                                // Column modification                                for (int i = 0; i <= Math.Min(n' k + 3); i++)                              {                                  p = x*h[i][k] + y*h[i][k + 1];                                  if (notlast)                                  {                                      p = p + z*h[i][k + 2];                                      h[i][k + 2] = h[i][k + 2] - p*r;                                  }                                  h[i][k] = h[i][k] - p;                                  h[i][k + 1] = h[i][k + 1] - p*q;                              }                                // Accumulate transformations                                for (int i = low; i <= high; i++)                              {                                  p = x*v[i][k] + y*v[i][k + 1];                                  if (notlast)                                  {                                      p = p + z*v[i][k + 2];                                      v[i][k + 2] = v[i][k + 2] - p*r;                                  }                                  v[i][k] = v[i][k] - p;                                  v[i][k + 1] = v[i][k + 1] - p*q;                              }                          } // (s != 0)                      } // k loop                  } // check convergence              }
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: while (n >= low)              {                  // Look for single small sub-diagonal element                    int l = n;                  while (l > low)                  {                      s = Math.Abs(h[l - 1][l - 1]) + Math.Abs(h[l][l]);                      if (s == 0.0)                      {                          s = norm;                      }                      if (Math.Abs(h[l][l - 1]) < eps*s)                      {                          break;                      }                      l--;                  }                    // Check for convergence                  // One root found                    if (l == n)                  {                      h[n][n] = h[n][n] + exshift;                      d[n] = h[n][n];                      e[n] = 0.0;                      n--;                      iter = 0;                        // Two roots found                  }                  else if (l == n - 1)                  {                      w = h[n][n - 1]*h[n - 1][n];                      p = (h[n - 1][n - 1] - h[n][n])/2.0;                      q = p*p + w;                      z = Math.Sqrt(Math.Abs(q));                      h[n][n] = h[n][n] + exshift;                      h[n - 1][n - 1] = h[n - 1][n - 1] + exshift;                      x = h[n][n];                        // Real pair                        if (q >= 0)                      {                          if (p >= 0)                          {                              z = p + z;                          }                          else                          {                              z = p - z;                          }                          d[n - 1] = x + z;                          d[n] = d[n - 1];                          if (z != 0.0)                          {                              d[n] = x - w/z;                          }                          e[n - 1] = 0.0;                          e[n] = 0.0;                          x = h[n][n - 1];                          s = Math.Abs(x) + Math.Abs(z);                          p = x/s;                          q = z/s;                          r = Math.Sqrt(p*p + q*q);                          p = p/r;                          q = q/r;                            // Row modification                            for (int j = n - 1; j < nn; j++)                          {                              z = h[n - 1][j];                              h[n - 1][j] = q*z + p*h[n][j];                              h[n][j] = q*h[n][j] - p*z;                          }                            // Column modification                            for (int i = 0; i <= n; i++)                          {                              z = h[i][n - 1];                              h[i][n - 1] = q*z + p*h[i][n];                              h[i][n] = q*h[i][n] - p*z;                          }                            // Accumulate transformations                            for (int i = low; i <= high; i++)                          {                              z = v[i][n - 1];                              v[i][n - 1] = q*z + p*v[i][n];                              v[i][n] = q*v[i][n] - p*z;                          }                            // Complex pair                      }                      else                      {                          d[n - 1] = x + p;                          d[n] = x + p;                          e[n - 1] = z;                          e[n] = -z;                      }                      n = n - 2;                      iter = 0;                        // No convergence yet                  }                  else                  {                      // Form shift                        x = h[n][n];                      y = 0.0;                      w = 0.0;                      if (l < n)                      {                          y = h[n - 1][n - 1];                          w = h[n][n - 1]*h[n - 1][n];                      }                        // Wilkinson's original ad hoc shift                        if (iter == 10)                      {                          exshift += x;                          for (int i = low; i <= n; i++)                          {                              h[i][i] -= x;                          }                          s = Math.Abs(h[n][n - 1]) + Math.Abs(h[n - 1][n - 2]);                          x = y = 0.75*s;                          w = -0.4375*s*s;                      }                        // MATLAB's new ad hoc shift                        if (iter == 30)                      {                          s = (y - x)/2.0;                          s = s*s + w;                          if (s > 0)                          {                              s = Math.Sqrt(s);                              if (y < x)                              {                                  s = -s;                              }                              s = x - w/((y - x)/2.0 + s);                              for (int i = low; i <= n; i++)                              {                                  h[i][i] -= s;                              }                              exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1; // (Could check iteration count here.)                        // Look for two consecutive small sub-diagonal elements                        int m = n - 2;                      while (m >= l)                      {                          z = h[m][m];                          r = x - z;                          s = y - z;                          p = (r*s - w)/h[m + 1][m] + h[m][m + 1];                          q = h[m + 1][m + 1] - z - r - s;                          r = h[m + 2][m + 1];                          s = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                          p = p/s;                          q = q/s;                          r = r/s;                          if (m == l)                          {                              break;                          }                          if (Math.Abs(h[m][m - 1])*(Math.Abs(q) + Math.Abs(r)) < eps                              *(Math.Abs(p)*(Math.Abs(h[m - 1][m - 1])                                             + Math.Abs(z) + Math.Abs(h[m + 1][m + 1]))))                          {                              break;                          }                          m--;                      }                        for (int i = m + 2; i <= n; i++)                      {                          h[i][i - 2] = 0.0;                          if (i > m + 2)                          {                              h[i][i - 3] = 0.0;                          }                      }                        // Double QR step involving rows l:n and columns m:n                        for (int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                          if (k != m)                          {                              p = h[k][k - 1];                              q = h[k + 1][k - 1];                              r = (notlast ? h[k + 2][k - 1] : 0.0);                              x = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                              if (x != 0.0)                              {                                  p = p/x;                                  q = q/x;                                  r = r/x;                              }                          }                          if (x == 0.0)                          {                              break;                          }                          s = Math.Sqrt(p*p + q*q + r*r);                          if (p < 0)                          {                              s = -s;                          }                          if (s != 0)                          {                              if (k != m)                              {                                  h[k][k - 1] = -s*x;                              }                              else if (l != m)                              {                                  h[k][k - 1] = -h[k][k - 1];                              }                              p = p + s;                              x = p/s;                              y = q/s;                              z = r/s;                              q = q/p;                              r = r/p;                                // Row modification                                for (int j = k; j < nn; j++)                              {                                  p = h[k][j] + q*h[k + 1][j];                                  if (notlast)                                  {                                      p = p + r*h[k + 2][j];                                      h[k + 2][j] = h[k + 2][j] - p*z;                                  }                                  h[k][j] = h[k][j] - p*x;                                  h[k + 1][j] = h[k + 1][j] - p*y;                              }                                // Column modification                                for (int i = 0; i <= Math.Min(n' k + 3); i++)                              {                                  p = x*h[i][k] + y*h[i][k + 1];                                  if (notlast)                                  {                                      p = p + z*h[i][k + 2];                                      h[i][k + 2] = h[i][k + 2] - p*r;                                  }                                  h[i][k] = h[i][k] - p;                                  h[i][k + 1] = h[i][k + 1] - p*q;                              }                                // Accumulate transformations                                for (int i = low; i <= high; i++)                              {                                  p = x*v[i][k] + y*v[i][k + 1];                                  if (notlast)                                  {                                      p = p + z*v[i][k + 2];                                      v[i][k + 2] = v[i][k + 2] - p*r;                                  }                                  v[i][k] = v[i][k] - p;                                  v[i][k + 1] = v[i][k + 1] - p*q;                              }                          } // (s != 0)                      } // k loop                  } // check convergence              }
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: for (n = nn - 1; n >= 0; n--)              {                  p = d[n];                  q = e[n];                    // Real vector                    if (q == 0)                  {                      int l = n;                      h[n][n] = 1.0;                      for (int i = n - 1; i >= 0; i--)                      {                          w = h[i][i] - p;                          r = 0.0;                          for (int j = l; j <= n; j++)                          {                              r = r + h[i][j]*h[j][n];                          }                          if (e[i] < 0.0)                          {                              z = w;                              s = r;                          }                          else                          {                              l = i;                              if (e[i] == 0.0)                              {                                  if (w != 0.0)                                  {                                      h[i][n] = -r/w;                                  }                                  else                                  {                                      h[i][n] = -r/(eps*norm);                                  }                                    // Solve real equations                              }                              else                              {                                  x = h[i][i + 1];                                  y = h[i + 1][i];                                  q = (d[i] - p)*(d[i] - p) + e[i]*e[i];                                  t = (x*s - z*r)/q;                                  h[i][n] = t;                                  if (Math.Abs(x) > Math.Abs(z))                                  {                                      h[i + 1][n] = (-r - w*t)/x;                                  }                                  else                                  {                                      h[i + 1][n] = (-s - y*t)/z;                                  }                              }                                // Overflow control                                t = Math.Abs(h[i][n]);                              if ((eps*t)*t > 1)                              {                                  for (int j = i; j <= n; j++)                                  {                                      h[j][n] = h[j][n]/t;                                  }                              }                          }                      }                        // Complex vector                  }                  else if (q < 0)                  {                      int l = n - 1;                        // Last vector component imaginary so matrix is triangular                        if (Math.Abs(h[n][n - 1]) > Math.Abs(h[n - 1][n]))                      {                          h[n - 1][n - 1] = q/h[n][n - 1];                          h[n - 1][n] = -(h[n][n] - p)/h[n][n - 1];                      }                      else                      {                          cdiv(0.0' -h[n - 1][n]' h[n - 1][n - 1] - p' q);                          h[n - 1][n - 1] = cdivr;                          h[n - 1][n] = cdivi;                      }                      h[n][n - 1] = 0.0;                      h[n][n] = 1.0;                      for (int i = n - 2; i >= 0; i--)                      {                          double ra' sa' vr' vi;                          ra = 0.0;                          sa = 0.0;                          for (int j = l; j <= n; j++)                          {                              ra = ra + h[i][j]*h[j][n - 1];                              sa = sa + h[i][j]*h[j][n];                          }                          w = h[i][i] - p;                            if (e[i] < 0.0)                          {                              z = w;                              r = ra;                              s = sa;                          }                          else                          {                              l = i;                              if (e[i] == 0)                              {                                  cdiv(-ra' -sa' w' q);                                  h[i][n - 1] = cdivr;                                  h[i][n] = cdivi;                              }                              else                              {                                  // Solve complex equations                                    x = h[i][i + 1];                                  y = h[i + 1][i];                                  vr = (d[i] - p)*(d[i] - p) + e[i]*e[i] - q*q;                                  vi = (d[i] - p)*2.0*q;                                  if (vr == 0.0 & vi == 0.0)                                  {                                      vr = eps                                           *norm                                           *(Math.Abs(w) + Math.Abs(q)                                             + Math.Abs(x) + Math.Abs(y) + Math                                                                               .Abs(z));                                  }                                  cdiv(x*r - z*ra + q*sa' x*s - z*sa - q                                                          *ra' vr' vi);                                  h[i][n - 1] = cdivr;                                  h[i][n] = cdivi;                                  if (Math.Abs(x) > (Math.Abs(z) + Math.Abs(q)))                                  {                                      h[i + 1][n - 1] = (-ra - w*h[i][n - 1] + q                                                         *h[i][n])                                                        /x;                                      h[i + 1][n] = (-sa - w*h[i][n] - q                                                     *h[i][n - 1])                                                    /x;                                  }                                  else                                  {                                      cdiv(-r - y*h[i][n - 1]' -s - y*h[i][n]' z'                                           q);                                      h[i + 1][n - 1] = cdivr;                                      h[i + 1][n] = cdivi;                                  }                              }                                // Overflow control                                t = Math.Max(Math.Abs(h[i][n - 1])' Math.Abs(h[i][n]));                              if ((eps*t)*t > 1)                              {                                  for (int j = i; j <= n; j++)                                  {                                      h[j][n - 1] = h[j][n - 1]/t;                                      h[j][n] = h[j][n]/t;                                  }                              }                          }                      }                  }              }
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: for (n = nn - 1; n >= 0; n--)              {                  p = d[n];                  q = e[n];                    // Real vector                    if (q == 0)                  {                      int l = n;                      h[n][n] = 1.0;                      for (int i = n - 1; i >= 0; i--)                      {                          w = h[i][i] - p;                          r = 0.0;                          for (int j = l; j <= n; j++)                          {                              r = r + h[i][j]*h[j][n];                          }                          if (e[i] < 0.0)                          {                              z = w;                              s = r;                          }                          else                          {                              l = i;                              if (e[i] == 0.0)                              {                                  if (w != 0.0)                                  {                                      h[i][n] = -r/w;                                  }                                  else                                  {                                      h[i][n] = -r/(eps*norm);                                  }                                    // Solve real equations                              }                              else                              {                                  x = h[i][i + 1];                                  y = h[i + 1][i];                                  q = (d[i] - p)*(d[i] - p) + e[i]*e[i];                                  t = (x*s - z*r)/q;                                  h[i][n] = t;                                  if (Math.Abs(x) > Math.Abs(z))                                  {                                      h[i + 1][n] = (-r - w*t)/x;                                  }                                  else                                  {                                      h[i + 1][n] = (-s - y*t)/z;                                  }                              }                                // Overflow control                                t = Math.Abs(h[i][n]);                              if ((eps*t)*t > 1)                              {                                  for (int j = i; j <= n; j++)                                  {                                      h[j][n] = h[j][n]/t;                                  }                              }                          }                      }                        // Complex vector                  }                  else if (q < 0)                  {                      int l = n - 1;                        // Last vector component imaginary so matrix is triangular                        if (Math.Abs(h[n][n - 1]) > Math.Abs(h[n - 1][n]))                      {                          h[n - 1][n - 1] = q/h[n][n - 1];                          h[n - 1][n] = -(h[n][n] - p)/h[n][n - 1];                      }                      else                      {                          cdiv(0.0' -h[n - 1][n]' h[n - 1][n - 1] - p' q);                          h[n - 1][n - 1] = cdivr;                          h[n - 1][n] = cdivi;                      }                      h[n][n - 1] = 0.0;                      h[n][n] = 1.0;                      for (int i = n - 2; i >= 0; i--)                      {                          double ra' sa' vr' vi;                          ra = 0.0;                          sa = 0.0;                          for (int j = l; j <= n; j++)                          {                              ra = ra + h[i][j]*h[j][n - 1];                              sa = sa + h[i][j]*h[j][n];                          }                          w = h[i][i] - p;                            if (e[i] < 0.0)                          {                              z = w;                              r = ra;                              s = sa;                          }                          else                          {                              l = i;                              if (e[i] == 0)                              {                                  cdiv(-ra' -sa' w' q);                                  h[i][n - 1] = cdivr;                                  h[i][n] = cdivi;                              }                              else                              {                                  // Solve complex equations                                    x = h[i][i + 1];                                  y = h[i + 1][i];                                  vr = (d[i] - p)*(d[i] - p) + e[i]*e[i] - q*q;                                  vi = (d[i] - p)*2.0*q;                                  if (vr == 0.0 & vi == 0.0)                                  {                                      vr = eps                                           *norm                                           *(Math.Abs(w) + Math.Abs(q)                                             + Math.Abs(x) + Math.Abs(y) + Math                                                                               .Abs(z));                                  }                                  cdiv(x*r - z*ra + q*sa' x*s - z*sa - q                                                          *ra' vr' vi);                                  h[i][n - 1] = cdivr;                                  h[i][n] = cdivi;                                  if (Math.Abs(x) > (Math.Abs(z) + Math.Abs(q)))                                  {                                      h[i + 1][n - 1] = (-ra - w*h[i][n - 1] + q                                                         *h[i][n])                                                        /x;                                      h[i + 1][n] = (-sa - w*h[i][n] - q                                                     *h[i][n - 1])                                                    /x;                                  }                                  else                                  {                                      cdiv(-r - y*h[i][n - 1]' -s - y*h[i][n]' z'                                           q);                                      h[i + 1][n - 1] = cdivr;                                      h[i + 1][n] = cdivi;                                  }                              }                                // Overflow control                                t = Math.Max(Math.Abs(h[i][n - 1])' Math.Abs(h[i][n]));                              if ((eps*t)*t > 1)                              {                                  for (int j = i; j <= n; j++)                                  {                                      h[j][n - 1] = h[j][n - 1]/t;                                      h[j][n] = h[j][n]/t;                                  }                              }                          }                      }                  }              }
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: int nrt = Math.Max(0' Math.Min(n - 2' m));
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: double eps = Math.Pow(2.0' -52.0);
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: double eps = Math.Pow(2.0' -52.0);
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: double tiny = Math.Pow(2.0' -966.0);
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: double tiny = Math.Pow(2.0' -966.0);
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0)              {                  int k' kase;                    // Here is where a test for too many iterations would go.                    // This section of the program inspects for                  // negligible elements in the s and e arrays. On                  // completion the variables kase and k are set as follows.                    // kase = 1 if s(p) and e[k-1] are negligible and k<p                  // kase = 2 if s(k) is negligible and k<p                  // kase = 3 if e[k-1] is negligible' k<p' and                  // s(k)' ...' s(p) are not negligible (qr step).                  // kase = 4 if e(p-1) is negligible (convergence).                    for (k = p - 2; k >= -1; k--)                  {                      if (k == -1)                      {                          break;                      }                      if (Math.Abs(e[k]) <= tiny + eps                          *(Math.Abs(s[k]) + Math.Abs(s[k + 1])))                      {                          e[k] = 0.0;                          break;                      }                  }                  if (k == p - 2)                  {                      kase = 4;                  }                  else                  {                      int ks;                      for (ks = p - 1; ks >= k; ks--)                      {                          if (ks == k)                          {                              break;                          }                          double t = (ks != p ? Math.Abs(e[ks]) : 0.0)                                     + (ks != k + 1 ? Math.Abs(e[ks - 1]) : 0.0);                          if (Math.Abs(s[ks]) <= tiny + eps*t)                          {                              s[ks] = 0.0;                              break;                          }                      }                      if (ks == k)                      {                          kase = 3;                      }                      else if (ks == p - 1)                      {                          kase = 1;                      }                      else                      {                          kase = 2;                          k = ks;                      }                  }                  k++;                    // Perform the task indicated by kase.                    switch (kase)                  {                          // Deflate negligible s(p).                        case 1:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for (int j = p - 2; j >= k; j--)                              {                                  double t = EncogMath.Hypot(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  if (j != k)                                  {                                      f = -sn*e[j - 1];                                      e[j - 1] = cs*e[j - 1];                                  }                                  if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*vmatrix[i][j] + sn*vmatrix[i][p - 1];                                          vmatrix[i][p - 1] = -sn*vmatrix[i][j] + cs*vmatrix[i][p - 1];                                          vmatrix[i][j] = t;                                      }                                  }                              }                          }                          break;                            // Split at negligible s(k).                        case 2:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for (int j = k; j < p; j++)                              {                                  double t = EncogMath.Hypot(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  f = -sn*e[j];                                  e[j] = cs*e[j];                                  if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*umatrix[i][j] + sn*umatrix[i][k - 1];                                          umatrix[i][k - 1] = -sn*umatrix[i][j] + cs*umatrix[i][k - 1];                                          umatrix[i][j] = t;                                      }                                  }                              }                          }                          break;                            // Perform one qr step.                        case 3:                          {                              // Calculate the shift.                                double scale = Math.Max(Math.Max(Math                                                                   .Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))'                                                                        Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math                                                                                                                  .Abs(                                                                                                                      e[k]));                              double sp = s[p - 1]/scale;                              double spm1 = s[p - 2]/scale;                              double epm1 = e[p - 2]/scale;                              double sk = s[k]/scale;                              double ek = e[k]/scale;                              double b = ((spm1 + sp)*(spm1 - sp) + epm1*epm1)/2.0;                              double c = (sp*epm1)*(sp*epm1);                              double shift = 0.0;                              if ((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt(b*b + c);                                  if (b < 0.0)                                  {                                      shift = -shift;                                  }                                  shift = c/(b + shift);                              }                              double f = (sk + sp)*(sk - sp) + shift;                              double g = sk*ek;                                // Chase zeros.                                for (int j = k; j < p - 1; j++)                              {                                  double t = EncogMath.Hypot(f' g);                                  double cs = f/t;                                  double sn = g/t;                                  if (j != k)                                  {                                      e[j - 1] = t;                                  }                                  f = cs*s[j] + sn*e[j];                                  e[j] = cs*e[j] - sn*s[j];                                  g = sn*s[j + 1];                                  s[j + 1] = cs*s[j + 1];                                  if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*vmatrix[i][j] + sn*vmatrix[i][j + 1];                                          vmatrix[i][j + 1] = -sn*vmatrix[i][j] + cs*vmatrix[i][j + 1];                                          vmatrix[i][j] = t;                                      }                                  }                                  t = EncogMath.Hypot(f' g);                                  cs = f/t;                                  sn = g/t;                                  s[j] = t;                                  f = cs*e[j] + sn*s[j + 1];                                  s[j + 1] = -sn*e[j] + cs*s[j + 1];                                  g = sn*e[j + 1];                                  e[j + 1] = cs*e[j + 1];                                  if (wantu && (j < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*umatrix[i][j] + sn*umatrix[i][j + 1];                                          umatrix[i][j + 1] = -sn*umatrix[i][j] + cs*umatrix[i][j + 1];                                          umatrix[i][j] = t;                                      }                                  }                              }                              e[p - 2] = f;                              iter = iter + 1;                          }                          break;                            // Convergence.                        case 4:                          {                              // Make the singular values positive.                                if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                  if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                      {                                          vmatrix[i][k] = -vmatrix[i][k];                                      }                                  }                              }                                // Order the singular values.                                while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                  {                                      break;                                  }                                  double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                  if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = vmatrix[i][k + 1];                                          vmatrix[i][k + 1] = vmatrix[i][k];                                          vmatrix[i][k] = t;                                      }                                  }                                  if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = umatrix[i][k + 1];                                          umatrix[i][k + 1] = umatrix[i][k];                                          umatrix[i][k] = t;                                      }                                  }                                  k++;                              }                              iter = 0;                              p--;                          }                          break;                  }              }
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0)              {                  int k' kase;                    // Here is where a test for too many iterations would go.                    // This section of the program inspects for                  // negligible elements in the s and e arrays. On                  // completion the variables kase and k are set as follows.                    // kase = 1 if s(p) and e[k-1] are negligible and k<p                  // kase = 2 if s(k) is negligible and k<p                  // kase = 3 if e[k-1] is negligible' k<p' and                  // s(k)' ...' s(p) are not negligible (qr step).                  // kase = 4 if e(p-1) is negligible (convergence).                    for (k = p - 2; k >= -1; k--)                  {                      if (k == -1)                      {                          break;                      }                      if (Math.Abs(e[k]) <= tiny + eps                          *(Math.Abs(s[k]) + Math.Abs(s[k + 1])))                      {                          e[k] = 0.0;                          break;                      }                  }                  if (k == p - 2)                  {                      kase = 4;                  }                  else                  {                      int ks;                      for (ks = p - 1; ks >= k; ks--)                      {                          if (ks == k)                          {                              break;                          }                          double t = (ks != p ? Math.Abs(e[ks]) : 0.0)                                     + (ks != k + 1 ? Math.Abs(e[ks - 1]) : 0.0);                          if (Math.Abs(s[ks]) <= tiny + eps*t)                          {                              s[ks] = 0.0;                              break;                          }                      }                      if (ks == k)                      {                          kase = 3;                      }                      else if (ks == p - 1)                      {                          kase = 1;                      }                      else                      {                          kase = 2;                          k = ks;                      }                  }                  k++;                    // Perform the task indicated by kase.                    switch (kase)                  {                          // Deflate negligible s(p).                        case 1:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for (int j = p - 2; j >= k; j--)                              {                                  double t = EncogMath.Hypot(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  if (j != k)                                  {                                      f = -sn*e[j - 1];                                      e[j - 1] = cs*e[j - 1];                                  }                                  if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*vmatrix[i][j] + sn*vmatrix[i][p - 1];                                          vmatrix[i][p - 1] = -sn*vmatrix[i][j] + cs*vmatrix[i][p - 1];                                          vmatrix[i][j] = t;                                      }                                  }                              }                          }                          break;                            // Split at negligible s(k).                        case 2:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for (int j = k; j < p; j++)                              {                                  double t = EncogMath.Hypot(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  f = -sn*e[j];                                  e[j] = cs*e[j];                                  if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*umatrix[i][j] + sn*umatrix[i][k - 1];                                          umatrix[i][k - 1] = -sn*umatrix[i][j] + cs*umatrix[i][k - 1];                                          umatrix[i][j] = t;                                      }                                  }                              }                          }                          break;                            // Perform one qr step.                        case 3:                          {                              // Calculate the shift.                                double scale = Math.Max(Math.Max(Math                                                                   .Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))'                                                                        Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math                                                                                                                  .Abs(                                                                                                                      e[k]));                              double sp = s[p - 1]/scale;                              double spm1 = s[p - 2]/scale;                              double epm1 = e[p - 2]/scale;                              double sk = s[k]/scale;                              double ek = e[k]/scale;                              double b = ((spm1 + sp)*(spm1 - sp) + epm1*epm1)/2.0;                              double c = (sp*epm1)*(sp*epm1);                              double shift = 0.0;                              if ((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt(b*b + c);                                  if (b < 0.0)                                  {                                      shift = -shift;                                  }                                  shift = c/(b + shift);                              }                              double f = (sk + sp)*(sk - sp) + shift;                              double g = sk*ek;                                // Chase zeros.                                for (int j = k; j < p - 1; j++)                              {                                  double t = EncogMath.Hypot(f' g);                                  double cs = f/t;                                  double sn = g/t;                                  if (j != k)                                  {                                      e[j - 1] = t;                                  }                                  f = cs*s[j] + sn*e[j];                                  e[j] = cs*e[j] - sn*s[j];                                  g = sn*s[j + 1];                                  s[j + 1] = cs*s[j + 1];                                  if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*vmatrix[i][j] + sn*vmatrix[i][j + 1];                                          vmatrix[i][j + 1] = -sn*vmatrix[i][j] + cs*vmatrix[i][j + 1];                                          vmatrix[i][j] = t;                                      }                                  }                                  t = EncogMath.Hypot(f' g);                                  cs = f/t;                                  sn = g/t;                                  s[j] = t;                                  f = cs*e[j] + sn*s[j + 1];                                  s[j + 1] = -sn*e[j] + cs*s[j + 1];                                  g = sn*e[j + 1];                                  e[j + 1] = cs*e[j + 1];                                  if (wantu && (j < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*umatrix[i][j] + sn*umatrix[i][j + 1];                                          umatrix[i][j + 1] = -sn*umatrix[i][j] + cs*umatrix[i][j + 1];                                          umatrix[i][j] = t;                                      }                                  }                              }                              e[p - 2] = f;                              iter = iter + 1;                          }                          break;                            // Convergence.                        case 4:                          {                              // Make the singular values positive.                                if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                  if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                      {                                          vmatrix[i][k] = -vmatrix[i][k];                                      }                                  }                              }                                // Order the singular values.                                while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                  {                                      break;                                  }                                  double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                  if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = vmatrix[i][k + 1];                                          vmatrix[i][k + 1] = vmatrix[i][k];                                          vmatrix[i][k] = t;                                      }                                  }                                  if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = umatrix[i][k + 1];                                          umatrix[i][k + 1] = umatrix[i][k];                                          umatrix[i][k] = t;                                      }                                  }                                  k++;                              }                              iter = 0;                              p--;                          }                          break;                  }              }
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0)              {                  int k' kase;                    // Here is where a test for too many iterations would go.                    // This section of the program inspects for                  // negligible elements in the s and e arrays. On                  // completion the variables kase and k are set as follows.                    // kase = 1 if s(p) and e[k-1] are negligible and k<p                  // kase = 2 if s(k) is negligible and k<p                  // kase = 3 if e[k-1] is negligible' k<p' and                  // s(k)' ...' s(p) are not negligible (qr step).                  // kase = 4 if e(p-1) is negligible (convergence).                    for (k = p - 2; k >= -1; k--)                  {                      if (k == -1)                      {                          break;                      }                      if (Math.Abs(e[k]) <= tiny + eps                          *(Math.Abs(s[k]) + Math.Abs(s[k + 1])))                      {                          e[k] = 0.0;                          break;                      }                  }                  if (k == p - 2)                  {                      kase = 4;                  }                  else                  {                      int ks;                      for (ks = p - 1; ks >= k; ks--)                      {                          if (ks == k)                          {                              break;                          }                          double t = (ks != p ? Math.Abs(e[ks]) : 0.0)                                     + (ks != k + 1 ? Math.Abs(e[ks - 1]) : 0.0);                          if (Math.Abs(s[ks]) <= tiny + eps*t)                          {                              s[ks] = 0.0;                              break;                          }                      }                      if (ks == k)                      {                          kase = 3;                      }                      else if (ks == p - 1)                      {                          kase = 1;                      }                      else                      {                          kase = 2;                          k = ks;                      }                  }                  k++;                    // Perform the task indicated by kase.                    switch (kase)                  {                          // Deflate negligible s(p).                        case 1:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for (int j = p - 2; j >= k; j--)                              {                                  double t = EncogMath.Hypot(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  if (j != k)                                  {                                      f = -sn*e[j - 1];                                      e[j - 1] = cs*e[j - 1];                                  }                                  if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*vmatrix[i][j] + sn*vmatrix[i][p - 1];                                          vmatrix[i][p - 1] = -sn*vmatrix[i][j] + cs*vmatrix[i][p - 1];                                          vmatrix[i][j] = t;                                      }                                  }                              }                          }                          break;                            // Split at negligible s(k).                        case 2:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for (int j = k; j < p; j++)                              {                                  double t = EncogMath.Hypot(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  f = -sn*e[j];                                  e[j] = cs*e[j];                                  if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*umatrix[i][j] + sn*umatrix[i][k - 1];                                          umatrix[i][k - 1] = -sn*umatrix[i][j] + cs*umatrix[i][k - 1];                                          umatrix[i][j] = t;                                      }                                  }                              }                          }                          break;                            // Perform one qr step.                        case 3:                          {                              // Calculate the shift.                                double scale = Math.Max(Math.Max(Math                                                                   .Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))'                                                                        Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math                                                                                                                  .Abs(                                                                                                                      e[k]));                              double sp = s[p - 1]/scale;                              double spm1 = s[p - 2]/scale;                              double epm1 = e[p - 2]/scale;                              double sk = s[k]/scale;                              double ek = e[k]/scale;                              double b = ((spm1 + sp)*(spm1 - sp) + epm1*epm1)/2.0;                              double c = (sp*epm1)*(sp*epm1);                              double shift = 0.0;                              if ((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt(b*b + c);                                  if (b < 0.0)                                  {                                      shift = -shift;                                  }                                  shift = c/(b + shift);                              }                              double f = (sk + sp)*(sk - sp) + shift;                              double g = sk*ek;                                // Chase zeros.                                for (int j = k; j < p - 1; j++)                              {                                  double t = EncogMath.Hypot(f' g);                                  double cs = f/t;                                  double sn = g/t;                                  if (j != k)                                  {                                      e[j - 1] = t;                                  }                                  f = cs*s[j] + sn*e[j];                                  e[j] = cs*e[j] - sn*s[j];                                  g = sn*s[j + 1];                                  s[j + 1] = cs*s[j + 1];                                  if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*vmatrix[i][j] + sn*vmatrix[i][j + 1];                                          vmatrix[i][j + 1] = -sn*vmatrix[i][j] + cs*vmatrix[i][j + 1];                                          vmatrix[i][j] = t;                                      }                                  }                                  t = EncogMath.Hypot(f' g);                                  cs = f/t;                                  sn = g/t;                                  s[j] = t;                                  f = cs*e[j] + sn*s[j + 1];                                  s[j + 1] = -sn*e[j] + cs*s[j + 1];                                  g = sn*e[j + 1];                                  e[j + 1] = cs*e[j + 1];                                  if (wantu && (j < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*umatrix[i][j] + sn*umatrix[i][j + 1];                                          umatrix[i][j + 1] = -sn*umatrix[i][j] + cs*umatrix[i][j + 1];                                          umatrix[i][j] = t;                                      }                                  }                              }                              e[p - 2] = f;                              iter = iter + 1;                          }                          break;                            // Convergence.                        case 4:                          {                              // Make the singular values positive.                                if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                  if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                      {                                          vmatrix[i][k] = -vmatrix[i][k];                                      }                                  }                              }                                // Order the singular values.                                while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                  {                                      break;                                  }                                  double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                  if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = vmatrix[i][k + 1];                                          vmatrix[i][k + 1] = vmatrix[i][k];                                          vmatrix[i][k] = t;                                      }                                  }                                  if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = umatrix[i][k + 1];                                          umatrix[i][k + 1] = umatrix[i][k];                                          umatrix[i][k] = t;                                      }                                  }                                  k++;                              }                              iter = 0;                              p--;                          }                          break;                  }              }
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0)              {                  int k' kase;                    // Here is where a test for too many iterations would go.                    // This section of the program inspects for                  // negligible elements in the s and e arrays. On                  // completion the variables kase and k are set as follows.                    // kase = 1 if s(p) and e[k-1] are negligible and k<p                  // kase = 2 if s(k) is negligible and k<p                  // kase = 3 if e[k-1] is negligible' k<p' and                  // s(k)' ...' s(p) are not negligible (qr step).                  // kase = 4 if e(p-1) is negligible (convergence).                    for (k = p - 2; k >= -1; k--)                  {                      if (k == -1)                      {                          break;                      }                      if (Math.Abs(e[k]) <= tiny + eps                          *(Math.Abs(s[k]) + Math.Abs(s[k + 1])))                      {                          e[k] = 0.0;                          break;                      }                  }                  if (k == p - 2)                  {                      kase = 4;                  }                  else                  {                      int ks;                      for (ks = p - 1; ks >= k; ks--)                      {                          if (ks == k)                          {                              break;                          }                          double t = (ks != p ? Math.Abs(e[ks]) : 0.0)                                     + (ks != k + 1 ? Math.Abs(e[ks - 1]) : 0.0);                          if (Math.Abs(s[ks]) <= tiny + eps*t)                          {                              s[ks] = 0.0;                              break;                          }                      }                      if (ks == k)                      {                          kase = 3;                      }                      else if (ks == p - 1)                      {                          kase = 1;                      }                      else                      {                          kase = 2;                          k = ks;                      }                  }                  k++;                    // Perform the task indicated by kase.                    switch (kase)                  {                          // Deflate negligible s(p).                        case 1:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for (int j = p - 2; j >= k; j--)                              {                                  double t = EncogMath.Hypot(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  if (j != k)                                  {                                      f = -sn*e[j - 1];                                      e[j - 1] = cs*e[j - 1];                                  }                                  if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*vmatrix[i][j] + sn*vmatrix[i][p - 1];                                          vmatrix[i][p - 1] = -sn*vmatrix[i][j] + cs*vmatrix[i][p - 1];                                          vmatrix[i][j] = t;                                      }                                  }                              }                          }                          break;                            // Split at negligible s(k).                        case 2:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for (int j = k; j < p; j++)                              {                                  double t = EncogMath.Hypot(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  f = -sn*e[j];                                  e[j] = cs*e[j];                                  if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*umatrix[i][j] + sn*umatrix[i][k - 1];                                          umatrix[i][k - 1] = -sn*umatrix[i][j] + cs*umatrix[i][k - 1];                                          umatrix[i][j] = t;                                      }                                  }                              }                          }                          break;                            // Perform one qr step.                        case 3:                          {                              // Calculate the shift.                                double scale = Math.Max(Math.Max(Math                                                                   .Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))'                                                                        Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math                                                                                                                  .Abs(                                                                                                                      e[k]));                              double sp = s[p - 1]/scale;                              double spm1 = s[p - 2]/scale;                              double epm1 = e[p - 2]/scale;                              double sk = s[k]/scale;                              double ek = e[k]/scale;                              double b = ((spm1 + sp)*(spm1 - sp) + epm1*epm1)/2.0;                              double c = (sp*epm1)*(sp*epm1);                              double shift = 0.0;                              if ((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt(b*b + c);                                  if (b < 0.0)                                  {                                      shift = -shift;                                  }                                  shift = c/(b + shift);                              }                              double f = (sk + sp)*(sk - sp) + shift;                              double g = sk*ek;                                // Chase zeros.                                for (int j = k; j < p - 1; j++)                              {                                  double t = EncogMath.Hypot(f' g);                                  double cs = f/t;                                  double sn = g/t;                                  if (j != k)                                  {                                      e[j - 1] = t;                                  }                                  f = cs*s[j] + sn*e[j];                                  e[j] = cs*e[j] - sn*s[j];                                  g = sn*s[j + 1];                                  s[j + 1] = cs*s[j + 1];                                  if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*vmatrix[i][j] + sn*vmatrix[i][j + 1];                                          vmatrix[i][j + 1] = -sn*vmatrix[i][j] + cs*vmatrix[i][j + 1];                                          vmatrix[i][j] = t;                                      }                                  }                                  t = EncogMath.Hypot(f' g);                                  cs = f/t;                                  sn = g/t;                                  s[j] = t;                                  f = cs*e[j] + sn*s[j + 1];                                  s[j + 1] = -sn*e[j] + cs*s[j + 1];                                  g = sn*e[j + 1];                                  e[j + 1] = cs*e[j + 1];                                  if (wantu && (j < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*umatrix[i][j] + sn*umatrix[i][j + 1];                                          umatrix[i][j + 1] = -sn*umatrix[i][j] + cs*umatrix[i][j + 1];                                          umatrix[i][j] = t;                                      }                                  }                              }                              e[p - 2] = f;                              iter = iter + 1;                          }                          break;                            // Convergence.                        case 4:                          {                              // Make the singular values positive.                                if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                  if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                      {                                          vmatrix[i][k] = -vmatrix[i][k];                                      }                                  }                              }                                // Order the singular values.                                while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                  {                                      break;                                  }                                  double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                  if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = vmatrix[i][k + 1];                                          vmatrix[i][k + 1] = vmatrix[i][k];                                          vmatrix[i][k] = t;                                      }                                  }                                  if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = umatrix[i][k + 1];                                          umatrix[i][k + 1] = umatrix[i][k];                                          umatrix[i][k] = t;                                      }                                  }                                  k++;                              }                              iter = 0;                              p--;                          }                          break;                  }              }
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0)              {                  int k' kase;                    // Here is where a test for too many iterations would go.                    // This section of the program inspects for                  // negligible elements in the s and e arrays. On                  // completion the variables kase and k are set as follows.                    // kase = 1 if s(p) and e[k-1] are negligible and k<p                  // kase = 2 if s(k) is negligible and k<p                  // kase = 3 if e[k-1] is negligible' k<p' and                  // s(k)' ...' s(p) are not negligible (qr step).                  // kase = 4 if e(p-1) is negligible (convergence).                    for (k = p - 2; k >= -1; k--)                  {                      if (k == -1)                      {                          break;                      }                      if (Math.Abs(e[k]) <= tiny + eps                          *(Math.Abs(s[k]) + Math.Abs(s[k + 1])))                      {                          e[k] = 0.0;                          break;                      }                  }                  if (k == p - 2)                  {                      kase = 4;                  }                  else                  {                      int ks;                      for (ks = p - 1; ks >= k; ks--)                      {                          if (ks == k)                          {                              break;                          }                          double t = (ks != p ? Math.Abs(e[ks]) : 0.0)                                     + (ks != k + 1 ? Math.Abs(e[ks - 1]) : 0.0);                          if (Math.Abs(s[ks]) <= tiny + eps*t)                          {                              s[ks] = 0.0;                              break;                          }                      }                      if (ks == k)                      {                          kase = 3;                      }                      else if (ks == p - 1)                      {                          kase = 1;                      }                      else                      {                          kase = 2;                          k = ks;                      }                  }                  k++;                    // Perform the task indicated by kase.                    switch (kase)                  {                          // Deflate negligible s(p).                        case 1:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for (int j = p - 2; j >= k; j--)                              {                                  double t = EncogMath.Hypot(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  if (j != k)                                  {                                      f = -sn*e[j - 1];                                      e[j - 1] = cs*e[j - 1];                                  }                                  if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*vmatrix[i][j] + sn*vmatrix[i][p - 1];                                          vmatrix[i][p - 1] = -sn*vmatrix[i][j] + cs*vmatrix[i][p - 1];                                          vmatrix[i][j] = t;                                      }                                  }                              }                          }                          break;                            // Split at negligible s(k).                        case 2:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for (int j = k; j < p; j++)                              {                                  double t = EncogMath.Hypot(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  f = -sn*e[j];                                  e[j] = cs*e[j];                                  if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*umatrix[i][j] + sn*umatrix[i][k - 1];                                          umatrix[i][k - 1] = -sn*umatrix[i][j] + cs*umatrix[i][k - 1];                                          umatrix[i][j] = t;                                      }                                  }                              }                          }                          break;                            // Perform one qr step.                        case 3:                          {                              // Calculate the shift.                                double scale = Math.Max(Math.Max(Math                                                                   .Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))'                                                                        Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math                                                                                                                  .Abs(                                                                                                                      e[k]));                              double sp = s[p - 1]/scale;                              double spm1 = s[p - 2]/scale;                              double epm1 = e[p - 2]/scale;                              double sk = s[k]/scale;                              double ek = e[k]/scale;                              double b = ((spm1 + sp)*(spm1 - sp) + epm1*epm1)/2.0;                              double c = (sp*epm1)*(sp*epm1);                              double shift = 0.0;                              if ((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt(b*b + c);                                  if (b < 0.0)                                  {                                      shift = -shift;                                  }                                  shift = c/(b + shift);                              }                              double f = (sk + sp)*(sk - sp) + shift;                              double g = sk*ek;                                // Chase zeros.                                for (int j = k; j < p - 1; j++)                              {                                  double t = EncogMath.Hypot(f' g);                                  double cs = f/t;                                  double sn = g/t;                                  if (j != k)                                  {                                      e[j - 1] = t;                                  }                                  f = cs*s[j] + sn*e[j];                                  e[j] = cs*e[j] - sn*s[j];                                  g = sn*s[j + 1];                                  s[j + 1] = cs*s[j + 1];                                  if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*vmatrix[i][j] + sn*vmatrix[i][j + 1];                                          vmatrix[i][j + 1] = -sn*vmatrix[i][j] + cs*vmatrix[i][j + 1];                                          vmatrix[i][j] = t;                                      }                                  }                                  t = EncogMath.Hypot(f' g);                                  cs = f/t;                                  sn = g/t;                                  s[j] = t;                                  f = cs*e[j] + sn*s[j + 1];                                  s[j + 1] = -sn*e[j] + cs*s[j + 1];                                  g = sn*e[j + 1];                                  e[j + 1] = cs*e[j + 1];                                  if (wantu && (j < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*umatrix[i][j] + sn*umatrix[i][j + 1];                                          umatrix[i][j + 1] = -sn*umatrix[i][j] + cs*umatrix[i][j + 1];                                          umatrix[i][j] = t;                                      }                                  }                              }                              e[p - 2] = f;                              iter = iter + 1;                          }                          break;                            // Convergence.                        case 4:                          {                              // Make the singular values positive.                                if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                  if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                      {                                          vmatrix[i][k] = -vmatrix[i][k];                                      }                                  }                              }                                // Order the singular values.                                while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                  {                                      break;                                  }                                  double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                  if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = vmatrix[i][k + 1];                                          vmatrix[i][k + 1] = vmatrix[i][k];                                          vmatrix[i][k] = t;                                      }                                  }                                  if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = umatrix[i][k + 1];                                          umatrix[i][k + 1] = umatrix[i][k];                                          umatrix[i][k] = t;                                      }                                  }                                  k++;                              }                              iter = 0;                              p--;                          }                          break;                  }              }
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0)              {                  int k' kase;                    // Here is where a test for too many iterations would go.                    // This section of the program inspects for                  // negligible elements in the s and e arrays. On                  // completion the variables kase and k are set as follows.                    // kase = 1 if s(p) and e[k-1] are negligible and k<p                  // kase = 2 if s(k) is negligible and k<p                  // kase = 3 if e[k-1] is negligible' k<p' and                  // s(k)' ...' s(p) are not negligible (qr step).                  // kase = 4 if e(p-1) is negligible (convergence).                    for (k = p - 2; k >= -1; k--)                  {                      if (k == -1)                      {                          break;                      }                      if (Math.Abs(e[k]) <= tiny + eps                          *(Math.Abs(s[k]) + Math.Abs(s[k + 1])))                      {                          e[k] = 0.0;                          break;                      }                  }                  if (k == p - 2)                  {                      kase = 4;                  }                  else                  {                      int ks;                      for (ks = p - 1; ks >= k; ks--)                      {                          if (ks == k)                          {                              break;                          }                          double t = (ks != p ? Math.Abs(e[ks]) : 0.0)                                     + (ks != k + 1 ? Math.Abs(e[ks - 1]) : 0.0);                          if (Math.Abs(s[ks]) <= tiny + eps*t)                          {                              s[ks] = 0.0;                              break;                          }                      }                      if (ks == k)                      {                          kase = 3;                      }                      else if (ks == p - 1)                      {                          kase = 1;                      }                      else                      {                          kase = 2;                          k = ks;                      }                  }                  k++;                    // Perform the task indicated by kase.                    switch (kase)                  {                          // Deflate negligible s(p).                        case 1:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for (int j = p - 2; j >= k; j--)                              {                                  double t = EncogMath.Hypot(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  if (j != k)                                  {                                      f = -sn*e[j - 1];                                      e[j - 1] = cs*e[j - 1];                                  }                                  if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*vmatrix[i][j] + sn*vmatrix[i][p - 1];                                          vmatrix[i][p - 1] = -sn*vmatrix[i][j] + cs*vmatrix[i][p - 1];                                          vmatrix[i][j] = t;                                      }                                  }                              }                          }                          break;                            // Split at negligible s(k).                        case 2:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for (int j = k; j < p; j++)                              {                                  double t = EncogMath.Hypot(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  f = -sn*e[j];                                  e[j] = cs*e[j];                                  if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*umatrix[i][j] + sn*umatrix[i][k - 1];                                          umatrix[i][k - 1] = -sn*umatrix[i][j] + cs*umatrix[i][k - 1];                                          umatrix[i][j] = t;                                      }                                  }                              }                          }                          break;                            // Perform one qr step.                        case 3:                          {                              // Calculate the shift.                                double scale = Math.Max(Math.Max(Math                                                                   .Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))'                                                                        Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math                                                                                                                  .Abs(                                                                                                                      e[k]));                              double sp = s[p - 1]/scale;                              double spm1 = s[p - 2]/scale;                              double epm1 = e[p - 2]/scale;                              double sk = s[k]/scale;                              double ek = e[k]/scale;                              double b = ((spm1 + sp)*(spm1 - sp) + epm1*epm1)/2.0;                              double c = (sp*epm1)*(sp*epm1);                              double shift = 0.0;                              if ((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt(b*b + c);                                  if (b < 0.0)                                  {                                      shift = -shift;                                  }                                  shift = c/(b + shift);                              }                              double f = (sk + sp)*(sk - sp) + shift;                              double g = sk*ek;                                // Chase zeros.                                for (int j = k; j < p - 1; j++)                              {                                  double t = EncogMath.Hypot(f' g);                                  double cs = f/t;                                  double sn = g/t;                                  if (j != k)                                  {                                      e[j - 1] = t;                                  }                                  f = cs*s[j] + sn*e[j];                                  e[j] = cs*e[j] - sn*s[j];                                  g = sn*s[j + 1];                                  s[j + 1] = cs*s[j + 1];                                  if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*vmatrix[i][j] + sn*vmatrix[i][j + 1];                                          vmatrix[i][j + 1] = -sn*vmatrix[i][j] + cs*vmatrix[i][j + 1];                                          vmatrix[i][j] = t;                                      }                                  }                                  t = EncogMath.Hypot(f' g);                                  cs = f/t;                                  sn = g/t;                                  s[j] = t;                                  f = cs*e[j] + sn*s[j + 1];                                  s[j + 1] = -sn*e[j] + cs*s[j + 1];                                  g = sn*e[j + 1];                                  e[j + 1] = cs*e[j + 1];                                  if (wantu && (j < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*umatrix[i][j] + sn*umatrix[i][j + 1];                                          umatrix[i][j + 1] = -sn*umatrix[i][j] + cs*umatrix[i][j + 1];                                          umatrix[i][j] = t;                                      }                                  }                              }                              e[p - 2] = f;                              iter = iter + 1;                          }                          break;                            // Convergence.                        case 4:                          {                              // Make the singular values positive.                                if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                  if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                      {                                          vmatrix[i][k] = -vmatrix[i][k];                                      }                                  }                              }                                // Order the singular values.                                while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                  {                                      break;                                  }                                  double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                  if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = vmatrix[i][k + 1];                                          vmatrix[i][k + 1] = vmatrix[i][k];                                          vmatrix[i][k] = t;                                      }                                  }                                  if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = umatrix[i][k + 1];                                          umatrix[i][k + 1] = umatrix[i][k];                                          umatrix[i][k] = t;                                      }                                  }                                  k++;                              }                              iter = 0;                              p--;                          }                          break;                  }              }
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0)              {                  int k' kase;                    // Here is where a test for too many iterations would go.                    // This section of the program inspects for                  // negligible elements in the s and e arrays. On                  // completion the variables kase and k are set as follows.                    // kase = 1 if s(p) and e[k-1] are negligible and k<p                  // kase = 2 if s(k) is negligible and k<p                  // kase = 3 if e[k-1] is negligible' k<p' and                  // s(k)' ...' s(p) are not negligible (qr step).                  // kase = 4 if e(p-1) is negligible (convergence).                    for (k = p - 2; k >= -1; k--)                  {                      if (k == -1)                      {                          break;                      }                      if (Math.Abs(e[k]) <= tiny + eps                          *(Math.Abs(s[k]) + Math.Abs(s[k + 1])))                      {                          e[k] = 0.0;                          break;                      }                  }                  if (k == p - 2)                  {                      kase = 4;                  }                  else                  {                      int ks;                      for (ks = p - 1; ks >= k; ks--)                      {                          if (ks == k)                          {                              break;                          }                          double t = (ks != p ? Math.Abs(e[ks]) : 0.0)                                     + (ks != k + 1 ? Math.Abs(e[ks - 1]) : 0.0);                          if (Math.Abs(s[ks]) <= tiny + eps*t)                          {                              s[ks] = 0.0;                              break;                          }                      }                      if (ks == k)                      {                          kase = 3;                      }                      else if (ks == p - 1)                      {                          kase = 1;                      }                      else                      {                          kase = 2;                          k = ks;                      }                  }                  k++;                    // Perform the task indicated by kase.                    switch (kase)                  {                          // Deflate negligible s(p).                        case 1:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for (int j = p - 2; j >= k; j--)                              {                                  double t = EncogMath.Hypot(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  if (j != k)                                  {                                      f = -sn*e[j - 1];                                      e[j - 1] = cs*e[j - 1];                                  }                                  if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*vmatrix[i][j] + sn*vmatrix[i][p - 1];                                          vmatrix[i][p - 1] = -sn*vmatrix[i][j] + cs*vmatrix[i][p - 1];                                          vmatrix[i][j] = t;                                      }                                  }                              }                          }                          break;                            // Split at negligible s(k).                        case 2:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for (int j = k; j < p; j++)                              {                                  double t = EncogMath.Hypot(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  f = -sn*e[j];                                  e[j] = cs*e[j];                                  if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*umatrix[i][j] + sn*umatrix[i][k - 1];                                          umatrix[i][k - 1] = -sn*umatrix[i][j] + cs*umatrix[i][k - 1];                                          umatrix[i][j] = t;                                      }                                  }                              }                          }                          break;                            // Perform one qr step.                        case 3:                          {                              // Calculate the shift.                                double scale = Math.Max(Math.Max(Math                                                                   .Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))'                                                                        Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math                                                                                                                  .Abs(                                                                                                                      e[k]));                              double sp = s[p - 1]/scale;                              double spm1 = s[p - 2]/scale;                              double epm1 = e[p - 2]/scale;                              double sk = s[k]/scale;                              double ek = e[k]/scale;                              double b = ((spm1 + sp)*(spm1 - sp) + epm1*epm1)/2.0;                              double c = (sp*epm1)*(sp*epm1);                              double shift = 0.0;                              if ((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt(b*b + c);                                  if (b < 0.0)                                  {                                      shift = -shift;                                  }                                  shift = c/(b + shift);                              }                              double f = (sk + sp)*(sk - sp) + shift;                              double g = sk*ek;                                // Chase zeros.                                for (int j = k; j < p - 1; j++)                              {                                  double t = EncogMath.Hypot(f' g);                                  double cs = f/t;                                  double sn = g/t;                                  if (j != k)                                  {                                      e[j - 1] = t;                                  }                                  f = cs*s[j] + sn*e[j];                                  e[j] = cs*e[j] - sn*s[j];                                  g = sn*s[j + 1];                                  s[j + 1] = cs*s[j + 1];                                  if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*vmatrix[i][j] + sn*vmatrix[i][j + 1];                                          vmatrix[i][j + 1] = -sn*vmatrix[i][j] + cs*vmatrix[i][j + 1];                                          vmatrix[i][j] = t;                                      }                                  }                                  t = EncogMath.Hypot(f' g);                                  cs = f/t;                                  sn = g/t;                                  s[j] = t;                                  f = cs*e[j] + sn*s[j + 1];                                  s[j + 1] = -sn*e[j] + cs*s[j + 1];                                  g = sn*e[j + 1];                                  e[j + 1] = cs*e[j + 1];                                  if (wantu && (j < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*umatrix[i][j] + sn*umatrix[i][j + 1];                                          umatrix[i][j + 1] = -sn*umatrix[i][j] + cs*umatrix[i][j + 1];                                          umatrix[i][j] = t;                                      }                                  }                              }                              e[p - 2] = f;                              iter = iter + 1;                          }                          break;                            // Convergence.                        case 4:                          {                              // Make the singular values positive.                                if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                  if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                      {                                          vmatrix[i][k] = -vmatrix[i][k];                                      }                                  }                              }                                // Order the singular values.                                while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                  {                                      break;                                  }                                  double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                  if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = vmatrix[i][k + 1];                                          vmatrix[i][k + 1] = vmatrix[i][k];                                          vmatrix[i][k] = t;                                      }                                  }                                  if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = umatrix[i][k + 1];                                          umatrix[i][k + 1] = umatrix[i][k];                                          umatrix[i][k] = t;                                      }                                  }                                  k++;                              }                              iter = 0;                              p--;                          }                          break;                  }              }
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0)              {                  int k' kase;                    // Here is where a test for too many iterations would go.                    // This section of the program inspects for                  // negligible elements in the s and e arrays. On                  // completion the variables kase and k are set as follows.                    // kase = 1 if s(p) and e[k-1] are negligible and k<p                  // kase = 2 if s(k) is negligible and k<p                  // kase = 3 if e[k-1] is negligible' k<p' and                  // s(k)' ...' s(p) are not negligible (qr step).                  // kase = 4 if e(p-1) is negligible (convergence).                    for (k = p - 2; k >= -1; k--)                  {                      if (k == -1)                      {                          break;                      }                      if (Math.Abs(e[k]) <= tiny + eps                          *(Math.Abs(s[k]) + Math.Abs(s[k + 1])))                      {                          e[k] = 0.0;                          break;                      }                  }                  if (k == p - 2)                  {                      kase = 4;                  }                  else                  {                      int ks;                      for (ks = p - 1; ks >= k; ks--)                      {                          if (ks == k)                          {                              break;                          }                          double t = (ks != p ? Math.Abs(e[ks]) : 0.0)                                     + (ks != k + 1 ? Math.Abs(e[ks - 1]) : 0.0);                          if (Math.Abs(s[ks]) <= tiny + eps*t)                          {                              s[ks] = 0.0;                              break;                          }                      }                      if (ks == k)                      {                          kase = 3;                      }                      else if (ks == p - 1)                      {                          kase = 1;                      }                      else                      {                          kase = 2;                          k = ks;                      }                  }                  k++;                    // Perform the task indicated by kase.                    switch (kase)                  {                          // Deflate negligible s(p).                        case 1:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for (int j = p - 2; j >= k; j--)                              {                                  double t = EncogMath.Hypot(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  if (j != k)                                  {                                      f = -sn*e[j - 1];                                      e[j - 1] = cs*e[j - 1];                                  }                                  if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*vmatrix[i][j] + sn*vmatrix[i][p - 1];                                          vmatrix[i][p - 1] = -sn*vmatrix[i][j] + cs*vmatrix[i][p - 1];                                          vmatrix[i][j] = t;                                      }                                  }                              }                          }                          break;                            // Split at negligible s(k).                        case 2:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for (int j = k; j < p; j++)                              {                                  double t = EncogMath.Hypot(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  f = -sn*e[j];                                  e[j] = cs*e[j];                                  if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*umatrix[i][j] + sn*umatrix[i][k - 1];                                          umatrix[i][k - 1] = -sn*umatrix[i][j] + cs*umatrix[i][k - 1];                                          umatrix[i][j] = t;                                      }                                  }                              }                          }                          break;                            // Perform one qr step.                        case 3:                          {                              // Calculate the shift.                                double scale = Math.Max(Math.Max(Math                                                                   .Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))'                                                                        Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math                                                                                                                  .Abs(                                                                                                                      e[k]));                              double sp = s[p - 1]/scale;                              double spm1 = s[p - 2]/scale;                              double epm1 = e[p - 2]/scale;                              double sk = s[k]/scale;                              double ek = e[k]/scale;                              double b = ((spm1 + sp)*(spm1 - sp) + epm1*epm1)/2.0;                              double c = (sp*epm1)*(sp*epm1);                              double shift = 0.0;                              if ((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt(b*b + c);                                  if (b < 0.0)                                  {                                      shift = -shift;                                  }                                  shift = c/(b + shift);                              }                              double f = (sk + sp)*(sk - sp) + shift;                              double g = sk*ek;                                // Chase zeros.                                for (int j = k; j < p - 1; j++)                              {                                  double t = EncogMath.Hypot(f' g);                                  double cs = f/t;                                  double sn = g/t;                                  if (j != k)                                  {                                      e[j - 1] = t;                                  }                                  f = cs*s[j] + sn*e[j];                                  e[j] = cs*e[j] - sn*s[j];                                  g = sn*s[j + 1];                                  s[j + 1] = cs*s[j + 1];                                  if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*vmatrix[i][j] + sn*vmatrix[i][j + 1];                                          vmatrix[i][j + 1] = -sn*vmatrix[i][j] + cs*vmatrix[i][j + 1];                                          vmatrix[i][j] = t;                                      }                                  }                                  t = EncogMath.Hypot(f' g);                                  cs = f/t;                                  sn = g/t;                                  s[j] = t;                                  f = cs*e[j] + sn*s[j + 1];                                  s[j + 1] = -sn*e[j] + cs*s[j + 1];                                  g = sn*e[j + 1];                                  e[j + 1] = cs*e[j + 1];                                  if (wantu && (j < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*umatrix[i][j] + sn*umatrix[i][j + 1];                                          umatrix[i][j + 1] = -sn*umatrix[i][j] + cs*umatrix[i][j + 1];                                          umatrix[i][j] = t;                                      }                                  }                              }                              e[p - 2] = f;                              iter = iter + 1;                          }                          break;                            // Convergence.                        case 4:                          {                              // Make the singular values positive.                                if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                  if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                      {                                          vmatrix[i][k] = -vmatrix[i][k];                                      }                                  }                              }                                // Order the singular values.                                while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                  {                                      break;                                  }                                  double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                  if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = vmatrix[i][k + 1];                                          vmatrix[i][k + 1] = vmatrix[i][k];                                          vmatrix[i][k] = t;                                      }                                  }                                  if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = umatrix[i][k + 1];                                          umatrix[i][k + 1] = umatrix[i][k];                                          umatrix[i][k] = t;                                      }                                  }                                  k++;                              }                              iter = 0;                              p--;                          }                          break;                  }              }
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0)              {                  int k' kase;                    // Here is where a test for too many iterations would go.                    // This section of the program inspects for                  // negligible elements in the s and e arrays. On                  // completion the variables kase and k are set as follows.                    // kase = 1 if s(p) and e[k-1] are negligible and k<p                  // kase = 2 if s(k) is negligible and k<p                  // kase = 3 if e[k-1] is negligible' k<p' and                  // s(k)' ...' s(p) are not negligible (qr step).                  // kase = 4 if e(p-1) is negligible (convergence).                    for (k = p - 2; k >= -1; k--)                  {                      if (k == -1)                      {                          break;                      }                      if (Math.Abs(e[k]) <= tiny + eps                          *(Math.Abs(s[k]) + Math.Abs(s[k + 1])))                      {                          e[k] = 0.0;                          break;                      }                  }                  if (k == p - 2)                  {                      kase = 4;                  }                  else                  {                      int ks;                      for (ks = p - 1; ks >= k; ks--)                      {                          if (ks == k)                          {                              break;                          }                          double t = (ks != p ? Math.Abs(e[ks]) : 0.0)                                     + (ks != k + 1 ? Math.Abs(e[ks - 1]) : 0.0);                          if (Math.Abs(s[ks]) <= tiny + eps*t)                          {                              s[ks] = 0.0;                              break;                          }                      }                      if (ks == k)                      {                          kase = 3;                      }                      else if (ks == p - 1)                      {                          kase = 1;                      }                      else                      {                          kase = 2;                          k = ks;                      }                  }                  k++;                    // Perform the task indicated by kase.                    switch (kase)                  {                          // Deflate negligible s(p).                        case 1:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for (int j = p - 2; j >= k; j--)                              {                                  double t = EncogMath.Hypot(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  if (j != k)                                  {                                      f = -sn*e[j - 1];                                      e[j - 1] = cs*e[j - 1];                                  }                                  if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*vmatrix[i][j] + sn*vmatrix[i][p - 1];                                          vmatrix[i][p - 1] = -sn*vmatrix[i][j] + cs*vmatrix[i][p - 1];                                          vmatrix[i][j] = t;                                      }                                  }                              }                          }                          break;                            // Split at negligible s(k).                        case 2:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for (int j = k; j < p; j++)                              {                                  double t = EncogMath.Hypot(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  f = -sn*e[j];                                  e[j] = cs*e[j];                                  if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*umatrix[i][j] + sn*umatrix[i][k - 1];                                          umatrix[i][k - 1] = -sn*umatrix[i][j] + cs*umatrix[i][k - 1];                                          umatrix[i][j] = t;                                      }                                  }                              }                          }                          break;                            // Perform one qr step.                        case 3:                          {                              // Calculate the shift.                                double scale = Math.Max(Math.Max(Math                                                                   .Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))'                                                                        Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math                                                                                                                  .Abs(                                                                                                                      e[k]));                              double sp = s[p - 1]/scale;                              double spm1 = s[p - 2]/scale;                              double epm1 = e[p - 2]/scale;                              double sk = s[k]/scale;                              double ek = e[k]/scale;                              double b = ((spm1 + sp)*(spm1 - sp) + epm1*epm1)/2.0;                              double c = (sp*epm1)*(sp*epm1);                              double shift = 0.0;                              if ((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt(b*b + c);                                  if (b < 0.0)                                  {                                      shift = -shift;                                  }                                  shift = c/(b + shift);                              }                              double f = (sk + sp)*(sk - sp) + shift;                              double g = sk*ek;                                // Chase zeros.                                for (int j = k; j < p - 1; j++)                              {                                  double t = EncogMath.Hypot(f' g);                                  double cs = f/t;                                  double sn = g/t;                                  if (j != k)                                  {                                      e[j - 1] = t;                                  }                                  f = cs*s[j] + sn*e[j];                                  e[j] = cs*e[j] - sn*s[j];                                  g = sn*s[j + 1];                                  s[j + 1] = cs*s[j + 1];                                  if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*vmatrix[i][j] + sn*vmatrix[i][j + 1];                                          vmatrix[i][j + 1] = -sn*vmatrix[i][j] + cs*vmatrix[i][j + 1];                                          vmatrix[i][j] = t;                                      }                                  }                                  t = EncogMath.Hypot(f' g);                                  cs = f/t;                                  sn = g/t;                                  s[j] = t;                                  f = cs*e[j] + sn*s[j + 1];                                  s[j + 1] = -sn*e[j] + cs*s[j + 1];                                  g = sn*e[j + 1];                                  e[j + 1] = cs*e[j + 1];                                  if (wantu && (j < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*umatrix[i][j] + sn*umatrix[i][j + 1];                                          umatrix[i][j + 1] = -sn*umatrix[i][j] + cs*umatrix[i][j + 1];                                          umatrix[i][j] = t;                                      }                                  }                              }                              e[p - 2] = f;                              iter = iter + 1;                          }                          break;                            // Convergence.                        case 4:                          {                              // Make the singular values positive.                                if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                  if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                      {                                          vmatrix[i][k] = -vmatrix[i][k];                                      }                                  }                              }                                // Order the singular values.                                while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                  {                                      break;                                  }                                  double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                  if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = vmatrix[i][k + 1];                                          vmatrix[i][k + 1] = vmatrix[i][k];                                          vmatrix[i][k] = t;                                      }                                  }                                  if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = umatrix[i][k + 1];                                          umatrix[i][k + 1] = umatrix[i][k];                                          umatrix[i][k] = t;                                      }                                  }                                  k++;                              }                              iter = 0;                              p--;                          }                          break;                  }              }
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0)              {                  int k' kase;                    // Here is where a test for too many iterations would go.                    // This section of the program inspects for                  // negligible elements in the s and e arrays. On                  // completion the variables kase and k are set as follows.                    // kase = 1 if s(p) and e[k-1] are negligible and k<p                  // kase = 2 if s(k) is negligible and k<p                  // kase = 3 if e[k-1] is negligible' k<p' and                  // s(k)' ...' s(p) are not negligible (qr step).                  // kase = 4 if e(p-1) is negligible (convergence).                    for (k = p - 2; k >= -1; k--)                  {                      if (k == -1)                      {                          break;                      }                      if (Math.Abs(e[k]) <= tiny + eps                          *(Math.Abs(s[k]) + Math.Abs(s[k + 1])))                      {                          e[k] = 0.0;                          break;                      }                  }                  if (k == p - 2)                  {                      kase = 4;                  }                  else                  {                      int ks;                      for (ks = p - 1; ks >= k; ks--)                      {                          if (ks == k)                          {                              break;                          }                          double t = (ks != p ? Math.Abs(e[ks]) : 0.0)                                     + (ks != k + 1 ? Math.Abs(e[ks - 1]) : 0.0);                          if (Math.Abs(s[ks]) <= tiny + eps*t)                          {                              s[ks] = 0.0;                              break;                          }                      }                      if (ks == k)                      {                          kase = 3;                      }                      else if (ks == p - 1)                      {                          kase = 1;                      }                      else                      {                          kase = 2;                          k = ks;                      }                  }                  k++;                    // Perform the task indicated by kase.                    switch (kase)                  {                          // Deflate negligible s(p).                        case 1:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for (int j = p - 2; j >= k; j--)                              {                                  double t = EncogMath.Hypot(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  if (j != k)                                  {                                      f = -sn*e[j - 1];                                      e[j - 1] = cs*e[j - 1];                                  }                                  if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*vmatrix[i][j] + sn*vmatrix[i][p - 1];                                          vmatrix[i][p - 1] = -sn*vmatrix[i][j] + cs*vmatrix[i][p - 1];                                          vmatrix[i][j] = t;                                      }                                  }                              }                          }                          break;                            // Split at negligible s(k).                        case 2:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for (int j = k; j < p; j++)                              {                                  double t = EncogMath.Hypot(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  f = -sn*e[j];                                  e[j] = cs*e[j];                                  if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*umatrix[i][j] + sn*umatrix[i][k - 1];                                          umatrix[i][k - 1] = -sn*umatrix[i][j] + cs*umatrix[i][k - 1];                                          umatrix[i][j] = t;                                      }                                  }                              }                          }                          break;                            // Perform one qr step.                        case 3:                          {                              // Calculate the shift.                                double scale = Math.Max(Math.Max(Math                                                                   .Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))'                                                                        Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math                                                                                                                  .Abs(                                                                                                                      e[k]));                              double sp = s[p - 1]/scale;                              double spm1 = s[p - 2]/scale;                              double epm1 = e[p - 2]/scale;                              double sk = s[k]/scale;                              double ek = e[k]/scale;                              double b = ((spm1 + sp)*(spm1 - sp) + epm1*epm1)/2.0;                              double c = (sp*epm1)*(sp*epm1);                              double shift = 0.0;                              if ((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt(b*b + c);                                  if (b < 0.0)                                  {                                      shift = -shift;                                  }                                  shift = c/(b + shift);                              }                              double f = (sk + sp)*(sk - sp) + shift;                              double g = sk*ek;                                // Chase zeros.                                for (int j = k; j < p - 1; j++)                              {                                  double t = EncogMath.Hypot(f' g);                                  double cs = f/t;                                  double sn = g/t;                                  if (j != k)                                  {                                      e[j - 1] = t;                                  }                                  f = cs*s[j] + sn*e[j];                                  e[j] = cs*e[j] - sn*s[j];                                  g = sn*s[j + 1];                                  s[j + 1] = cs*s[j + 1];                                  if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*vmatrix[i][j] + sn*vmatrix[i][j + 1];                                          vmatrix[i][j + 1] = -sn*vmatrix[i][j] + cs*vmatrix[i][j + 1];                                          vmatrix[i][j] = t;                                      }                                  }                                  t = EncogMath.Hypot(f' g);                                  cs = f/t;                                  sn = g/t;                                  s[j] = t;                                  f = cs*e[j] + sn*s[j + 1];                                  s[j + 1] = -sn*e[j] + cs*s[j + 1];                                  g = sn*e[j + 1];                                  e[j + 1] = cs*e[j + 1];                                  if (wantu && (j < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*umatrix[i][j] + sn*umatrix[i][j + 1];                                          umatrix[i][j + 1] = -sn*umatrix[i][j] + cs*umatrix[i][j + 1];                                          umatrix[i][j] = t;                                      }                                  }                              }                              e[p - 2] = f;                              iter = iter + 1;                          }                          break;                            // Convergence.                        case 4:                          {                              // Make the singular values positive.                                if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                  if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                      {                                          vmatrix[i][k] = -vmatrix[i][k];                                      }                                  }                              }                                // Order the singular values.                                while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                  {                                      break;                                  }                                  double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                  if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = vmatrix[i][k + 1];                                          vmatrix[i][k + 1] = vmatrix[i][k];                                          vmatrix[i][k] = t;                                      }                                  }                                  if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = umatrix[i][k + 1];                                          umatrix[i][k + 1] = umatrix[i][k];                                          umatrix[i][k] = t;                                      }                                  }                                  k++;                              }                              iter = 0;                              p--;                          }                          break;                  }              }
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0)              {                  int k' kase;                    // Here is where a test for too many iterations would go.                    // This section of the program inspects for                  // negligible elements in the s and e arrays. On                  // completion the variables kase and k are set as follows.                    // kase = 1 if s(p) and e[k-1] are negligible and k<p                  // kase = 2 if s(k) is negligible and k<p                  // kase = 3 if e[k-1] is negligible' k<p' and                  // s(k)' ...' s(p) are not negligible (qr step).                  // kase = 4 if e(p-1) is negligible (convergence).                    for (k = p - 2; k >= -1; k--)                  {                      if (k == -1)                      {                          break;                      }                      if (Math.Abs(e[k]) <= tiny + eps                          *(Math.Abs(s[k]) + Math.Abs(s[k + 1])))                      {                          e[k] = 0.0;                          break;                      }                  }                  if (k == p - 2)                  {                      kase = 4;                  }                  else                  {                      int ks;                      for (ks = p - 1; ks >= k; ks--)                      {                          if (ks == k)                          {                              break;                          }                          double t = (ks != p ? Math.Abs(e[ks]) : 0.0)                                     + (ks != k + 1 ? Math.Abs(e[ks - 1]) : 0.0);                          if (Math.Abs(s[ks]) <= tiny + eps*t)                          {                              s[ks] = 0.0;                              break;                          }                      }                      if (ks == k)                      {                          kase = 3;                      }                      else if (ks == p - 1)                      {                          kase = 1;                      }                      else                      {                          kase = 2;                          k = ks;                      }                  }                  k++;                    // Perform the task indicated by kase.                    switch (kase)                  {                          // Deflate negligible s(p).                        case 1:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for (int j = p - 2; j >= k; j--)                              {                                  double t = EncogMath.Hypot(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  if (j != k)                                  {                                      f = -sn*e[j - 1];                                      e[j - 1] = cs*e[j - 1];                                  }                                  if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*vmatrix[i][j] + sn*vmatrix[i][p - 1];                                          vmatrix[i][p - 1] = -sn*vmatrix[i][j] + cs*vmatrix[i][p - 1];                                          vmatrix[i][j] = t;                                      }                                  }                              }                          }                          break;                            // Split at negligible s(k).                        case 2:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for (int j = k; j < p; j++)                              {                                  double t = EncogMath.Hypot(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  f = -sn*e[j];                                  e[j] = cs*e[j];                                  if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*umatrix[i][j] + sn*umatrix[i][k - 1];                                          umatrix[i][k - 1] = -sn*umatrix[i][j] + cs*umatrix[i][k - 1];                                          umatrix[i][j] = t;                                      }                                  }                              }                          }                          break;                            // Perform one qr step.                        case 3:                          {                              // Calculate the shift.                                double scale = Math.Max(Math.Max(Math                                                                   .Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))'                                                                        Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math                                                                                                                  .Abs(                                                                                                                      e[k]));                              double sp = s[p - 1]/scale;                              double spm1 = s[p - 2]/scale;                              double epm1 = e[p - 2]/scale;                              double sk = s[k]/scale;                              double ek = e[k]/scale;                              double b = ((spm1 + sp)*(spm1 - sp) + epm1*epm1)/2.0;                              double c = (sp*epm1)*(sp*epm1);                              double shift = 0.0;                              if ((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt(b*b + c);                                  if (b < 0.0)                                  {                                      shift = -shift;                                  }                                  shift = c/(b + shift);                              }                              double f = (sk + sp)*(sk - sp) + shift;                              double g = sk*ek;                                // Chase zeros.                                for (int j = k; j < p - 1; j++)                              {                                  double t = EncogMath.Hypot(f' g);                                  double cs = f/t;                                  double sn = g/t;                                  if (j != k)                                  {                                      e[j - 1] = t;                                  }                                  f = cs*s[j] + sn*e[j];                                  e[j] = cs*e[j] - sn*s[j];                                  g = sn*s[j + 1];                                  s[j + 1] = cs*s[j + 1];                                  if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*vmatrix[i][j] + sn*vmatrix[i][j + 1];                                          vmatrix[i][j + 1] = -sn*vmatrix[i][j] + cs*vmatrix[i][j + 1];                                          vmatrix[i][j] = t;                                      }                                  }                                  t = EncogMath.Hypot(f' g);                                  cs = f/t;                                  sn = g/t;                                  s[j] = t;                                  f = cs*e[j] + sn*s[j + 1];                                  s[j + 1] = -sn*e[j] + cs*s[j + 1];                                  g = sn*e[j + 1];                                  e[j + 1] = cs*e[j + 1];                                  if (wantu && (j < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*umatrix[i][j] + sn*umatrix[i][j + 1];                                          umatrix[i][j + 1] = -sn*umatrix[i][j] + cs*umatrix[i][j + 1];                                          umatrix[i][j] = t;                                      }                                  }                              }                              e[p - 2] = f;                              iter = iter + 1;                          }                          break;                            // Convergence.                        case 4:                          {                              // Make the singular values positive.                                if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                  if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                      {                                          vmatrix[i][k] = -vmatrix[i][k];                                      }                                  }                              }                                // Order the singular values.                                while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                  {                                      break;                                  }                                  double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                  if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = vmatrix[i][k + 1];                                          vmatrix[i][k + 1] = vmatrix[i][k];                                          vmatrix[i][k] = t;                                      }                                  }                                  if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = umatrix[i][k + 1];                                          umatrix[i][k + 1] = umatrix[i][k];                                          umatrix[i][k] = t;                                      }                                  }                                  k++;                              }                              iter = 0;                              p--;                          }                          break;                  }              }
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0)              {                  int k' kase;                    // Here is where a test for too many iterations would go.                    // This section of the program inspects for                  // negligible elements in the s and e arrays. On                  // completion the variables kase and k are set as follows.                    // kase = 1 if s(p) and e[k-1] are negligible and k<p                  // kase = 2 if s(k) is negligible and k<p                  // kase = 3 if e[k-1] is negligible' k<p' and                  // s(k)' ...' s(p) are not negligible (qr step).                  // kase = 4 if e(p-1) is negligible (convergence).                    for (k = p - 2; k >= -1; k--)                  {                      if (k == -1)                      {                          break;                      }                      if (Math.Abs(e[k]) <= tiny + eps                          *(Math.Abs(s[k]) + Math.Abs(s[k + 1])))                      {                          e[k] = 0.0;                          break;                      }                  }                  if (k == p - 2)                  {                      kase = 4;                  }                  else                  {                      int ks;                      for (ks = p - 1; ks >= k; ks--)                      {                          if (ks == k)                          {                              break;                          }                          double t = (ks != p ? Math.Abs(e[ks]) : 0.0)                                     + (ks != k + 1 ? Math.Abs(e[ks - 1]) : 0.0);                          if (Math.Abs(s[ks]) <= tiny + eps*t)                          {                              s[ks] = 0.0;                              break;                          }                      }                      if (ks == k)                      {                          kase = 3;                      }                      else if (ks == p - 1)                      {                          kase = 1;                      }                      else                      {                          kase = 2;                          k = ks;                      }                  }                  k++;                    // Perform the task indicated by kase.                    switch (kase)                  {                          // Deflate negligible s(p).                        case 1:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for (int j = p - 2; j >= k; j--)                              {                                  double t = EncogMath.Hypot(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  if (j != k)                                  {                                      f = -sn*e[j - 1];                                      e[j - 1] = cs*e[j - 1];                                  }                                  if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*vmatrix[i][j] + sn*vmatrix[i][p - 1];                                          vmatrix[i][p - 1] = -sn*vmatrix[i][j] + cs*vmatrix[i][p - 1];                                          vmatrix[i][j] = t;                                      }                                  }                              }                          }                          break;                            // Split at negligible s(k).                        case 2:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for (int j = k; j < p; j++)                              {                                  double t = EncogMath.Hypot(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  f = -sn*e[j];                                  e[j] = cs*e[j];                                  if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*umatrix[i][j] + sn*umatrix[i][k - 1];                                          umatrix[i][k - 1] = -sn*umatrix[i][j] + cs*umatrix[i][k - 1];                                          umatrix[i][j] = t;                                      }                                  }                              }                          }                          break;                            // Perform one qr step.                        case 3:                          {                              // Calculate the shift.                                double scale = Math.Max(Math.Max(Math                                                                   .Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))'                                                                        Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math                                                                                                                  .Abs(                                                                                                                      e[k]));                              double sp = s[p - 1]/scale;                              double spm1 = s[p - 2]/scale;                              double epm1 = e[p - 2]/scale;                              double sk = s[k]/scale;                              double ek = e[k]/scale;                              double b = ((spm1 + sp)*(spm1 - sp) + epm1*epm1)/2.0;                              double c = (sp*epm1)*(sp*epm1);                              double shift = 0.0;                              if ((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt(b*b + c);                                  if (b < 0.0)                                  {                                      shift = -shift;                                  }                                  shift = c/(b + shift);                              }                              double f = (sk + sp)*(sk - sp) + shift;                              double g = sk*ek;                                // Chase zeros.                                for (int j = k; j < p - 1; j++)                              {                                  double t = EncogMath.Hypot(f' g);                                  double cs = f/t;                                  double sn = g/t;                                  if (j != k)                                  {                                      e[j - 1] = t;                                  }                                  f = cs*s[j] + sn*e[j];                                  e[j] = cs*e[j] - sn*s[j];                                  g = sn*s[j + 1];                                  s[j + 1] = cs*s[j + 1];                                  if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*vmatrix[i][j] + sn*vmatrix[i][j + 1];                                          vmatrix[i][j + 1] = -sn*vmatrix[i][j] + cs*vmatrix[i][j + 1];                                          vmatrix[i][j] = t;                                      }                                  }                                  t = EncogMath.Hypot(f' g);                                  cs = f/t;                                  sn = g/t;                                  s[j] = t;                                  f = cs*e[j] + sn*s[j + 1];                                  s[j + 1] = -sn*e[j] + cs*s[j + 1];                                  g = sn*e[j + 1];                                  e[j + 1] = cs*e[j + 1];                                  if (wantu && (j < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*umatrix[i][j] + sn*umatrix[i][j + 1];                                          umatrix[i][j + 1] = -sn*umatrix[i][j] + cs*umatrix[i][j + 1];                                          umatrix[i][j] = t;                                      }                                  }                              }                              e[p - 2] = f;                              iter = iter + 1;                          }                          break;                            // Convergence.                        case 4:                          {                              // Make the singular values positive.                                if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                  if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                      {                                          vmatrix[i][k] = -vmatrix[i][k];                                      }                                  }                              }                                // Order the singular values.                                while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                  {                                      break;                                  }                                  double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                  if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = vmatrix[i][k + 1];                                          vmatrix[i][k + 1] = vmatrix[i][k];                                          vmatrix[i][k] = t;                                      }                                  }                                  if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = umatrix[i][k + 1];                                          umatrix[i][k + 1] = umatrix[i][k];                                          umatrix[i][k] = t;                                      }                                  }                                  k++;                              }                              iter = 0;                              p--;                          }                          break;                  }              }
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0)              {                  int k' kase;                    // Here is where a test for too many iterations would go.                    // This section of the program inspects for                  // negligible elements in the s and e arrays. On                  // completion the variables kase and k are set as follows.                    // kase = 1 if s(p) and e[k-1] are negligible and k<p                  // kase = 2 if s(k) is negligible and k<p                  // kase = 3 if e[k-1] is negligible' k<p' and                  // s(k)' ...' s(p) are not negligible (qr step).                  // kase = 4 if e(p-1) is negligible (convergence).                    for (k = p - 2; k >= -1; k--)                  {                      if (k == -1)                      {                          break;                      }                      if (Math.Abs(e[k]) <= tiny + eps                          *(Math.Abs(s[k]) + Math.Abs(s[k + 1])))                      {                          e[k] = 0.0;                          break;                      }                  }                  if (k == p - 2)                  {                      kase = 4;                  }                  else                  {                      int ks;                      for (ks = p - 1; ks >= k; ks--)                      {                          if (ks == k)                          {                              break;                          }                          double t = (ks != p ? Math.Abs(e[ks]) : 0.0)                                     + (ks != k + 1 ? Math.Abs(e[ks - 1]) : 0.0);                          if (Math.Abs(s[ks]) <= tiny + eps*t)                          {                              s[ks] = 0.0;                              break;                          }                      }                      if (ks == k)                      {                          kase = 3;                      }                      else if (ks == p - 1)                      {                          kase = 1;                      }                      else                      {                          kase = 2;                          k = ks;                      }                  }                  k++;                    // Perform the task indicated by kase.                    switch (kase)                  {                          // Deflate negligible s(p).                        case 1:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for (int j = p - 2; j >= k; j--)                              {                                  double t = EncogMath.Hypot(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  if (j != k)                                  {                                      f = -sn*e[j - 1];                                      e[j - 1] = cs*e[j - 1];                                  }                                  if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*vmatrix[i][j] + sn*vmatrix[i][p - 1];                                          vmatrix[i][p - 1] = -sn*vmatrix[i][j] + cs*vmatrix[i][p - 1];                                          vmatrix[i][j] = t;                                      }                                  }                              }                          }                          break;                            // Split at negligible s(k).                        case 2:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for (int j = k; j < p; j++)                              {                                  double t = EncogMath.Hypot(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  f = -sn*e[j];                                  e[j] = cs*e[j];                                  if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*umatrix[i][j] + sn*umatrix[i][k - 1];                                          umatrix[i][k - 1] = -sn*umatrix[i][j] + cs*umatrix[i][k - 1];                                          umatrix[i][j] = t;                                      }                                  }                              }                          }                          break;                            // Perform one qr step.                        case 3:                          {                              // Calculate the shift.                                double scale = Math.Max(Math.Max(Math                                                                   .Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))'                                                                        Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math                                                                                                                  .Abs(                                                                                                                      e[k]));                              double sp = s[p - 1]/scale;                              double spm1 = s[p - 2]/scale;                              double epm1 = e[p - 2]/scale;                              double sk = s[k]/scale;                              double ek = e[k]/scale;                              double b = ((spm1 + sp)*(spm1 - sp) + epm1*epm1)/2.0;                              double c = (sp*epm1)*(sp*epm1);                              double shift = 0.0;                              if ((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt(b*b + c);                                  if (b < 0.0)                                  {                                      shift = -shift;                                  }                                  shift = c/(b + shift);                              }                              double f = (sk + sp)*(sk - sp) + shift;                              double g = sk*ek;                                // Chase zeros.                                for (int j = k; j < p - 1; j++)                              {                                  double t = EncogMath.Hypot(f' g);                                  double cs = f/t;                                  double sn = g/t;                                  if (j != k)                                  {                                      e[j - 1] = t;                                  }                                  f = cs*s[j] + sn*e[j];                                  e[j] = cs*e[j] - sn*s[j];                                  g = sn*s[j + 1];                                  s[j + 1] = cs*s[j + 1];                                  if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*vmatrix[i][j] + sn*vmatrix[i][j + 1];                                          vmatrix[i][j + 1] = -sn*vmatrix[i][j] + cs*vmatrix[i][j + 1];                                          vmatrix[i][j] = t;                                      }                                  }                                  t = EncogMath.Hypot(f' g);                                  cs = f/t;                                  sn = g/t;                                  s[j] = t;                                  f = cs*e[j] + sn*s[j + 1];                                  s[j + 1] = -sn*e[j] + cs*s[j + 1];                                  g = sn*e[j + 1];                                  e[j + 1] = cs*e[j + 1];                                  if (wantu && (j < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*umatrix[i][j] + sn*umatrix[i][j + 1];                                          umatrix[i][j + 1] = -sn*umatrix[i][j] + cs*umatrix[i][j + 1];                                          umatrix[i][j] = t;                                      }                                  }                              }                              e[p - 2] = f;                              iter = iter + 1;                          }                          break;                            // Convergence.                        case 4:                          {                              // Make the singular values positive.                                if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                  if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                      {                                          vmatrix[i][k] = -vmatrix[i][k];                                      }                                  }                              }                                // Order the singular values.                                while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                  {                                      break;                                  }                                  double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                  if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = vmatrix[i][k + 1];                                          vmatrix[i][k + 1] = vmatrix[i][k];                                          vmatrix[i][k] = t;                                      }                                  }                                  if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = umatrix[i][k + 1];                                          umatrix[i][k + 1] = umatrix[i][k];                                          umatrix[i][k] = t;                                      }                                  }                                  k++;                              }                              iter = 0;                              p--;                          }                          break;                  }              }
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0)              {                  int k' kase;                    // Here is where a test for too many iterations would go.                    // This section of the program inspects for                  // negligible elements in the s and e arrays. On                  // completion the variables kase and k are set as follows.                    // kase = 1 if s(p) and e[k-1] are negligible and k<p                  // kase = 2 if s(k) is negligible and k<p                  // kase = 3 if e[k-1] is negligible' k<p' and                  // s(k)' ...' s(p) are not negligible (qr step).                  // kase = 4 if e(p-1) is negligible (convergence).                    for (k = p - 2; k >= -1; k--)                  {                      if (k == -1)                      {                          break;                      }                      if (Math.Abs(e[k]) <= tiny + eps                          *(Math.Abs(s[k]) + Math.Abs(s[k + 1])))                      {                          e[k] = 0.0;                          break;                      }                  }                  if (k == p - 2)                  {                      kase = 4;                  }                  else                  {                      int ks;                      for (ks = p - 1; ks >= k; ks--)                      {                          if (ks == k)                          {                              break;                          }                          double t = (ks != p ? Math.Abs(e[ks]) : 0.0)                                     + (ks != k + 1 ? Math.Abs(e[ks - 1]) : 0.0);                          if (Math.Abs(s[ks]) <= tiny + eps*t)                          {                              s[ks] = 0.0;                              break;                          }                      }                      if (ks == k)                      {                          kase = 3;                      }                      else if (ks == p - 1)                      {                          kase = 1;                      }                      else                      {                          kase = 2;                          k = ks;                      }                  }                  k++;                    // Perform the task indicated by kase.                    switch (kase)                  {                          // Deflate negligible s(p).                        case 1:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for (int j = p - 2; j >= k; j--)                              {                                  double t = EncogMath.Hypot(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  if (j != k)                                  {                                      f = -sn*e[j - 1];                                      e[j - 1] = cs*e[j - 1];                                  }                                  if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*vmatrix[i][j] + sn*vmatrix[i][p - 1];                                          vmatrix[i][p - 1] = -sn*vmatrix[i][j] + cs*vmatrix[i][p - 1];                                          vmatrix[i][j] = t;                                      }                                  }                              }                          }                          break;                            // Split at negligible s(k).                        case 2:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for (int j = k; j < p; j++)                              {                                  double t = EncogMath.Hypot(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  f = -sn*e[j];                                  e[j] = cs*e[j];                                  if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*umatrix[i][j] + sn*umatrix[i][k - 1];                                          umatrix[i][k - 1] = -sn*umatrix[i][j] + cs*umatrix[i][k - 1];                                          umatrix[i][j] = t;                                      }                                  }                              }                          }                          break;                            // Perform one qr step.                        case 3:                          {                              // Calculate the shift.                                double scale = Math.Max(Math.Max(Math                                                                   .Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))'                                                                        Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math                                                                                                                  .Abs(                                                                                                                      e[k]));                              double sp = s[p - 1]/scale;                              double spm1 = s[p - 2]/scale;                              double epm1 = e[p - 2]/scale;                              double sk = s[k]/scale;                              double ek = e[k]/scale;                              double b = ((spm1 + sp)*(spm1 - sp) + epm1*epm1)/2.0;                              double c = (sp*epm1)*(sp*epm1);                              double shift = 0.0;                              if ((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt(b*b + c);                                  if (b < 0.0)                                  {                                      shift = -shift;                                  }                                  shift = c/(b + shift);                              }                              double f = (sk + sp)*(sk - sp) + shift;                              double g = sk*ek;                                // Chase zeros.                                for (int j = k; j < p - 1; j++)                              {                                  double t = EncogMath.Hypot(f' g);                                  double cs = f/t;                                  double sn = g/t;                                  if (j != k)                                  {                                      e[j - 1] = t;                                  }                                  f = cs*s[j] + sn*e[j];                                  e[j] = cs*e[j] - sn*s[j];                                  g = sn*s[j + 1];                                  s[j + 1] = cs*s[j + 1];                                  if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*vmatrix[i][j] + sn*vmatrix[i][j + 1];                                          vmatrix[i][j + 1] = -sn*vmatrix[i][j] + cs*vmatrix[i][j + 1];                                          vmatrix[i][j] = t;                                      }                                  }                                  t = EncogMath.Hypot(f' g);                                  cs = f/t;                                  sn = g/t;                                  s[j] = t;                                  f = cs*e[j] + sn*s[j + 1];                                  s[j + 1] = -sn*e[j] + cs*s[j + 1];                                  g = sn*e[j + 1];                                  e[j + 1] = cs*e[j + 1];                                  if (wantu && (j < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*umatrix[i][j] + sn*umatrix[i][j + 1];                                          umatrix[i][j + 1] = -sn*umatrix[i][j] + cs*umatrix[i][j + 1];                                          umatrix[i][j] = t;                                      }                                  }                              }                              e[p - 2] = f;                              iter = iter + 1;                          }                          break;                            // Convergence.                        case 4:                          {                              // Make the singular values positive.                                if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                  if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                      {                                          vmatrix[i][k] = -vmatrix[i][k];                                      }                                  }                              }                                // Order the singular values.                                while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                  {                                      break;                                  }                                  double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                  if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = vmatrix[i][k + 1];                                          vmatrix[i][k + 1] = vmatrix[i][k];                                          vmatrix[i][k] = t;                                      }                                  }                                  if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = umatrix[i][k + 1];                                          umatrix[i][k + 1] = umatrix[i][k];                                          umatrix[i][k] = t;                                      }                                  }                                  k++;                              }                              iter = 0;                              p--;                          }                          break;                  }              }
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0)              {                  int k' kase;                    // Here is where a test for too many iterations would go.                    // This section of the program inspects for                  // negligible elements in the s and e arrays. On                  // completion the variables kase and k are set as follows.                    // kase = 1 if s(p) and e[k-1] are negligible and k<p                  // kase = 2 if s(k) is negligible and k<p                  // kase = 3 if e[k-1] is negligible' k<p' and                  // s(k)' ...' s(p) are not negligible (qr step).                  // kase = 4 if e(p-1) is negligible (convergence).                    for (k = p - 2; k >= -1; k--)                  {                      if (k == -1)                      {                          break;                      }                      if (Math.Abs(e[k]) <= tiny + eps                          *(Math.Abs(s[k]) + Math.Abs(s[k + 1])))                      {                          e[k] = 0.0;                          break;                      }                  }                  if (k == p - 2)                  {                      kase = 4;                  }                  else                  {                      int ks;                      for (ks = p - 1; ks >= k; ks--)                      {                          if (ks == k)                          {                              break;                          }                          double t = (ks != p ? Math.Abs(e[ks]) : 0.0)                                     + (ks != k + 1 ? Math.Abs(e[ks - 1]) : 0.0);                          if (Math.Abs(s[ks]) <= tiny + eps*t)                          {                              s[ks] = 0.0;                              break;                          }                      }                      if (ks == k)                      {                          kase = 3;                      }                      else if (ks == p - 1)                      {                          kase = 1;                      }                      else                      {                          kase = 2;                          k = ks;                      }                  }                  k++;                    // Perform the task indicated by kase.                    switch (kase)                  {                          // Deflate negligible s(p).                        case 1:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for (int j = p - 2; j >= k; j--)                              {                                  double t = EncogMath.Hypot(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  if (j != k)                                  {                                      f = -sn*e[j - 1];                                      e[j - 1] = cs*e[j - 1];                                  }                                  if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*vmatrix[i][j] + sn*vmatrix[i][p - 1];                                          vmatrix[i][p - 1] = -sn*vmatrix[i][j] + cs*vmatrix[i][p - 1];                                          vmatrix[i][j] = t;                                      }                                  }                              }                          }                          break;                            // Split at negligible s(k).                        case 2:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for (int j = k; j < p; j++)                              {                                  double t = EncogMath.Hypot(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  f = -sn*e[j];                                  e[j] = cs*e[j];                                  if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*umatrix[i][j] + sn*umatrix[i][k - 1];                                          umatrix[i][k - 1] = -sn*umatrix[i][j] + cs*umatrix[i][k - 1];                                          umatrix[i][j] = t;                                      }                                  }                              }                          }                          break;                            // Perform one qr step.                        case 3:                          {                              // Calculate the shift.                                double scale = Math.Max(Math.Max(Math                                                                   .Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))'                                                                        Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math                                                                                                                  .Abs(                                                                                                                      e[k]));                              double sp = s[p - 1]/scale;                              double spm1 = s[p - 2]/scale;                              double epm1 = e[p - 2]/scale;                              double sk = s[k]/scale;                              double ek = e[k]/scale;                              double b = ((spm1 + sp)*(spm1 - sp) + epm1*epm1)/2.0;                              double c = (sp*epm1)*(sp*epm1);                              double shift = 0.0;                              if ((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt(b*b + c);                                  if (b < 0.0)                                  {                                      shift = -shift;                                  }                                  shift = c/(b + shift);                              }                              double f = (sk + sp)*(sk - sp) + shift;                              double g = sk*ek;                                // Chase zeros.                                for (int j = k; j < p - 1; j++)                              {                                  double t = EncogMath.Hypot(f' g);                                  double cs = f/t;                                  double sn = g/t;                                  if (j != k)                                  {                                      e[j - 1] = t;                                  }                                  f = cs*s[j] + sn*e[j];                                  e[j] = cs*e[j] - sn*s[j];                                  g = sn*s[j + 1];                                  s[j + 1] = cs*s[j + 1];                                  if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*vmatrix[i][j] + sn*vmatrix[i][j + 1];                                          vmatrix[i][j + 1] = -sn*vmatrix[i][j] + cs*vmatrix[i][j + 1];                                          vmatrix[i][j] = t;                                      }                                  }                                  t = EncogMath.Hypot(f' g);                                  cs = f/t;                                  sn = g/t;                                  s[j] = t;                                  f = cs*e[j] + sn*s[j + 1];                                  s[j + 1] = -sn*e[j] + cs*s[j + 1];                                  g = sn*e[j + 1];                                  e[j + 1] = cs*e[j + 1];                                  if (wantu && (j < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*umatrix[i][j] + sn*umatrix[i][j + 1];                                          umatrix[i][j + 1] = -sn*umatrix[i][j] + cs*umatrix[i][j + 1];                                          umatrix[i][j] = t;                                      }                                  }                              }                              e[p - 2] = f;                              iter = iter + 1;                          }                          break;                            // Convergence.                        case 4:                          {                              // Make the singular values positive.                                if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                  if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                      {                                          vmatrix[i][k] = -vmatrix[i][k];                                      }                                  }                              }                                // Order the singular values.                                while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                  {                                      break;                                  }                                  double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                  if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = vmatrix[i][k + 1];                                          vmatrix[i][k + 1] = vmatrix[i][k];                                          vmatrix[i][k] = t;                                      }                                  }                                  if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = umatrix[i][k + 1];                                          umatrix[i][k + 1] = umatrix[i][k];                                          umatrix[i][k] = t;                                      }                                  }                                  k++;                              }                              iter = 0;                              p--;                          }                          break;                  }              }
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0)              {                  int k' kase;                    // Here is where a test for too many iterations would go.                    // This section of the program inspects for                  // negligible elements in the s and e arrays. On                  // completion the variables kase and k are set as follows.                    // kase = 1 if s(p) and e[k-1] are negligible and k<p                  // kase = 2 if s(k) is negligible and k<p                  // kase = 3 if e[k-1] is negligible' k<p' and                  // s(k)' ...' s(p) are not negligible (qr step).                  // kase = 4 if e(p-1) is negligible (convergence).                    for (k = p - 2; k >= -1; k--)                  {                      if (k == -1)                      {                          break;                      }                      if (Math.Abs(e[k]) <= tiny + eps                          *(Math.Abs(s[k]) + Math.Abs(s[k + 1])))                      {                          e[k] = 0.0;                          break;                      }                  }                  if (k == p - 2)                  {                      kase = 4;                  }                  else                  {                      int ks;                      for (ks = p - 1; ks >= k; ks--)                      {                          if (ks == k)                          {                              break;                          }                          double t = (ks != p ? Math.Abs(e[ks]) : 0.0)                                     + (ks != k + 1 ? Math.Abs(e[ks - 1]) : 0.0);                          if (Math.Abs(s[ks]) <= tiny + eps*t)                          {                              s[ks] = 0.0;                              break;                          }                      }                      if (ks == k)                      {                          kase = 3;                      }                      else if (ks == p - 1)                      {                          kase = 1;                      }                      else                      {                          kase = 2;                          k = ks;                      }                  }                  k++;                    // Perform the task indicated by kase.                    switch (kase)                  {                          // Deflate negligible s(p).                        case 1:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for (int j = p - 2; j >= k; j--)                              {                                  double t = EncogMath.Hypot(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  if (j != k)                                  {                                      f = -sn*e[j - 1];                                      e[j - 1] = cs*e[j - 1];                                  }                                  if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*vmatrix[i][j] + sn*vmatrix[i][p - 1];                                          vmatrix[i][p - 1] = -sn*vmatrix[i][j] + cs*vmatrix[i][p - 1];                                          vmatrix[i][j] = t;                                      }                                  }                              }                          }                          break;                            // Split at negligible s(k).                        case 2:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for (int j = k; j < p; j++)                              {                                  double t = EncogMath.Hypot(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  f = -sn*e[j];                                  e[j] = cs*e[j];                                  if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*umatrix[i][j] + sn*umatrix[i][k - 1];                                          umatrix[i][k - 1] = -sn*umatrix[i][j] + cs*umatrix[i][k - 1];                                          umatrix[i][j] = t;                                      }                                  }                              }                          }                          break;                            // Perform one qr step.                        case 3:                          {                              // Calculate the shift.                                double scale = Math.Max(Math.Max(Math                                                                   .Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))'                                                                        Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math                                                                                                                  .Abs(                                                                                                                      e[k]));                              double sp = s[p - 1]/scale;                              double spm1 = s[p - 2]/scale;                              double epm1 = e[p - 2]/scale;                              double sk = s[k]/scale;                              double ek = e[k]/scale;                              double b = ((spm1 + sp)*(spm1 - sp) + epm1*epm1)/2.0;                              double c = (sp*epm1)*(sp*epm1);                              double shift = 0.0;                              if ((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt(b*b + c);                                  if (b < 0.0)                                  {                                      shift = -shift;                                  }                                  shift = c/(b + shift);                              }                              double f = (sk + sp)*(sk - sp) + shift;                              double g = sk*ek;                                // Chase zeros.                                for (int j = k; j < p - 1; j++)                              {                                  double t = EncogMath.Hypot(f' g);                                  double cs = f/t;                                  double sn = g/t;                                  if (j != k)                                  {                                      e[j - 1] = t;                                  }                                  f = cs*s[j] + sn*e[j];                                  e[j] = cs*e[j] - sn*s[j];                                  g = sn*s[j + 1];                                  s[j + 1] = cs*s[j + 1];                                  if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*vmatrix[i][j] + sn*vmatrix[i][j + 1];                                          vmatrix[i][j + 1] = -sn*vmatrix[i][j] + cs*vmatrix[i][j + 1];                                          vmatrix[i][j] = t;                                      }                                  }                                  t = EncogMath.Hypot(f' g);                                  cs = f/t;                                  sn = g/t;                                  s[j] = t;                                  f = cs*e[j] + sn*s[j + 1];                                  s[j + 1] = -sn*e[j] + cs*s[j + 1];                                  g = sn*e[j + 1];                                  e[j + 1] = cs*e[j + 1];                                  if (wantu && (j < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*umatrix[i][j] + sn*umatrix[i][j + 1];                                          umatrix[i][j + 1] = -sn*umatrix[i][j] + cs*umatrix[i][j + 1];                                          umatrix[i][j] = t;                                      }                                  }                              }                              e[p - 2] = f;                              iter = iter + 1;                          }                          break;                            // Convergence.                        case 4:                          {                              // Make the singular values positive.                                if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                  if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                      {                                          vmatrix[i][k] = -vmatrix[i][k];                                      }                                  }                              }                                // Order the singular values.                                while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                  {                                      break;                                  }                                  double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                  if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = vmatrix[i][k + 1];                                          vmatrix[i][k + 1] = vmatrix[i][k];                                          vmatrix[i][k] = t;                                      }                                  }                                  if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = umatrix[i][k + 1];                                          umatrix[i][k + 1] = umatrix[i][k];                                          umatrix[i][k] = t;                                      }                                  }                                  k++;                              }                              iter = 0;                              p--;                          }                          break;                  }              }
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0)              {                  int k' kase;                    // Here is where a test for too many iterations would go.                    // This section of the program inspects for                  // negligible elements in the s and e arrays. On                  // completion the variables kase and k are set as follows.                    // kase = 1 if s(p) and e[k-1] are negligible and k<p                  // kase = 2 if s(k) is negligible and k<p                  // kase = 3 if e[k-1] is negligible' k<p' and                  // s(k)' ...' s(p) are not negligible (qr step).                  // kase = 4 if e(p-1) is negligible (convergence).                    for (k = p - 2; k >= -1; k--)                  {                      if (k == -1)                      {                          break;                      }                      if (Math.Abs(e[k]) <= tiny + eps                          *(Math.Abs(s[k]) + Math.Abs(s[k + 1])))                      {                          e[k] = 0.0;                          break;                      }                  }                  if (k == p - 2)                  {                      kase = 4;                  }                  else                  {                      int ks;                      for (ks = p - 1; ks >= k; ks--)                      {                          if (ks == k)                          {                              break;                          }                          double t = (ks != p ? Math.Abs(e[ks]) : 0.0)                                     + (ks != k + 1 ? Math.Abs(e[ks - 1]) : 0.0);                          if (Math.Abs(s[ks]) <= tiny + eps*t)                          {                              s[ks] = 0.0;                              break;                          }                      }                      if (ks == k)                      {                          kase = 3;                      }                      else if (ks == p - 1)                      {                          kase = 1;                      }                      else                      {                          kase = 2;                          k = ks;                      }                  }                  k++;                    // Perform the task indicated by kase.                    switch (kase)                  {                          // Deflate negligible s(p).                        case 1:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for (int j = p - 2; j >= k; j--)                              {                                  double t = EncogMath.Hypot(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  if (j != k)                                  {                                      f = -sn*e[j - 1];                                      e[j - 1] = cs*e[j - 1];                                  }                                  if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*vmatrix[i][j] + sn*vmatrix[i][p - 1];                                          vmatrix[i][p - 1] = -sn*vmatrix[i][j] + cs*vmatrix[i][p - 1];                                          vmatrix[i][j] = t;                                      }                                  }                              }                          }                          break;                            // Split at negligible s(k).                        case 2:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for (int j = k; j < p; j++)                              {                                  double t = EncogMath.Hypot(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  f = -sn*e[j];                                  e[j] = cs*e[j];                                  if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*umatrix[i][j] + sn*umatrix[i][k - 1];                                          umatrix[i][k - 1] = -sn*umatrix[i][j] + cs*umatrix[i][k - 1];                                          umatrix[i][j] = t;                                      }                                  }                              }                          }                          break;                            // Perform one qr step.                        case 3:                          {                              // Calculate the shift.                                double scale = Math.Max(Math.Max(Math                                                                   .Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))'                                                                        Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math                                                                                                                  .Abs(                                                                                                                      e[k]));                              double sp = s[p - 1]/scale;                              double spm1 = s[p - 2]/scale;                              double epm1 = e[p - 2]/scale;                              double sk = s[k]/scale;                              double ek = e[k]/scale;                              double b = ((spm1 + sp)*(spm1 - sp) + epm1*epm1)/2.0;                              double c = (sp*epm1)*(sp*epm1);                              double shift = 0.0;                              if ((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt(b*b + c);                                  if (b < 0.0)                                  {                                      shift = -shift;                                  }                                  shift = c/(b + shift);                              }                              double f = (sk + sp)*(sk - sp) + shift;                              double g = sk*ek;                                // Chase zeros.                                for (int j = k; j < p - 1; j++)                              {                                  double t = EncogMath.Hypot(f' g);                                  double cs = f/t;                                  double sn = g/t;                                  if (j != k)                                  {                                      e[j - 1] = t;                                  }                                  f = cs*s[j] + sn*e[j];                                  e[j] = cs*e[j] - sn*s[j];                                  g = sn*s[j + 1];                                  s[j + 1] = cs*s[j + 1];                                  if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*vmatrix[i][j] + sn*vmatrix[i][j + 1];                                          vmatrix[i][j + 1] = -sn*vmatrix[i][j] + cs*vmatrix[i][j + 1];                                          vmatrix[i][j] = t;                                      }                                  }                                  t = EncogMath.Hypot(f' g);                                  cs = f/t;                                  sn = g/t;                                  s[j] = t;                                  f = cs*e[j] + sn*s[j + 1];                                  s[j + 1] = -sn*e[j] + cs*s[j + 1];                                  g = sn*e[j + 1];                                  e[j + 1] = cs*e[j + 1];                                  if (wantu && (j < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*umatrix[i][j] + sn*umatrix[i][j + 1];                                          umatrix[i][j + 1] = -sn*umatrix[i][j] + cs*umatrix[i][j + 1];                                          umatrix[i][j] = t;                                      }                                  }                              }                              e[p - 2] = f;                              iter = iter + 1;                          }                          break;                            // Convergence.                        case 4:                          {                              // Make the singular values positive.                                if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                  if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                      {                                          vmatrix[i][k] = -vmatrix[i][k];                                      }                                  }                              }                                // Order the singular values.                                while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                  {                                      break;                                  }                                  double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                  if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = vmatrix[i][k + 1];                                          vmatrix[i][k + 1] = vmatrix[i][k];                                          vmatrix[i][k] = t;                                      }                                  }                                  if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = umatrix[i][k + 1];                                          umatrix[i][k + 1] = umatrix[i][k];                                          umatrix[i][k] = t;                                      }                                  }                                  k++;                              }                              iter = 0;                              p--;                          }                          break;                  }              }
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,Rank,The following statement contains a magic number: double eps = Math.Pow(2.0' -52.0);
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,Rank,The following statement contains a magic number: double eps = Math.Pow(2.0' -52.0);
Magic Number,Encog.MathUtil.Matrices.Hessian,HessianCR,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Hessian\HessianCR.cs,Compute,The following statement contains a magic number: _sse = e/2;
Magic Number,Encog.MathUtil.Matrices.Hessian,HessianFD,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Hessian\HessianFD.cs,HessianFD,The following statement contains a magic number: PointsPerSide = 5;
Magic Number,Encog.MathUtil.Matrices.Hessian,HessianFD,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Hessian\HessianFD.cs,Init,The following statement contains a magic number: _pointCount = (PointsPerSide*2) + 1;
Magic Number,Encog.MathUtil.Matrices.Hessian,HessianFD,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Hessian\HessianFD.cs,InternalCompute,The following statement contains a magic number: foreach (IMLDataPair pair in _training)              {                  EngineArray.Fill(derivative' 0);                  IMLData networkOutput = _network.Compute(pair.Input);                  double e = pair.Ideal[outputNeuron] - networkOutput[outputNeuron];                  error.UpdateError(networkOutput[outputNeuron]' pair.Ideal[outputNeuron]);                    int currentWeight = 0;                    // loop over the output weights                  int outputFeedCount = _network.GetLayerTotalNeuronCount(_network.LayerCount - 2);                  for (int i = 0; i < _network.OutputCount; i++)                  {                      for (int j = 0; j < outputFeedCount; j++)                      {                          double jc;                            if (i == outputNeuron)                          {                              jc = ComputeDerivative(pair.Input' outputNeuron'                                  currentWeight' _dStep'                                  networkOutput[outputNeuron]' row);                          }                          else                          {                              jc = 0;                          }                            _gradients[currentWeight] += jc*e;                          derivative[currentWeight] = jc;                          currentWeight++;                      }                  }                    // Loop over every weight in the neural network                  while (currentWeight < _network.Flat.Weights.Length)                  {                      double jc = ComputeDerivative(                          pair.Input' outputNeuron' currentWeight'                          _dStep'                          networkOutput[outputNeuron]' row);                      derivative[currentWeight] = jc;                      _gradients[currentWeight] += jc*e;                      currentWeight++;                  }                    row++;                  UpdateHessian(derivative);              }
Magic Number,Encog.MathUtil.Randomize,BasicRandomizer,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\BasicRandomizer.cs,BasicRandomizer,The following statement contains a magic number: _random = new Random((int) (DateTime.Now.Ticks*100));
Magic Number,Encog.MathUtil.Randomize,Distort,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Distort.cs,Randomize,The following statement contains a magic number: return d + (_factor - (NextDouble()*_factor*2));
Magic Number,Encog.MathUtil.Randomize,EncogRandom,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\EncogRandom.cs,NextGaussian,The following statement contains a magic number: if (haveNextNextGaussian)              {                  haveNextNextGaussian = false;                  return nextNextGaussian;              }              else              {                  double v1' v2' s;                  do                  {                      v1 = 2 * NextDouble() - 1;   // between -1.0 and 1.0                      v2 = 2 * NextDouble() - 1;   // between -1.0 and 1.0                      s = v1 * v1 + v2 * v2;                  } while (s >= 1 || s == 0);                  double multiplier = Math.Sqrt(-2 * Math.Log(s) / s);                  nextNextGaussian = v2 * multiplier;                  haveNextNextGaussian = true;                  return v1 * multiplier;              }
Magic Number,Encog.MathUtil.Randomize,EncogRandom,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\EncogRandom.cs,NextGaussian,The following statement contains a magic number: if (haveNextNextGaussian)              {                  haveNextNextGaussian = false;                  return nextNextGaussian;              }              else              {                  double v1' v2' s;                  do                  {                      v1 = 2 * NextDouble() - 1;   // between -1.0 and 1.0                      v2 = 2 * NextDouble() - 1;   // between -1.0 and 1.0                      s = v1 * v1 + v2 * v2;                  } while (s >= 1 || s == 0);                  double multiplier = Math.Sqrt(-2 * Math.Log(s) / s);                  nextNextGaussian = v2 * multiplier;                  haveNextNextGaussian = true;                  return v1 * multiplier;              }
Magic Number,Encog.MathUtil.Randomize,EncogRandom,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\EncogRandom.cs,NextGaussian,The following statement contains a magic number: if (haveNextNextGaussian)              {                  haveNextNextGaussian = false;                  return nextNextGaussian;              }              else              {                  double v1' v2' s;                  do                  {                      v1 = 2 * NextDouble() - 1;   // between -1.0 and 1.0                      v2 = 2 * NextDouble() - 1;   // between -1.0 and 1.0                      s = v1 * v1 + v2 * v2;                  } while (s >= 1 || s == 0);                  double multiplier = Math.Sqrt(-2 * Math.Log(s) / s);                  nextNextGaussian = v2 * multiplier;                  haveNextNextGaussian = true;                  return v1 * multiplier;              }
Magic Number,Encog.MathUtil.Randomize,RandomChoice,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\RandomChoice.cs,RandomChoice,The following statement contains a magic number: if (total == 0.0)              {                  double prob = 1.0 / probabilities.Length;                  for (int i = 0; i < probabilities.Length; i++)                  {                      probabilities[i] = prob;                  }              }              else              {                  double total2 = 0;                  double factor = 1.0 / total;                  for (int i = 0; i < probabilities.Length; i++)                  {                      probabilities[i] = probabilities[i] * factor;                      total2 += probabilities[i];                  }                    if (Math.Abs(1.0 - total2) > 0.02)                  {                      double prob = 1.0 / probabilities.Length;                      for (int i = 0; i < probabilities.Length; i++)                      {                          probabilities[i] = prob;                      }                  }              }
Magic Number,Encog.MathUtil.Randomize.Generate,AbstractBoxMuller,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\AbstractBoxMuller.cs,NextGaussian,The following statement contains a magic number: if (_useLast)              {                  y1 = _y2;                  _useLast = false;              }              else              {                  double x1;                  double x2;                  double w;                  do                  {                      x1 = 2.0 * NextDouble() - 1.0;                      x2 = 2.0 * NextDouble() - 1.0;                      w = x1 * x1 + x2 * x2;                  } while (w >= 1.0);                    w = Math.Sqrt((-2.0 * Math.Log(w)) / w);                  y1 = x1 * w;                  _y2 = x2 * w;                  _useLast = true;              }
Magic Number,Encog.MathUtil.Randomize.Generate,AbstractBoxMuller,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\AbstractBoxMuller.cs,NextGaussian,The following statement contains a magic number: if (_useLast)              {                  y1 = _y2;                  _useLast = false;              }              else              {                  double x1;                  double x2;                  double w;                  do                  {                      x1 = 2.0 * NextDouble() - 1.0;                      x2 = 2.0 * NextDouble() - 1.0;                      w = x1 * x1 + x2 * x2;                  } while (w >= 1.0);                    w = Math.Sqrt((-2.0 * Math.Log(w)) / w);                  y1 = x1 * w;                  _y2 = x2 * w;                  _useLast = true;              }
Magic Number,Encog.MathUtil.Randomize.Generate,AbstractBoxMuller,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\AbstractBoxMuller.cs,NextGaussian,The following statement contains a magic number: if (_useLast)              {                  y1 = _y2;                  _useLast = false;              }              else              {                  double x1;                  double x2;                  double w;                  do                  {                      x1 = 2.0 * NextDouble() - 1.0;                      x2 = 2.0 * NextDouble() - 1.0;                      w = x1 * x1 + x2 * x2;                  } while (w >= 1.0);                    w = Math.Sqrt((-2.0 * Math.Log(w)) / w);                  y1 = x1 * w;                  _y2 = x2 * w;                  _useLast = true;              }
Magic Number,Encog.MathUtil.Randomize.Generate,BasicGenerateRandom,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\BasicGenerateRandom.cs,NextBoolean,The following statement contains a magic number: return _rnd.NextDouble() > 0.5;
Magic Number,Encog.MathUtil.Randomize.Generate,LinearCongruentialRandom,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\LinearCongruentialRandom.cs,NextBoolean,The following statement contains a magic number: return NextDouble() > 0.5;
Magic Number,Encog.MathUtil.Randomize.Generate,MersenneTwisterGenerateRandom,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\MersenneTwisterGenerateRandom.cs,SetSeed,The following statement contains a magic number: _mag01 = new UInt32[2];
Magic Number,Encog.MathUtil.Randomize.Generate,MersenneTwisterGenerateRandom,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\MersenneTwisterGenerateRandom.cs,SetSeed,The following statement contains a magic number: for (_mti = 1; _mti < N; _mti++)              {                  _stateVector[_mti] =                          (1812433253 * (_stateVector[_mti - 1] ^ (_stateVector[_mti - 1] >> 30)) + _mti);              }
Magic Number,Encog.MathUtil.Randomize.Generate,MersenneTwisterGenerateRandom,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\MersenneTwisterGenerateRandom.cs,SetSeed,The following statement contains a magic number: for (_mti = 1; _mti < N; _mti++)              {                  _stateVector[_mti] =                          (1812433253 * (_stateVector[_mti - 1] ^ (_stateVector[_mti - 1] >> 30)) + _mti);              }
Magic Number,Encog.MathUtil.Randomize.Generate,MersenneTwisterGenerateRandom,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\MersenneTwisterGenerateRandom.cs,SetSeed,The following statement contains a magic number: SetSeed(19650218);
Magic Number,Encog.MathUtil.Randomize.Generate,MersenneTwisterGenerateRandom,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\MersenneTwisterGenerateRandom.cs,SetSeed,The following statement contains a magic number: for (; k != 0; k--)              {                    _stateVector[i] = (uint)((_stateVector[i] ^ ((_stateVector[i - 1] ^ (_stateVector[i - 1] >> 30)) * 1664525U)) + array[j] + j);                  i++;                  j++;                  if (i >= N)                  {                      _stateVector[0] = _stateVector[N - 1];                      i = 1;                  }                  if (j >= array.Length) j = 0;              }
Magic Number,Encog.MathUtil.Randomize.Generate,MersenneTwisterGenerateRandom,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\MersenneTwisterGenerateRandom.cs,SetSeed,The following statement contains a magic number: for (k = N - 1; k != 0; k--)              {                  _stateVector[i] = (uint)((_stateVector[i] ^ ((_stateVector[i - 1] ^ (_stateVector[i - 1] >> 30)) * 1566083941U)) - i);                  i++;                  if (i >= N)                  {                      _stateVector[0] = _stateVector[N - 1];                      i = 1;                  }              }
Magic Number,Encog.MathUtil.Randomize.Generate,MersenneTwisterGenerateRandom,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\MersenneTwisterGenerateRandom.cs,Next,The following statement contains a magic number: y ^= y >> 11;
Magic Number,Encog.MathUtil.Randomize.Generate,MersenneTwisterGenerateRandom,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\MersenneTwisterGenerateRandom.cs,Next,The following statement contains a magic number: y ^= (y << 7) & TemperingMaskB;
Magic Number,Encog.MathUtil.Randomize.Generate,MersenneTwisterGenerateRandom,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\MersenneTwisterGenerateRandom.cs,Next,The following statement contains a magic number: y ^= (y << 15) & TemperingMaskC;
Magic Number,Encog.MathUtil.Randomize.Generate,MersenneTwisterGenerateRandom,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\MersenneTwisterGenerateRandom.cs,Next,The following statement contains a magic number: y ^= (y >> 18);
Magic Number,Encog.MathUtil.Randomize.Generate,MersenneTwisterGenerateRandom,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\MersenneTwisterGenerateRandom.cs,Next,The following statement contains a magic number: return y >> (32 - bits);
Magic Number,Encog.MathUtil.Randomize.Generate,MersenneTwisterGenerateRandom,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\MersenneTwisterGenerateRandom.cs,NextDouble,The following statement contains a magic number: return (((long)Next(26) << 27) + Next(27))                      / (double)(1L << 53);
Magic Number,Encog.MathUtil.Randomize.Generate,MersenneTwisterGenerateRandom,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\MersenneTwisterGenerateRandom.cs,NextDouble,The following statement contains a magic number: return (((long)Next(26) << 27) + Next(27))                      / (double)(1L << 53);
Magic Number,Encog.MathUtil.Randomize.Generate,MersenneTwisterGenerateRandom,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\MersenneTwisterGenerateRandom.cs,NextDouble,The following statement contains a magic number: return (((long)Next(26) << 27) + Next(27))                      / (double)(1L << 53);
Magic Number,Encog.MathUtil.Randomize.Generate,MersenneTwisterGenerateRandom,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\MersenneTwisterGenerateRandom.cs,NextDouble,The following statement contains a magic number: return (((long)Next(26) << 27) + Next(27))                      / (double)(1L << 53);
Magic Number,Encog.MathUtil.Randomize.Generate,MersenneTwisterGenerateRandom,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\MersenneTwisterGenerateRandom.cs,NextLong,The following statement contains a magic number: uint u1 = Next(32);
Magic Number,Encog.MathUtil.Randomize.Generate,MersenneTwisterGenerateRandom,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\MersenneTwisterGenerateRandom.cs,NextLong,The following statement contains a magic number: uint u2 = Next(32);
Magic Number,Encog.MathUtil.Randomize.Generate,MersenneTwisterGenerateRandom,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\MersenneTwisterGenerateRandom.cs,NextLong,The following statement contains a magic number: return ((long)u1 << 32) + u2;
Magic Number,Encog.MathUtil.Randomize.Generate,MersenneTwisterGenerateRandom,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\MersenneTwisterGenerateRandom.cs,NextBoolean,The following statement contains a magic number: return NextDouble() > 0.5;
Magic Number,Encog.MathUtil.Randomize.Generate,MultiplyWithCarryGenerateRandom,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\MultiplyWithCarryGenerateRandom.cs,NextDouble,The following statement contains a magic number: return (((long)Next(26) << 27) + Next(27))                      / (double)(1L << 53);
Magic Number,Encog.MathUtil.Randomize.Generate,MultiplyWithCarryGenerateRandom,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\MultiplyWithCarryGenerateRandom.cs,NextDouble,The following statement contains a magic number: return (((long)Next(26) << 27) + Next(27))                      / (double)(1L << 53);
Magic Number,Encog.MathUtil.Randomize.Generate,MultiplyWithCarryGenerateRandom,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\MultiplyWithCarryGenerateRandom.cs,NextDouble,The following statement contains a magic number: return (((long)Next(26) << 27) + Next(27))                      / (double)(1L << 53);
Magic Number,Encog.MathUtil.Randomize.Generate,MultiplyWithCarryGenerateRandom,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\MultiplyWithCarryGenerateRandom.cs,NextDouble,The following statement contains a magic number: return (((long)Next(26) << 27) + Next(27))                      / (double)(1L << 53);
Magic Number,Encog.MathUtil.Randomize.Generate,MultiplyWithCarryGenerateRandom,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\MultiplyWithCarryGenerateRandom.cs,Next,The following statement contains a magic number: long d32 = t >> 32;
Magic Number,Encog.MathUtil.Randomize.Generate,MultiplyWithCarryGenerateRandom,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\MultiplyWithCarryGenerateRandom.cs,Next,The following statement contains a magic number: _seed[_n] = 0xFFFFFFFEL - (t & 0xFFFFFFFFL) - (_c - d32 << 32) - _c & 0xFFFFFFFFL;
Magic Number,Encog.MathUtil.Randomize.Generate,MultiplyWithCarryGenerateRandom,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\MultiplyWithCarryGenerateRandom.cs,Next,The following statement contains a magic number: return (int)(result >> 32 - bits);
Magic Number,Encog.MathUtil.Randomize.Generate,MultiplyWithCarryGenerateRandom,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\MultiplyWithCarryGenerateRandom.cs,SetR,The following statement contains a magic number: if (theR <= 0)              {                  theR = 256;              }              else              {                  bool validR = true;                  long a = theR;                  while (a != 1 && validR)                  {                      if (a % 2 != 0)                      {                          theR = 256;                          validR = false;                      }                      a >>= 1;                  }              }
Magic Number,Encog.MathUtil.Randomize.Generate,MultiplyWithCarryGenerateRandom,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\MultiplyWithCarryGenerateRandom.cs,SetR,The following statement contains a magic number: if (theR <= 0)              {                  theR = 256;              }              else              {                  bool validR = true;                  long a = theR;                  while (a != 1 && validR)                  {                      if (a % 2 != 0)                      {                          theR = 256;                          validR = false;                      }                      a >>= 1;                  }              }
Magic Number,Encog.MathUtil.Randomize.Generate,MultiplyWithCarryGenerateRandom,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\MultiplyWithCarryGenerateRandom.cs,SetR,The following statement contains a magic number: if (theR <= 0)              {                  theR = 256;              }              else              {                  bool validR = true;                  long a = theR;                  while (a != 1 && validR)                  {                      if (a % 2 != 0)                      {                          theR = 256;                          validR = false;                      }                      a >>= 1;                  }              }
Magic Number,Encog.MathUtil.Randomize.Generate,MultiplyWithCarryGenerateRandom,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\MultiplyWithCarryGenerateRandom.cs,NextLong,The following statement contains a magic number: return ((long)Next(32) << 32) + Next(32);
Magic Number,Encog.MathUtil.Randomize.Generate,MultiplyWithCarryGenerateRandom,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\MultiplyWithCarryGenerateRandom.cs,NextLong,The following statement contains a magic number: return ((long)Next(32) << 32) + Next(32);
Magic Number,Encog.MathUtil.Randomize.Generate,MultiplyWithCarryGenerateRandom,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\MultiplyWithCarryGenerateRandom.cs,NextLong,The following statement contains a magic number: return ((long)Next(32) << 32) + Next(32);
Magic Number,Encog.MathUtil.Randomize.Generate,MultiplyWithCarryGenerateRandom,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\MultiplyWithCarryGenerateRandom.cs,NextBoolean,The following statement contains a magic number: return NextDouble() > 0.5;
Magic Number,Encog.MathUtil.Randomize.Generate,SecureGenerateRandom,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\SecureGenerateRandom.cs,NextDouble,The following statement contains a magic number: var result = new byte[8];
Magic Number,Encog.MathUtil.Randomize.Generate,SecureGenerateRandom,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\SecureGenerateRandom.cs,NextBoolean,The following statement contains a magic number: return NextDouble() > 0.5;
Magic Number,Encog.MathUtil.Randomize.Generate,SecureGenerateRandom,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\SecureGenerateRandom.cs,NextFloat,The following statement contains a magic number: var result = new byte[4];
Magic Number,Encog.MathUtil.Randomize.Generate,SecureGenerateRandom,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\SecureGenerateRandom.cs,NextLong,The following statement contains a magic number: var result = new byte[8];
Magic Number,Encog.MathUtil.Randomize.Generate,SecureGenerateRandom,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\SecureGenerateRandom.cs,NextInt,The following statement contains a magic number: var result = new byte[4];
Magic Number,Encog.MathUtil.RBF,MexicanHatFunction,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\RBF\MexicanHatFunction.cs,Calculate,The following statement contains a magic number: for (int i = 0; i < center.Length; i++)              {                  norm += Math.Pow(x[i] - center[i]' 2) / (2.0 * width * width);              }
Magic Number,Encog.MathUtil.RBF,MexicanHatFunction,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\RBF\MexicanHatFunction.cs,Calculate,The following statement contains a magic number: for (int i = 0; i < center.Length; i++)              {                  norm += Math.Pow(x[i] - center[i]' 2) / (2.0 * width * width);              }
Magic Number,Encog.MathUtil.RBF,MexicanHatFunction,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\RBF\MexicanHatFunction.cs,Calculate,The following statement contains a magic number: return Peak*(1 - norm)*Math.Exp(-norm/2);
Magic Number,Encog.MathUtil.RBF,GaussianFunction,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\RBF\GaussianFunction.cs,Calculate,The following statement contains a magic number: for (int i = 0; i < center.Length; i++)              {                  value += Math.Pow(x[i] - center[i]' 2)                           /(2.0*width*width);              }
Magic Number,Encog.MathUtil.RBF,GaussianFunction,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\RBF\GaussianFunction.cs,Calculate,The following statement contains a magic number: for (int i = 0; i < center.Length; i++)              {                  value += Math.Pow(x[i] - center[i]' 2)                           /(2.0*width*width);              }
Magic Number,Encog.ML.Bayesian,BayesianChoice,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Bayesian\BayesianChoice.cs,ToFullString,The following statement contains a magic number: if (!IsIndex)              {                  result.Append(":");                  result.Append(CSVFormat.EgFormat.Format(Min' 4));                  result.Append(" to ");                  result.Append(CSVFormat.EgFormat.Format(Max' 4));              }
Magic Number,Encog.ML.Bayesian,BayesianChoice,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Bayesian\BayesianChoice.cs,ToFullString,The following statement contains a magic number: if (!IsIndex)              {                  result.Append(":");                  result.Append(CSVFormat.EgFormat.Format(Min' 4));                  result.Append(" to ");                  result.Append(CSVFormat.EgFormat.Format(Max' 4));              }
Magic Number,Encog.ML.Bayesian.Parse,ParseProbability,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Bayesian\Parse\ParseProbability.cs,AddEvents,The following statement contains a magic number: while (!done && !parser.EOL())              {                  char ch = parser.Peek();                  if (delim.IndexOf(ch) != -1)                  {                      if (ch == ')' || ch == '|')                          done = true;                        ParsedEvent parsedEvent;                        // deal with a value specified by + or -                      if (l.Length > 0 && l[0] == '+')                      {                          String l2 = l.ToString().Substring(1);                          parsedEvent = new ParsedEvent(l2.Trim());                          parsedEvent.Value = "true";                      }                      else if (l.Length > 0 && l[0] == '-')                      {                          String l2 = l.ToString().Substring(1);                          parsedEvent = new ParsedEvent(l2.Trim());                          parsedEvent.Value = "false";                      }                      else                      {                          String l2 = l.ToString();                          parsedEvent = new ParsedEvent(l2.Trim());                      }                        // parse choices                      if (ch == '[')                      {                          parser.Advance();                          int index = 0;                          while (ch != ']' && !parser.EOL())                          {                                String labelName = parser.ReadToChars(":']");                              if (parser.Peek() == ':')                              {                                  parser.Advance();                                  parser.EatWhiteSpace();                                  double min = double.Parse(parser.ReadToWhiteSpace());                                  parser.EatWhiteSpace();                                  if (!parser.LookAhead("to"' true))                                  {                                      throw new BayesianError("Expected \"to\" in probability choice range.");                                  }                                  parser.Advance(2);                                  double max = CSVFormat.EgFormat.Parse(parser.ReadToChars("']"));                                  parsedEvent.ChoiceList.Add(new ParsedChoice(labelName' min' max));                                }                              else                              {                                  parsedEvent.ChoiceList.Add(new ParsedChoice(labelName' index++));                              }                              parser.EatWhiteSpace();                              ch = parser.Peek();                                if (ch == ''')                              {                                  parser.Advance();                              }                          }                      }                        // deal with a value specified by =                      if (parser.Peek() == '=')                      {                          parser.ReadChar();                          String value = parser.ReadToChars(delim);                          //					BayesianEvent evt = this.network.getEvent(parsedEvent.getLabel());                          parsedEvent.Value = value;                      }                        if (ch == ''')                      {                          parser.Advance();                      }                        if (ch == ']')                      {                          parser.Advance();                      }                        if (parsedEvent.Label.Length > 0)                      {                          results.Add(parsedEvent);                      }                      l.Length = 0;                  }                  else                  {                      parser.Advance();                      l.Append(ch);                  }              }
Magic Number,Encog.ML.Bayesian.Parse,ParseProbability,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Bayesian\Parse\ParseProbability.cs,Parse,The following statement contains a magic number: parser.Advance(2);
Magic Number,Encog.ML.Bayesian.Query,EventState,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Bayesian\Query\EventState.cs,ToString,The following statement contains a magic number: result.Append(Format.FormatDouble(_value' 2));
Magic Number,Encog.ML.Bayesian.Query,EventState,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Bayesian\Query\EventState.cs,ToString,The following statement contains a magic number: result.Append(Format.FormatDouble(CompareValue' 2));
Magic Number,Encog.ML.Bayesian.Table,TableLine,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Bayesian\Table\TableLine.cs,ToString,The following statement contains a magic number: r.Append(Format.FormatDouble(Probability' 2));
Magic Number,Encog.ML.Bayesian.Table,TableLine,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Bayesian\Table\TableLine.cs,ToString,The following statement contains a magic number: foreach (int t in _arguments)              {                  r.Append(Format.FormatDouble(t' 2));                  r.Append(" ");              }
Magic Number,Encog.ML.Data.Buffer,BinaryDataLoader,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Buffer\BinaryDataLoader.cs,External2Binary,The following statement contains a magic number: while (_codec.Read(input' ideal' ref significance))              {                  egb.Write(input);                  egb.Write(ideal);                    currentRecord++;                  lastUpdate++;                  if (lastUpdate >= 10000)                  {                      lastUpdate = 0;                      Status.Report(0' currentRecord' "Importing...");                  }                  egb.Write(significance);              }
Magic Number,Encog.ML.Data.Buffer,BinaryDataLoader,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Buffer\BinaryDataLoader.cs,Binary2External,The following statement contains a magic number: for (int i = 0; i < egb.NumberOfRecords; i++)              {                  for (int j = 0; j < inputCount; j++)                  {                      input[j] = egb.Read();                  }                    for (int j = 0; j < idealCount; j++)                  {                      ideal[j] = egb.Read();                  }                    double significance = egb.Read();                    _codec.Write(input' ideal' significance);                    currentRecord++;                  lastUpdate++;                  if (lastUpdate >= 10000)                  {                      lastUpdate = 0;                      Status.Report(egb.NumberOfRecords' currentRecord'                                    "Exporting...");                  }              }
Magic Number,Encog.ML.Data.Buffer,MemoryDataLoader,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Buffer\MemoryDataLoader.cs,External2Memory,The following statement contains a magic number: while (_codec.Read(input' ideal' ref significance))              {                  IMLData b = null;                    IMLData a = new BasicMLData(input);                    if (_codec.IdealSize > 0)                      b = new BasicMLData(ideal);                    IMLDataPair pair = new BasicMLDataPair(a' b);                  pair.Significance = significance;                  Result.Add(pair);                    currentRecord++;                  lastUpdate++;                  if (lastUpdate >= 10000)                  {                      lastUpdate = 0;                      Status.Report(0' currentRecord' "Importing...");                  }              }
Magic Number,Encog.ML.Data.Dynamic,SlidingWindowMLDataProvider,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Dynamic\Providers\SlidingWindowMLDataProvider.cs,SlidingWindowMLDataProvider,The following statement contains a magic number: if(list.Count < 2) throw new ArgumentException("List is too small."' "list");
Magic Number,Encog.ML.Data.Image,ImageMLData,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Image\ImageMLData.cs,Downsample,The following statement contains a magic number: for (int i = 0; i < sample.Length; i++)              {                  sample[i] = ((sample[i] - 0)                               /(255 - 0))                              *(hi - lo) + lo;              }
Magic Number,Encog.ML.Data.Market.Loader,CSVFinal,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFinal.cs,ReadAndCallLoader,The following statement contains a magic number: while (csv.Next())                  {                      DateTime date = csv.GetDate(0);                      ParsedDate = date;                        if (writeonce)                      {                          Console.WriteLine(@"First parsed date in csv:" + ParsedDate.ToShortDateString());                          Console.WriteLine(@"Stopping at date:" + to.ToShortDateString());                          Console.WriteLine(@"Current DateTime:" + ParsedDate.ToShortDateString() + @" Time:" +                                            ParsedDate.ToShortTimeString() + @"  Asked Start date was " +                                            from.ToShortDateString());                          writeonce = false;                      }                      if (ParsedDate >= from && ParsedDate <= to)                      {                          DateTime datex = csv.GetDate(0);                          double open = csv.GetDouble(1);                          double close = csv.GetDouble(2);                          double high = csv.GetDouble(3);                          double low = csv.GetDouble(4);                          double volume = csv.GetDouble(5);                          double range = Math.Abs(open - close);                          double HighLowRange = Math.Abs(high - low);                          double DirectionalRange = close - open;                          LoadedMarketData data = new LoadedMarketData(datex' symbol);                          data.SetData(MarketDataType.Open' open);                          data.SetData(MarketDataType.High' high);                          data.SetData(MarketDataType.Low' low);                          data.SetData(MarketDataType.Close' close);                          data.SetData(MarketDataType.Volume' volume);                          data.SetData(MarketDataType.RangeHighLow' Math.Round(HighLowRange' 6));                          data.SetData(MarketDataType.RangeOpenClose' Math.Round(range' 6));                          data.SetData(MarketDataType.RangeOpenCloseNonAbsolute' Math.Round(DirectionalRange' 6));                          result.Add(data);                          }                    }
Magic Number,Encog.ML.Data.Market.Loader,CSVFinal,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFinal.cs,ReadAndCallLoader,The following statement contains a magic number: while (csv.Next())                  {                      DateTime date = csv.GetDate(0);                      ParsedDate = date;                        if (writeonce)                      {                          Console.WriteLine(@"First parsed date in csv:" + ParsedDate.ToShortDateString());                          Console.WriteLine(@"Stopping at date:" + to.ToShortDateString());                          Console.WriteLine(@"Current DateTime:" + ParsedDate.ToShortDateString() + @" Time:" +                                            ParsedDate.ToShortTimeString() + @"  Asked Start date was " +                                            from.ToShortDateString());                          writeonce = false;                      }                      if (ParsedDate >= from && ParsedDate <= to)                      {                          DateTime datex = csv.GetDate(0);                          double open = csv.GetDouble(1);                          double close = csv.GetDouble(2);                          double high = csv.GetDouble(3);                          double low = csv.GetDouble(4);                          double volume = csv.GetDouble(5);                          double range = Math.Abs(open - close);                          double HighLowRange = Math.Abs(high - low);                          double DirectionalRange = close - open;                          LoadedMarketData data = new LoadedMarketData(datex' symbol);                          data.SetData(MarketDataType.Open' open);                          data.SetData(MarketDataType.High' high);                          data.SetData(MarketDataType.Low' low);                          data.SetData(MarketDataType.Close' close);                          data.SetData(MarketDataType.Volume' volume);                          data.SetData(MarketDataType.RangeHighLow' Math.Round(HighLowRange' 6));                          data.SetData(MarketDataType.RangeOpenClose' Math.Round(range' 6));                          data.SetData(MarketDataType.RangeOpenCloseNonAbsolute' Math.Round(DirectionalRange' 6));                          result.Add(data);                          }                    }
Magic Number,Encog.ML.Data.Market.Loader,CSVFinal,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFinal.cs,ReadAndCallLoader,The following statement contains a magic number: while (csv.Next())                  {                      DateTime date = csv.GetDate(0);                      ParsedDate = date;                        if (writeonce)                      {                          Console.WriteLine(@"First parsed date in csv:" + ParsedDate.ToShortDateString());                          Console.WriteLine(@"Stopping at date:" + to.ToShortDateString());                          Console.WriteLine(@"Current DateTime:" + ParsedDate.ToShortDateString() + @" Time:" +                                            ParsedDate.ToShortTimeString() + @"  Asked Start date was " +                                            from.ToShortDateString());                          writeonce = false;                      }                      if (ParsedDate >= from && ParsedDate <= to)                      {                          DateTime datex = csv.GetDate(0);                          double open = csv.GetDouble(1);                          double close = csv.GetDouble(2);                          double high = csv.GetDouble(3);                          double low = csv.GetDouble(4);                          double volume = csv.GetDouble(5);                          double range = Math.Abs(open - close);                          double HighLowRange = Math.Abs(high - low);                          double DirectionalRange = close - open;                          LoadedMarketData data = new LoadedMarketData(datex' symbol);                          data.SetData(MarketDataType.Open' open);                          data.SetData(MarketDataType.High' high);                          data.SetData(MarketDataType.Low' low);                          data.SetData(MarketDataType.Close' close);                          data.SetData(MarketDataType.Volume' volume);                          data.SetData(MarketDataType.RangeHighLow' Math.Round(HighLowRange' 6));                          data.SetData(MarketDataType.RangeOpenClose' Math.Round(range' 6));                          data.SetData(MarketDataType.RangeOpenCloseNonAbsolute' Math.Round(DirectionalRange' 6));                          result.Add(data);                          }                    }
Magic Number,Encog.ML.Data.Market.Loader,CSVFinal,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFinal.cs,ReadAndCallLoader,The following statement contains a magic number: while (csv.Next())                  {                      DateTime date = csv.GetDate(0);                      ParsedDate = date;                        if (writeonce)                      {                          Console.WriteLine(@"First parsed date in csv:" + ParsedDate.ToShortDateString());                          Console.WriteLine(@"Stopping at date:" + to.ToShortDateString());                          Console.WriteLine(@"Current DateTime:" + ParsedDate.ToShortDateString() + @" Time:" +                                            ParsedDate.ToShortTimeString() + @"  Asked Start date was " +                                            from.ToShortDateString());                          writeonce = false;                      }                      if (ParsedDate >= from && ParsedDate <= to)                      {                          DateTime datex = csv.GetDate(0);                          double open = csv.GetDouble(1);                          double close = csv.GetDouble(2);                          double high = csv.GetDouble(3);                          double low = csv.GetDouble(4);                          double volume = csv.GetDouble(5);                          double range = Math.Abs(open - close);                          double HighLowRange = Math.Abs(high - low);                          double DirectionalRange = close - open;                          LoadedMarketData data = new LoadedMarketData(datex' symbol);                          data.SetData(MarketDataType.Open' open);                          data.SetData(MarketDataType.High' high);                          data.SetData(MarketDataType.Low' low);                          data.SetData(MarketDataType.Close' close);                          data.SetData(MarketDataType.Volume' volume);                          data.SetData(MarketDataType.RangeHighLow' Math.Round(HighLowRange' 6));                          data.SetData(MarketDataType.RangeOpenClose' Math.Round(range' 6));                          data.SetData(MarketDataType.RangeOpenCloseNonAbsolute' Math.Round(DirectionalRange' 6));                          result.Add(data);                          }                    }
Magic Number,Encog.ML.Data.Market.Loader,CSVFinal,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFinal.cs,ReadAndCallLoader,The following statement contains a magic number: while (csv.Next())                  {                      DateTime date = csv.GetDate(0);                      ParsedDate = date;                        if (writeonce)                      {                          Console.WriteLine(@"First parsed date in csv:" + ParsedDate.ToShortDateString());                          Console.WriteLine(@"Stopping at date:" + to.ToShortDateString());                          Console.WriteLine(@"Current DateTime:" + ParsedDate.ToShortDateString() + @" Time:" +                                            ParsedDate.ToShortTimeString() + @"  Asked Start date was " +                                            from.ToShortDateString());                          writeonce = false;                      }                      if (ParsedDate >= from && ParsedDate <= to)                      {                          DateTime datex = csv.GetDate(0);                          double open = csv.GetDouble(1);                          double close = csv.GetDouble(2);                          double high = csv.GetDouble(3);                          double low = csv.GetDouble(4);                          double volume = csv.GetDouble(5);                          double range = Math.Abs(open - close);                          double HighLowRange = Math.Abs(high - low);                          double DirectionalRange = close - open;                          LoadedMarketData data = new LoadedMarketData(datex' symbol);                          data.SetData(MarketDataType.Open' open);                          data.SetData(MarketDataType.High' high);                          data.SetData(MarketDataType.Low' low);                          data.SetData(MarketDataType.Close' close);                          data.SetData(MarketDataType.Volume' volume);                          data.SetData(MarketDataType.RangeHighLow' Math.Round(HighLowRange' 6));                          data.SetData(MarketDataType.RangeOpenClose' Math.Round(range' 6));                          data.SetData(MarketDataType.RangeOpenCloseNonAbsolute' Math.Round(DirectionalRange' 6));                          result.Add(data);                          }                    }
Magic Number,Encog.ML.Data.Market.Loader,CSVFinal,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFinal.cs,ReadAndCallLoader,The following statement contains a magic number: while (csv.Next())                  {                      DateTime date = csv.GetDate(0);                      ParsedDate = date;                        if (writeonce)                      {                          Console.WriteLine(@"First parsed date in csv:" + ParsedDate.ToShortDateString());                          Console.WriteLine(@"Stopping at date:" + to.ToShortDateString());                          Console.WriteLine(@"Current DateTime:" + ParsedDate.ToShortDateString() + @" Time:" +                                            ParsedDate.ToShortTimeString() + @"  Asked Start date was " +                                            from.ToShortDateString());                          writeonce = false;                      }                      if (ParsedDate >= from && ParsedDate <= to)                      {                          DateTime datex = csv.GetDate(0);                          double open = csv.GetDouble(1);                          double close = csv.GetDouble(2);                          double high = csv.GetDouble(3);                          double low = csv.GetDouble(4);                          double volume = csv.GetDouble(5);                          double range = Math.Abs(open - close);                          double HighLowRange = Math.Abs(high - low);                          double DirectionalRange = close - open;                          LoadedMarketData data = new LoadedMarketData(datex' symbol);                          data.SetData(MarketDataType.Open' open);                          data.SetData(MarketDataType.High' high);                          data.SetData(MarketDataType.Low' low);                          data.SetData(MarketDataType.Close' close);                          data.SetData(MarketDataType.Volume' volume);                          data.SetData(MarketDataType.RangeHighLow' Math.Round(HighLowRange' 6));                          data.SetData(MarketDataType.RangeOpenClose' Math.Round(range' 6));                          data.SetData(MarketDataType.RangeOpenCloseNonAbsolute' Math.Round(DirectionalRange' 6));                          result.Add(data);                          }                    }
Magic Number,Encog.ML.Data.Market.Loader,CSVFinal,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFinal.cs,ReadAndCallLoader,The following statement contains a magic number: while (csv.Next())                  {                      DateTime date = csv.GetDate(0);                      ParsedDate = date;                        if (writeonce)                      {                          Console.WriteLine(@"First parsed date in csv:" + ParsedDate.ToShortDateString());                          Console.WriteLine(@"Stopping at date:" + to.ToShortDateString());                          Console.WriteLine(@"Current DateTime:" + ParsedDate.ToShortDateString() + @" Time:" +                                            ParsedDate.ToShortTimeString() + @"  Asked Start date was " +                                            from.ToShortDateString());                          writeonce = false;                      }                      if (ParsedDate >= from && ParsedDate <= to)                      {                          DateTime datex = csv.GetDate(0);                          double open = csv.GetDouble(1);                          double close = csv.GetDouble(2);                          double high = csv.GetDouble(3);                          double low = csv.GetDouble(4);                          double volume = csv.GetDouble(5);                          double range = Math.Abs(open - close);                          double HighLowRange = Math.Abs(high - low);                          double DirectionalRange = close - open;                          LoadedMarketData data = new LoadedMarketData(datex' symbol);                          data.SetData(MarketDataType.Open' open);                          data.SetData(MarketDataType.High' high);                          data.SetData(MarketDataType.Low' low);                          data.SetData(MarketDataType.Close' close);                          data.SetData(MarketDataType.Volume' volume);                          data.SetData(MarketDataType.RangeHighLow' Math.Round(HighLowRange' 6));                          data.SetData(MarketDataType.RangeOpenClose' Math.Round(range' 6));                          data.SetData(MarketDataType.RangeOpenCloseNonAbsolute' Math.Round(DirectionalRange' 6));                          result.Add(data);                          }                    }
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,button1_Click,The following statement contains a magic number: openFileDialog1.FilterIndex = (2);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,CSVFormLoader_Load,The following statement contains a magic number: CSVFormatsCombo.SelectedIndex = 2;
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.statusStrip1.Location = new System.Drawing.Point(0' 437);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.statusStrip1.Size = new System.Drawing.Size(391' 22);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.statusStrip1.Size = new System.Drawing.Size(391' 22);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.toolStripStatusLabel1.Size = new System.Drawing.Size(44' 17);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.toolStripStatusLabel1.Size = new System.Drawing.Size(44' 17);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.button1.Location = new System.Drawing.Point(100' 335);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.button1.Location = new System.Drawing.Point(100' 335);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.button1.Size = new System.Drawing.Size(121' 37);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.button1.Size = new System.Drawing.Size(121' 37);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.textBox1.Location = new System.Drawing.Point(66' 403);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.textBox1.Location = new System.Drawing.Point(66' 403);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.textBox1.Size = new System.Drawing.Size(267' 20);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.textBox1.Size = new System.Drawing.Size(267' 20);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.textBox1.TabIndex = 2;
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.CSVFormatsCombo.Location = new System.Drawing.Point(100' 6);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.CSVFormatsCombo.Location = new System.Drawing.Point(100' 6);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.CSVFormatsCombo.Size = new System.Drawing.Size(121' 21);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.CSVFormatsCombo.Size = new System.Drawing.Size(121' 21);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.CSVFormatsCombo.TabIndex = 3;
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point(4' 410);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point(4' 410);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size(59' 13);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size(59' 13);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.label1.TabIndex = 4;
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point(4' 14);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point(4' 14);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size(63' 13);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size(63' 13);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.label2.TabIndex = 5;
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.label3.Location = new System.Drawing.Point(4' 359);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.label3.Location = new System.Drawing.Point(4' 359);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.label3.Size = new System.Drawing.Size(55' 13);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.label3.Size = new System.Drawing.Size(55' 13);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.label3.TabIndex = 6;
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.label4.Location = new System.Drawing.Point(4' 68);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.label4.Location = new System.Drawing.Point(4' 68);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.label4.Size = new System.Drawing.Size(87' 13);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.label4.Size = new System.Drawing.Size(87' 13);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.label4.TabIndex = 7;
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.MarketDataTypesListBox.Location = new System.Drawing.Point(100' 52);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.MarketDataTypesListBox.Location = new System.Drawing.Point(100' 52);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.MarketDataTypesListBox.Size = new System.Drawing.Size(120' 95);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.MarketDataTypesListBox.Size = new System.Drawing.Size(120' 95);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.MarketDataTypesListBox.TabIndex = 8;
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.DateTimeFormatTextBox.Location = new System.Drawing.Point(100' 231);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.DateTimeFormatTextBox.Location = new System.Drawing.Point(100' 231);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.DateTimeFormatTextBox.Size = new System.Drawing.Size(229' 20);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.DateTimeFormatTextBox.Size = new System.Drawing.Size(229' 20);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.DateTimeFormatTextBox.TabIndex = 11;
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.label5.Location = new System.Drawing.Point(7' 237);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.label5.Location = new System.Drawing.Point(7' 237);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.label5.Size = new System.Drawing.Size(85' 13);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.label5.Size = new System.Drawing.Size(85' 13);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.label5.TabIndex = 12;
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.FileColumnsLabel.Location = new System.Drawing.Point(4' 170);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.FileColumnsLabel.Location = new System.Drawing.Point(4' 170);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.FileColumnsLabel.Size = new System.Drawing.Size(78' 13);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.FileColumnsLabel.Size = new System.Drawing.Size(78' 13);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.FileColumnsLabel.TabIndex = 9;
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.ColumnsInCSVTextBox.Location = new System.Drawing.Point(100' 170);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.ColumnsInCSVTextBox.Location = new System.Drawing.Point(100' 170);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.ColumnsInCSVTextBox.Size = new System.Drawing.Size(229' 20);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.ColumnsInCSVTextBox.Size = new System.Drawing.Size(229' 20);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.ColumnsInCSVTextBox.TabIndex = 10;
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(391' 459);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(391' 459);
Magic Number,Encog.ML.Data.Versatile.Columns,ColumnDefinition,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Versatile\Columns\ColumnDefinition.cs,ToString,The following statement contains a magic number: if (DataType == ColumnType.Continuous)              {                  result.Append(";low=");                  result.Append(Format.FormatDouble(Low' 6));                  result.Append("'high=");                  result.Append(Format.FormatDouble(High' 6));                  result.Append("'mean=");                  result.Append(Format.FormatDouble(Mean' 6));                  result.Append("'sd=");                  result.Append(Format.FormatDouble(Sd' 6));              }              else              {                  result.Append(";");                  result.Append(_classes);              }
Magic Number,Encog.ML.Data.Versatile.Columns,ColumnDefinition,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Versatile\Columns\ColumnDefinition.cs,ToString,The following statement contains a magic number: if (DataType == ColumnType.Continuous)              {                  result.Append(";low=");                  result.Append(Format.FormatDouble(Low' 6));                  result.Append("'high=");                  result.Append(Format.FormatDouble(High' 6));                  result.Append("'mean=");                  result.Append(Format.FormatDouble(Mean' 6));                  result.Append("'sd=");                  result.Append(Format.FormatDouble(Sd' 6));              }              else              {                  result.Append(";");                  result.Append(_classes);              }
Magic Number,Encog.ML.Data.Versatile.Columns,ColumnDefinition,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Versatile\Columns\ColumnDefinition.cs,ToString,The following statement contains a magic number: if (DataType == ColumnType.Continuous)              {                  result.Append(";low=");                  result.Append(Format.FormatDouble(Low' 6));                  result.Append("'high=");                  result.Append(Format.FormatDouble(High' 6));                  result.Append("'mean=");                  result.Append(Format.FormatDouble(Mean' 6));                  result.Append("'sd=");                  result.Append(Format.FormatDouble(Sd' 6));              }              else              {                  result.Append(";");                  result.Append(_classes);              }
Magic Number,Encog.ML.Data.Versatile.Columns,ColumnDefinition,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Versatile\Columns\ColumnDefinition.cs,ToString,The following statement contains a magic number: if (DataType == ColumnType.Continuous)              {                  result.Append(";low=");                  result.Append(Format.FormatDouble(Low' 6));                  result.Append("'high=");                  result.Append(Format.FormatDouble(High' 6));                  result.Append("'mean=");                  result.Append(Format.FormatDouble(Mean' 6));                  result.Append("'sd=");                  result.Append(Format.FormatDouble(Sd' 6));              }              else              {                  result.Append(";");                  result.Append(_classes);              }
Magic Number,Encog.ML.Data.Versatile.Normalizers,RangeNormalizer,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Versatile\Normalizers\RangeNormalizer.cs,NormalizeColumn,The following statement contains a magic number: if (Double.IsNaN(result))              {                  result = ((_normalizedHigh - _normalizedLow)/2) + _normalizedLow;              }
Magic Number,Encog.ML.Data.Versatile.Normalizers,RangeNormalizer,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Versatile\Normalizers\RangeNormalizer.cs,DenormalizeColumn,The following statement contains a magic number: if (Double.IsNaN(result))              {                  return "" + (((_normalizedHigh - _normalizedLow)/2) + _normalizedLow);              }
Magic Number,Encog.ML.Data.Versatile.Normalizers,RangeOrdinal,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Versatile\Normalizers\RangeOrdinal.cs,NormalizeColumn,The following statement contains a magic number: if (Double.IsNaN(result))              {                  result = ((_normalizedHigh - _normalizedLow)/2)                           + _normalizedLow;              }
Magic Number,Encog.ML.EA.Species,BasicSpecies,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\EA\Species\BasicSpecies.cs,ToString,The following statement contains a magic number: result.Append(Format.FormatDouble(BestScore' 2));
Magic Number,Encog.ML.EA.Species,ThresholdSpeciation,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\EA\Species\ThresholdSpeciation.cs,AdjustCompatibilityThreshold,The following statement contains a magic number: const double thresholdIncrement = 0.01;
Magic Number,Encog.ML.EA.Species,ThresholdSpeciation,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\EA\Species\ThresholdSpeciation.cs,AdjustCompatibilityThreshold,The following statement contains a magic number: if (_population.Species.Count > _maxNumberOfSpecies)              {                  _compatibilityThreshold += thresholdIncrement;              }                else if (_population.Species.Count < 2)              {                  _compatibilityThreshold -= thresholdIncrement;              }
Magic Number,Encog.ML.EA.Train,BasicEA,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\EA\Train\BasicEA.cs,BasicEA,The following statement contains a magic number: EliteRate = 0.3;
Magic Number,Encog.ML.EA.Train,BasicEA,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\EA\Train\BasicEA.cs,BasicEA,The following statement contains a magic number: MaxTries = 5;
Magic Number,Encog.ML.EA.Train,BasicEA,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\EA\Train\BasicEA.cs,BasicEA,The following statement contains a magic number: MaxOperationErrors = 500;
Magic Number,Encog.ML.EA.Train,BasicEA,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\EA\Train\BasicEA.cs,BasicEA,The following statement contains a magic number: Selection = new TournamentSelection(this' 4);
Magic Number,Encog.ML.EA.Train,BasicEA,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\EA\Train\BasicEA.cs,Iteration,The following statement contains a magic number: foreach (ISpecies species in Population.Species)             {                 int numToSpawn = species.OffspringCount;                  // Add elite genomes directly                 if (species.Members.Count > 5)                 {                     var idealEliteCount = (int) (species.Members.Count*EliteRate);                     int eliteCount = Math.Min(numToSpawn' idealEliteCount);                     for (int i = 0; i < eliteCount; i++)                     {                         IGenome eliteGenome = species.Members[i];                         if (_oldBestGenome != eliteGenome)                         {                             numToSpawn--;                             if (!AddChild(eliteGenome))                             {                                 break;                             }                         }                     }                 }                  // now add one task for each offspring that each species is allowed                 while (numToSpawn-- > 0)                 {                     var worker = new EAWorker(this' species);                     threadList.Add(worker);                 }             }
Magic Number,Encog.ML.EA.Train,EAWorker,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\EA\Train\EAWorker.cs,PerformTask,The following statement contains a magic number: do              {                  try                  {                      // choose an evolutionary operation (i.e. crossover or a type of                      // mutation) to use                      IEvolutionaryOperator opp = _train.Operators                                                       .PickMaxParents(_rnd'                                                                       _species.Members.Count);                        _children[0] = null;                        // prepare for either sexual or asexual reproduction either way'                      // we need at least one parent' which is the first parent.                      //                      // Chose the first parent' there must be at least one genome in                      // this species                      _parents[0] = ChooseParent();                        // if the number of individuals in this species is only                      // one then we can only clone and perhaps mutate' otherwise use                      // the crossover probability to determine if we are to use                      // sexual reproduction.                      if (opp.ParentsNeeded > 1)                      {                          int numAttempts = 5;                            _parents[1] = ChooseParent();                          while (_parents[0] == _parents[1]                                 && numAttempts-- > 0)                          {                              _parents[1] = ChooseParent();                          }                            // success' perform crossover                          if (_parents[0] != _parents[1])                          {                              opp.PerformOperation(_rnd' _parents' 0'                                                   _children' 0);                          }                      }                      else                      {                          // clone a child (asexual reproduction)                          opp.PerformOperation(_rnd' _parents' 0'                                               _children' 0);                          _children[0].Population = _parents[0].Population;                      }                        // process the new child                      foreach (IGenome child in _children)                      {                          if (child != null)                          {                              child.Population = _parents[0].Population;                              if (_train.Rules.IsValid(child))                              {                                  child.BirthGeneration = _train.IterationNumber;                                    _train.CalculateScore(child);                                  if (!_train.AddChild(child))                                  {                                      return;                                  }                                  success = true;                              }                          }                      }                  }                  catch (EARuntimeError)                  {                      tries--;                      if (tries < 0)                      {                          throw new EncogError(                              "Could not perform a successful genetic operaton after "                              + _train.MaxOperationErrors                              + " tries.");                      }                  }                  catch (Exception t)                  {                      if (!_train.IgnoreExceptions)                      {                          throw;                      }                  }              } while (!success);
Magic Number,Encog.ML.Factory.Method,EPLFactory,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Factory\Method\EPLFactory.cs,Create,The following statement contains a magic number: int populationSize = holder.GetInt(                      MLMethodFactory.PropertyPopulationSize' false' 1000);
Magic Number,Encog.ML.Factory.Method,EPLFactory,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Factory\Method\EPLFactory.cs,Create,The following statement contains a magic number: if (context.Functions.Count > 0)              {                  (new RampedHalfAndHalf(context' 2' 6)).Generate(new EncogRandom()' pop);              }
Magic Number,Encog.ML.Factory.Method,EPLFactory,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Factory\Method\EPLFactory.cs,Create,The following statement contains a magic number: if (context.Functions.Count > 0)              {                  (new RampedHalfAndHalf(context' 2' 6)).Generate(new EncogRandom()' pop);              }
Magic Number,Encog.ML.Factory.Method,FeedforwardFactory,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Factory\Method\FeedforwardFactory.cs,Create,The following statement contains a magic number: foreach (String layerStr  in  layers)              {                  // determine default                  int defaultCount = questionPhase == 0 ? input : output;                    ArchitectureLayer layer = ArchitectureParse.ParseLayer(                      layerStr' defaultCount);                  bool bias = layer.Bias;                    String part = layer.Name;                  part = part != null ? part.Trim() : "";                    IActivationFunction lookup = _factory.Create(part);  			  			    if (lookup!=null)                   {  				    af = lookup;  			    }                   else                   {                      if (layer.UsedDefault)                      {                          questionPhase++;                          if (questionPhase > 2)                          {                              throw new EncogError("Only two ?'s may be used.");                          }                      }                        if (layer.Count == 0)                      {                          throw new EncogError("Unknown architecture element: "                                               + architecture + "' can't parse: " + part);                      }                        result.AddLayer(new BasicLayer(af' bias' layer.Count));                  }              }
Magic Number,Encog.ML.Factory.Method,NEATFactory,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Factory\Method\NEATFactory.cs,Create,The following statement contains a magic number: int populationSize = holder.GetInt(                      MLMethodFactory.PropertyPopulationSize' false' 1000);
Magic Number,Encog.ML.Factory.Method,PNNFactory,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Factory\Method\PNNFactory.cs,Create,The following statement contains a magic number: ArchitectureLayer outputLayer = ArchitectureParse.ParseLayer(                  layers[2]' output);
Magic Number,Encog.ML.Factory.Method,RBFNetworkFactory,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Factory\Method\RBFNetworkFactory.cs,Create,The following statement contains a magic number: ArchitectureLayer outputLayer = ArchitectureParse.ParseLayer(                  layers[2]' output);
Magic Number,Encog.ML.Factory.Method,SOMFactory,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Factory\Method\SOMFactory.cs,Create,The following statement contains a magic number: if (layers.Count != 2)              {                  throw new EncogError(                      "SOM's must have exactly two elements' separated by ->.");              }
Magic Number,Encog.ML.Factory.Method,SRNFactory,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Factory\Method\SRNFactory.cs,Create,The following statement contains a magic number: ArchitectureLayer outputLayer = ArchitectureParse.ParseLayer(                  layers[2]' output);
Magic Number,Encog.ML.Factory.Method,SVMFactory,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Factory\Method\SVMFactory.cs,Create,The following statement contains a magic number: ArchitectureLayer outputLayer = ArchitectureParse.ParseLayer(                  layers[2]' output);
Magic Number,Encog.ML.Factory.Parse,ArchitectureParse,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Factory\Parse\ArchitectureParse.cs,ParseLayer,The following statement contains a magic number: if (check.EndsWith(":B"))              {                  check = check.Substring(0' (check.Length - 2) - (0));                  layer.Bias = true;              }
Magic Number,Encog.ML.Factory.Parse,ArchitectureParse,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Factory\Parse\ArchitectureParse.cs,ParseLayers,The following statement contains a magic number: do              {                  String part;                  int index = line.IndexOf("->"' bs);                  if (index != -1)                  {                      part = line.Substring(bs' (index) - (bs)).Trim();                      bs = index + 2;                  }                  else                  {                      part = line.Substring(bs).Trim();                      done = true;                  }                    bool bias = part.EndsWith("b");                  if (bias)                  {                      part = part.Substring(0' (part.Length - 1) - (0));                  }                    result.Add(part);              } while (!done);
Magic Number,Encog.ML.Factory.Train,AnnealFactory,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Factory\Train\AnnealFactory.cs,Create,The following statement contains a magic number: double startTemp = holder.GetDouble(                  MLTrainFactory.PropertyTemperatureStart' false' 10);
Magic Number,Encog.ML.Factory.Train,AnnealFactory,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Factory\Train\AnnealFactory.cs,Create,The following statement contains a magic number: double stopTemp = holder.GetDouble(                  MLTrainFactory.PropertyTemperatureStop' false' 2);
Magic Number,Encog.ML.Factory.Train,AnnealFactory,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Factory\Train\AnnealFactory.cs,Create,The following statement contains a magic number: int cycles = holder.GetInt(MLTrainFactory.Cycles' false' 100);
Magic Number,Encog.ML.Factory.Train,EPLGAFactory,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Factory\Train\EPLGAFactory.cs,Create,The following statement contains a magic number: train.AddOperation(0.8' new SubtreeCrossover());
Magic Number,Encog.ML.Factory.Train,EPLGAFactory,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Factory\Train\EPLGAFactory.cs,Create,The following statement contains a magic number: train.AddOperation(0.1' new SubtreeMutation(pop.Context' 4));
Magic Number,Encog.ML.Factory.Train,EPLGAFactory,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Factory\Train\EPLGAFactory.cs,Create,The following statement contains a magic number: train.AddOperation(0.1' new SubtreeMutation(pop.Context' 4));
Magic Number,Encog.ML.Factory.Train,EPLGAFactory,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Factory\Train\EPLGAFactory.cs,Create,The following statement contains a magic number: train.AddOperation(0.1' new ConstMutation(pop.Context' 0.5' 1.0));
Magic Number,Encog.ML.Factory.Train,EPLGAFactory,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Factory\Train\EPLGAFactory.cs,Create,The following statement contains a magic number: train.AddOperation(0.1' new ConstMutation(pop.Context' 0.5' 1.0));
Magic Number,Encog.ML.Factory.Train,GeneticFactory,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Factory\Train\GeneticFactory.cs,Create,The following statement contains a magic number: int populationSize = holder.GetInt(  				MLTrainFactory.PropertyPopulationSize' false' 5000);
Magic Number,Encog.ML.Factory.Train,NeighborhoodSOMFactory,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Factory\Train\NeighborhoodSOMFactory.cs,Create,The following statement contains a magic number: if (args.ContainsKey(MLTrainFactory.PropertyIterations))              {                  int plannedIterations = holder.GetInt(                      MLTrainFactory.PropertyIterations' false' 1000);                  double startRate = holder.GetDouble(                      MLTrainFactory.PropertyStartLearningRate' false' 0.05d);                  double endRate = holder.GetDouble(                      MLTrainFactory.PropertyEndLearningRate' false' 0.05d);                  double startRadius = holder.GetDouble(                      MLTrainFactory.PropertyStartRadius' false' 10);                  double endRadius = holder.GetDouble(                      MLTrainFactory.PropertyEndRadius' false' 1);                  result.SetAutoDecay(plannedIterations' startRate' endRate'                                      startRadius' endRadius);              }
Magic Number,Encog.ML.Factory.Train,NeighborhoodSOMFactory,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Factory\Train\NeighborhoodSOMFactory.cs,Create,The following statement contains a magic number: if (args.ContainsKey(MLTrainFactory.PropertyIterations))              {                  int plannedIterations = holder.GetInt(                      MLTrainFactory.PropertyIterations' false' 1000);                  double startRate = holder.GetDouble(                      MLTrainFactory.PropertyStartLearningRate' false' 0.05d);                  double endRate = holder.GetDouble(                      MLTrainFactory.PropertyEndLearningRate' false' 0.05d);                  double startRadius = holder.GetDouble(                      MLTrainFactory.PropertyStartRadius' false' 10);                  double endRadius = holder.GetDouble(                      MLTrainFactory.PropertyEndRadius' false' 1);                  result.SetAutoDecay(plannedIterations' startRate' endRate'                                      startRadius' endRadius);              }
Magic Number,Encog.ML.Factory.Train,PSOFactory,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Factory\Train\PSOFactory.cs,Create,The following statement contains a magic number: int particles = holder.GetInt(                      MLTrainFactory.PropertyParticles' false' 20);
Magic Number,Encog.ML.Factory.Train,QuickPropFactory,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Factory\Train\QuickPropFactory.cs,Create,The following statement contains a magic number: double learningRate = holder.GetDouble(                  MLTrainFactory.PropertyLearningRate' false' 2.0);
Magic Number,Encog.ML.Genetic,MLMethodGeneticAlgorithm,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Genetic\MLMethodGeneticAlgorithm.cs,MLMethodGeneticAlgorithm,The following statement contains a magic number: int s = Math                      .Max(defaultSpecies.Members[0].Size / 5' 1);
Magic Number,Encog.ML.Genetic,MLMethodGeneticAlgorithm,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Genetic\MLMethodGeneticAlgorithm.cs,MLMethodGeneticAlgorithm,The following statement contains a magic number: this.genetic.AddOperation(0.9' new Splice(s));
Magic Number,Encog.ML.Genetic,MLMethodGeneticAlgorithm,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Genetic\MLMethodGeneticAlgorithm.cs,MLMethodGeneticAlgorithm,The following statement contains a magic number: this.genetic.AddOperation(0.1' new MutatePerturb(1.0));
Magic Number,Encog.ML.Genetic.Mutate,MutatePerturb,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Genetic\Mutate\MutatePerturb.cs,PerformOperation,The following statement contains a magic number: for (int i = 0; i < parent.Size; i++)              {                  double value = parent.Data[i];                  value += (perturbAmount - (rnd.NextDouble() * perturbAmount * 2));                  child.Data[i] = value;              }
Magic Number,Encog.ML.HMM.Alog,ForwardBackwardCalculator,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\HMM\Alog\ForwardBackwardCalculator.cs,ComputeBeta,The following statement contains a magic number: for (var t = (int) (oseq.Count - 2); t >= 0; t--)              {                  for (int i = 0; i < hmm.StateCount; i++)                  {                      ComputeBetaStep(hmm' oseq[t + 1]' t' i);                  }              }
Magic Number,Encog.ML.HMM.Alog,ForwardBackwardScaledCalculator,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\HMM\Alog\ForwardBackwardScaledCalculator.cs,ComputeBeta,The following statement contains a magic number: for (var t = (int) (oseq.Count - 2); t >= 0; t--)              {                  for (int i = 0; i < hmm.StateCount; i++)                  {                      ComputeBetaStep(hmm' oseq[t + 1]' t' i);                      Beta[t][i] /= _ctFactors[t];                  }              }
Magic Number,Encog.ML.HMM.Alog,KullbackLeiblerDistanceCalculator,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\HMM\Alog\KullbackLeiblerDistanceCalculator.cs,KullbackLeiblerDistanceCalculator,The following statement contains a magic number: Len = 1000;
Magic Number,Encog.ML.HMM.Alog,KullbackLeiblerDistanceCalculator,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\HMM\Alog\KullbackLeiblerDistanceCalculator.cs,KullbackLeiblerDistanceCalculator,The following statement contains a magic number: SequenceCount = 10;
Magic Number,Encog.ML.HMM.Alog,ViterbiCalculator,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\HMM\Alog\ViterbiCalculator.cs,ViterbiCalculator,The following statement contains a magic number: for (int t2 = (int)(oseq.Count - 2); t2 >= 0; t2--)              {                  _stateSequence[t2] = this.psy[t2 + 1][_stateSequence[t2 + 1]];              }
Magic Number,Encog.ML.HMM.Distributions,ContinousDistribution,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\HMM\Distributions\ContinousDistribution.cs,Probability,The following statement contains a magic number: double expArg = MatrixMath.Multiply(MatrixMath.Transpose(vmm)' t)                                  [0' 0] * -0.5;
Magic Number,Encog.ML.HMM.Distributions,ContinousDistribution,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\HMM\Distributions\ContinousDistribution.cs,Probability,The following statement contains a magic number: return Math.Exp(expArg)                     / (Math.Pow(2.0 * Math.PI' _dimension / 2.0) * Math.Pow(                         _covarianceDet' 0.5));
Magic Number,Encog.ML.HMM.Distributions,ContinousDistribution,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\HMM\Distributions\ContinousDistribution.cs,Probability,The following statement contains a magic number: return Math.Exp(expArg)                     / (Math.Pow(2.0 * Math.PI' _dimension / 2.0) * Math.Pow(                         _covarianceDet' 0.5));
Magic Number,Encog.ML.HMM.Distributions,ContinousDistribution,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\HMM\Distributions\ContinousDistribution.cs,Probability,The following statement contains a magic number: return Math.Exp(expArg)                     / (Math.Pow(2.0 * Math.PI' _dimension / 2.0) * Math.Pow(                         _covarianceDet' 0.5));
Magic Number,Encog.ML.HMM.Train.KMeans,TrainKMeans,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\HMM\Train\KMeans\TrainKMeans.cs,LearnTransition,The following statement contains a magic number: foreach (IMLDataSet obsSeq in _training.Sequences)              {                  if (obsSeq.Count < 2)                  {                      continue;                  }                    int secondState = _clusters.Cluster(obsSeq[0]);                  for (int i = 1; i < obsSeq.Count; i++)                  {                      int firstState = secondState;                      secondState = _clusters.Cluster(obsSeq[i]);                        hmm.TransitionProbability[firstState][secondState] =                          hmm.TransitionProbability[firstState][secondState] + 1.0;                  }              }
Magic Number,Encog.ML.Model.Config,FeedforwardConfig,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Model\Config\FeedforwardConfig.cs,SuggestModelArchitecture,The following statement contains a magic number: var hiddenCount = (int) ((inputColumns + outputColumns)*1.5);
Magic Number,Encog.ML.Model.Config,FeedforwardConfig,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Model\Config\FeedforwardConfig.cs,SuggestNormalizationStrategy,The following statement contains a magic number: double[] d = {-1000' -100' -50};
Magic Number,Encog.ML.Model.Config,FeedforwardConfig,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Model\Config\FeedforwardConfig.cs,SuggestNormalizationStrategy,The following statement contains a magic number: double[] d = {-1000' -100' -50};
Magic Number,Encog.ML.Model.Config,FeedforwardConfig,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Model\Config\FeedforwardConfig.cs,SuggestNormalizationStrategy,The following statement contains a magic number: double[] d = {-1000' -100' -50};
Magic Number,Encog.ML.Model.Config,FeedforwardConfig,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Model\Config\FeedforwardConfig.cs,SuggestNormalizationStrategy,The following statement contains a magic number: if (d[0] > 0 && d[1] > 0 && d[2] > 0)              {                  inputLow = 0;              }
Magic Number,Encog.ML.Model.Config,RBFNetworkConfig,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Model\Config\RBFNetworkConfig.cs,SuggestModelArchitecture,The following statement contains a magic number: var hiddenCount = (int) ((inputColumns + outputColumns)*1.5);
Magic Number,Encog.ML.Model,EncogModel,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Model\EncogModel.cs,FitFold,The following statement contains a magic number: if (train.ImplementationType == TrainingImplementationType.Iterative)              {                  var earlyStop = new SimpleEarlyStoppingStrategy(                      fold.Validation);                  train.AddStrategy(earlyStop);                    var line = new StringBuilder();                  while (!train.TrainingDone)                  {                      train.Iteration();                      line.Length = 0;                      line.Append("Fold #");                      line.Append(foldNum);                      line.Append("/");                      line.Append(k);                      line.Append(": Iteration #");                      line.Append(train.IterationNumber);                      line.Append("' Training Error: ");                      line.Append(Format.FormatDouble(train.Error' 8));                      line.Append("' Validation Error: ");                      line.Append(Format.FormatDouble(earlyStop.ValidationError'                          8));                      Report.Report(k' foldNum' line.ToString());                  }                  fold.Score = earlyStop.ValidationError;                  fold.Method = method;              }              else if (train.ImplementationType == TrainingImplementationType.OnePass)              {                  train.Iteration();                  double validationError = CalculateError(method'                      fold.Validation);                  Report.Report(k' k'                      "Trained' Training Error: " + train.Error                      + "' Validatoin Error: " + validationError);                  fold.Score = validationError;                  fold.Method = method;              }              else              {                  throw new EncogError("Unsupported training type for EncogModel: "                                       + train.ImplementationType);              }
Magic Number,Encog.ML.Model,EncogModel,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Model\EncogModel.cs,FitFold,The following statement contains a magic number: if (train.ImplementationType == TrainingImplementationType.Iterative)              {                  var earlyStop = new SimpleEarlyStoppingStrategy(                      fold.Validation);                  train.AddStrategy(earlyStop);                    var line = new StringBuilder();                  while (!train.TrainingDone)                  {                      train.Iteration();                      line.Length = 0;                      line.Append("Fold #");                      line.Append(foldNum);                      line.Append("/");                      line.Append(k);                      line.Append(": Iteration #");                      line.Append(train.IterationNumber);                      line.Append("' Training Error: ");                      line.Append(Format.FormatDouble(train.Error' 8));                      line.Append("' Validation Error: ");                      line.Append(Format.FormatDouble(earlyStop.ValidationError'                          8));                      Report.Report(k' foldNum' line.ToString());                  }                  fold.Score = earlyStop.ValidationError;                  fold.Method = method;              }              else if (train.ImplementationType == TrainingImplementationType.OnePass)              {                  train.Iteration();                  double validationError = CalculateError(method'                      fold.Validation);                  Report.Report(k' k'                      "Trained' Training Error: " + train.Error                      + "' Validatoin Error: " + validationError);                  fold.Score = validationError;                  fold.Method = method;              }              else              {                  throw new EncogError("Unsupported training type for EncogModel: "                                       + train.ImplementationType);              }
Magic Number,Encog.ML.Prg,PersistPrgPopulation,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Prg\PersistPrgPopulation.cs,Read,The following statement contains a magic number: while ((section = reader.ReadNextSection()) != null)              {                  if (section.SectionName.Equals("BASIC")                      && section.SubSectionName.Equals("PARAMS"))                  {                      IDictionary<string' string> prms = section.ParseParams();                      EngineArray.PutAll(prms' result.Properties);                  }                  else if (section.SectionName.Equals("BASIC")                           && section.SubSectionName.Equals("EPL-POPULATION"))                  {                      foreach (string line in section.Lines)                      {                          IList<String> cols = EncogFileSection.SplitColumns(line);                            if (String.Compare(cols[0]' "s"' StringComparison.OrdinalIgnoreCase) == 0)                          {                              lastSpecies = new BasicSpecies                                  {                                      Age = int.Parse(cols[1])'                                      BestScore = CSVFormat.EgFormat.Parse(cols[2])'                                      Population = result'                                      GensNoImprovement = int.Parse(cols[3])                                  };                              result.Species.Add(lastSpecies);                          }                          else if (cols[0].Equals("p"))                          {                              double score;                              double adjustedScore;                                if (String.Compare(cols[1]' "nan"' StringComparison.OrdinalIgnoreCase) == 0                                  || String.Compare(cols[2]' "nan"' StringComparison.OrdinalIgnoreCase) == 0)                              {                                  score = Double.NaN;                                  adjustedScore = Double.NaN;                              }                              else                              {                                  score = CSVFormat.EgFormat.Parse(cols[1]);                                  adjustedScore = CSVFormat.EgFormat.Parse(cols[2]);                              }                                String code = cols[3];                              var prg = new EncogProgram(context);                              prg.CompileEPL(code);                              prg.Score = score;                              prg.Species = lastSpecies;                              prg.AdjustedScore = adjustedScore;                              if (lastSpecies == null)                              {                                  throw new EncogError(                                      "Have not defined a species yet");                              }                              lastSpecies.Add(prg);                              count++;                          }                      }                  }                  else if (section.SectionName.Equals("BASIC")                           && section.SubSectionName.Equals("EPL-OPCODES"))                  {                      foreach (String line in section.Lines)                      {                          IList<string> cols = EncogFileSection.SplitColumns(line);                          String name = cols[0];                          int args = int.Parse(cols[1]);                          result.Context.Functions.AddExtension(name' args);                      }                  }                  else if (section.SectionName.Equals("BASIC")                           && section.SubSectionName.Equals("EPL-SYMBOLIC"))                  {                      bool first = true;                      foreach (string line in section.Lines)                      {                          if (!first)                          {                              IList<String> cols = EncogFileSection.SplitColumns(line);                              String name = cols[0];                              String t = cols[1];                              var vt = EPLValueType.Unknown;                                if (string.Compare(t' "f"' true) == 0)                              {                                  vt = EPLValueType.FloatingType;                              }                              else if (string.Compare(t' "b"' true) == 0)                              {                                  vt = EPLValueType.BooleanType;                              }                              else if (string.Compare(t' "i"' true) == 0)                              {                                  vt = EPLValueType.IntType;                              }                              else if (string.Compare(t' "s"' true) == 0)                              {                                  vt = EPLValueType.StringType;                              }                              else if (string.Compare(t' "e"' true) == 0)                              {                                  vt = EPLValueType.EnumType;                              }                                int enumType = int.Parse(cols[2]);                              int enumCount = int.Parse(cols[3]);                              var mapping = new VariableMapping(                                  name' vt' enumType' enumCount);                              if (mapping.Name.Length > 0)                              {                                  result.Context.DefineVariable(mapping);                              }                              else                              {                                  result.Context.Result = mapping;                              }                          }                          else                          {                              first = false;                          }                      }                  }              }
Magic Number,Encog.ML.Prg,PersistPrgPopulation,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Prg\PersistPrgPopulation.cs,Read,The following statement contains a magic number: while ((section = reader.ReadNextSection()) != null)              {                  if (section.SectionName.Equals("BASIC")                      && section.SubSectionName.Equals("PARAMS"))                  {                      IDictionary<string' string> prms = section.ParseParams();                      EngineArray.PutAll(prms' result.Properties);                  }                  else if (section.SectionName.Equals("BASIC")                           && section.SubSectionName.Equals("EPL-POPULATION"))                  {                      foreach (string line in section.Lines)                      {                          IList<String> cols = EncogFileSection.SplitColumns(line);                            if (String.Compare(cols[0]' "s"' StringComparison.OrdinalIgnoreCase) == 0)                          {                              lastSpecies = new BasicSpecies                                  {                                      Age = int.Parse(cols[1])'                                      BestScore = CSVFormat.EgFormat.Parse(cols[2])'                                      Population = result'                                      GensNoImprovement = int.Parse(cols[3])                                  };                              result.Species.Add(lastSpecies);                          }                          else if (cols[0].Equals("p"))                          {                              double score;                              double adjustedScore;                                if (String.Compare(cols[1]' "nan"' StringComparison.OrdinalIgnoreCase) == 0                                  || String.Compare(cols[2]' "nan"' StringComparison.OrdinalIgnoreCase) == 0)                              {                                  score = Double.NaN;                                  adjustedScore = Double.NaN;                              }                              else                              {                                  score = CSVFormat.EgFormat.Parse(cols[1]);                                  adjustedScore = CSVFormat.EgFormat.Parse(cols[2]);                              }                                String code = cols[3];                              var prg = new EncogProgram(context);                              prg.CompileEPL(code);                              prg.Score = score;                              prg.Species = lastSpecies;                              prg.AdjustedScore = adjustedScore;                              if (lastSpecies == null)                              {                                  throw new EncogError(                                      "Have not defined a species yet");                              }                              lastSpecies.Add(prg);                              count++;                          }                      }                  }                  else if (section.SectionName.Equals("BASIC")                           && section.SubSectionName.Equals("EPL-OPCODES"))                  {                      foreach (String line in section.Lines)                      {                          IList<string> cols = EncogFileSection.SplitColumns(line);                          String name = cols[0];                          int args = int.Parse(cols[1]);                          result.Context.Functions.AddExtension(name' args);                      }                  }                  else if (section.SectionName.Equals("BASIC")                           && section.SubSectionName.Equals("EPL-SYMBOLIC"))                  {                      bool first = true;                      foreach (string line in section.Lines)                      {                          if (!first)                          {                              IList<String> cols = EncogFileSection.SplitColumns(line);                              String name = cols[0];                              String t = cols[1];                              var vt = EPLValueType.Unknown;                                if (string.Compare(t' "f"' true) == 0)                              {                                  vt = EPLValueType.FloatingType;                              }                              else if (string.Compare(t' "b"' true) == 0)                              {                                  vt = EPLValueType.BooleanType;                              }                              else if (string.Compare(t' "i"' true) == 0)                              {                                  vt = EPLValueType.IntType;                              }                              else if (string.Compare(t' "s"' true) == 0)                              {                                  vt = EPLValueType.StringType;                              }                              else if (string.Compare(t' "e"' true) == 0)                              {                                  vt = EPLValueType.EnumType;                              }                                int enumType = int.Parse(cols[2]);                              int enumCount = int.Parse(cols[3]);                              var mapping = new VariableMapping(                                  name' vt' enumType' enumCount);                              if (mapping.Name.Length > 0)                              {                                  result.Context.DefineVariable(mapping);                              }                              else                              {                                  result.Context.Result = mapping;                              }                          }                          else                          {                              first = false;                          }                      }                  }              }
Magic Number,Encog.ML.Prg,PersistPrgPopulation,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Prg\PersistPrgPopulation.cs,Read,The following statement contains a magic number: while ((section = reader.ReadNextSection()) != null)              {                  if (section.SectionName.Equals("BASIC")                      && section.SubSectionName.Equals("PARAMS"))                  {                      IDictionary<string' string> prms = section.ParseParams();                      EngineArray.PutAll(prms' result.Properties);                  }                  else if (section.SectionName.Equals("BASIC")                           && section.SubSectionName.Equals("EPL-POPULATION"))                  {                      foreach (string line in section.Lines)                      {                          IList<String> cols = EncogFileSection.SplitColumns(line);                            if (String.Compare(cols[0]' "s"' StringComparison.OrdinalIgnoreCase) == 0)                          {                              lastSpecies = new BasicSpecies                                  {                                      Age = int.Parse(cols[1])'                                      BestScore = CSVFormat.EgFormat.Parse(cols[2])'                                      Population = result'                                      GensNoImprovement = int.Parse(cols[3])                                  };                              result.Species.Add(lastSpecies);                          }                          else if (cols[0].Equals("p"))                          {                              double score;                              double adjustedScore;                                if (String.Compare(cols[1]' "nan"' StringComparison.OrdinalIgnoreCase) == 0                                  || String.Compare(cols[2]' "nan"' StringComparison.OrdinalIgnoreCase) == 0)                              {                                  score = Double.NaN;                                  adjustedScore = Double.NaN;                              }                              else                              {                                  score = CSVFormat.EgFormat.Parse(cols[1]);                                  adjustedScore = CSVFormat.EgFormat.Parse(cols[2]);                              }                                String code = cols[3];                              var prg = new EncogProgram(context);                              prg.CompileEPL(code);                              prg.Score = score;                              prg.Species = lastSpecies;                              prg.AdjustedScore = adjustedScore;                              if (lastSpecies == null)                              {                                  throw new EncogError(                                      "Have not defined a species yet");                              }                              lastSpecies.Add(prg);                              count++;                          }                      }                  }                  else if (section.SectionName.Equals("BASIC")                           && section.SubSectionName.Equals("EPL-OPCODES"))                  {                      foreach (String line in section.Lines)                      {                          IList<string> cols = EncogFileSection.SplitColumns(line);                          String name = cols[0];                          int args = int.Parse(cols[1]);                          result.Context.Functions.AddExtension(name' args);                      }                  }                  else if (section.SectionName.Equals("BASIC")                           && section.SubSectionName.Equals("EPL-SYMBOLIC"))                  {                      bool first = true;                      foreach (string line in section.Lines)                      {                          if (!first)                          {                              IList<String> cols = EncogFileSection.SplitColumns(line);                              String name = cols[0];                              String t = cols[1];                              var vt = EPLValueType.Unknown;                                if (string.Compare(t' "f"' true) == 0)                              {                                  vt = EPLValueType.FloatingType;                              }                              else if (string.Compare(t' "b"' true) == 0)                              {                                  vt = EPLValueType.BooleanType;                              }                              else if (string.Compare(t' "i"' true) == 0)                              {                                  vt = EPLValueType.IntType;                              }                              else if (string.Compare(t' "s"' true) == 0)                              {                                  vt = EPLValueType.StringType;                              }                              else if (string.Compare(t' "e"' true) == 0)                              {                                  vt = EPLValueType.EnumType;                              }                                int enumType = int.Parse(cols[2]);                              int enumCount = int.Parse(cols[3]);                              var mapping = new VariableMapping(                                  name' vt' enumType' enumCount);                              if (mapping.Name.Length > 0)                              {                                  result.Context.DefineVariable(mapping);                              }                              else                              {                                  result.Context.Result = mapping;                              }                          }                          else                          {                              first = false;                          }                      }                  }              }
Magic Number,Encog.ML.Prg,PersistPrgPopulation,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Prg\PersistPrgPopulation.cs,Read,The following statement contains a magic number: while ((section = reader.ReadNextSection()) != null)              {                  if (section.SectionName.Equals("BASIC")                      && section.SubSectionName.Equals("PARAMS"))                  {                      IDictionary<string' string> prms = section.ParseParams();                      EngineArray.PutAll(prms' result.Properties);                  }                  else if (section.SectionName.Equals("BASIC")                           && section.SubSectionName.Equals("EPL-POPULATION"))                  {                      foreach (string line in section.Lines)                      {                          IList<String> cols = EncogFileSection.SplitColumns(line);                            if (String.Compare(cols[0]' "s"' StringComparison.OrdinalIgnoreCase) == 0)                          {                              lastSpecies = new BasicSpecies                                  {                                      Age = int.Parse(cols[1])'                                      BestScore = CSVFormat.EgFormat.Parse(cols[2])'                                      Population = result'                                      GensNoImprovement = int.Parse(cols[3])                                  };                              result.Species.Add(lastSpecies);                          }                          else if (cols[0].Equals("p"))                          {                              double score;                              double adjustedScore;                                if (String.Compare(cols[1]' "nan"' StringComparison.OrdinalIgnoreCase) == 0                                  || String.Compare(cols[2]' "nan"' StringComparison.OrdinalIgnoreCase) == 0)                              {                                  score = Double.NaN;                                  adjustedScore = Double.NaN;                              }                              else                              {                                  score = CSVFormat.EgFormat.Parse(cols[1]);                                  adjustedScore = CSVFormat.EgFormat.Parse(cols[2]);                              }                                String code = cols[3];                              var prg = new EncogProgram(context);                              prg.CompileEPL(code);                              prg.Score = score;                              prg.Species = lastSpecies;                              prg.AdjustedScore = adjustedScore;                              if (lastSpecies == null)                              {                                  throw new EncogError(                                      "Have not defined a species yet");                              }                              lastSpecies.Add(prg);                              count++;                          }                      }                  }                  else if (section.SectionName.Equals("BASIC")                           && section.SubSectionName.Equals("EPL-OPCODES"))                  {                      foreach (String line in section.Lines)                      {                          IList<string> cols = EncogFileSection.SplitColumns(line);                          String name = cols[0];                          int args = int.Parse(cols[1]);                          result.Context.Functions.AddExtension(name' args);                      }                  }                  else if (section.SectionName.Equals("BASIC")                           && section.SubSectionName.Equals("EPL-SYMBOLIC"))                  {                      bool first = true;                      foreach (string line in section.Lines)                      {                          if (!first)                          {                              IList<String> cols = EncogFileSection.SplitColumns(line);                              String name = cols[0];                              String t = cols[1];                              var vt = EPLValueType.Unknown;                                if (string.Compare(t' "f"' true) == 0)                              {                                  vt = EPLValueType.FloatingType;                              }                              else if (string.Compare(t' "b"' true) == 0)                              {                                  vt = EPLValueType.BooleanType;                              }                              else if (string.Compare(t' "i"' true) == 0)                              {                                  vt = EPLValueType.IntType;                              }                              else if (string.Compare(t' "s"' true) == 0)                              {                                  vt = EPLValueType.StringType;                              }                              else if (string.Compare(t' "e"' true) == 0)                              {                                  vt = EPLValueType.EnumType;                              }                                int enumType = int.Parse(cols[2]);                              int enumCount = int.Parse(cols[3]);                              var mapping = new VariableMapping(                                  name' vt' enumType' enumCount);                              if (mapping.Name.Length > 0)                              {                                  result.Context.DefineVariable(mapping);                              }                              else                              {                                  result.Context.Result = mapping;                              }                          }                          else                          {                              first = false;                          }                      }                  }              }
Magic Number,Encog.ML.Prg,PersistPrgPopulation,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Prg\PersistPrgPopulation.cs,Read,The following statement contains a magic number: while ((section = reader.ReadNextSection()) != null)              {                  if (section.SectionName.Equals("BASIC")                      && section.SubSectionName.Equals("PARAMS"))                  {                      IDictionary<string' string> prms = section.ParseParams();                      EngineArray.PutAll(prms' result.Properties);                  }                  else if (section.SectionName.Equals("BASIC")                           && section.SubSectionName.Equals("EPL-POPULATION"))                  {                      foreach (string line in section.Lines)                      {                          IList<String> cols = EncogFileSection.SplitColumns(line);                            if (String.Compare(cols[0]' "s"' StringComparison.OrdinalIgnoreCase) == 0)                          {                              lastSpecies = new BasicSpecies                                  {                                      Age = int.Parse(cols[1])'                                      BestScore = CSVFormat.EgFormat.Parse(cols[2])'                                      Population = result'                                      GensNoImprovement = int.Parse(cols[3])                                  };                              result.Species.Add(lastSpecies);                          }                          else if (cols[0].Equals("p"))                          {                              double score;                              double adjustedScore;                                if (String.Compare(cols[1]' "nan"' StringComparison.OrdinalIgnoreCase) == 0                                  || String.Compare(cols[2]' "nan"' StringComparison.OrdinalIgnoreCase) == 0)                              {                                  score = Double.NaN;                                  adjustedScore = Double.NaN;                              }                              else                              {                                  score = CSVFormat.EgFormat.Parse(cols[1]);                                  adjustedScore = CSVFormat.EgFormat.Parse(cols[2]);                              }                                String code = cols[3];                              var prg = new EncogProgram(context);                              prg.CompileEPL(code);                              prg.Score = score;                              prg.Species = lastSpecies;                              prg.AdjustedScore = adjustedScore;                              if (lastSpecies == null)                              {                                  throw new EncogError(                                      "Have not defined a species yet");                              }                              lastSpecies.Add(prg);                              count++;                          }                      }                  }                  else if (section.SectionName.Equals("BASIC")                           && section.SubSectionName.Equals("EPL-OPCODES"))                  {                      foreach (String line in section.Lines)                      {                          IList<string> cols = EncogFileSection.SplitColumns(line);                          String name = cols[0];                          int args = int.Parse(cols[1]);                          result.Context.Functions.AddExtension(name' args);                      }                  }                  else if (section.SectionName.Equals("BASIC")                           && section.SubSectionName.Equals("EPL-SYMBOLIC"))                  {                      bool first = true;                      foreach (string line in section.Lines)                      {                          if (!first)                          {                              IList<String> cols = EncogFileSection.SplitColumns(line);                              String name = cols[0];                              String t = cols[1];                              var vt = EPLValueType.Unknown;                                if (string.Compare(t' "f"' true) == 0)                              {                                  vt = EPLValueType.FloatingType;                              }                              else if (string.Compare(t' "b"' true) == 0)                              {                                  vt = EPLValueType.BooleanType;                              }                              else if (string.Compare(t' "i"' true) == 0)                              {                                  vt = EPLValueType.IntType;                              }                              else if (string.Compare(t' "s"' true) == 0)                              {                                  vt = EPLValueType.StringType;                              }                              else if (string.Compare(t' "e"' true) == 0)                              {                                  vt = EPLValueType.EnumType;                              }                                int enumType = int.Parse(cols[2]);                              int enumCount = int.Parse(cols[3]);                              var mapping = new VariableMapping(                                  name' vt' enumType' enumCount);                              if (mapping.Name.Length > 0)                              {                                  result.Context.DefineVariable(mapping);                              }                              else                              {                                  result.Context.Result = mapping;                              }                          }                          else                          {                              first = false;                          }                      }                  }              }
Magic Number,Encog.ML.Prg,PersistPrgPopulation,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Prg\PersistPrgPopulation.cs,Read,The following statement contains a magic number: while ((section = reader.ReadNextSection()) != null)              {                  if (section.SectionName.Equals("BASIC")                      && section.SubSectionName.Equals("PARAMS"))                  {                      IDictionary<string' string> prms = section.ParseParams();                      EngineArray.PutAll(prms' result.Properties);                  }                  else if (section.SectionName.Equals("BASIC")                           && section.SubSectionName.Equals("EPL-POPULATION"))                  {                      foreach (string line in section.Lines)                      {                          IList<String> cols = EncogFileSection.SplitColumns(line);                            if (String.Compare(cols[0]' "s"' StringComparison.OrdinalIgnoreCase) == 0)                          {                              lastSpecies = new BasicSpecies                                  {                                      Age = int.Parse(cols[1])'                                      BestScore = CSVFormat.EgFormat.Parse(cols[2])'                                      Population = result'                                      GensNoImprovement = int.Parse(cols[3])                                  };                              result.Species.Add(lastSpecies);                          }                          else if (cols[0].Equals("p"))                          {                              double score;                              double adjustedScore;                                if (String.Compare(cols[1]' "nan"' StringComparison.OrdinalIgnoreCase) == 0                                  || String.Compare(cols[2]' "nan"' StringComparison.OrdinalIgnoreCase) == 0)                              {                                  score = Double.NaN;                                  adjustedScore = Double.NaN;                              }                              else                              {                                  score = CSVFormat.EgFormat.Parse(cols[1]);                                  adjustedScore = CSVFormat.EgFormat.Parse(cols[2]);                              }                                String code = cols[3];                              var prg = new EncogProgram(context);                              prg.CompileEPL(code);                              prg.Score = score;                              prg.Species = lastSpecies;                              prg.AdjustedScore = adjustedScore;                              if (lastSpecies == null)                              {                                  throw new EncogError(                                      "Have not defined a species yet");                              }                              lastSpecies.Add(prg);                              count++;                          }                      }                  }                  else if (section.SectionName.Equals("BASIC")                           && section.SubSectionName.Equals("EPL-OPCODES"))                  {                      foreach (String line in section.Lines)                      {                          IList<string> cols = EncogFileSection.SplitColumns(line);                          String name = cols[0];                          int args = int.Parse(cols[1]);                          result.Context.Functions.AddExtension(name' args);                      }                  }                  else if (section.SectionName.Equals("BASIC")                           && section.SubSectionName.Equals("EPL-SYMBOLIC"))                  {                      bool first = true;                      foreach (string line in section.Lines)                      {                          if (!first)                          {                              IList<String> cols = EncogFileSection.SplitColumns(line);                              String name = cols[0];                              String t = cols[1];                              var vt = EPLValueType.Unknown;                                if (string.Compare(t' "f"' true) == 0)                              {                                  vt = EPLValueType.FloatingType;                              }                              else if (string.Compare(t' "b"' true) == 0)                              {                                  vt = EPLValueType.BooleanType;                              }                              else if (string.Compare(t' "i"' true) == 0)                              {                                  vt = EPLValueType.IntType;                              }                              else if (string.Compare(t' "s"' true) == 0)                              {                                  vt = EPLValueType.StringType;                              }                              else if (string.Compare(t' "e"' true) == 0)                              {                                  vt = EPLValueType.EnumType;                              }                                int enumType = int.Parse(cols[2]);                              int enumCount = int.Parse(cols[3]);                              var mapping = new VariableMapping(                                  name' vt' enumType' enumCount);                              if (mapping.Name.Length > 0)                              {                                  result.Context.DefineVariable(mapping);                              }                              else                              {                                  result.Context.Result = mapping;                              }                          }                          else                          {                              first = false;                          }                      }                  }              }
Magic Number,Encog.ML.Prg,PersistPrgPopulation,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Prg\PersistPrgPopulation.cs,Read,The following statement contains a magic number: while ((section = reader.ReadNextSection()) != null)              {                  if (section.SectionName.Equals("BASIC")                      && section.SubSectionName.Equals("PARAMS"))                  {                      IDictionary<string' string> prms = section.ParseParams();                      EngineArray.PutAll(prms' result.Properties);                  }                  else if (section.SectionName.Equals("BASIC")                           && section.SubSectionName.Equals("EPL-POPULATION"))                  {                      foreach (string line in section.Lines)                      {                          IList<String> cols = EncogFileSection.SplitColumns(line);                            if (String.Compare(cols[0]' "s"' StringComparison.OrdinalIgnoreCase) == 0)                          {                              lastSpecies = new BasicSpecies                                  {                                      Age = int.Parse(cols[1])'                                      BestScore = CSVFormat.EgFormat.Parse(cols[2])'                                      Population = result'                                      GensNoImprovement = int.Parse(cols[3])                                  };                              result.Species.Add(lastSpecies);                          }                          else if (cols[0].Equals("p"))                          {                              double score;                              double adjustedScore;                                if (String.Compare(cols[1]' "nan"' StringComparison.OrdinalIgnoreCase) == 0                                  || String.Compare(cols[2]' "nan"' StringComparison.OrdinalIgnoreCase) == 0)                              {                                  score = Double.NaN;                                  adjustedScore = Double.NaN;                              }                              else                              {                                  score = CSVFormat.EgFormat.Parse(cols[1]);                                  adjustedScore = CSVFormat.EgFormat.Parse(cols[2]);                              }                                String code = cols[3];                              var prg = new EncogProgram(context);                              prg.CompileEPL(code);                              prg.Score = score;                              prg.Species = lastSpecies;                              prg.AdjustedScore = adjustedScore;                              if (lastSpecies == null)                              {                                  throw new EncogError(                                      "Have not defined a species yet");                              }                              lastSpecies.Add(prg);                              count++;                          }                      }                  }                  else if (section.SectionName.Equals("BASIC")                           && section.SubSectionName.Equals("EPL-OPCODES"))                  {                      foreach (String line in section.Lines)                      {                          IList<string> cols = EncogFileSection.SplitColumns(line);                          String name = cols[0];                          int args = int.Parse(cols[1]);                          result.Context.Functions.AddExtension(name' args);                      }                  }                  else if (section.SectionName.Equals("BASIC")                           && section.SubSectionName.Equals("EPL-SYMBOLIC"))                  {                      bool first = true;                      foreach (string line in section.Lines)                      {                          if (!first)                          {                              IList<String> cols = EncogFileSection.SplitColumns(line);                              String name = cols[0];                              String t = cols[1];                              var vt = EPLValueType.Unknown;                                if (string.Compare(t' "f"' true) == 0)                              {                                  vt = EPLValueType.FloatingType;                              }                              else if (string.Compare(t' "b"' true) == 0)                              {                                  vt = EPLValueType.BooleanType;                              }                              else if (string.Compare(t' "i"' true) == 0)                              {                                  vt = EPLValueType.IntType;                              }                              else if (string.Compare(t' "s"' true) == 0)                              {                                  vt = EPLValueType.StringType;                              }                              else if (string.Compare(t' "e"' true) == 0)                              {                                  vt = EPLValueType.EnumType;                              }                                int enumType = int.Parse(cols[2]);                              int enumCount = int.Parse(cols[3]);                              var mapping = new VariableMapping(                                  name' vt' enumType' enumCount);                              if (mapping.Name.Length > 0)                              {                                  result.Context.DefineVariable(mapping);                              }                              else                              {                                  result.Context.Result = mapping;                              }                          }                          else                          {                              first = false;                          }                      }                  }              }
Magic Number,Encog.ML.Prg.Generator,AbstractPrgGenerator,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Prg\Generator\AbstractPrgGenerator.cs,AbstractPrgGenerator,The following statement contains a magic number: MinConst = -10;
Magic Number,Encog.ML.Prg.Generator,AbstractPrgGenerator,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Prg\Generator\AbstractPrgGenerator.cs,AbstractPrgGenerator,The following statement contains a magic number: MaxConst = 10;
Magic Number,Encog.ML.Prg.Generator,AbstractPrgGenerator,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Prg\Generator\AbstractPrgGenerator.cs,AbstractPrgGenerator,The following statement contains a magic number: MaxGenerationErrors = 500;
Magic Number,Encog.ML.Prg.Generator,AbstractPrgGenerator,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Prg\Generator\AbstractPrgGenerator.cs,CreateRandomNode,The following statement contains a magic number: if (EncogOpcodeRegistry.IsOperator(temp.NodeType) && children.Length >= 2)              {                  // for an operator of size 2 or greater make sure all children are                  // the same time                  IList<EPLValueType> childTypes = temp.Params[0]                      .DetermineArgumentTypes(types);                  EPLValueType selectedType = childTypes[rnd                                                             .Next(childTypes.Count)];                  childTypes.Clear();                  childTypes.Add(selectedType);                    // now create the children of a common type                  for (int i = 0; i < children.Length; i++)                  {                      children[i] = CreateNode(rnd' program' depthRemaining - 1'                                               childTypes);                  }              }              else              {                  // otherwise' let the children have their own types                  for (int i = 0; i < children.Length; i++)                  {                      IList<EPLValueType> childTypes = temp.Params[i]                          .DetermineArgumentTypes(types);                      children[i] = CreateNode(rnd' program' depthRemaining - 1'                                               childTypes);                  }              }
Magic Number,Encog.ML.Prg.Generator,AbstractPrgGenerator,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Prg\Generator\AbstractPrgGenerator.cs,GenerateRandomOpcode,The following statement contains a magic number: int tries = 10000;
Magic Number,Encog.ML.Prg.Generator,RampedHalfAndHalf,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Prg\Generator\RampedHalfAndHalf.cs,CreateNode,The following statement contains a magic number: if (rnd.NextDouble() > 0.5)              {                  return _fullGenerator.CreateNode(rnd' program'                                                  actualDepthRemaining' types);              }
Magic Number,Encog.ML.Prg.Opp,SubtreeCrossover,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Prg\Opp\SubtreeCrossover.cs,PerformOperation,The following statement contains a magic number: int tries = 100;
Magic Number,Encog.ML.Prg.Species,PrgSpeciation,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Prg\Species\PrgSpeciation.cs,PrgSpeciation,The following statement contains a magic number: CompatibilityThreshold = 15;
Magic Number,Encog.ML.Prg.Species,PrgSpeciation,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Prg\Species\PrgSpeciation.cs,PrgSpeciation,The following statement contains a magic number: MaxNumberOfSpecies = 30;
Magic Number,Encog.ML.Prg.Species,PrgSpeciation,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Prg\Species\PrgSpeciation.cs,PrgSpeciation,The following statement contains a magic number: NumGensAllowedNoImprovement = 15;
Magic Number,Encog.ML.Prg.Train.Rewrite,RewriteAlgebraic,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Prg\Train\Rewrite\RewriteAlgebraic.cs,TryMinusMinus,The following statement contains a magic number: if (parent.Name.Equals("-") && parent.ChildNodes.Count == 2)              {                  ProgramNode child1 = parent.GetChildNode(0);                  ProgramNode child2 = parent.GetChildNode(1);                    if (child2.Name.Equals("#const"))                  {                      ExpressionValue v = child2.Data[0];                      if (v.IsFloat)                      {                          double v2 = v.ToFloatValue();                          if (v2 < 0)                          {                              child2.Data[0] = new ExpressionValue(-v2);                              parent = parent.Owner.Context.Functions.FactorProgramNode(                                  "+"' parent.Owner' new[] {child1' child2});                          }                      }                      else if (v.IsInt)                      {                          long v2 = v.ToIntValue();                          if (v2 < 0)                          {                              child2.Data[0] = new ExpressionValue(-v2);                              parent = parent.Owner.Context.Functions                                             .FactorProgramNode("+"' parent.Owner'                                                                new[] {child1' child2});                          }                      }                  }              }
Magic Number,Encog.ML.Prg.Train.Rewrite,RewriteAlgebraic,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Prg\Train\Rewrite\RewriteAlgebraic.cs,TryPlusNeg,The following statement contains a magic number: if (parent.Name.Equals("+") && parent.ChildNodes.Count == 2)              {                  ProgramNode child1 = parent.GetChildNode(0);                  ProgramNode child2 = parent.GetChildNode(1);                    if (child2.Name.Equals("-")                      && child2.ChildNodes.Count == 1)                  {                      parent = parent.Owner.Context.Functions.FactorProgramNode(                          "-"' parent.Owner' new[]                              {                                  child1'                                  child2.GetChildNode(0)                              });                  }                  else if (child2.Name.Equals("#const"))                  {                      ExpressionValue v = child2.Data[0];                      if (v.IsFloat)                      {                          double v2 = v.ToFloatValue();                          if (v2 < 0)                          {                              child2.Data[0] = new ExpressionValue(-v2);                              parent = parent.Owner.Context.Functions.FactorProgramNode("-"'                                                                                        parent.Owner'                                                                                        new[] {child1' child2});                          }                      }                      else if (v.IsInt)                      {                          long v2 = v.ToIntValue();                          if (v2 < 0)                          {                              child2.Data[0] = new ExpressionValue(-v2);                              parent = parent.Owner.Context.Functions                                             .FactorProgramNode("-"' parent.Owner'                                                                new[] {child1' child2});                          }                      }                  }              }
Magic Number,Encog.ML.Prg.Train.Rewrite,RewriteAlgebraic,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Prg\Train\Rewrite\RewriteAlgebraic.cs,TryVarOpVar,The following statement contains a magic number: if (parent.ChildNodes.Count == 2                  && parent.Name.Length == 1                  && "+-*/".IndexOf(parent.Name[0]) != -1)              {                  ProgramNode child1 = parent.GetChildNode(0);                  ProgramNode child2 = parent.GetChildNode(1);                    if (child1.Name.Equals("#var")                      && child2.Name.Equals("#var"))                  {                      if (child1.Data[0].ToIntValue() == child2.Data[0]                                                             .ToIntValue())                      {                          switch (parent.Name[0])                          {                              case '-':                                  parent = CreateNumericConst(parent.Owner' 0);                                  break;                              case '+':                                  parent = parent.Owner.Functions.FactorProgramNode("*"' parent.Owner'                                                                                    new[]                                                                                        {                                                                                            CreateNumericConst(                                                                                                parent.Owner' 2)'                                                                                            child1                                                                                        });                                  break;                              case '*':                                  parent = parent                                      .Owner                                      .Functions                                      .FactorProgramNode(                                          "^"'                                          parent.Owner'                                          new[]                                              {                                                  child1'                                                  CreateNumericConst(                                                      parent.Owner' 2)                                              });                                  break;                              case '/':                                  parent = CreateNumericConst(parent.Owner' 1);                                  break;                          }                      }                  }              }
Magic Number,Encog.ML.Prg.Train.Rewrite,RewriteAlgebraic,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Prg\Train\Rewrite\RewriteAlgebraic.cs,TryVarOpVar,The following statement contains a magic number: if (parent.ChildNodes.Count == 2                  && parent.Name.Length == 1                  && "+-*/".IndexOf(parent.Name[0]) != -1)              {                  ProgramNode child1 = parent.GetChildNode(0);                  ProgramNode child2 = parent.GetChildNode(1);                    if (child1.Name.Equals("#var")                      && child2.Name.Equals("#var"))                  {                      if (child1.Data[0].ToIntValue() == child2.Data[0]                                                             .ToIntValue())                      {                          switch (parent.Name[0])                          {                              case '-':                                  parent = CreateNumericConst(parent.Owner' 0);                                  break;                              case '+':                                  parent = parent.Owner.Functions.FactorProgramNode("*"' parent.Owner'                                                                                    new[]                                                                                        {                                                                                            CreateNumericConst(                                                                                                parent.Owner' 2)'                                                                                            child1                                                                                        });                                  break;                              case '*':                                  parent = parent                                      .Owner                                      .Functions                                      .FactorProgramNode(                                          "^"'                                          parent.Owner'                                          new[]                                              {                                                  child1'                                                  CreateNumericConst(                                                      parent.Owner' 2)                                              });                                  break;                              case '/':                                  parent = CreateNumericConst(parent.Owner' 1);                                  break;                          }                      }                  }              }
Magic Number,Encog.ML.Prg.Train.Rewrite,RewriteAlgebraic,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Prg\Train\Rewrite\RewriteAlgebraic.cs,TryVarOpVar,The following statement contains a magic number: if (parent.ChildNodes.Count == 2                  && parent.Name.Length == 1                  && "+-*/".IndexOf(parent.Name[0]) != -1)              {                  ProgramNode child1 = parent.GetChildNode(0);                  ProgramNode child2 = parent.GetChildNode(1);                    if (child1.Name.Equals("#var")                      && child2.Name.Equals("#var"))                  {                      if (child1.Data[0].ToIntValue() == child2.Data[0]                                                             .ToIntValue())                      {                          switch (parent.Name[0])                          {                              case '-':                                  parent = CreateNumericConst(parent.Owner' 0);                                  break;                              case '+':                                  parent = parent.Owner.Functions.FactorProgramNode("*"' parent.Owner'                                                                                    new[]                                                                                        {                                                                                            CreateNumericConst(                                                                                                parent.Owner' 2)'                                                                                            child1                                                                                        });                                  break;                              case '*':                                  parent = parent                                      .Owner                                      .Functions                                      .FactorProgramNode(                                          "^"'                                          parent.Owner'                                          new[]                                              {                                                  child1'                                                  CreateNumericConst(                                                      parent.Owner' 2)                                              });                                  break;                              case '/':                                  parent = CreateNumericConst(parent.Owner' 1);                                  break;                          }                      }                  }              }
Magic Number,Encog.ML.Train.Strategy,EarlyStoppingStrategy,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Train\Strategy\EarlyStoppingStrategy.cs,PostIteration,The following statement contains a magic number: if (_lastCheck > _stripLength)              {                  _validationError = _calc.CalculateError(_validationSet);                  _testError = _calc.CalculateError(_testSet);                  _eOpt = Math.Min(_validationError' _eOpt);                  _gl = 100.0*((_validationError/_eOpt) - 1.0);                    _stripEfficiency = (_stripTotal)                                    /(_stripLength*_stripOpt);                    //System.out.println("eff=" + this.stripEfficiency + "' gl=" + this.gl);                    // setup for next time                  _stripTotal = 0;                  _lastCheck = 0;                    // should we stop?                  _stop = (_gl > _alpha)                         || (_stripEfficiency < _minEfficiency);              }
Magic Number,Encog.Neural.ART,ART1,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\ART\ART1.cs,ART1,The following statement contains a magic number: _c1 = 5;
Magic Number,Encog.Neural.ART,ART1,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\ART\ART1.cs,ART1,The following statement contains a magic number: _l = 3;
Magic Number,Encog.Neural.ART,ART1,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\ART\ART1.cs,ART1,The following statement contains a magic number: _c1 = 5;
Magic Number,Encog.Neural.ART,ART1,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\ART\ART1.cs,ART1,The following statement contains a magic number: _l = 3;
Magic Number,Encog.Neural.Flat,FlatNetwork,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Flat\FlatNetwork.cs,FlatNetwork,The following statement contains a magic number: if ((hidden1 == 0) && (hidden2 == 0))              {                  layers = new FlatLayer[2];                  layers[0] = new FlatLayer(linearAct' input'                                            DefaultBiasActivation);                  layers[1] = new FlatLayer(act' output'                                            NoBiasActivation);              }              else if ((hidden1 == 0) || (hidden2 == 0))              {                  int count = Math.Max(hidden1' hidden2);                  layers = new FlatLayer[3];                  layers[0] = new FlatLayer(linearAct' input'                                            DefaultBiasActivation);                  layers[1] = new FlatLayer(act' count'                                            DefaultBiasActivation);                  layers[2] = new FlatLayer(act' output'                                            NoBiasActivation);              }              else              {                  layers = new FlatLayer[4];                  layers[0] = new FlatLayer(linearAct' input'                                            DefaultBiasActivation);                  layers[1] = new FlatLayer(act' hidden1'                                            DefaultBiasActivation);                  layers[2] = new FlatLayer(act' hidden2'                                            DefaultBiasActivation);                  layers[3] = new FlatLayer(act' output'                                            NoBiasActivation);              }
Magic Number,Encog.Neural.Flat,FlatNetwork,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Flat\FlatNetwork.cs,FlatNetwork,The following statement contains a magic number: if ((hidden1 == 0) && (hidden2 == 0))              {                  layers = new FlatLayer[2];                  layers[0] = new FlatLayer(linearAct' input'                                            DefaultBiasActivation);                  layers[1] = new FlatLayer(act' output'                                            NoBiasActivation);              }              else if ((hidden1 == 0) || (hidden2 == 0))              {                  int count = Math.Max(hidden1' hidden2);                  layers = new FlatLayer[3];                  layers[0] = new FlatLayer(linearAct' input'                                            DefaultBiasActivation);                  layers[1] = new FlatLayer(act' count'                                            DefaultBiasActivation);                  layers[2] = new FlatLayer(act' output'                                            NoBiasActivation);              }              else              {                  layers = new FlatLayer[4];                  layers[0] = new FlatLayer(linearAct' input'                                            DefaultBiasActivation);                  layers[1] = new FlatLayer(act' hidden1'                                            DefaultBiasActivation);                  layers[2] = new FlatLayer(act' hidden2'                                            DefaultBiasActivation);                  layers[3] = new FlatLayer(act' output'                                            NoBiasActivation);              }
Magic Number,Encog.Neural.Flat,FlatNetwork,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Flat\FlatNetwork.cs,FlatNetwork,The following statement contains a magic number: if ((hidden1 == 0) && (hidden2 == 0))              {                  layers = new FlatLayer[2];                  layers[0] = new FlatLayer(linearAct' input'                                            DefaultBiasActivation);                  layers[1] = new FlatLayer(act' output'                                            NoBiasActivation);              }              else if ((hidden1 == 0) || (hidden2 == 0))              {                  int count = Math.Max(hidden1' hidden2);                  layers = new FlatLayer[3];                  layers[0] = new FlatLayer(linearAct' input'                                            DefaultBiasActivation);                  layers[1] = new FlatLayer(act' count'                                            DefaultBiasActivation);                  layers[2] = new FlatLayer(act' output'                                            NoBiasActivation);              }              else              {                  layers = new FlatLayer[4];                  layers[0] = new FlatLayer(linearAct' input'                                            DefaultBiasActivation);                  layers[1] = new FlatLayer(act' hidden1'                                            DefaultBiasActivation);                  layers[2] = new FlatLayer(act' hidden2'                                            DefaultBiasActivation);                  layers[3] = new FlatLayer(act' output'                                            NoBiasActivation);              }
Magic Number,Encog.Neural.Flat,FlatNetwork,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Flat\FlatNetwork.cs,FlatNetwork,The following statement contains a magic number: if ((hidden1 == 0) && (hidden2 == 0))              {                  layers = new FlatLayer[2];                  layers[0] = new FlatLayer(linearAct' input'                                            DefaultBiasActivation);                  layers[1] = new FlatLayer(act' output'                                            NoBiasActivation);              }              else if ((hidden1 == 0) || (hidden2 == 0))              {                  int count = Math.Max(hidden1' hidden2);                  layers = new FlatLayer[3];                  layers[0] = new FlatLayer(linearAct' input'                                            DefaultBiasActivation);                  layers[1] = new FlatLayer(act' count'                                            DefaultBiasActivation);                  layers[2] = new FlatLayer(act' output'                                            NoBiasActivation);              }              else              {                  layers = new FlatLayer[4];                  layers[0] = new FlatLayer(linearAct' input'                                            DefaultBiasActivation);                  layers[1] = new FlatLayer(act' hidden1'                                            DefaultBiasActivation);                  layers[2] = new FlatLayer(act' hidden2'                                            DefaultBiasActivation);                  layers[3] = new FlatLayer(act' output'                                            NoBiasActivation);              }
Magic Number,Encog.Neural.Flat,FlatNetwork,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Flat\FlatNetwork.cs,FlatNetwork,The following statement contains a magic number: if ((hidden1 == 0) && (hidden2 == 0))              {                  layers = new FlatLayer[2];                  layers[0] = new FlatLayer(linearAct' input'                                            DefaultBiasActivation);                  layers[1] = new FlatLayer(act' output'                                            NoBiasActivation);              }              else if ((hidden1 == 0) || (hidden2 == 0))              {                  int count = Math.Max(hidden1' hidden2);                  layers = new FlatLayer[3];                  layers[0] = new FlatLayer(linearAct' input'                                            DefaultBiasActivation);                  layers[1] = new FlatLayer(act' count'                                            DefaultBiasActivation);                  layers[2] = new FlatLayer(act' output'                                            NoBiasActivation);              }              else              {                  layers = new FlatLayer[4];                  layers[0] = new FlatLayer(linearAct' input'                                            DefaultBiasActivation);                  layers[1] = new FlatLayer(act' hidden1'                                            DefaultBiasActivation);                  layers[2] = new FlatLayer(act' hidden2'                                            DefaultBiasActivation);                  layers[3] = new FlatLayer(act' output'                                            NoBiasActivation);              }
Magic Number,Encog.Neural.Flat,FlatNetwork,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Flat\FlatNetwork.cs,FlatNetwork,The following statement contains a magic number: if ((hidden1 == 0) && (hidden2 == 0))              {                  layers = new FlatLayer[2];                  layers[0] = new FlatLayer(linearAct' input'                                            DefaultBiasActivation);                  layers[1] = new FlatLayer(act' output'                                            NoBiasActivation);              }              else if ((hidden1 == 0) || (hidden2 == 0))              {                  int count = Math.Max(hidden1' hidden2);                  layers = new FlatLayer[3];                  layers[0] = new FlatLayer(linearAct' input'                                            DefaultBiasActivation);                  layers[1] = new FlatLayer(act' count'                                            DefaultBiasActivation);                  layers[2] = new FlatLayer(act' output'                                            NoBiasActivation);              }              else              {                  layers = new FlatLayer[4];                  layers[0] = new FlatLayer(linearAct' input'                                            DefaultBiasActivation);                  layers[1] = new FlatLayer(act' hidden1'                                            DefaultBiasActivation);                  layers[2] = new FlatLayer(act' hidden2'                                            DefaultBiasActivation);                  layers[3] = new FlatLayer(act' output'                                            NoBiasActivation);              }
Magic Number,Encog.Neural.Flat,FlatNetworkRBF,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Flat\FlatNetworkRBF.cs,FlatNetworkRBF,The following statement contains a magic number: var layers = new FlatLayer[3];
Magic Number,Encog.Neural.Flat,FlatNetworkRBF,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Flat\FlatNetworkRBF.cs,FlatNetworkRBF,The following statement contains a magic number: layers[2] = new FlatLayer(new ActivationLinear()' outputCount' 0.0d);
Magic Number,Encog.Neural.Freeform,FreeformNetwork,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Freeform\FreeformNetwork.cs,FreeformNetwork,The following statement contains a magic number: if (network.LayerCount < 2)              {                  throw new FreeformNetworkError(                      "The BasicNetwork must have at least two layers to be converted.");              }
Magic Number,Encog.Neural.Freeform.Training,FreeformBackPropagation,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Freeform\Training\FreeformBackPropagation.cs,FreeformBackPropagation,The following statement contains a magic number: theNetwork.TempTrainingAllocate(1' 2);
Magic Number,Encog.Neural.Freeform.Training,FreeformResilientPropagation,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Freeform\Training\FreeformResilientPropagation.cs,FreeformResilientPropagation,The following statement contains a magic number: theNetwork.TempTrainingAllocate(1' 4);
Magic Number,Encog.Neural.HyperNEAT,HyperNEATCODEC,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\HyperNEAT\HyperNEATCODEC.cs,HyperNEATCODEC,The following statement contains a magic number: MinWeight = 0.2;
Magic Number,Encog.Neural.HyperNEAT,HyperNEATCODEC,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\HyperNEAT\HyperNEATCODEC.cs,HyperNEATCODEC,The following statement contains a magic number: MaxWeight = 5.0;
Magic Number,Encog.Neural.HyperNEAT,HyperNEATGenome,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\HyperNEAT\HyperNEATGenome.cs,BuildCPPNActivationFunctions,The following statement contains a magic number: activationFunctions.Add(0.25' new ActivationClippedLinear());
Magic Number,Encog.Neural.HyperNEAT,HyperNEATGenome,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\HyperNEAT\HyperNEATGenome.cs,BuildCPPNActivationFunctions,The following statement contains a magic number: activationFunctions.Add(0.25' new ActivationBipolarSteepenedSigmoid());
Magic Number,Encog.Neural.HyperNEAT,HyperNEATGenome,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\HyperNEAT\HyperNEATGenome.cs,BuildCPPNActivationFunctions,The following statement contains a magic number: activationFunctions.Add(0.25' new ActivationGaussian());
Magic Number,Encog.Neural.HyperNEAT,HyperNEATGenome,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\HyperNEAT\HyperNEATGenome.cs,BuildCPPNActivationFunctions,The following statement contains a magic number: activationFunctions.Add(0.25' new ActivationSIN());
Magic Number,Encog.Neural.HyperNEAT.Substrate,SubstrateFactory,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\HyperNEAT\Substrate\SubstrateFactory.cs,factorSandwichSubstrate,The following statement contains a magic number: Substrate result = new Substrate(3);
Magic Number,Encog.Neural.HyperNEAT.Substrate,SubstrateFactory,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\HyperNEAT\Substrate\SubstrateFactory.cs,factorSandwichSubstrate,The following statement contains a magic number: double inputTick = 2.0 / inputEdgeSize;
Magic Number,Encog.Neural.HyperNEAT.Substrate,SubstrateFactory,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\HyperNEAT\Substrate\SubstrateFactory.cs,factorSandwichSubstrate,The following statement contains a magic number: double outputTick = 2.0 / inputEdgeSize;
Magic Number,Encog.Neural.HyperNEAT.Substrate,SubstrateFactory,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\HyperNEAT\Substrate\SubstrateFactory.cs,factorSandwichSubstrate,The following statement contains a magic number: double inputOrig = -1.0 + (inputTick / 2.0);
Magic Number,Encog.Neural.HyperNEAT.Substrate,SubstrateFactory,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\HyperNEAT\Substrate\SubstrateFactory.cs,factorSandwichSubstrate,The following statement contains a magic number: double outputOrig = -1.0 + (inputTick / 2.0);
Magic Number,Encog.Neural.HyperNEAT.Substrate,SubstrateFactory,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\HyperNEAT\Substrate\SubstrateFactory.cs,factorSandwichSubstrate,The following statement contains a magic number: for (int row = 0; row < inputEdgeSize; row++)              {                  for (int col = 0; col < inputEdgeSize; col++)                  {                      SubstrateNode inputNode = result.CreateInputNode();                      inputNode.Location[0] = -1;                      inputNode.Location[1] = inputOrig + (row * inputTick);                      inputNode.Location[2] = inputOrig + (col * inputTick);                  }              }
Magic Number,Encog.Neural.HyperNEAT.Substrate,SubstrateFactory,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\HyperNEAT\Substrate\SubstrateFactory.cs,factorSandwichSubstrate,The following statement contains a magic number: for (int orow = 0; orow < outputEdgeSize; orow++)              {                  for (int ocol = 0; ocol < outputEdgeSize; ocol++)                  {                      SubstrateNode outputNode = result.CreateOutputNode();                      outputNode.Location[0] = 1;                      outputNode.Location[1] = outputOrig + (orow * outputTick);                      outputNode.Location[2] = outputOrig + (ocol * outputTick);                        // link this output node to every input node                      foreach (SubstrateNode inputNode in result.InputNodes)                      {                          result.CreateLink(inputNode' outputNode);                      }                  }              }
Magic Number,Encog.Neural.NEAT,NEATUtil,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\NEATUtil.cs,ConstructNEATTrainer,The following statement contains a magic number: result.Selection = new TruncationSelection(result' 0.3);
Magic Number,Encog.Neural.NEAT,NEATUtil,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\NEATUtil.cs,ConstructNEATTrainer,The following statement contains a magic number: weightMutation.Components.Add(                      0.1125'                      new NEATMutateWeights(new SelectFixed(1)'                              new MutatePerturbLinkWeight(0.02)));
Magic Number,Encog.Neural.NEAT,NEATUtil,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\NEATUtil.cs,ConstructNEATTrainer,The following statement contains a magic number: weightMutation.Components.Add(                      0.1125'                      new NEATMutateWeights(new SelectFixed(1)'                              new MutatePerturbLinkWeight(0.02)));
Magic Number,Encog.Neural.NEAT,NEATUtil,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\NEATUtil.cs,ConstructNEATTrainer,The following statement contains a magic number: weightMutation.Components.Add(                      0.1125'                      new NEATMutateWeights(new SelectFixed(2)'                              new MutatePerturbLinkWeight(0.02)));
Magic Number,Encog.Neural.NEAT,NEATUtil,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\NEATUtil.cs,ConstructNEATTrainer,The following statement contains a magic number: weightMutation.Components.Add(                      0.1125'                      new NEATMutateWeights(new SelectFixed(2)'                              new MutatePerturbLinkWeight(0.02)));
Magic Number,Encog.Neural.NEAT,NEATUtil,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\NEATUtil.cs,ConstructNEATTrainer,The following statement contains a magic number: weightMutation.Components.Add(                      0.1125'                      new NEATMutateWeights(new SelectFixed(2)'                              new MutatePerturbLinkWeight(0.02)));
Magic Number,Encog.Neural.NEAT,NEATUtil,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\NEATUtil.cs,ConstructNEATTrainer,The following statement contains a magic number: weightMutation.Components.Add(                      0.1125'                      new NEATMutateWeights(new SelectFixed(3)'                              new MutatePerturbLinkWeight(0.02)));
Magic Number,Encog.Neural.NEAT,NEATUtil,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\NEATUtil.cs,ConstructNEATTrainer,The following statement contains a magic number: weightMutation.Components.Add(                      0.1125'                      new NEATMutateWeights(new SelectFixed(3)'                              new MutatePerturbLinkWeight(0.02)));
Magic Number,Encog.Neural.NEAT,NEATUtil,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\NEATUtil.cs,ConstructNEATTrainer,The following statement contains a magic number: weightMutation.Components.Add(                      0.1125'                      new NEATMutateWeights(new SelectFixed(3)'                              new MutatePerturbLinkWeight(0.02)));
Magic Number,Encog.Neural.NEAT,NEATUtil,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\NEATUtil.cs,ConstructNEATTrainer,The following statement contains a magic number: weightMutation.Components.Add(                      0.1125'                      new NEATMutateWeights(new SelectProportion(0.02)'                              new MutatePerturbLinkWeight(0.02)));
Magic Number,Encog.Neural.NEAT,NEATUtil,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\NEATUtil.cs,ConstructNEATTrainer,The following statement contains a magic number: weightMutation.Components.Add(                      0.1125'                      new NEATMutateWeights(new SelectProportion(0.02)'                              new MutatePerturbLinkWeight(0.02)));
Magic Number,Encog.Neural.NEAT,NEATUtil,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\NEATUtil.cs,ConstructNEATTrainer,The following statement contains a magic number: weightMutation.Components.Add(                      0.1125'                      new NEATMutateWeights(new SelectProportion(0.02)'                              new MutatePerturbLinkWeight(0.02)));
Magic Number,Encog.Neural.NEAT,NEATUtil,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\NEATUtil.cs,ConstructNEATTrainer,The following statement contains a magic number: weightMutation.Components.Add(                      0.1125'                      new NEATMutateWeights(new SelectFixed(1)'                              new MutatePerturbLinkWeight(1)));
Magic Number,Encog.Neural.NEAT,NEATUtil,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\NEATUtil.cs,ConstructNEATTrainer,The following statement contains a magic number: weightMutation.Components.Add(                      0.1125'                      new NEATMutateWeights(new SelectFixed(2)'                              new MutatePerturbLinkWeight(1)));
Magic Number,Encog.Neural.NEAT,NEATUtil,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\NEATUtil.cs,ConstructNEATTrainer,The following statement contains a magic number: weightMutation.Components.Add(                      0.1125'                      new NEATMutateWeights(new SelectFixed(2)'                              new MutatePerturbLinkWeight(1)));
Magic Number,Encog.Neural.NEAT,NEATUtil,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\NEATUtil.cs,ConstructNEATTrainer,The following statement contains a magic number: weightMutation.Components.Add(                      0.1125'                      new NEATMutateWeights(new SelectFixed(3)'                              new MutatePerturbLinkWeight(1)));
Magic Number,Encog.Neural.NEAT,NEATUtil,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\NEATUtil.cs,ConstructNEATTrainer,The following statement contains a magic number: weightMutation.Components.Add(                      0.1125'                      new NEATMutateWeights(new SelectFixed(3)'                              new MutatePerturbLinkWeight(1)));
Magic Number,Encog.Neural.NEAT,NEATUtil,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\NEATUtil.cs,ConstructNEATTrainer,The following statement contains a magic number: weightMutation.Components.Add(                      0.1125'                      new NEATMutateWeights(new SelectProportion(0.02)'                              new MutatePerturbLinkWeight(1)));
Magic Number,Encog.Neural.NEAT,NEATUtil,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\NEATUtil.cs,ConstructNEATTrainer,The following statement contains a magic number: weightMutation.Components.Add(                      0.1125'                      new NEATMutateWeights(new SelectProportion(0.02)'                              new MutatePerturbLinkWeight(1)));
Magic Number,Encog.Neural.NEAT,NEATUtil,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\NEATUtil.cs,ConstructNEATTrainer,The following statement contains a magic number: weightMutation.Components.Add(                      0.03'                      new NEATMutateWeights(new SelectFixed(1)'                              new MutateResetLinkWeight()));
Magic Number,Encog.Neural.NEAT,NEATUtil,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\NEATUtil.cs,ConstructNEATTrainer,The following statement contains a magic number: weightMutation.Components.Add(                      0.03'                      new NEATMutateWeights(new SelectFixed(2)'                              new MutateResetLinkWeight()));
Magic Number,Encog.Neural.NEAT,NEATUtil,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\NEATUtil.cs,ConstructNEATTrainer,The following statement contains a magic number: weightMutation.Components.Add(                      0.03'                      new NEATMutateWeights(new SelectFixed(2)'                              new MutateResetLinkWeight()));
Magic Number,Encog.Neural.NEAT,NEATUtil,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\NEATUtil.cs,ConstructNEATTrainer,The following statement contains a magic number: weightMutation.Components.Add(                      0.03'                      new NEATMutateWeights(new SelectFixed(3)'                              new MutateResetLinkWeight()));
Magic Number,Encog.Neural.NEAT,NEATUtil,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\NEATUtil.cs,ConstructNEATTrainer,The following statement contains a magic number: weightMutation.Components.Add(                      0.03'                      new NEATMutateWeights(new SelectFixed(3)'                              new MutateResetLinkWeight()));
Magic Number,Encog.Neural.NEAT,NEATUtil,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\NEATUtil.cs,ConstructNEATTrainer,The following statement contains a magic number: weightMutation.Components.Add(                      0.01'                      new NEATMutateWeights(new SelectProportion(0.02)'                              new MutateResetLinkWeight()));
Magic Number,Encog.Neural.NEAT,NEATUtil,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\NEATUtil.cs,ConstructNEATTrainer,The following statement contains a magic number: weightMutation.Components.Add(                      0.01'                      new NEATMutateWeights(new SelectProportion(0.02)'                              new MutateResetLinkWeight()));
Magic Number,Encog.Neural.NEAT,NEATUtil,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\NEATUtil.cs,ConstructNEATTrainer,The following statement contains a magic number: result.AddOperation(0.5' new NEATCrossover());
Magic Number,Encog.Neural.NEAT,NEATUtil,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\NEATUtil.cs,ConstructNEATTrainer,The following statement contains a magic number: result.AddOperation(0.494' weightMutation);
Magic Number,Encog.Neural.NEAT,NEATUtil,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\NEATUtil.cs,ConstructNEATTrainer,The following statement contains a magic number: result.AddOperation(0.0005' new NEATMutateAddNode());
Magic Number,Encog.Neural.NEAT,NEATUtil,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\NEATUtil.cs,ConstructNEATTrainer,The following statement contains a magic number: result.AddOperation(0.005' new NEATMutateAddLink());
Magic Number,Encog.Neural.NEAT,NEATUtil,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\NEATUtil.cs,ConstructNEATTrainer,The following statement contains a magic number: result.AddOperation(0.0005' new NEATMutateRemoveLink());
Magic Number,Encog.Neural.NEAT,PersistNEATPopulation,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: while ((section = reader.ReadNextSection()) != null)              {                  if (section.SectionName.Equals("NEAT-POPULATION")                          && section.SubSectionName.Equals("INNOVATIONS"))                  {                      foreach (String line in section.Lines)                      {                          IList<String> cols = EncogFileSection                                  .SplitColumns(line);                          var innovation = new NEATInnovation();                          var innovationId = int.Parse(cols[1]);                          innovation.InnovationId = innovationId;                          innovation.NeuronId = int.Parse(cols[2]);                          result.Innovations.Innovations[cols[0]] = innovation;                          nextInnovationId = Math.Max(nextInnovationId' innovationId + 1);                      }                  }                  else if (section.SectionName.Equals("NEAT-POPULATION")                        && section.SubSectionName.Equals("SPECIES"))                  {                      NEATGenome lastGenome = null;                      BasicSpecies lastSpecies = null;                        foreach (String line in section.Lines)                      {                          IList<String> cols = EncogFileSection.SplitColumns(line);                            if (String.Compare(cols[0]' "s"' StringComparison.OrdinalIgnoreCase) == 0)                          {                              lastSpecies = new BasicSpecies                                  {                                      Population = result'                                      Age = int.Parse(cols[1])'                                      BestScore = CSVFormat.EgFormat.Parse(cols[2])'                                      GensNoImprovement = int.Parse(cols[3])                                  };                              result.Species.Add(lastSpecies);                          }                          else if (String.Compare(cols[0]' "g"' StringComparison.OrdinalIgnoreCase) == 0)                          {                              bool isLeader = lastGenome == null;                              lastGenome = new NEATGenome                                  {                                      InputCount = result.InputCount'                                      OutputCount = result.OutputCount'                                      Species = lastSpecies'                                      AdjustedScore = CSVFormat.EgFormat.Parse(cols[1])'                                      Score = CSVFormat.EgFormat.Parse(cols[2])'                                      BirthGeneration = int.Parse(cols[3])                                  };                              lastSpecies.Add(lastGenome);                              if (isLeader)                              {                                  lastSpecies.Leader = lastGenome;                              }                          }                          else if (String.Compare(cols[0]' "n"' StringComparison.OrdinalIgnoreCase) == 0)                          {                              var neuronGene = new NEATNeuronGene();                              int geneId = int.Parse(cols[1]);                              neuronGene.Id = geneId;                                IActivationFunction af = EncogFileSection.ParseActivationFunction(cols[2]);                              neuronGene.ActivationFunction = af;                                neuronGene.NeuronType = PersistNEATPopulation.StringToNeuronType(cols[3]);                              neuronGene.InnovationId = int.Parse(cols[4]);                              lastGenome.NeuronsChromosome.Add(neuronGene);                              nextGeneId = Math.Max(geneId + 1' nextGeneId);                          }                          else if (String.Compare(cols[0]' "l"' StringComparison.OrdinalIgnoreCase) == 0)                          {                              var linkGene = new NEATLinkGene                                  {                                      Id = int.Parse(cols[1])'                                      Enabled = (int.Parse(cols[2]) > 0)'                                      FromNeuronId = int.Parse(cols[3])'                                      ToNeuronId = int.Parse(cols[4])'                                      Weight = CSVFormat.EgFormat.Parse(cols[5])'                                      InnovationId = int.Parse(cols[6])                                  };                              lastGenome.LinksChromosome.Add(linkGene);                          }                      }                    }                  else if (section.SectionName.Equals("NEAT-POPULATION")                        && section.SubSectionName.Equals("CONFIG"))                  {                      IDictionary<string' string> prm = section.ParseParams();                        string afStr = prm[NEATPopulation.PropertyNEATActivation];                        if (String.Compare(afStr' TypeCppn' StringComparison.OrdinalIgnoreCase) == 0)                      {                          HyperNEATGenome.BuildCPPNActivationFunctions(result.ActivationFunctions);                      }                      else                      {                          result.NEATActivationFunction = EncogFileSection.ParseActivationFunction(prm'                                          NEATPopulation.PropertyNEATActivation);                      }                        result.ActivationCycles = EncogFileSection.ParseInt(prm'                              PersistConst.ActivationCycles);                      result.InputCount = EncogFileSection.ParseInt(prm'                              PersistConst.InputCount);                      result.OutputCount = EncogFileSection.ParseInt(prm'                              PersistConst.OutputCount);                      result.PopulationSize = EncogFileSection.ParseInt(prm'                              NEATPopulation.PropertyPopulationSize);                      result.SurvivalRate = EncogFileSection.ParseDouble(prm'                              NEATPopulation.PropertySurvivalRate);                      result.ActivationCycles = EncogFileSection.ParseInt(prm'                              NEATPopulation.PropertyCycles);                  }              }
Magic Number,Encog.Neural.NEAT,PersistNEATPopulation,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: while ((section = reader.ReadNextSection()) != null)              {                  if (section.SectionName.Equals("NEAT-POPULATION")                          && section.SubSectionName.Equals("INNOVATIONS"))                  {                      foreach (String line in section.Lines)                      {                          IList<String> cols = EncogFileSection                                  .SplitColumns(line);                          var innovation = new NEATInnovation();                          var innovationId = int.Parse(cols[1]);                          innovation.InnovationId = innovationId;                          innovation.NeuronId = int.Parse(cols[2]);                          result.Innovations.Innovations[cols[0]] = innovation;                          nextInnovationId = Math.Max(nextInnovationId' innovationId + 1);                      }                  }                  else if (section.SectionName.Equals("NEAT-POPULATION")                        && section.SubSectionName.Equals("SPECIES"))                  {                      NEATGenome lastGenome = null;                      BasicSpecies lastSpecies = null;                        foreach (String line in section.Lines)                      {                          IList<String> cols = EncogFileSection.SplitColumns(line);                            if (String.Compare(cols[0]' "s"' StringComparison.OrdinalIgnoreCase) == 0)                          {                              lastSpecies = new BasicSpecies                                  {                                      Population = result'                                      Age = int.Parse(cols[1])'                                      BestScore = CSVFormat.EgFormat.Parse(cols[2])'                                      GensNoImprovement = int.Parse(cols[3])                                  };                              result.Species.Add(lastSpecies);                          }                          else if (String.Compare(cols[0]' "g"' StringComparison.OrdinalIgnoreCase) == 0)                          {                              bool isLeader = lastGenome == null;                              lastGenome = new NEATGenome                                  {                                      InputCount = result.InputCount'                                      OutputCount = result.OutputCount'                                      Species = lastSpecies'                                      AdjustedScore = CSVFormat.EgFormat.Parse(cols[1])'                                      Score = CSVFormat.EgFormat.Parse(cols[2])'                                      BirthGeneration = int.Parse(cols[3])                                  };                              lastSpecies.Add(lastGenome);                              if (isLeader)                              {                                  lastSpecies.Leader = lastGenome;                              }                          }                          else if (String.Compare(cols[0]' "n"' StringComparison.OrdinalIgnoreCase) == 0)                          {                              var neuronGene = new NEATNeuronGene();                              int geneId = int.Parse(cols[1]);                              neuronGene.Id = geneId;                                IActivationFunction af = EncogFileSection.ParseActivationFunction(cols[2]);                              neuronGene.ActivationFunction = af;                                neuronGene.NeuronType = PersistNEATPopulation.StringToNeuronType(cols[3]);                              neuronGene.InnovationId = int.Parse(cols[4]);                              lastGenome.NeuronsChromosome.Add(neuronGene);                              nextGeneId = Math.Max(geneId + 1' nextGeneId);                          }                          else if (String.Compare(cols[0]' "l"' StringComparison.OrdinalIgnoreCase) == 0)                          {                              var linkGene = new NEATLinkGene                                  {                                      Id = int.Parse(cols[1])'                                      Enabled = (int.Parse(cols[2]) > 0)'                                      FromNeuronId = int.Parse(cols[3])'                                      ToNeuronId = int.Parse(cols[4])'                                      Weight = CSVFormat.EgFormat.Parse(cols[5])'                                      InnovationId = int.Parse(cols[6])                                  };                              lastGenome.LinksChromosome.Add(linkGene);                          }                      }                    }                  else if (section.SectionName.Equals("NEAT-POPULATION")                        && section.SubSectionName.Equals("CONFIG"))                  {                      IDictionary<string' string> prm = section.ParseParams();                        string afStr = prm[NEATPopulation.PropertyNEATActivation];                        if (String.Compare(afStr' TypeCppn' StringComparison.OrdinalIgnoreCase) == 0)                      {                          HyperNEATGenome.BuildCPPNActivationFunctions(result.ActivationFunctions);                      }                      else                      {                          result.NEATActivationFunction = EncogFileSection.ParseActivationFunction(prm'                                          NEATPopulation.PropertyNEATActivation);                      }                        result.ActivationCycles = EncogFileSection.ParseInt(prm'                              PersistConst.ActivationCycles);                      result.InputCount = EncogFileSection.ParseInt(prm'                              PersistConst.InputCount);                      result.OutputCount = EncogFileSection.ParseInt(prm'                              PersistConst.OutputCount);                      result.PopulationSize = EncogFileSection.ParseInt(prm'                              NEATPopulation.PropertyPopulationSize);                      result.SurvivalRate = EncogFileSection.ParseDouble(prm'                              NEATPopulation.PropertySurvivalRate);                      result.ActivationCycles = EncogFileSection.ParseInt(prm'                              NEATPopulation.PropertyCycles);                  }              }
Magic Number,Encog.Neural.NEAT,PersistNEATPopulation,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: while ((section = reader.ReadNextSection()) != null)              {                  if (section.SectionName.Equals("NEAT-POPULATION")                          && section.SubSectionName.Equals("INNOVATIONS"))                  {                      foreach (String line in section.Lines)                      {                          IList<String> cols = EncogFileSection                                  .SplitColumns(line);                          var innovation = new NEATInnovation();                          var innovationId = int.Parse(cols[1]);                          innovation.InnovationId = innovationId;                          innovation.NeuronId = int.Parse(cols[2]);                          result.Innovations.Innovations[cols[0]] = innovation;                          nextInnovationId = Math.Max(nextInnovationId' innovationId + 1);                      }                  }                  else if (section.SectionName.Equals("NEAT-POPULATION")                        && section.SubSectionName.Equals("SPECIES"))                  {                      NEATGenome lastGenome = null;                      BasicSpecies lastSpecies = null;                        foreach (String line in section.Lines)                      {                          IList<String> cols = EncogFileSection.SplitColumns(line);                            if (String.Compare(cols[0]' "s"' StringComparison.OrdinalIgnoreCase) == 0)                          {                              lastSpecies = new BasicSpecies                                  {                                      Population = result'                                      Age = int.Parse(cols[1])'                                      BestScore = CSVFormat.EgFormat.Parse(cols[2])'                                      GensNoImprovement = int.Parse(cols[3])                                  };                              result.Species.Add(lastSpecies);                          }                          else if (String.Compare(cols[0]' "g"' StringComparison.OrdinalIgnoreCase) == 0)                          {                              bool isLeader = lastGenome == null;                              lastGenome = new NEATGenome                                  {                                      InputCount = result.InputCount'                                      OutputCount = result.OutputCount'                                      Species = lastSpecies'                                      AdjustedScore = CSVFormat.EgFormat.Parse(cols[1])'                                      Score = CSVFormat.EgFormat.Parse(cols[2])'                                      BirthGeneration = int.Parse(cols[3])                                  };                              lastSpecies.Add(lastGenome);                              if (isLeader)                              {                                  lastSpecies.Leader = lastGenome;                              }                          }                          else if (String.Compare(cols[0]' "n"' StringComparison.OrdinalIgnoreCase) == 0)                          {                              var neuronGene = new NEATNeuronGene();                              int geneId = int.Parse(cols[1]);                              neuronGene.Id = geneId;                                IActivationFunction af = EncogFileSection.ParseActivationFunction(cols[2]);                              neuronGene.ActivationFunction = af;                                neuronGene.NeuronType = PersistNEATPopulation.StringToNeuronType(cols[3]);                              neuronGene.InnovationId = int.Parse(cols[4]);                              lastGenome.NeuronsChromosome.Add(neuronGene);                              nextGeneId = Math.Max(geneId + 1' nextGeneId);                          }                          else if (String.Compare(cols[0]' "l"' StringComparison.OrdinalIgnoreCase) == 0)                          {                              var linkGene = new NEATLinkGene                                  {                                      Id = int.Parse(cols[1])'                                      Enabled = (int.Parse(cols[2]) > 0)'                                      FromNeuronId = int.Parse(cols[3])'                                      ToNeuronId = int.Parse(cols[4])'                                      Weight = CSVFormat.EgFormat.Parse(cols[5])'                                      InnovationId = int.Parse(cols[6])                                  };                              lastGenome.LinksChromosome.Add(linkGene);                          }                      }                    }                  else if (section.SectionName.Equals("NEAT-POPULATION")                        && section.SubSectionName.Equals("CONFIG"))                  {                      IDictionary<string' string> prm = section.ParseParams();                        string afStr = prm[NEATPopulation.PropertyNEATActivation];                        if (String.Compare(afStr' TypeCppn' StringComparison.OrdinalIgnoreCase) == 0)                      {                          HyperNEATGenome.BuildCPPNActivationFunctions(result.ActivationFunctions);                      }                      else                      {                          result.NEATActivationFunction = EncogFileSection.ParseActivationFunction(prm'                                          NEATPopulation.PropertyNEATActivation);                      }                        result.ActivationCycles = EncogFileSection.ParseInt(prm'                              PersistConst.ActivationCycles);                      result.InputCount = EncogFileSection.ParseInt(prm'                              PersistConst.InputCount);                      result.OutputCount = EncogFileSection.ParseInt(prm'                              PersistConst.OutputCount);                      result.PopulationSize = EncogFileSection.ParseInt(prm'                              NEATPopulation.PropertyPopulationSize);                      result.SurvivalRate = EncogFileSection.ParseDouble(prm'                              NEATPopulation.PropertySurvivalRate);                      result.ActivationCycles = EncogFileSection.ParseInt(prm'                              NEATPopulation.PropertyCycles);                  }              }
Magic Number,Encog.Neural.NEAT,PersistNEATPopulation,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: while ((section = reader.ReadNextSection()) != null)              {                  if (section.SectionName.Equals("NEAT-POPULATION")                          && section.SubSectionName.Equals("INNOVATIONS"))                  {                      foreach (String line in section.Lines)                      {                          IList<String> cols = EncogFileSection                                  .SplitColumns(line);                          var innovation = new NEATInnovation();                          var innovationId = int.Parse(cols[1]);                          innovation.InnovationId = innovationId;                          innovation.NeuronId = int.Parse(cols[2]);                          result.Innovations.Innovations[cols[0]] = innovation;                          nextInnovationId = Math.Max(nextInnovationId' innovationId + 1);                      }                  }                  else if (section.SectionName.Equals("NEAT-POPULATION")                        && section.SubSectionName.Equals("SPECIES"))                  {                      NEATGenome lastGenome = null;                      BasicSpecies lastSpecies = null;                        foreach (String line in section.Lines)                      {                          IList<String> cols = EncogFileSection.SplitColumns(line);                            if (String.Compare(cols[0]' "s"' StringComparison.OrdinalIgnoreCase) == 0)                          {                              lastSpecies = new BasicSpecies                                  {                                      Population = result'                                      Age = int.Parse(cols[1])'                                      BestScore = CSVFormat.EgFormat.Parse(cols[2])'                                      GensNoImprovement = int.Parse(cols[3])                                  };                              result.Species.Add(lastSpecies);                          }                          else if (String.Compare(cols[0]' "g"' StringComparison.OrdinalIgnoreCase) == 0)                          {                              bool isLeader = lastGenome == null;                              lastGenome = new NEATGenome                                  {                                      InputCount = result.InputCount'                                      OutputCount = result.OutputCount'                                      Species = lastSpecies'                                      AdjustedScore = CSVFormat.EgFormat.Parse(cols[1])'                                      Score = CSVFormat.EgFormat.Parse(cols[2])'                                      BirthGeneration = int.Parse(cols[3])                                  };                              lastSpecies.Add(lastGenome);                              if (isLeader)                              {                                  lastSpecies.Leader = lastGenome;                              }                          }                          else if (String.Compare(cols[0]' "n"' StringComparison.OrdinalIgnoreCase) == 0)                          {                              var neuronGene = new NEATNeuronGene();                              int geneId = int.Parse(cols[1]);                              neuronGene.Id = geneId;                                IActivationFunction af = EncogFileSection.ParseActivationFunction(cols[2]);                              neuronGene.ActivationFunction = af;                                neuronGene.NeuronType = PersistNEATPopulation.StringToNeuronType(cols[3]);                              neuronGene.InnovationId = int.Parse(cols[4]);                              lastGenome.NeuronsChromosome.Add(neuronGene);                              nextGeneId = Math.Max(geneId + 1' nextGeneId);                          }                          else if (String.Compare(cols[0]' "l"' StringComparison.OrdinalIgnoreCase) == 0)                          {                              var linkGene = new NEATLinkGene                                  {                                      Id = int.Parse(cols[1])'                                      Enabled = (int.Parse(cols[2]) > 0)'                                      FromNeuronId = int.Parse(cols[3])'                                      ToNeuronId = int.Parse(cols[4])'                                      Weight = CSVFormat.EgFormat.Parse(cols[5])'                                      InnovationId = int.Parse(cols[6])                                  };                              lastGenome.LinksChromosome.Add(linkGene);                          }                      }                    }                  else if (section.SectionName.Equals("NEAT-POPULATION")                        && section.SubSectionName.Equals("CONFIG"))                  {                      IDictionary<string' string> prm = section.ParseParams();                        string afStr = prm[NEATPopulation.PropertyNEATActivation];                        if (String.Compare(afStr' TypeCppn' StringComparison.OrdinalIgnoreCase) == 0)                      {                          HyperNEATGenome.BuildCPPNActivationFunctions(result.ActivationFunctions);                      }                      else                      {                          result.NEATActivationFunction = EncogFileSection.ParseActivationFunction(prm'                                          NEATPopulation.PropertyNEATActivation);                      }                        result.ActivationCycles = EncogFileSection.ParseInt(prm'                              PersistConst.ActivationCycles);                      result.InputCount = EncogFileSection.ParseInt(prm'                              PersistConst.InputCount);                      result.OutputCount = EncogFileSection.ParseInt(prm'                              PersistConst.OutputCount);                      result.PopulationSize = EncogFileSection.ParseInt(prm'                              NEATPopulation.PropertyPopulationSize);                      result.SurvivalRate = EncogFileSection.ParseDouble(prm'                              NEATPopulation.PropertySurvivalRate);                      result.ActivationCycles = EncogFileSection.ParseInt(prm'                              NEATPopulation.PropertyCycles);                  }              }
Magic Number,Encog.Neural.NEAT,PersistNEATPopulation,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: while ((section = reader.ReadNextSection()) != null)              {                  if (section.SectionName.Equals("NEAT-POPULATION")                          && section.SubSectionName.Equals("INNOVATIONS"))                  {                      foreach (String line in section.Lines)                      {                          IList<String> cols = EncogFileSection                                  .SplitColumns(line);                          var innovation = new NEATInnovation();                          var innovationId = int.Parse(cols[1]);                          innovation.InnovationId = innovationId;                          innovation.NeuronId = int.Parse(cols[2]);                          result.Innovations.Innovations[cols[0]] = innovation;                          nextInnovationId = Math.Max(nextInnovationId' innovationId + 1);                      }                  }                  else if (section.SectionName.Equals("NEAT-POPULATION")                        && section.SubSectionName.Equals("SPECIES"))                  {                      NEATGenome lastGenome = null;                      BasicSpecies lastSpecies = null;                        foreach (String line in section.Lines)                      {                          IList<String> cols = EncogFileSection.SplitColumns(line);                            if (String.Compare(cols[0]' "s"' StringComparison.OrdinalIgnoreCase) == 0)                          {                              lastSpecies = new BasicSpecies                                  {                                      Population = result'                                      Age = int.Parse(cols[1])'                                      BestScore = CSVFormat.EgFormat.Parse(cols[2])'                                      GensNoImprovement = int.Parse(cols[3])                                  };                              result.Species.Add(lastSpecies);                          }                          else if (String.Compare(cols[0]' "g"' StringComparison.OrdinalIgnoreCase) == 0)                          {                              bool isLeader = lastGenome == null;                              lastGenome = new NEATGenome                                  {                                      InputCount = result.InputCount'                                      OutputCount = result.OutputCount'                                      Species = lastSpecies'                                      AdjustedScore = CSVFormat.EgFormat.Parse(cols[1])'                                      Score = CSVFormat.EgFormat.Parse(cols[2])'                                      BirthGeneration = int.Parse(cols[3])                                  };                              lastSpecies.Add(lastGenome);                              if (isLeader)                              {                                  lastSpecies.Leader = lastGenome;                              }                          }                          else if (String.Compare(cols[0]' "n"' StringComparison.OrdinalIgnoreCase) == 0)                          {                              var neuronGene = new NEATNeuronGene();                              int geneId = int.Parse(cols[1]);                              neuronGene.Id = geneId;                                IActivationFunction af = EncogFileSection.ParseActivationFunction(cols[2]);                              neuronGene.ActivationFunction = af;                                neuronGene.NeuronType = PersistNEATPopulation.StringToNeuronType(cols[3]);                              neuronGene.InnovationId = int.Parse(cols[4]);                              lastGenome.NeuronsChromosome.Add(neuronGene);                              nextGeneId = Math.Max(geneId + 1' nextGeneId);                          }                          else if (String.Compare(cols[0]' "l"' StringComparison.OrdinalIgnoreCase) == 0)                          {                              var linkGene = new NEATLinkGene                                  {                                      Id = int.Parse(cols[1])'                                      Enabled = (int.Parse(cols[2]) > 0)'                                      FromNeuronId = int.Parse(cols[3])'                                      ToNeuronId = int.Parse(cols[4])'                                      Weight = CSVFormat.EgFormat.Parse(cols[5])'                                      InnovationId = int.Parse(cols[6])                                  };                              lastGenome.LinksChromosome.Add(linkGene);                          }                      }                    }                  else if (section.SectionName.Equals("NEAT-POPULATION")                        && section.SubSectionName.Equals("CONFIG"))                  {                      IDictionary<string' string> prm = section.ParseParams();                        string afStr = prm[NEATPopulation.PropertyNEATActivation];                        if (String.Compare(afStr' TypeCppn' StringComparison.OrdinalIgnoreCase) == 0)                      {                          HyperNEATGenome.BuildCPPNActivationFunctions(result.ActivationFunctions);                      }                      else                      {                          result.NEATActivationFunction = EncogFileSection.ParseActivationFunction(prm'                                          NEATPopulation.PropertyNEATActivation);                      }                        result.ActivationCycles = EncogFileSection.ParseInt(prm'                              PersistConst.ActivationCycles);                      result.InputCount = EncogFileSection.ParseInt(prm'                              PersistConst.InputCount);                      result.OutputCount = EncogFileSection.ParseInt(prm'                              PersistConst.OutputCount);                      result.PopulationSize = EncogFileSection.ParseInt(prm'                              NEATPopulation.PropertyPopulationSize);                      result.SurvivalRate = EncogFileSection.ParseDouble(prm'                              NEATPopulation.PropertySurvivalRate);                      result.ActivationCycles = EncogFileSection.ParseInt(prm'                              NEATPopulation.PropertyCycles);                  }              }
Magic Number,Encog.Neural.NEAT,PersistNEATPopulation,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: while ((section = reader.ReadNextSection()) != null)              {                  if (section.SectionName.Equals("NEAT-POPULATION")                          && section.SubSectionName.Equals("INNOVATIONS"))                  {                      foreach (String line in section.Lines)                      {                          IList<String> cols = EncogFileSection                                  .SplitColumns(line);                          var innovation = new NEATInnovation();                          var innovationId = int.Parse(cols[1]);                          innovation.InnovationId = innovationId;                          innovation.NeuronId = int.Parse(cols[2]);                          result.Innovations.Innovations[cols[0]] = innovation;                          nextInnovationId = Math.Max(nextInnovationId' innovationId + 1);                      }                  }                  else if (section.SectionName.Equals("NEAT-POPULATION")                        && section.SubSectionName.Equals("SPECIES"))                  {                      NEATGenome lastGenome = null;                      BasicSpecies lastSpecies = null;                        foreach (String line in section.Lines)                      {                          IList<String> cols = EncogFileSection.SplitColumns(line);                            if (String.Compare(cols[0]' "s"' StringComparison.OrdinalIgnoreCase) == 0)                          {                              lastSpecies = new BasicSpecies                                  {                                      Population = result'                                      Age = int.Parse(cols[1])'                                      BestScore = CSVFormat.EgFormat.Parse(cols[2])'                                      GensNoImprovement = int.Parse(cols[3])                                  };                              result.Species.Add(lastSpecies);                          }                          else if (String.Compare(cols[0]' "g"' StringComparison.OrdinalIgnoreCase) == 0)                          {                              bool isLeader = lastGenome == null;                              lastGenome = new NEATGenome                                  {                                      InputCount = result.InputCount'                                      OutputCount = result.OutputCount'                                      Species = lastSpecies'                                      AdjustedScore = CSVFormat.EgFormat.Parse(cols[1])'                                      Score = CSVFormat.EgFormat.Parse(cols[2])'                                      BirthGeneration = int.Parse(cols[3])                                  };                              lastSpecies.Add(lastGenome);                              if (isLeader)                              {                                  lastSpecies.Leader = lastGenome;                              }                          }                          else if (String.Compare(cols[0]' "n"' StringComparison.OrdinalIgnoreCase) == 0)                          {                              var neuronGene = new NEATNeuronGene();                              int geneId = int.Parse(cols[1]);                              neuronGene.Id = geneId;                                IActivationFunction af = EncogFileSection.ParseActivationFunction(cols[2]);                              neuronGene.ActivationFunction = af;                                neuronGene.NeuronType = PersistNEATPopulation.StringToNeuronType(cols[3]);                              neuronGene.InnovationId = int.Parse(cols[4]);                              lastGenome.NeuronsChromosome.Add(neuronGene);                              nextGeneId = Math.Max(geneId + 1' nextGeneId);                          }                          else if (String.Compare(cols[0]' "l"' StringComparison.OrdinalIgnoreCase) == 0)                          {                              var linkGene = new NEATLinkGene                                  {                                      Id = int.Parse(cols[1])'                                      Enabled = (int.Parse(cols[2]) > 0)'                                      FromNeuronId = int.Parse(cols[3])'                                      ToNeuronId = int.Parse(cols[4])'                                      Weight = CSVFormat.EgFormat.Parse(cols[5])'                                      InnovationId = int.Parse(cols[6])                                  };                              lastGenome.LinksChromosome.Add(linkGene);                          }                      }                    }                  else if (section.SectionName.Equals("NEAT-POPULATION")                        && section.SubSectionName.Equals("CONFIG"))                  {                      IDictionary<string' string> prm = section.ParseParams();                        string afStr = prm[NEATPopulation.PropertyNEATActivation];                        if (String.Compare(afStr' TypeCppn' StringComparison.OrdinalIgnoreCase) == 0)                      {                          HyperNEATGenome.BuildCPPNActivationFunctions(result.ActivationFunctions);                      }                      else                      {                          result.NEATActivationFunction = EncogFileSection.ParseActivationFunction(prm'                                          NEATPopulation.PropertyNEATActivation);                      }                        result.ActivationCycles = EncogFileSection.ParseInt(prm'                              PersistConst.ActivationCycles);                      result.InputCount = EncogFileSection.ParseInt(prm'                              PersistConst.InputCount);                      result.OutputCount = EncogFileSection.ParseInt(prm'                              PersistConst.OutputCount);                      result.PopulationSize = EncogFileSection.ParseInt(prm'                              NEATPopulation.PropertyPopulationSize);                      result.SurvivalRate = EncogFileSection.ParseDouble(prm'                              NEATPopulation.PropertySurvivalRate);                      result.ActivationCycles = EncogFileSection.ParseInt(prm'                              NEATPopulation.PropertyCycles);                  }              }
Magic Number,Encog.Neural.NEAT,PersistNEATPopulation,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: while ((section = reader.ReadNextSection()) != null)              {                  if (section.SectionName.Equals("NEAT-POPULATION")                          && section.SubSectionName.Equals("INNOVATIONS"))                  {                      foreach (String line in section.Lines)                      {                          IList<String> cols = EncogFileSection                                  .SplitColumns(line);                          var innovation = new NEATInnovation();                          var innovationId = int.Parse(cols[1]);                          innovation.InnovationId = innovationId;                          innovation.NeuronId = int.Parse(cols[2]);                          result.Innovations.Innovations[cols[0]] = innovation;                          nextInnovationId = Math.Max(nextInnovationId' innovationId + 1);                      }                  }                  else if (section.SectionName.Equals("NEAT-POPULATION")                        && section.SubSectionName.Equals("SPECIES"))                  {                      NEATGenome lastGenome = null;                      BasicSpecies lastSpecies = null;                        foreach (String line in section.Lines)                      {                          IList<String> cols = EncogFileSection.SplitColumns(line);                            if (String.Compare(cols[0]' "s"' StringComparison.OrdinalIgnoreCase) == 0)                          {                              lastSpecies = new BasicSpecies                                  {                                      Population = result'                                      Age = int.Parse(cols[1])'                                      BestScore = CSVFormat.EgFormat.Parse(cols[2])'                                      GensNoImprovement = int.Parse(cols[3])                                  };                              result.Species.Add(lastSpecies);                          }                          else if (String.Compare(cols[0]' "g"' StringComparison.OrdinalIgnoreCase) == 0)                          {                              bool isLeader = lastGenome == null;                              lastGenome = new NEATGenome                                  {                                      InputCount = result.InputCount'                                      OutputCount = result.OutputCount'                                      Species = lastSpecies'                                      AdjustedScore = CSVFormat.EgFormat.Parse(cols[1])'                                      Score = CSVFormat.EgFormat.Parse(cols[2])'                                      BirthGeneration = int.Parse(cols[3])                                  };                              lastSpecies.Add(lastGenome);                              if (isLeader)                              {                                  lastSpecies.Leader = lastGenome;                              }                          }                          else if (String.Compare(cols[0]' "n"' StringComparison.OrdinalIgnoreCase) == 0)                          {                              var neuronGene = new NEATNeuronGene();                              int geneId = int.Parse(cols[1]);                              neuronGene.Id = geneId;                                IActivationFunction af = EncogFileSection.ParseActivationFunction(cols[2]);                              neuronGene.ActivationFunction = af;                                neuronGene.NeuronType = PersistNEATPopulation.StringToNeuronType(cols[3]);                              neuronGene.InnovationId = int.Parse(cols[4]);                              lastGenome.NeuronsChromosome.Add(neuronGene);                              nextGeneId = Math.Max(geneId + 1' nextGeneId);                          }                          else if (String.Compare(cols[0]' "l"' StringComparison.OrdinalIgnoreCase) == 0)                          {                              var linkGene = new NEATLinkGene                                  {                                      Id = int.Parse(cols[1])'                                      Enabled = (int.Parse(cols[2]) > 0)'                                      FromNeuronId = int.Parse(cols[3])'                                      ToNeuronId = int.Parse(cols[4])'                                      Weight = CSVFormat.EgFormat.Parse(cols[5])'                                      InnovationId = int.Parse(cols[6])                                  };                              lastGenome.LinksChromosome.Add(linkGene);                          }                      }                    }                  else if (section.SectionName.Equals("NEAT-POPULATION")                        && section.SubSectionName.Equals("CONFIG"))                  {                      IDictionary<string' string> prm = section.ParseParams();                        string afStr = prm[NEATPopulation.PropertyNEATActivation];                        if (String.Compare(afStr' TypeCppn' StringComparison.OrdinalIgnoreCase) == 0)                      {                          HyperNEATGenome.BuildCPPNActivationFunctions(result.ActivationFunctions);                      }                      else                      {                          result.NEATActivationFunction = EncogFileSection.ParseActivationFunction(prm'                                          NEATPopulation.PropertyNEATActivation);                      }                        result.ActivationCycles = EncogFileSection.ParseInt(prm'                              PersistConst.ActivationCycles);                      result.InputCount = EncogFileSection.ParseInt(prm'                              PersistConst.InputCount);                      result.OutputCount = EncogFileSection.ParseInt(prm'                              PersistConst.OutputCount);                      result.PopulationSize = EncogFileSection.ParseInt(prm'                              NEATPopulation.PropertyPopulationSize);                      result.SurvivalRate = EncogFileSection.ParseDouble(prm'                              NEATPopulation.PropertySurvivalRate);                      result.ActivationCycles = EncogFileSection.ParseInt(prm'                              NEATPopulation.PropertyCycles);                  }              }
Magic Number,Encog.Neural.NEAT,PersistNEATPopulation,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: while ((section = reader.ReadNextSection()) != null)              {                  if (section.SectionName.Equals("NEAT-POPULATION")                          && section.SubSectionName.Equals("INNOVATIONS"))                  {                      foreach (String line in section.Lines)                      {                          IList<String> cols = EncogFileSection                                  .SplitColumns(line);                          var innovation = new NEATInnovation();                          var innovationId = int.Parse(cols[1]);                          innovation.InnovationId = innovationId;                          innovation.NeuronId = int.Parse(cols[2]);                          result.Innovations.Innovations[cols[0]] = innovation;                          nextInnovationId = Math.Max(nextInnovationId' innovationId + 1);                      }                  }                  else if (section.SectionName.Equals("NEAT-POPULATION")                        && section.SubSectionName.Equals("SPECIES"))                  {                      NEATGenome lastGenome = null;                      BasicSpecies lastSpecies = null;                        foreach (String line in section.Lines)                      {                          IList<String> cols = EncogFileSection.SplitColumns(line);                            if (String.Compare(cols[0]' "s"' StringComparison.OrdinalIgnoreCase) == 0)                          {                              lastSpecies = new BasicSpecies                                  {                                      Population = result'                                      Age = int.Parse(cols[1])'                                      BestScore = CSVFormat.EgFormat.Parse(cols[2])'                                      GensNoImprovement = int.Parse(cols[3])                                  };                              result.Species.Add(lastSpecies);                          }                          else if (String.Compare(cols[0]' "g"' StringComparison.OrdinalIgnoreCase) == 0)                          {                              bool isLeader = lastGenome == null;                              lastGenome = new NEATGenome                                  {                                      InputCount = result.InputCount'                                      OutputCount = result.OutputCount'                                      Species = lastSpecies'                                      AdjustedScore = CSVFormat.EgFormat.Parse(cols[1])'                                      Score = CSVFormat.EgFormat.Parse(cols[2])'                                      BirthGeneration = int.Parse(cols[3])                                  };                              lastSpecies.Add(lastGenome);                              if (isLeader)                              {                                  lastSpecies.Leader = lastGenome;                              }                          }                          else if (String.Compare(cols[0]' "n"' StringComparison.OrdinalIgnoreCase) == 0)                          {                              var neuronGene = new NEATNeuronGene();                              int geneId = int.Parse(cols[1]);                              neuronGene.Id = geneId;                                IActivationFunction af = EncogFileSection.ParseActivationFunction(cols[2]);                              neuronGene.ActivationFunction = af;                                neuronGene.NeuronType = PersistNEATPopulation.StringToNeuronType(cols[3]);                              neuronGene.InnovationId = int.Parse(cols[4]);                              lastGenome.NeuronsChromosome.Add(neuronGene);                              nextGeneId = Math.Max(geneId + 1' nextGeneId);                          }                          else if (String.Compare(cols[0]' "l"' StringComparison.OrdinalIgnoreCase) == 0)                          {                              var linkGene = new NEATLinkGene                                  {                                      Id = int.Parse(cols[1])'                                      Enabled = (int.Parse(cols[2]) > 0)'                                      FromNeuronId = int.Parse(cols[3])'                                      ToNeuronId = int.Parse(cols[4])'                                      Weight = CSVFormat.EgFormat.Parse(cols[5])'                                      InnovationId = int.Parse(cols[6])                                  };                              lastGenome.LinksChromosome.Add(linkGene);                          }                      }                    }                  else if (section.SectionName.Equals("NEAT-POPULATION")                        && section.SubSectionName.Equals("CONFIG"))                  {                      IDictionary<string' string> prm = section.ParseParams();                        string afStr = prm[NEATPopulation.PropertyNEATActivation];                        if (String.Compare(afStr' TypeCppn' StringComparison.OrdinalIgnoreCase) == 0)                      {                          HyperNEATGenome.BuildCPPNActivationFunctions(result.ActivationFunctions);                      }                      else                      {                          result.NEATActivationFunction = EncogFileSection.ParseActivationFunction(prm'                                          NEATPopulation.PropertyNEATActivation);                      }                        result.ActivationCycles = EncogFileSection.ParseInt(prm'                              PersistConst.ActivationCycles);                      result.InputCount = EncogFileSection.ParseInt(prm'                              PersistConst.InputCount);                      result.OutputCount = EncogFileSection.ParseInt(prm'                              PersistConst.OutputCount);                      result.PopulationSize = EncogFileSection.ParseInt(prm'                              NEATPopulation.PropertyPopulationSize);                      result.SurvivalRate = EncogFileSection.ParseDouble(prm'                              NEATPopulation.PropertySurvivalRate);                      result.ActivationCycles = EncogFileSection.ParseInt(prm'                              NEATPopulation.PropertyCycles);                  }              }
Magic Number,Encog.Neural.NEAT,PersistNEATPopulation,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: while ((section = reader.ReadNextSection()) != null)              {                  if (section.SectionName.Equals("NEAT-POPULATION")                          && section.SubSectionName.Equals("INNOVATIONS"))                  {                      foreach (String line in section.Lines)                      {                          IList<String> cols = EncogFileSection                                  .SplitColumns(line);                          var innovation = new NEATInnovation();                          var innovationId = int.Parse(cols[1]);                          innovation.InnovationId = innovationId;                          innovation.NeuronId = int.Parse(cols[2]);                          result.Innovations.Innovations[cols[0]] = innovation;                          nextInnovationId = Math.Max(nextInnovationId' innovationId + 1);                      }                  }                  else if (section.SectionName.Equals("NEAT-POPULATION")                        && section.SubSectionName.Equals("SPECIES"))                  {                      NEATGenome lastGenome = null;                      BasicSpecies lastSpecies = null;                        foreach (String line in section.Lines)                      {                          IList<String> cols = EncogFileSection.SplitColumns(line);                            if (String.Compare(cols[0]' "s"' StringComparison.OrdinalIgnoreCase) == 0)                          {                              lastSpecies = new BasicSpecies                                  {                                      Population = result'                                      Age = int.Parse(cols[1])'                                      BestScore = CSVFormat.EgFormat.Parse(cols[2])'                                      GensNoImprovement = int.Parse(cols[3])                                  };                              result.Species.Add(lastSpecies);                          }                          else if (String.Compare(cols[0]' "g"' StringComparison.OrdinalIgnoreCase) == 0)                          {                              bool isLeader = lastGenome == null;                              lastGenome = new NEATGenome                                  {                                      InputCount = result.InputCount'                                      OutputCount = result.OutputCount'                                      Species = lastSpecies'                                      AdjustedScore = CSVFormat.EgFormat.Parse(cols[1])'                                      Score = CSVFormat.EgFormat.Parse(cols[2])'                                      BirthGeneration = int.Parse(cols[3])                                  };                              lastSpecies.Add(lastGenome);                              if (isLeader)                              {                                  lastSpecies.Leader = lastGenome;                              }                          }                          else if (String.Compare(cols[0]' "n"' StringComparison.OrdinalIgnoreCase) == 0)                          {                              var neuronGene = new NEATNeuronGene();                              int geneId = int.Parse(cols[1]);                              neuronGene.Id = geneId;                                IActivationFunction af = EncogFileSection.ParseActivationFunction(cols[2]);                              neuronGene.ActivationFunction = af;                                neuronGene.NeuronType = PersistNEATPopulation.StringToNeuronType(cols[3]);                              neuronGene.InnovationId = int.Parse(cols[4]);                              lastGenome.NeuronsChromosome.Add(neuronGene);                              nextGeneId = Math.Max(geneId + 1' nextGeneId);                          }                          else if (String.Compare(cols[0]' "l"' StringComparison.OrdinalIgnoreCase) == 0)                          {                              var linkGene = new NEATLinkGene                                  {                                      Id = int.Parse(cols[1])'                                      Enabled = (int.Parse(cols[2]) > 0)'                                      FromNeuronId = int.Parse(cols[3])'                                      ToNeuronId = int.Parse(cols[4])'                                      Weight = CSVFormat.EgFormat.Parse(cols[5])'                                      InnovationId = int.Parse(cols[6])                                  };                              lastGenome.LinksChromosome.Add(linkGene);                          }                      }                    }                  else if (section.SectionName.Equals("NEAT-POPULATION")                        && section.SubSectionName.Equals("CONFIG"))                  {                      IDictionary<string' string> prm = section.ParseParams();                        string afStr = prm[NEATPopulation.PropertyNEATActivation];                        if (String.Compare(afStr' TypeCppn' StringComparison.OrdinalIgnoreCase) == 0)                      {                          HyperNEATGenome.BuildCPPNActivationFunctions(result.ActivationFunctions);                      }                      else                      {                          result.NEATActivationFunction = EncogFileSection.ParseActivationFunction(prm'                                          NEATPopulation.PropertyNEATActivation);                      }                        result.ActivationCycles = EncogFileSection.ParseInt(prm'                              PersistConst.ActivationCycles);                      result.InputCount = EncogFileSection.ParseInt(prm'                              PersistConst.InputCount);                      result.OutputCount = EncogFileSection.ParseInt(prm'                              PersistConst.OutputCount);                      result.PopulationSize = EncogFileSection.ParseInt(prm'                              NEATPopulation.PropertyPopulationSize);                      result.SurvivalRate = EncogFileSection.ParseDouble(prm'                              NEATPopulation.PropertySurvivalRate);                      result.ActivationCycles = EncogFileSection.ParseInt(prm'                              NEATPopulation.PropertyCycles);                  }              }
Magic Number,Encog.Neural.NEAT,PersistNEATPopulation,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: while ((section = reader.ReadNextSection()) != null)              {                  if (section.SectionName.Equals("NEAT-POPULATION")                          && section.SubSectionName.Equals("INNOVATIONS"))                  {                      foreach (String line in section.Lines)                      {                          IList<String> cols = EncogFileSection                                  .SplitColumns(line);                          var innovation = new NEATInnovation();                          var innovationId = int.Parse(cols[1]);                          innovation.InnovationId = innovationId;                          innovation.NeuronId = int.Parse(cols[2]);                          result.Innovations.Innovations[cols[0]] = innovation;                          nextInnovationId = Math.Max(nextInnovationId' innovationId + 1);                      }                  }                  else if (section.SectionName.Equals("NEAT-POPULATION")                        && section.SubSectionName.Equals("SPECIES"))                  {                      NEATGenome lastGenome = null;                      BasicSpecies lastSpecies = null;                        foreach (String line in section.Lines)                      {                          IList<String> cols = EncogFileSection.SplitColumns(line);                            if (String.Compare(cols[0]' "s"' StringComparison.OrdinalIgnoreCase) == 0)                          {                              lastSpecies = new BasicSpecies                                  {                                      Population = result'                                      Age = int.Parse(cols[1])'                                      BestScore = CSVFormat.EgFormat.Parse(cols[2])'                                      GensNoImprovement = int.Parse(cols[3])                                  };                              result.Species.Add(lastSpecies);                          }                          else if (String.Compare(cols[0]' "g"' StringComparison.OrdinalIgnoreCase) == 0)                          {                              bool isLeader = lastGenome == null;                              lastGenome = new NEATGenome                                  {                                      InputCount = result.InputCount'                                      OutputCount = result.OutputCount'                                      Species = lastSpecies'                                      AdjustedScore = CSVFormat.EgFormat.Parse(cols[1])'                                      Score = CSVFormat.EgFormat.Parse(cols[2])'                                      BirthGeneration = int.Parse(cols[3])                                  };                              lastSpecies.Add(lastGenome);                              if (isLeader)                              {                                  lastSpecies.Leader = lastGenome;                              }                          }                          else if (String.Compare(cols[0]' "n"' StringComparison.OrdinalIgnoreCase) == 0)                          {                              var neuronGene = new NEATNeuronGene();                              int geneId = int.Parse(cols[1]);                              neuronGene.Id = geneId;                                IActivationFunction af = EncogFileSection.ParseActivationFunction(cols[2]);                              neuronGene.ActivationFunction = af;                                neuronGene.NeuronType = PersistNEATPopulation.StringToNeuronType(cols[3]);                              neuronGene.InnovationId = int.Parse(cols[4]);                              lastGenome.NeuronsChromosome.Add(neuronGene);                              nextGeneId = Math.Max(geneId + 1' nextGeneId);                          }                          else if (String.Compare(cols[0]' "l"' StringComparison.OrdinalIgnoreCase) == 0)                          {                              var linkGene = new NEATLinkGene                                  {                                      Id = int.Parse(cols[1])'                                      Enabled = (int.Parse(cols[2]) > 0)'                                      FromNeuronId = int.Parse(cols[3])'                                      ToNeuronId = int.Parse(cols[4])'                                      Weight = CSVFormat.EgFormat.Parse(cols[5])'                                      InnovationId = int.Parse(cols[6])                                  };                              lastGenome.LinksChromosome.Add(linkGene);                          }                      }                    }                  else if (section.SectionName.Equals("NEAT-POPULATION")                        && section.SubSectionName.Equals("CONFIG"))                  {                      IDictionary<string' string> prm = section.ParseParams();                        string afStr = prm[NEATPopulation.PropertyNEATActivation];                        if (String.Compare(afStr' TypeCppn' StringComparison.OrdinalIgnoreCase) == 0)                      {                          HyperNEATGenome.BuildCPPNActivationFunctions(result.ActivationFunctions);                      }                      else                      {                          result.NEATActivationFunction = EncogFileSection.ParseActivationFunction(prm'                                          NEATPopulation.PropertyNEATActivation);                      }                        result.ActivationCycles = EncogFileSection.ParseInt(prm'                              PersistConst.ActivationCycles);                      result.InputCount = EncogFileSection.ParseInt(prm'                              PersistConst.InputCount);                      result.OutputCount = EncogFileSection.ParseInt(prm'                              PersistConst.OutputCount);                      result.PopulationSize = EncogFileSection.ParseInt(prm'                              NEATPopulation.PropertyPopulationSize);                      result.SurvivalRate = EncogFileSection.ParseDouble(prm'                              NEATPopulation.PropertySurvivalRate);                      result.ActivationCycles = EncogFileSection.ParseInt(prm'                              NEATPopulation.PropertyCycles);                  }              }
Magic Number,Encog.Neural.NEAT,PersistNEATPopulation,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: while ((section = reader.ReadNextSection()) != null)              {                  if (section.SectionName.Equals("NEAT-POPULATION")                          && section.SubSectionName.Equals("INNOVATIONS"))                  {                      foreach (String line in section.Lines)                      {                          IList<String> cols = EncogFileSection                                  .SplitColumns(line);                          var innovation = new NEATInnovation();                          var innovationId = int.Parse(cols[1]);                          innovation.InnovationId = innovationId;                          innovation.NeuronId = int.Parse(cols[2]);                          result.Innovations.Innovations[cols[0]] = innovation;                          nextInnovationId = Math.Max(nextInnovationId' innovationId + 1);                      }                  }                  else if (section.SectionName.Equals("NEAT-POPULATION")                        && section.SubSectionName.Equals("SPECIES"))                  {                      NEATGenome lastGenome = null;                      BasicSpecies lastSpecies = null;                        foreach (String line in section.Lines)                      {                          IList<String> cols = EncogFileSection.SplitColumns(line);                            if (String.Compare(cols[0]' "s"' StringComparison.OrdinalIgnoreCase) == 0)                          {                              lastSpecies = new BasicSpecies                                  {                                      Population = result'                                      Age = int.Parse(cols[1])'                                      BestScore = CSVFormat.EgFormat.Parse(cols[2])'                                      GensNoImprovement = int.Parse(cols[3])                                  };                              result.Species.Add(lastSpecies);                          }                          else if (String.Compare(cols[0]' "g"' StringComparison.OrdinalIgnoreCase) == 0)                          {                              bool isLeader = lastGenome == null;                              lastGenome = new NEATGenome                                  {                                      InputCount = result.InputCount'                                      OutputCount = result.OutputCount'                                      Species = lastSpecies'                                      AdjustedScore = CSVFormat.EgFormat.Parse(cols[1])'                                      Score = CSVFormat.EgFormat.Parse(cols[2])'                                      BirthGeneration = int.Parse(cols[3])                                  };                              lastSpecies.Add(lastGenome);                              if (isLeader)                              {                                  lastSpecies.Leader = lastGenome;                              }                          }                          else if (String.Compare(cols[0]' "n"' StringComparison.OrdinalIgnoreCase) == 0)                          {                              var neuronGene = new NEATNeuronGene();                              int geneId = int.Parse(cols[1]);                              neuronGene.Id = geneId;                                IActivationFunction af = EncogFileSection.ParseActivationFunction(cols[2]);                              neuronGene.ActivationFunction = af;                                neuronGene.NeuronType = PersistNEATPopulation.StringToNeuronType(cols[3]);                              neuronGene.InnovationId = int.Parse(cols[4]);                              lastGenome.NeuronsChromosome.Add(neuronGene);                              nextGeneId = Math.Max(geneId + 1' nextGeneId);                          }                          else if (String.Compare(cols[0]' "l"' StringComparison.OrdinalIgnoreCase) == 0)                          {                              var linkGene = new NEATLinkGene                                  {                                      Id = int.Parse(cols[1])'                                      Enabled = (int.Parse(cols[2]) > 0)'                                      FromNeuronId = int.Parse(cols[3])'                                      ToNeuronId = int.Parse(cols[4])'                                      Weight = CSVFormat.EgFormat.Parse(cols[5])'                                      InnovationId = int.Parse(cols[6])                                  };                              lastGenome.LinksChromosome.Add(linkGene);                          }                      }                    }                  else if (section.SectionName.Equals("NEAT-POPULATION")                        && section.SubSectionName.Equals("CONFIG"))                  {                      IDictionary<string' string> prm = section.ParseParams();                        string afStr = prm[NEATPopulation.PropertyNEATActivation];                        if (String.Compare(afStr' TypeCppn' StringComparison.OrdinalIgnoreCase) == 0)                      {                          HyperNEATGenome.BuildCPPNActivationFunctions(result.ActivationFunctions);                      }                      else                      {                          result.NEATActivationFunction = EncogFileSection.ParseActivationFunction(prm'                                          NEATPopulation.PropertyNEATActivation);                      }                        result.ActivationCycles = EncogFileSection.ParseInt(prm'                              PersistConst.ActivationCycles);                      result.InputCount = EncogFileSection.ParseInt(prm'                              PersistConst.InputCount);                      result.OutputCount = EncogFileSection.ParseInt(prm'                              PersistConst.OutputCount);                      result.PopulationSize = EncogFileSection.ParseInt(prm'                              NEATPopulation.PropertyPopulationSize);                      result.SurvivalRate = EncogFileSection.ParseDouble(prm'                              NEATPopulation.PropertySurvivalRate);                      result.ActivationCycles = EncogFileSection.ParseInt(prm'                              NEATPopulation.PropertyCycles);                  }              }
Magic Number,Encog.Neural.NEAT,PersistNEATPopulation,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: while ((section = reader.ReadNextSection()) != null)              {                  if (section.SectionName.Equals("NEAT-POPULATION")                          && section.SubSectionName.Equals("INNOVATIONS"))                  {                      foreach (String line in section.Lines)                      {                          IList<String> cols = EncogFileSection                                  .SplitColumns(line);                          var innovation = new NEATInnovation();                          var innovationId = int.Parse(cols[1]);                          innovation.InnovationId = innovationId;                          innovation.NeuronId = int.Parse(cols[2]);                          result.Innovations.Innovations[cols[0]] = innovation;                          nextInnovationId = Math.Max(nextInnovationId' innovationId + 1);                      }                  }                  else if (section.SectionName.Equals("NEAT-POPULATION")                        && section.SubSectionName.Equals("SPECIES"))                  {                      NEATGenome lastGenome = null;                      BasicSpecies lastSpecies = null;                        foreach (String line in section.Lines)                      {                          IList<String> cols = EncogFileSection.SplitColumns(line);                            if (String.Compare(cols[0]' "s"' StringComparison.OrdinalIgnoreCase) == 0)                          {                              lastSpecies = new BasicSpecies                                  {                                      Population = result'                                      Age = int.Parse(cols[1])'                                      BestScore = CSVFormat.EgFormat.Parse(cols[2])'                                      GensNoImprovement = int.Parse(cols[3])                                  };                              result.Species.Add(lastSpecies);                          }                          else if (String.Compare(cols[0]' "g"' StringComparison.OrdinalIgnoreCase) == 0)                          {                              bool isLeader = lastGenome == null;                              lastGenome = new NEATGenome                                  {                                      InputCount = result.InputCount'                                      OutputCount = result.OutputCount'                                      Species = lastSpecies'                                      AdjustedScore = CSVFormat.EgFormat.Parse(cols[1])'                                      Score = CSVFormat.EgFormat.Parse(cols[2])'                                      BirthGeneration = int.Parse(cols[3])                                  };                              lastSpecies.Add(lastGenome);                              if (isLeader)                              {                                  lastSpecies.Leader = lastGenome;                              }                          }                          else if (String.Compare(cols[0]' "n"' StringComparison.OrdinalIgnoreCase) == 0)                          {                              var neuronGene = new NEATNeuronGene();                              int geneId = int.Parse(cols[1]);                              neuronGene.Id = geneId;                                IActivationFunction af = EncogFileSection.ParseActivationFunction(cols[2]);                              neuronGene.ActivationFunction = af;                                neuronGene.NeuronType = PersistNEATPopulation.StringToNeuronType(cols[3]);                              neuronGene.InnovationId = int.Parse(cols[4]);                              lastGenome.NeuronsChromosome.Add(neuronGene);                              nextGeneId = Math.Max(geneId + 1' nextGeneId);                          }                          else if (String.Compare(cols[0]' "l"' StringComparison.OrdinalIgnoreCase) == 0)                          {                              var linkGene = new NEATLinkGene                                  {                                      Id = int.Parse(cols[1])'                                      Enabled = (int.Parse(cols[2]) > 0)'                                      FromNeuronId = int.Parse(cols[3])'                                      ToNeuronId = int.Parse(cols[4])'                                      Weight = CSVFormat.EgFormat.Parse(cols[5])'                                      InnovationId = int.Parse(cols[6])                                  };                              lastGenome.LinksChromosome.Add(linkGene);                          }                      }                    }                  else if (section.SectionName.Equals("NEAT-POPULATION")                        && section.SubSectionName.Equals("CONFIG"))                  {                      IDictionary<string' string> prm = section.ParseParams();                        string afStr = prm[NEATPopulation.PropertyNEATActivation];                        if (String.Compare(afStr' TypeCppn' StringComparison.OrdinalIgnoreCase) == 0)                      {                          HyperNEATGenome.BuildCPPNActivationFunctions(result.ActivationFunctions);                      }                      else                      {                          result.NEATActivationFunction = EncogFileSection.ParseActivationFunction(prm'                                          NEATPopulation.PropertyNEATActivation);                      }                        result.ActivationCycles = EncogFileSection.ParseInt(prm'                              PersistConst.ActivationCycles);                      result.InputCount = EncogFileSection.ParseInt(prm'                              PersistConst.InputCount);                      result.OutputCount = EncogFileSection.ParseInt(prm'                              PersistConst.OutputCount);                      result.PopulationSize = EncogFileSection.ParseInt(prm'                              NEATPopulation.PropertyPopulationSize);                      result.SurvivalRate = EncogFileSection.ParseDouble(prm'                              NEATPopulation.PropertySurvivalRate);                      result.ActivationCycles = EncogFileSection.ParseInt(prm'                              NEATPopulation.PropertyCycles);                  }              }
Magic Number,Encog.Neural.NEAT,PersistNEATPopulation,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: while ((section = reader.ReadNextSection()) != null)              {                  if (section.SectionName.Equals("NEAT-POPULATION")                          && section.SubSectionName.Equals("INNOVATIONS"))                  {                      foreach (String line in section.Lines)                      {                          IList<String> cols = EncogFileSection                                  .SplitColumns(line);                          var innovation = new NEATInnovation();                          var innovationId = int.Parse(cols[1]);                          innovation.InnovationId = innovationId;                          innovation.NeuronId = int.Parse(cols[2]);                          result.Innovations.Innovations[cols[0]] = innovation;                          nextInnovationId = Math.Max(nextInnovationId' innovationId + 1);                      }                  }                  else if (section.SectionName.Equals("NEAT-POPULATION")                        && section.SubSectionName.Equals("SPECIES"))                  {                      NEATGenome lastGenome = null;                      BasicSpecies lastSpecies = null;                        foreach (String line in section.Lines)                      {                          IList<String> cols = EncogFileSection.SplitColumns(line);                            if (String.Compare(cols[0]' "s"' StringComparison.OrdinalIgnoreCase) == 0)                          {                              lastSpecies = new BasicSpecies                                  {                                      Population = result'                                      Age = int.Parse(cols[1])'                                      BestScore = CSVFormat.EgFormat.Parse(cols[2])'                                      GensNoImprovement = int.Parse(cols[3])                                  };                              result.Species.Add(lastSpecies);                          }                          else if (String.Compare(cols[0]' "g"' StringComparison.OrdinalIgnoreCase) == 0)                          {                              bool isLeader = lastGenome == null;                              lastGenome = new NEATGenome                                  {                                      InputCount = result.InputCount'                                      OutputCount = result.OutputCount'                                      Species = lastSpecies'                                      AdjustedScore = CSVFormat.EgFormat.Parse(cols[1])'                                      Score = CSVFormat.EgFormat.Parse(cols[2])'                                      BirthGeneration = int.Parse(cols[3])                                  };                              lastSpecies.Add(lastGenome);                              if (isLeader)                              {                                  lastSpecies.Leader = lastGenome;                              }                          }                          else if (String.Compare(cols[0]' "n"' StringComparison.OrdinalIgnoreCase) == 0)                          {                              var neuronGene = new NEATNeuronGene();                              int geneId = int.Parse(cols[1]);                              neuronGene.Id = geneId;                                IActivationFunction af = EncogFileSection.ParseActivationFunction(cols[2]);                              neuronGene.ActivationFunction = af;                                neuronGene.NeuronType = PersistNEATPopulation.StringToNeuronType(cols[3]);                              neuronGene.InnovationId = int.Parse(cols[4]);                              lastGenome.NeuronsChromosome.Add(neuronGene);                              nextGeneId = Math.Max(geneId + 1' nextGeneId);                          }                          else if (String.Compare(cols[0]' "l"' StringComparison.OrdinalIgnoreCase) == 0)                          {                              var linkGene = new NEATLinkGene                                  {                                      Id = int.Parse(cols[1])'                                      Enabled = (int.Parse(cols[2]) > 0)'                                      FromNeuronId = int.Parse(cols[3])'                                      ToNeuronId = int.Parse(cols[4])'                                      Weight = CSVFormat.EgFormat.Parse(cols[5])'                                      InnovationId = int.Parse(cols[6])                                  };                              lastGenome.LinksChromosome.Add(linkGene);                          }                      }                    }                  else if (section.SectionName.Equals("NEAT-POPULATION")                        && section.SubSectionName.Equals("CONFIG"))                  {                      IDictionary<string' string> prm = section.ParseParams();                        string afStr = prm[NEATPopulation.PropertyNEATActivation];                        if (String.Compare(afStr' TypeCppn' StringComparison.OrdinalIgnoreCase) == 0)                      {                          HyperNEATGenome.BuildCPPNActivationFunctions(result.ActivationFunctions);                      }                      else                      {                          result.NEATActivationFunction = EncogFileSection.ParseActivationFunction(prm'                                          NEATPopulation.PropertyNEATActivation);                      }                        result.ActivationCycles = EncogFileSection.ParseInt(prm'                              PersistConst.ActivationCycles);                      result.InputCount = EncogFileSection.ParseInt(prm'                              PersistConst.InputCount);                      result.OutputCount = EncogFileSection.ParseInt(prm'                              PersistConst.OutputCount);                      result.PopulationSize = EncogFileSection.ParseInt(prm'                              NEATPopulation.PropertyPopulationSize);                      result.SurvivalRate = EncogFileSection.ParseDouble(prm'                              NEATPopulation.PropertySurvivalRate);                      result.ActivationCycles = EncogFileSection.ParseInt(prm'                              NEATPopulation.PropertyCycles);                  }              }
Magic Number,Encog.Neural.NEAT,NEATPopulation,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\NEATPopulation.cs,NEATPopulation,The following statement contains a magic number: WeightRange = 5;
Magic Number,Encog.Neural.NEAT,NEATPopulation,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\NEATPopulation.cs,NEATPopulation,The following statement contains a magic number: InitialConnectionDensity = 0.1;
Magic Number,Encog.Neural.NEAT,NEATPopulation,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\NEATPopulation.cs,NEATPopulation,The following statement contains a magic number: WeightRange = 5;
Magic Number,Encog.Neural.NEAT,NEATPopulation,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\NEATPopulation.cs,NEATPopulation,The following statement contains a magic number: InitialConnectionDensity = 0.1;
Magic Number,Encog.Neural.NEAT,NEATPopulation,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\NEATPopulation.cs,NEATPopulation,The following statement contains a magic number: WeightRange = 5;
Magic Number,Encog.Neural.NEAT,NEATPopulation,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\NEATPopulation.cs,NEATPopulation,The following statement contains a magic number: InitialConnectionDensity = 0.1;
Magic Number,Encog.Neural.NEAT,NEATPopulation,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\NEATPopulation.cs,NEATPopulation,The following statement contains a magic number: InputCount = 6;
Magic Number,Encog.Neural.NEAT,NEATPopulation,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\NEATPopulation.cs,NEATPopulation,The following statement contains a magic number: OutputCount = 2;
Magic Number,Encog.Neural.NEAT.Training,NEATGenome,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\Training\NEATGenome.cs,ToString,The following statement contains a magic number: result.Append(Format.FormatDouble(Score' 2));
Magic Number,Encog.Neural.NEAT.Training,NEATGenome,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\Training\NEATGenome.cs,ToString,The following statement contains a magic number: result.Append(Format.FormatDouble(AdjustedScore' 2));
Magic Number,Encog.Neural.NEAT.Training.Opp,NEATCrossover,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\Training\Opp\NEATCrossover.cs,FavorParent,The following statement contains a magic number: if (Math.Abs(mom.Score - dad.Score) < EncogFramework.DefaultDoubleEqual)              {                  // are mom and dad the same fitness                  if (mom.NumGenes == dad.NumGenes)                  {                      // if mom and dad are the same fitness and have the same number                      // of genes'                      // then randomly pick mom or dad as the most fit.                      if (rnd.NextDouble() > 0.5)                      {                          return mom;                      }                      return dad;                  }                      // mom and dad are the same fitness' but different number of genes                  // favor the parent with fewer genes                  if (mom.NumGenes < dad.NumGenes)                  {                      return mom;                  }                  return dad;              }
Magic Number,Encog.Neural.NEAT.Training.Opp,NEATMutateAddNode,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\Training\Opp\NEATMutateAddNode.cs,PerformOperation,The following statement contains a magic number: int sizeBias = ((NEATGenome)parents[0]).InputCount                      + ((NEATGenome)parents[0]).OutputCount + 10;
Magic Number,Encog.Neural.NEAT.Training.Species,OriginalNEATSpeciation,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\Training\Species\OriginalNEATSpeciation.cs,OriginalNEATSpeciation,The following statement contains a magic number: ConstMatched = 0.4;
Magic Number,Encog.Neural.Networks.Structure,NeuralStructure,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Structure\NeuralStructure.cs,FinalizeStructure,The following statement contains a magic number: if (_layers.Count < 2)              {                  throw new NeuralNetworkError(                      "There must be at least two layers before the structure is finalized.");              }
Magic Number,Encog.Neural.Networks.Training.Lma,LevenbergMarquardtTraining,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\LMA\LevenbergMarquardtTraining.cs,LevenbergMarquardtTraining,The following statement contains a magic number: _lambda = 0.1;
Magic Number,Encog.Neural.Networks.Training.NM,NelderMeadTraining,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\NM\NelderMeadTraining.cs,NelderMeadTraining,The following statement contains a magic number: _jcount = _konvge = 500;
Magic Number,Encog.Neural.Networks.Training.NM,NelderMeadTraining,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\NM\NelderMeadTraining.cs,Iteration,The following statement contains a magic number: for (;;)              {                  /*                   * if (kcount <= icount) { break; }                   */                  _ynewlo = _y[0];                  _ihi = 0;                    for (int i = 1; i < _nn; i++)                  {                      if (_ynewlo < _y[i])                      {                          _ynewlo = _y[i];                          _ihi = i;                      }                  }                  /*                   * Calculate PBAR' the centroid of the simplex vertices excepting                   * the vertex with Y value YNEWLO.                   */                  for (int i = 0; i < n; i++)                  {                      _z = 0.0;                      for (int j = 0; j < _nn; j++)                      {                          _z = _z + _p[i + j*n];                      }                      _z = _z - _p[i + _ihi*n];                      _pbar[i] = _z/n;                  }                  /*                   * Reflection through the centroid.                   */                  for (int i = 0; i < n; i++)                  {                      _pstar[i] = _pbar[i] + rcoeff                                 *(_pbar[i] - _p[i + _ihi*n]);                  }                  _ystar = Fn(_pstar);                  /*                   * Successful reflection' so extension.                   */                  if (_ystar < _ylo)                  {                      for (int i = 0; i < n; i++)                      {                          _p2Star[i] = _pbar[i] + ecoeff                                      *(_pstar[i] - _pbar[i]);                      }                      _y2Star = Fn(_p2Star);                      /*                       * Check extension.                       */                      if (_ystar < _y2Star)                      {                          for (int i = 0; i < n; i++)                          {                              _p[i + _ihi*n] = _pstar[i];                          }                          _y[_ihi] = _ystar;                      }                          /*                       * Retain extension or contraction.                       */                      else                      {                          for (int i = 0; i < n; i++)                          {                              _p[i + _ihi*n] = _p2Star[i];                          }                          _y[_ihi] = _y2Star;                      }                  }                      /*                   * No extension.                   */                  else                  {                      _l = 0;                      for (int i = 0; i < _nn; i++)                      {                          if (_ystar < _y[i])                          {                              _l = _l + 1;                          }                      }                        if (1 < _l)                      {                          for (int i = 0; i < n; i++)                          {                              _p[i + _ihi*n] = _pstar[i];                          }                          _y[_ihi] = _ystar;                      }                          /*                       * Contraction on the Y(IHI) side of the centroid.                       */                      else if (_l == 0)                      {                          for (int i = 0; i < n; i++)                          {                              _p2Star[i] = _pbar[i] + ccoeff                                          *(_p[i + _ihi*n] - _pbar[i]);                          }                          _y2Star = Fn(_p2Star);                          /*                           * Contract the whole simplex.                           */                          if (_y[_ihi] < _y2Star)                          {                              for (int j = 0; j < _nn; j++)                              {                                  for (int i = 0; i < n; i++)                                  {                                      _p[i + j*n] = (_p[i + j*n] + _p[i                                                                   + _ilo*n])*0.5;                                      _trainedWeights[i] = _p[i + j*n];                                  }                                  _y[j] = Fn(_trainedWeights);                              }                              _ylo = _y[0];                              _ilo = 0;                                for (int i = 1; i < _nn; i++)                              {                                  if (_y[i] < _ylo)                                  {                                      _ylo = _y[i];                                      _ilo = i;                                  }                              }                              continue;                          }                              /*                           * Retain contraction.                           */                          for (int i = 0; i < n; i++)                          {                              _p[i + _ihi*n] = _p2Star[i];                          }                          _y[_ihi] = _y2Star;                      }                          /*                       * Contraction on the reflection side of the centroid.                       */                      else if (_l == 1)                      {                          for (int i = 0; i < n; i++)                          {                              _p2Star[i] = _pbar[i] + ccoeff                                          *(_pstar[i] - _pbar[i]);                          }                          _y2Star = Fn(_p2Star);                          /*                           * Retain reflection?                           */                          if (_y2Star <= _ystar)                          {                              for (int i = 0; i < n; i++)                              {                                  _p[i + _ihi*n] = _p2Star[i];                              }                              _y[_ihi] = _y2Star;                          }                          else                          {                              for (int i = 0; i < n; i++)                              {                                  _p[i + _ihi*n] = _pstar[i];                              }                              _y[_ihi] = _ystar;                          }                      }                  }                  /*                   * Check if YLO improved.                   */                  if (_y[_ihi] < _ylo)                  {                      _ylo = _y[_ihi];                      _ilo = _ihi;                  }                  _jcount = _jcount - 1;                    if (0 < _jcount)                  {                      continue;                  }                  /*                   * Check to see if minimum reached.                   */                  // if (icount <= kcount)                  {                      _jcount = _konvge;                        _z = 0.0;                      for (int i = 0; i < _nn; i++)                      {                          _z = _z + _y[i];                      }                      double x = _z/_nn;                        _z = 0.0;                      for (int i = 0; i < _nn; i++)                      {  						var inner = _y[i] - x;                          _z = _z + inner * inner;                      }                        if (_z <= _rq)                      {                          break;                      }                  }              }
Magic Number,Encog.Neural.Networks.Training.PNN,DeriveMinimum,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\PNN\DeriveMinimum.cs,Calculate,The following statement contains a magic number: for (int iteration = 0; iteration < maxIterations; iteration++)              {                  if (fbest < maxError)                  {                      break;                  }                    EncogLogging.Log(EncogLogging.LevelInfo'                      "Beginning internal Iteration #" + iteration + "' currentError=" + fbest + "'target=" + maxError);                     // Check for convergence                  double toler;                  if (prevBest <= 1.0d)                  {                      toler = tol;                  }                  else                  {                      toler = tol*prevBest;                  }                    // Stop if there is little improvement                  if ((prevBest - fbest) <= toler)                  {                      if (++convergenceCounter >= 3)                      {                          break;                      }                  }                  else                  {                      convergenceCounter = 0;                  }                    double dot2 = 0;                  double dlen = 0;                  double dot1 = dot2 = dlen = 0.0d;                  double high = 1.0e-4d;                  for (int i= 0; i < n; i++)                  {                      bs[i] = x[i];                      if (deriv2[i] > high)                      {                          high = deriv2[i];                      }                      dot1 += direc[i]*g[i]; // Directional first derivative                      dot2 += direc[i]*direc[i]*deriv2[i]; // and second                      dlen += direc[i]*direc[i]; // Length of search vector                  }                    double scale;                    if (Math.Abs(dot2) < EncogFramework.DefaultDoubleEqual)                  {                      scale = 0;                  }                  else                  {                      scale = dot1/dot2;                  }                  high = 1.5d/high;                  if (high < 1.0e-4d)                  {                      high = 1.0e-4d;                  }                    if (scale < 0.0d)                  {                      scale = high;                  }                  else if (scale < 0.1d*high)                  {                      scale = 0.1d*high;                  }                  else if (scale > 10.0d*high)                  {                      scale = 10.0d*high;                  }                    prevBest = fbest;                  globalMinimum.Y2 = fbest;                    globalMinimum.FindBestRange(0.0d' 2.0d*scale' -3' false' maxError'                                              network);                    if (globalMinimum.Y2 < maxError)                  {                      if (globalMinimum.Y2 < fbest)                      {                          for (int i = 0; i < n; i++)                          {                              x[i] = bs[i] + globalMinimum.Y2*direc[i];                              if (x[i] < 1.0e-10d)                              {                                  x[i] = 1.0e-10d;                              }                          }                          fbest = globalMinimum.Y2;                      }                      else                      {                          for (int i = 0; i < n; i++)                          {                              x[i] = bs[i];                          }                      }                      break;                  }                    if (convergenceCounter > 0)                  {                      fbest = globalMinimum.Brentmin(20' maxError' eps' 1.0e-7d'                                                     network' globalMinimum.Y2);                  }                  else                  {                      fbest = globalMinimum.Brentmin(10' maxError' 1.0e-6d' 1.0e-5d'                                                     network' globalMinimum.Y2);                  }                    for (int i = 0; i < n; i++)                  {                      x[i] = bs[i] + globalMinimum.X2*direc[i];                      if (x[i] < 1.0e-10d)                      {                          x[i] = 1.0e-10d;                      }                  }                    double improvement = (prevBest - fbest)/prevBest;                    if (fbest < maxError)                  {                      break;                  }                    for (int i = 0; i < n; i++)                  {                      direc[i] = -direc[i]; // negative gradient                  }                    double gam = Gamma(n' g' direc);                    if (gam < 0.0d)                  {                      gam = 0.0d;                  }                    if (gam > 10.0d)                  {                      gam = 10.0d;                  }                    if (improvement < 0.001d)                  {                      ++poorCj;                  }                  else                  {                      poorCj = 0;                  }                    if (poorCj >= 2)                  {                      if (gam > 1.0d)                      {                          gam = 1.0d;                      }                  }                    if (poorCj >= 6)                  {                      poorCj = 0;                      gam = 0.0d;                  }                    FindNewDir(n' gam' g' h' direc);              }
Magic Number,Encog.Neural.Networks.Training.PNN,DeriveMinimum,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\PNN\DeriveMinimum.cs,Calculate,The following statement contains a magic number: for (int iteration = 0; iteration < maxIterations; iteration++)              {                  if (fbest < maxError)                  {                      break;                  }                    EncogLogging.Log(EncogLogging.LevelInfo'                      "Beginning internal Iteration #" + iteration + "' currentError=" + fbest + "'target=" + maxError);                     // Check for convergence                  double toler;                  if (prevBest <= 1.0d)                  {                      toler = tol;                  }                  else                  {                      toler = tol*prevBest;                  }                    // Stop if there is little improvement                  if ((prevBest - fbest) <= toler)                  {                      if (++convergenceCounter >= 3)                      {                          break;                      }                  }                  else                  {                      convergenceCounter = 0;                  }                    double dot2 = 0;                  double dlen = 0;                  double dot1 = dot2 = dlen = 0.0d;                  double high = 1.0e-4d;                  for (int i= 0; i < n; i++)                  {                      bs[i] = x[i];                      if (deriv2[i] > high)                      {                          high = deriv2[i];                      }                      dot1 += direc[i]*g[i]; // Directional first derivative                      dot2 += direc[i]*direc[i]*deriv2[i]; // and second                      dlen += direc[i]*direc[i]; // Length of search vector                  }                    double scale;                    if (Math.Abs(dot2) < EncogFramework.DefaultDoubleEqual)                  {                      scale = 0;                  }                  else                  {                      scale = dot1/dot2;                  }                  high = 1.5d/high;                  if (high < 1.0e-4d)                  {                      high = 1.0e-4d;                  }                    if (scale < 0.0d)                  {                      scale = high;                  }                  else if (scale < 0.1d*high)                  {                      scale = 0.1d*high;                  }                  else if (scale > 10.0d*high)                  {                      scale = 10.0d*high;                  }                    prevBest = fbest;                  globalMinimum.Y2 = fbest;                    globalMinimum.FindBestRange(0.0d' 2.0d*scale' -3' false' maxError'                                              network);                    if (globalMinimum.Y2 < maxError)                  {                      if (globalMinimum.Y2 < fbest)                      {                          for (int i = 0; i < n; i++)                          {                              x[i] = bs[i] + globalMinimum.Y2*direc[i];                              if (x[i] < 1.0e-10d)                              {                                  x[i] = 1.0e-10d;                              }                          }                          fbest = globalMinimum.Y2;                      }                      else                      {                          for (int i = 0; i < n; i++)                          {                              x[i] = bs[i];                          }                      }                      break;                  }                    if (convergenceCounter > 0)                  {                      fbest = globalMinimum.Brentmin(20' maxError' eps' 1.0e-7d'                                                     network' globalMinimum.Y2);                  }                  else                  {                      fbest = globalMinimum.Brentmin(10' maxError' 1.0e-6d' 1.0e-5d'                                                     network' globalMinimum.Y2);                  }                    for (int i = 0; i < n; i++)                  {                      x[i] = bs[i] + globalMinimum.X2*direc[i];                      if (x[i] < 1.0e-10d)                      {                          x[i] = 1.0e-10d;                      }                  }                    double improvement = (prevBest - fbest)/prevBest;                    if (fbest < maxError)                  {                      break;                  }                    for (int i = 0; i < n; i++)                  {                      direc[i] = -direc[i]; // negative gradient                  }                    double gam = Gamma(n' g' direc);                    if (gam < 0.0d)                  {                      gam = 0.0d;                  }                    if (gam > 10.0d)                  {                      gam = 10.0d;                  }                    if (improvement < 0.001d)                  {                      ++poorCj;                  }                  else                  {                      poorCj = 0;                  }                    if (poorCj >= 2)                  {                      if (gam > 1.0d)                      {                          gam = 1.0d;                      }                  }                    if (poorCj >= 6)                  {                      poorCj = 0;                      gam = 0.0d;                  }                    FindNewDir(n' gam' g' h' direc);              }
Magic Number,Encog.Neural.Networks.Training.PNN,DeriveMinimum,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\PNN\DeriveMinimum.cs,Calculate,The following statement contains a magic number: for (int iteration = 0; iteration < maxIterations; iteration++)              {                  if (fbest < maxError)                  {                      break;                  }                    EncogLogging.Log(EncogLogging.LevelInfo'                      "Beginning internal Iteration #" + iteration + "' currentError=" + fbest + "'target=" + maxError);                     // Check for convergence                  double toler;                  if (prevBest <= 1.0d)                  {                      toler = tol;                  }                  else                  {                      toler = tol*prevBest;                  }                    // Stop if there is little improvement                  if ((prevBest - fbest) <= toler)                  {                      if (++convergenceCounter >= 3)                      {                          break;                      }                  }                  else                  {                      convergenceCounter = 0;                  }                    double dot2 = 0;                  double dlen = 0;                  double dot1 = dot2 = dlen = 0.0d;                  double high = 1.0e-4d;                  for (int i= 0; i < n; i++)                  {                      bs[i] = x[i];                      if (deriv2[i] > high)                      {                          high = deriv2[i];                      }                      dot1 += direc[i]*g[i]; // Directional first derivative                      dot2 += direc[i]*direc[i]*deriv2[i]; // and second                      dlen += direc[i]*direc[i]; // Length of search vector                  }                    double scale;                    if (Math.Abs(dot2) < EncogFramework.DefaultDoubleEqual)                  {                      scale = 0;                  }                  else                  {                      scale = dot1/dot2;                  }                  high = 1.5d/high;                  if (high < 1.0e-4d)                  {                      high = 1.0e-4d;                  }                    if (scale < 0.0d)                  {                      scale = high;                  }                  else if (scale < 0.1d*high)                  {                      scale = 0.1d*high;                  }                  else if (scale > 10.0d*high)                  {                      scale = 10.0d*high;                  }                    prevBest = fbest;                  globalMinimum.Y2 = fbest;                    globalMinimum.FindBestRange(0.0d' 2.0d*scale' -3' false' maxError'                                              network);                    if (globalMinimum.Y2 < maxError)                  {                      if (globalMinimum.Y2 < fbest)                      {                          for (int i = 0; i < n; i++)                          {                              x[i] = bs[i] + globalMinimum.Y2*direc[i];                              if (x[i] < 1.0e-10d)                              {                                  x[i] = 1.0e-10d;                              }                          }                          fbest = globalMinimum.Y2;                      }                      else                      {                          for (int i = 0; i < n; i++)                          {                              x[i] = bs[i];                          }                      }                      break;                  }                    if (convergenceCounter > 0)                  {                      fbest = globalMinimum.Brentmin(20' maxError' eps' 1.0e-7d'                                                     network' globalMinimum.Y2);                  }                  else                  {                      fbest = globalMinimum.Brentmin(10' maxError' 1.0e-6d' 1.0e-5d'                                                     network' globalMinimum.Y2);                  }                    for (int i = 0; i < n; i++)                  {                      x[i] = bs[i] + globalMinimum.X2*direc[i];                      if (x[i] < 1.0e-10d)                      {                          x[i] = 1.0e-10d;                      }                  }                    double improvement = (prevBest - fbest)/prevBest;                    if (fbest < maxError)                  {                      break;                  }                    for (int i = 0; i < n; i++)                  {                      direc[i] = -direc[i]; // negative gradient                  }                    double gam = Gamma(n' g' direc);                    if (gam < 0.0d)                  {                      gam = 0.0d;                  }                    if (gam > 10.0d)                  {                      gam = 10.0d;                  }                    if (improvement < 0.001d)                  {                      ++poorCj;                  }                  else                  {                      poorCj = 0;                  }                    if (poorCj >= 2)                  {                      if (gam > 1.0d)                      {                          gam = 1.0d;                      }                  }                    if (poorCj >= 6)                  {                      poorCj = 0;                      gam = 0.0d;                  }                    FindNewDir(n' gam' g' h' direc);              }
Magic Number,Encog.Neural.Networks.Training.PNN,DeriveMinimum,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\PNN\DeriveMinimum.cs,Calculate,The following statement contains a magic number: for (int iteration = 0; iteration < maxIterations; iteration++)              {                  if (fbest < maxError)                  {                      break;                  }                    EncogLogging.Log(EncogLogging.LevelInfo'                      "Beginning internal Iteration #" + iteration + "' currentError=" + fbest + "'target=" + maxError);                     // Check for convergence                  double toler;                  if (prevBest <= 1.0d)                  {                      toler = tol;                  }                  else                  {                      toler = tol*prevBest;                  }                    // Stop if there is little improvement                  if ((prevBest - fbest) <= toler)                  {                      if (++convergenceCounter >= 3)                      {                          break;                      }                  }                  else                  {                      convergenceCounter = 0;                  }                    double dot2 = 0;                  double dlen = 0;                  double dot1 = dot2 = dlen = 0.0d;                  double high = 1.0e-4d;                  for (int i= 0; i < n; i++)                  {                      bs[i] = x[i];                      if (deriv2[i] > high)                      {                          high = deriv2[i];                      }                      dot1 += direc[i]*g[i]; // Directional first derivative                      dot2 += direc[i]*direc[i]*deriv2[i]; // and second                      dlen += direc[i]*direc[i]; // Length of search vector                  }                    double scale;                    if (Math.Abs(dot2) < EncogFramework.DefaultDoubleEqual)                  {                      scale = 0;                  }                  else                  {                      scale = dot1/dot2;                  }                  high = 1.5d/high;                  if (high < 1.0e-4d)                  {                      high = 1.0e-4d;                  }                    if (scale < 0.0d)                  {                      scale = high;                  }                  else if (scale < 0.1d*high)                  {                      scale = 0.1d*high;                  }                  else if (scale > 10.0d*high)                  {                      scale = 10.0d*high;                  }                    prevBest = fbest;                  globalMinimum.Y2 = fbest;                    globalMinimum.FindBestRange(0.0d' 2.0d*scale' -3' false' maxError'                                              network);                    if (globalMinimum.Y2 < maxError)                  {                      if (globalMinimum.Y2 < fbest)                      {                          for (int i = 0; i < n; i++)                          {                              x[i] = bs[i] + globalMinimum.Y2*direc[i];                              if (x[i] < 1.0e-10d)                              {                                  x[i] = 1.0e-10d;                              }                          }                          fbest = globalMinimum.Y2;                      }                      else                      {                          for (int i = 0; i < n; i++)                          {                              x[i] = bs[i];                          }                      }                      break;                  }                    if (convergenceCounter > 0)                  {                      fbest = globalMinimum.Brentmin(20' maxError' eps' 1.0e-7d'                                                     network' globalMinimum.Y2);                  }                  else                  {                      fbest = globalMinimum.Brentmin(10' maxError' 1.0e-6d' 1.0e-5d'                                                     network' globalMinimum.Y2);                  }                    for (int i = 0; i < n; i++)                  {                      x[i] = bs[i] + globalMinimum.X2*direc[i];                      if (x[i] < 1.0e-10d)                      {                          x[i] = 1.0e-10d;                      }                  }                    double improvement = (prevBest - fbest)/prevBest;                    if (fbest < maxError)                  {                      break;                  }                    for (int i = 0; i < n; i++)                  {                      direc[i] = -direc[i]; // negative gradient                  }                    double gam = Gamma(n' g' direc);                    if (gam < 0.0d)                  {                      gam = 0.0d;                  }                    if (gam > 10.0d)                  {                      gam = 10.0d;                  }                    if (improvement < 0.001d)                  {                      ++poorCj;                  }                  else                  {                      poorCj = 0;                  }                    if (poorCj >= 2)                  {                      if (gam > 1.0d)                      {                          gam = 1.0d;                      }                  }                    if (poorCj >= 6)                  {                      poorCj = 0;                      gam = 0.0d;                  }                    FindNewDir(n' gam' g' h' direc);              }
Magic Number,Encog.Neural.Networks.Training.PNN,DeriveMinimum,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\PNN\DeriveMinimum.cs,Calculate,The following statement contains a magic number: for (int iteration = 0; iteration < maxIterations; iteration++)              {                  if (fbest < maxError)                  {                      break;                  }                    EncogLogging.Log(EncogLogging.LevelInfo'                      "Beginning internal Iteration #" + iteration + "' currentError=" + fbest + "'target=" + maxError);                     // Check for convergence                  double toler;                  if (prevBest <= 1.0d)                  {                      toler = tol;                  }                  else                  {                      toler = tol*prevBest;                  }                    // Stop if there is little improvement                  if ((prevBest - fbest) <= toler)                  {                      if (++convergenceCounter >= 3)                      {                          break;                      }                  }                  else                  {                      convergenceCounter = 0;                  }                    double dot2 = 0;                  double dlen = 0;                  double dot1 = dot2 = dlen = 0.0d;                  double high = 1.0e-4d;                  for (int i= 0; i < n; i++)                  {                      bs[i] = x[i];                      if (deriv2[i] > high)                      {                          high = deriv2[i];                      }                      dot1 += direc[i]*g[i]; // Directional first derivative                      dot2 += direc[i]*direc[i]*deriv2[i]; // and second                      dlen += direc[i]*direc[i]; // Length of search vector                  }                    double scale;                    if (Math.Abs(dot2) < EncogFramework.DefaultDoubleEqual)                  {                      scale = 0;                  }                  else                  {                      scale = dot1/dot2;                  }                  high = 1.5d/high;                  if (high < 1.0e-4d)                  {                      high = 1.0e-4d;                  }                    if (scale < 0.0d)                  {                      scale = high;                  }                  else if (scale < 0.1d*high)                  {                      scale = 0.1d*high;                  }                  else if (scale > 10.0d*high)                  {                      scale = 10.0d*high;                  }                    prevBest = fbest;                  globalMinimum.Y2 = fbest;                    globalMinimum.FindBestRange(0.0d' 2.0d*scale' -3' false' maxError'                                              network);                    if (globalMinimum.Y2 < maxError)                  {                      if (globalMinimum.Y2 < fbest)                      {                          for (int i = 0; i < n; i++)                          {                              x[i] = bs[i] + globalMinimum.Y2*direc[i];                              if (x[i] < 1.0e-10d)                              {                                  x[i] = 1.0e-10d;                              }                          }                          fbest = globalMinimum.Y2;                      }                      else                      {                          for (int i = 0; i < n; i++)                          {                              x[i] = bs[i];                          }                      }                      break;                  }                    if (convergenceCounter > 0)                  {                      fbest = globalMinimum.Brentmin(20' maxError' eps' 1.0e-7d'                                                     network' globalMinimum.Y2);                  }                  else                  {                      fbest = globalMinimum.Brentmin(10' maxError' 1.0e-6d' 1.0e-5d'                                                     network' globalMinimum.Y2);                  }                    for (int i = 0; i < n; i++)                  {                      x[i] = bs[i] + globalMinimum.X2*direc[i];                      if (x[i] < 1.0e-10d)                      {                          x[i] = 1.0e-10d;                      }                  }                    double improvement = (prevBest - fbest)/prevBest;                    if (fbest < maxError)                  {                      break;                  }                    for (int i = 0; i < n; i++)                  {                      direc[i] = -direc[i]; // negative gradient                  }                    double gam = Gamma(n' g' direc);                    if (gam < 0.0d)                  {                      gam = 0.0d;                  }                    if (gam > 10.0d)                  {                      gam = 10.0d;                  }                    if (improvement < 0.001d)                  {                      ++poorCj;                  }                  else                  {                      poorCj = 0;                  }                    if (poorCj >= 2)                  {                      if (gam > 1.0d)                      {                          gam = 1.0d;                      }                  }                    if (poorCj >= 6)                  {                      poorCj = 0;                      gam = 0.0d;                  }                    FindNewDir(n' gam' g' h' direc);              }
Magic Number,Encog.Neural.Networks.Training.PNN,DeriveMinimum,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\PNN\DeriveMinimum.cs,Calculate,The following statement contains a magic number: for (int iteration = 0; iteration < maxIterations; iteration++)              {                  if (fbest < maxError)                  {                      break;                  }                    EncogLogging.Log(EncogLogging.LevelInfo'                      "Beginning internal Iteration #" + iteration + "' currentError=" + fbest + "'target=" + maxError);                     // Check for convergence                  double toler;                  if (prevBest <= 1.0d)                  {                      toler = tol;                  }                  else                  {                      toler = tol*prevBest;                  }                    // Stop if there is little improvement                  if ((prevBest - fbest) <= toler)                  {                      if (++convergenceCounter >= 3)                      {                          break;                      }                  }                  else                  {                      convergenceCounter = 0;                  }                    double dot2 = 0;                  double dlen = 0;                  double dot1 = dot2 = dlen = 0.0d;                  double high = 1.0e-4d;                  for (int i= 0; i < n; i++)                  {                      bs[i] = x[i];                      if (deriv2[i] > high)                      {                          high = deriv2[i];                      }                      dot1 += direc[i]*g[i]; // Directional first derivative                      dot2 += direc[i]*direc[i]*deriv2[i]; // and second                      dlen += direc[i]*direc[i]; // Length of search vector                  }                    double scale;                    if (Math.Abs(dot2) < EncogFramework.DefaultDoubleEqual)                  {                      scale = 0;                  }                  else                  {                      scale = dot1/dot2;                  }                  high = 1.5d/high;                  if (high < 1.0e-4d)                  {                      high = 1.0e-4d;                  }                    if (scale < 0.0d)                  {                      scale = high;                  }                  else if (scale < 0.1d*high)                  {                      scale = 0.1d*high;                  }                  else if (scale > 10.0d*high)                  {                      scale = 10.0d*high;                  }                    prevBest = fbest;                  globalMinimum.Y2 = fbest;                    globalMinimum.FindBestRange(0.0d' 2.0d*scale' -3' false' maxError'                                              network);                    if (globalMinimum.Y2 < maxError)                  {                      if (globalMinimum.Y2 < fbest)                      {                          for (int i = 0; i < n; i++)                          {                              x[i] = bs[i] + globalMinimum.Y2*direc[i];                              if (x[i] < 1.0e-10d)                              {                                  x[i] = 1.0e-10d;                              }                          }                          fbest = globalMinimum.Y2;                      }                      else                      {                          for (int i = 0; i < n; i++)                          {                              x[i] = bs[i];                          }                      }                      break;                  }                    if (convergenceCounter > 0)                  {                      fbest = globalMinimum.Brentmin(20' maxError' eps' 1.0e-7d'                                                     network' globalMinimum.Y2);                  }                  else                  {                      fbest = globalMinimum.Brentmin(10' maxError' 1.0e-6d' 1.0e-5d'                                                     network' globalMinimum.Y2);                  }                    for (int i = 0; i < n; i++)                  {                      x[i] = bs[i] + globalMinimum.X2*direc[i];                      if (x[i] < 1.0e-10d)                      {                          x[i] = 1.0e-10d;                      }                  }                    double improvement = (prevBest - fbest)/prevBest;                    if (fbest < maxError)                  {                      break;                  }                    for (int i = 0; i < n; i++)                  {                      direc[i] = -direc[i]; // negative gradient                  }                    double gam = Gamma(n' g' direc);                    if (gam < 0.0d)                  {                      gam = 0.0d;                  }                    if (gam > 10.0d)                  {                      gam = 10.0d;                  }                    if (improvement < 0.001d)                  {                      ++poorCj;                  }                  else                  {                      poorCj = 0;                  }                    if (poorCj >= 2)                  {                      if (gam > 1.0d)                      {                          gam = 1.0d;                      }                  }                    if (poorCj >= 6)                  {                      poorCj = 0;                      gam = 0.0d;                  }                    FindNewDir(n' gam' g' h' direc);              }
Magic Number,Encog.Neural.Networks.Training.PNN,GlobalMinimumSearch,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\PNN\GlobalMinimumSearch.cs,Brentmin,The following statement contains a magic number: for (int iter = 0; iter < maxIterations; iter++)              {                  // Have we reached an acceptable error?                  if (fbest < maxError)                  {                      break;                  }                    double xmid = 0.5d*(xlow + xhigh);                  double tol1 = tol*(Math.Abs(xbest) + eps);                  double tol2 = 2.0*tol1;                    // See if xlow is close relative to tol2'                  // Also' that that xbest is near the midpoint.                  if (Math.Abs(xbest - xmid) <= (tol2 - 0.5d*(xhigh - xlow)))                  {                      break;                  }                    // Don't go to close to eps' the machine precision.                  if ((iter >= 2) && ((fthirdbest - fbest) < eps))                  {                      break;                  }                    double xrecent = 0;                    // Try parabolic fit' if we moved far enough.                  if (Math.Abs(prevdist) > tol1)                  {                      // Temps holders for the parabolic estimate                      double t1 = (xbest - x2ndBest)*(fbest - fthirdbest);                      double t2 = (xbest - x3rdBest)*(fbest - fsecbest);                      double numer = (xbest - x3rdBest)*t2                                     - (xbest - x2ndBest)*t1;                      double denom = 2.0*(t1 - t2);                      double testdist = prevdist;                      prevdist = step;                      // This is the parabolic estimate to min.                      if (denom != 0.0d)                      {                          step = numer/denom;                      }                      else                      {                          // test failed.                          step = 1.0e30d;                      }                        // If shrinking' and within bounds' then use the parabolic                      // estimate.                      if ((Math.Abs(step) < Math.Abs(0.5d*testdist))                          && (step + xbest > xlow) && (step + xbest < xhigh))                      {                          xrecent = xbest + step;                          // If very close to known bounds.                          if ((xrecent - xlow < tol2) || (xhigh - xrecent < tol2))                          {                              if (xbest < xmid)                              {                                  step = tol1;                              }                              else                              {                                  step = -tol1;                              }                          }                      }                      else                      {                          // Parabolic estimate poor' so use golden section                          prevdist = (xbest >= xmid) ? xlow - xbest : xhigh - xbest;                          step = Cgold*prevdist;                      }                  }                  else                  {                      // prevdist did not exceed tol1: we did not move far                      // enough                      // to justify a parabolic fit. Use golden section.                      prevdist = (xbest >= xmid) ? xlow - xbest : xhigh - xbest;                      step = .3819660d*prevdist;                  }                    if (Math.Abs(step) >= tol1)                  {                      xrecent = xbest + step; // another trial we must move a                  }                  else                  {                      // decent distance.                      if (step > 0.0)                      {                          xrecent = xbest + tol1;                      }                      else                      {                          xrecent = xbest - tol1;                      }                  }                    /*  				 * At long last we have a trial point 'xrecent'. Evaluate the  				 * function.  				 */                    double frecent = network.CalcErrorWithSingleSigma(xrecent);                    if (frecent < 0.0d)                  {                      break;                  }                    if (frecent <= fbest)                  {                      // If we improved...                      if (xrecent >= xbest)                      {                          xlow = xbest; // replacing the appropriate endpoint                      }                      else                      {                          xhigh = xbest;                      }                      x3rdBest = x2ndBest; // Update x and f values for best'                      x2ndBest = xbest; // second and third best                      xbest = xrecent;                      fthirdbest = fsecbest;                      fsecbest = fbest;                      fbest = frecent;                  }                  else                  {                      // We did not improve                      if (xrecent < xbest)                      {                          xlow = xrecent; // replacing the appropriate endpoint                      }                      else                      {                          xhigh = xrecent;                      }                        if ((frecent <= fsecbest) || (x2ndBest == xbest))                      {                          x3rdBest = x2ndBest;                            x2ndBest = xrecent;                          fthirdbest = fsecbest;                          fsecbest = frecent;                      }                      else if ((frecent <= fthirdbest) || (x3rdBest == xbest)                               || (x3rdBest == x2ndBest))                      {                          x3rdBest = xrecent;                          fthirdbest = frecent;                      }                  }              }
Magic Number,Encog.Neural.Networks.Training.PNN,GlobalMinimumSearch,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\PNN\GlobalMinimumSearch.cs,Brentmin,The following statement contains a magic number: for (int iter = 0; iter < maxIterations; iter++)              {                  // Have we reached an acceptable error?                  if (fbest < maxError)                  {                      break;                  }                    double xmid = 0.5d*(xlow + xhigh);                  double tol1 = tol*(Math.Abs(xbest) + eps);                  double tol2 = 2.0*tol1;                    // See if xlow is close relative to tol2'                  // Also' that that xbest is near the midpoint.                  if (Math.Abs(xbest - xmid) <= (tol2 - 0.5d*(xhigh - xlow)))                  {                      break;                  }                    // Don't go to close to eps' the machine precision.                  if ((iter >= 2) && ((fthirdbest - fbest) < eps))                  {                      break;                  }                    double xrecent = 0;                    // Try parabolic fit' if we moved far enough.                  if (Math.Abs(prevdist) > tol1)                  {                      // Temps holders for the parabolic estimate                      double t1 = (xbest - x2ndBest)*(fbest - fthirdbest);                      double t2 = (xbest - x3rdBest)*(fbest - fsecbest);                      double numer = (xbest - x3rdBest)*t2                                     - (xbest - x2ndBest)*t1;                      double denom = 2.0*(t1 - t2);                      double testdist = prevdist;                      prevdist = step;                      // This is the parabolic estimate to min.                      if (denom != 0.0d)                      {                          step = numer/denom;                      }                      else                      {                          // test failed.                          step = 1.0e30d;                      }                        // If shrinking' and within bounds' then use the parabolic                      // estimate.                      if ((Math.Abs(step) < Math.Abs(0.5d*testdist))                          && (step + xbest > xlow) && (step + xbest < xhigh))                      {                          xrecent = xbest + step;                          // If very close to known bounds.                          if ((xrecent - xlow < tol2) || (xhigh - xrecent < tol2))                          {                              if (xbest < xmid)                              {                                  step = tol1;                              }                              else                              {                                  step = -tol1;                              }                          }                      }                      else                      {                          // Parabolic estimate poor' so use golden section                          prevdist = (xbest >= xmid) ? xlow - xbest : xhigh - xbest;                          step = Cgold*prevdist;                      }                  }                  else                  {                      // prevdist did not exceed tol1: we did not move far                      // enough                      // to justify a parabolic fit. Use golden section.                      prevdist = (xbest >= xmid) ? xlow - xbest : xhigh - xbest;                      step = .3819660d*prevdist;                  }                    if (Math.Abs(step) >= tol1)                  {                      xrecent = xbest + step; // another trial we must move a                  }                  else                  {                      // decent distance.                      if (step > 0.0)                      {                          xrecent = xbest + tol1;                      }                      else                      {                          xrecent = xbest - tol1;                      }                  }                    /*  				 * At long last we have a trial point 'xrecent'. Evaluate the  				 * function.  				 */                    double frecent = network.CalcErrorWithSingleSigma(xrecent);                    if (frecent < 0.0d)                  {                      break;                  }                    if (frecent <= fbest)                  {                      // If we improved...                      if (xrecent >= xbest)                      {                          xlow = xbest; // replacing the appropriate endpoint                      }                      else                      {                          xhigh = xbest;                      }                      x3rdBest = x2ndBest; // Update x and f values for best'                      x2ndBest = xbest; // second and third best                      xbest = xrecent;                      fthirdbest = fsecbest;                      fsecbest = fbest;                      fbest = frecent;                  }                  else                  {                      // We did not improve                      if (xrecent < xbest)                      {                          xlow = xrecent; // replacing the appropriate endpoint                      }                      else                      {                          xhigh = xrecent;                      }                        if ((frecent <= fsecbest) || (x2ndBest == xbest))                      {                          x3rdBest = x2ndBest;                            x2ndBest = xrecent;                          fthirdbest = fsecbest;                          fsecbest = frecent;                      }                      else if ((frecent <= fthirdbest) || (x3rdBest == xbest)                               || (x3rdBest == x2ndBest))                      {                          x3rdBest = xrecent;                          fthirdbest = frecent;                      }                  }              }
Magic Number,Encog.Neural.Networks.Training.PNN,GlobalMinimumSearch,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\PNN\GlobalMinimumSearch.cs,Brentmin,The following statement contains a magic number: for (int iter = 0; iter < maxIterations; iter++)              {                  // Have we reached an acceptable error?                  if (fbest < maxError)                  {                      break;                  }                    double xmid = 0.5d*(xlow + xhigh);                  double tol1 = tol*(Math.Abs(xbest) + eps);                  double tol2 = 2.0*tol1;                    // See if xlow is close relative to tol2'                  // Also' that that xbest is near the midpoint.                  if (Math.Abs(xbest - xmid) <= (tol2 - 0.5d*(xhigh - xlow)))                  {                      break;                  }                    // Don't go to close to eps' the machine precision.                  if ((iter >= 2) && ((fthirdbest - fbest) < eps))                  {                      break;                  }                    double xrecent = 0;                    // Try parabolic fit' if we moved far enough.                  if (Math.Abs(prevdist) > tol1)                  {                      // Temps holders for the parabolic estimate                      double t1 = (xbest - x2ndBest)*(fbest - fthirdbest);                      double t2 = (xbest - x3rdBest)*(fbest - fsecbest);                      double numer = (xbest - x3rdBest)*t2                                     - (xbest - x2ndBest)*t1;                      double denom = 2.0*(t1 - t2);                      double testdist = prevdist;                      prevdist = step;                      // This is the parabolic estimate to min.                      if (denom != 0.0d)                      {                          step = numer/denom;                      }                      else                      {                          // test failed.                          step = 1.0e30d;                      }                        // If shrinking' and within bounds' then use the parabolic                      // estimate.                      if ((Math.Abs(step) < Math.Abs(0.5d*testdist))                          && (step + xbest > xlow) && (step + xbest < xhigh))                      {                          xrecent = xbest + step;                          // If very close to known bounds.                          if ((xrecent - xlow < tol2) || (xhigh - xrecent < tol2))                          {                              if (xbest < xmid)                              {                                  step = tol1;                              }                              else                              {                                  step = -tol1;                              }                          }                      }                      else                      {                          // Parabolic estimate poor' so use golden section                          prevdist = (xbest >= xmid) ? xlow - xbest : xhigh - xbest;                          step = Cgold*prevdist;                      }                  }                  else                  {                      // prevdist did not exceed tol1: we did not move far                      // enough                      // to justify a parabolic fit. Use golden section.                      prevdist = (xbest >= xmid) ? xlow - xbest : xhigh - xbest;                      step = .3819660d*prevdist;                  }                    if (Math.Abs(step) >= tol1)                  {                      xrecent = xbest + step; // another trial we must move a                  }                  else                  {                      // decent distance.                      if (step > 0.0)                      {                          xrecent = xbest + tol1;                      }                      else                      {                          xrecent = xbest - tol1;                      }                  }                    /*  				 * At long last we have a trial point 'xrecent'. Evaluate the  				 * function.  				 */                    double frecent = network.CalcErrorWithSingleSigma(xrecent);                    if (frecent < 0.0d)                  {                      break;                  }                    if (frecent <= fbest)                  {                      // If we improved...                      if (xrecent >= xbest)                      {                          xlow = xbest; // replacing the appropriate endpoint                      }                      else                      {                          xhigh = xbest;                      }                      x3rdBest = x2ndBest; // Update x and f values for best'                      x2ndBest = xbest; // second and third best                      xbest = xrecent;                      fthirdbest = fsecbest;                      fsecbest = fbest;                      fbest = frecent;                  }                  else                  {                      // We did not improve                      if (xrecent < xbest)                      {                          xlow = xrecent; // replacing the appropriate endpoint                      }                      else                      {                          xhigh = xrecent;                      }                        if ((frecent <= fsecbest) || (x2ndBest == xbest))                      {                          x3rdBest = x2ndBest;                            x2ndBest = xrecent;                          fthirdbest = fsecbest;                          fsecbest = frecent;                      }                      else if ((frecent <= fthirdbest) || (x3rdBest == xbest)                               || (x3rdBest == x2ndBest))                      {                          x3rdBest = xrecent;                          fthirdbest = frecent;                      }                  }              }
Magic Number,Encog.Neural.Networks.Training.PNN,TrainBasicPNN,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\PNN\TrainBasicPNN.cs,Iteration,The following statement contains a magic number: double d = dermin.Calculate(32767' _maxError' 1.0e-8d'                                          _minImprovement' this' _network.InputCount' x'                                          globalMinimum.Y2' bs' direc' g' h' dwk2);
Magic Number,Encog.Neural.Networks.Training.Propagation,GradientWorker,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\Propagation\GradientWorker.cs,Process,The following statement contains a magic number: if (_owner.L1 > EncogFramework.DefaultDoubleEqual                      || _owner.L1 > EncogFramework.DefaultDoubleEqual)              {                  double[] lp = new double[2];                  CalculateRegularizationPenalty(lp);                  for (int i = 0; i < _actual.Length; i++)                  {                      double p = (lp[0] * _owner.L1) + (lp[1] * _owner.L2);                      _layerDelta[i] += p;                  }              }
Magic Number,Encog.Neural.Networks.Training.Propagation,Propagation,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\Propagation\Propagation.cs,Init,The following statement contains a magic number: if (FixFlatSpot)              {                  for (int i = 0; i < _flat.ActivationFunctions.Length; i++)                  {                      IActivationFunction af = _flat.ActivationFunctions[i];                      if( af is ActivationSigmoid )                      {                          _flatSpot[i] = 0.1;                      }                      else                      {                          _flatSpot[i] = 0.0;                      }                  }              }              else              {                  EngineArray.Fill(_flatSpot' 0.0);              }
Magic Number,Encog.Neural.Networks.Training.Propagation.SCG,ScaledConjugateGradient,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\Propagation\SCG\ScaledConjugateGradient.cs,Iteration,The following statement contains a magic number: if (_delta <= 0)              {                  _lambda2 = 2 * (_lambda - _delta / _magP);                  _delta = _lambda * _magP - _delta;                  _lambda = _lambda2;              }
Magic Number,Encog.Neural.Networks.Training.Propagation.SCG,ScaledConjugateGradient,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\Propagation\SCG\ScaledConjugateGradient.cs,Iteration,The following statement contains a magic number: double gdelta = 2 * _delta * (_oldError - Error)                              / (mu * mu);
Magic Number,Encog.Neural.Networks.Training.Propagation.SGD,BatchDataSet,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\Propagation\SGD\BatchDataSet.cs,BatchDataSet,The following statement contains a magic number: BatchSize = 500;
Magic Number,Encog.Neural.Networks.Training.Propagation.SGD,StochasticGradientDescent,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\Propagation\SGD\StochasticGradientDescent.cs,StochasticGradientDescent,The following statement contains a magic number: if (!(training is BatchDataSet))              {                  BatchSize = 25;              }
Magic Number,Encog.Neural.Networks.Training.Propagation.SGD,StochasticGradientDescent,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\Propagation\SGD\StochasticGradientDescent.cs,StochasticGradientDescent,The following statement contains a magic number: LearningRate = 0.001;
Magic Number,Encog.Neural.Networks.Training.Propagation.SGD,StochasticGradientDescent,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\Propagation\SGD\StochasticGradientDescent.cs,StochasticGradientDescent,The following statement contains a magic number: Momentum = 0.9;
Magic Number,Encog.Neural.Networks.Training.Propagation.SGD,StochasticGradientDescent,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\Propagation\SGD\StochasticGradientDescent.cs,Process,The following statement contains a magic number: if (L1 > EncogFramework.DefaultDoubleEqual                      || L2 > EncogFramework.DefaultDoubleEqual)              {                  double[] lp = new double[2];                  CalculateRegularizationPenalty(lp);                  for (int i = 0; i < actual.Length; i++)                  {                      double p = (lp[0] * L1) + (lp[1] * L2);                      _layerDelta[i] += p;                  }              }
Magic Number,Encog.Neural.Networks.Training.Propagation.SGD.Update,RMSPropUpdate,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\Propagation\SGD\Update\RMSPropUpdate.cs,RMSPropUpdate,The following statement contains a magic number: DecayRate = 0.99;
Magic Number,Encog.Neural.Networks.Training.Propagation.SGD.Update,RMSPropUpdate,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\Propagation\SGD\Update\RMSPropUpdate.cs,RMSPropUpdate,The following statement contains a magic number: EPS = 1e-8;
Magic Number,Encog.Neural.Networks.Training.Propagation.SGD.Update,AdaGradUpdate,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\Propagation\SGD\Update\AdaGradUpdate.cs,AdaGradUpdate,The following statement contains a magic number: EPS = 1e-8;
Magic Number,Encog.Neural.Networks.Training.Simple,TrainAdaline,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\Simple\TrainAdaline.cs,TrainAdaline,The following statement contains a magic number: if (network.LayerCount > 2)              {                  throw new NeuralNetworkError(                      "An ADALINE network only has two layers.");              }
Magic Number,Encog.Neural.Pattern,ART1Pattern,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Pattern\ART1Pattern.cs,ART1Pattern,The following statement contains a magic number: _c1 = 5;
Magic Number,Encog.Neural.Pattern,ART1Pattern,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Pattern\ART1Pattern.cs,ART1Pattern,The following statement contains a magic number: _l = 3;
Magic Number,Encog.Neural.Pattern,BoltzmannPattern,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Pattern\BoltzmannPattern.cs,BoltzmannPattern,The following statement contains a magic number: _annealCycles = 100;
Magic Number,Encog.Neural.Pattern,BoltzmannPattern,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Pattern\BoltzmannPattern.cs,BoltzmannPattern,The following statement contains a magic number: _runCycles = 1000;
Magic Number,Encog.Neural.PNN,AbstractPNN,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\PNN\AbstractPNN.cs,AbstractPNN,The following statement contains a magic number: Error = -1000;
Magic Number,Encog.Neural.Prune,PruneIncremental,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Prune\PruneIncremental.cs,Init,The following statement contains a magic number: if (_hidden.Count == 1)              {                  _hidden1Size = (_hidden[0].Max - _hidden[0].Min) + 1;                  _hidden2Size = 0;                  _results = EngineArray.AllocateDouble2D(_hidden1Size' 1);              }              else if (_hidden.Count == 2)              {                  // handle display for two layers                  _hidden1Size = (_hidden[0].Max - _hidden[0].Min) + 1;                  _hidden2Size = (_hidden[1].Max - _hidden[1].Min) + 1;                  _results = EngineArray.AllocateDouble2D(_hidden1Size' _hidden2Size);              }              else              {                  // we don't handle displays for more than two layers                  _hidden1Size = 0;                  _hidden2Size = 0;                  _results = null;              }
Magic Number,Encog.Neural.Prune,PruneIncremental,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Prune\PruneIncremental.cs,PerformJobUnit,The following statement contains a magic number: for (int z = 0; z < _weightTries; z++)              {                  network.Reset();                  Propagation train = new ResilientPropagation(network'                                                               useTraining);                  var strat = new StopTrainingStrategy(0.001d'                                                       5);                    train.AddStrategy(strat);                  train.ThreadCount = 1; // force single thread mode                    for (int i = 0;                       (i < _iterations) && !ShouldStop                       && !strat.ShouldStop();                       i++)                  {                      train.Iteration();                  }                    error = Math.Min(error' train.Error);              }
Magic Number,Encog.Neural.Prune,PruneIncremental,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Prune\PruneIncremental.cs,PerformJobUnit,The following statement contains a magic number: if (!ShouldStop)              {                  // update min and max                    _high = Math.Max(_high' error);                  _low = Math.Min(_low' error);                    if (_hidden1Size > 0)                  {                      int networkHidden1Count;                      int networkHidden2Count;                        if (network.LayerCount > 3)                      {                          networkHidden2Count = network.GetLayerNeuronCount(2);                          networkHidden1Count = network.GetLayerNeuronCount(1);                      }                      else                      {                          networkHidden2Count = 0;                          networkHidden1Count = network.GetLayerNeuronCount(1);                      }                        int row' col;                        if (_hidden2Size == 0)                      {                          row = networkHidden1Count - _hidden[0].Min;                          col = 0;                      }                      else                      {                          row = networkHidden1Count - _hidden[0].Min;                          col = networkHidden2Count - _hidden[1].Min;                      }                        if ((row < 0) || (col < 0))                      {                          Console.Out.WriteLine("STOP");                      }                      _results[row][col] = error;                  }                    // report status                  _currentTry++;                    UpdateBest(network' error);                  ReportStatus(                      context'                      "Current: "                      + NetworkToString(network)                      + "; Best: "                      + NetworkToString(_bestNetwork));              }
Magic Number,Encog.Neural.Prune,PruneIncremental,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Prune\PruneIncremental.cs,PerformJobUnit,The following statement contains a magic number: if (!ShouldStop)              {                  // update min and max                    _high = Math.Max(_high' error);                  _low = Math.Min(_low' error);                    if (_hidden1Size > 0)                  {                      int networkHidden1Count;                      int networkHidden2Count;                        if (network.LayerCount > 3)                      {                          networkHidden2Count = network.GetLayerNeuronCount(2);                          networkHidden1Count = network.GetLayerNeuronCount(1);                      }                      else                      {                          networkHidden2Count = 0;                          networkHidden1Count = network.GetLayerNeuronCount(1);                      }                        int row' col;                        if (_hidden2Size == 0)                      {                          row = networkHidden1Count - _hidden[0].Min;                          col = 0;                      }                      else                      {                          row = networkHidden1Count - _hidden[0].Min;                          col = networkHidden2Count - _hidden[1].Min;                      }                        if ((row < 0) || (col < 0))                      {                          Console.Out.WriteLine("STOP");                      }                      _results[row][col] = error;                  }                    // report status                  _currentTry++;                    UpdateBest(network' error);                  ReportStatus(                      context'                      "Current: "                      + NetworkToString(network)                      + "; Best: "                      + NetworkToString(_bestNetwork));              }
Magic Number,Encog.Neural.Prune,PruneSelective,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Prune\PruneSelective.cs,IncreaseNeuronCount,The following statement contains a magic number: for (int fromLayer = flat.LayerCounts.Length - 2; fromLayer >= 0; fromLayer--)              {                  int fromNeuronCount = _network                      .GetLayerTotalNeuronCount(fromLayer);                  int toNeuronCount = _network                      .GetLayerNeuronCount(fromLayer + 1);                  int toLayer = fromLayer + 1;                    for (int toNeuron = 0; toNeuron < toNeuronCount; toNeuron++)                  {                      for (int fromNeuron = 0; fromNeuron < fromNeuronCount; fromNeuron++)                      {                          if ((toLayer == targetLayer)                              && (toNeuron >= oldNeuronCount))                          {                              newWeights[weightsIndex++] = 0;                          }                          else if ((fromLayer == targetLayer)                                   && (fromNeuron > oldNeuronCount))                          {                              newWeights[weightsIndex++] = 0;                          }                          else                          {                              newWeights[weightsIndex++] = _network.Flat.Weights[oldWeightsIndex++];                          }                      }                  }              }
Magic Number,Encog.Neural.Prune,PruneSelective,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Prune\PruneSelective.cs,Prune,The following statement contains a magic number: for (int fromLayer = flat.LayerCounts.Length - 2; fromLayer >= 0; fromLayer--)              {                  int fromNeuronCount = _network                      .GetLayerTotalNeuronCount(fromLayer);                  int toNeuronCount = _network                      .GetLayerNeuronCount(fromLayer + 1);                  int toLayer = fromLayer + 1;                    for (int toNeuron = 0; toNeuron < toNeuronCount; toNeuron++)                  {                      for (int fromNeuron = 0; fromNeuron < fromNeuronCount; fromNeuron++)                      {                          bool skip = false;                          if ((toLayer == targetLayer) && (toNeuron == neuron))                          {                              skip = true;                          }                          else if ((fromLayer == targetLayer)                                   && (fromNeuron == neuron))                          {                              skip = true;                          }                            if (!skip)                          {                              newWeights[weightsIndex++] = _network.GetWeight(                                  fromLayer' fromNeuron' toNeuron);                          }                      }                  }              }
Magic Number,Encog.Neural.Prune,PruneSelective,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Prune\PruneSelective.cs,RandomizeNeuron,The following statement contains a magic number: for (int fromLayer = flat.LayerCounts.Length - 2; fromLayer >= 0; fromLayer--)              {                  int fromNeuronCount = _network                      .GetLayerTotalNeuronCount(fromLayer);                  int toNeuronCount = _network                      .GetLayerNeuronCount(fromLayer + 1);                  int toLayer = fromLayer + 1;                    for (int toNeuron = 0; toNeuron < toNeuronCount; toNeuron++)                  {                      for (int fromNeuron = 0; fromNeuron < fromNeuronCount; fromNeuron++)                      {                          bool randomize = false;                          if ((toLayer == targetLayer) && (toNeuron == neuron))                          {                              randomize = true;                          }                          else if ((fromLayer == targetLayer)                                   && (fromNeuron == neuron))                          {                              randomize = true;                          }                            double weight = _network.GetWeight(fromLayer'                                                            fromNeuron' toNeuron);                            if (randomize)                          {                              weight = d.Randomize(weight);                          }                            newWeights[weightsIndex++] = weight;                      }                  }              }
Magic Number,Encog.Neural.Rbf,PersistRBFNetwork,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\RBF\PersistRBFNetwork.cs,Read,The following statement contains a magic number: while ((section = ins0.ReadNextSection()) != null)              {                  if (section.SectionName.Equals("RBF-NETWORK")                      && section.SubSectionName.Equals("PARAMS"))                  {                      IDictionary<String' String> paras = section.ParseParams();                      EngineArray.PutAll(paras' result.Properties);                  }                  if (section.SectionName.Equals("RBF-NETWORK")                      && section.SubSectionName.Equals("NETWORK"))                  {                      IDictionary<String' String> p = section.ParseParams();                        flat.BeginTraining = EncogFileSection.ParseInt(p'                                                                     BasicNetwork.TagBeginTraining);                      flat.ConnectionLimit = EncogFileSection.ParseDouble(p'                                                                          BasicNetwork.TagConnectionLimit);                      flat.ContextTargetOffset = EncogFileSection.ParseIntArray(                          p' BasicNetwork.TagContextTargetOffset);                      flat.ContextTargetSize = EncogFileSection.ParseIntArray(                          p' BasicNetwork.TagContextTargetSize);                      flat.EndTraining = EncogFileSection.ParseInt(p'                                                                   BasicNetwork.TagEndTraining);                      flat.HasContext = EncogFileSection.ParseBoolean(p'                                                                      BasicNetwork.TagHasContext);                      flat.InputCount = EncogFileSection.ParseInt(p'                                                                  PersistConst.InputCount);                      flat.LayerCounts = EncogFileSection.ParseIntArray(p'                                                                        BasicNetwork.TagLayerCounts);                      flat.LayerFeedCounts = EncogFileSection.ParseIntArray(p'                                                                            BasicNetwork.TagLayerFeedCounts);                      flat.LayerContextCount = EncogFileSection.ParseIntArray(p' BasicNetwork.TagLayerContextCount);                      flat.LayerIndex = EncogFileSection.ParseIntArray(p'                                                                       BasicNetwork.TagLayerIndex);                      flat.LayerOutput = section.ParseDoubleArray(p'                                                                           PersistConst.Output);                      flat.LayerSums = new double[flat.LayerOutput.Length];                      flat.OutputCount = EncogFileSection.ParseInt(p'PersistConst.OutputCount);                      flat.WeightIndex = EncogFileSection.ParseIntArray(p'                                                                        BasicNetwork.TagWeightIndex);                      flat.Weights = section.ParseDoubleArray(p'                                                                       PersistConst.Weights);                      flat.BiasActivation = section.ParseDoubleArray(p' BasicNetwork.TagBiasActivation);                  }                  else if (section.SectionName.Equals("RBF-NETWORK")                           && section.SubSectionName.Equals("ACTIVATION"))                  {                      int index = 0;                        flat.ActivationFunctions = new IActivationFunction[flat.LayerCounts.Length];                          foreach (String line  in  section.Lines)                      {                          IActivationFunction af;                          IList<String> cols = EncogFileSection                              .SplitColumns(line);                          String name = ReflectionUtil.AfPath                                        + cols[0];                          try                          {                              af = (IActivationFunction) ReflectionUtil.LoadObject(name);                          }                          catch (Exception e)                          {                              throw new PersistError(e);                          }                          for (int i = 0; i < af.ParamNames.Length; i++)                          {                              af.Params[i] = CSVFormat.EgFormat.Parse(cols[i + 1]);                          }                            flat.ActivationFunctions[index++] = af;                      }                  }                  else if (section.SectionName.Equals("RBF-NETWORK")                           && section.SubSectionName.Equals("RBF"))                  {                      int index = 0;                        int hiddenCount = flat.LayerCounts[1];                      int inputCount = flat.LayerCounts[2];                        flat.RBF = new IRadialBasisFunction[hiddenCount];                          foreach (String line  in  section.Lines)                      {                          IRadialBasisFunction rbf;                          IList<String> cols = EncogFileSection                              .SplitColumns(line);                          String name = ReflectionUtil.RBFPath + cols[0];                          try                          {                              rbf = (IRadialBasisFunction) ReflectionUtil.LoadObject(name);                          }                          catch (TypeLoadException ex)                          {                              throw new PersistError(ex);                          }                          catch (TargetException ex)                          {                              throw new PersistError(ex);                          }                          catch (MemberAccessException ex)                          {                              throw new PersistError(ex);                          }                            rbf.Width = CSVFormat.EgFormat.Parse(cols[1]);                          rbf.Peak = CSVFormat.EgFormat.Parse(cols[2]);                          rbf.Centers = new double[inputCount];                            for (int i = 0; i < inputCount; i++)                          {                              rbf.Centers[i] = CSVFormat.EgFormat.Parse(cols[i + 3]);                          }                            flat.RBF[index++] = rbf;                      }                  }              }
Magic Number,Encog.Neural.Rbf,PersistRBFNetwork,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\RBF\PersistRBFNetwork.cs,Read,The following statement contains a magic number: while ((section = ins0.ReadNextSection()) != null)              {                  if (section.SectionName.Equals("RBF-NETWORK")                      && section.SubSectionName.Equals("PARAMS"))                  {                      IDictionary<String' String> paras = section.ParseParams();                      EngineArray.PutAll(paras' result.Properties);                  }                  if (section.SectionName.Equals("RBF-NETWORK")                      && section.SubSectionName.Equals("NETWORK"))                  {                      IDictionary<String' String> p = section.ParseParams();                        flat.BeginTraining = EncogFileSection.ParseInt(p'                                                                     BasicNetwork.TagBeginTraining);                      flat.ConnectionLimit = EncogFileSection.ParseDouble(p'                                                                          BasicNetwork.TagConnectionLimit);                      flat.ContextTargetOffset = EncogFileSection.ParseIntArray(                          p' BasicNetwork.TagContextTargetOffset);                      flat.ContextTargetSize = EncogFileSection.ParseIntArray(                          p' BasicNetwork.TagContextTargetSize);                      flat.EndTraining = EncogFileSection.ParseInt(p'                                                                   BasicNetwork.TagEndTraining);                      flat.HasContext = EncogFileSection.ParseBoolean(p'                                                                      BasicNetwork.TagHasContext);                      flat.InputCount = EncogFileSection.ParseInt(p'                                                                  PersistConst.InputCount);                      flat.LayerCounts = EncogFileSection.ParseIntArray(p'                                                                        BasicNetwork.TagLayerCounts);                      flat.LayerFeedCounts = EncogFileSection.ParseIntArray(p'                                                                            BasicNetwork.TagLayerFeedCounts);                      flat.LayerContextCount = EncogFileSection.ParseIntArray(p' BasicNetwork.TagLayerContextCount);                      flat.LayerIndex = EncogFileSection.ParseIntArray(p'                                                                       BasicNetwork.TagLayerIndex);                      flat.LayerOutput = section.ParseDoubleArray(p'                                                                           PersistConst.Output);                      flat.LayerSums = new double[flat.LayerOutput.Length];                      flat.OutputCount = EncogFileSection.ParseInt(p'PersistConst.OutputCount);                      flat.WeightIndex = EncogFileSection.ParseIntArray(p'                                                                        BasicNetwork.TagWeightIndex);                      flat.Weights = section.ParseDoubleArray(p'                                                                       PersistConst.Weights);                      flat.BiasActivation = section.ParseDoubleArray(p' BasicNetwork.TagBiasActivation);                  }                  else if (section.SectionName.Equals("RBF-NETWORK")                           && section.SubSectionName.Equals("ACTIVATION"))                  {                      int index = 0;                        flat.ActivationFunctions = new IActivationFunction[flat.LayerCounts.Length];                          foreach (String line  in  section.Lines)                      {                          IActivationFunction af;                          IList<String> cols = EncogFileSection                              .SplitColumns(line);                          String name = ReflectionUtil.AfPath                                        + cols[0];                          try                          {                              af = (IActivationFunction) ReflectionUtil.LoadObject(name);                          }                          catch (Exception e)                          {                              throw new PersistError(e);                          }                          for (int i = 0; i < af.ParamNames.Length; i++)                          {                              af.Params[i] = CSVFormat.EgFormat.Parse(cols[i + 1]);                          }                            flat.ActivationFunctions[index++] = af;                      }                  }                  else if (section.SectionName.Equals("RBF-NETWORK")                           && section.SubSectionName.Equals("RBF"))                  {                      int index = 0;                        int hiddenCount = flat.LayerCounts[1];                      int inputCount = flat.LayerCounts[2];                        flat.RBF = new IRadialBasisFunction[hiddenCount];                          foreach (String line  in  section.Lines)                      {                          IRadialBasisFunction rbf;                          IList<String> cols = EncogFileSection                              .SplitColumns(line);                          String name = ReflectionUtil.RBFPath + cols[0];                          try                          {                              rbf = (IRadialBasisFunction) ReflectionUtil.LoadObject(name);                          }                          catch (TypeLoadException ex)                          {                              throw new PersistError(ex);                          }                          catch (TargetException ex)                          {                              throw new PersistError(ex);                          }                          catch (MemberAccessException ex)                          {                              throw new PersistError(ex);                          }                            rbf.Width = CSVFormat.EgFormat.Parse(cols[1]);                          rbf.Peak = CSVFormat.EgFormat.Parse(cols[2]);                          rbf.Centers = new double[inputCount];                            for (int i = 0; i < inputCount; i++)                          {                              rbf.Centers[i] = CSVFormat.EgFormat.Parse(cols[i + 3]);                          }                            flat.RBF[index++] = rbf;                      }                  }              }
Magic Number,Encog.Neural.Rbf,PersistRBFNetwork,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\RBF\PersistRBFNetwork.cs,Read,The following statement contains a magic number: while ((section = ins0.ReadNextSection()) != null)              {                  if (section.SectionName.Equals("RBF-NETWORK")                      && section.SubSectionName.Equals("PARAMS"))                  {                      IDictionary<String' String> paras = section.ParseParams();                      EngineArray.PutAll(paras' result.Properties);                  }                  if (section.SectionName.Equals("RBF-NETWORK")                      && section.SubSectionName.Equals("NETWORK"))                  {                      IDictionary<String' String> p = section.ParseParams();                        flat.BeginTraining = EncogFileSection.ParseInt(p'                                                                     BasicNetwork.TagBeginTraining);                      flat.ConnectionLimit = EncogFileSection.ParseDouble(p'                                                                          BasicNetwork.TagConnectionLimit);                      flat.ContextTargetOffset = EncogFileSection.ParseIntArray(                          p' BasicNetwork.TagContextTargetOffset);                      flat.ContextTargetSize = EncogFileSection.ParseIntArray(                          p' BasicNetwork.TagContextTargetSize);                      flat.EndTraining = EncogFileSection.ParseInt(p'                                                                   BasicNetwork.TagEndTraining);                      flat.HasContext = EncogFileSection.ParseBoolean(p'                                                                      BasicNetwork.TagHasContext);                      flat.InputCount = EncogFileSection.ParseInt(p'                                                                  PersistConst.InputCount);                      flat.LayerCounts = EncogFileSection.ParseIntArray(p'                                                                        BasicNetwork.TagLayerCounts);                      flat.LayerFeedCounts = EncogFileSection.ParseIntArray(p'                                                                            BasicNetwork.TagLayerFeedCounts);                      flat.LayerContextCount = EncogFileSection.ParseIntArray(p' BasicNetwork.TagLayerContextCount);                      flat.LayerIndex = EncogFileSection.ParseIntArray(p'                                                                       BasicNetwork.TagLayerIndex);                      flat.LayerOutput = section.ParseDoubleArray(p'                                                                           PersistConst.Output);                      flat.LayerSums = new double[flat.LayerOutput.Length];                      flat.OutputCount = EncogFileSection.ParseInt(p'PersistConst.OutputCount);                      flat.WeightIndex = EncogFileSection.ParseIntArray(p'                                                                        BasicNetwork.TagWeightIndex);                      flat.Weights = section.ParseDoubleArray(p'                                                                       PersistConst.Weights);                      flat.BiasActivation = section.ParseDoubleArray(p' BasicNetwork.TagBiasActivation);                  }                  else if (section.SectionName.Equals("RBF-NETWORK")                           && section.SubSectionName.Equals("ACTIVATION"))                  {                      int index = 0;                        flat.ActivationFunctions = new IActivationFunction[flat.LayerCounts.Length];                          foreach (String line  in  section.Lines)                      {                          IActivationFunction af;                          IList<String> cols = EncogFileSection                              .SplitColumns(line);                          String name = ReflectionUtil.AfPath                                        + cols[0];                          try                          {                              af = (IActivationFunction) ReflectionUtil.LoadObject(name);                          }                          catch (Exception e)                          {                              throw new PersistError(e);                          }                          for (int i = 0; i < af.ParamNames.Length; i++)                          {                              af.Params[i] = CSVFormat.EgFormat.Parse(cols[i + 1]);                          }                            flat.ActivationFunctions[index++] = af;                      }                  }                  else if (section.SectionName.Equals("RBF-NETWORK")                           && section.SubSectionName.Equals("RBF"))                  {                      int index = 0;                        int hiddenCount = flat.LayerCounts[1];                      int inputCount = flat.LayerCounts[2];                        flat.RBF = new IRadialBasisFunction[hiddenCount];                          foreach (String line  in  section.Lines)                      {                          IRadialBasisFunction rbf;                          IList<String> cols = EncogFileSection                              .SplitColumns(line);                          String name = ReflectionUtil.RBFPath + cols[0];                          try                          {                              rbf = (IRadialBasisFunction) ReflectionUtil.LoadObject(name);                          }                          catch (TypeLoadException ex)                          {                              throw new PersistError(ex);                          }                          catch (TargetException ex)                          {                              throw new PersistError(ex);                          }                          catch (MemberAccessException ex)                          {                              throw new PersistError(ex);                          }                            rbf.Width = CSVFormat.EgFormat.Parse(cols[1]);                          rbf.Peak = CSVFormat.EgFormat.Parse(cols[2]);                          rbf.Centers = new double[inputCount];                            for (int i = 0; i < inputCount; i++)                          {                              rbf.Centers[i] = CSVFormat.EgFormat.Parse(cols[i + 3]);                          }                            flat.RBF[index++] = rbf;                      }                  }              }
Magic Number,Encog.Neural.RBF,RBFNetwork,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\RBF\RBFNetwork.cs,SetRBFCentersAndWidthsEqualSpacing,The following statement contains a magic number: if (expectedSideLength != cmp)              {                  throw new NeuralNetworkError(                      "Total number of RBF neurons must be some integer to the power of 'dimensions'.\n"                      + Format.FormatDouble(expectedSideLength' 5)                      + " <> " + Format.FormatDouble(cmp' 5));              }
Magic Number,Encog.Neural.RBF,RBFNetwork,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\RBF\RBFNetwork.cs,SetRBFCentersAndWidthsEqualSpacing,The following statement contains a magic number: if (expectedSideLength != cmp)              {                  throw new NeuralNetworkError(                      "Total number of RBF neurons must be some integer to the power of 'dimensions'.\n"                      + Format.FormatDouble(expectedSideLength' 5)                      + " <> " + Format.FormatDouble(cmp' 5));              }
Magic Number,Encog.Neural.RBF.Training,SVD,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\RBF\Training\SVD.cs,Svdcmp,The following statement contains a magic number: for (i = 0; i < n; i++)              {                  l = i + 2;                  rv1[i] = scale*g;                  g = s = scale = 0.0d;                  if (i < m)                  {                      for (k = i; k < m; k++)                          scale += Math.Abs(a[k][i]);                      if (scale != 0.0d)                      {                          for (k = i; k < m; k++)                          {                              a[k][i] /= scale;                              s += a[k][i]*a[k][i];                          }                          f = a[i][i];                          g = -SIGN(Math.Sqrt(s)' f);                          h = f*g - s;                          a[i][i] = f - g;                          for (j = l - 1; j < n; j++)                          {                              for (s = 0.0d' k = i; k < m; k++)                                  s += a[k][i]*a[k][j];                              f = s/h;                              for (k = i; k < m; k++)                                  a[k][j] += f*a[k][i];                          }                          for (k = i; k < m; k++)                              a[k][i] *= scale;                      }                  }                  w[i] = scale*g;                  g = s = scale = 0.0d;                  if (i + 1 <= m && i + 1 != n)                  {                      for (k = l - 1; k < n; k++)                          scale += Math.Abs(a[i][k]);                      if (scale != 0.0d)                      {                          for (k = l - 1; k < n; k++)                          {                              a[i][k] /= scale;                              s += a[i][k]*a[i][k];                          }                          f = a[i][l - 1];                          g = -SIGN(Math.Sqrt(s)' f);                          h = f*g - s;                          a[i][l - 1] = f - g;                          for (k = l - 1; k < n; k++)                              rv1[k] = a[i][k]/h;                          for (j = l - 1; j < m; j++)                          {                              for (s = 0.0d' k = l - 1; k < n; k++)                                  s += a[j][k]*a[i][k];                              for (k = l - 1; k < n; k++)                                  a[j][k] += s*rv1[k];                          }                          for (k = l - 1; k < n; k++)                              a[i][k] *= scale;                      }                  }                  anorm = MAX(anorm' (Math.Abs(w[i]) + Math.Abs(rv1[i])));              }
Magic Number,Encog.Neural.RBF.Training,SVD,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\RBF\Training\SVD.cs,Svdcmp,The following statement contains a magic number: for (k = n - 1; k >= 0; k--)              {                  for (its = 0; its < 30; its++)                  {                      flag = true;                      for (l = k; l >= 0; l--)                      {                          nm = l - 1;                          if (Math.Abs(rv1[l]) + anorm == anorm)                          {                              flag = false;                              break;                          }                          if (Math.Abs(w[nm]) + anorm == anorm)                              break;                      }                      if (flag)                      {                          c = 0.0d;                          s = 1.0d;                          for (i = l; i < k + 1; i++)                          {                              f = s*rv1[i];                              rv1[i] = c*rv1[i];                              if (Math.Abs(f) + anorm == anorm)                                  break;                              g = w[i];                              h = Pythag(f' g);                              w[i] = h;                              h = 1.0d/h;                              c = g*h;                              s = -f*h;                              for (j = 0; j < m; j++)                              {                                  y = a[j][nm];                                  z = a[j][i];                                  a[j][nm] = y*c + z*s;                                  a[j][i] = z*c - y*s;                              }                          }                      }                      z = w[k];                      if (l == k)                      {                          if (z < 0.0d)                          {                              w[k] = -z;                              for (j = 0; j < n; j++)                                  v[j][k] = -v[j][k];                          }                          break;                      }                      if (its == 29)                      {                          //	Debug.Print("no convergence in 30 svdcmp iterations");                      }                      x = w[l];                      nm = k - 1;                      y = w[nm];                      g = rv1[nm];                      h = rv1[k];                      f = ((y - z)*(y + z) + (g - h)*(g + h))/(2.0d*h*y);                      g = Pythag(f' 1.0d);                      f = ((x - z)*(x + z) + h*((y/(f + SIGN(g' f))) - h))/x;                      c = s = 1.0d;                      for (j = l; j <= nm; j++)                      {                          i = j + 1;                          g = rv1[i];                          y = w[i];                          h = s*g;                          g = c*g;                          z = Pythag(f' h);                          rv1[j] = z;                          c = f/z;                          s = h/z;                          f = x*c + g*s;                          g = g*c - x*s;                          h = y*s;                          y *= c;                          for (jj = 0; jj < n; jj++)                          {                              x = v[jj][j];                              z = v[jj][i];                              v[jj][j] = x*c + z*s;                              v[jj][i] = z*c - x*s;                          }                          z = Pythag(f' h);                          w[j] = z;                          if (z != 0)                          {                              z = 1.0d/z;                              c = f*z;                              s = h*z;                          }                          f = c*g + s*y;                          x = c*y - s*g;                          for (jj = 0; jj < m; jj++)                          {                              y = a[jj][j];                              z = a[jj][i];                              a[jj][j] = y*c + z*s;                              a[jj][i] = z*c - y*s;                          }                      }                      rv1[l] = 0.0d;                      rv1[k] = f;                      w[k] = x;                  }              }
Magic Number,Encog.Neural.RBF.Training,SVD,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\RBF\Training\SVD.cs,Svdcmp,The following statement contains a magic number: for (k = n - 1; k >= 0; k--)              {                  for (its = 0; its < 30; its++)                  {                      flag = true;                      for (l = k; l >= 0; l--)                      {                          nm = l - 1;                          if (Math.Abs(rv1[l]) + anorm == anorm)                          {                              flag = false;                              break;                          }                          if (Math.Abs(w[nm]) + anorm == anorm)                              break;                      }                      if (flag)                      {                          c = 0.0d;                          s = 1.0d;                          for (i = l; i < k + 1; i++)                          {                              f = s*rv1[i];                              rv1[i] = c*rv1[i];                              if (Math.Abs(f) + anorm == anorm)                                  break;                              g = w[i];                              h = Pythag(f' g);                              w[i] = h;                              h = 1.0d/h;                              c = g*h;                              s = -f*h;                              for (j = 0; j < m; j++)                              {                                  y = a[j][nm];                                  z = a[j][i];                                  a[j][nm] = y*c + z*s;                                  a[j][i] = z*c - y*s;                              }                          }                      }                      z = w[k];                      if (l == k)                      {                          if (z < 0.0d)                          {                              w[k] = -z;                              for (j = 0; j < n; j++)                                  v[j][k] = -v[j][k];                          }                          break;                      }                      if (its == 29)                      {                          //	Debug.Print("no convergence in 30 svdcmp iterations");                      }                      x = w[l];                      nm = k - 1;                      y = w[nm];                      g = rv1[nm];                      h = rv1[k];                      f = ((y - z)*(y + z) + (g - h)*(g + h))/(2.0d*h*y);                      g = Pythag(f' 1.0d);                      f = ((x - z)*(x + z) + h*((y/(f + SIGN(g' f))) - h))/x;                      c = s = 1.0d;                      for (j = l; j <= nm; j++)                      {                          i = j + 1;                          g = rv1[i];                          y = w[i];                          h = s*g;                          g = c*g;                          z = Pythag(f' h);                          rv1[j] = z;                          c = f/z;                          s = h/z;                          f = x*c + g*s;                          g = g*c - x*s;                          h = y*s;                          y *= c;                          for (jj = 0; jj < n; jj++)                          {                              x = v[jj][j];                              z = v[jj][i];                              v[jj][j] = x*c + z*s;                              v[jj][i] = z*c - x*s;                          }                          z = Pythag(f' h);                          w[j] = z;                          if (z != 0)                          {                              z = 1.0d/z;                              c = f*z;                              s = h*z;                          }                          f = c*g + s*y;                          x = c*y - s*g;                          for (jj = 0; jj < m; jj++)                          {                              y = a[jj][j];                              z = a[jj][i];                              a[jj][j] = y*c + z*s;                              a[jj][i] = z*c - y*s;                          }                      }                      rv1[l] = 0.0d;                      rv1[k] = f;                      w[k] = x;                  }              }
Magic Number,Encog.Neural.SOM,SOMNetwork,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\SOM\SOMNetwork.cs,CalculateError,The following statement contains a magic number: return bmu.WorstDistance/100.0;
Magic Number,Encog.Neural.SOM.Training.Neighborhood,BasicTrainSOM,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\SOM\Training\Neighborhood\BasicTrainSOM.cs,Iteration,The following statement contains a magic number: Error = _bmuUtil.WorstDistance/100.0;
Magic Number,Encog.Neural.SOM.Training.Neighborhood,BasicTrainSOM,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\SOM\Training\Neighborhood\BasicTrainSOM.cs,ToString,The following statement contains a magic number: result.Append(Format.FormatDouble(_radius' 2));
Magic Number,Encog.Neural.SOM.Training.Neighborhood,NeighborhoodRBF,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\SOM\Training\Neighborhood\NeighborhoodRBF.cs,NeighborhoodRBF,The following statement contains a magic number: var size = new int[2];
Magic Number,Encog.Neural.SOM.Training.Neighborhood,NeighborhoodRBF,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\SOM\Training\Neighborhood\NeighborhoodRBF.cs,NeighborhoodRBF,The following statement contains a magic number: var centerArray = new double[2];
Magic Number,Encog.Neural.SOM.Training.Neighborhood,NeighborhoodRBF,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\SOM\Training\Neighborhood\NeighborhoodRBF.cs,NeighborhoodRBF,The following statement contains a magic number: var widthArray = new double[2];
Magic Number,Encog.Neural.SOM.Training.Neighborhood,NeighborhoodRBF,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\SOM\Training\Neighborhood\NeighborhoodRBF.cs,NeighborhoodRBF,The following statement contains a magic number: switch (type)              {                  case RBFEnum.Gaussian:                      _rbf = new GaussianFunction(2);                      break;                  case RBFEnum.InverseMultiquadric:                      _rbf = new InverseMultiquadricFunction(2);                      break;                  case RBFEnum.Multiquadric:                      _rbf = new MultiquadricFunction(2);                      break;                  case RBFEnum.MexicanHat:                      _rbf = new MexicanHatFunction(2);                      break;              }
Magic Number,Encog.Neural.SOM.Training.Neighborhood,NeighborhoodRBF,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\SOM\Training\Neighborhood\NeighborhoodRBF.cs,NeighborhoodRBF,The following statement contains a magic number: switch (type)              {                  case RBFEnum.Gaussian:                      _rbf = new GaussianFunction(2);                      break;                  case RBFEnum.InverseMultiquadric:                      _rbf = new InverseMultiquadricFunction(2);                      break;                  case RBFEnum.Multiquadric:                      _rbf = new MultiquadricFunction(2);                      break;                  case RBFEnum.MexicanHat:                      _rbf = new MexicanHatFunction(2);                      break;              }
Magic Number,Encog.Neural.SOM.Training.Neighborhood,NeighborhoodRBF,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\SOM\Training\Neighborhood\NeighborhoodRBF.cs,NeighborhoodRBF,The following statement contains a magic number: switch (type)              {                  case RBFEnum.Gaussian:                      _rbf = new GaussianFunction(2);                      break;                  case RBFEnum.InverseMultiquadric:                      _rbf = new InverseMultiquadricFunction(2);                      break;                  case RBFEnum.Multiquadric:                      _rbf = new MultiquadricFunction(2);                      break;                  case RBFEnum.MexicanHat:                      _rbf = new MexicanHatFunction(2);                      break;              }
Magic Number,Encog.Neural.SOM.Training.Neighborhood,NeighborhoodRBF,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\SOM\Training\Neighborhood\NeighborhoodRBF.cs,NeighborhoodRBF,The following statement contains a magic number: switch (type)              {                  case RBFEnum.Gaussian:                      _rbf = new GaussianFunction(2);                      break;                  case RBFEnum.InverseMultiquadric:                      _rbf = new InverseMultiquadricFunction(2);                      break;                  case RBFEnum.Multiquadric:                      _rbf = new MultiquadricFunction(2);                      break;                  case RBFEnum.MexicanHat:                      _rbf = new MexicanHatFunction(2);                      break;              }
Magic Number,Encog.Neural.SOM.Training.Neighborhood,NeighborhoodRBF,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\SOM\Training\Neighborhood\NeighborhoodRBF.cs,NeighborhoodRBF,The following statement contains a magic number: switch (type)              {                  case RBFEnum.Gaussian:                      _rbf = new GaussianFunction(2);                      break;                  case RBFEnum.InverseMultiquadric:                      _rbf = new InverseMultiquadricFunction(2);                      break;                  case RBFEnum.Multiquadric:                      _rbf = new MultiquadricFunction(2);                      break;                  case RBFEnum.MexicanHat:                      _rbf = new MexicanHatFunction(2);                      break;              }
Magic Number,Encog.Neural.SOM.Training.Neighborhood,NeighborhoodRBF,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\SOM\Training\Neighborhood\NeighborhoodRBF.cs,NeighborhoodRBF,The following statement contains a magic number: switch (type)              {                  case RBFEnum.Gaussian:                      _rbf = new GaussianFunction(2);                      break;                  case RBFEnum.InverseMultiquadric:                      _rbf = new InverseMultiquadricFunction(2);                      break;                  case RBFEnum.Multiquadric:                      _rbf = new MultiquadricFunction(2);                      break;                  case RBFEnum.MexicanHat:                      _rbf = new MexicanHatFunction(2);                      break;              }
Magic Number,Encog.Neural.SOM.Training.Neighborhood,NeighborhoodRBF,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\SOM\Training\Neighborhood\NeighborhoodRBF.cs,NeighborhoodRBF,The following statement contains a magic number: switch (type)              {                  case RBFEnum.Gaussian:                      _rbf = new GaussianFunction(2);                      break;                  case RBFEnum.InverseMultiquadric:                      _rbf = new InverseMultiquadricFunction(2);                      break;                  case RBFEnum.Multiquadric:                      _rbf = new MultiquadricFunction(2);                      break;                  case RBFEnum.MexicanHat:                      _rbf = new MexicanHatFunction(2);                      break;              }
Magic Number,Encog.Neural.SOM.Training.Neighborhood,NeighborhoodRBF,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\SOM\Training\Neighborhood\NeighborhoodRBF.cs,NeighborhoodRBF,The following statement contains a magic number: switch (type)              {                  case RBFEnum.Gaussian:                      _rbf = new GaussianFunction(2);                      break;                  case RBFEnum.InverseMultiquadric:                      _rbf = new InverseMultiquadricFunction(2);                      break;                  case RBFEnum.Multiquadric:                      _rbf = new MultiquadricFunction(2);                      break;                  case RBFEnum.MexicanHat:                      _rbf = new MexicanHatFunction(2);                      break;              }
Magic Number,Encog.Neural.Thermal,BoltzmannMachine,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Thermal\BoltzmannMachine.cs,BoltzmannMachine,The following statement contains a magic number: _annealCycles = 100;
Magic Number,Encog.Neural.Thermal,BoltzmannMachine,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Thermal\BoltzmannMachine.cs,BoltzmannMachine,The following statement contains a magic number: _runCycles = 1000;
Magic Number,Encog.Neural.Thermal,BoltzmannMachine,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Thermal\BoltzmannMachine.cs,BoltzmannMachine,The following statement contains a magic number: _annealCycles = 100;
Magic Number,Encog.Neural.Thermal,BoltzmannMachine,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Thermal\BoltzmannMachine.cs,BoltzmannMachine,The following statement contains a magic number: _runCycles = 1000;
Magic Number,Encog.Neural.Thermal,ThermalNetwork,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Thermal\ThermalNetwork.cs,CalculateEnergy,The following statement contains a magic number: return -1*tempE/2;
Magic Number,Encog.Parse.Expression,CommonRender,C:\repos\encog_encog-dotnet-core\encog-core-cs\Parse\Expression\CommonRender.cs,DetermineNodeType,The following statement contains a magic number: if (node.ChildNodes.Count != 2)              {                  return ExpressionNodeType.Function;              }
Magic Number,Encog.Parse.Expression.Common,ParseCommonExpression,C:\repos\encog_encog-dotnet-core\encog-core-cs\Parse\Expression\Common\ParseCommonExpression.cs,HandleNumeric,The following statement contains a magic number: while (char.IsDigit(this.parser.Peek()))              {                  value = (10.0 * value) + (this.parser.ReadChar() - '0');              }
Magic Number,Encog.Parse.Expression.Common,ParseCommonExpression,C:\repos\encog_encog-dotnet-core\encog-core-cs\Parse\Expression\Common\ParseCommonExpression.cs,HandleNumeric,The following statement contains a magic number: if (this.parser.Peek() == '.')              {                  isFloat = true;                  this.parser.Advance();                    int i = 1;                  while (char.IsDigit(this.parser.Peek()))                  {                      double f = (this.parser.ReadChar() - '0');                      f /= Math.Pow(10.0' i);                      value += f;                      i++;                  }              }
Magic Number,Encog.Parse.Expression.Common,ParseCommonExpression,C:\repos\encog_encog-dotnet-core\encog-core-cs\Parse\Expression\Common\ParseCommonExpression.cs,HandleNumeric,The following statement contains a magic number: if (char.ToUpper(this.parser.Peek()) == 'E')              {                  this.parser.Advance();                    if ((this.parser.Peek() == '+') || (this.parser.Peek() == '-'))                  {                      sign = this.parser.ReadChar();                  }                    while (char.IsDigit(this.parser.Peek()))                  {                      exponent = (int)(10.0 * exponent)                              + (this.parser.ReadChar() - '0');                  }                    if (sign == '-')                  {                      isFloat = true;                      exponent = -exponent;                  }                    value = value * Math.Pow(10' exponent);              }
Magic Number,Encog.Parse.Expression.Common,ParseCommonExpression,C:\repos\encog_encog-dotnet-core\encog-core-cs\Parse\Expression\Common\ParseCommonExpression.cs,HandleNumeric,The following statement contains a magic number: if (char.ToUpper(this.parser.Peek()) == 'E')              {                  this.parser.Advance();                    if ((this.parser.Peek() == '+') || (this.parser.Peek() == '-'))                  {                      sign = this.parser.ReadChar();                  }                    while (char.IsDigit(this.parser.Peek()))                  {                      exponent = (int)(10.0 * exponent)                              + (this.parser.ReadChar() - '0');                  }                    if (sign == '-')                  {                      isFloat = true;                      exponent = -exponent;                  }                    value = value * Math.Pow(10' exponent);              }
Magic Number,Encog.Parse.Expression.Common,ParseCommonExpression,C:\repos\encog_encog-dotnet-core\encog-core-cs\Parse\Expression\Common\ParseCommonExpression.cs,handleString,The following statement contains a magic number: do              {                  ch = this.parser.ReadChar();                  if (ch == 34)                  {                      // handle double quote                      if (this.parser.Peek() == 34)                      {                          this.parser.Advance();                          str.Append(ch);                          ch = this.parser.ReadChar();                      }                  }                  else                  {                      str.Append(ch);                  }              } while ((ch != 34) && (ch > 0));
Magic Number,Encog.Parse.Expression.Common,ParseCommonExpression,C:\repos\encog_encog-dotnet-core\encog-core-cs\Parse\Expression\Common\ParseCommonExpression.cs,handleString,The following statement contains a magic number: do              {                  ch = this.parser.ReadChar();                  if (ch == 34)                  {                      // handle double quote                      if (this.parser.Peek() == 34)                      {                          this.parser.Advance();                          str.Append(ch);                          ch = this.parser.ReadChar();                      }                  }                  else                  {                      str.Append(ch);                  }              } while ((ch != 34) && (ch > 0));
Magic Number,Encog.Parse.Expression.Common,ParseCommonExpression,C:\repos\encog_encog-dotnet-core\encog-core-cs\Parse\Expression\Common\ParseCommonExpression.cs,handleString,The following statement contains a magic number: do              {                  ch = this.parser.ReadChar();                  if (ch == 34)                  {                      // handle double quote                      if (this.parser.Peek() == 34)                      {                          this.parser.Advance();                          str.Append(ch);                          ch = this.parser.ReadChar();                      }                  }                  else                  {                      str.Append(ch);                  }              } while ((ch != 34) && (ch > 0));
Magic Number,Encog.Parse.Expression.Common,ParseCommonExpression,C:\repos\encog_encog-dotnet-core\encog-core-cs\Parse\Expression\Common\ParseCommonExpression.cs,handleString,The following statement contains a magic number: if (ch != 34)              {                  throw (new EACompileError("Unterminated string"));              }
Magic Number,Encog.Parse.Expression.Latex,RenderLatexExpression,C:\repos\encog_encog-dotnet-core\encog-core-cs\Parse\Expression\Latex\RenderLatexExpression.cs,HandleOperator,The following statement contains a magic number: if (temp.ChildNodeCount == 2)              {                  String a = RenderNode(node.GetChildNode(0));                  String b = RenderNode(node.GetChildNode(1));                    if (temp == StandardExtensions.EXTENSION_DIV)                  {                      result.Append("\\frac{");                      result.Append(b);                      result.Append("}{");                      result.Append(a);                      result.Append("}");                  }                  else if (temp == StandardExtensions.EXTENSION_MUL)                  {                      result.Append("(");                      result.Append(b);                      result.Append("\\cdot ");                      result.Append(a);                      result.Append(")");                  }                  else                  {                      result.Append("(");                      result.Append(b);                      result.Append(temp.Name);                      result.Append(a);                      result.Append(")");                  }                }              else if (temp.ChildNodeCount == 1)              {                  String a = RenderNode(node.GetChildNode(0));                  result.Append("(");                  result.Append(temp.Name);                  result.Append(a);                  result.Append(")");              }              else              {                  throw new EACompileError(                          "An operator must have an arity of 1 or 2' probably should be made a function.");              }
Magic Number,Encog.Persist,EncogDirectoryPersistence,C:\repos\encog_encog-dotnet-core\encog-core-cs\Persist\EncogDirectoryPersistence.cs,LoadObject,The following statement contains a magic number: if (p.FileVersion < Int32.Parse(paras[4]))              {                  throw new PersistError(                      "The file you are trying to read is from a later version of Encog.  Please upgrade Encog to read this file.");              }
Magic Number,Encog.Persist,EncogDirectoryPersistence,C:\repos\encog_encog-dotnet-core\encog-core-cs\Persist\EncogDirectoryPersistence.cs,ReadLine,The following statement contains a magic number: try              {                  var result = new StringBuilder();                    char ch;                    do                  {                      int b = mask0.ReadByte();                      if (b == -1)                      {                          return result.ToString();                      }                        ch = (char) b;                        if ((ch != 13) && (ch != 10))                      {                          result.Append(ch);                      }                  } while (ch != 10);                    return result.ToString();              }              catch (IOException ex)              {                  throw new PersistError(ex);              }
Magic Number,Encog.Persist,EncogDirectoryPersistence,C:\repos\encog_encog-dotnet-core\encog-core-cs\Persist\EncogDirectoryPersistence.cs,ReadLine,The following statement contains a magic number: try              {                  var result = new StringBuilder();                    char ch;                    do                  {                      int b = mask0.ReadByte();                      if (b == -1)                      {                          return result.ToString();                      }                        ch = (char) b;                        if ((ch != 13) && (ch != 10))                      {                          result.Append(ch);                      }                  } while (ch != 10);                    return result.ToString();              }              catch (IOException ex)              {                  throw new PersistError(ex);              }
Magic Number,Encog.Persist,EncogDirectoryPersistence,C:\repos\encog_encog-dotnet-core\encog-core-cs\Persist\EncogDirectoryPersistence.cs,ReadLine,The following statement contains a magic number: try              {                  var result = new StringBuilder();                    char ch;                    do                  {                      int b = mask0.ReadByte();                      if (b == -1)                      {                          return result.ToString();                      }                        ch = (char) b;                        if ((ch != 13) && (ch != 10))                      {                          result.Append(ch);                      }                  } while (ch != 10);                    return result.ToString();              }              catch (IOException ex)              {                  throw new PersistError(ex);              }
Magic Number,Encog.Persist,EncogDirectoryPersistence,C:\repos\encog_encog-dotnet-core\encog-core-cs\Persist\EncogDirectoryPersistence.cs,SaveObject,The following statement contains a magic number: try              {                  IEncogPersistor p = PersistorRegistry.Instance                      .GetPersistor(obj.GetType());                    if (p == null)                  {                      throw new PersistError("Do not know how to persist object: "                                             + obj.GetType().Name);                  }                    os.Flush();                  var pw = new StreamWriter(os);                  DateTime now = DateTime.Now;                  pw.WriteLine("encog'" + p.PersistClassString + "'java'"                               + EncogFramework.Version + "'" + p.FileVersion + "'"                               + (now.Ticks/10000));                  pw.Flush();                  p.Save(os' obj);              }              catch (IOException ex)              {                  throw new PersistError(ex);              }
Magic Number,Encog.Persist,EncogFileSection,C:\repos\encog_encog-dotnet-core\encog-core-cs\Persist\EncogFileSection.cs,ParseDoubleArray,The following statement contains a magic number: try              {                                    if ( !paras.ContainsKey(name) )                  {                      throw new PersistError("Missing property: " + name);                  }                    v = paras[name];                    if (v.StartsWith("##"))                  {                      int i = int.Parse(v.Substring(2));                      return _largeArrays[i];                  }                  else                  {                      return NumberList.FromList(CSVFormat.EgFormat' v);                  }              }              catch (FormatException )              {                  throw new PersistError("Field: " + name + "' "                                         + "invalid integer: " + v);              }
Magic Number,Encog.Persist,EncogFileSection,C:\repos\encog_encog-dotnet-core\encog-core-cs\Persist\EncogFileSection.cs,ParseMatrix,The following statement contains a magic number: int index = 2;
Magic Number,Encog.Persist,EncogReadHelper,C:\repos\encog_encog-dotnet-core\encog-core-cs\Persist\EncogReadHelper.cs,ReadNextSection,The following statement contains a magic number: try              {                  String line;                  var largeArrays = new List<double[]>();                    while ((line = reader.ReadLine()) != null)                  {                      line = line.Trim();                        // is it a comment                      if (line.StartsWith("//"))                      {                          continue;                      }  	                          // is it a section or subsection                      else if (line.StartsWith("["))                      {                          // handle previous section                          section = new EncogFileSection(                              currentSectionName' currentSubSectionName);                            foreach (String str in lines)                          {                              section.Lines.Add(str);                          }                              // now begin the new section                          lines.Clear();                          String s = line.Substring(1).Trim();                          if (!s.EndsWith("]"))                          {                              throw new PersistError("Invalid section: " + line);                          }                          s = s.Substring(0' (line.Length - 2) - (0));                          int idx = s.IndexOf(':');                          if (idx == -1)                          {                              currentSectionName = s;                              currentSubSectionName = "";                          }                          else                          {                              if (currentSectionName.Length < 1)                              {                                  throw new PersistError(                                      "Can't begin subsection when a section has not yet been defined: "                                      + line);                              }                                String newSection = s.Substring(0' (idx) - (0));                              String newSubSection = s.Substring(idx + 1);                                if (!newSection.Equals(currentSectionName))                              {                                  throw new PersistError("Can't begin subsection "                                                         + line                                                         + "' while we are still in the section: "                                                         + currentSectionName);                              }                                currentSubSectionName = newSubSection;                          }                          section.LargeArrays = largeArrays;                          return section;                      }                      else if (line.Length < 1)                      {                          continue;                      }                      else if (line.StartsWith("##double"))                      {                          double[] d = ReadLargeArray(line);                          largeArrays.Add(d);                      }                       else                      {                          if (currentSectionName.Length < 1)                          {                              throw new PersistError(                                  "Unknown command before first section: " + line);                          }                            lines.Add(line);                      }                  }                    if (currentSectionName.Length == 0)                  {                      return null;                  }                    section = new EncogFileSection(currentSectionName'                                                 currentSubSectionName);                    foreach (String l in lines)                  {                      section.Lines.Add(l);                  }                    currentSectionName = "";                  currentSubSectionName = "";                  section.LargeArrays = largeArrays;                  return section;              }              catch (IOException ex)              {                  throw new PersistError(ex);              }
Magic Number,Encog.Persist,EncogReadHelper,C:\repos\encog_encog-dotnet-core\encog-core-cs\Persist\EncogReadHelper.cs,ReadLargeArray,The following statement contains a magic number: String str = line.Substring(9);
Magic Number,Encog.Persist,EncogWriteHelper,C:\repos\encog_encog-dotnet-core\encog-core-cs\Persist\EncogWriteHelper.cs,WriteProperty,The following statement contains a magic number: if (d.Length < 2048)              {                  var result = new StringBuilder();                  NumberList.ToList(CSVFormat.EgFormat' result' d);                  WriteProperty(name' result.ToString());              }              else              {                  xout.Write(name);                  xout.Write("=##");                  xout.WriteLine(_largeArrayNumber++);                  xout.Write("##double#");                  xout.WriteLine(d.Length);                    int index = 0;                    while (index < d.Length)                  {                      bool first = true;                      for (int i = 0; (i < 2048) && (index < d.Length); i++)                      {                          if (!first)                          {                              xout.Write("'");                          }                          else                          {                              xout.Write("   ");                          }                          xout.Write(CSVFormat.EgFormat.Format(d[index]'                                  EncogFramework.DefaultPrecision));                          index++;                          first = false;                      }                      xout.WriteLine();                  }                  xout.WriteLine("##end");              }
Magic Number,Encog.Persist,EncogWriteHelper,C:\repos\encog_encog-dotnet-core\encog-core-cs\Persist\EncogWriteHelper.cs,WriteProperty,The following statement contains a magic number: if (d.Length < 2048)              {                  var result = new StringBuilder();                  NumberList.ToList(CSVFormat.EgFormat' result' d);                  WriteProperty(name' result.ToString());              }              else              {                  xout.Write(name);                  xout.Write("=##");                  xout.WriteLine(_largeArrayNumber++);                  xout.Write("##double#");                  xout.WriteLine(d.Length);                    int index = 0;                    while (index < d.Length)                  {                      bool first = true;                      for (int i = 0; (i < 2048) && (index < d.Length); i++)                      {                          if (!first)                          {                              xout.Write("'");                          }                          else                          {                              xout.Write("   ");                          }                          xout.Write(CSVFormat.EgFormat.Format(d[index]'                                  EncogFramework.DefaultPrecision));                          index++;                          first = false;                      }                      xout.WriteLine();                  }                  xout.WriteLine("##end");              }
Magic Number,Encog.Util.Banchmark,EncogBenchmark,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Banchmark\EncogBenchmark.cs,EvalCpu,The following statement contains a magic number: int small = Evaluate.EvaluateTrain(2' 4' 0' 1);
Magic Number,Encog.Util.Banchmark,EncogBenchmark,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Banchmark\EncogBenchmark.cs,EvalCpu,The following statement contains a magic number: int small = Evaluate.EvaluateTrain(2' 4' 0' 1);
Magic Number,Encog.Util.Banchmark,EncogBenchmark,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Banchmark\EncogBenchmark.cs,EvalCpu,The following statement contains a magic number: _report.Report(Steps' Step1'                            "Evaluate CPU' tiny= " + Format.FormatInteger(small/100));
Magic Number,Encog.Util.Banchmark,EncogBenchmark,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Banchmark\EncogBenchmark.cs,EvalCpu,The following statement contains a magic number: int medium = Evaluate.EvaluateTrain(10' 20' 0' 1);
Magic Number,Encog.Util.Banchmark,EncogBenchmark,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Banchmark\EncogBenchmark.cs,EvalCpu,The following statement contains a magic number: int medium = Evaluate.EvaluateTrain(10' 20' 0' 1);
Magic Number,Encog.Util.Banchmark,EncogBenchmark,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Banchmark\EncogBenchmark.cs,EvalCpu,The following statement contains a magic number: _report.Report(Steps' Step1'                            "Evaluate CPU' small= " + Format.FormatInteger(medium/30));
Magic Number,Encog.Util.Banchmark,EncogBenchmark,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Banchmark\EncogBenchmark.cs,EvalCpu,The following statement contains a magic number: int large = Evaluate.EvaluateTrain(100' 200' 40' 5);
Magic Number,Encog.Util.Banchmark,EncogBenchmark,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Banchmark\EncogBenchmark.cs,EvalCpu,The following statement contains a magic number: int large = Evaluate.EvaluateTrain(100' 200' 40' 5);
Magic Number,Encog.Util.Banchmark,EncogBenchmark,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Banchmark\EncogBenchmark.cs,EvalCpu,The following statement contains a magic number: int large = Evaluate.EvaluateTrain(100' 200' 40' 5);
Magic Number,Encog.Util.Banchmark,EncogBenchmark,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Banchmark\EncogBenchmark.cs,EvalCpu,The following statement contains a magic number: int large = Evaluate.EvaluateTrain(100' 200' 40' 5);
Magic Number,Encog.Util.Banchmark,EncogBenchmark,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Banchmark\EncogBenchmark.cs,EvalCpu,The following statement contains a magic number: int huge = Evaluate.EvaluateTrain(200' 300' 200' 50);
Magic Number,Encog.Util.Banchmark,EncogBenchmark,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Banchmark\EncogBenchmark.cs,EvalCpu,The following statement contains a magic number: int huge = Evaluate.EvaluateTrain(200' 300' 200' 50);
Magic Number,Encog.Util.Banchmark,EncogBenchmark,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Banchmark\EncogBenchmark.cs,EvalCpu,The following statement contains a magic number: int huge = Evaluate.EvaluateTrain(200' 300' 200' 50);
Magic Number,Encog.Util.Banchmark,EncogBenchmark,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Banchmark\EncogBenchmark.cs,EvalCpu,The following statement contains a magic number: int huge = Evaluate.EvaluateTrain(200' 300' 200' 50);
Magic Number,Encog.Util.Banchmark,EncogBenchmark,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Banchmark\EncogBenchmark.cs,EvalCpu,The following statement contains a magic number: int result = (small/100) + (medium/30) + large + huge;
Magic Number,Encog.Util.Banchmark,EncogBenchmark,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Banchmark\EncogBenchmark.cs,EvalCpu,The following statement contains a magic number: int result = (small/100) + (medium/30) + large + huge;
Magic Number,Encog.Util.Banchmark,EncogBenchmark,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Banchmark\EncogBenchmark.cs,EvalMemory,The following statement contains a magic number: BasicMLDataSet training = RandomTrainingFactory.Generate(                  1000' 10000' 10' 10' -1' 1);
Magic Number,Encog.Util.Banchmark,EncogBenchmark,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Banchmark\EncogBenchmark.cs,EvalMemory,The following statement contains a magic number: BasicMLDataSet training = RandomTrainingFactory.Generate(                  1000' 10000' 10' 10' -1' 1);
Magic Number,Encog.Util.Banchmark,EncogBenchmark,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Banchmark\EncogBenchmark.cs,EvalMemory,The following statement contains a magic number: BasicMLDataSet training = RandomTrainingFactory.Generate(                  1000' 10000' 10' 10' -1' 1);
Magic Number,Encog.Util.Banchmark,EncogBenchmark,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Banchmark\EncogBenchmark.cs,EvalMemory,The following statement contains a magic number: BasicMLDataSet training = RandomTrainingFactory.Generate(                  1000' 10000' 10' 10' -1' 1);
Magic Number,Encog.Util.Banchmark,EncogBenchmark,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Banchmark\EncogBenchmark.cs,EvalMemory,The following statement contains a magic number: const long stop = (10*Evaluate.Milis);
Magic Number,Encog.Util.Banchmark,EncogBenchmark,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Banchmark\EncogBenchmark.cs,EvalMemory,The following statement contains a magic number: iterations /= 100000;
Magic Number,Encog.Util.Banchmark,EncogBenchmark,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Banchmark\EncogBenchmark.cs,EvalBinary,The following statement contains a magic number: BasicMLDataSet training = RandomTrainingFactory.Generate(                  1000' 10000' 10' 10' -1' 1);
Magic Number,Encog.Util.Banchmark,EncogBenchmark,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Banchmark\EncogBenchmark.cs,EvalBinary,The following statement contains a magic number: BasicMLDataSet training = RandomTrainingFactory.Generate(                  1000' 10000' 10' 10' -1' 1);
Magic Number,Encog.Util.Banchmark,EncogBenchmark,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Banchmark\EncogBenchmark.cs,EvalBinary,The following statement contains a magic number: BasicMLDataSet training = RandomTrainingFactory.Generate(                  1000' 10000' 10' 10' -1' 1);
Magic Number,Encog.Util.Banchmark,EncogBenchmark,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Banchmark\EncogBenchmark.cs,EvalBinary,The following statement contains a magic number: BasicMLDataSet training = RandomTrainingFactory.Generate(                  1000' 10000' 10' 10' -1' 1);
Magic Number,Encog.Util.Banchmark,EncogBenchmark,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Banchmark\EncogBenchmark.cs,EvalBinary,The following statement contains a magic number: const long stop = (10*Evaluate.Milis);
Magic Number,Encog.Util.Banchmark,EncogBenchmark,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Banchmark\EncogBenchmark.cs,EvalBinary,The following statement contains a magic number: iterations /= 100000;
Magic Number,Encog.Util.Banchmark,Evaluate,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Banchmark\Evaluate.cs,EvaluateTrain,The following statement contains a magic number: IMLDataSet training = RandomTrainingFactory.Generate(1000'                                                                  10000' input' output' -1' 1);
Magic Number,Encog.Util.Banchmark,Evaluate,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Banchmark\Evaluate.cs,EvaluateTrain,The following statement contains a magic number: IMLDataSet training = RandomTrainingFactory.Generate(1000'                                                                  10000' input' output' -1' 1);
Magic Number,Encog.Util.Banchmark,Evaluate,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Banchmark\Evaluate.cs,EvaluateTrain,The following statement contains a magic number: const int milis10 = Milis * 10;
Magic Number,Encog.Util.Concurrency,DetermineWorkload,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Concurrency\DetermineWorkload.cs,DetermineWorkload,The following statement contains a magic number: if (threads == 0)              {                  var num = (int) (Math.Log(((double) Process.GetCurrentProcess().ProcessorAffinity + 1)' 2.0));                      // if there is more than one processor' use processor count +1                  if (num != 1)                  {                      num++;                  }                  // if there is a single processor' just use one thread                    // Now see how big the training sets are going to be.                  // We want at least 100 training elements in each.                  // This method will likely be further "tuned" in future versions.                    long recordCount = _workloadSize;                  long workPerThread = recordCount/num;                    if (workPerThread < 100)                  {                      num = Math.Max(1' (int) (recordCount/100));                  }                    _threadCount = num;              }              else              {                  _threadCount = Math.Min(threads' workloadSize);              }
Magic Number,Encog.Util.Concurrency,DetermineWorkload,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Concurrency\DetermineWorkload.cs,DetermineWorkload,The following statement contains a magic number: if (threads == 0)              {                  var num = (int) (Math.Log(((double) Process.GetCurrentProcess().ProcessorAffinity + 1)' 2.0));                      // if there is more than one processor' use processor count +1                  if (num != 1)                  {                      num++;                  }                  // if there is a single processor' just use one thread                    // Now see how big the training sets are going to be.                  // We want at least 100 training elements in each.                  // This method will likely be further "tuned" in future versions.                    long recordCount = _workloadSize;                  long workPerThread = recordCount/num;                    if (workPerThread < 100)                  {                      num = Math.Max(1' (int) (recordCount/100));                  }                    _threadCount = num;              }              else              {                  _threadCount = Math.Min(threads' workloadSize);              }
Magic Number,Encog.Util.Concurrency,DetermineWorkload,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Concurrency\DetermineWorkload.cs,DetermineWorkload,The following statement contains a magic number: if (threads == 0)              {                  var num = (int) (Math.Log(((double) Process.GetCurrentProcess().ProcessorAffinity + 1)' 2.0));                      // if there is more than one processor' use processor count +1                  if (num != 1)                  {                      num++;                  }                  // if there is a single processor' just use one thread                    // Now see how big the training sets are going to be.                  // We want at least 100 training elements in each.                  // This method will likely be further "tuned" in future versions.                    long recordCount = _workloadSize;                  long workPerThread = recordCount/num;                    if (workPerThread < 100)                  {                      num = Math.Max(1' (int) (recordCount/100));                  }                    _threadCount = num;              }              else              {                  _threadCount = Math.Min(threads' workloadSize);              }
Magic Number,Encog.Util.CSV,NumberList,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\CSV\NumberList.cs,ToList,The following statement contains a magic number: ToList(format' 20' result' data);
Magic Number,Encog.Util,Format,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Format.cs,FormatMemory,The following statement contains a magic number: if (memory < MemoryMeg)              {                  return FormatDouble((memory)/((double) MemoryK)' 2) + " KB";              }
Magic Number,Encog.Util,Format,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Format.cs,FormatMemory,The following statement contains a magic number: if (memory < MemoryGig)              {                  return FormatDouble((memory)/((double) MemoryMeg)' 2) + " MB";              }
Magic Number,Encog.Util,Format,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Format.cs,FormatMemory,The following statement contains a magic number: if (memory < MemoryTera)              {                  return FormatDouble((memory)/((double) MemoryGig)' 2) + " GB";              }
Magic Number,Encog.Util,Format,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Format.cs,FormatMemory,The following statement contains a magic number: return FormatDouble((memory)/((double) MemoryTera)' 2) + " TB";
Magic Number,Encog.Util,Format,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Format.cs,FormatPercent,The following statement contains a magic number: return (e*100.0).ToString("N6") + "%";
Magic Number,Encog.Util,Format,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Format.cs,FormatPercentWhole,The following statement contains a magic number: return (e*100.0).ToString("N0") + "%";
Magic Number,Encog.Util,DirectoryUtil,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\DirectoryUtil.cs,ReadStream,The following statement contains a magic number: try              {                  var sb = new StringBuilder(1024);                    var chars = new byte[BufferSize];                  while ((istream.Read(chars' 0' chars.Length)) > -1)                  {                      string s = Encoding.ASCII.GetString(chars);                      sb.Append(s);                  }                    return sb.ToString();              }              catch (IOException e)              {  #if logging                  LOGGER.Error("Exception"' e);  #endif                  throw new EncogError(e);              }
Magic Number,Encog.Util,StringUtil,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\StringUtil.cs,FromBytes,The following statement contains a magic number: var b2 = new byte[b.Length*2];
Magic Number,Encog.Util,StringUtil,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\StringUtil.cs,FromBytes,The following statement contains a magic number: for (int i = 0; i < b.Length; i++)              {                  b2[i*2] = b[i];                  b2[(i*2) + 1] = 0;              }
Magic Number,Encog.Util,StringUtil,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\StringUtil.cs,FromBytes,The following statement contains a magic number: for (int i = 0; i < b.Length; i++)              {                  b2[i*2] = b[i];                  b2[(i*2) + 1] = 0;              }
Magic Number,Encog.Util,YahooSearch,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\YahooSearch.cs,Search,The following statement contains a magic number: while (!done)              {                  try                  {                      result = DoSearch(uri);                      done = true;                  }                  catch (IOException e)                  {                      if (tries == 5)                      {                          throw;                      }                      Thread.Sleep(5000);                  }                  tries++;              }
Magic Number,Encog.Util,YahooSearch,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\YahooSearch.cs,Search,The following statement contains a magic number: while (!done)              {                  try                  {                      result = DoSearch(uri);                      done = true;                  }                  catch (IOException e)                  {                      if (tries == 5)                      {                          throw;                      }                      Thread.Sleep(5000);                  }                  tries++;              }
Magic Number,Encog.Util.File,Directory,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\File\Directory.cs,ReadStream,The following statement contains a magic number: try              {                  var sb = new StringBuilder(1024);                  TextReader reader = new StreamReader(mask0);                    var chars = new char[BufferSize];                  int numRead;                  while ((numRead = reader.Read(chars' 0' chars.Length)) > -1)                  {                      sb.Append(new String(chars' 0' numRead));                  }                  reader.Close();                    return sb.ToString();              }              catch (IOException e)              {                  throw new EncogError(e);              }
Magic Number,Encog.Util.File,FileUtil,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\File\FileUtil.cs,ReadFileAsString,The following statement contains a magic number: var fileData = new StringBuilder(1000);
Magic Number,Encog.Util.File,FileUtil,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\File\FileUtil.cs,ReadFileAsString,The following statement contains a magic number: var buf = new char[1024];
Magic Number,Encog.Util.File,FileUtil,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\File\FileUtil.cs,ReadFileAsString,The following statement contains a magic number: while ((numRead = reader.Read(buf' 0' buf.Length)) != -1)              {                  var readData = new string(buf' 0' numRead);                  fileData.Append(readData);                  buf = new char[1024];              }
Magic Number,Encog.Util.File,FileUtil,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\File\FileUtil.cs,CopyStream,The following statement contains a magic number: var buffer = new byte[32768];
Magic Number,Encog.Util.NetworkUtil,DateNormalize,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\NetworkUtil\DateNormalize.cs,NormalizeMonth,The following statement contains a magic number: var eq = new Equilateral(12' -1' 1);
Magic Number,Encog.Util.NetworkUtil,DateNormalize,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\NetworkUtil\DateNormalize.cs,DenormalizeMonth,The following statement contains a magic number: var eq = new Equilateral(12' -1' 1);
Magic Number,Encog.Util.NetworkUtil,DateNormalize,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\NetworkUtil\DateNormalize.cs,NormalizeDays,The following statement contains a magic number: var eq = new Equilateral(31' -1' 1);
Magic Number,Encog.Util.NetworkUtil,DateNormalize,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\NetworkUtil\DateNormalize.cs,DenormalizeDays,The following statement contains a magic number: var eq = new Equilateral(31' -1' 1);
Magic Number,Encog.Util.NetworkUtil,DateNormalize,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\NetworkUtil\DateNormalize.cs,NormalizeHour,The following statement contains a magic number: var eq = new Equilateral(24' -1' 1);
Magic Number,Encog.Util.NetworkUtil,DateNormalize,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\NetworkUtil\DateNormalize.cs,DenormalizeHour,The following statement contains a magic number: var eq = new Equilateral(24' -1' 1);
Magic Number,Encog.Util.NetworkUtil,DateNormalize,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\NetworkUtil\DateNormalize.cs,NormalizeSeconds,The following statement contains a magic number: var eq = new Equilateral(60' -1' 1);
Magic Number,Encog.Util.NetworkUtil,DateNormalize,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\NetworkUtil\DateNormalize.cs,DenormalizeSeconds,The following statement contains a magic number: var eq = new Equilateral(60' -1' 1);
Magic Number,Encog.Util.NetworkUtil,DateNormalize,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\NetworkUtil\DateNormalize.cs,NormalizeYear,The following statement contains a magic number: var eq = new Equilateral(2011' -1' 1);
Magic Number,Encog.Util.NetworkUtil,DateNormalize,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\NetworkUtil\DateNormalize.cs,DenormalizeYear,The following statement contains a magic number: var eq = new Equilateral(2011' -1' 1);
Magic Number,Encog.Util.NetworkUtil,NetworkUtility,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\NetworkUtil\NetworkUtility.cs,DetermineAngle,The following statement contains a magic number: double result = (Math.Atan2(angle[0]' angle[1])/Math.PI)*180;
Magic Number,Encog.Util.NetworkUtil,NetworkUtility,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\NetworkUtil\NetworkUtility.cs,DetermineAngle,The following statement contains a magic number: if (result < 0)                  result += 360;
Magic Number,Encog.Util.NetworkUtil,NetworkUtility,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\NetworkUtil\NetworkUtility.cs,AveragePercents,The following statement contains a magic number: return Math.Abs(first - second)/(first + second)*100;
Magic Number,Encog.Util.NetworkUtil,TrainerHelper,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\NetworkUtil\TrainerHelper.cs,AddInputsViaLinq,The following statement contains a magic number: ArrayList arlist = new ArrayList(4);
Magic Number,Encog.Util.NetworkUtil,TrainerHelper,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\NetworkUtil\TrainerHelper.cs,AddInputs,The following statement contains a magic number: ArrayList arlist = new ArrayList(4);
Magic Number,Encog.Util.Normalize,DataNormalization,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Normalize\DataNormalization.cs,ReportResult,The following statement contains a magic number: if (_lastReport >= 10000)              {                  _report.Report(total' current' message);                  _lastReport = 0;              }
Magic Number,Encog.Util.Normalize.Output.Nominal,OutputEquilateral,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Normalize\Output\Nominal\OutputEquilateral.cs,AddItem,The following statement contains a magic number: AddItem(inputField' value - 0.1' value + 0.1);
Magic Number,Encog.Util.Normalize.Output.Nominal,OutputEquilateral,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Normalize\Output\Nominal\OutputEquilateral.cs,AddItem,The following statement contains a magic number: AddItem(inputField' value - 0.1' value + 0.1);
Magic Number,Encog.Util.Normalize.Output.Nominal,OutputOneOf,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Normalize\Output\Nominal\OutputOneOf.cs,AddItem,The following statement contains a magic number: AddItem(inputField' value - 0.5' value + 0.5);
Magic Number,Encog.Util.Normalize.Output.Nominal,OutputOneOf,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Normalize\Output\Nominal\OutputOneOf.cs,AddItem,The following statement contains a magic number: AddItem(inputField' value - 0.5' value + 0.5);
Magic Number,Encog.Util.Simple,EncogUtility,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\EncogUtility.cs,FormatNeuralData,The following statement contains a magic number: for (int i = 0; i < data.Count; i++)              {                  if (i != 0)                  {                      result.Append(''');                  }                  result.Append(Format.FormatDouble(data[i]' 4));              }
Magic Number,Encog.Util.Simple,EncogUtility,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\EncogUtility.cs,TrainConsole,The following statement contains a magic number: do              {                  train.Iteration();                    long current = Environment.TickCount;                  long elapsed = (current - start)/1000;                  remaining = minutes - elapsed/60;                    Console.WriteLine(@"Iteration #" + Format.FormatInteger(epoch)                                    + @" Error:" + Format.FormatPercent(train.Error)                                    + @" elapsed time = " + Format.FormatTimeSpan((int) elapsed)                                    + @" time left = "                                    + Format.FormatTimeSpan((int) remaining*60));                  epoch++;              } while (remaining > 0 && !train.TrainingDone);
Magic Number,Encog.Util.Simple,EncogUtility,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\EncogUtility.cs,TrainConsole,The following statement contains a magic number: do              {                  train.Iteration();                    long current = Environment.TickCount;                  long elapsed = (current - start)/1000;                  remaining = minutes - elapsed/60;                    Console.WriteLine(@"Iteration #" + Format.FormatInteger(epoch)                                    + @" Error:" + Format.FormatPercent(train.Error)                                    + @" elapsed time = " + Format.FormatTimeSpan((int) elapsed)                                    + @" time left = "                                    + Format.FormatTimeSpan((int) remaining*60));                  epoch++;              } while (remaining > 0 && !train.TrainingDone);
Magic Number,Encog.Util.Simple,EncogUtility,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\EncogUtility.cs,TrainConsole,The following statement contains a magic number: do              {                  train.Iteration();                    long current = Environment.TickCount;                  long elapsed = (current - start)/1000;                  remaining = minutes - elapsed/60;                    Console.WriteLine(@"Iteration #" + Format.FormatInteger(epoch)                                    + @" Error:" + Format.FormatPercent(train.Error)                                    + @" elapsed time = " + Format.FormatTimeSpan((int) elapsed)                                    + @" time left = "                                    + Format.FormatTimeSpan((int) remaining*60));                  epoch++;              } while (remaining > 0 && !train.TrainingDone);
Magic Number,Encog.Util.Simple,EncogUtility,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\EncogUtility.cs,TrainConsole,The following statement contains a magic number: do              {                  train.Iteration();                    double current = Environment.TickCount;                  double elapsed = (current - start) / 1000;                  remaining = seconds - elapsed;                    Console.WriteLine(@"Iteration #" + Format.FormatInteger(epoch)                                    + @" Error:" + Format.FormatPercent(train.Error)                                    + @" elapsed time = " + Format.FormatTimeSpan((int)elapsed)                                    + @" time left = "                                    + Format.FormatTimeSpan((int)remaining));                  epoch++;              } while (remaining > 0 && !train.TrainingDone);
Magic Number,Encog.Util.Simple,TrainingDialog,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\TrainingDialog.cs,ThreadProcess,The following statement contains a magic number: do              {                  Train.Iteration();                    long current = Environment.TickCount;                  long elapsed = (current - start);                  elapsed /= 1000;                    var obj = new object[3];                  obj[0] = "" + Format.FormatInteger(epoch);                  obj[1] = "" + Format.FormatPercent(Train.Error);                  obj[2] = "" + Format.FormatTimeSpan((int) elapsed);                  BeginInvoke(new StatsDelegate(UpdateStats)' obj);                    epoch++;              } while (!ShouldStop);
Magic Number,Encog.Util.Simple,TrainingDialog,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\TrainingDialog.cs,ThreadProcess,The following statement contains a magic number: do              {                  Train.Iteration();                    long current = Environment.TickCount;                  long elapsed = (current - start);                  elapsed /= 1000;                    var obj = new object[3];                  obj[0] = "" + Format.FormatInteger(epoch);                  obj[1] = "" + Format.FormatPercent(Train.Error);                  obj[2] = "" + Format.FormatTimeSpan((int) elapsed);                  BeginInvoke(new StatsDelegate(UpdateStats)' obj);                    epoch++;              } while (!ShouldStop);
Magic Number,Encog.Util.Simple,TrainingDialog,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\TrainingDialog.cs,ThreadProcess,The following statement contains a magic number: do              {                  Train.Iteration();                    long current = Environment.TickCount;                  long elapsed = (current - start);                  elapsed /= 1000;                    var obj = new object[3];                  obj[0] = "" + Format.FormatInteger(epoch);                  obj[1] = "" + Format.FormatPercent(Train.Error);                  obj[2] = "" + Format.FormatTimeSpan((int) elapsed);                  BeginInvoke(new StatsDelegate(UpdateStats)' obj);                    epoch++;              } while (!ShouldStop);
Magic Number,Encog.Util.Simple,TrainingDialog,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\TrainingDialog.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point(12' 9);
Magic Number,Encog.Util.Simple,TrainingDialog,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\TrainingDialog.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point(12' 9);
Magic Number,Encog.Util.Simple,TrainingDialog,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\TrainingDialog.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size(69' 13);
Magic Number,Encog.Util.Simple,TrainingDialog,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\TrainingDialog.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size(69' 13);
Magic Number,Encog.Util.Simple,TrainingDialog,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\TrainingDialog.cs,InitializeComponent,The following statement contains a magic number: this.button1.Location = new System.Drawing.Point(15' 96);
Magic Number,Encog.Util.Simple,TrainingDialog,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\TrainingDialog.cs,InitializeComponent,The following statement contains a magic number: this.button1.Location = new System.Drawing.Point(15' 96);
Magic Number,Encog.Util.Simple,TrainingDialog,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\TrainingDialog.cs,InitializeComponent,The following statement contains a magic number: this.button1.Size = new System.Drawing.Size(218' 23);
Magic Number,Encog.Util.Simple,TrainingDialog,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\TrainingDialog.cs,InitializeComponent,The following statement contains a magic number: this.button1.Size = new System.Drawing.Size(218' 23);
Magic Number,Encog.Util.Simple,TrainingDialog,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\TrainingDialog.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point(12' 36);
Magic Number,Encog.Util.Simple,TrainingDialog,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\TrainingDialog.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point(12' 36);
Magic Number,Encog.Util.Simple,TrainingDialog,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\TrainingDialog.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size(53' 13);
Magic Number,Encog.Util.Simple,TrainingDialog,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\TrainingDialog.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size(53' 13);
Magic Number,Encog.Util.Simple,TrainingDialog,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\TrainingDialog.cs,InitializeComponent,The following statement contains a magic number: this.label2.TabIndex = 2;
Magic Number,Encog.Util.Simple,TrainingDialog,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\TrainingDialog.cs,InitializeComponent,The following statement contains a magic number: this.label3.Location = new System.Drawing.Point(12' 66);
Magic Number,Encog.Util.Simple,TrainingDialog,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\TrainingDialog.cs,InitializeComponent,The following statement contains a magic number: this.label3.Location = new System.Drawing.Point(12' 66);
Magic Number,Encog.Util.Simple,TrainingDialog,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\TrainingDialog.cs,InitializeComponent,The following statement contains a magic number: this.label3.Size = new System.Drawing.Size(74' 13);
Magic Number,Encog.Util.Simple,TrainingDialog,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\TrainingDialog.cs,InitializeComponent,The following statement contains a magic number: this.label3.Size = new System.Drawing.Size(74' 13);
Magic Number,Encog.Util.Simple,TrainingDialog,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\TrainingDialog.cs,InitializeComponent,The following statement contains a magic number: this.label3.TabIndex = 3;
Magic Number,Encog.Util.Simple,TrainingDialog,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\TrainingDialog.cs,InitializeComponent,The following statement contains a magic number: this.currentError.Location = new System.Drawing.Point(133' 6);
Magic Number,Encog.Util.Simple,TrainingDialog,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\TrainingDialog.cs,InitializeComponent,The following statement contains a magic number: this.currentError.Location = new System.Drawing.Point(133' 6);
Magic Number,Encog.Util.Simple,TrainingDialog,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\TrainingDialog.cs,InitializeComponent,The following statement contains a magic number: this.currentError.Size = new System.Drawing.Size(100' 20);
Magic Number,Encog.Util.Simple,TrainingDialog,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\TrainingDialog.cs,InitializeComponent,The following statement contains a magic number: this.currentError.Size = new System.Drawing.Size(100' 20);
Magic Number,Encog.Util.Simple,TrainingDialog,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\TrainingDialog.cs,InitializeComponent,The following statement contains a magic number: this.currentError.TabIndex = 4;
Magic Number,Encog.Util.Simple,TrainingDialog,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\TrainingDialog.cs,InitializeComponent,The following statement contains a magic number: this.iterations.Location = new System.Drawing.Point(133' 36);
Magic Number,Encog.Util.Simple,TrainingDialog,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\TrainingDialog.cs,InitializeComponent,The following statement contains a magic number: this.iterations.Location = new System.Drawing.Point(133' 36);
Magic Number,Encog.Util.Simple,TrainingDialog,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\TrainingDialog.cs,InitializeComponent,The following statement contains a magic number: this.iterations.Size = new System.Drawing.Size(100' 20);
Magic Number,Encog.Util.Simple,TrainingDialog,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\TrainingDialog.cs,InitializeComponent,The following statement contains a magic number: this.iterations.Size = new System.Drawing.Size(100' 20);
Magic Number,Encog.Util.Simple,TrainingDialog,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\TrainingDialog.cs,InitializeComponent,The following statement contains a magic number: this.iterations.TabIndex = 5;
Magic Number,Encog.Util.Simple,TrainingDialog,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\TrainingDialog.cs,InitializeComponent,The following statement contains a magic number: this.trainingTime.Location = new System.Drawing.Point(133' 66);
Magic Number,Encog.Util.Simple,TrainingDialog,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\TrainingDialog.cs,InitializeComponent,The following statement contains a magic number: this.trainingTime.Location = new System.Drawing.Point(133' 66);
Magic Number,Encog.Util.Simple,TrainingDialog,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\TrainingDialog.cs,InitializeComponent,The following statement contains a magic number: this.trainingTime.Size = new System.Drawing.Size(100' 20);
Magic Number,Encog.Util.Simple,TrainingDialog,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\TrainingDialog.cs,InitializeComponent,The following statement contains a magic number: this.trainingTime.Size = new System.Drawing.Size(100' 20);
Magic Number,Encog.Util.Simple,TrainingDialog,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\TrainingDialog.cs,InitializeComponent,The following statement contains a magic number: this.trainingTime.TabIndex = 6;
Magic Number,Encog.Util.Simple,TrainingDialog,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\TrainingDialog.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(253' 127);
Magic Number,Encog.Util.Simple,TrainingDialog,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\TrainingDialog.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(253' 127);
Magic Number,Encog.Util.Time,NumericDateUtil,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Time\NumericDateUtil.cs,GetMinutePeriod,The following statement contains a magic number: int minutes = minute + (hour*60);
Magic Number,Encog.Util.Time,NumericDateUtil,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Time\NumericDateUtil.cs,Combine,The following statement contains a magic number: return (date*1000000) + time;
Magic Number,Encog.Util.Time,NumericDateUtil,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Time\NumericDateUtil.cs,GetDayOfWeek,The following statement contains a magic number: switch (t.DayOfWeek)              {                  case DayOfWeek.Sunday:                      return 0;                  case DayOfWeek.Monday:                      return 1;                  case DayOfWeek.Tuesday:                      return 2;                  case DayOfWeek.Wednesday:                      return 3;                  case DayOfWeek.Thursday:                      return 4;                  case DayOfWeek.Friday:                      return 5;                  case DayOfWeek.Saturday:                      return 6;                  default:                      // no way this should happen!                      return -1;              }
Magic Number,Encog.Util.Time,NumericDateUtil,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Time\NumericDateUtil.cs,GetDayOfWeek,The following statement contains a magic number: switch (t.DayOfWeek)              {                  case DayOfWeek.Sunday:                      return 0;                  case DayOfWeek.Monday:                      return 1;                  case DayOfWeek.Tuesday:                      return 2;                  case DayOfWeek.Wednesday:                      return 3;                  case DayOfWeek.Thursday:                      return 4;                  case DayOfWeek.Friday:                      return 5;                  case DayOfWeek.Saturday:                      return 6;                  default:                      // no way this should happen!                      return -1;              }
Magic Number,Encog.Util.Time,NumericDateUtil,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Time\NumericDateUtil.cs,GetDayOfWeek,The following statement contains a magic number: switch (t.DayOfWeek)              {                  case DayOfWeek.Sunday:                      return 0;                  case DayOfWeek.Monday:                      return 1;                  case DayOfWeek.Tuesday:                      return 2;                  case DayOfWeek.Wednesday:                      return 3;                  case DayOfWeek.Thursday:                      return 4;                  case DayOfWeek.Friday:                      return 5;                  case DayOfWeek.Saturday:                      return 6;                  default:                      // no way this should happen!                      return -1;              }
Magic Number,Encog.Util.Time,NumericDateUtil,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Time\NumericDateUtil.cs,GetDayOfWeek,The following statement contains a magic number: switch (t.DayOfWeek)              {                  case DayOfWeek.Sunday:                      return 0;                  case DayOfWeek.Monday:                      return 1;                  case DayOfWeek.Tuesday:                      return 2;                  case DayOfWeek.Wednesday:                      return 3;                  case DayOfWeek.Thursday:                      return 4;                  case DayOfWeek.Friday:                      return 5;                  case DayOfWeek.Saturday:                      return 6;                  default:                      // no way this should happen!                      return -1;              }
Magic Number,Encog.Util.Time,NumericDateUtil,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Time\NumericDateUtil.cs,GetDayOfWeek,The following statement contains a magic number: switch (t.DayOfWeek)              {                  case DayOfWeek.Sunday:                      return 0;                  case DayOfWeek.Monday:                      return 1;                  case DayOfWeek.Tuesday:                      return 2;                  case DayOfWeek.Wednesday:                      return 3;                  case DayOfWeek.Thursday:                      return 4;                  case DayOfWeek.Friday:                      return 5;                  case DayOfWeek.Saturday:                      return 6;                  default:                      // no way this should happen!                      return -1;              }
Magic Number,Encog.Util.Time,TimeSpanUtil,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Time\TimeSpanUtil.cs,GetSpanMinutes,The following statement contains a magic number: return GetSpanSeconds()/60;
Magic Number,Encog.Util.Time,TimeSpanUtil,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Time\TimeSpanUtil.cs,GetSpanHours,The following statement contains a magic number: return GetSpanMinutes()/60;
Magic Number,Encog.Util.Time,TimeSpanUtil,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Time\TimeSpanUtil.cs,GetSpanDays,The following statement contains a magic number: return GetSpanHours()/24;
Magic Number,Encog.Util.Time,TimeSpanUtil,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Time\TimeSpanUtil.cs,GetSpanWeeks,The following statement contains a magic number: return GetSpanDays()/7;
Magic Number,Encog.Util.Time,TimeSpanUtil,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Time\TimeSpanUtil.cs,GetSpanFortnights,The following statement contains a magic number: return GetSpanWeeks()/2;
Magic Number,Encog.Util.Time,TimeSpanUtil,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Time\TimeSpanUtil.cs,GetSpanMonths,The following statement contains a magic number: return (_to.Month - _from.Month) + (_to.Year - _from.Year)*12;
Magic Number,Encog.Util.Time,TimeSpanUtil,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Time\TimeSpanUtil.cs,GetSpanYears,The following statement contains a magic number: return GetSpanMonths()/12;
Magic Number,Encog.Util.Time,TimeSpanUtil,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Time\TimeSpanUtil.cs,GetSpanScores,The following statement contains a magic number: return GetSpanYears()/20;
Magic Number,Encog.Util.Time,TimeSpanUtil,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Time\TimeSpanUtil.cs,GetSpanCenturies,The following statement contains a magic number: return GetSpanYears()/100;
Magic Number,Encog.Util.Time,TimeSpanUtil,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\Time\TimeSpanUtil.cs,GetSpanMillennia,The following statement contains a magic number: return GetSpanYears()/1000;
Magic Number,Encog.Parse,PeekableInputStream,C:\repos\encog_encog-dotnet-core\encog-core-cs\Parse\PeekableInputStream.cs,PeekableInputStream,The following statement contains a magic number: _peekBytes = new byte[10];
Magic Number,Encog.Parse,PeekableInputStream,C:\repos\encog_encog-dotnet-core\encog-core-cs\Parse\PeekableInputStream.cs,Peek,The following statement contains a magic number: if (_peekBytes.Length <= depth)              {                  var temp = new byte[depth + 10];                  for (int i = 0; i < _peekBytes.Length; i++)                  {                      temp[i] = _peekBytes[i];                  }                  _peekBytes = temp;              }
Magic Number,Encog.Util.DownSample,RGBDownsample,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\DownSample\RGBDownsample.cs,DownSample,The following statement contains a magic number: var result = new double[height*width*3];
Magic Number,Encog.Util.DownSample,RGBDownsample,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\DownSample\RGBDownsample.cs,HLineClear,The following statement contains a magic number: for (int i = 0; i < _imageWidth; i++)              {                  Color pixel = Image.GetPixel(i' y);                  if (pixel.R < 250 || pixel.G < 250 || pixel.B < 250)                  {                      return false;                  }              }
Magic Number,Encog.Util.DownSample,RGBDownsample,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\DownSample\RGBDownsample.cs,HLineClear,The following statement contains a magic number: for (int i = 0; i < _imageWidth; i++)              {                  Color pixel = Image.GetPixel(i' y);                  if (pixel.R < 250 || pixel.G < 250 || pixel.B < 250)                  {                      return false;                  }              }
Magic Number,Encog.Util.DownSample,RGBDownsample,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\DownSample\RGBDownsample.cs,HLineClear,The following statement contains a magic number: for (int i = 0; i < _imageWidth; i++)              {                  Color pixel = Image.GetPixel(i' y);                  if (pixel.R < 250 || pixel.G < 250 || pixel.B < 250)                  {                      return false;                  }              }
Magic Number,Encog.Util.DownSample,RGBDownsample,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\DownSample\RGBDownsample.cs,VLineClear,The following statement contains a magic number: for (int i = 0; i < _imageHeight; i++)              {                  Color pixel = Image.GetPixel(x' i);                  if (pixel.R < 250 || pixel.G < 250 || pixel.B < 250)                  {                      return false;                  }              }
Magic Number,Encog.Util.DownSample,RGBDownsample,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\DownSample\RGBDownsample.cs,VLineClear,The following statement contains a magic number: for (int i = 0; i < _imageHeight; i++)              {                  Color pixel = Image.GetPixel(x' i);                  if (pixel.R < 250 || pixel.G < 250 || pixel.B < 250)                  {                      return false;                  }              }
Magic Number,Encog.Util.DownSample,RGBDownsample,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\DownSample\RGBDownsample.cs,VLineClear,The following statement contains a magic number: for (int i = 0; i < _imageHeight; i++)              {                  Color pixel = Image.GetPixel(x' i);                  if (pixel.R < 250 || pixel.G < 250 || pixel.B < 250)                  {                      return false;                  }              }
Magic Number,Encog.Util.DownSample,SimpleIntensityDownsample,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\DownSample\SimpleIntensityDownsample.cs,DownSample,The following statement contains a magic number: var result = new double[height*width*3];
Magic Number,Encog.Util.DownSample,SimpleIntensityDownsample,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\DownSample\SimpleIntensityDownsample.cs,DownSample,The following statement contains a magic number: for (int y = 0; y < height; y++)              {                  for (int x = 0; x < width; x++)                  {                      DownSampleRegion(x' y);                      result[index++] = (CurrentRed + CurrentBlue                                         + CurrentGreen)/3;                  }              }
Magic Number,Encog.Util.HTTP,FormUtility,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\HTTP\FormUtility.cs,AddFile,The following statement contains a magic number: if (_boundary != null)              {                  Boundary();                  WriteName(name);                  Write("; filename=\"");                  Write(file);                  Write("\"");                  Newline();                  Write("Content-Type: ");                    Writeln(type);                  Newline();                    var buf = new byte[8192];                  int nread;                    _writer.Flush();                  _os.Flush();                    Stream istream = new FileStream(file' FileMode.Open);                  while ((nread = istream.Read(buf' 0' buf.Length)) > 0)                  {                      _os.Write(buf' 0' nread);                  }                    _os.Flush();                  Newline();              }
Magic Number,Encog.Util.HTTP,URLUtility,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\HTTP\URLUtility.cs,ConstructURL,The following statement contains a magic number: if (port == 80 && String.Compare(protocol' "http") != 0)              {                  sb.Append(':');                  sb.Append("80");              }              else if (port == 443 && String.Compare(protocol' "https") != 0)              {                  sb.Append(':');                  sb.Append("443");              }
Magic Number,Encog.Util.HTTP,URLUtility,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\HTTP\URLUtility.cs,ConstructURL,The following statement contains a magic number: if (port == 80 && String.Compare(protocol' "http") != 0)              {                  sb.Append(':');                  sb.Append("80");              }              else if (port == 443 && String.Compare(protocol' "https") != 0)              {                  sb.Append(':');                  sb.Append("443");              }
Magic Number,Encog.Util.HTTP,URLUtility,C:\repos\encog_encog-dotnet-core\encog-core-cs\Util\HTTP\URLUtility.cs,ContainsInvalidURLCharacters,The following statement contains a magic number: return url.Any(ch => ch > 255);
Missing Default,Encog.App.Analyst.Wizard,AnalystWizard,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,GenerateProcess,The following switch statement is missing a default case: switch (prediction)              {                  case PredictionType.fieldmax:                      c.Append("fieldmax(\"");                      c.Append(predictField);                      c.Append("\"'");                      c.Append(-forwardWindow);                      c.Append("'");                      c.Append(-1);                      c.Append(")");                      break;                  case PredictionType.fieldmaxpip:                      c.Append("fieldmaxpip(\"");                      c.Append(predictField);                      c.Append("\"'");                      c.Append(-forwardWindow);                      c.Append("'");                      c.Append(-1);                      c.Append(")");                      break;              }
Missing Default,Encog.App.Generate,EncogCodeGeneration,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Generate\EncogCodeGeneration.cs,EncogCodeGeneration,The following switch statement is missing a default case: switch (theTargetLanguage)              {                  case TargetLanguage.NoGeneration:                      throw new AnalystCodeGenerationError(                          "No target language has been specified for code generation.");                  case TargetLanguage.Java:                      generator = new GenerateEncogJava();                      break;                  case TargetLanguage.CSharp:                      generator = new GenerateCS();                      break;                  case TargetLanguage.MQL4:                      generator = new GenerateMQL4();                      break;                  case TargetLanguage.NinjaScript:                      generator = new GenerateNinjaScript();                      break;                  case TargetLanguage.JavaScript:                      generator = new GenerateEncogJavaScript();                      break;              }
Missing Default,Encog.App.Generate.Generators.CS,GenerateCS,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Generate\Generators\CS\GenerateCS.cs,GenerateNode,The following switch statement is missing a default case: switch (node.Type)              {                  case NodeType.Comment:                      GenerateComment(node);                      break;                  case NodeType.Class:                      GenerateClass(node);                      break;                  case NodeType.MainFunction:                      GenerateMainFunction(node);                      break;                  case NodeType.Const:                      GenerateConst(node);                      break;                  case NodeType.StaticFunction:                      GenerateFunction(node);                      break;                  case NodeType.FunctionCall:                      GenerateFunctionCall(node);                      break;                  case NodeType.CreateNetwork:                      GenerateCreateNetwork(node);                      break;                  case NodeType.InitArray:                      GenerateArrayInit(node);                      break;                  case NodeType.EmbedTraining:                      GenerateEmbedTraining(node);                      break;                  case NodeType.LoadTraining:                      GenerateLoadTraining(node);                      break;              }
Missing Default,Encog.App.Generate.Generators.Java,GenerateEncogJava,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Generate\Generators\Java\GenerateEncogJava.cs,GenerateNode,The following switch statement is missing a default case: switch (node.Type)              {                  case NodeType.Comment:                      GenerateComment(node);                      break;                  case NodeType.Class:                      GenerateClass(node);                      break;                  case NodeType.MainFunction:                      GenerateMainFunction(node);                      break;                  case NodeType.Const:                      GenerateConst(node);                      break;                  case NodeType.StaticFunction:                      GenerateFunction(node);                      break;                  case NodeType.FunctionCall:                      GenerateFunctionCall(node);                      break;                  case NodeType.CreateNetwork:                      GenerateCreateNetwork(node);                      break;                  case NodeType.InitArray:                      GenerateArrayInit(node);                      break;                  case NodeType.EmbedTraining:                      GenerateEmbedTraining(node);                      break;                  case NodeType.LoadTraining:                      GenerateLoadTraining(node);                      break;              }
Missing Default,Encog.App.Generate.Generators.JS,GenerateEncogJavaScript,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Generate\Generators\JS\GenerateEncogJavaScript.cs,GenerateNode,The following switch statement is missing a default case: switch (node.Type)              {                  case NodeType.Comment:                      GenerateComment(node);                      break;                  case NodeType.Class:                      GenerateClass(node);                      break;                  case NodeType.MainFunction:                      GenerateMainFunction(node);                      break;                  case NodeType.Const:                      GenerateConst(node);                      break;                  case NodeType.StaticFunction:                      GenerateFunction(node);                      break;                  case NodeType.FunctionCall:                      GenerateFunctionCall(node);                      break;                  case NodeType.CreateNetwork:                      EmbedNetwork(node);                      break;                  case NodeType.InitArray:                      GenerateArrayInit(node);                      break;                  case NodeType.EmbedTraining:                      EmbedTraining(node);                      break;              }
Missing Default,Encog.App.Quant.Loader.OpenQuant.Data,Bar,C:\repos\encog_encog-dotnet-core\encog-core-cs\App\Quant\Loader\OpenQuant\Bar.cs,GetPrice,The following switch statement is missing a default case: switch (option)                  {                      case BarPrice.High:                          return High;                        case BarPrice.Low:                          return Low;                        case BarPrice.Open:                          return Open;                        case BarPrice.Close:                          return Close;                        case BarPrice.Median:                          return Median;                        case BarPrice.Typical:                          return Typical;                        case BarPrice.Weighted:                          return Weighted;                  }
Missing Default,Encog.MathUtil.LIBSVM,svm,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_train_one,The following switch statement is missing a default case: switch (param.svm_type)              {                  case svm_parameter.C_SVC:                      solve_c_svc(prob' param' alpha' si' Cp' Cn);                      break;                    case svm_parameter.NU_SVC:                      solve_nu_svc(prob' param' alpha' si);                      break;                    case svm_parameter.ONE_CLASS:                      solve_one_class(prob' param' alpha' si);                      break;                    case svm_parameter.EPSILON_SVR:                      solve_epsilon_svr(prob' param' alpha' si);                      break;                    case svm_parameter.NU_SVR:                      solve_nu_svr(prob' param' alpha' si);                      break;              }
Missing Default,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,C:\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following switch statement is missing a default case: switch (kase)                  {                          // Deflate negligible s(p).                        case 1:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for (int j = p - 2; j >= k; j--)                              {                                  double t = EncogMath.Hypot(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  if (j != k)                                  {                                      f = -sn*e[j - 1];                                      e[j - 1] = cs*e[j - 1];                                  }                                  if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*vmatrix[i][j] + sn*vmatrix[i][p - 1];                                          vmatrix[i][p - 1] = -sn*vmatrix[i][j] + cs*vmatrix[i][p - 1];                                          vmatrix[i][j] = t;                                      }                                  }                              }                          }                          break;                            // Split at negligible s(k).                        case 2:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for (int j = k; j < p; j++)                              {                                  double t = EncogMath.Hypot(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  f = -sn*e[j];                                  e[j] = cs*e[j];                                  if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*umatrix[i][j] + sn*umatrix[i][k - 1];                                          umatrix[i][k - 1] = -sn*umatrix[i][j] + cs*umatrix[i][k - 1];                                          umatrix[i][j] = t;                                      }                                  }                              }                          }                          break;                            // Perform one qr step.                        case 3:                          {                              // Calculate the shift.                                double scale = Math.Max(Math.Max(Math                                                                   .Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))'                                                                        Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math                                                                                                                  .Abs(                                                                                                                      e[k]));                              double sp = s[p - 1]/scale;                              double spm1 = s[p - 2]/scale;                              double epm1 = e[p - 2]/scale;                              double sk = s[k]/scale;                              double ek = e[k]/scale;                              double b = ((spm1 + sp)*(spm1 - sp) + epm1*epm1)/2.0;                              double c = (sp*epm1)*(sp*epm1);                              double shift = 0.0;                              if ((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt(b*b + c);                                  if (b < 0.0)                                  {                                      shift = -shift;                                  }                                  shift = c/(b + shift);                              }                              double f = (sk + sp)*(sk - sp) + shift;                              double g = sk*ek;                                // Chase zeros.                                for (int j = k; j < p - 1; j++)                              {                                  double t = EncogMath.Hypot(f' g);                                  double cs = f/t;                                  double sn = g/t;                                  if (j != k)                                  {                                      e[j - 1] = t;                                  }                                  f = cs*s[j] + sn*e[j];                                  e[j] = cs*e[j] - sn*s[j];                                  g = sn*s[j + 1];                                  s[j + 1] = cs*s[j + 1];                                  if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*vmatrix[i][j] + sn*vmatrix[i][j + 1];                                          vmatrix[i][j + 1] = -sn*vmatrix[i][j] + cs*vmatrix[i][j + 1];                                          vmatrix[i][j] = t;                                      }                                  }                                  t = EncogMath.Hypot(f' g);                                  cs = f/t;                                  sn = g/t;                                  s[j] = t;                                  f = cs*e[j] + sn*s[j + 1];                                  s[j + 1] = -sn*e[j] + cs*s[j + 1];                                  g = sn*e[j + 1];                                  e[j + 1] = cs*e[j + 1];                                  if (wantu && (j < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*umatrix[i][j] + sn*umatrix[i][j + 1];                                          umatrix[i][j + 1] = -sn*umatrix[i][j] + cs*umatrix[i][j + 1];                                          umatrix[i][j] = t;                                      }                                  }                              }                              e[p - 2] = f;                              iter = iter + 1;                          }                          break;                            // Convergence.                        case 4:                          {                              // Make the singular values positive.                                if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                  if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                      {                                          vmatrix[i][k] = -vmatrix[i][k];                                      }                                  }                              }                                // Order the singular values.                                while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                  {                                      break;                                  }                                  double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                  if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = vmatrix[i][k + 1];                                          vmatrix[i][k + 1] = vmatrix[i][k];                                          vmatrix[i][k] = t;                                      }                                  }                                  if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = umatrix[i][k + 1];                                          umatrix[i][k + 1] = umatrix[i][k];                                          umatrix[i][k] = t;                                      }                                  }                                  k++;                              }                              iter = 0;                              p--;                          }                          break;                  }
Missing Default,Encog.ML.Bayesian.Query,BasicQuery,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Bayesian\Query\BasicQuery.cs,LocateEventTypes,The following switch statement is missing a default case: switch (GetEventType(e))                  {                      case EventType.Evidence:                          _evidenceEvents.Add(e);                          break;                      case EventType.Outcome:                          _outcomeEvents.Add(e);                          break;                  }
Missing Default,Encog.ML.Bayesian.Training,TrainBayesian,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Bayesian\Training\TrainBayesian.cs,IterationInit,The following switch statement is missing a default case: switch (_initNetwork)              {                  case BayesianInit.InitEmpty:                      _network.RemoveAllRelations();                      _network.FinalizeStructure();                      break;                  case BayesianInit.InitNoChange:                      break;                  case BayesianInit.InitNaiveBayes:                      InitNaiveBayes();                      break;              }
Missing Default,Encog.ML.Bayesian.Training,TrainBayesian,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Bayesian\Training\TrainBayesian.cs,Iteration,The following switch statement is missing a default case: switch (_p)              {                  case Phase.Init:                      IterationInit();                      break;                  case Phase.Search:                      IterationSearch();                      break;                  case Phase.SearchDone:                      IterationSearchDone();                      break;                  case Phase.Probability:                      IterationProbability();                      break;                  case Phase.Finish:                      IterationFinish();                      break;              }
Missing Default,Encog.ML.Data.Versatile.Columns,ColumnDefinition,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Versatile\Columns\ColumnDefinition.cs,Analyze,The following switch statement is missing a default case: switch (DataType)              {                  case ColumnType.Continuous:                      AnalyzeContinuous(value);                      break;                  case ColumnType.Ordinal:                      AnalyzeOrdinal(value);                      break;                  case ColumnType.Nominal:                      AnalyzeNominal(value);                      break;              }
Missing Default,Encog.ML.Prg,EncogProgram,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Prg\EncogProgram.cs,Compute,The following switch statement is missing a default case: switch (resultMapping.VariableType)              {                  case EPLValueType.FloatingType:                      if (v.IsNumeric)                      {                          result.Data[0] = v.ToFloatValue();                          success = true;                      }                      break;                  case EPLValueType.StringType:                      result.Data[0] = v.ToFloatValue();                      success = true;                      break;                  case EPLValueType.BooleanType:                      if (v.IsBoolean)                      {                          result.Data[0] = v.ToBooleanValue() ? 1.0 : 0.0;                          success = true;                      }                      break;                  case EPLValueType.IntType:                      if (v.IsNumeric)                      {                          result[0] = v.ToIntValue();                          success = true;                      }                      break;                  case EPLValueType.EnumType:                      if (v.IsEnum)                      {                          result.Data[0] = v.ToIntValue();                          success = true;                      }                      break;              }
Missing Default,Encog.ML.Prg,PersistPrgPopulation,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Prg\PersistPrgPopulation.cs,GetType,The following switch statement is missing a default case: switch (mapping.VariableType)              {                  case EPLValueType.FloatingType:                      return "f";                  case EPLValueType.StringType:                      return "s";                  case EPLValueType.BooleanType:                      return "b";                  case EPLValueType.IntType:                      return "i";                  case EPLValueType.EnumType:                      return "e";              }
Missing Default,Encog.ML.Prg.Train.Rewrite,RewriteAlgebraic,C:\repos\encog_encog-dotnet-core\encog-core-cs\ML\Prg\Train\Rewrite\RewriteAlgebraic.cs,TryVarOpVar,The following switch statement is missing a default case: switch (parent.Name[0])                          {                              case '-':                                  parent = CreateNumericConst(parent.Owner' 0);                                  break;                              case '+':                                  parent = parent.Owner.Functions.FactorProgramNode("*"' parent.Owner'                                                                                    new[]                                                                                        {                                                                                            CreateNumericConst(                                                                                                parent.Owner' 2)'                                                                                            child1                                                                                        });                                  break;                              case '*':                                  parent = parent                                      .Owner                                      .Functions                                      .FactorProgramNode(                                          "^"'                                          parent.Owner'                                          new[]                                              {                                                  child1'                                                  CreateNumericConst(                                                      parent.Owner' 2)                                              });                                  break;                              case '/':                                  parent = CreateNumericConst(parent.Owner' 1);                                  break;                          }
Missing Default,Encog.Neural.SOM.Training.Neighborhood,NeighborhoodRBF,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\SOM\Training\Neighborhood\NeighborhoodRBF.cs,NeighborhoodRBF,The following switch statement is missing a default case: switch (type)              {                  case RBFEnum.Gaussian:                      _rbf = new GaussianFunction(2);                      break;                  case RBFEnum.InverseMultiquadric:                      _rbf = new InverseMultiquadricFunction(2);                      break;                  case RBFEnum.Multiquadric:                      _rbf = new MultiquadricFunction(2);                      break;                  case RBFEnum.MexicanHat:                      _rbf = new MexicanHatFunction(2);                      break;              }
Missing Default,Encog.Neural.SOM.Training.Neighborhood,NeighborhoodRBF,C:\repos\encog_encog-dotnet-core\encog-core-cs\Neural\SOM\Training\Neighborhood\NeighborhoodRBF.cs,NeighborhoodRBF,The following switch statement is missing a default case: switch (type)              {                  case RBFEnum.Gaussian:                      _rbf = new GaussianFunction(2);                      break;                  case RBFEnum.InverseMultiquadric:                      _rbf = new InverseMultiquadricFunction(2);                      break;                  case RBFEnum.Multiquadric:                      _rbf = new MultiquadricFunction(2);                      break;                  case RBFEnum.MexicanHat:                      _rbf = new MexicanHatFunction(2);                      break;              }
Missing Default,Encog.Parse.Expression.Common,RenderCommonExpression,C:\repos\encog_encog-dotnet-core\encog-core-cs\Parse\Expression\Common\RenderCommonExpression.cs,RenderNode,The following switch statement is missing a default case: switch (DetermineNodeType(node))              {                  case ExpressionNodeType.ConstVal:                      result.Append(RenderConst(node));                      break;                  case ExpressionNodeType.Operator:                      result.Append(RenderOperator(node));                      break;                  case ExpressionNodeType.Variable:                      result.Append(RenderVar(node));                      break;                  case ExpressionNodeType.Function:                      result.Append(RenderFunction(node));                      break;              }
Missing Default,Encog.Parse.Expression.Latex,RenderLatexExpression,C:\repos\encog_encog-dotnet-core\encog-core-cs\Parse\Expression\Latex\RenderLatexExpression.cs,RenderNode,The following switch statement is missing a default case: switch (DetermineNodeType(node))              {                  case ExpressionNodeType.ConstVal:                      return HandleConst(node);                  case ExpressionNodeType.Operator:                      return HandleOperator(node);                  case ExpressionNodeType.Variable:                      return HandleVar(node);                  case ExpressionNodeType.Function:                      return HandleFunction(node);              }
