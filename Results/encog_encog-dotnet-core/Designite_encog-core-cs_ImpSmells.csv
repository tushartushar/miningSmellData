Implementation smell,Namespace,Class,File,Method,Description
Long Method,Encog.App.Analyst.Analyze,PerformAnalysis,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Analyze\PerformAnalysis.cs,Process,The method has 114 lines of code.
Long Method,Encog.App.Analyst.Report,AnalystReport,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Report\AnalystReport.cs,ProduceReport,The method has 118 lines of code.
Long Method,Encog.App.Analyst.Script,ScriptLoad,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Script\ScriptLoad.cs,ProcessSubSection,The method has 114 lines of code.
Long Method,Encog.App.Analyst.Wizard,AnalystWizard,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,DetermineTargetField,The method has 104 lines of code.
Long Method,Encog.App.Analyst.Wizard,AnalystWizard,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,GenerateBayesian,The method has 113 lines of code.
Long Method,Encog.MathUtil.LIBSVM,Solver,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,Solve,The method has 221 lines of code.
Long Method,Encog.MathUtil.LIBSVM,svm,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,sigmoid_train,The method has 110 lines of code.
Long Method,Encog.MathUtil.LIBSVM,svm,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_train,The method has 234 lines of code.
Long Method,Encog.MathUtil.LIBSVM,svm,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_load_model,The method has 134 lines of code.
Long Method,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Tred2,The method has 126 lines of code.
Long Method,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Tql2,The method has 115 lines of code.
Long Method,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The method has 472 lines of code.
Long Method,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The method has 473 lines of code.
Long Method,Encog.ML.Data.Market.Loader,CSVFormLoader,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The method has 178 lines of code.
Long Method,Encog.ML.Factory.Method,SVMFactory,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Factory\Method\SVMFactory.cs,Create,The method has 101 lines of code.
Long Method,Encog.ML.Prg,PersistPrgPopulation,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Prg\PersistPrgPopulation.cs,Read,The method has 146 lines of code.
Long Method,Encog.Neural.NEAT,PersistNEATPopulation,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The method has 142 lines of code.
Long Method,Encog.Neural.NEAT.Training.Opp,NEATCrossover,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\Training\Opp\NEATCrossover.cs,PerformOperation,The method has 111 lines of code.
Long Method,Encog.Neural.Networks.Training.NM,NelderMeadTraining,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\NM\NelderMeadTraining.cs,Iteration,The method has 297 lines of code.
Long Method,Encog.Neural.Networks.Training.PNN,DeriveMinimum,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\PNN\DeriveMinimum.cs,Calculate,The method has 172 lines of code.
Long Method,Encog.Neural.Networks.Training.PNN,GlobalMinimumSearch,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\PNN\GlobalMinimumSearch.cs,Brentmin,The method has 171 lines of code.
Long Method,Encog.Neural.Networks.Training.PNN,GlobalMinimumSearch,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\PNN\GlobalMinimumSearch.cs,FindBestRange,The method has 194 lines of code.
Long Method,Encog.Neural.Networks.Training.PNN,TrainBasicPNN,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\PNN\TrainBasicPNN.cs,CalculateError,The method has 127 lines of code.
Long Method,Encog.Neural.Networks.Training.PNN,TrainBasicPNN,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\PNN\TrainBasicPNN.cs,ComputeDeriv,The method has 209 lines of code.
Long Method,Encog.Neural.Networks.Training.Propagation.SCG,ScaledConjugateGradient,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\Propagation\SCG\ScaledConjugateGradient.cs,Iteration,The method has 128 lines of code.
Long Method,Encog.Neural.Rbf,PersistRBFNetwork,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\RBF\PersistRBFNetwork.cs,Read,The method has 119 lines of code.
Long Method,Encog.Neural.RBF.Training,SVD,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\RBF\Training\SVD.cs,Svdcmp,The method has 231 lines of code.
Long Method,Encog.Persist,EncogReadHelper,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Persist\EncogReadHelper.cs,ReadNextSection,The method has 100 lines of code.
Complex Method,Encog.App.Analyst.CSV,EvaluateRawCSV,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\CSV\EvaluateRawCSV.cs,AnalystPrepareOutputFile,Cyclomatic complexity of the method is 8
Complex Method,Encog.App.Analyst.CSV,AnalystEvaluateCSV,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\CSV\AnalystEvaluateCSV.cs,Process,Cyclomatic complexity of the method is 11
Complex Method,Encog.App.Analyst.CSV,AnalystEvaluateRawCSV,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\CSV\AnalystEvaluateRawCSV.cs,AnalystPrepareOutputFile,Cyclomatic complexity of the method is 9
Complex Method,Encog.App.Analyst.Analyze,AnalyzedField,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Analyze\AnalyzedField.cs,Analyze1,Cyclomatic complexity of the method is 8
Complex Method,Encog.App.Analyst.Analyze,PerformAnalysis,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Analyze\PerformAnalysis.cs,Process,Cyclomatic complexity of the method is 25
Complex Method,Encog.App.Analyst.CSV.Basic,BasicCachedFile,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\CSV\Basic\BasicCachedFile.cs,AttemptResolveName,Cyclomatic complexity of the method is 8
Complex Method,Encog.App.Analyst.CSV.Normalize,AnalystNormalizeCSV,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\CSV\Normalize\AnalystNormalizeCSV.cs,ExtractFields,Cyclomatic complexity of the method is 10
Complex Method,Encog.App.Analyst.CSV.Sort,RowComparator,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\CSV\Sort\RowComparator.cs,Compare,Cyclomatic complexity of the method is 8
Complex Method,Encog.App.Analyst.Script,ScriptLoad,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Script\ScriptLoad.cs,HandleDataClasses,Cyclomatic complexity of the method is 10
Complex Method,Encog.App.Analyst.Script,ScriptLoad,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Script\ScriptLoad.cs,HandleNormalizeRange,Cyclomatic complexity of the method is 9
Complex Method,Encog.App.Analyst.Script,ScriptLoad,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Script\ScriptLoad.cs,ProcessSubSection,Cyclomatic complexity of the method is 23
Complex Method,Encog.App.Analyst.Script,ScriptSave,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Script\ScriptSave.cs,SaveNormalize,Cyclomatic complexity of the method is 8
Complex Method,Encog.App.Analyst.Script.Prop,PropertyConstraints,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Script\Prop\PropertyConstraints.cs,PropertyConstraints,Cyclomatic complexity of the method is 9
Complex Method,Encog.App.Analyst.Script.Prop,PropertyEntry,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Script\Prop\PropertyEntry.cs,Validate,Cyclomatic complexity of the method is 10
Complex Method,Encog.App.Analyst.Wizard,AnalystWizard,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,DetermineTargetField,Cyclomatic complexity of the method is 18
Complex Method,Encog.App.Analyst.Wizard,AnalystWizard,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,ExpandTimeSlices,Cyclomatic complexity of the method is 12
Complex Method,Encog.App.Analyst.Wizard,AnalystWizard,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,GenerateBayesian,Cyclomatic complexity of the method is 14
Complex Method,Encog.App.Analyst.Wizard,AnalystWizard,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,generateEPL,Cyclomatic complexity of the method is 9
Complex Method,Encog.App.Analyst.Wizard,AnalystWizard,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,GenerateFilenames,Cyclomatic complexity of the method is 8
Complex Method,Encog.App.Analyst.Wizard,AnalystWizard,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,GenerateGenerate,Cyclomatic complexity of the method is 10
Complex Method,Encog.App.Analyst.Wizard,AnalystWizard,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,GenerateNormalizedFields,Cyclomatic complexity of the method is 8
Complex Method,Encog.App.Analyst.Wizard,AnalystWizard,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,GenerateTasks,Cyclomatic complexity of the method is 11
Complex Method,Encog.App.Generate,EncogCodeGeneration,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Generate\EncogCodeGeneration.cs,Generate,Cyclomatic complexity of the method is 8
Complex Method,Encog.App.Generate.Generators.CS,GenerateCS,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Generate\Generators\CS\GenerateCS.cs,GenerateNode,Cyclomatic complexity of the method is 10
Complex Method,Encog.App.Generate.Generators.Java,GenerateEncogJava,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Generate\Generators\Java\GenerateEncogJava.cs,GenerateNode,Cyclomatic complexity of the method is 10
Complex Method,Encog.App.Generate.Generators.JS,GenerateEncogJavaScript,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Generate\Generators\JS\GenerateEncogJavaScript.cs,GenerateNode,Cyclomatic complexity of the method is 9
Complex Method,Encog.App.Generate.Generators.JS,GenerateEncogJavaScript,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Generate\Generators\JS\GenerateEncogJavaScript.cs,ToSingleLineArray,Cyclomatic complexity of the method is 8
Complex Method,Encog.App.Generate.Generators.MQL4,GenerateMQL4,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Generate\Generators\MQL4\GenerateMQL4.cs,ProcessCalc,Cyclomatic complexity of the method is 9
Complex Method,Encog.App.Generate.Generators.NinjaScript,GenerateNinjaScript,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Generate\Generators\NinjaScript\GenerateNinjaScript.cs,ProcessCalc,Cyclomatic complexity of the method is 9
Complex Method,Encog.App.Quant.Indicators,ProcessIndicators,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Quant\Indicators\ProcessIndicators.cs,WriteCSV,Cyclomatic complexity of the method is 9
Complex Method,Encog.App.Quant.Loader.OpenQuant,DataArray,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Quant\Loader\OpenQuant\BarSeries.cs,GetIndex,Cyclomatic complexity of the method is 8
Complex Method,Encog.Bot.Browse,Browser,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Bot\Browse\Browser.cs,Navigate,Cyclomatic complexity of the method is 8
Complex Method,Encog.Bot.Browse,LoadWebPage,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Bot\Browse\LoadWebPage.cs,LoadContents,Cyclomatic complexity of the method is 16
Complex Method,Encog.MathUtil,Equilateral,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Equilateral.cs,Equilat,Cyclomatic complexity of the method is 9
Complex Method,Encog.MathUtil.LIBSVM,Cache,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,swap_index,Cyclomatic complexity of the method is 10
Complex Method,Encog.MathUtil.LIBSVM,Kernel,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,k_function,Cyclomatic complexity of the method is 10
Complex Method,Encog.MathUtil.LIBSVM,Solver,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,Solve,Cyclomatic complexity of the method is 39
Complex Method,Encog.MathUtil.LIBSVM,Solver,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,select_working_set,Cyclomatic complexity of the method is 12
Complex Method,Encog.MathUtil.LIBSVM,Solver,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,do_shrinking,Cyclomatic complexity of the method is 21
Complex Method,Encog.MathUtil.LIBSVM,Solver_NU,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,select_working_set,Cyclomatic complexity of the method is 13
Complex Method,Encog.MathUtil.LIBSVM,Solver_NU,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,do_shrinking,Cyclomatic complexity of the method is 29
Complex Method,Encog.MathUtil.LIBSVM,Solver_NU,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,calculate_rho,Cyclomatic complexity of the method is 9
Complex Method,Encog.MathUtil.LIBSVM,svm,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_train_one,Cyclomatic complexity of the method is 10
Complex Method,Encog.MathUtil.LIBSVM,svm,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,sigmoid_train,Cyclomatic complexity of the method is 15
Complex Method,Encog.MathUtil.LIBSVM,svm,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,multiclass_probability,Cyclomatic complexity of the method is 13
Complex Method,Encog.MathUtil.LIBSVM,svm,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_binary_svc_probability,Cyclomatic complexity of the method is 15
Complex Method,Encog.MathUtil.LIBSVM,svm,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_train,Cyclomatic complexity of the method is 48
Complex Method,Encog.MathUtil.LIBSVM,svm,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_cross_validation,Cyclomatic complexity of the method is 9
Complex Method,Encog.MathUtil.LIBSVM,svm,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_predict_values,Cyclomatic complexity of the method is 9
Complex Method,Encog.MathUtil.LIBSVM,svm,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_predict,Cyclomatic complexity of the method is 9
Complex Method,Encog.MathUtil.LIBSVM,svm,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_save_model,Cyclomatic complexity of the method is 16
Complex Method,Encog.MathUtil.LIBSVM,svm,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_load_model,Cyclomatic complexity of the method is 30
Complex Method,Encog.MathUtil.LIBSVM,svm,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_check_parameter,Cyclomatic complexity of the method is 23
Complex Method,Encog.MathUtil.Matrices.Decomposition,CholeskyDecomposition,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\CholeskyDecomposition.cs,Solve,Cyclomatic complexity of the method is 9
Complex Method,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,EigenvalueDecomposition,Cyclomatic complexity of the method is 8
Complex Method,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Tred2,Cyclomatic complexity of the method is 23
Complex Method,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Tql2,Cyclomatic complexity of the method is 11
Complex Method,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Orthes,Cyclomatic complexity of the method is 20
Complex Method,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,Cyclomatic complexity of the method is 69
Complex Method,Encog.MathUtil.Matrices.Decomposition,LUDecomposition,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\LUDecomposition.cs,LUDecomposition,Cyclomatic complexity of the method is 12
Complex Method,Encog.MathUtil.Matrices.Decomposition,LUDecomposition,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\LUDecomposition.cs,Solve,Cyclomatic complexity of the method is 10
Complex Method,Encog.MathUtil.Matrices.Decomposition,LUDecomposition,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\LUDecomposition.cs,Solve,Cyclomatic complexity of the method is 9
Complex Method,Encog.MathUtil.Matrices.Decomposition,LUDecomposition,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\LUDecomposition.cs,Inverse,Cyclomatic complexity of the method is 10
Complex Method,Encog.MathUtil.Matrices.Decomposition,QRDecomposition,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\QRDecomposition.cs,QRDecomposition,Cyclomatic complexity of the method is 9
Complex Method,Encog.MathUtil.Matrices.Decomposition,QRDecomposition,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\QRDecomposition.cs,Solve,Cyclomatic complexity of the method is 11
Complex Method,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,Cyclomatic complexity of the method is 84
Complex Method,Encog.MathUtil.Randomize,RandomChoice,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\RandomChoice.cs,Generate,Cyclomatic complexity of the method is 9
Complex Method,Encog.ML.Bayesian,BayesianNetwork,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Bayesian\BayesianNetwork.cs,IsCondIndependent,Cyclomatic complexity of the method is 9
Complex Method,Encog.ML.Bayesian,PersistBayes,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Bayesian\PersistBayes.cs,Read,Cyclomatic complexity of the method is 10
Complex Method,Encog.ML.Bayesian,PersistBayes,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Bayesian\PersistBayes.cs,Save,Cyclomatic complexity of the method is 12
Complex Method,Encog.ML.Bayesian.Parse,ParseProbability,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Bayesian\Parse\ParseProbability.cs,AddEvents,Cyclomatic complexity of the method is 15
Complex Method,Encog.ML.Bayesian.Training.Estimator,SimpleEstimator,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Bayesian\Training\Estimator\SimpleEstimator.cs,CalculateProbability,Cyclomatic complexity of the method is 8
Complex Method,Encog.ML.Data.Versatile,VersatileMLDataSet,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Versatile\VersatileMLDataSet.cs,Analyze,Cyclomatic complexity of the method is 10
Complex Method,Encog.ML.EA.Species,ThresholdSpeciation,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\EA\Species\ThresholdSpeciation.cs,SpeciateAndCalculateSpawnLevels,Cyclomatic complexity of the method is 10
Complex Method,Encog.ML.EA.Train,BasicEA,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\EA\Train\BasicEA.cs,Iteration,Cyclomatic complexity of the method is 12
Complex Method,Encog.ML.Factory.Method,SVMFactory,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Factory\Method\SVMFactory.cs,Create,Cyclomatic complexity of the method is 16
Complex Method,Encog.ML.Factory.Train,NeighborhoodSOMFactory,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Factory\Train\NeighborhoodSOMFactory.cs,Create,Cyclomatic complexity of the method is 11
Complex Method,Encog.ML.Factory.Train,TrainBayesianFactory,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Factory\Train\TrainBayesianFactory.cs,Create,Cyclomatic complexity of the method is 8
Complex Method,Encog.ML.HMM.Alog,ViterbiCalculator,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\HMM\Alog\ViterbiCalculator.cs,ViterbiCalculator,Cyclomatic complexity of the method is 8
Complex Method,Encog.ML.HMM.Distributions,ContinousDistribution,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\HMM\Distributions\ContinousDistribution.cs,Fit,Cyclomatic complexity of the method is 8
Complex Method,Encog.ML.HMM,PersistHMM,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\HMM\PersistHMM.cs,Read,Cyclomatic complexity of the method is 9
Complex Method,Encog.ML.HMM.Train.BW,BaseBaumWelch,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\HMM\Train\BW\BaseBaumWelch.cs,Iteration,Cyclomatic complexity of the method is 17
Complex Method,Encog.ML.HMM.Train.KMeans,TrainKMeans,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\HMM\Train\KMeans\TrainKMeans.cs,LearnTransition,Cyclomatic complexity of the method is 11
Complex Method,Encog.ML.Prg,EncogProgram,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Prg\EncogProgram.cs,Compute,Cyclomatic complexity of the method is 12
Complex Method,Encog.ML.Prg,PersistPrgPopulation,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Prg\PersistPrgPopulation.cs,Read,Cyclomatic complexity of the method is 24
Complex Method,Encog.ML.Prg.Ext,BasicTemplate,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Prg\Ext\BasicTemplate.cs,BasicTemplate,Cyclomatic complexity of the method is 8
Complex Method,Encog.ML.Prg.Ext,BasicTemplate,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Prg\Ext\BasicTemplate.cs,ReadParam,Cyclomatic complexity of the method is 8
Complex Method,Encog.ML.Prg.Train.Rewrite,RewriteAlgebraic,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Prg\Train\Rewrite\RewriteAlgebraic.cs,TryPlusNeg,Cyclomatic complexity of the method is 8
Complex Method,Encog.Neural.CPN,CPNNetwork,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\CPN\CPN.cs,ComputeInstar,Cyclomatic complexity of the method is 8
Complex Method,Encog.Neural.Freeform,FreeformNetwork,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Freeform\FreeformNetwork.cs,FreeformNetwork,Cyclomatic complexity of the method is 8
Complex Method,Encog.Neural.HyperNEAT,HyperNEATCODEC,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\HyperNEAT\HyperNEATCODEC.cs,Decode,Cyclomatic complexity of the method is 10
Complex Method,Encog.Neural.NEAT,PersistNEATPopulation,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,Cyclomatic complexity of the method is 16
Complex Method,Encog.Neural.NEAT.Training.Opp,NEATCrossover,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\Training\Opp\NEATCrossover.cs,PerformOperation,Cyclomatic complexity of the method is 17
Complex Method,Encog.Neural.Networks.Structure,AnalyzeNetwork,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Structure\AnalyzeNetwork.cs,AnalyzeNetwork,Cyclomatic complexity of the method is 10
Complex Method,Encog.Neural.Networks.Training.NM,NelderMeadTraining,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\NM\NelderMeadTraining.cs,Iteration,Cyclomatic complexity of the method is 46
Complex Method,Encog.Neural.Networks.Training.PNN,DeriveMinimum,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\PNN\DeriveMinimum.cs,Calculate,Cyclomatic complexity of the method is 30
Complex Method,Encog.Neural.Networks.Training.PNN,GlobalMinimumSearch,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\PNN\GlobalMinimumSearch.cs,Brentmin,Cyclomatic complexity of the method is 18
Complex Method,Encog.Neural.Networks.Training.PNN,GlobalMinimumSearch,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\PNN\GlobalMinimumSearch.cs,FindBestRange,Cyclomatic complexity of the method is 21
Complex Method,Encog.Neural.Networks.Training.PNN,TrainBasicPNN,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\PNN\TrainBasicPNN.cs,CalculateError,Cyclomatic complexity of the method is 23
Complex Method,Encog.Neural.Networks.Training.PNN,TrainBasicPNN,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\PNN\TrainBasicPNN.cs,ComputeDeriv,Cyclomatic complexity of the method is 35
Complex Method,Encog.Neural.Networks.Training.Propagation.SCG,ScaledConjugateGradient,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\Propagation\SCG\ScaledConjugateGradient.cs,Iteration,Cyclomatic complexity of the method is 14
Complex Method,Encog.Neural.PNN,BasicPNN,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\PNN\BasicPNN.cs,Compute,Cyclomatic complexity of the method is 21
Complex Method,Encog.Neural.Pnn,PersistBasicPNN,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\PNN\PersistBasicPNN.cs,Read,Cyclomatic complexity of the method is 9
Complex Method,Encog.Neural.Prune,PruneIncremental,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Prune\PruneIncremental.cs,PerformJobUnit,Cyclomatic complexity of the method is 10
Complex Method,Encog.Neural.Prune,PruneIncremental,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Prune\PruneIncremental.cs,UpdateBest,Cyclomatic complexity of the method is 11
Complex Method,Encog.Neural.Prune,PruneSelective,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Prune\PruneSelective.cs,IncreaseNeuronCount,Cyclomatic complexity of the method is 11
Complex Method,Encog.Neural.Prune,PruneSelective,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Prune\PruneSelective.cs,Prune,Cyclomatic complexity of the method is 10
Complex Method,Encog.Neural.Prune,PruneSelective,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Prune\PruneSelective.cs,RandomizeNeuron,Cyclomatic complexity of the method is 8
Complex Method,Encog.Neural.Rbf,PersistRBFNetwork,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\RBF\PersistRBFNetwork.cs,Read,Cyclomatic complexity of the method is 10
Complex Method,Encog.Neural.RBF.Training,SVD,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\RBF\Training\SVD.cs,Svdfit,Cyclomatic complexity of the method is 10
Complex Method,Encog.Neural.RBF.Training,SVD,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\RBF\Training\SVD.cs,Svdcmp,Cyclomatic complexity of the method is 52
Complex Method,Encog.Parse.Expression.Common,ParseCommonExpression,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Parse\Expression\Common\ParseCommonExpression.cs,HandleNumeric,Cyclomatic complexity of the method is 11
Complex Method,Encog.Parse.Expression.Common,ParseCommonExpression,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Parse\Expression\Common\ParseCommonExpression.cs,handleAlpha,Cyclomatic complexity of the method is 10
Complex Method,Encog.Parse.Expression.Common,ParseCommonExpression,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Parse\Expression\Common\ParseCommonExpression.cs,Parse,Cyclomatic complexity of the method is 11
Complex Method,Encog.Parse.Expression.EPL,ParseEPL,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Parse\Expression\EPL\ParseEPL.cs,Parse,Cyclomatic complexity of the method is 12
Complex Method,Encog.Parse.Expression.EPL,RenderEPL,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Parse\Expression\EPL\RenderEPL.cs,RenderNode,Cyclomatic complexity of the method is 8
Complex Method,Encog.Persist,EncogReadHelper,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Persist\EncogReadHelper.cs,ReadNextSection,Cyclomatic complexity of the method is 14
Complex Method,Encog.ML.SVM,SupportVectorMachine,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\SVM\SupportVectorMachine.cs,SupportVectorMachine,Cyclomatic complexity of the method is 10
Complex Method,Encog.ML.SVM.Training,SVMSearchTrain,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\SVM\Training\SVMSearchTrain.cs,Iteration,Cyclomatic complexity of the method is 8
Complex Method,Encog.Plugin.SystemPlugin,SystemActivationPlugin,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Plugin\SystemPlugin\SystemActivationPlugin.cs,AllocateAF,Cyclomatic complexity of the method is 13
Complex Method,Encog.Plugin.SystemPlugin,SystemLoggingPlugin,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Plugin\SystemPlugin\SystemLoggingPlugin.cs,Log,Cyclomatic complexity of the method is 8
Complex Method,Encog.Plugin.SystemPlugin,SystemMethodsPlugin,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Plugin\SystemPlugin\SystemMethodsPlugin.cs,CreateMethod,Cyclomatic complexity of the method is 9
Complex Method,Encog.Plugin.SystemPlugin,SystemTrainingPlugin,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Plugin\SystemPlugin\SystemTrainingPlugin.cs,CreateTraining,Cyclomatic complexity of the method is 21
Complex Method,Encog.Util.CSV,ParseCSVLine,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\CSV\ParseCSVLine.cs,ParseCharSep,Cyclomatic complexity of the method is 8
Complex Method,Encog.Util.KMeans,KMeansUtil<TK>,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\KMeans\KMeansUtil.cs,InitRandomClusters,Cyclomatic complexity of the method is 8
Complex Method,Encog.Util.Normalize,DataNormalization,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Normalize\DataNormalization.cs,BuildForNetworkInput,Cyclomatic complexity of the method is 10
Complex Method,Encog.Util.Time,NumericDateUtil,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Time\NumericDateUtil.cs,GetDayOfWeek,Cyclomatic complexity of the method is 8
Complex Method,Encog.Util.Time,EnglishTimeUnitNames,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Time\EnglishTimeUnitNames.cs,Code,Cyclomatic complexity of the method is 13
Complex Method,Encog.Util.Time,EnglishTimeUnitNames,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Time\EnglishTimeUnitNames.cs,Plural,Cyclomatic complexity of the method is 13
Complex Method,Encog.Util.Time,EnglishTimeUnitNames,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Time\EnglishTimeUnitNames.cs,Singular,Cyclomatic complexity of the method is 13
Complex Method,Encog.Util.Time,TimeSpanUtil,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Time\TimeSpanUtil.cs,GetSpan,Cyclomatic complexity of the method is 13
Complex Method,Encog.Parse.Tags.Read,ReadTags,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Parse\Tags\Read\ReadTags.cs,ParseTag,Cyclomatic complexity of the method is 15
Complex Method,Encog.Parse.Tags.Read,ReadTags,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Parse\Tags\Read\ReadTags.cs,PeekEndTag,Cyclomatic complexity of the method is 8
Complex Method,Encog.Util.DownSample,RGBDownsample,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\DownSample\RGBDownsample.cs,FindBounds,Cyclomatic complexity of the method is 9
Complex Method,Encog.Util.HTTP,URLUtility,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\HTTP\URLUtility.cs,ConvertFilename,Cyclomatic complexity of the method is 9
Long Parameter List,Encog.App.Analyst.CSV.Normalize,AnalystNormalizeCSV,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\CSV\Normalize\AnalystNormalizeCSV.cs,ExtractFields,The method has 5 parameters. Parameters: analyst' headers' csv' outputLength' skipOutput
Long Parameter List,Encog.App.Analyst.Script.Normalize,AnalystField,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Script\Normalize\AnalystField.cs,AnalystField,The method has 6 parameters. Parameters: theAction' theName' ahigh' alow' nhigh' nlow
Long Parameter List,Encog.App.Analyst.Script.Normalize,AnalystField,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Script\Normalize\AnalystField.cs,MakeClass,The method has 5 parameters. Parameters: theAction' classFrom' classTo' high' low
Long Parameter List,Encog.App.Analyst.Wizard,AnalystWizard,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,Wizard,The method has 5 parameters. Parameters: url' saveFile' analyzeFile' b' format
Long Parameter List,Encog.App.Analyst.Wizard,AnalystWizard,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,WizardRealTime,The method has 6 parameters. Parameters: sourceData' csvFile' backwardWindow' forwardWindow' prediction' predictField
Long Parameter List,Encog.App.Quant.Loader.OpenQuant.Data,Bar,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Quant\Loader\OpenQuant\Bar.cs,Bar,The method has 10 parameters. Parameters: barType' size' beginTime' endTime' open' high' low' close' volume' openInt
Long Parameter List,Encog.App.Quant.Loader.OpenQuant.Data,Bar,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Quant\Loader\OpenQuant\Bar.cs,Bar,The method has 5 parameters. Parameters: size' open' high' low' close
Long Parameter List,Encog.App.Quant.Loader.OpenQuant,OpenQuantLoader,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Quant\Loader\OpenQuant\OpenQuantLoader.cs,OpenquantDataLoader,The method has 5 parameters. Parameters: instrument' dtfrom' dtto' bartype' barsize
Long Parameter List,Encog.App.Quant.Loader.OpenQuant,LoaderTypes,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Quant\Loader\OpenQuant\OpenQuantLoader.cs,LoaderTypes,The method has 5 parameters. Parameters: instrument' StartingDate' ToDate' Type' SizeOfBars
Long Parameter List,Encog.App.Quant.Loader.Yahoo,YahooDownload,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Quant\Loader\Yahoo\YahooDownload.cs,LoadAllData,The method has 5 parameters. Parameters: ticker' output' outputFormat' from' to
Long Parameter List,Encog.Bot,BotUtil,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Bot\BotUtil.cs,ExtractFromIndex,The method has 5 parameters. Parameters: str' token1' token2' index' occurence
Long Parameter List,Encog.MathUtil.LIBSVM,Solver,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,Solve,The method has 10 parameters. Parameters: l' Q' b_' y_' alpha_' Cp' Cn' eps' si' shrinking
Long Parameter List,Encog.MathUtil.LIBSVM,Solver_NU,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,Solve,The method has 10 parameters. Parameters: l' Q' b' y' alpha' Cp' Cn' eps' si' shrinking
Long Parameter List,Encog.MathUtil.LIBSVM,svm,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,solve_c_svc,The method has 6 parameters. Parameters: prob' param' alpha' si' Cp' Cn
Long Parameter List,Encog.MathUtil.LIBSVM,svm,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_binary_svc_probability,The method has 5 parameters. Parameters: prob' param' Cp' Cn' probAB
Long Parameter List,Encog.MathUtil.Matrices,Matrix,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Matrix.cs,SetMatrix,The method has 5 parameters. Parameters: i0' i1' j0' j1' x
Long Parameter List,Encog.MathUtil.Matrices.Hessian,HessianFD,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Hessian\HessianFD.cs,ComputeDerivative,The method has 6 parameters. Parameters: inputData' outputNeuron' weight' stepSize' networkOutput' row
Long Parameter List,Encog.ML.Bayesian,BayesianNetwork,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Bayesian\BayesianNetwork.cs,IsCondIndependent,The method has 5 parameters. Parameters: previousHead' a' goal' searched' given
Long Parameter List,Encog.ML.Bayesian.Training,TrainBayesian,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Bayesian\Training\TrainBayesian.cs,TrainBayesian,The method has 6 parameters. Parameters: theNetwork' theData' theMaximumParents' theInit' theSearch' theEstimator
Long Parameter List,Encog.ML.Bayesian.Training.Search.k2,SearchK2,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Bayesian\Training\Search\k2\SearchK2.cs,CalculateN,The method has 5 parameters. Parameters: network' e' parents' parentInstance' desiredValue
Long Parameter List,Encog.ML.Data.Buffer.CODEC,CSVDataCODEC,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Buffer\CODEC\CSVDataCODEC.cs,CSVDataCODEC,The method has 6 parameters. Parameters: file' format' headers' inputCount' idealCount' significance
Long Parameter List,Encog.ML.Data.Dynamic,SlidingWindowMLDataProvider,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Dynamic\Providers\SlidingWindowMLDataProvider.cs,SlidingWindowMLDataProvider,The method has 5 parameters. Parameters: list' windowSize' windowOffset' stepSize' gap
Long Parameter List,Encog.ML.Data.Image,ImageMLData,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Image\ImageMLData.cs,Downsample,The method has 6 parameters. Parameters: downsampler' findBounds' height' width' hi' lo
Long Parameter List,Encog.ML.Data.Market.Loader,CSVFinal,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFinal.cs,ReadAndCallLoader,The method has 5 parameters. Parameters: symbol' neededTypes' from' to' File
Long Parameter List,Encog.ML.Data.Market.Loader,CSVLoader,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVLoader.cs,ReadAndCallLoader,The method has 5 parameters. Parameters: symbol' neededTypes' from' to' File
Long Parameter List,Encog.ML.Data.Market,MarketDataDescription,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\MarketDataDescription.cs,MarketDataDescription,The method has 6 parameters. Parameters: ticker' dataType' type' activationFunction' input' predict
Long Parameter List,Encog.ML.Data.Market,MarketDataDescription,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\MarketDataDescription.cs,MarketDataDescription,The method has 5 parameters. Parameters: ticker' dataType' type' input' predict
Long Parameter List,Encog.ML.Data.Specific,CSVMLDataSet,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Specific\CSVMLDataSet.cs,CSVMLDataSet,The method has 6 parameters. Parameters: filename' inputSize' idealSize' headers' format' expectSignificance
Long Parameter List,Encog.ML.Data.Temporal,TemporalDataDescription,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Temporal\TemporalDataDescription.cs,TemporalDataDescription,The method has 6 parameters. Parameters: activationFunction' low' high' type' input' predict
Long Parameter List,Encog.ML.Data.Versatile,NormalizationHelper,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Versatile\NormalizationHelper.cs,NormalizeToVector,The method has 5 parameters. Parameters: colDef' outputColumn' output' isInput' value
Long Parameter List,Encog.ML.Data.Versatile.Normalizers.Strategy,BasicNormalizationStrategy,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Versatile\Normalizers\Strategy\BasicNormalizationStrategy.cs,NormalizeColumn,The method has 5 parameters. Parameters: colDef' isInput' value' outputData' outputColumn
Long Parameter List,Encog.ML.Data.Versatile.Normalizers.Strategy,BasicNormalizationStrategy,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Versatile\Normalizers\Strategy\BasicNormalizationStrategy.cs,NormalizeColumn,The method has 5 parameters. Parameters: colDef' isInput' value' outputData' outputColumn
Long Parameter List,Encog.ML.Data.Versatile.Normalizers.Strategy,INormalizationStrategy,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Versatile\Normalizers\Strategy\INormalizationStrategy.cs,NormalizeColumn,The method has 5 parameters. Parameters: colDef' isInput' value' outpuData' outputColumn
Long Parameter List,Encog.ML.Data.Versatile.Normalizers.Strategy,INormalizationStrategy,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Versatile\Normalizers\Strategy\INormalizationStrategy.cs,NormalizeColumn,The method has 5 parameters. Parameters: colDef' isInput' value' outpuData' outputColumn
Long Parameter List,Encog.ML.EA.Opp,CompoundOperator,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\EA\Opp\CompoundOperator.cs,PerformOperation,The method has 5 parameters. Parameters: rnd' parents' parentIndex' offspring' offspringIndex
Long Parameter List,Encog.ML.EA.Opp,IEvolutionaryOperator,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\EA\Opp\IEvolutionaryOperator.cs,PerformOperation,The method has 5 parameters. Parameters: rnd' parents' parentIndex' offspring' offspringIndex
Long Parameter List,Encog.ML.EA.Score.Multi,ParallelScore,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\EA\Score\Multi\ParallelScore.cs,ParallelScore,The method has 5 parameters. Parameters: thePopulation' theCODEC' theAdjusters' theScoreFunction' theThreadCount
Long Parameter List,Encog.ML.Genetic.Crossover,Splice,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Genetic\Crossover\Splice.cs,PerformOperation,The method has 5 parameters. Parameters: rnd' parents' parentIndex' offspring' offspringIndex
Long Parameter List,Encog.ML.Genetic.Crossover,SpliceNoRepeat,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Genetic\Crossover\SpliceNoRepeat.cs,PerformOperation,The method has 5 parameters. Parameters: rnd' parents' parentIndex' offspring' offspringIndex
Long Parameter List,Encog.ML.Genetic.Mutate,MutatePerturb,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Genetic\Mutate\MutatePerturb.cs,PerformOperation,The method has 5 parameters. Parameters: rnd' parents' parentIndex' offspring' offspringIndex
Long Parameter List,Encog.ML.Genetic.Mutate,MutateShuffle,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Genetic\Mutate\MutateShuffle.cs,PerformOperation,The method has 5 parameters. Parameters: rnd' parents' parentIndex' offspring' offspringIndex
Long Parameter List,Encog.ML.Model,EncogModel,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Model\EncogModel.cs,SelectMethod,The method has 5 parameters. Parameters: dataset' methodType' methodArgs' trainingType' trainingArgs
Long Parameter List,Encog.ML.Prg.Ext,BasicTemplate,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Prg\Ext\BasicTemplate.cs,BasicTemplate,The method has 8 parameters. Parameters: thePrecedence' theSignature' theType' isVariable' theDataSize' theEvaluate' theIsPossibleReturnType' theRandomize
Long Parameter List,Encog.ML.Prg.Ext,BasicTemplate,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Prg\Ext\BasicTemplate.cs,Randomize,The method has 5 parameters. Parameters: rnd' desiredType' actual' minValue' maxValue
Long Parameter List,Encog.ML.Prg.Ext,IProgramExtensionTemplate,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Prg\Ext\IProgramExtensionTemplate.cs,Randomize,The method has 5 parameters. Parameters: rnd' desiredType' actual' minValue' maxValue
Long Parameter List,Encog.ML.Prg.Generator,AbstractPrgGenerator,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Prg\Generator\AbstractPrgGenerator.cs,CreateRandomNode,The method has 6 parameters. Parameters: rnd' program' depthRemaining' types' includeTerminal' includeFunction
Long Parameter List,Encog.ML.Prg.Opp,ConstMutation,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Prg\Opp\ConstMutation.cs,PerformOperation,The method has 5 parameters. Parameters: rnd' parents' parentIndex' offspring' offspringIndex
Long Parameter List,Encog.ML.Prg.Opp,SubtreeCrossover,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Prg\Opp\SubtreeCrossover.cs,PerformOperation,The method has 5 parameters. Parameters: rnd' parents' parentIndex' offspring' offspringIndex
Long Parameter List,Encog.ML.Prg.Opp,SubtreeMutation,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Prg\Opp\SubtreeMutation.cs,PerformOperation,The method has 5 parameters. Parameters: rnd' parents' parentIndex' offspring' offspringIndex
Long Parameter List,Encog.ML.Prg.Opp,SubtreeMutation,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Prg\Opp\SubtreeMutation.cs,FindNode,The method has 5 parameters. Parameters: rnd' result' parentNode' types' globalIndex
Long Parameter List,Encog.ML.Train.Strategy,EarlyStoppingStrategy,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Train\Strategy\EarlyStoppingStrategy.cs,EarlyStoppingStrategy,The method has 5 parameters. Parameters: theValidationSet' theTestSet' theStripLength' theAlpha' theMinEfficiency
Long Parameter List,Encog.Neural.Error,ATanErrorFunction,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Error\ATanErrorFunction.cs,CalculateError,The method has 8 parameters. Parameters: af' b' a' ideal' actual' error' derivShift' significance
Long Parameter List,Encog.Neural.Error,CrossEntropyErrorFunction,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Error\CrossEntropyErrorFunction.cs,CalculateError,The method has 8 parameters. Parameters: af' b' a' ideal' actual' error' derivShift' significance
Long Parameter List,Encog.Neural.Error,IErrorFunction,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Error\IErrorFunction.cs,CalculateError,The method has 8 parameters. Parameters: af' b' a' ideal' actual' error' derivShift' significance
Long Parameter List,Encog.Neural.Error,LinearErrorFunction,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Error\LinearErrorFunction.cs,CalculateError,The method has 8 parameters. Parameters: af' b' a' ideal' actual' error' derivShift' significance
Long Parameter List,Encog.Neural.Error,OutputErrorFunction,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Error\OutputErrorFunction.cs,CalculateError,The method has 8 parameters. Parameters: af' b' a' ideal' actual' error' derivShift' significance
Long Parameter List,Encog.Neural.Flat,FlatNetwork,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Flat\FlatNetwork.cs,FlatNetwork,The method has 5 parameters. Parameters: input' hidden1' hidden2' output' tanh
Long Parameter List,Encog.Neural.Freeform,FreeformNetwork,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Freeform\FreeformNetwork.cs,CreateFeedforward,The method has 5 parameters. Parameters: input' hidden1' hidden2' output' af
Long Parameter List,Encog.Neural.Freeform,FreeformNetwork,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Freeform\FreeformNetwork.cs,ConnectLayers,The method has 5 parameters. Parameters: source' target' theActivationFunction' biasActivation' isRecurrent
Long Parameter List,Encog.Neural.HyperNEAT,FactorHyperNEATGenome,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\HyperNEAT\FactorHyperNEATGenome.cs,Factor,The method has 5 parameters. Parameters: rnd' pop' inputCount' outputCount' connectionDensity
Long Parameter List,Encog.Neural.HyperNEAT,HyperNEATGenome,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\HyperNEAT\HyperNEATGenome.cs,HyperNEATGenome,The method has 5 parameters. Parameters: rnd' pop' inputCount' outputCount' connectionDensity
Long Parameter List,Encog.Neural.NEAT,FactorNEATGenome,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\FactorNEATGenome.cs,Factor,The method has 5 parameters. Parameters: rnd' pop' inputCount' outputCount' connectionDensity
Long Parameter List,Encog.Neural.NEAT,INEATGenomeFactory,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\INEATGenomeFactory.cs,Factor,The method has 5 parameters. Parameters: rnd' pop' inputCount' outputCount' connectionDensity
Long Parameter List,Encog.Neural.NEAT.Training,NEATGenome,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\Training\NEATGenome.cs,NEATGenome,The method has 5 parameters. Parameters: rnd' pop' inputCount' outputCount' connectionDensity
Long Parameter List,Encog.Neural.NEAT.Training,NEATLinkGene,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\Training\NEATLinkGene.cs,NEATLinkGene,The method has 5 parameters. Parameters: fromNeuronId' toNeuronId' enabled' innovationId' weight
Long Parameter List,Encog.Neural.NEAT.Training.Opp,NEATCrossover,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\Training\Opp\NEATCrossover.cs,PerformOperation,The method has 5 parameters. Parameters: rnd' parents' parentIndex' offspring' offspringIndex
Long Parameter List,Encog.Neural.NEAT.Training.Opp,NEATMutateAddLink,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\Training\Opp\NEATMutateAddLink.cs,PerformOperation,The method has 5 parameters. Parameters: rnd' parents' parentIndex' offspring' offspringIndex
Long Parameter List,Encog.Neural.NEAT.Training.Opp,NEATMutateAddNode,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\Training\Opp\NEATMutateAddNode.cs,PerformOperation,The method has 5 parameters. Parameters: rnd' parents' parentIndex' offspring' offspringIndex
Long Parameter List,Encog.Neural.NEAT.Training.Opp,NEATMutateRemoveLink,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\Training\Opp\NEATMutateRemoveLink.cs,PerformOperation,The method has 5 parameters. Parameters: rnd' parents' parentIndex' offspring' offspringIndex
Long Parameter List,Encog.Neural.NEAT.Training.Opp,NEATMutateWeights,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\Training\Opp\NEATMutateWeights.cs,PerformOperation,The method has 5 parameters. Parameters: rnd' parents' parentIndex' offspring' offspringIndex
Long Parameter List,Encog.Neural.NEAT.Training.Opp,NEATMutation,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\Training\Opp\NEATMutation.cs,PerformOperation,The method has 5 parameters. Parameters: rnd' parents' parentIndex' offspring' offspringIndex
Long Parameter List,Encog.Neural.Networks.Training.Anneal,NeuralSimulatedAnnealing,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\Anneal\NeuralSimulatedAnnealing.cs,NeuralSimulatedAnnealing,The method has 5 parameters. Parameters: network' calculateScore' startTemp' stopTemp' cycles
Long Parameter List,Encog.Neural.Networks.Training.PNN,DeriveMinimum,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\PNN\DeriveMinimum.cs,Calculate,The method has 13 parameters. Parameters: maxIterations' maxError' eps' tol' network' n' x' ystart' bs' direc' g' h' deriv2
Long Parameter List,Encog.Neural.Networks.Training.PNN,DeriveMinimum,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\PNN\DeriveMinimum.cs,FindNewDir,The method has 5 parameters. Parameters: n' gam' g' h' grad
Long Parameter List,Encog.Neural.Networks.Training.PNN,GlobalMinimumSearch,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\PNN\GlobalMinimumSearch.cs,Brentmin,The method has 6 parameters. Parameters: maxIterations' maxError' eps' tol' network' y
Long Parameter List,Encog.Neural.Networks.Training.PNN,GlobalMinimumSearch,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\PNN\GlobalMinimumSearch.cs,FindBestRange,The method has 6 parameters. Parameters: low' high' numberOfPoints' useLog' minError' network
Long Parameter List,Encog.Neural.Networks.Training.Propagation,GradientWorker,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\Propagation\GradientWorker.cs,GradientWorker,The method has 7 parameters. Parameters: theNetwork' theOwner' theTraining' theLow' theHigh' theFlatSpots' ef
Long Parameter List,Encog.Neural.Prune,PruneIncremental,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Prune\PruneIncremental.cs,PruneIncremental,The method has 6 parameters. Parameters: training' pattern' iterations' weightTries' numTopResults' report
Long Parameter List,Encog.Neural.Prune,PruneSelective,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Prune\PruneSelective.cs,RandomizeNeuron,The method has 7 parameters. Parameters: targetLayer' neuron' useRange' low' high' usePercent' percent
Long Parameter List,Encog.Neural.RBF,RBFNetwork,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\RBF\RBFNetwork.cs,SetRBFCentersAndWidthsEqualSpacing,The method has 5 parameters. Parameters: minPosition' maxPosition' t' volumeNeuronRBFWidth' useWideEdgeRBFs
Long Parameter List,Encog.Neural.RBF.Training,SVD,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\RBF\Training\SVD.cs,Svdbksb,The method has 5 parameters. Parameters: u' w' v' b' x
Long Parameter List,Encog.Neural.SOM.Training.Neighborhood,BasicTrainSOM,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\SOM\Training\Neighborhood\BasicTrainSOM.cs,SetAutoDecay,The method has 5 parameters. Parameters: plannedIterations' startRate' endRate' startRadius' endRadius
Long Parameter List,Encog.Plugin.SystemPlugin,SystemLoggingPlugin,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Plugin\SystemPlugin\SystemLoggingPlugin.cs,CalculateGradient,The method has 10 parameters. Parameters: gradients' layerOutput' weights' layerDelta' af' index' fromLayerIndex' fromLayerSize' toLayerIndex' toLayerSize
Long Parameter List,Encog.Plugin.SystemPlugin,SystemLoggingPlugin,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Plugin\SystemPlugin\SystemLoggingPlugin.cs,CalculateLayer,The method has 7 parameters. Parameters: weights' layerOutput' startIndex' outputIndex' outputSize' inputIndex' inputSize
Long Parameter List,Encog.Util.Arrayutil,NormalizedField,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Arrayutil\NormalizedField.cs,NormalizedField,The method has 6 parameters. Parameters: theAction' theName' ahigh' alow' nhigh' nlow
Long Parameter List,Encog.Util.Arrayutil,NormalizedField,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Arrayutil\NormalizedField.cs,MakeClass,The method has 5 parameters. Parameters: theAction' classFrom' classTo' high' low
Long Parameter List,Encog.Util.Banchmark,EncoderTrainingFactory,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Banchmark\EncoderTrainingFactory.cs,GenerateTraining,The method has 6 parameters. Parameters: inputCount' compl' inputMin' inputMax' outputMin' outputMax
Long Parameter List,Encog.Util.Banchmark,RandomTrainingFactory,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Banchmark\RandomTrainingFactory.cs,Generate,The method has 6 parameters. Parameters: seed' count' inputCount' idealCount' min' max
Long Parameter List,Encog.Util.Banchmark,RandomTrainingFactory,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Banchmark\RandomTrainingFactory.cs,Generate,The method has 5 parameters. Parameters: training' seed' count' min' max
Long Parameter List,Encog.Util,EngineArray,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\EngineArray.cs,ArrayCopy,The method has 5 parameters. Parameters: source' sourceIndex' output' targetIndex' size
Long Parameter List,Encog.Util,EngineArray,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\EngineArray.cs,ArrayCopy,The method has 5 parameters. Parameters: source' sourcePos' target' targetPos' length
Long Parameter List,Encog.Util,EngineArray,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\EngineArray.cs,ArrayCopy,The method has 5 parameters. Parameters: source' sourcePos' target' targetPos' length
Long Parameter List,Encog.Util.Normalize.Output,BasicOutputField,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Normalize\Output\BasicOutputField.cs,Calculate,The method has 5 parameters. Parameters: value' min' max' hi' lo
Long Parameter List,Encog.Util.Simple,TrainingSetUtil,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\TrainingSetUtil.cs,LoadCSVTOMemory,The method has 5 parameters. Parameters: format' filename' headers' inputSize' idealSize
Long Parameter List,Encog.Util.Simple,EncogUtility,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\EncogUtility.cs,ConvertCSV2Binary,The method has 7 parameters. Parameters: csvFile' format' binFile' inputCount' outputCount' headers' expectSignificance
Long Parameter List,Encog.Util.Simple,EncogUtility,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\EncogUtility.cs,ConvertCSV2Binary,The method has 6 parameters. Parameters: csvFile' format' binFile' input' ideal' headers
Long Parameter List,Encog.Util.Simple,EncogUtility,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\EncogUtility.cs,LoadCSV2Memory,The method has 6 parameters. Parameters: filename' input' ideal' headers' format' expectSignificance
Long Parameter List,Encog.Util.Simple,EncogUtility,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\EncogUtility.cs,SimpleFeedForward,The method has 5 parameters. Parameters: input' hidden1' hidden2' output' tanh
Long Identifier,Encog.ML.EA.Score.Adjust,ComplexityAdjustedScore,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\EA\Score\Adjust\ComplexityAdjustedScore.cs,ComplexityAdjustedScore,The length of the parameter theComplexityPentaltyFullThreshold is 34.
Long Identifier,Encog.ML.Factory,MLTrainFactory,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Factory\MLTrainFactory.cs,,The length of the parameter PropertyBayesianRegularization is 30.
Long Statement,Encog.App.Generate.Generators.JS,GenerateEncogJavaScript,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Generate\Generators\JS\GenerateEncogJavaScript.cs,GenerateClass,The length of the statement  "                "<noscript>Your browser does not support JavaScript! Note: if you are trying to view this in Encog Workbench' right-click file and choose \"Open as Text\".</noscript>"); " is 169.
Long Statement,Encog.MathUtil.LIBSVM,SVC_Q,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,get_Q,The length of the statement  "                    //UPGRADE_WARNING: Data types in Visual C# might be different.  Verify the accuracy of narrowing conversions. 'ms-help://MS.VSCC.2003/commoner/redir/redirect.htm?keyword="jlca1042_3"' " is 183.
Long Statement,Encog.MathUtil.LIBSVM,ONE_CLASS_Q,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,get_Q,The length of the statement  "                    //UPGRADE_WARNING: Data types in Visual C# might be different.  Verify the accuracy of narrowing conversions. 'ms-help://MS.VSCC.2003/commoner/redir/redirect.htm?keyword="jlca1042_3"' " is 183.
Long Statement,Encog.MathUtil.LIBSVM,SVR_Q,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,get_Q,The length of the statement  "                    //UPGRADE_WARNING: Data types in Visual C# might be different.  Verify the accuracy of narrowing conversions. 'ms-help://MS.VSCC.2003/commoner/redir/redirect.htm?keyword="jlca1042_3"' " is 183.
Long Statement,Encog.MathUtil.LIBSVM,svm,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,solve_one_class,The length of the statement  "            //UPGRADE_WARNING: Data types in Visual C# might be different.  Verify the accuracy of narrowing conversions. 'ms-help://MS.VSCC.2003/commoner/redir/redirect.htm?keyword="jlca1042_3"' " is 183.
Long Statement,Encog.MathUtil.LIBSVM,svm,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_binary_svc_probability,The length of the statement  "                //UPGRADE_WARNING: Data types in Visual C# might be different.  Verify the accuracy of narrowing conversions. 'ms-help://MS.VSCC.2003/commoner/redir/redirect.htm?keyword="jlca1042_3"' " is 183.
Long Statement,Encog.MathUtil.LIBSVM,svm,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_svr_probability,The length of the statement  "                "Prob. model for test data: target value = predicted value + z'\nz: Laplace distribution e^(-|z|/sigma)/(2sigma)'sigma=" + " is 122.
Long Statement,Encog.MathUtil.LIBSVM,svm,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_train,The length of the statement  "                    //UPGRADE_WARNING: Data types in Visual C# might be different.  Verify the accuracy of narrowing conversions. 'ms-help://MS.VSCC.2003/commoner/redir/redirect.htm?keyword="jlca1042_3"' " is 183.
Long Statement,Encog.MathUtil.LIBSVM,svm,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_cross_validation,The length of the statement  "                //UPGRADE_WARNING: Data types in Visual C# might be different.  Verify the accuracy of narrowing conversions. 'ms-help://MS.VSCC.2003/commoner/redir/redirect.htm?keyword="jlca1042_3"' " is 183.
Long Statement,Encog.MathUtil.LIBSVM,svm,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_check_parameter,The length of the statement  "                    //UPGRADE_WARNING: Data types in Visual C# might be different.  Verify the accuracy of narrowing conversions. 'ms-help://MS.VSCC.2003/commoner/redir/redirect.htm?keyword="jlca1042_3"' " is 183.
Long Statement,Encog.MathUtil.LIBSVM,svm_parameter,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm_parameter.cs,Clone,The length of the statement  "                //UPGRADE_NOTE: Exception 'java.lang.CloneNotSupportedException' was converted to 'System.Exception' which has different behavior. 'ms-help://MS.VSCC.2003/commoner/redir/redirect.htm?keyword="jlca1100_3"' " is 204.
Long Statement,Encog.MathUtil.Matrices,MatrixMath,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\MatrixMath.cs,Multiply,The length of the statement  "                    "To use ordinary matrix multiplication the number of columns on the first matrix must mat the number of rows on the second."); " is 126.
Long Statement,Encog.MathUtil.Randomize.Generate,MersenneTwisterGenerateRandom,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\MersenneTwisterGenerateRandom.cs,SetSeed,The length of the statement  "                _stateVector[i] = (uint)((_stateVector[i] ^ ((_stateVector[i - 1] ^ (_stateVector[i - 1] >> 30)) * 1664525U)) + array[j] + j); " is 126.
Long Statement,Encog.ML.Data.Market.Loader,CSVFinal,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFinal.cs,ReadAndCallLoader,The length of the statement  "                //In case we want to use a different date format...and have used the SetDateFormat method' our DateFormat must then not be null.. " is 129.
Long Statement,Encog.ML.EA.Score.Multi,ParallelScore,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\EA\Score\Multi\ParallelScore.cs,Process,The length of the statement  "            IList<ParallelScoreTask> tasks = (from species in _population.Species from genome in species.Members select new ParallelScoreTask(genome' this)).ToList(); " is 154.
Long Statement,Encog.ML.EA.Species,ThresholdSpeciation,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\EA\Species\ThresholdSpeciation.cs,SpeciateAndCalculateSpawnLevels,The length of the statement  "            double totalSpeciesScore = speciesCollection.Sum(species => species.CalculateShare(_owner.ScoreFunction.ShouldMinimize' maxScore)); " is 131.
Long Statement,Encog.ML.Prg,EncogProgramContext,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Prg\EncogProgramContext.cs,GetMaxEnumType,The length of the statement  "            r = (from mapping in _definedVariables where mapping.VariableType == EPLValueType.EnumType select mapping.EnumType).Concat(new[] {r}).Max(); " is 140.
Long Statement,Encog.ML.Prg.Ext,FunctionFactory,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Prg\Ext\FunctionFactory.cs,FindFunction,The length of the statement  "            return _opcodes.Where(opcode => opcode.NodeType == NodeType.Function).FirstOrDefault(opcode => opcode.Name.Equals(name)); " is 121.
Long Statement,Encog.ML.Prg.Ext,FunctionFactory,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Prg\Ext\FunctionFactory.cs,FindOperatorExact,The length of the statement  "            return _opcodes.Where(opcode => opcode.NodeType == NodeType.OperatorLeft || opcode.NodeType == NodeType.OperatorRight).FirstOrDefault(opcode => opcode.Name.Equals(str)); " is 169.
Long Statement,Encog.Neural.Freeform,FreeformNetwork,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Freeform\FreeformNetwork.cs,CreateContext,The length of the statement  "                    "A layer cannot have a context layer connected if there are no other outbound connections from the source layer.  Please connect the source layer somewhere else first."); " is 170.
Long Statement,Encog.Neural.Networks.Training.PSO,NeuralPSO,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\PSO\NeuralPSO.cs,IsScoreBetter,The length of the statement  "            return ((m_calculateScore.ShouldMinimize && (score1 < score2)) || ((!m_calculateScore.ShouldMinimize) && (score1 > score2))); " is 125.
Long Statement,Encog.Util.NetworkUtil,TrainerHelper,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\NetworkUtil\TrainerHelper.cs,MakeDataSet,The length of the statement  "            set = new BasicMLDataSet((double[][])FirstList.ToArray(typeof(double[]))' (double[][])outputsar.ToArray(typeof(double[]))); " is 123.
Complex Conditional,Encog.MathUtil.LIBSVM,svm,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_predict_probability,The conditional expression  "(model.param.svm_type == svm_parameter.C_SVC || model.param.svm_type == svm_parameter.NU_SVC) &&                  model.probA != null && model.probB != null"  is complex.
Complex Conditional,Encog.MathUtil.LIBSVM,svm,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_check_parameter,The conditional expression  "svm_type != svm_parameter.C_SVC && svm_type != svm_parameter.NU_SVC &&                  svm_type != svm_parameter.ONE_CLASS && svm_type != svm_parameter.EPSILON_SVR &&                  svm_type != svm_parameter.NU_SVR"  is complex.
Complex Conditional,Encog.MathUtil.LIBSVM,svm,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_check_parameter,The conditional expression  "kernel_type != svm_parameter.LINEAR && kernel_type != svm_parameter.POLY &&                  kernel_type != svm_parameter.RBF && kernel_type != svm_parameter.SIGMOID"  is complex.
Complex Conditional,Encog.MathUtil.LIBSVM,svm,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_check_probability_model,The conditional expression  "((model.param.svm_type == svm_parameter.C_SVC || model.param.svm_type == svm_parameter.NU_SVC) &&                   model.probA != null && model.probB != null) ||                  ((model.param.svm_type == svm_parameter.EPSILON_SVR || model.param.svm_type == svm_parameter.NU_SVR) &&                   model.probA != null)"  is complex.
Complex Conditional,Encog.ML.EA.Population,BasicPopulation,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\EA\Population\BasicPopulation.cs,PurgeInvalidGenomes,The conditional expression  "double.IsInfinity(genome.Score)                          || double.IsInfinity(genome.AdjustedScore)                          || double.IsNaN(genome.Score)                          || double.IsNaN(genome.AdjustedScore)"  is complex.
Complex Conditional,Encog.Parse.Expression.Common,ParseCommonExpression,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Parse\Expression\Common\ParseCommonExpression.cs,functionQueue,The conditional expression  "this.functionStack.Count != 0                      && this.functionStack.Peek().NodeType != NodeType.None                      && ((f.NodeType == NodeType.OperatorLeft && f                              .Precedence >= this.functionStack.Peek()                              .Precedence) || f.Precedence > this.functionStack                              .Peek().Precedence)"  is complex.
Complex Conditional,Encog.Parse.Tags.Read,ReadTags,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Parse\Tags\Read\ReadTags.cs,ParseAttributeName,The conditional expression  "!char.IsWhiteSpace((char) _source.Peek())                         && (_source.Peek() != '=')                         && (_source.Peek() != '>')                         && (_source.Peek() != -1)"  is complex.
Virtual Method Call from Constructor,Encog.ML.Data.Basic,BasicMLDataSet,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Basic\BasicMLDataSet.cs,BasicMLDataSet,The constructor "BasicMLDataSet" calls a virtual method "Add".
Virtual Method Call from Constructor,Encog.ML.Data.Basic,BasicMLDataSet,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Basic\BasicMLDataSet.cs,BasicMLDataSet,The constructor "BasicMLDataSet" calls a virtual method "Add".
Virtual Method Call from Constructor,Encog.Neural.Networks.Training.Propagation.Back,Backpropagation,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\Propagation\Back\Backpropagation.cs,Backpropagation,The constructor "Backpropagation" calls a virtual method "AddStrategy".
Virtual Method Call from Constructor,Encog.Neural.Networks.Training.Propagation.Back,Backpropagation,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\Propagation\Back\Backpropagation.cs,Backpropagation,The constructor "Backpropagation" calls a virtual method "AddStrategy".
Empty Catch Block,Encog.Cloud.Indicator.Server,IndicatorLink,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Cloud\Indicator\Server\IndicatorLink.cs,Close,The method has an empty catch block.
Empty Catch Block,Encog.ML.Bayesian.Parse,ParsedEvent,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Bayesian\Parse\ParsedEvent.cs,ResolveValue,The method has an empty catch block.
Magic Number,Encog.App.Analyst.Commands,CmdSet,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Commands\CmdSet.cs,ExecuteCommand,The following statement contains a magic number: String name = cols[2];
Magic Number,Encog.App.Analyst.Commands,CmdTrain,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Commands\CmdTrain.cs,ObtainCross,The following statement contains a magic number: String str = cross.Substring(6);
Magic Number,Encog.App.Analyst.Analyze,AnalyzedField,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Analyze\AnalyzedField.cs,FinalizeField,The following statement contains a magic number: result.Min = Min - 0.0001;
Magic Number,Encog.App.Analyst.Analyze,AnalyzedField,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Analyze\AnalyzedField.cs,FinalizeField,The following statement contains a magic number: result.Max = Min + 0.0001;
Magic Number,Encog.App.Analyst.CSV.Basic,LoadedRow,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\CSV\Basic\LoadedRow.cs,LoadedRow,The following statement contains a magic number: _data[i] = format.Format(data[i]' 5);
Magic Number,Encog.App.Analyst.CSV.Basic,LoadedRow,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\CSV\Basic\LoadedRow.cs,LoadedRow,The following statement contains a magic number: _data[i] = format.Format(data[i]' 5);
Magic Number,Encog.App.Analyst.CSV.Segregate,SegregateCSV,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\CSV\Segregate\SegregateCSV.cs,BalanceTargets,The following statement contains a magic number: double percent = stp.Percent/100.0;
Magic Number,Encog.App.Analyst.CSV.Segregate,SegregateCSV,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\CSV\Segregate\SegregateCSV.cs,Validate,The following statement contains a magic number: _targets.Count < 2
Magic Number,Encog.App.Analyst.Missing,NegateMissing,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Missing\NegateMissing.cs,HandleMissing,The following statement contains a magic number: double n = stat.NormalizedHigh - (stat.NormalizedHigh - stat.NormalizedLow/2);
Magic Number,Encog.App.Analyst.Script,ScriptLoad,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Script\ScriptLoad.cs,HandleDataClasses,The following statement contains a magic number: String name = cols[2];
Magic Number,Encog.App.Analyst.Script,ScriptLoad,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Script\ScriptLoad.cs,HandleDataClasses,The following statement contains a magic number: int count = Int32.Parse(cols[3]);
Magic Number,Encog.App.Analyst.Script,ScriptLoad,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Script\ScriptLoad.cs,HandleDataStats,The following statement contains a magic number: bool iscomplete = Int32.Parse(cols[2]) > 0;
Magic Number,Encog.App.Analyst.Script,ScriptLoad,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Script\ScriptLoad.cs,HandleDataStats,The following statement contains a magic number: double amax = CSVFormat.EgFormat.Parse(cols[5]);
Magic Number,Encog.App.Analyst.Script,ScriptLoad,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Script\ScriptLoad.cs,HandleDataStats,The following statement contains a magic number: double amin = CSVFormat.EgFormat.Parse(cols[6]);
Magic Number,Encog.App.Analyst.Script,ScriptLoad,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Script\ScriptLoad.cs,HandleDataStats,The following statement contains a magic number: double mean = CSVFormat.EgFormat.Parse(cols[7]);
Magic Number,Encog.App.Analyst.Script,ScriptLoad,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Script\ScriptLoad.cs,HandleDataStats,The following statement contains a magic number: double sdev = CSVFormat.EgFormat.Parse(cols[8]);
Magic Number,Encog.App.Analyst.Script,ScriptLoad,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Script\ScriptLoad.cs,HandleDataStats,The following statement contains a magic number: source = cols[9];
Magic Number,Encog.App.Analyst.Script,ScriptLoad,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Script\ScriptLoad.cs,HandleDataStats,The following statement contains a magic number: cols.Count > 9
Magic Number,Encog.App.Analyst.Script,ScriptLoad,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Script\ScriptLoad.cs,HandleNormalizeRange,The following statement contains a magic number: int timeSlice = Int32.Parse(cols[2]);
Magic Number,Encog.App.Analyst.Script,ScriptLoad,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Script\ScriptLoad.cs,HandleNormalizeRange,The following statement contains a magic number: String action = cols[3];
Magic Number,Encog.App.Analyst.Script,ScriptLoad,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Script\ScriptLoad.cs,HandleNormalizeRange,The following statement contains a magic number: double high = CSVFormat.EgFormat.Parse(cols[4]);
Magic Number,Encog.App.Analyst.Script,ScriptLoad,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Script\ScriptLoad.cs,HandleNormalizeRange,The following statement contains a magic number: double low = CSVFormat.EgFormat.Parse(cols[5]);
Magic Number,Encog.App.Analyst.Script.Normalize,AnalystField,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Script\Normalize\AnalystField.cs,DeNormalize,The following statement contains a magic number: return ((NormalizedHigh - NormalizedLow)/2) + NormalizedLow;
Magic Number,Encog.App.Analyst.Script.Normalize,AnalystField,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Script\Normalize\AnalystField.cs,Normalize,The following statement contains a magic number: return ((NormalizedHigh - NormalizedLow)/2) + NormalizedLow;
Magic Number,Encog.App.Analyst.Script.Prop,PropertyConstraints,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Script\Prop\PropertyConstraints.cs,PropertyConstraints,The following statement contains a magic number: String typeStr = csv.Get(2);
Magic Number,Encog.App.Analyst.Script.Prop,PropertyConstraints,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Script\Prop\PropertyConstraints.cs,FindEntry,The following statement contains a magic number: String name = cols[2];
Magic Number,Encog.App.Analyst.Wizard,AnalystWizard,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,DetermineTargetField,The following statement contains a magic number: _script.Properties.SetProperty(                          ScriptProperties.ClusterConfigClusters' 2);
Magic Number,Encog.App.Analyst.Wizard,AnalystWizard,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,GenerateFeedForward,The following statement contains a magic number: var hidden = (int) ((inputColumns)*1.5d);
Magic Number,Encog.App.Analyst.Wizard,AnalystWizard,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,generateEPL,The following statement contains a magic number: inputColumns > 26
Magic Number,Encog.App.Analyst.Wizard,AnalystWizard,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,GenerateRBF,The following statement contains a magic number: var hidden = (int) ((inputColumns)*1.5d);
Magic Number,Encog.App.Analyst.Wizard,AnalystWizard,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,GenerateSegregate,The following statement contains a magic number: var array = new AnalystSegregateTarget[2];
Magic Number,Encog.App.Analyst.Wizard,AnalystWizard,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,WizardRealTime,The following statement contains a magic number: MaxError = 0.05;
Magic Number,Encog.App.Analyst.Wizard,AnalystWizard,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,GenerateSourceData,The following statement contains a magic number: df.Max = 100000;
Magic Number,Encog.App.Analyst.Wizard,AnalystWizard,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,GenerateSourceData,The following statement contains a magic number: df.Min = -100000;
Magic Number,Encog.App.Analyst.Wizard,AnalystWizard,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,GenerateSourceData,The following statement contains a magic number: df2.Max = 100000;
Magic Number,Encog.App.Analyst.Wizard,AnalystWizard,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,GenerateSourceData,The following statement contains a magic number: df2.Min = -100000;
Magic Number,Encog.App.Finance.Indicators,TechnicalIndicators,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Finance\Indicators\Finance.cs,Avg,The following statement contains a magic number: return (a + b)/2;
Magic Number,Encog.App.Generate.Generators,AbstractTemplateGenerator,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Generate\Generators\AbstractTemplateGenerator.cs,Generate,The following statement contains a magic number: ProcessToken(line.Substring(2).Trim());
Magic Number,Encog.App.Generate.Generators,AbstractTemplateGenerator,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Generate\Generators\AbstractTemplateGenerator.cs,CreateActivations,The following statement contains a magic number: result[i] = 2;
Magic Number,Encog.App.Generate.Generators,AbstractTemplateGenerator,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Generate\Generators\AbstractTemplateGenerator.cs,CreateActivations,The following statement contains a magic number: result[i] = 3;
Magic Number,Encog.App.Generate.Generators,AbstractTemplateGenerator,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Generate\Generators\AbstractTemplateGenerator.cs,CreateActivations,The following statement contains a magic number: result[i] = 4;
Magic Number,Encog.App.Generate.Generators,AbstractTemplateGenerator,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Generate\Generators\AbstractTemplateGenerator.cs,ToBrokenList,The following statement contains a magic number: lineCount > 10
Magic Number,Encog.App.Generate.Generators,AbstractTemplateGenerator,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Generate\Generators\AbstractTemplateGenerator.cs,ToBrokenList,The following statement contains a magic number: lineCount > 10
Magic Number,Encog.App.Generate.Generators.CS,GenerateCS,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Generate\Generators\CS\GenerateCS.cs,GenerateArrayInit,The following statement contains a magic number: lineCount >= 10
Magic Number,Encog.App.Generate.Generators.Java,GenerateEncogJava,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Generate\Generators\Java\GenerateEncogJava.cs,GenerateArrayInit,The following statement contains a magic number: lineCount >= 10
Magic Number,Encog.App.Generate.Generators.JS,GenerateEncogJavaScript,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Generate\Generators\JS\GenerateEncogJavaScript.cs,GenerateArrayInit,The following statement contains a magic number: lineCount >= 10
Magic Number,Encog.App.Generate.Generators.MQL4,GenerateMQL4,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Generate\Generators\MQL4\GenerateMQL4.cs,ProcessCalc,The following statement contains a magic number: IndentLevel = 2;
Magic Number,Encog.App.Generate.Generators.MQL4,GenerateMQL4,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Generate\Generators\MQL4\GenerateMQL4.cs,ProcessCalc,The following statement contains a magic number: IndentLevel = 2;
Magic Number,Encog.App.Generate.Generators.MQL4,GenerateMQL4,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Generate\Generators\MQL4\GenerateMQL4.cs,ProcessMainBlock,The following statement contains a magic number: IndentLevel = 2;
Magic Number,Encog.App.Generate.Generators.MQL4,GenerateMQL4,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Generate\Generators\MQL4\GenerateMQL4.cs,ProcessObtain,The following statement contains a magic number: IndentLevel = 3;
Magic Number,Encog.App.Generate.Generators.NinjaScript,GenerateNinjaScript,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Generate\Generators\NinjaScript\GenerateNinjaScript.cs,ProcessMainBlock,The following statement contains a magic number: IndentLevel = 2;
Magic Number,Encog.App.Generate.Generators.NinjaScript,GenerateNinjaScript,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Generate\Generators\NinjaScript\GenerateNinjaScript.cs,ProcessCalc,The following statement contains a magic number: IndentLevel = 2;
Magic Number,Encog.App.Generate.Generators.NinjaScript,GenerateNinjaScript,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Generate\Generators\NinjaScript\GenerateNinjaScript.cs,ProcessCalc,The following statement contains a magic number: IndentLevel = 2;
Magic Number,Encog.App.Generate.Generators.NinjaScript,GenerateNinjaScript,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Generate\Generators\NinjaScript\GenerateNinjaScript.cs,ProcessObtain,The following statement contains a magic number: IndentLevel = 3;
Magic Number,Encog.App.Quant.Loader.Yahoo,YahooDownload,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Quant\Loader\Yahoo\YahooDownload.cs,YahooDownload,The following statement contains a magic number: Precision = 10;
Magic Number,Encog.App.Quant.Ninja,NinjaStreamWriter,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Quant\Ninja\NinjaStreamWriter.cs,NinjaStreamWriter,The following statement contains a magic number: Percision = 10;
Magic Number,Encog.Cloud.Indicator.Basic,DownloadIndicator,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Cloud\Indicator\Basic\DownloadIndicator.cs,NotifyPacket,The following statement contains a magic number: holder.Record(when' 2' packet.Args)
Magic Number,Encog.Cloud.Indicator.Server,IndicatorLink,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Cloud\Indicator\Server\IndicatorLink.cs,ReadNextBlock,The following statement contains a magic number: var buffer = new byte[1024];
Magic Number,Encog.Cloud.Indicator.Server,IndicatorLink,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Cloud\Indicator\Server\IndicatorLink.cs,InitConnection,The following statement contains a magic number: var args = new String[2];
Magic Number,Encog.Cloud.Indicator.Server,IndicatorServer,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Cloud\Indicator\Server\IndicatorServer.cs,Run,The following statement contains a magic number: _listenSocket.Listen(5);
Magic Number,Encog.Cloud.Indicator.Server,IndicatorServer,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Cloud\Indicator\Server\IndicatorServer.cs,WaitForIndicatorCompletion,The following statement contains a magic number: Thread.Sleep(1000);
Magic Number,Encog.Cloud.Indicator.Server,IndicatorServer,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Cloud\Indicator\Server\IndicatorServer.cs,WaitForIndicatorCompletion,The following statement contains a magic number: Thread.Sleep(1000);
Magic Number,Encog.Cloud.Indicator.Server,IndicatorServer,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Cloud\Indicator\Server\IndicatorServer.cs,WaitForShutdown,The following statement contains a magic number: Thread.Sleep(1000);
Magic Number,Encog.Engine.Network.Activation,ActivationClippedLinear,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Engine\Network\Activation\ActivationClippedLinear.cs,ActivationFunction,The following statement contains a magic number: d[i] = (2.0 / (1.0 + Math.Exp(-4.9 * d[i]))) - 1.0;
Magic Number,Encog.Engine.Network.Activation,ActivationClippedLinear,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Engine\Network\Activation\ActivationClippedLinear.cs,ActivationFunction,The following statement contains a magic number: d[i] = (2.0 / (1.0 + Math.Exp(-4.9 * d[i]))) - 1.0;
Magic Number,Encog.Engine.Network.Activation,ActivationElliott,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Engine\Network\Activation\ActivationElliott.cs,ActivationFunction,The following statement contains a magic number: x[i] = ((x[i]*s)/2)/(1 + Math.Abs(x[i]*s)) + 0.5;
Magic Number,Encog.Engine.Network.Activation,ActivationElliott,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Engine\Network\Activation\ActivationElliott.cs,ActivationFunction,The following statement contains a magic number: x[i] = ((x[i]*s)/2)/(1 + Math.Abs(x[i]*s)) + 0.5;
Magic Number,Encog.Engine.Network.Activation,ActivationElliott,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Engine\Network\Activation\ActivationElliott.cs,DerivativeFunction,The following statement contains a magic number: return s/(2.0*(1.0 + Math.Abs(b*s))*(1 + Math.Abs(b*s)));
Magic Number,Encog.Engine.Network.Activation,ActivationGaussian,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Engine\Network\Activation\ActivationGaussian.cs,ActivationFunction,The following statement contains a magic number: x[i] = BoundMath.Exp(-Math.Pow(2.5 * x[i]' 2.0));
Magic Number,Encog.Engine.Network.Activation,ActivationGaussian,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Engine\Network\Activation\ActivationGaussian.cs,ActivationFunction,The following statement contains a magic number: x[i] = BoundMath.Exp(-Math.Pow(2.5 * x[i]' 2.0));
Magic Number,Encog.Engine.Network.Activation,ActivationGaussian,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Engine\Network\Activation\ActivationGaussian.cs,DerivativeFunction,The following statement contains a magic number: return Math.Exp(Math.Pow(2.5 * b' 2.0) * 12.5 * b);
Magic Number,Encog.Engine.Network.Activation,ActivationGaussian,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Engine\Network\Activation\ActivationGaussian.cs,DerivativeFunction,The following statement contains a magic number: return Math.Exp(Math.Pow(2.5 * b' 2.0) * 12.5 * b);
Magic Number,Encog.Engine.Network.Activation,ActivationGaussian,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Engine\Network\Activation\ActivationGaussian.cs,DerivativeFunction,The following statement contains a magic number: return Math.Exp(Math.Pow(2.5 * b' 2.0) * 12.5 * b);
Magic Number,Encog.Engine.Network.Activation,ActivationRamp,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Engine\Network\Activation\ActivationRamp.cs,ActivationRamp,The following statement contains a magic number: _paras = new double[4];
Magic Number,Encog.Engine.Network.Activation,ActivationReLU,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Engine\Network\Activation\ActivationReLU.cs,ActivationReLU,The following statement contains a magic number: _params = new double[2];
Magic Number,Encog.Engine.Network.Activation,ActivationSIN,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Engine\Network\Activation\ActivationSIN.cs,ActivationFunction,The following statement contains a magic number: x[i] = BoundMath.Sin(2.0 * x[i]);
Magic Number,Encog.Engine.Network.Activation,ActivationSIN,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Engine\Network\Activation\ActivationSIN.cs,DerivativeFunction,The following statement contains a magic number: return BoundMath.Cos(2.0 * b);
Magic Number,Encog.Engine.Network.Activation,ActivationSteepenedSigmoid,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Engine\Network\Activation\ActivationSteepenedSigmoid.cs,ActivationFunction,The following statement contains a magic number: x[i] = 1.0 / (1.0 + Math.Exp(-4.9 * x[i]));
Magic Number,Encog.Engine.Network.Activation,ActivationSteepenedSigmoid,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Engine\Network\Activation\ActivationSteepenedSigmoid.cs,DerivativeFunction,The following statement contains a magic number: double s = Math.Exp(-4.9 * a);
Magic Number,Encog.Engine.Network.Activation,ActivationSteepenedSigmoid,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Engine\Network\Activation\ActivationSteepenedSigmoid.cs,DerivativeFunction,The following statement contains a magic number: return Math.Pow(s * 4.9 / (1 + s)' 2);
Magic Number,Encog.Engine.Network.Activation,ActivationSteepenedSigmoid,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Engine\Network\Activation\ActivationSteepenedSigmoid.cs,DerivativeFunction,The following statement contains a magic number: return Math.Pow(s * 4.9 / (1 + s)' 2);
Magic Number,Encog.Engine.Network.Activation,ActivationStep,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Engine\Network\Activation\ActivationStep.cs,ActivationStep,The following statement contains a magic number: _paras = new double[3];
Magic Number,Encog.Engine.Network.Activation,ActivationTANH,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Engine\Network\Activation\ActivationTANH.cs,ActivationFunction,The following statement contains a magic number: x[i] = 2.0 / (1.0 + BoundMath.Exp(-2.0 * x[i])) - 1.0;
Magic Number,Encog.Engine.Network.Activation,ActivationTANH,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Engine\Network\Activation\ActivationTANH.cs,ActivationFunction,The following statement contains a magic number: x[i] = 2.0 / (1.0 + BoundMath.Exp(-2.0 * x[i])) - 1.0;
Magic Number,Encog.MathUtil,ComplexNumber,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\ComplexNumber.cs,Sqrt,The following statement contains a magic number: double theta = Arg()/2;
Magic Number,Encog.MathUtil,ComplexNumber,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\ComplexNumber.cs,Cosh,The following statement contains a magic number: return (Math.Exp(theta) + Math.Exp(-theta))/2;
Magic Number,Encog.MathUtil,ComplexNumber,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\ComplexNumber.cs,Sinh,The following statement contains a magic number: return (Math.Exp(theta) - Math.Exp(-theta))/2;
Magic Number,Encog.MathUtil,ComplexNumber,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\ComplexNumber.cs,ToString,The following statement contains a magic number: return Format.FormatDouble(_x' 4);
Magic Number,Encog.MathUtil,EncogMath,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\EncogMath.cs,Deg2Rad,The following statement contains a magic number: return deg*(Math.PI/180.0);
Magic Number,Encog.MathUtil,EncogMath,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\EncogMath.cs,Rad2Deg,The following statement contains a magic number: return rad*(180.0/Math.PI);
Magic Number,Encog.MathUtil,NumericRange,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\NumericRange.cs,ToString,The following statement contains a magic number: result.Append(Format.FormatDouble(_low' 5));
Magic Number,Encog.MathUtil,NumericRange,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\NumericRange.cs,ToString,The following statement contains a magic number: result.Append(Format.FormatDouble(_high' 5));
Magic Number,Encog.MathUtil,NumericRange,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\NumericRange.cs,ToString,The following statement contains a magic number: result.Append(Format.FormatDouble(_mean' 5));
Magic Number,Encog.MathUtil,NumericRange,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\NumericRange.cs,ToString,The following statement contains a magic number: result.Append(Format.FormatDouble(_rms' 5));
Magic Number,Encog.MathUtil,NumericRange,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\NumericRange.cs,ToString,The following statement contains a magic number: result.Append(Format.FormatDouble(_standardDeviation' 5));
Magic Number,Encog.MathUtil,VectorAlgebra,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\VectorAlgebra.cs,Randomise,The following statement contains a magic number: Randomise(v' 0.1);
Magic Number,Encog.MathUtil,VectorAlgebra,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\VectorAlgebra.cs,Randomise,The following statement contains a magic number: v[i] = (2 * rand.NextDouble() - 1) * maxValue;
Magic Number,Encog.MathUtil.Error,ErrorCalculation,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Error\ErrorCalculation.cs,CalculateSSE,The following statement contains a magic number: return _globalError / 2;
Magic Number,Encog.MathUtil.LIBSVM,Cache,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,Cache,The following statement contains a magic number: size /= 4;
Magic Number,Encog.MathUtil.LIBSVM,Cache,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,Cache,The following statement contains a magic number: size -= l*(16/4);
Magic Number,Encog.MathUtil.LIBSVM,Cache,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,Cache,The following statement contains a magic number: size -= l*(16/4);
Magic Number,Encog.MathUtil.LIBSVM,Kernel,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,tanh,The following statement contains a magic number: return 1.0 - 2.0/(e*e + 1);
Magic Number,Encog.MathUtil.LIBSVM,Kernel,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,kernel_function,The following statement contains a magic number: switch (kernel_type)              {                  case svm_parameter.LINEAR:                      return dot(x[i]' x[j]);                    case svm_parameter.POLY:                      return Math.Pow(gamma*dot(x[i]' x[j]) + coef0' degree);                    case svm_parameter.RBF:                      return Math.Exp((- gamma)*(x_square[i] + x_square[j] - 2*dot(x[i]' x[j])));                    case svm_parameter.SIGMOID:                      return tanh(gamma*dot(x[i]' x[j]) + coef0);                    default:                      return 0; // java              }
Magic Number,Encog.MathUtil.LIBSVM,Solver,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,Solve,The following statement contains a magic number: int counter = Math.Min(l' 1000) + 1;
Magic Number,Encog.MathUtil.LIBSVM,Solver,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,Solve,The following statement contains a magic number: var working_set = new int[2];
Magic Number,Encog.MathUtil.LIBSVM,Solver,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,Solve,The following statement contains a magic number: iter > 10000
Magic Number,Encog.MathUtil.LIBSVM,Solver,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,Solve,The following statement contains a magic number: counter = Math.Min(l' 1000);
Magic Number,Encog.MathUtil.LIBSVM,Solver,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,Solve,The following statement contains a magic number: double delta = (- G[i] - G[j])/Math.Max(Q_i[i] + Q_j[j] + 2*Q_i[j]' 0);
Magic Number,Encog.MathUtil.LIBSVM,Solver,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,Solve,The following statement contains a magic number: si.obj = v/2;
Magic Number,Encog.MathUtil.LIBSVM,Solver,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,do_shrinking,The following statement contains a magic number: var working_set = new int[2];
Magic Number,Encog.MathUtil.LIBSVM,Solver,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,do_shrinking,The following statement contains a magic number: unshrinked || - (Gm1 + Gm2) > eps*10
Magic Number,Encog.MathUtil.LIBSVM,Solver_NU,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,do_shrinking,The following statement contains a magic number: unshrinked || Math.Max(- (Gm1 + Gm2)' - (Gm3 + Gm4)) > eps*10
Magic Number,Encog.MathUtil.LIBSVM,Solver_NU,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,calculate_rho,The following statement contains a magic number: si.r = (r1 + r2)/2;
Magic Number,Encog.MathUtil.LIBSVM,Solver_NU,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,calculate_rho,The following statement contains a magic number: return (r1 - r2)/2;
Magic Number,Encog.MathUtil.LIBSVM,SVC_Q,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,SVC_Q,The following statement contains a magic number: cache = new Cache(prob.l' (int) (param.cache_size*(1 << 20)));
Magic Number,Encog.MathUtil.LIBSVM,ONE_CLASS_Q,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,ONE_CLASS_Q,The following statement contains a magic number: cache = new Cache(prob.l' (int) (param.cache_size*(1 << 20)));
Magic Number,Encog.MathUtil.LIBSVM,SVR_Q,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,SVR_Q,The following statement contains a magic number: cache = new Cache(l' (int) (param.cache_size*(1 << 20)));
Magic Number,Encog.MathUtil.LIBSVM,SVR_Q,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,SVR_Q,The following statement contains a magic number: sign = new sbyte[2*l];
Magic Number,Encog.MathUtil.LIBSVM,SVR_Q,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,SVR_Q,The following statement contains a magic number: index = new int[2*l];
Magic Number,Encog.MathUtil.LIBSVM,SVR_Q,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,SVR_Q,The following statement contains a magic number: buffer = new float[2][];
Magic Number,Encog.MathUtil.LIBSVM,SVR_Q,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,SVR_Q,The following statement contains a magic number: buffer[i] = new float[2*l];
Magic Number,Encog.MathUtil.LIBSVM,SVR_Q,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,SVR_Q,The following statement contains a magic number: i < 2
Magic Number,Encog.MathUtil.LIBSVM,svm,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,solve_nu_svc,The following statement contains a magic number: double sum_pos = nu*l/2;
Magic Number,Encog.MathUtil.LIBSVM,svm,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,solve_nu_svc,The following statement contains a magic number: double sum_neg = nu*l/2;
Magic Number,Encog.MathUtil.LIBSVM,svm,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,solve_epsilon_svr,The following statement contains a magic number: var alpha2 = new double[2*l];
Magic Number,Encog.MathUtil.LIBSVM,svm,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,solve_epsilon_svr,The following statement contains a magic number: var linear_term = new double[2*l];
Magic Number,Encog.MathUtil.LIBSVM,svm,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,solve_epsilon_svr,The following statement contains a magic number: var y = new sbyte[2*l];
Magic Number,Encog.MathUtil.LIBSVM,svm,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,solve_epsilon_svr,The following statement contains a magic number: s.Solve(2*l' new SVR_Q(prob' param)' linear_term' y' alpha2' param.C' param.C' param.eps' si'                      param.shrinking);
Magic Number,Encog.MathUtil.LIBSVM,svm,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,solve_nu_svr,The following statement contains a magic number: var alpha2 = new double[2*l];
Magic Number,Encog.MathUtil.LIBSVM,svm,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,solve_nu_svr,The following statement contains a magic number: var linear_term = new double[2*l];
Magic Number,Encog.MathUtil.LIBSVM,svm,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,solve_nu_svr,The following statement contains a magic number: var y = new sbyte[2*l];
Magic Number,Encog.MathUtil.LIBSVM,svm,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,solve_nu_svr,The following statement contains a magic number: double sum = C*param.nu*l/2;
Magic Number,Encog.MathUtil.LIBSVM,svm,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,solve_nu_svr,The following statement contains a magic number: s.Solve(2*l' new SVR_Q(prob' param)' linear_term' y' alpha2' C' C' param.eps' si' param.shrinking);
Magic Number,Encog.MathUtil.LIBSVM,svm,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,sigmoid_train,The following statement contains a magic number: int max_iter = 100;
Magic Number,Encog.MathUtil.LIBSVM,svm,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,sigmoid_train,The following statement contains a magic number: double min_step = 1e-10;
Magic Number,Encog.MathUtil.LIBSVM,svm,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,sigmoid_train,The following statement contains a magic number: double sigma = 1e-3;
Magic Number,Encog.MathUtil.LIBSVM,svm,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,sigmoid_train,The following statement contains a magic number: double eps = 1e-5;
Magic Number,Encog.MathUtil.LIBSVM,svm,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,sigmoid_train,The following statement contains a magic number: double hiTarget = (prior1 + 1.0)/(prior1 + 2.0);
Magic Number,Encog.MathUtil.LIBSVM,svm,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,sigmoid_train,The following statement contains a magic number: double loTarget = 1/(prior0 + 2.0);
Magic Number,Encog.MathUtil.LIBSVM,svm,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,sigmoid_train,The following statement contains a magic number: newf < fval + 0.0001*stepsize*gd
Magic Number,Encog.MathUtil.LIBSVM,svm,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,multiclass_probability,The following statement contains a magic number: int iter = 0' max_iter = 100;
Magic Number,Encog.MathUtil.LIBSVM,svm,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,multiclass_probability,The following statement contains a magic number: double pQp' eps = 0.001;
Magic Number,Encog.MathUtil.LIBSVM,svm,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,multiclass_probability,The following statement contains a magic number: pQp = (pQp + diff*(diff*Q[t][t] + 2*Qp[t]))/(1 + diff)/(1 + diff);
Magic Number,Encog.MathUtil.LIBSVM,svm,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_binary_svc_probability,The following statement contains a magic number: int nr_fold = 5;
Magic Number,Encog.MathUtil.LIBSVM,svm,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_svr_probability,The following statement contains a magic number: int nr_fold = 5;
Magic Number,Encog.MathUtil.LIBSVM,svm,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_svr_probability,The following statement contains a magic number: double std = Math.Sqrt(2*mae*mae);
Magic Number,Encog.MathUtil.LIBSVM,svm,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_train,The following statement contains a magic number: model.nr_class = 2;
Magic Number,Encog.MathUtil.LIBSVM,svm,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_predict_probability,The following statement contains a magic number: var dec_values = new double[nr_class*(nr_class - 1)/2];
Magic Number,Encog.MathUtil.LIBSVM,svm,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_predict_probability,The following statement contains a magic number: double min_prob = 1e-7;
Magic Number,Encog.MathUtil.LIBSVM,svm,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_save_model,The following statement contains a magic number: i < nr_class*(nr_class - 1)/2
Magic Number,Encog.MathUtil.LIBSVM,svm,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_save_model,The following statement contains a magic number: i < nr_class*(nr_class - 1)/2
Magic Number,Encog.MathUtil.LIBSVM,svm,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_load_model,The following statement contains a magic number: int n = st.Count/2;
Magic Number,Encog.MathUtil.LIBSVM,svm,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_check_parameter,The following statement contains a magic number: int max_nr_class = 16;
Magic Number,Encog.MathUtil.LIBSVM,svm,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_check_parameter,The following statement contains a magic number: max_nr_class *= 2;
Magic Number,Encog.MathUtil.LIBSVM,svm,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_check_parameter,The following statement contains a magic number: param.nu*(n1 + n2)/2 > Math.Min(n1' n2)
Magic Number,Encog.MathUtil.Matrices,BiPolarUtil,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\BiPolarUtil.cs,ToBinary,The following statement contains a magic number: return (d + 1)/2.0;
Magic Number,Encog.MathUtil.Matrices,BiPolarUtil,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\BiPolarUtil.cs,ToBiPolar,The following statement contains a magic number: return (2*NormalizeBinary(d)) - 1;
Magic Number,Encog.MathUtil.Matrices,Matrix,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Matrix.cs,Equals,The following statement contains a magic number: return equals((Matrix) other' 10);
Magic Number,Encog.MathUtil.Matrices,Matrix,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Matrix.cs,equals,The following statement contains a magic number: double test = Math.Pow(10.0' precision);
Magic Number,Encog.MathUtil.Matrices,Matrix,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Matrix.cs,equals,The following statement contains a magic number: precision = (int) Math.Pow(10' precision);
Magic Number,Encog.MathUtil.Matrices,MatrixMath,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\MatrixMath.cs,VectorLength,The following statement contains a magic number: rtn += Math.Pow(v[i]' 2);
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Tql2,The following statement contains a magic number: double eps = Math.Pow(2.0' -52.0);
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Tql2,The following statement contains a magic number: double eps = Math.Pow(2.0' -52.0);
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Tql2,The following statement contains a magic number: double p = (d[l + 1] - g)/(2.0*e[l]);
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: double eps = Math.Pow(2.0' -52.0);
Magic Number,Encog.MathUtil.Matrices.Decomposition,EigenvalueDecomposition,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\EigenvalueDecomposition.cs,Hqr2,The following statement contains a magic number: double eps = Math.Pow(2.0' -52.0);
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: int nrt = Math.Max(0' Math.Min(n - 2' m));
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: double eps = Math.Pow(2.0' -52.0);
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: double eps = Math.Pow(2.0' -52.0);
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: double tiny = Math.Pow(2.0' -966.0);
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: double tiny = Math.Pow(2.0' -966.0);
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: kase = 4;
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: k == p - 2
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: switch (kase)                  {                          // Deflate negligible s(p).                        case 1:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for (int j = p - 2; j >= k; j--)                              {                                  double t = EncogMath.Hypot(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  if (j != k)                                  {                                      f = -sn*e[j - 1];                                      e[j - 1] = cs*e[j - 1];                                  }                                  if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*vmatrix[i][j] + sn*vmatrix[i][p - 1];                                          vmatrix[i][p - 1] = -sn*vmatrix[i][j] + cs*vmatrix[i][p - 1];                                          vmatrix[i][j] = t;                                      }                                  }                              }                          }                          break;                            // Split at negligible s(k).                        case 2:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for (int j = k; j < p; j++)                              {                                  double t = EncogMath.Hypot(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  f = -sn*e[j];                                  e[j] = cs*e[j];                                  if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*umatrix[i][j] + sn*umatrix[i][k - 1];                                          umatrix[i][k - 1] = -sn*umatrix[i][j] + cs*umatrix[i][k - 1];                                          umatrix[i][j] = t;                                      }                                  }                              }                          }                          break;                            // Perform one qr step.                        case 3:                          {                              // Calculate the shift.                                double scale = Math.Max(Math.Max(Math                                                                   .Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))'                                                                        Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math                                                                                                                  .Abs(                                                                                                                      e[k]));                              double sp = s[p - 1]/scale;                              double spm1 = s[p - 2]/scale;                              double epm1 = e[p - 2]/scale;                              double sk = s[k]/scale;                              double ek = e[k]/scale;                              double b = ((spm1 + sp)*(spm1 - sp) + epm1*epm1)/2.0;                              double c = (sp*epm1)*(sp*epm1);                              double shift = 0.0;                              if ((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt(b*b + c);                                  if (b < 0.0)                                  {                                      shift = -shift;                                  }                                  shift = c/(b + shift);                              }                              double f = (sk + sp)*(sk - sp) + shift;                              double g = sk*ek;                                // Chase zeros.                                for (int j = k; j < p - 1; j++)                              {                                  double t = EncogMath.Hypot(f' g);                                  double cs = f/t;                                  double sn = g/t;                                  if (j != k)                                  {                                      e[j - 1] = t;                                  }                                  f = cs*s[j] + sn*e[j];                                  e[j] = cs*e[j] - sn*s[j];                                  g = sn*s[j + 1];                                  s[j + 1] = cs*s[j + 1];                                  if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*vmatrix[i][j] + sn*vmatrix[i][j + 1];                                          vmatrix[i][j + 1] = -sn*vmatrix[i][j] + cs*vmatrix[i][j + 1];                                          vmatrix[i][j] = t;                                      }                                  }                                  t = EncogMath.Hypot(f' g);                                  cs = f/t;                                  sn = g/t;                                  s[j] = t;                                  f = cs*e[j] + sn*s[j + 1];                                  s[j + 1] = -sn*e[j] + cs*s[j + 1];                                  g = sn*e[j + 1];                                  e[j + 1] = cs*e[j + 1];                                  if (wantu && (j < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*umatrix[i][j] + sn*umatrix[i][j + 1];                                          umatrix[i][j + 1] = -sn*umatrix[i][j] + cs*umatrix[i][j + 1];                                          umatrix[i][j] = t;                                      }                                  }                              }                              e[p - 2] = f;                              iter = iter + 1;                          }                          break;                            // Convergence.                        case 4:                          {                              // Make the singular values positive.                                if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                  if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                      {                                          vmatrix[i][k] = -vmatrix[i][k];                                      }                                  }                              }                                // Order the singular values.                                while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                  {                                      break;                                  }                                  double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                  if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = vmatrix[i][k + 1];                                          vmatrix[i][k + 1] = vmatrix[i][k];                                          vmatrix[i][k] = t;                                      }                                  }                                  if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = umatrix[i][k + 1];                                          umatrix[i][k + 1] = umatrix[i][k];                                          umatrix[i][k] = t;                                      }                                  }                                  k++;                              }                              iter = 0;                              p--;                          }                          break;                  }
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: switch (kase)                  {                          // Deflate negligible s(p).                        case 1:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for (int j = p - 2; j >= k; j--)                              {                                  double t = EncogMath.Hypot(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  if (j != k)                                  {                                      f = -sn*e[j - 1];                                      e[j - 1] = cs*e[j - 1];                                  }                                  if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*vmatrix[i][j] + sn*vmatrix[i][p - 1];                                          vmatrix[i][p - 1] = -sn*vmatrix[i][j] + cs*vmatrix[i][p - 1];                                          vmatrix[i][j] = t;                                      }                                  }                              }                          }                          break;                            // Split at negligible s(k).                        case 2:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for (int j = k; j < p; j++)                              {                                  double t = EncogMath.Hypot(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  f = -sn*e[j];                                  e[j] = cs*e[j];                                  if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*umatrix[i][j] + sn*umatrix[i][k - 1];                                          umatrix[i][k - 1] = -sn*umatrix[i][j] + cs*umatrix[i][k - 1];                                          umatrix[i][j] = t;                                      }                                  }                              }                          }                          break;                            // Perform one qr step.                        case 3:                          {                              // Calculate the shift.                                double scale = Math.Max(Math.Max(Math                                                                   .Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))'                                                                        Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math                                                                                                                  .Abs(                                                                                                                      e[k]));                              double sp = s[p - 1]/scale;                              double spm1 = s[p - 2]/scale;                              double epm1 = e[p - 2]/scale;                              double sk = s[k]/scale;                              double ek = e[k]/scale;                              double b = ((spm1 + sp)*(spm1 - sp) + epm1*epm1)/2.0;                              double c = (sp*epm1)*(sp*epm1);                              double shift = 0.0;                              if ((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt(b*b + c);                                  if (b < 0.0)                                  {                                      shift = -shift;                                  }                                  shift = c/(b + shift);                              }                              double f = (sk + sp)*(sk - sp) + shift;                              double g = sk*ek;                                // Chase zeros.                                for (int j = k; j < p - 1; j++)                              {                                  double t = EncogMath.Hypot(f' g);                                  double cs = f/t;                                  double sn = g/t;                                  if (j != k)                                  {                                      e[j - 1] = t;                                  }                                  f = cs*s[j] + sn*e[j];                                  e[j] = cs*e[j] - sn*s[j];                                  g = sn*s[j + 1];                                  s[j + 1] = cs*s[j + 1];                                  if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*vmatrix[i][j] + sn*vmatrix[i][j + 1];                                          vmatrix[i][j + 1] = -sn*vmatrix[i][j] + cs*vmatrix[i][j + 1];                                          vmatrix[i][j] = t;                                      }                                  }                                  t = EncogMath.Hypot(f' g);                                  cs = f/t;                                  sn = g/t;                                  s[j] = t;                                  f = cs*e[j] + sn*s[j + 1];                                  s[j + 1] = -sn*e[j] + cs*s[j + 1];                                  g = sn*e[j + 1];                                  e[j + 1] = cs*e[j + 1];                                  if (wantu && (j < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*umatrix[i][j] + sn*umatrix[i][j + 1];                                          umatrix[i][j + 1] = -sn*umatrix[i][j] + cs*umatrix[i][j + 1];                                          umatrix[i][j] = t;                                      }                                  }                              }                              e[p - 2] = f;                              iter = iter + 1;                          }                          break;                            // Convergence.                        case 4:                          {                              // Make the singular values positive.                                if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                  if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                      {                                          vmatrix[i][k] = -vmatrix[i][k];                                      }                                  }                              }                                // Order the singular values.                                while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                  {                                      break;                                  }                                  double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                  if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = vmatrix[i][k + 1];                                          vmatrix[i][k + 1] = vmatrix[i][k];                                          vmatrix[i][k] = t;                                      }                                  }                                  if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = umatrix[i][k + 1];                                          umatrix[i][k + 1] = umatrix[i][k];                                          umatrix[i][k] = t;                                      }                                  }                                  k++;                              }                              iter = 0;                              p--;                          }                          break;                  }
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: switch (kase)                  {                          // Deflate negligible s(p).                        case 1:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for (int j = p - 2; j >= k; j--)                              {                                  double t = EncogMath.Hypot(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  if (j != k)                                  {                                      f = -sn*e[j - 1];                                      e[j - 1] = cs*e[j - 1];                                  }                                  if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*vmatrix[i][j] + sn*vmatrix[i][p - 1];                                          vmatrix[i][p - 1] = -sn*vmatrix[i][j] + cs*vmatrix[i][p - 1];                                          vmatrix[i][j] = t;                                      }                                  }                              }                          }                          break;                            // Split at negligible s(k).                        case 2:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for (int j = k; j < p; j++)                              {                                  double t = EncogMath.Hypot(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  f = -sn*e[j];                                  e[j] = cs*e[j];                                  if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*umatrix[i][j] + sn*umatrix[i][k - 1];                                          umatrix[i][k - 1] = -sn*umatrix[i][j] + cs*umatrix[i][k - 1];                                          umatrix[i][j] = t;                                      }                                  }                              }                          }                          break;                            // Perform one qr step.                        case 3:                          {                              // Calculate the shift.                                double scale = Math.Max(Math.Max(Math                                                                   .Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))'                                                                        Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math                                                                                                                  .Abs(                                                                                                                      e[k]));                              double sp = s[p - 1]/scale;                              double spm1 = s[p - 2]/scale;                              double epm1 = e[p - 2]/scale;                              double sk = s[k]/scale;                              double ek = e[k]/scale;                              double b = ((spm1 + sp)*(spm1 - sp) + epm1*epm1)/2.0;                              double c = (sp*epm1)*(sp*epm1);                              double shift = 0.0;                              if ((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt(b*b + c);                                  if (b < 0.0)                                  {                                      shift = -shift;                                  }                                  shift = c/(b + shift);                              }                              double f = (sk + sp)*(sk - sp) + shift;                              double g = sk*ek;                                // Chase zeros.                                for (int j = k; j < p - 1; j++)                              {                                  double t = EncogMath.Hypot(f' g);                                  double cs = f/t;                                  double sn = g/t;                                  if (j != k)                                  {                                      e[j - 1] = t;                                  }                                  f = cs*s[j] + sn*e[j];                                  e[j] = cs*e[j] - sn*s[j];                                  g = sn*s[j + 1];                                  s[j + 1] = cs*s[j + 1];                                  if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*vmatrix[i][j] + sn*vmatrix[i][j + 1];                                          vmatrix[i][j + 1] = -sn*vmatrix[i][j] + cs*vmatrix[i][j + 1];                                          vmatrix[i][j] = t;                                      }                                  }                                  t = EncogMath.Hypot(f' g);                                  cs = f/t;                                  sn = g/t;                                  s[j] = t;                                  f = cs*e[j] + sn*s[j + 1];                                  s[j + 1] = -sn*e[j] + cs*s[j + 1];                                  g = sn*e[j + 1];                                  e[j + 1] = cs*e[j + 1];                                  if (wantu && (j < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*umatrix[i][j] + sn*umatrix[i][j + 1];                                          umatrix[i][j + 1] = -sn*umatrix[i][j] + cs*umatrix[i][j + 1];                                          umatrix[i][j] = t;                                      }                                  }                              }                              e[p - 2] = f;                              iter = iter + 1;                          }                          break;                            // Convergence.                        case 4:                          {                              // Make the singular values positive.                                if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                  if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                      {                                          vmatrix[i][k] = -vmatrix[i][k];                                      }                                  }                              }                                // Order the singular values.                                while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                  {                                      break;                                  }                                  double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                  if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = vmatrix[i][k + 1];                                          vmatrix[i][k + 1] = vmatrix[i][k];                                          vmatrix[i][k] = t;                                      }                                  }                                  if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = umatrix[i][k + 1];                                          umatrix[i][k + 1] = umatrix[i][k];                                          umatrix[i][k] = t;                                      }                                  }                                  k++;                              }                              iter = 0;                              p--;                          }                          break;                  }
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: switch (kase)                  {                          // Deflate negligible s(p).                        case 1:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for (int j = p - 2; j >= k; j--)                              {                                  double t = EncogMath.Hypot(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  if (j != k)                                  {                                      f = -sn*e[j - 1];                                      e[j - 1] = cs*e[j - 1];                                  }                                  if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*vmatrix[i][j] + sn*vmatrix[i][p - 1];                                          vmatrix[i][p - 1] = -sn*vmatrix[i][j] + cs*vmatrix[i][p - 1];                                          vmatrix[i][j] = t;                                      }                                  }                              }                          }                          break;                            // Split at negligible s(k).                        case 2:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for (int j = k; j < p; j++)                              {                                  double t = EncogMath.Hypot(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  f = -sn*e[j];                                  e[j] = cs*e[j];                                  if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*umatrix[i][j] + sn*umatrix[i][k - 1];                                          umatrix[i][k - 1] = -sn*umatrix[i][j] + cs*umatrix[i][k - 1];                                          umatrix[i][j] = t;                                      }                                  }                              }                          }                          break;                            // Perform one qr step.                        case 3:                          {                              // Calculate the shift.                                double scale = Math.Max(Math.Max(Math                                                                   .Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))'                                                                        Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math                                                                                                                  .Abs(                                                                                                                      e[k]));                              double sp = s[p - 1]/scale;                              double spm1 = s[p - 2]/scale;                              double epm1 = e[p - 2]/scale;                              double sk = s[k]/scale;                              double ek = e[k]/scale;                              double b = ((spm1 + sp)*(spm1 - sp) + epm1*epm1)/2.0;                              double c = (sp*epm1)*(sp*epm1);                              double shift = 0.0;                              if ((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt(b*b + c);                                  if (b < 0.0)                                  {                                      shift = -shift;                                  }                                  shift = c/(b + shift);                              }                              double f = (sk + sp)*(sk - sp) + shift;                              double g = sk*ek;                                // Chase zeros.                                for (int j = k; j < p - 1; j++)                              {                                  double t = EncogMath.Hypot(f' g);                                  double cs = f/t;                                  double sn = g/t;                                  if (j != k)                                  {                                      e[j - 1] = t;                                  }                                  f = cs*s[j] + sn*e[j];                                  e[j] = cs*e[j] - sn*s[j];                                  g = sn*s[j + 1];                                  s[j + 1] = cs*s[j + 1];                                  if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*vmatrix[i][j] + sn*vmatrix[i][j + 1];                                          vmatrix[i][j + 1] = -sn*vmatrix[i][j] + cs*vmatrix[i][j + 1];                                          vmatrix[i][j] = t;                                      }                                  }                                  t = EncogMath.Hypot(f' g);                                  cs = f/t;                                  sn = g/t;                                  s[j] = t;                                  f = cs*e[j] + sn*s[j + 1];                                  s[j + 1] = -sn*e[j] + cs*s[j + 1];                                  g = sn*e[j + 1];                                  e[j + 1] = cs*e[j + 1];                                  if (wantu && (j < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*umatrix[i][j] + sn*umatrix[i][j + 1];                                          umatrix[i][j + 1] = -sn*umatrix[i][j] + cs*umatrix[i][j + 1];                                          umatrix[i][j] = t;                                      }                                  }                              }                              e[p - 2] = f;                              iter = iter + 1;                          }                          break;                            // Convergence.                        case 4:                          {                              // Make the singular values positive.                                if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                  if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                      {                                          vmatrix[i][k] = -vmatrix[i][k];                                      }                                  }                              }                                // Order the singular values.                                while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                  {                                      break;                                  }                                  double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                  if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = vmatrix[i][k + 1];                                          vmatrix[i][k + 1] = vmatrix[i][k];                                          vmatrix[i][k] = t;                                      }                                  }                                  if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = umatrix[i][k + 1];                                          umatrix[i][k + 1] = umatrix[i][k];                                          umatrix[i][k] = t;                                      }                                  }                                  k++;                              }                              iter = 0;                              p--;                          }                          break;                  }
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: switch (kase)                  {                          // Deflate negligible s(p).                        case 1:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for (int j = p - 2; j >= k; j--)                              {                                  double t = EncogMath.Hypot(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  if (j != k)                                  {                                      f = -sn*e[j - 1];                                      e[j - 1] = cs*e[j - 1];                                  }                                  if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*vmatrix[i][j] + sn*vmatrix[i][p - 1];                                          vmatrix[i][p - 1] = -sn*vmatrix[i][j] + cs*vmatrix[i][p - 1];                                          vmatrix[i][j] = t;                                      }                                  }                              }                          }                          break;                            // Split at negligible s(k).                        case 2:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for (int j = k; j < p; j++)                              {                                  double t = EncogMath.Hypot(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  f = -sn*e[j];                                  e[j] = cs*e[j];                                  if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*umatrix[i][j] + sn*umatrix[i][k - 1];                                          umatrix[i][k - 1] = -sn*umatrix[i][j] + cs*umatrix[i][k - 1];                                          umatrix[i][j] = t;                                      }                                  }                              }                          }                          break;                            // Perform one qr step.                        case 3:                          {                              // Calculate the shift.                                double scale = Math.Max(Math.Max(Math                                                                   .Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))'                                                                        Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math                                                                                                                  .Abs(                                                                                                                      e[k]));                              double sp = s[p - 1]/scale;                              double spm1 = s[p - 2]/scale;                              double epm1 = e[p - 2]/scale;                              double sk = s[k]/scale;                              double ek = e[k]/scale;                              double b = ((spm1 + sp)*(spm1 - sp) + epm1*epm1)/2.0;                              double c = (sp*epm1)*(sp*epm1);                              double shift = 0.0;                              if ((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt(b*b + c);                                  if (b < 0.0)                                  {                                      shift = -shift;                                  }                                  shift = c/(b + shift);                              }                              double f = (sk + sp)*(sk - sp) + shift;                              double g = sk*ek;                                // Chase zeros.                                for (int j = k; j < p - 1; j++)                              {                                  double t = EncogMath.Hypot(f' g);                                  double cs = f/t;                                  double sn = g/t;                                  if (j != k)                                  {                                      e[j - 1] = t;                                  }                                  f = cs*s[j] + sn*e[j];                                  e[j] = cs*e[j] - sn*s[j];                                  g = sn*s[j + 1];                                  s[j + 1] = cs*s[j + 1];                                  if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*vmatrix[i][j] + sn*vmatrix[i][j + 1];                                          vmatrix[i][j + 1] = -sn*vmatrix[i][j] + cs*vmatrix[i][j + 1];                                          vmatrix[i][j] = t;                                      }                                  }                                  t = EncogMath.Hypot(f' g);                                  cs = f/t;                                  sn = g/t;                                  s[j] = t;                                  f = cs*e[j] + sn*s[j + 1];                                  s[j + 1] = -sn*e[j] + cs*s[j + 1];                                  g = sn*e[j + 1];                                  e[j + 1] = cs*e[j + 1];                                  if (wantu && (j < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*umatrix[i][j] + sn*umatrix[i][j + 1];                                          umatrix[i][j + 1] = -sn*umatrix[i][j] + cs*umatrix[i][j + 1];                                          umatrix[i][j] = t;                                      }                                  }                              }                              e[p - 2] = f;                              iter = iter + 1;                          }                          break;                            // Convergence.                        case 4:                          {                              // Make the singular values positive.                                if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                  if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                      {                                          vmatrix[i][k] = -vmatrix[i][k];                                      }                                  }                              }                                // Order the singular values.                                while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                  {                                      break;                                  }                                  double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                  if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = vmatrix[i][k + 1];                                          vmatrix[i][k + 1] = vmatrix[i][k];                                          vmatrix[i][k] = t;                                      }                                  }                                  if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = umatrix[i][k + 1];                                          umatrix[i][k + 1] = umatrix[i][k];                                          umatrix[i][k] = t;                                      }                                  }                                  k++;                              }                              iter = 0;                              p--;                          }                          break;                  }
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: switch (kase)                  {                          // Deflate negligible s(p).                        case 1:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for (int j = p - 2; j >= k; j--)                              {                                  double t = EncogMath.Hypot(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  if (j != k)                                  {                                      f = -sn*e[j - 1];                                      e[j - 1] = cs*e[j - 1];                                  }                                  if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*vmatrix[i][j] + sn*vmatrix[i][p - 1];                                          vmatrix[i][p - 1] = -sn*vmatrix[i][j] + cs*vmatrix[i][p - 1];                                          vmatrix[i][j] = t;                                      }                                  }                              }                          }                          break;                            // Split at negligible s(k).                        case 2:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for (int j = k; j < p; j++)                              {                                  double t = EncogMath.Hypot(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  f = -sn*e[j];                                  e[j] = cs*e[j];                                  if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*umatrix[i][j] + sn*umatrix[i][k - 1];                                          umatrix[i][k - 1] = -sn*umatrix[i][j] + cs*umatrix[i][k - 1];                                          umatrix[i][j] = t;                                      }                                  }                              }                          }                          break;                            // Perform one qr step.                        case 3:                          {                              // Calculate the shift.                                double scale = Math.Max(Math.Max(Math                                                                   .Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))'                                                                        Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math                                                                                                                  .Abs(                                                                                                                      e[k]));                              double sp = s[p - 1]/scale;                              double spm1 = s[p - 2]/scale;                              double epm1 = e[p - 2]/scale;                              double sk = s[k]/scale;                              double ek = e[k]/scale;                              double b = ((spm1 + sp)*(spm1 - sp) + epm1*epm1)/2.0;                              double c = (sp*epm1)*(sp*epm1);                              double shift = 0.0;                              if ((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt(b*b + c);                                  if (b < 0.0)                                  {                                      shift = -shift;                                  }                                  shift = c/(b + shift);                              }                              double f = (sk + sp)*(sk - sp) + shift;                              double g = sk*ek;                                // Chase zeros.                                for (int j = k; j < p - 1; j++)                              {                                  double t = EncogMath.Hypot(f' g);                                  double cs = f/t;                                  double sn = g/t;                                  if (j != k)                                  {                                      e[j - 1] = t;                                  }                                  f = cs*s[j] + sn*e[j];                                  e[j] = cs*e[j] - sn*s[j];                                  g = sn*s[j + 1];                                  s[j + 1] = cs*s[j + 1];                                  if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*vmatrix[i][j] + sn*vmatrix[i][j + 1];                                          vmatrix[i][j + 1] = -sn*vmatrix[i][j] + cs*vmatrix[i][j + 1];                                          vmatrix[i][j] = t;                                      }                                  }                                  t = EncogMath.Hypot(f' g);                                  cs = f/t;                                  sn = g/t;                                  s[j] = t;                                  f = cs*e[j] + sn*s[j + 1];                                  s[j + 1] = -sn*e[j] + cs*s[j + 1];                                  g = sn*e[j + 1];                                  e[j + 1] = cs*e[j + 1];                                  if (wantu && (j < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*umatrix[i][j] + sn*umatrix[i][j + 1];                                          umatrix[i][j + 1] = -sn*umatrix[i][j] + cs*umatrix[i][j + 1];                                          umatrix[i][j] = t;                                      }                                  }                              }                              e[p - 2] = f;                              iter = iter + 1;                          }                          break;                            // Convergence.                        case 4:                          {                              // Make the singular values positive.                                if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                  if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                      {                                          vmatrix[i][k] = -vmatrix[i][k];                                      }                                  }                              }                                // Order the singular values.                                while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                  {                                      break;                                  }                                  double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                  if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = vmatrix[i][k + 1];                                          vmatrix[i][k + 1] = vmatrix[i][k];                                          vmatrix[i][k] = t;                                      }                                  }                                  if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = umatrix[i][k + 1];                                          umatrix[i][k + 1] = umatrix[i][k];                                          umatrix[i][k] = t;                                      }                                  }                                  k++;                              }                              iter = 0;                              p--;                          }                          break;                  }
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: switch (kase)                  {                          // Deflate negligible s(p).                        case 1:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for (int j = p - 2; j >= k; j--)                              {                                  double t = EncogMath.Hypot(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  if (j != k)                                  {                                      f = -sn*e[j - 1];                                      e[j - 1] = cs*e[j - 1];                                  }                                  if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*vmatrix[i][j] + sn*vmatrix[i][p - 1];                                          vmatrix[i][p - 1] = -sn*vmatrix[i][j] + cs*vmatrix[i][p - 1];                                          vmatrix[i][j] = t;                                      }                                  }                              }                          }                          break;                            // Split at negligible s(k).                        case 2:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for (int j = k; j < p; j++)                              {                                  double t = EncogMath.Hypot(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  f = -sn*e[j];                                  e[j] = cs*e[j];                                  if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*umatrix[i][j] + sn*umatrix[i][k - 1];                                          umatrix[i][k - 1] = -sn*umatrix[i][j] + cs*umatrix[i][k - 1];                                          umatrix[i][j] = t;                                      }                                  }                              }                          }                          break;                            // Perform one qr step.                        case 3:                          {                              // Calculate the shift.                                double scale = Math.Max(Math.Max(Math                                                                   .Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))'                                                                        Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math                                                                                                                  .Abs(                                                                                                                      e[k]));                              double sp = s[p - 1]/scale;                              double spm1 = s[p - 2]/scale;                              double epm1 = e[p - 2]/scale;                              double sk = s[k]/scale;                              double ek = e[k]/scale;                              double b = ((spm1 + sp)*(spm1 - sp) + epm1*epm1)/2.0;                              double c = (sp*epm1)*(sp*epm1);                              double shift = 0.0;                              if ((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt(b*b + c);                                  if (b < 0.0)                                  {                                      shift = -shift;                                  }                                  shift = c/(b + shift);                              }                              double f = (sk + sp)*(sk - sp) + shift;                              double g = sk*ek;                                // Chase zeros.                                for (int j = k; j < p - 1; j++)                              {                                  double t = EncogMath.Hypot(f' g);                                  double cs = f/t;                                  double sn = g/t;                                  if (j != k)                                  {                                      e[j - 1] = t;                                  }                                  f = cs*s[j] + sn*e[j];                                  e[j] = cs*e[j] - sn*s[j];                                  g = sn*s[j + 1];                                  s[j + 1] = cs*s[j + 1];                                  if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*vmatrix[i][j] + sn*vmatrix[i][j + 1];                                          vmatrix[i][j + 1] = -sn*vmatrix[i][j] + cs*vmatrix[i][j + 1];                                          vmatrix[i][j] = t;                                      }                                  }                                  t = EncogMath.Hypot(f' g);                                  cs = f/t;                                  sn = g/t;                                  s[j] = t;                                  f = cs*e[j] + sn*s[j + 1];                                  s[j + 1] = -sn*e[j] + cs*s[j + 1];                                  g = sn*e[j + 1];                                  e[j + 1] = cs*e[j + 1];                                  if (wantu && (j < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*umatrix[i][j] + sn*umatrix[i][j + 1];                                          umatrix[i][j + 1] = -sn*umatrix[i][j] + cs*umatrix[i][j + 1];                                          umatrix[i][j] = t;                                      }                                  }                              }                              e[p - 2] = f;                              iter = iter + 1;                          }                          break;                            // Convergence.                        case 4:                          {                              // Make the singular values positive.                                if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                  if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                      {                                          vmatrix[i][k] = -vmatrix[i][k];                                      }                                  }                              }                                // Order the singular values.                                while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                  {                                      break;                                  }                                  double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                  if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = vmatrix[i][k + 1];                                          vmatrix[i][k + 1] = vmatrix[i][k];                                          vmatrix[i][k] = t;                                      }                                  }                                  if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = umatrix[i][k + 1];                                          umatrix[i][k + 1] = umatrix[i][k];                                          umatrix[i][k] = t;                                      }                                  }                                  k++;                              }                              iter = 0;                              p--;                          }                          break;                  }
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: switch (kase)                  {                          // Deflate negligible s(p).                        case 1:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for (int j = p - 2; j >= k; j--)                              {                                  double t = EncogMath.Hypot(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  if (j != k)                                  {                                      f = -sn*e[j - 1];                                      e[j - 1] = cs*e[j - 1];                                  }                                  if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*vmatrix[i][j] + sn*vmatrix[i][p - 1];                                          vmatrix[i][p - 1] = -sn*vmatrix[i][j] + cs*vmatrix[i][p - 1];                                          vmatrix[i][j] = t;                                      }                                  }                              }                          }                          break;                            // Split at negligible s(k).                        case 2:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for (int j = k; j < p; j++)                              {                                  double t = EncogMath.Hypot(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  f = -sn*e[j];                                  e[j] = cs*e[j];                                  if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*umatrix[i][j] + sn*umatrix[i][k - 1];                                          umatrix[i][k - 1] = -sn*umatrix[i][j] + cs*umatrix[i][k - 1];                                          umatrix[i][j] = t;                                      }                                  }                              }                          }                          break;                            // Perform one qr step.                        case 3:                          {                              // Calculate the shift.                                double scale = Math.Max(Math.Max(Math                                                                   .Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))'                                                                        Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math                                                                                                                  .Abs(                                                                                                                      e[k]));                              double sp = s[p - 1]/scale;                              double spm1 = s[p - 2]/scale;                              double epm1 = e[p - 2]/scale;                              double sk = s[k]/scale;                              double ek = e[k]/scale;                              double b = ((spm1 + sp)*(spm1 - sp) + epm1*epm1)/2.0;                              double c = (sp*epm1)*(sp*epm1);                              double shift = 0.0;                              if ((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt(b*b + c);                                  if (b < 0.0)                                  {                                      shift = -shift;                                  }                                  shift = c/(b + shift);                              }                              double f = (sk + sp)*(sk - sp) + shift;                              double g = sk*ek;                                // Chase zeros.                                for (int j = k; j < p - 1; j++)                              {                                  double t = EncogMath.Hypot(f' g);                                  double cs = f/t;                                  double sn = g/t;                                  if (j != k)                                  {                                      e[j - 1] = t;                                  }                                  f = cs*s[j] + sn*e[j];                                  e[j] = cs*e[j] - sn*s[j];                                  g = sn*s[j + 1];                                  s[j + 1] = cs*s[j + 1];                                  if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*vmatrix[i][j] + sn*vmatrix[i][j + 1];                                          vmatrix[i][j + 1] = -sn*vmatrix[i][j] + cs*vmatrix[i][j + 1];                                          vmatrix[i][j] = t;                                      }                                  }                                  t = EncogMath.Hypot(f' g);                                  cs = f/t;                                  sn = g/t;                                  s[j] = t;                                  f = cs*e[j] + sn*s[j + 1];                                  s[j + 1] = -sn*e[j] + cs*s[j + 1];                                  g = sn*e[j + 1];                                  e[j + 1] = cs*e[j + 1];                                  if (wantu && (j < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*umatrix[i][j] + sn*umatrix[i][j + 1];                                          umatrix[i][j + 1] = -sn*umatrix[i][j] + cs*umatrix[i][j + 1];                                          umatrix[i][j] = t;                                      }                                  }                              }                              e[p - 2] = f;                              iter = iter + 1;                          }                          break;                            // Convergence.                        case 4:                          {                              // Make the singular values positive.                                if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                  if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                      {                                          vmatrix[i][k] = -vmatrix[i][k];                                      }                                  }                              }                                // Order the singular values.                                while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                  {                                      break;                                  }                                  double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                  if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = vmatrix[i][k + 1];                                          vmatrix[i][k + 1] = vmatrix[i][k];                                          vmatrix[i][k] = t;                                      }                                  }                                  if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = umatrix[i][k + 1];                                          umatrix[i][k + 1] = umatrix[i][k];                                          umatrix[i][k] = t;                                      }                                  }                                  k++;                              }                              iter = 0;                              p--;                          }                          break;                  }
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: switch (kase)                  {                          // Deflate negligible s(p).                        case 1:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for (int j = p - 2; j >= k; j--)                              {                                  double t = EncogMath.Hypot(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  if (j != k)                                  {                                      f = -sn*e[j - 1];                                      e[j - 1] = cs*e[j - 1];                                  }                                  if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*vmatrix[i][j] + sn*vmatrix[i][p - 1];                                          vmatrix[i][p - 1] = -sn*vmatrix[i][j] + cs*vmatrix[i][p - 1];                                          vmatrix[i][j] = t;                                      }                                  }                              }                          }                          break;                            // Split at negligible s(k).                        case 2:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for (int j = k; j < p; j++)                              {                                  double t = EncogMath.Hypot(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  f = -sn*e[j];                                  e[j] = cs*e[j];                                  if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*umatrix[i][j] + sn*umatrix[i][k - 1];                                          umatrix[i][k - 1] = -sn*umatrix[i][j] + cs*umatrix[i][k - 1];                                          umatrix[i][j] = t;                                      }                                  }                              }                          }                          break;                            // Perform one qr step.                        case 3:                          {                              // Calculate the shift.                                double scale = Math.Max(Math.Max(Math                                                                   .Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))'                                                                        Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math                                                                                                                  .Abs(                                                                                                                      e[k]));                              double sp = s[p - 1]/scale;                              double spm1 = s[p - 2]/scale;                              double epm1 = e[p - 2]/scale;                              double sk = s[k]/scale;                              double ek = e[k]/scale;                              double b = ((spm1 + sp)*(spm1 - sp) + epm1*epm1)/2.0;                              double c = (sp*epm1)*(sp*epm1);                              double shift = 0.0;                              if ((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt(b*b + c);                                  if (b < 0.0)                                  {                                      shift = -shift;                                  }                                  shift = c/(b + shift);                              }                              double f = (sk + sp)*(sk - sp) + shift;                              double g = sk*ek;                                // Chase zeros.                                for (int j = k; j < p - 1; j++)                              {                                  double t = EncogMath.Hypot(f' g);                                  double cs = f/t;                                  double sn = g/t;                                  if (j != k)                                  {                                      e[j - 1] = t;                                  }                                  f = cs*s[j] + sn*e[j];                                  e[j] = cs*e[j] - sn*s[j];                                  g = sn*s[j + 1];                                  s[j + 1] = cs*s[j + 1];                                  if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*vmatrix[i][j] + sn*vmatrix[i][j + 1];                                          vmatrix[i][j + 1] = -sn*vmatrix[i][j] + cs*vmatrix[i][j + 1];                                          vmatrix[i][j] = t;                                      }                                  }                                  t = EncogMath.Hypot(f' g);                                  cs = f/t;                                  sn = g/t;                                  s[j] = t;                                  f = cs*e[j] + sn*s[j + 1];                                  s[j + 1] = -sn*e[j] + cs*s[j + 1];                                  g = sn*e[j + 1];                                  e[j + 1] = cs*e[j + 1];                                  if (wantu && (j < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*umatrix[i][j] + sn*umatrix[i][j + 1];                                          umatrix[i][j + 1] = -sn*umatrix[i][j] + cs*umatrix[i][j + 1];                                          umatrix[i][j] = t;                                      }                                  }                              }                              e[p - 2] = f;                              iter = iter + 1;                          }                          break;                            // Convergence.                        case 4:                          {                              // Make the singular values positive.                                if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                  if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                      {                                          vmatrix[i][k] = -vmatrix[i][k];                                      }                                  }                              }                                // Order the singular values.                                while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                  {                                      break;                                  }                                  double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                  if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = vmatrix[i][k + 1];                                          vmatrix[i][k + 1] = vmatrix[i][k];                                          vmatrix[i][k] = t;                                      }                                  }                                  if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = umatrix[i][k + 1];                                          umatrix[i][k + 1] = umatrix[i][k];                                          umatrix[i][k] = t;                                      }                                  }                                  k++;                              }                              iter = 0;                              p--;                          }                          break;                  }
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: switch (kase)                  {                          // Deflate negligible s(p).                        case 1:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for (int j = p - 2; j >= k; j--)                              {                                  double t = EncogMath.Hypot(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  if (j != k)                                  {                                      f = -sn*e[j - 1];                                      e[j - 1] = cs*e[j - 1];                                  }                                  if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*vmatrix[i][j] + sn*vmatrix[i][p - 1];                                          vmatrix[i][p - 1] = -sn*vmatrix[i][j] + cs*vmatrix[i][p - 1];                                          vmatrix[i][j] = t;                                      }                                  }                              }                          }                          break;                            // Split at negligible s(k).                        case 2:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for (int j = k; j < p; j++)                              {                                  double t = EncogMath.Hypot(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  f = -sn*e[j];                                  e[j] = cs*e[j];                                  if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*umatrix[i][j] + sn*umatrix[i][k - 1];                                          umatrix[i][k - 1] = -sn*umatrix[i][j] + cs*umatrix[i][k - 1];                                          umatrix[i][j] = t;                                      }                                  }                              }                          }                          break;                            // Perform one qr step.                        case 3:                          {                              // Calculate the shift.                                double scale = Math.Max(Math.Max(Math                                                                   .Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))'                                                                        Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math                                                                                                                  .Abs(                                                                                                                      e[k]));                              double sp = s[p - 1]/scale;                              double spm1 = s[p - 2]/scale;                              double epm1 = e[p - 2]/scale;                              double sk = s[k]/scale;                              double ek = e[k]/scale;                              double b = ((spm1 + sp)*(spm1 - sp) + epm1*epm1)/2.0;                              double c = (sp*epm1)*(sp*epm1);                              double shift = 0.0;                              if ((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt(b*b + c);                                  if (b < 0.0)                                  {                                      shift = -shift;                                  }                                  shift = c/(b + shift);                              }                              double f = (sk + sp)*(sk - sp) + shift;                              double g = sk*ek;                                // Chase zeros.                                for (int j = k; j < p - 1; j++)                              {                                  double t = EncogMath.Hypot(f' g);                                  double cs = f/t;                                  double sn = g/t;                                  if (j != k)                                  {                                      e[j - 1] = t;                                  }                                  f = cs*s[j] + sn*e[j];                                  e[j] = cs*e[j] - sn*s[j];                                  g = sn*s[j + 1];                                  s[j + 1] = cs*s[j + 1];                                  if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*vmatrix[i][j] + sn*vmatrix[i][j + 1];                                          vmatrix[i][j + 1] = -sn*vmatrix[i][j] + cs*vmatrix[i][j + 1];                                          vmatrix[i][j] = t;                                      }                                  }                                  t = EncogMath.Hypot(f' g);                                  cs = f/t;                                  sn = g/t;                                  s[j] = t;                                  f = cs*e[j] + sn*s[j + 1];                                  s[j + 1] = -sn*e[j] + cs*s[j + 1];                                  g = sn*e[j + 1];                                  e[j + 1] = cs*e[j + 1];                                  if (wantu && (j < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*umatrix[i][j] + sn*umatrix[i][j + 1];                                          umatrix[i][j + 1] = -sn*umatrix[i][j] + cs*umatrix[i][j + 1];                                          umatrix[i][j] = t;                                      }                                  }                              }                              e[p - 2] = f;                              iter = iter + 1;                          }                          break;                            // Convergence.                        case 4:                          {                              // Make the singular values positive.                                if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                  if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                      {                                          vmatrix[i][k] = -vmatrix[i][k];                                      }                                  }                              }                                // Order the singular values.                                while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                  {                                      break;                                  }                                  double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                  if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = vmatrix[i][k + 1];                                          vmatrix[i][k + 1] = vmatrix[i][k];                                          vmatrix[i][k] = t;                                      }                                  }                                  if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = umatrix[i][k + 1];                                          umatrix[i][k + 1] = umatrix[i][k];                                          umatrix[i][k] = t;                                      }                                  }                                  k++;                              }                              iter = 0;                              p--;                          }                          break;                  }
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: switch (kase)                  {                          // Deflate negligible s(p).                        case 1:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for (int j = p - 2; j >= k; j--)                              {                                  double t = EncogMath.Hypot(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  if (j != k)                                  {                                      f = -sn*e[j - 1];                                      e[j - 1] = cs*e[j - 1];                                  }                                  if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*vmatrix[i][j] + sn*vmatrix[i][p - 1];                                          vmatrix[i][p - 1] = -sn*vmatrix[i][j] + cs*vmatrix[i][p - 1];                                          vmatrix[i][j] = t;                                      }                                  }                              }                          }                          break;                            // Split at negligible s(k).                        case 2:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for (int j = k; j < p; j++)                              {                                  double t = EncogMath.Hypot(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  f = -sn*e[j];                                  e[j] = cs*e[j];                                  if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*umatrix[i][j] + sn*umatrix[i][k - 1];                                          umatrix[i][k - 1] = -sn*umatrix[i][j] + cs*umatrix[i][k - 1];                                          umatrix[i][j] = t;                                      }                                  }                              }                          }                          break;                            // Perform one qr step.                        case 3:                          {                              // Calculate the shift.                                double scale = Math.Max(Math.Max(Math                                                                   .Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))'                                                                        Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math                                                                                                                  .Abs(                                                                                                                      e[k]));                              double sp = s[p - 1]/scale;                              double spm1 = s[p - 2]/scale;                              double epm1 = e[p - 2]/scale;                              double sk = s[k]/scale;                              double ek = e[k]/scale;                              double b = ((spm1 + sp)*(spm1 - sp) + epm1*epm1)/2.0;                              double c = (sp*epm1)*(sp*epm1);                              double shift = 0.0;                              if ((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt(b*b + c);                                  if (b < 0.0)                                  {                                      shift = -shift;                                  }                                  shift = c/(b + shift);                              }                              double f = (sk + sp)*(sk - sp) + shift;                              double g = sk*ek;                                // Chase zeros.                                for (int j = k; j < p - 1; j++)                              {                                  double t = EncogMath.Hypot(f' g);                                  double cs = f/t;                                  double sn = g/t;                                  if (j != k)                                  {                                      e[j - 1] = t;                                  }                                  f = cs*s[j] + sn*e[j];                                  e[j] = cs*e[j] - sn*s[j];                                  g = sn*s[j + 1];                                  s[j + 1] = cs*s[j + 1];                                  if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*vmatrix[i][j] + sn*vmatrix[i][j + 1];                                          vmatrix[i][j + 1] = -sn*vmatrix[i][j] + cs*vmatrix[i][j + 1];                                          vmatrix[i][j] = t;                                      }                                  }                                  t = EncogMath.Hypot(f' g);                                  cs = f/t;                                  sn = g/t;                                  s[j] = t;                                  f = cs*e[j] + sn*s[j + 1];                                  s[j + 1] = -sn*e[j] + cs*s[j + 1];                                  g = sn*e[j + 1];                                  e[j + 1] = cs*e[j + 1];                                  if (wantu && (j < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*umatrix[i][j] + sn*umatrix[i][j + 1];                                          umatrix[i][j + 1] = -sn*umatrix[i][j] + cs*umatrix[i][j + 1];                                          umatrix[i][j] = t;                                      }                                  }                              }                              e[p - 2] = f;                              iter = iter + 1;                          }                          break;                            // Convergence.                        case 4:                          {                              // Make the singular values positive.                                if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                  if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                      {                                          vmatrix[i][k] = -vmatrix[i][k];                                      }                                  }                              }                                // Order the singular values.                                while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                  {                                      break;                                  }                                  double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                  if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = vmatrix[i][k + 1];                                          vmatrix[i][k + 1] = vmatrix[i][k];                                          vmatrix[i][k] = t;                                      }                                  }                                  if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = umatrix[i][k + 1];                                          umatrix[i][k + 1] = umatrix[i][k];                                          umatrix[i][k] = t;                                      }                                  }                                  k++;                              }                              iter = 0;                              p--;                          }                          break;                  }
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: switch (kase)                  {                          // Deflate negligible s(p).                        case 1:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for (int j = p - 2; j >= k; j--)                              {                                  double t = EncogMath.Hypot(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  if (j != k)                                  {                                      f = -sn*e[j - 1];                                      e[j - 1] = cs*e[j - 1];                                  }                                  if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*vmatrix[i][j] + sn*vmatrix[i][p - 1];                                          vmatrix[i][p - 1] = -sn*vmatrix[i][j] + cs*vmatrix[i][p - 1];                                          vmatrix[i][j] = t;                                      }                                  }                              }                          }                          break;                            // Split at negligible s(k).                        case 2:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for (int j = k; j < p; j++)                              {                                  double t = EncogMath.Hypot(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  f = -sn*e[j];                                  e[j] = cs*e[j];                                  if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*umatrix[i][j] + sn*umatrix[i][k - 1];                                          umatrix[i][k - 1] = -sn*umatrix[i][j] + cs*umatrix[i][k - 1];                                          umatrix[i][j] = t;                                      }                                  }                              }                          }                          break;                            // Perform one qr step.                        case 3:                          {                              // Calculate the shift.                                double scale = Math.Max(Math.Max(Math                                                                   .Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))'                                                                        Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math                                                                                                                  .Abs(                                                                                                                      e[k]));                              double sp = s[p - 1]/scale;                              double spm1 = s[p - 2]/scale;                              double epm1 = e[p - 2]/scale;                              double sk = s[k]/scale;                              double ek = e[k]/scale;                              double b = ((spm1 + sp)*(spm1 - sp) + epm1*epm1)/2.0;                              double c = (sp*epm1)*(sp*epm1);                              double shift = 0.0;                              if ((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt(b*b + c);                                  if (b < 0.0)                                  {                                      shift = -shift;                                  }                                  shift = c/(b + shift);                              }                              double f = (sk + sp)*(sk - sp) + shift;                              double g = sk*ek;                                // Chase zeros.                                for (int j = k; j < p - 1; j++)                              {                                  double t = EncogMath.Hypot(f' g);                                  double cs = f/t;                                  double sn = g/t;                                  if (j != k)                                  {                                      e[j - 1] = t;                                  }                                  f = cs*s[j] + sn*e[j];                                  e[j] = cs*e[j] - sn*s[j];                                  g = sn*s[j + 1];                                  s[j + 1] = cs*s[j + 1];                                  if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*vmatrix[i][j] + sn*vmatrix[i][j + 1];                                          vmatrix[i][j + 1] = -sn*vmatrix[i][j] + cs*vmatrix[i][j + 1];                                          vmatrix[i][j] = t;                                      }                                  }                                  t = EncogMath.Hypot(f' g);                                  cs = f/t;                                  sn = g/t;                                  s[j] = t;                                  f = cs*e[j] + sn*s[j + 1];                                  s[j + 1] = -sn*e[j] + cs*s[j + 1];                                  g = sn*e[j + 1];                                  e[j + 1] = cs*e[j + 1];                                  if (wantu && (j < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*umatrix[i][j] + sn*umatrix[i][j + 1];                                          umatrix[i][j + 1] = -sn*umatrix[i][j] + cs*umatrix[i][j + 1];                                          umatrix[i][j] = t;                                      }                                  }                              }                              e[p - 2] = f;                              iter = iter + 1;                          }                          break;                            // Convergence.                        case 4:                          {                              // Make the singular values positive.                                if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                  if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                      {                                          vmatrix[i][k] = -vmatrix[i][k];                                      }                                  }                              }                                // Order the singular values.                                while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                  {                                      break;                                  }                                  double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                  if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = vmatrix[i][k + 1];                                          vmatrix[i][k + 1] = vmatrix[i][k];                                          vmatrix[i][k] = t;                                      }                                  }                                  if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = umatrix[i][k + 1];                                          umatrix[i][k + 1] = umatrix[i][k];                                          umatrix[i][k] = t;                                      }                                  }                                  k++;                              }                              iter = 0;                              p--;                          }                          break;                  }
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,Rank,The following statement contains a magic number: double eps = Math.Pow(2.0' -52.0);
Magic Number,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,Rank,The following statement contains a magic number: double eps = Math.Pow(2.0' -52.0);
Magic Number,Encog.MathUtil.Matrices.Hessian,HessianCR,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Hessian\HessianCR.cs,Compute,The following statement contains a magic number: _sse = e/2;
Magic Number,Encog.MathUtil.Matrices.Hessian,HessianFD,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Hessian\HessianFD.cs,HessianFD,The following statement contains a magic number: PointsPerSide = 5;
Magic Number,Encog.MathUtil.Matrices.Hessian,HessianFD,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Hessian\HessianFD.cs,Init,The following statement contains a magic number: _pointCount = (PointsPerSide*2) + 1;
Magic Number,Encog.MathUtil.Matrices.Hessian,HessianFD,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Hessian\HessianFD.cs,InternalCompute,The following statement contains a magic number: int outputFeedCount = _network.GetLayerTotalNeuronCount(_network.LayerCount - 2);
Magic Number,Encog.MathUtil.Randomize,BasicRandomizer,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\BasicRandomizer.cs,BasicRandomizer,The following statement contains a magic number: _random = new Random((int) (DateTime.Now.Ticks*100));
Magic Number,Encog.MathUtil.Randomize,Distort,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Distort.cs,Randomize,The following statement contains a magic number: return d + (_factor - (NextDouble()*_factor*2));
Magic Number,Encog.MathUtil.Randomize,NguyenWidrowRandomizer,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\NguyenWidrowRandomizer.cs,RandomizeSynapse,The following statement contains a magic number: double b = 0.7d * Math.Pow(toCount' (1d / fromCount)) / (high - low);
Magic Number,Encog.MathUtil.Randomize.Generate,BasicGenerateRandom,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\BasicGenerateRandom.cs,NextBoolean,The following statement contains a magic number: return _rnd.NextDouble() > 0.5;
Magic Number,Encog.MathUtil.Randomize.Generate,LinearCongruentialRandom,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\LinearCongruentialRandom.cs,NextBoolean,The following statement contains a magic number: return NextDouble() > 0.5;
Magic Number,Encog.MathUtil.Randomize.Generate,MersenneTwisterGenerateRandom,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\MersenneTwisterGenerateRandom.cs,SetSeed,The following statement contains a magic number: _mag01 = new UInt32[2];
Magic Number,Encog.MathUtil.Randomize.Generate,MersenneTwisterGenerateRandom,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\MersenneTwisterGenerateRandom.cs,SetSeed,The following statement contains a magic number: _stateVector[_mti] =                          (1812433253 * (_stateVector[_mti - 1] ^ (_stateVector[_mti - 1] >> 30)) + _mti);
Magic Number,Encog.MathUtil.Randomize.Generate,MersenneTwisterGenerateRandom,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\MersenneTwisterGenerateRandom.cs,SetSeed,The following statement contains a magic number: _stateVector[_mti] =                          (1812433253 * (_stateVector[_mti - 1] ^ (_stateVector[_mti - 1] >> 30)) + _mti);
Magic Number,Encog.MathUtil.Randomize.Generate,MersenneTwisterGenerateRandom,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\MersenneTwisterGenerateRandom.cs,SetSeed,The following statement contains a magic number: SetSeed(19650218);
Magic Number,Encog.MathUtil.Randomize.Generate,MersenneTwisterGenerateRandom,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\MersenneTwisterGenerateRandom.cs,SetSeed,The following statement contains a magic number: _stateVector[i] = (uint)((_stateVector[i] ^ ((_stateVector[i - 1] ^ (_stateVector[i - 1] >> 30)) * 1664525U)) + array[j] + j);
Magic Number,Encog.MathUtil.Randomize.Generate,MersenneTwisterGenerateRandom,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\MersenneTwisterGenerateRandom.cs,SetSeed,The following statement contains a magic number: _stateVector[i] = (uint)((_stateVector[i] ^ ((_stateVector[i - 1] ^ (_stateVector[i - 1] >> 30)) * 1664525U)) + array[j] + j);
Magic Number,Encog.MathUtil.Randomize.Generate,MersenneTwisterGenerateRandom,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\MersenneTwisterGenerateRandom.cs,SetSeed,The following statement contains a magic number: _stateVector[i] = (uint)((_stateVector[i] ^ ((_stateVector[i - 1] ^ (_stateVector[i - 1] >> 30)) * 1566083941U)) - i);
Magic Number,Encog.MathUtil.Randomize.Generate,MersenneTwisterGenerateRandom,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\MersenneTwisterGenerateRandom.cs,SetSeed,The following statement contains a magic number: _stateVector[i] = (uint)((_stateVector[i] ^ ((_stateVector[i - 1] ^ (_stateVector[i - 1] >> 30)) * 1566083941U)) - i);
Magic Number,Encog.MathUtil.Randomize.Generate,MersenneTwisterGenerateRandom,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\MersenneTwisterGenerateRandom.cs,Next,The following statement contains a magic number: y ^= y >> 11;
Magic Number,Encog.MathUtil.Randomize.Generate,MersenneTwisterGenerateRandom,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\MersenneTwisterGenerateRandom.cs,Next,The following statement contains a magic number: y ^= (y << 7) & TemperingMaskB;
Magic Number,Encog.MathUtil.Randomize.Generate,MersenneTwisterGenerateRandom,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\MersenneTwisterGenerateRandom.cs,Next,The following statement contains a magic number: y ^= (y << 15) & TemperingMaskC;
Magic Number,Encog.MathUtil.Randomize.Generate,MersenneTwisterGenerateRandom,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\MersenneTwisterGenerateRandom.cs,Next,The following statement contains a magic number: y ^= (y >> 18);
Magic Number,Encog.MathUtil.Randomize.Generate,MersenneTwisterGenerateRandom,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\MersenneTwisterGenerateRandom.cs,Next,The following statement contains a magic number: return y >> (32 - bits);
Magic Number,Encog.MathUtil.Randomize.Generate,MersenneTwisterGenerateRandom,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\MersenneTwisterGenerateRandom.cs,NextDouble,The following statement contains a magic number: return (((long)Next(26) << 27) + Next(27))                      / (double)(1L << 53);
Magic Number,Encog.MathUtil.Randomize.Generate,MersenneTwisterGenerateRandom,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\MersenneTwisterGenerateRandom.cs,NextDouble,The following statement contains a magic number: return (((long)Next(26) << 27) + Next(27))                      / (double)(1L << 53);
Magic Number,Encog.MathUtil.Randomize.Generate,MersenneTwisterGenerateRandom,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\MersenneTwisterGenerateRandom.cs,NextDouble,The following statement contains a magic number: return (((long)Next(26) << 27) + Next(27))                      / (double)(1L << 53);
Magic Number,Encog.MathUtil.Randomize.Generate,MersenneTwisterGenerateRandom,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\MersenneTwisterGenerateRandom.cs,NextDouble,The following statement contains a magic number: return (((long)Next(26) << 27) + Next(27))                      / (double)(1L << 53);
Magic Number,Encog.MathUtil.Randomize.Generate,MersenneTwisterGenerateRandom,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\MersenneTwisterGenerateRandom.cs,NextLong,The following statement contains a magic number: uint u1 = Next(32);
Magic Number,Encog.MathUtil.Randomize.Generate,MersenneTwisterGenerateRandom,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\MersenneTwisterGenerateRandom.cs,NextLong,The following statement contains a magic number: uint u2 = Next(32);
Magic Number,Encog.MathUtil.Randomize.Generate,MersenneTwisterGenerateRandom,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\MersenneTwisterGenerateRandom.cs,NextLong,The following statement contains a magic number: return ((long)u1 << 32) + u2;
Magic Number,Encog.MathUtil.Randomize.Generate,MersenneTwisterGenerateRandom,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\MersenneTwisterGenerateRandom.cs,NextBoolean,The following statement contains a magic number: return NextDouble() > 0.5;
Magic Number,Encog.MathUtil.Randomize.Generate,MultiplyWithCarryGenerateRandom,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\MultiplyWithCarryGenerateRandom.cs,NextDouble,The following statement contains a magic number: return (((long)Next(26) << 27) + Next(27))                      / (double)(1L << 53);
Magic Number,Encog.MathUtil.Randomize.Generate,MultiplyWithCarryGenerateRandom,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\MultiplyWithCarryGenerateRandom.cs,NextDouble,The following statement contains a magic number: return (((long)Next(26) << 27) + Next(27))                      / (double)(1L << 53);
Magic Number,Encog.MathUtil.Randomize.Generate,MultiplyWithCarryGenerateRandom,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\MultiplyWithCarryGenerateRandom.cs,NextDouble,The following statement contains a magic number: return (((long)Next(26) << 27) + Next(27))                      / (double)(1L << 53);
Magic Number,Encog.MathUtil.Randomize.Generate,MultiplyWithCarryGenerateRandom,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\MultiplyWithCarryGenerateRandom.cs,NextDouble,The following statement contains a magic number: return (((long)Next(26) << 27) + Next(27))                      / (double)(1L << 53);
Magic Number,Encog.MathUtil.Randomize.Generate,MultiplyWithCarryGenerateRandom,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\MultiplyWithCarryGenerateRandom.cs,Next,The following statement contains a magic number: long d32 = t >> 32;
Magic Number,Encog.MathUtil.Randomize.Generate,MultiplyWithCarryGenerateRandom,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\MultiplyWithCarryGenerateRandom.cs,Next,The following statement contains a magic number: _seed[_n] = 0xFFFFFFFEL - (t & 0xFFFFFFFFL) - (_c - d32 << 32) - _c & 0xFFFFFFFFL;
Magic Number,Encog.MathUtil.Randomize.Generate,MultiplyWithCarryGenerateRandom,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\MultiplyWithCarryGenerateRandom.cs,Next,The following statement contains a magic number: return (int)(result >> 32 - bits);
Magic Number,Encog.MathUtil.Randomize.Generate,MultiplyWithCarryGenerateRandom,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\MultiplyWithCarryGenerateRandom.cs,SetR,The following statement contains a magic number: theR = 256;
Magic Number,Encog.MathUtil.Randomize.Generate,MultiplyWithCarryGenerateRandom,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\MultiplyWithCarryGenerateRandom.cs,NextLong,The following statement contains a magic number: return ((long)Next(32) << 32) + Next(32);
Magic Number,Encog.MathUtil.Randomize.Generate,MultiplyWithCarryGenerateRandom,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\MultiplyWithCarryGenerateRandom.cs,NextLong,The following statement contains a magic number: return ((long)Next(32) << 32) + Next(32);
Magic Number,Encog.MathUtil.Randomize.Generate,MultiplyWithCarryGenerateRandom,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\MultiplyWithCarryGenerateRandom.cs,NextLong,The following statement contains a magic number: return ((long)Next(32) << 32) + Next(32);
Magic Number,Encog.MathUtil.Randomize.Generate,MultiplyWithCarryGenerateRandom,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\MultiplyWithCarryGenerateRandom.cs,NextBoolean,The following statement contains a magic number: return NextDouble() > 0.5;
Magic Number,Encog.MathUtil.Randomize.Generate,SecureGenerateRandom,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\SecureGenerateRandom.cs,NextDouble,The following statement contains a magic number: var result = new byte[8];
Magic Number,Encog.MathUtil.Randomize.Generate,SecureGenerateRandom,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\SecureGenerateRandom.cs,NextBoolean,The following statement contains a magic number: return NextDouble() > 0.5;
Magic Number,Encog.MathUtil.Randomize.Generate,SecureGenerateRandom,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\SecureGenerateRandom.cs,NextFloat,The following statement contains a magic number: var result = new byte[4];
Magic Number,Encog.MathUtil.Randomize.Generate,SecureGenerateRandom,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\SecureGenerateRandom.cs,NextLong,The following statement contains a magic number: var result = new byte[8];
Magic Number,Encog.MathUtil.Randomize.Generate,SecureGenerateRandom,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Randomize\Generate\SecureGenerateRandom.cs,NextInt,The following statement contains a magic number: var result = new byte[4];
Magic Number,Encog.MathUtil.RBF,MexicanHatFunction,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\RBF\MexicanHatFunction.cs,Calculate,The following statement contains a magic number: norm += Math.Pow(x[i] - center[i]' 2) / (2.0 * width * width);
Magic Number,Encog.MathUtil.RBF,MexicanHatFunction,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\RBF\MexicanHatFunction.cs,Calculate,The following statement contains a magic number: norm += Math.Pow(x[i] - center[i]' 2) / (2.0 * width * width);
Magic Number,Encog.MathUtil.RBF,MexicanHatFunction,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\RBF\MexicanHatFunction.cs,Calculate,The following statement contains a magic number: return Peak*(1 - norm)*Math.Exp(-norm/2);
Magic Number,Encog.MathUtil.RBF,GaussianFunction,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\RBF\GaussianFunction.cs,Calculate,The following statement contains a magic number: value += Math.Pow(x[i] - center[i]' 2)                           /(2.0*width*width);
Magic Number,Encog.MathUtil.RBF,GaussianFunction,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\RBF\GaussianFunction.cs,Calculate,The following statement contains a magic number: value += Math.Pow(x[i] - center[i]' 2)                           /(2.0*width*width);
Magic Number,Encog.ML.Bayesian,BayesianChoice,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Bayesian\BayesianChoice.cs,ToFullString,The following statement contains a magic number: result.Append(CSVFormat.EgFormat.Format(Min' 4));
Magic Number,Encog.ML.Bayesian,BayesianChoice,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Bayesian\BayesianChoice.cs,ToFullString,The following statement contains a magic number: result.Append(CSVFormat.EgFormat.Format(Max' 4));
Magic Number,Encog.ML.Bayesian.Parse,ParseProbability,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Bayesian\Parse\ParseProbability.cs,AddEvents,The following statement contains a magic number: parser.Advance(2);
Magic Number,Encog.ML.Bayesian.Parse,ParseProbability,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Bayesian\Parse\ParseProbability.cs,Parse,The following statement contains a magic number: parser.Advance(2);
Magic Number,Encog.ML.Bayesian.Query,EventState,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Bayesian\Query\EventState.cs,ToString,The following statement contains a magic number: result.Append(Format.FormatDouble(_value' 2));
Magic Number,Encog.ML.Bayesian.Query,EventState,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Bayesian\Query\EventState.cs,ToString,The following statement contains a magic number: result.Append(Format.FormatDouble(CompareValue' 2));
Magic Number,Encog.ML.Bayesian.Table,TableLine,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Bayesian\Table\TableLine.cs,ToString,The following statement contains a magic number: r.Append(Format.FormatDouble(Probability' 2));
Magic Number,Encog.ML.Bayesian.Table,TableLine,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Bayesian\Table\TableLine.cs,ToString,The following statement contains a magic number: r.Append(Format.FormatDouble(t' 2));
Magic Number,Encog.ML.Data.Buffer,BinaryDataLoader,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Buffer\BinaryDataLoader.cs,External2Binary,The following statement contains a magic number: lastUpdate >= 10000
Magic Number,Encog.ML.Data.Buffer,BinaryDataLoader,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Buffer\BinaryDataLoader.cs,Binary2External,The following statement contains a magic number: lastUpdate >= 10000
Magic Number,Encog.ML.Data.Buffer,MemoryDataLoader,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Buffer\MemoryDataLoader.cs,External2Memory,The following statement contains a magic number: lastUpdate >= 10000
Magic Number,Encog.ML.Data.Dynamic,SlidingWindowMLDataProvider,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Dynamic\Providers\SlidingWindowMLDataProvider.cs,SlidingWindowMLDataProvider,The following statement contains a magic number: list.Count < 2
Magic Number,Encog.ML.Data.Image,ImageMLData,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Image\ImageMLData.cs,Downsample,The following statement contains a magic number: sample[i] = ((sample[i] - 0)                               /(255 - 0))                              *(hi - lo) + lo;
Magic Number,Encog.ML.Data.Market.Loader,CSVFinal,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFinal.cs,ReadAndCallLoader,The following statement contains a magic number: double close = csv.GetDouble(2);
Magic Number,Encog.ML.Data.Market.Loader,CSVFinal,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFinal.cs,ReadAndCallLoader,The following statement contains a magic number: double high = csv.GetDouble(3);
Magic Number,Encog.ML.Data.Market.Loader,CSVFinal,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFinal.cs,ReadAndCallLoader,The following statement contains a magic number: double low = csv.GetDouble(4);
Magic Number,Encog.ML.Data.Market.Loader,CSVFinal,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFinal.cs,ReadAndCallLoader,The following statement contains a magic number: double volume = csv.GetDouble(5);
Magic Number,Encog.ML.Data.Market.Loader,CSVFinal,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFinal.cs,ReadAndCallLoader,The following statement contains a magic number: data.SetData(MarketDataType.RangeHighLow' Math.Round(HighLowRange' 6));
Magic Number,Encog.ML.Data.Market.Loader,CSVFinal,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFinal.cs,ReadAndCallLoader,The following statement contains a magic number: data.SetData(MarketDataType.RangeOpenClose' Math.Round(range' 6));
Magic Number,Encog.ML.Data.Market.Loader,CSVFinal,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFinal.cs,ReadAndCallLoader,The following statement contains a magic number: data.SetData(MarketDataType.RangeOpenCloseNonAbsolute' Math.Round(DirectionalRange' 6));
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,button1_Click,The following statement contains a magic number: openFileDialog1.FilterIndex = (2);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,CSVFormLoader_Load,The following statement contains a magic number: CSVFormatsCombo.SelectedIndex = 2;
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.statusStrip1.Location = new System.Drawing.Point(0' 437);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.statusStrip1.Size = new System.Drawing.Size(391' 22);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.statusStrip1.Size = new System.Drawing.Size(391' 22);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.toolStripStatusLabel1.Size = new System.Drawing.Size(44' 17);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.toolStripStatusLabel1.Size = new System.Drawing.Size(44' 17);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.button1.Location = new System.Drawing.Point(100' 335);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.button1.Location = new System.Drawing.Point(100' 335);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.button1.Size = new System.Drawing.Size(121' 37);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.button1.Size = new System.Drawing.Size(121' 37);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.textBox1.Location = new System.Drawing.Point(66' 403);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.textBox1.Location = new System.Drawing.Point(66' 403);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.textBox1.Size = new System.Drawing.Size(267' 20);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.textBox1.Size = new System.Drawing.Size(267' 20);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.textBox1.TabIndex = 2;
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.CSVFormatsCombo.Location = new System.Drawing.Point(100' 6);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.CSVFormatsCombo.Location = new System.Drawing.Point(100' 6);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.CSVFormatsCombo.Size = new System.Drawing.Size(121' 21);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.CSVFormatsCombo.Size = new System.Drawing.Size(121' 21);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.CSVFormatsCombo.TabIndex = 3;
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point(4' 410);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point(4' 410);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size(59' 13);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size(59' 13);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.label1.TabIndex = 4;
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point(4' 14);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point(4' 14);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size(63' 13);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size(63' 13);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.label2.TabIndex = 5;
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.label3.Location = new System.Drawing.Point(4' 359);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.label3.Location = new System.Drawing.Point(4' 359);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.label3.Size = new System.Drawing.Size(55' 13);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.label3.Size = new System.Drawing.Size(55' 13);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.label3.TabIndex = 6;
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.label4.Location = new System.Drawing.Point(4' 68);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.label4.Location = new System.Drawing.Point(4' 68);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.label4.Size = new System.Drawing.Size(87' 13);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.label4.Size = new System.Drawing.Size(87' 13);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.label4.TabIndex = 7;
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.MarketDataTypesListBox.Location = new System.Drawing.Point(100' 52);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.MarketDataTypesListBox.Location = new System.Drawing.Point(100' 52);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.MarketDataTypesListBox.Size = new System.Drawing.Size(120' 95);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.MarketDataTypesListBox.Size = new System.Drawing.Size(120' 95);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.MarketDataTypesListBox.TabIndex = 8;
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.DateTimeFormatTextBox.Location = new System.Drawing.Point(100' 231);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.DateTimeFormatTextBox.Location = new System.Drawing.Point(100' 231);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.DateTimeFormatTextBox.Size = new System.Drawing.Size(229' 20);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.DateTimeFormatTextBox.Size = new System.Drawing.Size(229' 20);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.DateTimeFormatTextBox.TabIndex = 11;
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.label5.Location = new System.Drawing.Point(7' 237);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.label5.Location = new System.Drawing.Point(7' 237);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.label5.Size = new System.Drawing.Size(85' 13);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.label5.Size = new System.Drawing.Size(85' 13);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.label5.TabIndex = 12;
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.FileColumnsLabel.Location = new System.Drawing.Point(4' 170);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.FileColumnsLabel.Location = new System.Drawing.Point(4' 170);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.FileColumnsLabel.Size = new System.Drawing.Size(78' 13);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.FileColumnsLabel.Size = new System.Drawing.Size(78' 13);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.FileColumnsLabel.TabIndex = 9;
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.ColumnsInCSVTextBox.Location = new System.Drawing.Point(100' 170);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.ColumnsInCSVTextBox.Location = new System.Drawing.Point(100' 170);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.ColumnsInCSVTextBox.Size = new System.Drawing.Size(229' 20);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.ColumnsInCSVTextBox.Size = new System.Drawing.Size(229' 20);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.ColumnsInCSVTextBox.TabIndex = 10;
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.AutoScaleDimensions = new System.Drawing.SizeF(6F' 13F);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.AutoScaleDimensions = new System.Drawing.SizeF(6F' 13F);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(391' 459);
Magic Number,Encog.ML.Data.Market.Loader,CSVFormLoader,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Market\Loader\CSVFormLoader.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(391' 459);
Magic Number,Encog.ML.Data.Versatile.Columns,ColumnDefinition,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Versatile\Columns\ColumnDefinition.cs,ToString,The following statement contains a magic number: result.Append(Format.FormatDouble(Low' 6));
Magic Number,Encog.ML.Data.Versatile.Columns,ColumnDefinition,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Versatile\Columns\ColumnDefinition.cs,ToString,The following statement contains a magic number: result.Append(Format.FormatDouble(High' 6));
Magic Number,Encog.ML.Data.Versatile.Columns,ColumnDefinition,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Versatile\Columns\ColumnDefinition.cs,ToString,The following statement contains a magic number: result.Append(Format.FormatDouble(Mean' 6));
Magic Number,Encog.ML.Data.Versatile.Columns,ColumnDefinition,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Versatile\Columns\ColumnDefinition.cs,ToString,The following statement contains a magic number: result.Append(Format.FormatDouble(Sd' 6));
Magic Number,Encog.ML.Data.Versatile.Normalizers,RangeNormalizer,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Versatile\Normalizers\RangeNormalizer.cs,NormalizeColumn,The following statement contains a magic number: result = ((_normalizedHigh - _normalizedLow)/2) + _normalizedLow;
Magic Number,Encog.ML.Data.Versatile.Normalizers,RangeNormalizer,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Versatile\Normalizers\RangeNormalizer.cs,DenormalizeColumn,The following statement contains a magic number: return "" + (((_normalizedHigh - _normalizedLow)/2) + _normalizedLow);
Magic Number,Encog.ML.Data.Versatile.Normalizers,RangeOrdinal,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Versatile\Normalizers\RangeOrdinal.cs,NormalizeColumn,The following statement contains a magic number: result = ((_normalizedHigh - _normalizedLow)/2)                           + _normalizedLow;
Magic Number,Encog.ML.EA.Species,BasicSpecies,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\EA\Species\BasicSpecies.cs,ToString,The following statement contains a magic number: result.Append(Format.FormatDouble(BestScore' 2));
Magic Number,Encog.ML.EA.Species,ThresholdSpeciation,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\EA\Species\ThresholdSpeciation.cs,AdjustCompatibilityThreshold,The following statement contains a magic number: const double thresholdIncrement = 0.01;
Magic Number,Encog.ML.EA.Train,BasicEA,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\EA\Train\BasicEA.cs,BasicEA,The following statement contains a magic number: EliteRate = 0.3;
Magic Number,Encog.ML.EA.Train,BasicEA,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\EA\Train\BasicEA.cs,BasicEA,The following statement contains a magic number: MaxTries = 5;
Magic Number,Encog.ML.EA.Train,BasicEA,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\EA\Train\BasicEA.cs,BasicEA,The following statement contains a magic number: MaxOperationErrors = 500;
Magic Number,Encog.ML.EA.Train,BasicEA,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\EA\Train\BasicEA.cs,BasicEA,The following statement contains a magic number: Selection = new TournamentSelection(this' 4);
Magic Number,Encog.ML.EA.Train,BasicEA,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\EA\Train\BasicEA.cs,Iteration,The following statement contains a magic number: species.Members.Count > 5
Magic Number,Encog.ML.EA.Train,EAWorker,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\EA\Train\EAWorker.cs,PerformTask,The following statement contains a magic number: int numAttempts = 5;
Magic Number,Encog.ML.Factory.Method,EPLFactory,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Factory\Method\EPLFactory.cs,Create,The following statement contains a magic number: int populationSize = holder.GetInt(                      MLMethodFactory.PropertyPopulationSize' false' 1000);
Magic Number,Encog.ML.Factory.Method,EPLFactory,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Factory\Method\EPLFactory.cs,Create,The following statement contains a magic number: (new RampedHalfAndHalf(context' 2' 6)).Generate(new EncogRandom()' pop);
Magic Number,Encog.ML.Factory.Method,EPLFactory,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Factory\Method\EPLFactory.cs,Create,The following statement contains a magic number: (new RampedHalfAndHalf(context' 2' 6)).Generate(new EncogRandom()' pop);
Magic Number,Encog.ML.Factory.Method,NEATFactory,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Factory\Method\NEATFactory.cs,Create,The following statement contains a magic number: int populationSize = holder.GetInt(                      MLMethodFactory.PropertyPopulationSize' false' 1000);
Magic Number,Encog.ML.Factory.Method,PNNFactory,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Factory\Method\PNNFactory.cs,Create,The following statement contains a magic number: ArchitectureLayer outputLayer = ArchitectureParse.ParseLayer(                  layers[2]' output);
Magic Number,Encog.ML.Factory.Method,RBFNetworkFactory,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Factory\Method\RBFNetworkFactory.cs,Create,The following statement contains a magic number: ArchitectureLayer outputLayer = ArchitectureParse.ParseLayer(                  layers[2]' output);
Magic Number,Encog.ML.Factory.Method,SOMFactory,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Factory\Method\SOMFactory.cs,Create,The following statement contains a magic number: layers.Count != 2
Magic Number,Encog.ML.Factory.Method,SRNFactory,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Factory\Method\SRNFactory.cs,Create,The following statement contains a magic number: ArchitectureLayer outputLayer = ArchitectureParse.ParseLayer(                  layers[2]' output);
Magic Number,Encog.ML.Factory.Method,SVMFactory,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Factory\Method\SVMFactory.cs,Create,The following statement contains a magic number: ArchitectureLayer outputLayer = ArchitectureParse.ParseLayer(                  layers[2]' output);
Magic Number,Encog.ML.Factory.Parse,ArchitectureParse,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Factory\Parse\ArchitectureParse.cs,ParseLayer,The following statement contains a magic number: check = check.Substring(0' (check.Length - 2) - (0));
Magic Number,Encog.ML.Factory.Parse,ArchitectureParse,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Factory\Parse\ArchitectureParse.cs,ParseLayers,The following statement contains a magic number: bs = index + 2;
Magic Number,Encog.ML.Factory.Train,AnnealFactory,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Factory\Train\AnnealFactory.cs,Create,The following statement contains a magic number: double startTemp = holder.GetDouble(                  MLTrainFactory.PropertyTemperatureStart' false' 10);
Magic Number,Encog.ML.Factory.Train,AnnealFactory,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Factory\Train\AnnealFactory.cs,Create,The following statement contains a magic number: double stopTemp = holder.GetDouble(                  MLTrainFactory.PropertyTemperatureStop' false' 2);
Magic Number,Encog.ML.Factory.Train,AnnealFactory,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Factory\Train\AnnealFactory.cs,Create,The following statement contains a magic number: int cycles = holder.GetInt(MLTrainFactory.Cycles' false' 100);
Magic Number,Encog.ML.Factory.Train,BackPropFactory,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Factory\Train\BackPropFactory.cs,Create,The following statement contains a magic number: double learningRate = holder.GetDouble(                  MLTrainFactory.PropertyLearningRate' false' 0.7d);
Magic Number,Encog.ML.Factory.Train,BackPropFactory,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Factory\Train\BackPropFactory.cs,Create,The following statement contains a magic number: double momentum = holder.GetDouble(                  MLTrainFactory.PropertyLearningMomentum' false' 0.3d);
Magic Number,Encog.ML.Factory.Train,EPLGAFactory,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Factory\Train\EPLGAFactory.cs,Create,The following statement contains a magic number: train.AddOperation(0.8' new SubtreeCrossover());
Magic Number,Encog.ML.Factory.Train,EPLGAFactory,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Factory\Train\EPLGAFactory.cs,Create,The following statement contains a magic number: train.AddOperation(0.1' new SubtreeMutation(pop.Context' 4));
Magic Number,Encog.ML.Factory.Train,EPLGAFactory,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Factory\Train\EPLGAFactory.cs,Create,The following statement contains a magic number: train.AddOperation(0.1' new SubtreeMutation(pop.Context' 4));
Magic Number,Encog.ML.Factory.Train,EPLGAFactory,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Factory\Train\EPLGAFactory.cs,Create,The following statement contains a magic number: train.AddOperation(0.1' new ConstMutation(pop.Context' 0.5' 1.0));
Magic Number,Encog.ML.Factory.Train,EPLGAFactory,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Factory\Train\EPLGAFactory.cs,Create,The following statement contains a magic number: train.AddOperation(0.1' new ConstMutation(pop.Context' 0.5' 1.0));
Magic Number,Encog.ML.Factory.Train,GeneticFactory,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Factory\Train\GeneticFactory.cs,Create,The following statement contains a magic number: int populationSize = holder.GetInt(  				MLTrainFactory.PropertyPopulationSize' false' 5000);
Magic Number,Encog.ML.Factory.Train,ManhattanFactory,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Factory\Train\ManhattanFactory.cs,Create,The following statement contains a magic number: double learningRate = holder.GetDouble(                  MLTrainFactory.PropertyLearningRate' false' 0.1d);
Magic Number,Encog.ML.Factory.Train,NeighborhoodSOMFactory,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Factory\Train\NeighborhoodSOMFactory.cs,Create,The following statement contains a magic number: double learningRate = holder.GetDouble(                  MLTrainFactory.PropertyLearningRate' false' 0.7d);
Magic Number,Encog.ML.Factory.Train,NeighborhoodSOMFactory,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Factory\Train\NeighborhoodSOMFactory.cs,Create,The following statement contains a magic number: int plannedIterations = holder.GetInt(                      MLTrainFactory.PropertyIterations' false' 1000);
Magic Number,Encog.ML.Factory.Train,NeighborhoodSOMFactory,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Factory\Train\NeighborhoodSOMFactory.cs,Create,The following statement contains a magic number: double startRate = holder.GetDouble(                      MLTrainFactory.PropertyStartLearningRate' false' 0.05d);
Magic Number,Encog.ML.Factory.Train,NeighborhoodSOMFactory,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Factory\Train\NeighborhoodSOMFactory.cs,Create,The following statement contains a magic number: double endRate = holder.GetDouble(                      MLTrainFactory.PropertyEndLearningRate' false' 0.05d);
Magic Number,Encog.ML.Factory.Train,NeighborhoodSOMFactory,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Factory\Train\NeighborhoodSOMFactory.cs,Create,The following statement contains a magic number: double startRadius = holder.GetDouble(                      MLTrainFactory.PropertyStartRadius' false' 10);
Magic Number,Encog.ML.Factory.Train,PSOFactory,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Factory\Train\PSOFactory.cs,Create,The following statement contains a magic number: int particles = holder.GetInt(                      MLTrainFactory.PropertyParticles' false' 20);
Magic Number,Encog.ML.Factory.Train,QuickPropFactory,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Factory\Train\QuickPropFactory.cs,Create,The following statement contains a magic number: double learningRate = holder.GetDouble(                  MLTrainFactory.PropertyLearningRate' false' 2.0);
Magic Number,Encog.ML.Genetic,MLMethodGeneticAlgorithm,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Genetic\MLMethodGeneticAlgorithm.cs,MLMethodGeneticAlgorithm,The following statement contains a magic number: int s = Math                      .Max(defaultSpecies.Members[0].Size / 5' 1);
Magic Number,Encog.ML.Genetic,MLMethodGeneticAlgorithm,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Genetic\MLMethodGeneticAlgorithm.cs,MLMethodGeneticAlgorithm,The following statement contains a magic number: this.genetic.AddOperation(0.9' new Splice(s));
Magic Number,Encog.ML.Genetic,MLMethodGeneticAlgorithm,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Genetic\MLMethodGeneticAlgorithm.cs,MLMethodGeneticAlgorithm,The following statement contains a magic number: this.genetic.AddOperation(0.1' new MutatePerturb(1.0));
Magic Number,Encog.ML.Genetic.Mutate,MutatePerturb,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Genetic\Mutate\MutatePerturb.cs,PerformOperation,The following statement contains a magic number: value += (perturbAmount - (rnd.NextDouble() * perturbAmount * 2));
Magic Number,Encog.ML.HMM.Alog,KullbackLeiblerDistanceCalculator,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\HMM\Alog\KullbackLeiblerDistanceCalculator.cs,KullbackLeiblerDistanceCalculator,The following statement contains a magic number: Len = 1000;
Magic Number,Encog.ML.HMM.Alog,KullbackLeiblerDistanceCalculator,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\HMM\Alog\KullbackLeiblerDistanceCalculator.cs,KullbackLeiblerDistanceCalculator,The following statement contains a magic number: SequenceCount = 10;
Magic Number,Encog.ML.HMM.Distributions,ContinousDistribution,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\HMM\Distributions\ContinousDistribution.cs,Probability,The following statement contains a magic number: double expArg = MatrixMath.Multiply(MatrixMath.Transpose(vmm)' t)                                  [0' 0] * -0.5;
Magic Number,Encog.ML.HMM.Distributions,ContinousDistribution,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\HMM\Distributions\ContinousDistribution.cs,Probability,The following statement contains a magic number: return Math.Exp(expArg)                     / (Math.Pow(2.0 * Math.PI' _dimension / 2.0) * Math.Pow(                         _covarianceDet' 0.5));
Magic Number,Encog.ML.HMM.Distributions,ContinousDistribution,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\HMM\Distributions\ContinousDistribution.cs,Probability,The following statement contains a magic number: return Math.Exp(expArg)                     / (Math.Pow(2.0 * Math.PI' _dimension / 2.0) * Math.Pow(                         _covarianceDet' 0.5));
Magic Number,Encog.ML.HMM.Distributions,ContinousDistribution,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\HMM\Distributions\ContinousDistribution.cs,Probability,The following statement contains a magic number: return Math.Exp(expArg)                     / (Math.Pow(2.0 * Math.PI' _dimension / 2.0) * Math.Pow(                         _covarianceDet' 0.5));
Magic Number,Encog.ML.HMM.Train.KMeans,TrainKMeans,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\HMM\Train\KMeans\TrainKMeans.cs,LearnTransition,The following statement contains a magic number: obsSeq.Count < 2
Magic Number,Encog.ML.Model.Config,FeedforwardConfig,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Model\Config\FeedforwardConfig.cs,SuggestModelArchitecture,The following statement contains a magic number: var hiddenCount = (int) ((inputColumns + outputColumns)*1.5);
Magic Number,Encog.ML.Model.Config,FeedforwardConfig,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Model\Config\FeedforwardConfig.cs,SuggestNormalizationStrategy,The following statement contains a magic number: double[] d = {-1000' -100' -50};
Magic Number,Encog.ML.Model.Config,FeedforwardConfig,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Model\Config\FeedforwardConfig.cs,SuggestNormalizationStrategy,The following statement contains a magic number: double[] d = {-1000' -100' -50};
Magic Number,Encog.ML.Model.Config,FeedforwardConfig,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Model\Config\FeedforwardConfig.cs,SuggestNormalizationStrategy,The following statement contains a magic number: double[] d = {-1000' -100' -50};
Magic Number,Encog.ML.Model.Config,FeedforwardConfig,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Model\Config\FeedforwardConfig.cs,SuggestNormalizationStrategy,The following statement contains a magic number: d[0] > 0 && d[1] > 0 && d[2] > 0
Magic Number,Encog.ML.Model.Config,RBFNetworkConfig,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Model\Config\RBFNetworkConfig.cs,SuggestModelArchitecture,The following statement contains a magic number: var hiddenCount = (int) ((inputColumns + outputColumns)*1.5);
Magic Number,Encog.ML.Model,EncogModel,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Model\EncogModel.cs,FitFold,The following statement contains a magic number: line.Append(Format.FormatDouble(train.Error' 8));
Magic Number,Encog.ML.Model,EncogModel,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Model\EncogModel.cs,FitFold,The following statement contains a magic number: line.Append(Format.FormatDouble(earlyStop.ValidationError'                          8));
Magic Number,Encog.ML.Prg.Generator,AbstractPrgGenerator,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Prg\Generator\AbstractPrgGenerator.cs,AbstractPrgGenerator,The following statement contains a magic number: MinConst = -10;
Magic Number,Encog.ML.Prg.Generator,AbstractPrgGenerator,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Prg\Generator\AbstractPrgGenerator.cs,AbstractPrgGenerator,The following statement contains a magic number: MaxConst = 10;
Magic Number,Encog.ML.Prg.Generator,AbstractPrgGenerator,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Prg\Generator\AbstractPrgGenerator.cs,AbstractPrgGenerator,The following statement contains a magic number: MaxGenerationErrors = 500;
Magic Number,Encog.ML.Prg.Generator,AbstractPrgGenerator,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Prg\Generator\AbstractPrgGenerator.cs,CreateRandomNode,The following statement contains a magic number: EncogOpcodeRegistry.IsOperator(temp.NodeType) && children.Length >= 2
Magic Number,Encog.ML.Prg.Generator,AbstractPrgGenerator,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Prg\Generator\AbstractPrgGenerator.cs,GenerateRandomOpcode,The following statement contains a magic number: int tries = 10000;
Magic Number,Encog.ML.Prg.Generator,RampedHalfAndHalf,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Prg\Generator\RampedHalfAndHalf.cs,CreateNode,The following statement contains a magic number: rnd.NextDouble() > 0.5
Magic Number,Encog.ML.Prg.Opp,SubtreeCrossover,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Prg\Opp\SubtreeCrossover.cs,PerformOperation,The following statement contains a magic number: int tries = 100;
Magic Number,Encog.ML.Prg.Species,PrgSpeciation,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Prg\Species\PrgSpeciation.cs,PrgSpeciation,The following statement contains a magic number: CompatibilityThreshold = 15;
Magic Number,Encog.ML.Prg.Species,PrgSpeciation,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Prg\Species\PrgSpeciation.cs,PrgSpeciation,The following statement contains a magic number: MaxNumberOfSpecies = 30;
Magic Number,Encog.ML.Prg.Species,PrgSpeciation,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Prg\Species\PrgSpeciation.cs,PrgSpeciation,The following statement contains a magic number: NumGensAllowedNoImprovement = 15;
Magic Number,Encog.ML.Prg.Train.Rewrite,RewriteAlgebraic,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Prg\Train\Rewrite\RewriteAlgebraic.cs,TryMinusMinus,The following statement contains a magic number: parent.Name.Equals("-") && parent.ChildNodes.Count == 2
Magic Number,Encog.ML.Prg.Train.Rewrite,RewriteAlgebraic,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Prg\Train\Rewrite\RewriteAlgebraic.cs,TryPlusNeg,The following statement contains a magic number: parent.Name.Equals("+") && parent.ChildNodes.Count == 2
Magic Number,Encog.ML.Prg.Train.Rewrite,RewriteAlgebraic,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Prg\Train\Rewrite\RewriteAlgebraic.cs,TryVarOpVar,The following statement contains a magic number: switch (parent.Name[0])                          {                              case '-':                                  parent = CreateNumericConst(parent.Owner' 0);                                  break;                              case '+':                                  parent = parent.Owner.Functions.FactorProgramNode("*"' parent.Owner'                                                                                    new[]                                                                                        {                                                                                            CreateNumericConst(                                                                                                parent.Owner' 2)'                                                                                            child1                                                                                        });                                  break;                              case '*':                                  parent = parent                                      .Owner                                      .Functions                                      .FactorProgramNode(                                          "^"'                                          parent.Owner'                                          new[]                                              {                                                  child1'                                                  CreateNumericConst(                                                      parent.Owner' 2)                                              });                                  break;                              case '/':                                  parent = CreateNumericConst(parent.Owner' 1);                                  break;                          }
Magic Number,Encog.ML.Prg.Train.Rewrite,RewriteAlgebraic,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Prg\Train\Rewrite\RewriteAlgebraic.cs,TryVarOpVar,The following statement contains a magic number: switch (parent.Name[0])                          {                              case '-':                                  parent = CreateNumericConst(parent.Owner' 0);                                  break;                              case '+':                                  parent = parent.Owner.Functions.FactorProgramNode("*"' parent.Owner'                                                                                    new[]                                                                                        {                                                                                            CreateNumericConst(                                                                                                parent.Owner' 2)'                                                                                            child1                                                                                        });                                  break;                              case '*':                                  parent = parent                                      .Owner                                      .Functions                                      .FactorProgramNode(                                          "^"'                                          parent.Owner'                                          new[]                                              {                                                  child1'                                                  CreateNumericConst(                                                      parent.Owner' 2)                                              });                                  break;                              case '/':                                  parent = CreateNumericConst(parent.Owner' 1);                                  break;                          }
Magic Number,Encog.ML.Prg.Train.Rewrite,RewriteAlgebraic,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Prg\Train\Rewrite\RewriteAlgebraic.cs,TryVarOpVar,The following statement contains a magic number: parent.ChildNodes.Count == 2                  && parent.Name.Length == 1                  && "+-*/".IndexOf(parent.Name[0]) != -1
Magic Number,Encog.ML.Train.Strategy,EarlyStoppingStrategy,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Train\Strategy\EarlyStoppingStrategy.cs,PostIteration,The following statement contains a magic number: _gl = 100.0*((_validationError/_eOpt) - 1.0);
Magic Number,Encog.Neural.ART,ART1,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\ART\ART1.cs,ART1,The following statement contains a magic number: _b1 = 1.5d;
Magic Number,Encog.Neural.ART,ART1,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\ART\ART1.cs,ART1,The following statement contains a magic number: _c1 = 5;
Magic Number,Encog.Neural.ART,ART1,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\ART\ART1.cs,ART1,The following statement contains a magic number: _d1 = 0.9d;
Magic Number,Encog.Neural.ART,ART1,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\ART\ART1.cs,ART1,The following statement contains a magic number: _l = 3;
Magic Number,Encog.Neural.ART,ART1,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\ART\ART1.cs,ART1,The following statement contains a magic number: _vigilance = 0.9d;
Magic Number,Encog.Neural.ART,ART1,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\ART\ART1.cs,ART1,The following statement contains a magic number: _b1 = 1.5d;
Magic Number,Encog.Neural.ART,ART1,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\ART\ART1.cs,ART1,The following statement contains a magic number: _c1 = 5;
Magic Number,Encog.Neural.ART,ART1,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\ART\ART1.cs,ART1,The following statement contains a magic number: _d1 = 0.9d;
Magic Number,Encog.Neural.ART,ART1,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\ART\ART1.cs,ART1,The following statement contains a magic number: _l = 3;
Magic Number,Encog.Neural.ART,ART1,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\ART\ART1.cs,ART1,The following statement contains a magic number: _vigilance = 0.9d;
Magic Number,Encog.Neural.ART,ART1,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\ART\ART1.cs,Reset,The following statement contains a magic number: _weightsF1ToF2[i' j] = (_b1 - 1)/_d1 + 0.2d;
Magic Number,Encog.Neural.ART,ART1,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\ART\ART1.cs,Reset,The following statement contains a magic number: _weightsF2ToF1[j' i] = _l                                            /(_l - 1 + _f1Count) - 0.1d;
Magic Number,Encog.Neural.Flat,FlatNetwork,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Flat\FlatNetwork.cs,FlatNetwork,The following statement contains a magic number: layers = new FlatLayer[2];
Magic Number,Encog.Neural.Flat,FlatNetworkRBF,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Flat\FlatNetworkRBF.cs,FlatNetworkRBF,The following statement contains a magic number: var layers = new FlatLayer[3];
Magic Number,Encog.Neural.Flat,FlatNetworkRBF,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Flat\FlatNetworkRBF.cs,FlatNetworkRBF,The following statement contains a magic number: layers[2] = new FlatLayer(new ActivationLinear()' outputCount' 0.0d);
Magic Number,Encog.Neural.Freeform,FreeformNetwork,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Freeform\FreeformNetwork.cs,FreeformNetwork,The following statement contains a magic number: network.LayerCount < 2
Magic Number,Encog.Neural.Freeform.Training,FreeformBackPropagation,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Freeform\Training\FreeformBackPropagation.cs,FreeformBackPropagation,The following statement contains a magic number: theNetwork.TempTrainingAllocate(1' 2);
Magic Number,Encog.Neural.Freeform.Training,FreeformResilientPropagation,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Freeform\Training\FreeformResilientPropagation.cs,FreeformResilientPropagation,The following statement contains a magic number: theNetwork.TempTrainingAllocate(1' 4);
Magic Number,Encog.Neural.HyperNEAT,HyperNEATCODEC,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\HyperNEAT\HyperNEATCODEC.cs,HyperNEATCODEC,The following statement contains a magic number: MinWeight = 0.2;
Magic Number,Encog.Neural.HyperNEAT,HyperNEATCODEC,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\HyperNEAT\HyperNEATCODEC.cs,HyperNEATCODEC,The following statement contains a magic number: MaxWeight = 5.0;
Magic Number,Encog.Neural.HyperNEAT,HyperNEATGenome,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\HyperNEAT\HyperNEATGenome.cs,BuildCPPNActivationFunctions,The following statement contains a magic number: activationFunctions.Add(0.25' new ActivationClippedLinear());
Magic Number,Encog.Neural.HyperNEAT,HyperNEATGenome,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\HyperNEAT\HyperNEATGenome.cs,BuildCPPNActivationFunctions,The following statement contains a magic number: activationFunctions.Add(0.25' new ActivationBipolarSteepenedSigmoid());
Magic Number,Encog.Neural.HyperNEAT,HyperNEATGenome,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\HyperNEAT\HyperNEATGenome.cs,BuildCPPNActivationFunctions,The following statement contains a magic number: activationFunctions.Add(0.25' new ActivationGaussian());
Magic Number,Encog.Neural.HyperNEAT,HyperNEATGenome,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\HyperNEAT\HyperNEATGenome.cs,BuildCPPNActivationFunctions,The following statement contains a magic number: activationFunctions.Add(0.25' new ActivationSIN());
Magic Number,Encog.Neural.HyperNEAT.Substrate,SubstrateFactory,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\HyperNEAT\Substrate\SubstrateFactory.cs,factorSandwichSubstrate,The following statement contains a magic number: Substrate result = new Substrate(3);
Magic Number,Encog.Neural.HyperNEAT.Substrate,SubstrateFactory,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\HyperNEAT\Substrate\SubstrateFactory.cs,factorSandwichSubstrate,The following statement contains a magic number: double inputTick = 2.0 / inputEdgeSize;
Magic Number,Encog.Neural.HyperNEAT.Substrate,SubstrateFactory,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\HyperNEAT\Substrate\SubstrateFactory.cs,factorSandwichSubstrate,The following statement contains a magic number: double outputTick = 2.0 / inputEdgeSize;
Magic Number,Encog.Neural.HyperNEAT.Substrate,SubstrateFactory,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\HyperNEAT\Substrate\SubstrateFactory.cs,factorSandwichSubstrate,The following statement contains a magic number: double inputOrig = -1.0 + (inputTick / 2.0);
Magic Number,Encog.Neural.HyperNEAT.Substrate,SubstrateFactory,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\HyperNEAT\Substrate\SubstrateFactory.cs,factorSandwichSubstrate,The following statement contains a magic number: double outputOrig = -1.0 + (inputTick / 2.0);
Magic Number,Encog.Neural.HyperNEAT.Substrate,SubstrateFactory,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\HyperNEAT\Substrate\SubstrateFactory.cs,factorSandwichSubstrate,The following statement contains a magic number: inputNode.Location[2] = inputOrig + (col * inputTick);
Magic Number,Encog.Neural.HyperNEAT.Substrate,SubstrateFactory,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\HyperNEAT\Substrate\SubstrateFactory.cs,factorSandwichSubstrate,The following statement contains a magic number: outputNode.Location[2] = outputOrig + (ocol * outputTick);
Magic Number,Encog.Neural.NEAT,NEATUtil,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\NEATUtil.cs,ConstructNEATTrainer,The following statement contains a magic number: result.Selection = new TruncationSelection(result' 0.3);
Magic Number,Encog.Neural.NEAT,NEATUtil,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\NEATUtil.cs,ConstructNEATTrainer,The following statement contains a magic number: weightMutation.Components.Add(                      0.1125'                      new NEATMutateWeights(new SelectFixed(1)'                              new MutatePerturbLinkWeight(0.02)));
Magic Number,Encog.Neural.NEAT,NEATUtil,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\NEATUtil.cs,ConstructNEATTrainer,The following statement contains a magic number: weightMutation.Components.Add(                      0.1125'                      new NEATMutateWeights(new SelectFixed(1)'                              new MutatePerturbLinkWeight(0.02)));
Magic Number,Encog.Neural.NEAT,NEATUtil,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\NEATUtil.cs,ConstructNEATTrainer,The following statement contains a magic number: weightMutation.Components.Add(                      0.1125'                      new NEATMutateWeights(new SelectFixed(2)'                              new MutatePerturbLinkWeight(0.02)));
Magic Number,Encog.Neural.NEAT,NEATUtil,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\NEATUtil.cs,ConstructNEATTrainer,The following statement contains a magic number: weightMutation.Components.Add(                      0.1125'                      new NEATMutateWeights(new SelectFixed(2)'                              new MutatePerturbLinkWeight(0.02)));
Magic Number,Encog.Neural.NEAT,NEATUtil,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\NEATUtil.cs,ConstructNEATTrainer,The following statement contains a magic number: weightMutation.Components.Add(                      0.1125'                      new NEATMutateWeights(new SelectFixed(2)'                              new MutatePerturbLinkWeight(0.02)));
Magic Number,Encog.Neural.NEAT,NEATUtil,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\NEATUtil.cs,ConstructNEATTrainer,The following statement contains a magic number: weightMutation.Components.Add(                      0.1125'                      new NEATMutateWeights(new SelectFixed(3)'                              new MutatePerturbLinkWeight(0.02)));
Magic Number,Encog.Neural.NEAT,NEATUtil,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\NEATUtil.cs,ConstructNEATTrainer,The following statement contains a magic number: weightMutation.Components.Add(                      0.1125'                      new NEATMutateWeights(new SelectFixed(3)'                              new MutatePerturbLinkWeight(0.02)));
Magic Number,Encog.Neural.NEAT,NEATUtil,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\NEATUtil.cs,ConstructNEATTrainer,The following statement contains a magic number: weightMutation.Components.Add(                      0.1125'                      new NEATMutateWeights(new SelectFixed(3)'                              new MutatePerturbLinkWeight(0.02)));
Magic Number,Encog.Neural.NEAT,NEATUtil,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\NEATUtil.cs,ConstructNEATTrainer,The following statement contains a magic number: weightMutation.Components.Add(                      0.1125'                      new NEATMutateWeights(new SelectProportion(0.02)'                              new MutatePerturbLinkWeight(0.02)));
Magic Number,Encog.Neural.NEAT,NEATUtil,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\NEATUtil.cs,ConstructNEATTrainer,The following statement contains a magic number: weightMutation.Components.Add(                      0.1125'                      new NEATMutateWeights(new SelectProportion(0.02)'                              new MutatePerturbLinkWeight(0.02)));
Magic Number,Encog.Neural.NEAT,NEATUtil,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\NEATUtil.cs,ConstructNEATTrainer,The following statement contains a magic number: weightMutation.Components.Add(                      0.1125'                      new NEATMutateWeights(new SelectProportion(0.02)'                              new MutatePerturbLinkWeight(0.02)));
Magic Number,Encog.Neural.NEAT,NEATUtil,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\NEATUtil.cs,ConstructNEATTrainer,The following statement contains a magic number: weightMutation.Components.Add(                      0.1125'                      new NEATMutateWeights(new SelectFixed(1)'                              new MutatePerturbLinkWeight(1)));
Magic Number,Encog.Neural.NEAT,NEATUtil,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\NEATUtil.cs,ConstructNEATTrainer,The following statement contains a magic number: weightMutation.Components.Add(                      0.1125'                      new NEATMutateWeights(new SelectFixed(2)'                              new MutatePerturbLinkWeight(1)));
Magic Number,Encog.Neural.NEAT,NEATUtil,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\NEATUtil.cs,ConstructNEATTrainer,The following statement contains a magic number: weightMutation.Components.Add(                      0.1125'                      new NEATMutateWeights(new SelectFixed(2)'                              new MutatePerturbLinkWeight(1)));
Magic Number,Encog.Neural.NEAT,NEATUtil,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\NEATUtil.cs,ConstructNEATTrainer,The following statement contains a magic number: weightMutation.Components.Add(                      0.1125'                      new NEATMutateWeights(new SelectFixed(3)'                              new MutatePerturbLinkWeight(1)));
Magic Number,Encog.Neural.NEAT,NEATUtil,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\NEATUtil.cs,ConstructNEATTrainer,The following statement contains a magic number: weightMutation.Components.Add(                      0.1125'                      new NEATMutateWeights(new SelectFixed(3)'                              new MutatePerturbLinkWeight(1)));
Magic Number,Encog.Neural.NEAT,NEATUtil,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\NEATUtil.cs,ConstructNEATTrainer,The following statement contains a magic number: weightMutation.Components.Add(                      0.1125'                      new NEATMutateWeights(new SelectProportion(0.02)'                              new MutatePerturbLinkWeight(1)));
Magic Number,Encog.Neural.NEAT,NEATUtil,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\NEATUtil.cs,ConstructNEATTrainer,The following statement contains a magic number: weightMutation.Components.Add(                      0.1125'                      new NEATMutateWeights(new SelectProportion(0.02)'                              new MutatePerturbLinkWeight(1)));
Magic Number,Encog.Neural.NEAT,NEATUtil,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\NEATUtil.cs,ConstructNEATTrainer,The following statement contains a magic number: weightMutation.Components.Add(                      0.03'                      new NEATMutateWeights(new SelectFixed(1)'                              new MutateResetLinkWeight()));
Magic Number,Encog.Neural.NEAT,NEATUtil,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\NEATUtil.cs,ConstructNEATTrainer,The following statement contains a magic number: weightMutation.Components.Add(                      0.03'                      new NEATMutateWeights(new SelectFixed(2)'                              new MutateResetLinkWeight()));
Magic Number,Encog.Neural.NEAT,NEATUtil,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\NEATUtil.cs,ConstructNEATTrainer,The following statement contains a magic number: weightMutation.Components.Add(                      0.03'                      new NEATMutateWeights(new SelectFixed(2)'                              new MutateResetLinkWeight()));
Magic Number,Encog.Neural.NEAT,NEATUtil,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\NEATUtil.cs,ConstructNEATTrainer,The following statement contains a magic number: weightMutation.Components.Add(                      0.03'                      new NEATMutateWeights(new SelectFixed(3)'                              new MutateResetLinkWeight()));
Magic Number,Encog.Neural.NEAT,NEATUtil,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\NEATUtil.cs,ConstructNEATTrainer,The following statement contains a magic number: weightMutation.Components.Add(                      0.03'                      new NEATMutateWeights(new SelectFixed(3)'                              new MutateResetLinkWeight()));
Magic Number,Encog.Neural.NEAT,NEATUtil,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\NEATUtil.cs,ConstructNEATTrainer,The following statement contains a magic number: weightMutation.Components.Add(                      0.01'                      new NEATMutateWeights(new SelectProportion(0.02)'                              new MutateResetLinkWeight()));
Magic Number,Encog.Neural.NEAT,NEATUtil,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\NEATUtil.cs,ConstructNEATTrainer,The following statement contains a magic number: weightMutation.Components.Add(                      0.01'                      new NEATMutateWeights(new SelectProportion(0.02)'                              new MutateResetLinkWeight()));
Magic Number,Encog.Neural.NEAT,NEATUtil,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\NEATUtil.cs,ConstructNEATTrainer,The following statement contains a magic number: result.AddOperation(0.5' new NEATCrossover());
Magic Number,Encog.Neural.NEAT,NEATUtil,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\NEATUtil.cs,ConstructNEATTrainer,The following statement contains a magic number: result.AddOperation(0.494' weightMutation);
Magic Number,Encog.Neural.NEAT,NEATUtil,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\NEATUtil.cs,ConstructNEATTrainer,The following statement contains a magic number: result.AddOperation(0.0005' new NEATMutateAddNode());
Magic Number,Encog.Neural.NEAT,NEATUtil,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\NEATUtil.cs,ConstructNEATTrainer,The following statement contains a magic number: result.AddOperation(0.005' new NEATMutateAddLink());
Magic Number,Encog.Neural.NEAT,NEATUtil,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\NEATUtil.cs,ConstructNEATTrainer,The following statement contains a magic number: result.AddOperation(0.0005' new NEATMutateRemoveLink());
Magic Number,Encog.Neural.NEAT,PersistNEATPopulation,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\PersistNEATPopulation.cs,Read,The following statement contains a magic number: innovation.NeuronId = int.Parse(cols[2]);
Magic Number,Encog.Neural.NEAT,NEATPopulation,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\NEATPopulation.cs,NEATPopulation,The following statement contains a magic number: WeightRange = 5;
Magic Number,Encog.Neural.NEAT,NEATPopulation,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\NEATPopulation.cs,NEATPopulation,The following statement contains a magic number: InitialConnectionDensity = 0.1;
Magic Number,Encog.Neural.NEAT,NEATPopulation,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\NEATPopulation.cs,NEATPopulation,The following statement contains a magic number: WeightRange = 5;
Magic Number,Encog.Neural.NEAT,NEATPopulation,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\NEATPopulation.cs,NEATPopulation,The following statement contains a magic number: InitialConnectionDensity = 0.1;
Magic Number,Encog.Neural.NEAT,NEATPopulation,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\NEATPopulation.cs,NEATPopulation,The following statement contains a magic number: WeightRange = 5;
Magic Number,Encog.Neural.NEAT,NEATPopulation,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\NEATPopulation.cs,NEATPopulation,The following statement contains a magic number: InitialConnectionDensity = 0.1;
Magic Number,Encog.Neural.NEAT,NEATPopulation,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\NEATPopulation.cs,NEATPopulation,The following statement contains a magic number: InputCount = 6;
Magic Number,Encog.Neural.NEAT,NEATPopulation,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\NEATPopulation.cs,NEATPopulation,The following statement contains a magic number: OutputCount = 2;
Magic Number,Encog.Neural.NEAT.Training,NEATGenome,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\Training\NEATGenome.cs,ToString,The following statement contains a magic number: result.Append(Format.FormatDouble(Score' 2));
Magic Number,Encog.Neural.NEAT.Training,NEATGenome,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\Training\NEATGenome.cs,ToString,The following statement contains a magic number: result.Append(Format.FormatDouble(AdjustedScore' 2));
Magic Number,Encog.Neural.NEAT.Training.Opp,NEATCrossover,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\Training\Opp\NEATCrossover.cs,FavorParent,The following statement contains a magic number: rnd.NextDouble() > 0.5
Magic Number,Encog.Neural.NEAT.Training.Opp,NEATMutateAddNode,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\Training\Opp\NEATMutateAddNode.cs,PerformOperation,The following statement contains a magic number: int sizeBias = ((NEATGenome)parents[0]).InputCount                      + ((NEATGenome)parents[0]).OutputCount + 10;
Magic Number,Encog.Neural.NEAT.Training.Species,OriginalNEATSpeciation,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\NEAT\Training\Species\OriginalNEATSpeciation.cs,OriginalNEATSpeciation,The following statement contains a magic number: ConstMatched = 0.4;
Magic Number,Encog.Neural.Networks.Structure,NetworkCODEC,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Structure\NetworkCODEC.cs,Equals,The following statement contains a magic number: double test = Math.Pow(10.0d' precision);
Magic Number,Encog.Neural.Networks.Structure,NeuralStructure,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Structure\NeuralStructure.cs,FinalizeStructure,The following statement contains a magic number: _layers.Count < 2
Magic Number,Encog.Neural.Networks.Training.Lma,LevenbergMarquardtTraining,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\LMA\LevenbergMarquardtTraining.cs,LevenbergMarquardtTraining,The following statement contains a magic number: _lambda = 0.1;
Magic Number,Encog.Neural.Networks.Training.NM,NelderMeadTraining,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\NM\NelderMeadTraining.cs,NelderMeadTraining,The following statement contains a magic number: _jcount = _konvge = 500;
Magic Number,Encog.Neural.Networks.Training.PNN,DeriveMinimum,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\PNN\DeriveMinimum.cs,Calculate,The following statement contains a magic number: double prevBest = 1.0e30d;
Magic Number,Encog.Neural.Networks.Training.PNN,DeriveMinimum,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\PNN\DeriveMinimum.cs,Calculate,The following statement contains a magic number: ++convergenceCounter >= 3
Magic Number,Encog.Neural.Networks.Training.PNN,DeriveMinimum,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\PNN\DeriveMinimum.cs,Calculate,The following statement contains a magic number: double high = 1.0e-4d;
Magic Number,Encog.Neural.Networks.Training.PNN,DeriveMinimum,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\PNN\DeriveMinimum.cs,Calculate,The following statement contains a magic number: high = 1.5d/high;
Magic Number,Encog.Neural.Networks.Training.PNN,DeriveMinimum,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\PNN\DeriveMinimum.cs,Calculate,The following statement contains a magic number: high = 1.0e-4d;
Magic Number,Encog.Neural.Networks.Training.PNN,DeriveMinimum,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\PNN\DeriveMinimum.cs,Calculate,The following statement contains a magic number: high < 1.0e-4d
Magic Number,Encog.Neural.Networks.Training.PNN,DeriveMinimum,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\PNN\DeriveMinimum.cs,Calculate,The following statement contains a magic number: globalMinimum.FindBestRange(0.0d' 2.0d*scale' -3' false' maxError'                                              network);
Magic Number,Encog.Neural.Networks.Training.PNN,DeriveMinimum,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\PNN\DeriveMinimum.cs,Calculate,The following statement contains a magic number: globalMinimum.FindBestRange(0.0d' 2.0d*scale' -3' false' maxError'                                              network);
Magic Number,Encog.Neural.Networks.Training.PNN,DeriveMinimum,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\PNN\DeriveMinimum.cs,Calculate,The following statement contains a magic number: x[i] = 1.0e-10d;
Magic Number,Encog.Neural.Networks.Training.PNN,DeriveMinimum,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\PNN\DeriveMinimum.cs,Calculate,The following statement contains a magic number: x[i] < 1.0e-10d
Magic Number,Encog.Neural.Networks.Training.PNN,DeriveMinimum,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\PNN\DeriveMinimum.cs,Calculate,The following statement contains a magic number: fbest = globalMinimum.Brentmin(20' maxError' eps' 1.0e-7d'                                                     network' globalMinimum.Y2);
Magic Number,Encog.Neural.Networks.Training.PNN,DeriveMinimum,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\PNN\DeriveMinimum.cs,Calculate,The following statement contains a magic number: fbest = globalMinimum.Brentmin(20' maxError' eps' 1.0e-7d'                                                     network' globalMinimum.Y2);
Magic Number,Encog.Neural.Networks.Training.PNN,DeriveMinimum,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\PNN\DeriveMinimum.cs,Calculate,The following statement contains a magic number: x[i] = 1.0e-10d;
Magic Number,Encog.Neural.Networks.Training.PNN,DeriveMinimum,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\PNN\DeriveMinimum.cs,Calculate,The following statement contains a magic number: x[i] < 1.0e-10d
Magic Number,Encog.Neural.Networks.Training.PNN,DeriveMinimum,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\PNN\DeriveMinimum.cs,Calculate,The following statement contains a magic number: gam = 10.0d;
Magic Number,Encog.Neural.Networks.Training.PNN,DeriveMinimum,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\PNN\DeriveMinimum.cs,Calculate,The following statement contains a magic number: gam > 10.0d
Magic Number,Encog.Neural.Networks.Training.PNN,DeriveMinimum,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\PNN\DeriveMinimum.cs,Calculate,The following statement contains a magic number: improvement < 0.001d
Magic Number,Encog.Neural.Networks.Training.PNN,DeriveMinimum,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\PNN\DeriveMinimum.cs,Calculate,The following statement contains a magic number: poorCj >= 2
Magic Number,Encog.Neural.Networks.Training.PNN,DeriveMinimum,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\PNN\DeriveMinimum.cs,Calculate,The following statement contains a magic number: poorCj >= 6
Magic Number,Encog.Neural.Networks.Training.PNN,GlobalMinimumSearch,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\PNN\GlobalMinimumSearch.cs,Brentmin,The following statement contains a magic number: double xmid = 0.5d*(xlow + xhigh);
Magic Number,Encog.Neural.Networks.Training.PNN,GlobalMinimumSearch,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\PNN\GlobalMinimumSearch.cs,Brentmin,The following statement contains a magic number: double tol2 = 2.0*tol1;
Magic Number,Encog.Neural.Networks.Training.PNN,GlobalMinimumSearch,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\PNN\GlobalMinimumSearch.cs,Brentmin,The following statement contains a magic number: Math.Abs(xbest - xmid) <= (tol2 - 0.5d*(xhigh - xlow))
Magic Number,Encog.Neural.Networks.Training.PNN,GlobalMinimumSearch,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\PNN\GlobalMinimumSearch.cs,Brentmin,The following statement contains a magic number: (iter >= 2) && ((fthirdbest - fbest) < eps)
Magic Number,Encog.Neural.Networks.Training.PNN,GlobalMinimumSearch,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\PNN\GlobalMinimumSearch.cs,Brentmin,The following statement contains a magic number: double denom = 2.0*(t1 - t2);
Magic Number,Encog.Neural.Networks.Training.PNN,GlobalMinimumSearch,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\PNN\GlobalMinimumSearch.cs,Brentmin,The following statement contains a magic number: (Math.Abs(step) < Math.Abs(0.5d*testdist))                          && (step + xbest > xlow) && (step + xbest < xhigh)
Magic Number,Encog.Neural.Networks.Training.PNN,GlobalMinimumSearch,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\PNN\GlobalMinimumSearch.cs,FindBestRange,The following statement contains a magic number: rate *= 3.0d;
Magic Number,Encog.Neural.Networks.Training.PNN,TrainBasicPNN,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\PNN\TrainBasicPNN.cs,ComputeDeriv,The following statement contains a magic number: dist = 1.0e-40d;
Magic Number,Encog.Neural.Networks.Training.PNN,TrainBasicPNN,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\PNN\TrainBasicPNN.cs,ComputeDeriv,The following statement contains a magic number: dist < 1.0e-40d
Magic Number,Encog.Neural.Networks.Training.PNN,TrainBasicPNN,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\PNN\TrainBasicPNN.cs,ComputeDeriv,The following statement contains a magic number: _w[wptr + ivar] += temp*(2.0d*_dsqr[ivar] - 3.0d);
Magic Number,Encog.Neural.Networks.Training.PNN,TrainBasicPNN,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\PNN\TrainBasicPNN.cs,ComputeDeriv,The following statement contains a magic number: _w[wptr + ivar] += temp*(2.0d*_dsqr[ivar] - 3.0d);
Magic Number,Encog.Neural.Networks.Training.PNN,TrainBasicPNN,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\PNN\TrainBasicPNN.cs,ComputeDeriv,The following statement contains a magic number: psum = 1.0e-40d;
Magic Number,Encog.Neural.Networks.Training.PNN,TrainBasicPNN,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\PNN\TrainBasicPNN.cs,ComputeDeriv,The following statement contains a magic number: psum < 1.0e-40d
Magic Number,Encog.Neural.Networks.Training.PNN,TrainBasicPNN,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\PNN\TrainBasicPNN.cs,ComputeDeriv,The following statement contains a magic number: _v[outvar*_network.InputCount + ivar] *= 2.0d/(psum*_network.Sigma[ivar]);
Magic Number,Encog.Neural.Networks.Training.PNN,TrainBasicPNN,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\PNN\TrainBasicPNN.cs,ComputeDeriv,The following statement contains a magic number: _w[outvar*_network.InputCount + ivar] *= 2.0d/(psum                                                                   *_network.Sigma[ivar]*_network.Sigma[ivar]);
Magic Number,Encog.Neural.Networks.Training.PNN,TrainBasicPNN,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\PNN\TrainBasicPNN.cs,ComputeDeriv,The following statement contains a magic number: der2 = _w[outvar*_network.InputCount + ivar]                             + 2.0d*xout[outvar]*vtot*vtot - 2.0d                                                             *_v[outvar*_network.InputCount + ivar]                                                             *vtot - xout[outvar]*wtot;
Magic Number,Encog.Neural.Networks.Training.PNN,TrainBasicPNN,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\PNN\TrainBasicPNN.cs,ComputeDeriv,The following statement contains a magic number: der2 = _w[outvar*_network.InputCount + ivar]                             + 2.0d*xout[outvar]*vtot*vtot - 2.0d                                                             *_v[outvar*_network.InputCount + ivar]                                                             *vtot - xout[outvar]*wtot;
Magic Number,Encog.Neural.Networks.Training.PNN,TrainBasicPNN,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\PNN\TrainBasicPNN.cs,ComputeDeriv,The following statement contains a magic number: temp = 2.0d*(xout[outvar] - 1.0d);
Magic Number,Encog.Neural.Networks.Training.PNN,TrainBasicPNN,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\PNN\TrainBasicPNN.cs,ComputeDeriv,The following statement contains a magic number: _network.Deriv2[ivar] += temp*der2 + 2.0d*der1                                              *der1;
Magic Number,Encog.Neural.Networks.Training.PNN,TrainBasicPNN,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\PNN\TrainBasicPNN.cs,Iteration,The following statement contains a magic number: globalMinimum.Y2 = 1.0e30d;
Magic Number,Encog.Neural.Networks.Training.PNN,TrainBasicPNN,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\PNN\TrainBasicPNN.cs,Iteration,The following statement contains a magic number: double d = dermin.Calculate(32767' _maxError' 1.0e-8d'                                          _minImprovement' this' _network.InputCount' x'                                          globalMinimum.Y2' bs' direc' g' h' dwk2);
Magic Number,Encog.Neural.Networks.Training.PNN,TrainBasicPNN,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\PNN\TrainBasicPNN.cs,Iteration,The following statement contains a magic number: double d = dermin.Calculate(32767' _maxError' 1.0e-8d'                                          _minImprovement' this' _network.InputCount' x'                                          globalMinimum.Y2' bs' direc' g' h' dwk2);
Magic Number,Encog.Neural.Networks.Training.Propagation,GradientWorker,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\Propagation\GradientWorker.cs,Process,The following statement contains a magic number: double[] lp = new double[2];
Magic Number,Encog.Neural.Networks.Training.Propagation,Propagation,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\Propagation\Propagation.cs,Init,The following statement contains a magic number: _flatSpot[i] = 0.1;
Magic Number,Encog.Neural.Networks.Training.Propagation.SCG,ScaledConjugateGradient,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\Propagation\SCG\ScaledConjugateGradient.cs,CalculateGradients,The following statement contains a magic number: double factor = -2D / Gradients.Length / outCount;
Magic Number,Encog.Neural.Networks.Training.Propagation.SCG,ScaledConjugateGradient,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\Propagation\SCG\ScaledConjugateGradient.cs,Iteration,The following statement contains a magic number: _lambda2 = 2 * (_lambda - _delta / _magP);
Magic Number,Encog.Neural.Networks.Training.Propagation.SCG,ScaledConjugateGradient,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\Propagation\SCG\ScaledConjugateGradient.cs,Iteration,The following statement contains a magic number: double gdelta = 2 * _delta * (_oldError - Error)                              / (mu * mu);
Magic Number,Encog.Neural.Networks.Training.Propagation.SCG,ScaledConjugateGradient,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\Propagation\SCG\ScaledConjugateGradient.cs,Iteration,The following statement contains a magic number: _lambda *= 0.25D;
Magic Number,Encog.Neural.Networks.Training.Propagation.SCG,ScaledConjugateGradient,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\Propagation\SCG\ScaledConjugateGradient.cs,Iteration,The following statement contains a magic number: gdelta >= 0.75D
Magic Number,Encog.Neural.Networks.Training.Propagation.SCG,ScaledConjugateGradient,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\Propagation\SCG\ScaledConjugateGradient.cs,Iteration,The following statement contains a magic number: gdelta < 0.25D
Magic Number,Encog.Neural.Networks.Training.Propagation.SGD,BatchDataSet,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\Propagation\SGD\BatchDataSet.cs,BatchDataSet,The following statement contains a magic number: BatchSize = 500;
Magic Number,Encog.Neural.Networks.Training.Propagation.SGD,StochasticGradientDescent,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\Propagation\SGD\StochasticGradientDescent.cs,StochasticGradientDescent,The following statement contains a magic number: BatchSize = 25;
Magic Number,Encog.Neural.Networks.Training.Propagation.SGD,StochasticGradientDescent,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\Propagation\SGD\StochasticGradientDescent.cs,StochasticGradientDescent,The following statement contains a magic number: LearningRate = 0.001;
Magic Number,Encog.Neural.Networks.Training.Propagation.SGD,StochasticGradientDescent,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\Propagation\SGD\StochasticGradientDescent.cs,StochasticGradientDescent,The following statement contains a magic number: Momentum = 0.9;
Magic Number,Encog.Neural.Networks.Training.Propagation.SGD,StochasticGradientDescent,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\Propagation\SGD\StochasticGradientDescent.cs,Process,The following statement contains a magic number: double[] lp = new double[2];
Magic Number,Encog.Neural.Networks.Training.Propagation.SGD.Update,RMSPropUpdate,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\Propagation\SGD\Update\RMSPropUpdate.cs,RMSPropUpdate,The following statement contains a magic number: DecayRate = 0.99;
Magic Number,Encog.Neural.Networks.Training.Propagation.SGD.Update,RMSPropUpdate,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\Propagation\SGD\Update\RMSPropUpdate.cs,RMSPropUpdate,The following statement contains a magic number: EPS = 1e-8;
Magic Number,Encog.Neural.Networks.Training.Propagation.SGD.Update,AdaGradUpdate,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\Propagation\SGD\Update\AdaGradUpdate.cs,AdaGradUpdate,The following statement contains a magic number: EPS = 1e-8;
Magic Number,Encog.Neural.Networks.Training.Simple,TrainAdaline,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Networks\Training\Simple\TrainAdaline.cs,TrainAdaline,The following statement contains a magic number: network.LayerCount > 2
Magic Number,Encog.Neural.Pattern,ADALINEPattern,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Pattern\ADALINEPattern.cs,Generate,The following statement contains a magic number: (new RangeRandomizer(-0.5d' 0.5d)).Randomize(network);
Magic Number,Encog.Neural.Pattern,ADALINEPattern,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Pattern\ADALINEPattern.cs,Generate,The following statement contains a magic number: (new RangeRandomizer(-0.5d' 0.5d)).Randomize(network);
Magic Number,Encog.Neural.Pattern,ART1Pattern,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Pattern\ART1Pattern.cs,ART1Pattern,The following statement contains a magic number: _b1 = 1.5d;
Magic Number,Encog.Neural.Pattern,ART1Pattern,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Pattern\ART1Pattern.cs,ART1Pattern,The following statement contains a magic number: _c1 = 5;
Magic Number,Encog.Neural.Pattern,ART1Pattern,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Pattern\ART1Pattern.cs,ART1Pattern,The following statement contains a magic number: _d1 = 0.9d;
Magic Number,Encog.Neural.Pattern,ART1Pattern,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Pattern\ART1Pattern.cs,ART1Pattern,The following statement contains a magic number: _l = 3;
Magic Number,Encog.Neural.Pattern,ART1Pattern,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Pattern\ART1Pattern.cs,ART1Pattern,The following statement contains a magic number: _vigilance = 0.9d;
Magic Number,Encog.Neural.Pattern,BoltzmannPattern,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Pattern\BoltzmannPattern.cs,BoltzmannPattern,The following statement contains a magic number: _annealCycles = 100;
Magic Number,Encog.Neural.Pattern,BoltzmannPattern,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Pattern\BoltzmannPattern.cs,BoltzmannPattern,The following statement contains a magic number: _runCycles = 1000;
Magic Number,Encog.Neural.PNN,AbstractPNN,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\PNN\AbstractPNN.cs,AbstractPNN,The following statement contains a magic number: Error = -1000;
Magic Number,Encog.Neural.PNN,BasicPNN,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\PNN\BasicPNN.cs,Compute,The following statement contains a magic number: dist = 1.0e-40d;
Magic Number,Encog.Neural.PNN,BasicPNN,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\PNN\BasicPNN.cs,Compute,The following statement contains a magic number: dist < 1.0e-40d
Magic Number,Encog.Neural.PNN,BasicPNN,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\PNN\BasicPNN.cs,Compute,The following statement contains a magic number: psum = 1.0e-40d;
Magic Number,Encog.Neural.PNN,BasicPNN,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\PNN\BasicPNN.cs,Compute,The following statement contains a magic number: psum < 1.0e-40d
Magic Number,Encog.Neural.Prune,PruneIncremental,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Prune\PruneIncremental.cs,PerformJobUnit,The following statement contains a magic number: var strat = new StopTrainingStrategy(0.001d'                                                       5);
Magic Number,Encog.Neural.Prune,PruneIncremental,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Prune\PruneIncremental.cs,PerformJobUnit,The following statement contains a magic number: var strat = new StopTrainingStrategy(0.001d'                                                       5);
Magic Number,Encog.Neural.Prune,PruneIncremental,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Prune\PruneIncremental.cs,PerformJobUnit,The following statement contains a magic number: networkHidden2Count = network.GetLayerNeuronCount(2);
Magic Number,Encog.Neural.Prune,PruneIncremental,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Prune\PruneIncremental.cs,PerformJobUnit,The following statement contains a magic number: network.LayerCount > 3
Magic Number,Encog.Neural.RBF,RBFNetwork,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\RBF\RBFNetwork.cs,RBFNetwork,The following statement contains a magic number: double volumeNeuronWidth = 2.0d/hiddenCount;
Magic Number,Encog.Neural.RBF,RBFNetwork,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\RBF\RBFNetwork.cs,SetRBFCentersAndWidthsEqualSpacing,The following statement contains a magic number: throw new NeuralNetworkError(                      "Total number of RBF neurons must be some integer to the power of 'dimensions'.\n"                      + Format.FormatDouble(expectedSideLength' 5)                      + " <> " + Format.FormatDouble(cmp' 5));
Magic Number,Encog.Neural.RBF,RBFNetwork,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\RBF\RBFNetwork.cs,SetRBFCentersAndWidthsEqualSpacing,The following statement contains a magic number: throw new NeuralNetworkError(                      "Total number of RBF neurons must be some integer to the power of 'dimensions'.\n"                      + Format.FormatDouble(expectedSideLength' 5)                      + " <> " + Format.FormatDouble(cmp' 5));
Magic Number,Encog.Neural.RBF,RBFNetwork,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\RBF\RBFNetwork.cs,SetRBFCentersAndWidthsEqualSpacing,The following statement contains a magic number: double edgeNeuronRBFWidth = 2.5d*volumeNeuronRBFWidth;
Magic Number,Encog.Neural.RBF,RBFNetwork,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\RBF\RBFNetwork.cs,SetRBFFunction,The following statement contains a magic number: _flat.RBF[index] = new GaussianFunction(0.5d' centers'                                                         width);
Magic Number,Encog.Neural.RBF.Training,SVD,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\RBF\Training\SVD.cs,Svdfit,The following statement contains a magic number: double wmax' tmp' thresh' sum' TOL = 1e-13d;
Magic Number,Encog.Neural.RBF.Training,SVD,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\RBF\Training\SVD.cs,Svdcmp,The following statement contains a magic number: l = i + 2;
Magic Number,Encog.Neural.RBF.Training,SVD,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\RBF\Training\SVD.cs,Svdcmp,The following statement contains a magic number: its == 29
Magic Number,Encog.Neural.RBF.Training,SVD,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\RBF\Training\SVD.cs,Svdcmp,The following statement contains a magic number: f = ((y - z)*(y + z) + (g - h)*(g + h))/(2.0d*h*y);
Magic Number,Encog.Neural.RBF.Training,SVD,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\RBF\Training\SVD.cs,Svdcmp,The following statement contains a magic number: its < 30
Magic Number,Encog.Neural.SOM,SOMNetwork,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\SOM\SOMNetwork.cs,CalculateError,The following statement contains a magic number: return bmu.WorstDistance/100.0;
Magic Number,Encog.Neural.SOM.Training.Neighborhood,BasicTrainSOM,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\SOM\Training\Neighborhood\BasicTrainSOM.cs,Iteration,The following statement contains a magic number: Error = _bmuUtil.WorstDistance/100.0;
Magic Number,Encog.Neural.SOM.Training.Neighborhood,BasicTrainSOM,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\SOM\Training\Neighborhood\BasicTrainSOM.cs,ToString,The following statement contains a magic number: result.Append(Format.FormatDouble(_radius' 2));
Magic Number,Encog.Neural.SOM.Training.Neighborhood,NeighborhoodRBF,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\SOM\Training\Neighborhood\NeighborhoodRBF.cs,NeighborhoodRBF,The following statement contains a magic number: var size = new int[2];
Magic Number,Encog.Neural.SOM.Training.Neighborhood,NeighborhoodRBF,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\SOM\Training\Neighborhood\NeighborhoodRBF.cs,NeighborhoodRBF,The following statement contains a magic number: var centerArray = new double[2];
Magic Number,Encog.Neural.SOM.Training.Neighborhood,NeighborhoodRBF,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\SOM\Training\Neighborhood\NeighborhoodRBF.cs,NeighborhoodRBF,The following statement contains a magic number: var widthArray = new double[2];
Magic Number,Encog.Neural.SOM.Training.Neighborhood,NeighborhoodRBF,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\SOM\Training\Neighborhood\NeighborhoodRBF.cs,NeighborhoodRBF,The following statement contains a magic number: switch (type)              {                  case RBFEnum.Gaussian:                      _rbf = new GaussianFunction(2);                      break;                  case RBFEnum.InverseMultiquadric:                      _rbf = new InverseMultiquadricFunction(2);                      break;                  case RBFEnum.Multiquadric:                      _rbf = new MultiquadricFunction(2);                      break;                  case RBFEnum.MexicanHat:                      _rbf = new MexicanHatFunction(2);                      break;              }
Magic Number,Encog.Neural.SOM.Training.Neighborhood,NeighborhoodRBF,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\SOM\Training\Neighborhood\NeighborhoodRBF.cs,NeighborhoodRBF,The following statement contains a magic number: switch (type)              {                  case RBFEnum.Gaussian:                      _rbf = new GaussianFunction(2);                      break;                  case RBFEnum.InverseMultiquadric:                      _rbf = new InverseMultiquadricFunction(2);                      break;                  case RBFEnum.Multiquadric:                      _rbf = new MultiquadricFunction(2);                      break;                  case RBFEnum.MexicanHat:                      _rbf = new MexicanHatFunction(2);                      break;              }
Magic Number,Encog.Neural.SOM.Training.Neighborhood,NeighborhoodRBF,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\SOM\Training\Neighborhood\NeighborhoodRBF.cs,NeighborhoodRBF,The following statement contains a magic number: switch (type)              {                  case RBFEnum.Gaussian:                      _rbf = new GaussianFunction(2);                      break;                  case RBFEnum.InverseMultiquadric:                      _rbf = new InverseMultiquadricFunction(2);                      break;                  case RBFEnum.Multiquadric:                      _rbf = new MultiquadricFunction(2);                      break;                  case RBFEnum.MexicanHat:                      _rbf = new MexicanHatFunction(2);                      break;              }
Magic Number,Encog.Neural.SOM.Training.Neighborhood,NeighborhoodRBF,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\SOM\Training\Neighborhood\NeighborhoodRBF.cs,NeighborhoodRBF,The following statement contains a magic number: switch (type)              {                  case RBFEnum.Gaussian:                      _rbf = new GaussianFunction(2);                      break;                  case RBFEnum.InverseMultiquadric:                      _rbf = new InverseMultiquadricFunction(2);                      break;                  case RBFEnum.Multiquadric:                      _rbf = new MultiquadricFunction(2);                      break;                  case RBFEnum.MexicanHat:                      _rbf = new MexicanHatFunction(2);                      break;              }
Magic Number,Encog.Neural.SOM.Training.Neighborhood,NeighborhoodRBF,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\SOM\Training\Neighborhood\NeighborhoodRBF.cs,NeighborhoodRBF,The following statement contains a magic number: switch (type)              {                  case RBFEnum.Gaussian:                      _rbf = new GaussianFunction(2);                      break;                  case RBFEnum.InverseMultiquadric:                      _rbf = new InverseMultiquadricFunction(2);                      break;                  case RBFEnum.Multiquadric:                      _rbf = new MultiquadricFunction(2);                      break;                  case RBFEnum.MexicanHat:                      _rbf = new MexicanHatFunction(2);                      break;              }
Magic Number,Encog.Neural.SOM.Training.Neighborhood,NeighborhoodRBF,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\SOM\Training\Neighborhood\NeighborhoodRBF.cs,NeighborhoodRBF,The following statement contains a magic number: switch (type)              {                  case RBFEnum.Gaussian:                      _rbf = new GaussianFunction(2);                      break;                  case RBFEnum.InverseMultiquadric:                      _rbf = new InverseMultiquadricFunction(2);                      break;                  case RBFEnum.Multiquadric:                      _rbf = new MultiquadricFunction(2);                      break;                  case RBFEnum.MexicanHat:                      _rbf = new MexicanHatFunction(2);                      break;              }
Magic Number,Encog.Neural.SOM.Training.Neighborhood,NeighborhoodRBF,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\SOM\Training\Neighborhood\NeighborhoodRBF.cs,NeighborhoodRBF,The following statement contains a magic number: switch (type)              {                  case RBFEnum.Gaussian:                      _rbf = new GaussianFunction(2);                      break;                  case RBFEnum.InverseMultiquadric:                      _rbf = new InverseMultiquadricFunction(2);                      break;                  case RBFEnum.Multiquadric:                      _rbf = new MultiquadricFunction(2);                      break;                  case RBFEnum.MexicanHat:                      _rbf = new MexicanHatFunction(2);                      break;              }
Magic Number,Encog.Neural.SOM.Training.Neighborhood,NeighborhoodRBF,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\SOM\Training\Neighborhood\NeighborhoodRBF.cs,NeighborhoodRBF,The following statement contains a magic number: switch (type)              {                  case RBFEnum.Gaussian:                      _rbf = new GaussianFunction(2);                      break;                  case RBFEnum.InverseMultiquadric:                      _rbf = new InverseMultiquadricFunction(2);                      break;                  case RBFEnum.Multiquadric:                      _rbf = new MultiquadricFunction(2);                      break;                  case RBFEnum.MexicanHat:                      _rbf = new MexicanHatFunction(2);                      break;              }
Magic Number,Encog.Neural.Thermal,BoltzmannMachine,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Thermal\BoltzmannMachine.cs,BoltzmannMachine,The following statement contains a magic number: _annealCycles = 100;
Magic Number,Encog.Neural.Thermal,BoltzmannMachine,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Thermal\BoltzmannMachine.cs,BoltzmannMachine,The following statement contains a magic number: _runCycles = 1000;
Magic Number,Encog.Neural.Thermal,BoltzmannMachine,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Thermal\BoltzmannMachine.cs,BoltzmannMachine,The following statement contains a magic number: _annealCycles = 100;
Magic Number,Encog.Neural.Thermal,BoltzmannMachine,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Thermal\BoltzmannMachine.cs,BoltzmannMachine,The following statement contains a magic number: _runCycles = 1000;
Magic Number,Encog.Neural.Thermal,ThermalNetwork,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\Thermal\ThermalNetwork.cs,CalculateEnergy,The following statement contains a magic number: return -1*tempE/2;
Magic Number,Encog.Parse.Expression,CommonRender,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Parse\Expression\CommonRender.cs,DetermineNodeType,The following statement contains a magic number: node.ChildNodes.Count != 2
Magic Number,Encog.Parse.Expression.Common,ParseCommonExpression,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Parse\Expression\Common\ParseCommonExpression.cs,HandleNumeric,The following statement contains a magic number: value = (10.0 * value) + (this.parser.ReadChar() - '0');
Magic Number,Encog.Parse.Expression.Common,ParseCommonExpression,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Parse\Expression\Common\ParseCommonExpression.cs,HandleNumeric,The following statement contains a magic number: f /= Math.Pow(10.0' i);
Magic Number,Encog.Parse.Expression.Common,ParseCommonExpression,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Parse\Expression\Common\ParseCommonExpression.cs,HandleNumeric,The following statement contains a magic number: exponent = (int)(10.0 * exponent)                              + (this.parser.ReadChar() - '0');
Magic Number,Encog.Parse.Expression.Common,ParseCommonExpression,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Parse\Expression\Common\ParseCommonExpression.cs,HandleNumeric,The following statement contains a magic number: value = value * Math.Pow(10' exponent);
Magic Number,Encog.Parse.Expression.Common,ParseCommonExpression,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Parse\Expression\Common\ParseCommonExpression.cs,handleString,The following statement contains a magic number: this.parser.Peek() == 34
Magic Number,Encog.Parse.Expression.Common,ParseCommonExpression,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Parse\Expression\Common\ParseCommonExpression.cs,handleString,The following statement contains a magic number: ch == 34
Magic Number,Encog.Parse.Expression.Common,ParseCommonExpression,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Parse\Expression\Common\ParseCommonExpression.cs,handleString,The following statement contains a magic number: ch != 34
Magic Number,Encog.Parse.Expression.Latex,RenderLatexExpression,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Parse\Expression\Latex\RenderLatexExpression.cs,HandleOperator,The following statement contains a magic number: temp.ChildNodeCount == 2
Magic Number,Encog.Persist,EncogDirectoryPersistence,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Persist\EncogDirectoryPersistence.cs,LoadObject,The following statement contains a magic number: p.FileVersion < Int32.Parse(paras[4])
Magic Number,Encog.Persist,EncogDirectoryPersistence,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Persist\EncogDirectoryPersistence.cs,ReadLine,The following statement contains a magic number: (ch != 13) && (ch != 10)
Magic Number,Encog.Persist,EncogDirectoryPersistence,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Persist\EncogDirectoryPersistence.cs,ReadLine,The following statement contains a magic number: (ch != 13) && (ch != 10)
Magic Number,Encog.Persist,EncogDirectoryPersistence,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Persist\EncogDirectoryPersistence.cs,SaveObject,The following statement contains a magic number: pw.WriteLine("encog'" + p.PersistClassString + "'java'"                               + EncogFramework.Version + "'" + p.FileVersion + "'"                               + (now.Ticks/10000));
Magic Number,Encog.Persist,EncogFileSection,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Persist\EncogFileSection.cs,ParseDoubleArray,The following statement contains a magic number: int i = int.Parse(v.Substring(2));
Magic Number,Encog.Persist,EncogFileSection,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Persist\EncogFileSection.cs,ParseMatrix,The following statement contains a magic number: int index = 2;
Magic Number,Encog.Persist,EncogReadHelper,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Persist\EncogReadHelper.cs,ReadLargeArray,The following statement contains a magic number: String str = line.Substring(9);
Magic Number,Encog.Persist,EncogWriteHelper,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Persist\EncogWriteHelper.cs,WriteProperty,The following statement contains a magic number: d.Length < 2048
Magic Number,Encog.Util.Banchmark,EncogBenchmark,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Banchmark\EncogBenchmark.cs,EvalCpu,The following statement contains a magic number: int small = Evaluate.EvaluateTrain(2' 4' 0' 1);
Magic Number,Encog.Util.Banchmark,EncogBenchmark,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Banchmark\EncogBenchmark.cs,EvalCpu,The following statement contains a magic number: int small = Evaluate.EvaluateTrain(2' 4' 0' 1);
Magic Number,Encog.Util.Banchmark,EncogBenchmark,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Banchmark\EncogBenchmark.cs,EvalCpu,The following statement contains a magic number: _report.Report(Steps' Step1'                            "Evaluate CPU' tiny= " + Format.FormatInteger(small/100));
Magic Number,Encog.Util.Banchmark,EncogBenchmark,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Banchmark\EncogBenchmark.cs,EvalCpu,The following statement contains a magic number: int medium = Evaluate.EvaluateTrain(10' 20' 0' 1);
Magic Number,Encog.Util.Banchmark,EncogBenchmark,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Banchmark\EncogBenchmark.cs,EvalCpu,The following statement contains a magic number: int medium = Evaluate.EvaluateTrain(10' 20' 0' 1);
Magic Number,Encog.Util.Banchmark,EncogBenchmark,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Banchmark\EncogBenchmark.cs,EvalCpu,The following statement contains a magic number: _report.Report(Steps' Step1'                            "Evaluate CPU' small= " + Format.FormatInteger(medium/30));
Magic Number,Encog.Util.Banchmark,EncogBenchmark,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Banchmark\EncogBenchmark.cs,EvalCpu,The following statement contains a magic number: int large = Evaluate.EvaluateTrain(100' 200' 40' 5);
Magic Number,Encog.Util.Banchmark,EncogBenchmark,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Banchmark\EncogBenchmark.cs,EvalCpu,The following statement contains a magic number: int large = Evaluate.EvaluateTrain(100' 200' 40' 5);
Magic Number,Encog.Util.Banchmark,EncogBenchmark,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Banchmark\EncogBenchmark.cs,EvalCpu,The following statement contains a magic number: int large = Evaluate.EvaluateTrain(100' 200' 40' 5);
Magic Number,Encog.Util.Banchmark,EncogBenchmark,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Banchmark\EncogBenchmark.cs,EvalCpu,The following statement contains a magic number: int large = Evaluate.EvaluateTrain(100' 200' 40' 5);
Magic Number,Encog.Util.Banchmark,EncogBenchmark,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Banchmark\EncogBenchmark.cs,EvalCpu,The following statement contains a magic number: int huge = Evaluate.EvaluateTrain(200' 300' 200' 50);
Magic Number,Encog.Util.Banchmark,EncogBenchmark,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Banchmark\EncogBenchmark.cs,EvalCpu,The following statement contains a magic number: int huge = Evaluate.EvaluateTrain(200' 300' 200' 50);
Magic Number,Encog.Util.Banchmark,EncogBenchmark,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Banchmark\EncogBenchmark.cs,EvalCpu,The following statement contains a magic number: int huge = Evaluate.EvaluateTrain(200' 300' 200' 50);
Magic Number,Encog.Util.Banchmark,EncogBenchmark,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Banchmark\EncogBenchmark.cs,EvalCpu,The following statement contains a magic number: int huge = Evaluate.EvaluateTrain(200' 300' 200' 50);
Magic Number,Encog.Util.Banchmark,EncogBenchmark,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Banchmark\EncogBenchmark.cs,EvalCpu,The following statement contains a magic number: int result = (small/100) + (medium/30) + large + huge;
Magic Number,Encog.Util.Banchmark,EncogBenchmark,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Banchmark\EncogBenchmark.cs,EvalCpu,The following statement contains a magic number: int result = (small/100) + (medium/30) + large + huge;
Magic Number,Encog.Util.Banchmark,EncogBenchmark,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Banchmark\EncogBenchmark.cs,EvalMemory,The following statement contains a magic number: BasicMLDataSet training = RandomTrainingFactory.Generate(                  1000' 10000' 10' 10' -1' 1);
Magic Number,Encog.Util.Banchmark,EncogBenchmark,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Banchmark\EncogBenchmark.cs,EvalMemory,The following statement contains a magic number: BasicMLDataSet training = RandomTrainingFactory.Generate(                  1000' 10000' 10' 10' -1' 1);
Magic Number,Encog.Util.Banchmark,EncogBenchmark,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Banchmark\EncogBenchmark.cs,EvalMemory,The following statement contains a magic number: BasicMLDataSet training = RandomTrainingFactory.Generate(                  1000' 10000' 10' 10' -1' 1);
Magic Number,Encog.Util.Banchmark,EncogBenchmark,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Banchmark\EncogBenchmark.cs,EvalMemory,The following statement contains a magic number: BasicMLDataSet training = RandomTrainingFactory.Generate(                  1000' 10000' 10' 10' -1' 1);
Magic Number,Encog.Util.Banchmark,EncogBenchmark,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Banchmark\EncogBenchmark.cs,EvalMemory,The following statement contains a magic number: const long stop = (10*Evaluate.Milis);
Magic Number,Encog.Util.Banchmark,EncogBenchmark,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Banchmark\EncogBenchmark.cs,EvalMemory,The following statement contains a magic number: iterations /= 100000;
Magic Number,Encog.Util.Banchmark,EncogBenchmark,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Banchmark\EncogBenchmark.cs,EvalBinary,The following statement contains a magic number: BasicMLDataSet training = RandomTrainingFactory.Generate(                  1000' 10000' 10' 10' -1' 1);
Magic Number,Encog.Util.Banchmark,EncogBenchmark,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Banchmark\EncogBenchmark.cs,EvalBinary,The following statement contains a magic number: BasicMLDataSet training = RandomTrainingFactory.Generate(                  1000' 10000' 10' 10' -1' 1);
Magic Number,Encog.Util.Banchmark,EncogBenchmark,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Banchmark\EncogBenchmark.cs,EvalBinary,The following statement contains a magic number: BasicMLDataSet training = RandomTrainingFactory.Generate(                  1000' 10000' 10' 10' -1' 1);
Magic Number,Encog.Util.Banchmark,EncogBenchmark,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Banchmark\EncogBenchmark.cs,EvalBinary,The following statement contains a magic number: BasicMLDataSet training = RandomTrainingFactory.Generate(                  1000' 10000' 10' 10' -1' 1);
Magic Number,Encog.Util.Banchmark,EncogBenchmark,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Banchmark\EncogBenchmark.cs,EvalBinary,The following statement contains a magic number: const long stop = (10*Evaluate.Milis);
Magic Number,Encog.Util.Banchmark,EncogBenchmark,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Banchmark\EncogBenchmark.cs,EvalBinary,The following statement contains a magic number: iterations /= 100000;
Magic Number,Encog.Util.Banchmark,Evaluate,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Banchmark\Evaluate.cs,EvaluateTrain,The following statement contains a magic number: IMLDataSet training = RandomTrainingFactory.Generate(1000'                                                                  10000' input' output' -1' 1);
Magic Number,Encog.Util.Banchmark,Evaluate,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Banchmark\Evaluate.cs,EvaluateTrain,The following statement contains a magic number: IMLDataSet training = RandomTrainingFactory.Generate(1000'                                                                  10000' input' output' -1' 1);
Magic Number,Encog.Util.Banchmark,Evaluate,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Banchmark\Evaluate.cs,EvaluateTrain,The following statement contains a magic number: const int milis10 = Milis * 10;
Magic Number,Encog.Util.Concurrency,DetermineWorkload,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Concurrency\DetermineWorkload.cs,DetermineWorkload,The following statement contains a magic number: var num = (int) (Math.Log(((double) Process.GetCurrentProcess().ProcessorAffinity + 1)' 2.0));
Magic Number,Encog.Util.Concurrency,DetermineWorkload,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Concurrency\DetermineWorkload.cs,DetermineWorkload,The following statement contains a magic number: num = Math.Max(1' (int) (recordCount/100));
Magic Number,Encog.Util.Concurrency,DetermineWorkload,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Concurrency\DetermineWorkload.cs,DetermineWorkload,The following statement contains a magic number: workPerThread < 100
Magic Number,Encog.Util.CSV,NumberList,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\CSV\NumberList.cs,ToList,The following statement contains a magic number: ToList(format' 20' result' data);
Magic Number,Encog.Util,Format,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Format.cs,FormatMemory,The following statement contains a magic number: return FormatDouble((memory)/((double) MemoryK)' 2) + " KB";
Magic Number,Encog.Util,Format,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Format.cs,FormatMemory,The following statement contains a magic number: return FormatDouble((memory)/((double) MemoryMeg)' 2) + " MB";
Magic Number,Encog.Util,Format,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Format.cs,FormatMemory,The following statement contains a magic number: return FormatDouble((memory)/((double) MemoryGig)' 2) + " GB";
Magic Number,Encog.Util,Format,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Format.cs,FormatMemory,The following statement contains a magic number: return FormatDouble((memory)/((double) MemoryTera)' 2) + " TB";
Magic Number,Encog.Util,Format,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Format.cs,FormatPercent,The following statement contains a magic number: return (e*100.0).ToString("N6") + "%";
Magic Number,Encog.Util,Format,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Format.cs,FormatPercentWhole,The following statement contains a magic number: return (e*100.0).ToString("N0") + "%";
Magic Number,Encog.Util,DirectoryUtil,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\DirectoryUtil.cs,ReadStream,The following statement contains a magic number: var sb = new StringBuilder(1024);
Magic Number,Encog.Util,StringUtil,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\StringUtil.cs,FromBytes,The following statement contains a magic number: var b2 = new byte[b.Length*2];
Magic Number,Encog.Util,StringUtil,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\StringUtil.cs,FromBytes,The following statement contains a magic number: b2[i*2] = b[i];
Magic Number,Encog.Util,StringUtil,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\StringUtil.cs,FromBytes,The following statement contains a magic number: b2[(i*2) + 1] = 0;
Magic Number,Encog.Util.File,Directory,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\File\Directory.cs,ReadStream,The following statement contains a magic number: var sb = new StringBuilder(1024);
Magic Number,Encog.Util.File,FileUtil,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\File\FileUtil.cs,ReadFileAsString,The following statement contains a magic number: var fileData = new StringBuilder(1000);
Magic Number,Encog.Util.File,FileUtil,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\File\FileUtil.cs,ReadFileAsString,The following statement contains a magic number: var buf = new char[1024];
Magic Number,Encog.Util.File,FileUtil,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\File\FileUtil.cs,ReadFileAsString,The following statement contains a magic number: buf = new char[1024];
Magic Number,Encog.Util.File,FileUtil,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\File\FileUtil.cs,CopyStream,The following statement contains a magic number: var buffer = new byte[32768];
Magic Number,Encog.Util.NetworkUtil,DateNormalize,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\NetworkUtil\DateNormalize.cs,NormalizeMonth,The following statement contains a magic number: var eq = new Equilateral(12' -1' 1);
Magic Number,Encog.Util.NetworkUtil,DateNormalize,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\NetworkUtil\DateNormalize.cs,DenormalizeMonth,The following statement contains a magic number: var eq = new Equilateral(12' -1' 1);
Magic Number,Encog.Util.NetworkUtil,DateNormalize,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\NetworkUtil\DateNormalize.cs,NormalizeDays,The following statement contains a magic number: var eq = new Equilateral(31' -1' 1);
Magic Number,Encog.Util.NetworkUtil,DateNormalize,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\NetworkUtil\DateNormalize.cs,DenormalizeDays,The following statement contains a magic number: var eq = new Equilateral(31' -1' 1);
Magic Number,Encog.Util.NetworkUtil,DateNormalize,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\NetworkUtil\DateNormalize.cs,NormalizeHour,The following statement contains a magic number: var eq = new Equilateral(24' -1' 1);
Magic Number,Encog.Util.NetworkUtil,DateNormalize,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\NetworkUtil\DateNormalize.cs,DenormalizeHour,The following statement contains a magic number: var eq = new Equilateral(24' -1' 1);
Magic Number,Encog.Util.NetworkUtil,DateNormalize,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\NetworkUtil\DateNormalize.cs,NormalizeSeconds,The following statement contains a magic number: var eq = new Equilateral(60' -1' 1);
Magic Number,Encog.Util.NetworkUtil,DateNormalize,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\NetworkUtil\DateNormalize.cs,DenormalizeSeconds,The following statement contains a magic number: var eq = new Equilateral(60' -1' 1);
Magic Number,Encog.Util.NetworkUtil,DateNormalize,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\NetworkUtil\DateNormalize.cs,NormalizeYear,The following statement contains a magic number: var eq = new Equilateral(2011' -1' 1);
Magic Number,Encog.Util.NetworkUtil,DateNormalize,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\NetworkUtil\DateNormalize.cs,DenormalizeYear,The following statement contains a magic number: var eq = new Equilateral(2011' -1' 1);
Magic Number,Encog.Util.NetworkUtil,NetworkUtility,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\NetworkUtil\NetworkUtility.cs,DetermineAngle,The following statement contains a magic number: double result = (Math.Atan2(angle[0]' angle[1])/Math.PI)*180;
Magic Number,Encog.Util.NetworkUtil,NetworkUtility,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\NetworkUtil\NetworkUtility.cs,DetermineAngle,The following statement contains a magic number: result += 360;
Magic Number,Encog.Util.NetworkUtil,NetworkUtility,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\NetworkUtil\NetworkUtility.cs,AveragePercents,The following statement contains a magic number: return Math.Abs(first - second)/(first + second)*100;
Magic Number,Encog.Util.NetworkUtil,TrainerHelper,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\NetworkUtil\TrainerHelper.cs,AddInputsViaLinq,The following statement contains a magic number: ArrayList arlist = new ArrayList(4);
Magic Number,Encog.Util.NetworkUtil,TrainerHelper,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\NetworkUtil\TrainerHelper.cs,AddInputs,The following statement contains a magic number: ArrayList arlist = new ArrayList(4);
Magic Number,Encog.Util.Normalize,DataNormalization,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Normalize\DataNormalization.cs,ReportResult,The following statement contains a magic number: _lastReport >= 10000
Magic Number,Encog.Util.Normalize.Output.Nominal,OutputEquilateral,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Normalize\Output\Nominal\OutputEquilateral.cs,AddItem,The following statement contains a magic number: AddItem(inputField' value - 0.1' value + 0.1);
Magic Number,Encog.Util.Normalize.Output.Nominal,OutputEquilateral,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Normalize\Output\Nominal\OutputEquilateral.cs,AddItem,The following statement contains a magic number: AddItem(inputField' value - 0.1' value + 0.1);
Magic Number,Encog.Util.Normalize.Output.Nominal,OutputOneOf,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Normalize\Output\Nominal\OutputOneOf.cs,AddItem,The following statement contains a magic number: AddItem(inputField' value - 0.5' value + 0.5);
Magic Number,Encog.Util.Normalize.Output.Nominal,OutputOneOf,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Normalize\Output\Nominal\OutputOneOf.cs,AddItem,The following statement contains a magic number: AddItem(inputField' value - 0.5' value + 0.5);
Magic Number,Encog.Util.Simple,EncogUtility,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\EncogUtility.cs,FormatNeuralData,The following statement contains a magic number: result.Append(Format.FormatDouble(data[i]' 4));
Magic Number,Encog.Util.Simple,EncogUtility,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\EncogUtility.cs,TrainConsole,The following statement contains a magic number: long elapsed = (current - start)/1000;
Magic Number,Encog.Util.Simple,EncogUtility,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\EncogUtility.cs,TrainConsole,The following statement contains a magic number: remaining = minutes - elapsed/60;
Magic Number,Encog.Util.Simple,EncogUtility,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\EncogUtility.cs,TrainConsole,The following statement contains a magic number: Console.WriteLine(@"Iteration #" + Format.FormatInteger(epoch)                                    + @" Error:" + Format.FormatPercent(train.Error)                                    + @" elapsed time = " + Format.FormatTimeSpan((int) elapsed)                                    + @" time left = "                                    + Format.FormatTimeSpan((int) remaining*60));
Magic Number,Encog.Util.Simple,EncogUtility,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\EncogUtility.cs,TrainConsole,The following statement contains a magic number: double elapsed = (current - start) / 1000;
Magic Number,Encog.Util.Simple,TrainingDialog,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\TrainingDialog.cs,ThreadProcess,The following statement contains a magic number: elapsed /= 1000;
Magic Number,Encog.Util.Simple,TrainingDialog,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\TrainingDialog.cs,ThreadProcess,The following statement contains a magic number: var obj = new object[3];
Magic Number,Encog.Util.Simple,TrainingDialog,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\TrainingDialog.cs,ThreadProcess,The following statement contains a magic number: obj[2] = "" + Format.FormatTimeSpan((int) elapsed);
Magic Number,Encog.Util.Simple,TrainingDialog,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\TrainingDialog.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point(12' 9);
Magic Number,Encog.Util.Simple,TrainingDialog,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\TrainingDialog.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point(12' 9);
Magic Number,Encog.Util.Simple,TrainingDialog,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\TrainingDialog.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size(69' 13);
Magic Number,Encog.Util.Simple,TrainingDialog,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\TrainingDialog.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size(69' 13);
Magic Number,Encog.Util.Simple,TrainingDialog,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\TrainingDialog.cs,InitializeComponent,The following statement contains a magic number: this.button1.Location = new System.Drawing.Point(15' 96);
Magic Number,Encog.Util.Simple,TrainingDialog,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\TrainingDialog.cs,InitializeComponent,The following statement contains a magic number: this.button1.Location = new System.Drawing.Point(15' 96);
Magic Number,Encog.Util.Simple,TrainingDialog,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\TrainingDialog.cs,InitializeComponent,The following statement contains a magic number: this.button1.Size = new System.Drawing.Size(218' 23);
Magic Number,Encog.Util.Simple,TrainingDialog,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\TrainingDialog.cs,InitializeComponent,The following statement contains a magic number: this.button1.Size = new System.Drawing.Size(218' 23);
Magic Number,Encog.Util.Simple,TrainingDialog,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\TrainingDialog.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point(12' 36);
Magic Number,Encog.Util.Simple,TrainingDialog,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\TrainingDialog.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point(12' 36);
Magic Number,Encog.Util.Simple,TrainingDialog,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\TrainingDialog.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size(53' 13);
Magic Number,Encog.Util.Simple,TrainingDialog,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\TrainingDialog.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size(53' 13);
Magic Number,Encog.Util.Simple,TrainingDialog,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\TrainingDialog.cs,InitializeComponent,The following statement contains a magic number: this.label2.TabIndex = 2;
Magic Number,Encog.Util.Simple,TrainingDialog,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\TrainingDialog.cs,InitializeComponent,The following statement contains a magic number: this.label3.Location = new System.Drawing.Point(12' 66);
Magic Number,Encog.Util.Simple,TrainingDialog,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\TrainingDialog.cs,InitializeComponent,The following statement contains a magic number: this.label3.Location = new System.Drawing.Point(12' 66);
Magic Number,Encog.Util.Simple,TrainingDialog,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\TrainingDialog.cs,InitializeComponent,The following statement contains a magic number: this.label3.Size = new System.Drawing.Size(74' 13);
Magic Number,Encog.Util.Simple,TrainingDialog,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\TrainingDialog.cs,InitializeComponent,The following statement contains a magic number: this.label3.Size = new System.Drawing.Size(74' 13);
Magic Number,Encog.Util.Simple,TrainingDialog,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\TrainingDialog.cs,InitializeComponent,The following statement contains a magic number: this.label3.TabIndex = 3;
Magic Number,Encog.Util.Simple,TrainingDialog,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\TrainingDialog.cs,InitializeComponent,The following statement contains a magic number: this.currentError.Location = new System.Drawing.Point(133' 6);
Magic Number,Encog.Util.Simple,TrainingDialog,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\TrainingDialog.cs,InitializeComponent,The following statement contains a magic number: this.currentError.Location = new System.Drawing.Point(133' 6);
Magic Number,Encog.Util.Simple,TrainingDialog,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\TrainingDialog.cs,InitializeComponent,The following statement contains a magic number: this.currentError.Size = new System.Drawing.Size(100' 20);
Magic Number,Encog.Util.Simple,TrainingDialog,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\TrainingDialog.cs,InitializeComponent,The following statement contains a magic number: this.currentError.Size = new System.Drawing.Size(100' 20);
Magic Number,Encog.Util.Simple,TrainingDialog,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\TrainingDialog.cs,InitializeComponent,The following statement contains a magic number: this.currentError.TabIndex = 4;
Magic Number,Encog.Util.Simple,TrainingDialog,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\TrainingDialog.cs,InitializeComponent,The following statement contains a magic number: this.iterations.Location = new System.Drawing.Point(133' 36);
Magic Number,Encog.Util.Simple,TrainingDialog,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\TrainingDialog.cs,InitializeComponent,The following statement contains a magic number: this.iterations.Location = new System.Drawing.Point(133' 36);
Magic Number,Encog.Util.Simple,TrainingDialog,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\TrainingDialog.cs,InitializeComponent,The following statement contains a magic number: this.iterations.Size = new System.Drawing.Size(100' 20);
Magic Number,Encog.Util.Simple,TrainingDialog,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\TrainingDialog.cs,InitializeComponent,The following statement contains a magic number: this.iterations.Size = new System.Drawing.Size(100' 20);
Magic Number,Encog.Util.Simple,TrainingDialog,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\TrainingDialog.cs,InitializeComponent,The following statement contains a magic number: this.iterations.TabIndex = 5;
Magic Number,Encog.Util.Simple,TrainingDialog,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\TrainingDialog.cs,InitializeComponent,The following statement contains a magic number: this.trainingTime.Location = new System.Drawing.Point(133' 66);
Magic Number,Encog.Util.Simple,TrainingDialog,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\TrainingDialog.cs,InitializeComponent,The following statement contains a magic number: this.trainingTime.Location = new System.Drawing.Point(133' 66);
Magic Number,Encog.Util.Simple,TrainingDialog,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\TrainingDialog.cs,InitializeComponent,The following statement contains a magic number: this.trainingTime.Size = new System.Drawing.Size(100' 20);
Magic Number,Encog.Util.Simple,TrainingDialog,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\TrainingDialog.cs,InitializeComponent,The following statement contains a magic number: this.trainingTime.Size = new System.Drawing.Size(100' 20);
Magic Number,Encog.Util.Simple,TrainingDialog,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\TrainingDialog.cs,InitializeComponent,The following statement contains a magic number: this.trainingTime.TabIndex = 6;
Magic Number,Encog.Util.Simple,TrainingDialog,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\TrainingDialog.cs,InitializeComponent,The following statement contains a magic number: this.AutoScaleDimensions = new System.Drawing.SizeF(6F' 13F);
Magic Number,Encog.Util.Simple,TrainingDialog,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\TrainingDialog.cs,InitializeComponent,The following statement contains a magic number: this.AutoScaleDimensions = new System.Drawing.SizeF(6F' 13F);
Magic Number,Encog.Util.Simple,TrainingDialog,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\TrainingDialog.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(253' 127);
Magic Number,Encog.Util.Simple,TrainingDialog,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Simple\TrainingDialog.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(253' 127);
Magic Number,Encog.Util.Time,NumericDateUtil,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Time\NumericDateUtil.cs,GetMinutePeriod,The following statement contains a magic number: int minutes = minute + (hour*60);
Magic Number,Encog.Util.Time,NumericDateUtil,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Time\NumericDateUtil.cs,Combine,The following statement contains a magic number: return (date*1000000) + time;
Magic Number,Encog.Util.Time,NumericDateUtil,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Time\NumericDateUtil.cs,GetDayOfWeek,The following statement contains a magic number: switch (t.DayOfWeek)              {                  case DayOfWeek.Sunday:                      return 0;                  case DayOfWeek.Monday:                      return 1;                  case DayOfWeek.Tuesday:                      return 2;                  case DayOfWeek.Wednesday:                      return 3;                  case DayOfWeek.Thursday:                      return 4;                  case DayOfWeek.Friday:                      return 5;                  case DayOfWeek.Saturday:                      return 6;                  default:                      // no way this should happen!                      return -1;              }
Magic Number,Encog.Util.Time,NumericDateUtil,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Time\NumericDateUtil.cs,GetDayOfWeek,The following statement contains a magic number: switch (t.DayOfWeek)              {                  case DayOfWeek.Sunday:                      return 0;                  case DayOfWeek.Monday:                      return 1;                  case DayOfWeek.Tuesday:                      return 2;                  case DayOfWeek.Wednesday:                      return 3;                  case DayOfWeek.Thursday:                      return 4;                  case DayOfWeek.Friday:                      return 5;                  case DayOfWeek.Saturday:                      return 6;                  default:                      // no way this should happen!                      return -1;              }
Magic Number,Encog.Util.Time,NumericDateUtil,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Time\NumericDateUtil.cs,GetDayOfWeek,The following statement contains a magic number: switch (t.DayOfWeek)              {                  case DayOfWeek.Sunday:                      return 0;                  case DayOfWeek.Monday:                      return 1;                  case DayOfWeek.Tuesday:                      return 2;                  case DayOfWeek.Wednesday:                      return 3;                  case DayOfWeek.Thursday:                      return 4;                  case DayOfWeek.Friday:                      return 5;                  case DayOfWeek.Saturday:                      return 6;                  default:                      // no way this should happen!                      return -1;              }
Magic Number,Encog.Util.Time,NumericDateUtil,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Time\NumericDateUtil.cs,GetDayOfWeek,The following statement contains a magic number: switch (t.DayOfWeek)              {                  case DayOfWeek.Sunday:                      return 0;                  case DayOfWeek.Monday:                      return 1;                  case DayOfWeek.Tuesday:                      return 2;                  case DayOfWeek.Wednesday:                      return 3;                  case DayOfWeek.Thursday:                      return 4;                  case DayOfWeek.Friday:                      return 5;                  case DayOfWeek.Saturday:                      return 6;                  default:                      // no way this should happen!                      return -1;              }
Magic Number,Encog.Util.Time,NumericDateUtil,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Time\NumericDateUtil.cs,GetDayOfWeek,The following statement contains a magic number: switch (t.DayOfWeek)              {                  case DayOfWeek.Sunday:                      return 0;                  case DayOfWeek.Monday:                      return 1;                  case DayOfWeek.Tuesday:                      return 2;                  case DayOfWeek.Wednesday:                      return 3;                  case DayOfWeek.Thursday:                      return 4;                  case DayOfWeek.Friday:                      return 5;                  case DayOfWeek.Saturday:                      return 6;                  default:                      // no way this should happen!                      return -1;              }
Magic Number,Encog.Util.Time,TimeSpanUtil,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Time\TimeSpanUtil.cs,GetSpanMinutes,The following statement contains a magic number: return GetSpanSeconds()/60;
Magic Number,Encog.Util.Time,TimeSpanUtil,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Time\TimeSpanUtil.cs,GetSpanHours,The following statement contains a magic number: return GetSpanMinutes()/60;
Magic Number,Encog.Util.Time,TimeSpanUtil,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Time\TimeSpanUtil.cs,GetSpanDays,The following statement contains a magic number: return GetSpanHours()/24;
Magic Number,Encog.Util.Time,TimeSpanUtil,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Time\TimeSpanUtil.cs,GetSpanWeeks,The following statement contains a magic number: return GetSpanDays()/7;
Magic Number,Encog.Util.Time,TimeSpanUtil,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Time\TimeSpanUtil.cs,GetSpanFortnights,The following statement contains a magic number: return GetSpanWeeks()/2;
Magic Number,Encog.Util.Time,TimeSpanUtil,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Time\TimeSpanUtil.cs,GetSpanMonths,The following statement contains a magic number: return (_to.Month - _from.Month) + (_to.Year - _from.Year)*12;
Magic Number,Encog.Util.Time,TimeSpanUtil,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Time\TimeSpanUtil.cs,GetSpanYears,The following statement contains a magic number: return GetSpanMonths()/12;
Magic Number,Encog.Util.Time,TimeSpanUtil,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Time\TimeSpanUtil.cs,GetSpanScores,The following statement contains a magic number: return GetSpanYears()/20;
Magic Number,Encog.Util.Time,TimeSpanUtil,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Time\TimeSpanUtil.cs,GetSpanCenturies,The following statement contains a magic number: return GetSpanYears()/100;
Magic Number,Encog.Util.Time,TimeSpanUtil,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\Time\TimeSpanUtil.cs,GetSpanMillennia,The following statement contains a magic number: return GetSpanYears()/1000;
Magic Number,Encog.Parse,PeekableInputStream,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Parse\PeekableInputStream.cs,PeekableInputStream,The following statement contains a magic number: _peekBytes = new byte[10];
Magic Number,Encog.Parse,PeekableInputStream,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Parse\PeekableInputStream.cs,Peek,The following statement contains a magic number: var temp = new byte[depth + 10];
Magic Number,Encog.Util.DownSample,RGBDownsample,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\DownSample\RGBDownsample.cs,DownSample,The following statement contains a magic number: var result = new double[height*width*3];
Magic Number,Encog.Util.DownSample,RGBDownsample,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\DownSample\RGBDownsample.cs,HLineClear,The following statement contains a magic number: pixel.R < 250 || pixel.G < 250 || pixel.B < 250
Magic Number,Encog.Util.DownSample,RGBDownsample,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\DownSample\RGBDownsample.cs,HLineClear,The following statement contains a magic number: pixel.R < 250 || pixel.G < 250 || pixel.B < 250
Magic Number,Encog.Util.DownSample,RGBDownsample,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\DownSample\RGBDownsample.cs,HLineClear,The following statement contains a magic number: pixel.R < 250 || pixel.G < 250 || pixel.B < 250
Magic Number,Encog.Util.DownSample,RGBDownsample,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\DownSample\RGBDownsample.cs,VLineClear,The following statement contains a magic number: pixel.R < 250 || pixel.G < 250 || pixel.B < 250
Magic Number,Encog.Util.DownSample,RGBDownsample,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\DownSample\RGBDownsample.cs,VLineClear,The following statement contains a magic number: pixel.R < 250 || pixel.G < 250 || pixel.B < 250
Magic Number,Encog.Util.DownSample,RGBDownsample,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\DownSample\RGBDownsample.cs,VLineClear,The following statement contains a magic number: pixel.R < 250 || pixel.G < 250 || pixel.B < 250
Magic Number,Encog.Util.DownSample,SimpleIntensityDownsample,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\DownSample\SimpleIntensityDownsample.cs,DownSample,The following statement contains a magic number: var result = new double[height*width*3];
Magic Number,Encog.Util.DownSample,SimpleIntensityDownsample,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\DownSample\SimpleIntensityDownsample.cs,DownSample,The following statement contains a magic number: result[index++] = (CurrentRed + CurrentBlue                                         + CurrentGreen)/3;
Magic Number,Encog.Util.HTTP,FormUtility,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\HTTP\FormUtility.cs,AddFile,The following statement contains a magic number: var buf = new byte[8192];
Magic Number,Encog.Util.HTTP,URLUtility,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\HTTP\URLUtility.cs,ConstructURL,The following statement contains a magic number: port == 80 && String.Compare(protocol' "http") != 0
Magic Number,Encog.Util.HTTP,URLUtility,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Util\HTTP\URLUtility.cs,ContainsInvalidURLCharacters,The following statement contains a magic number: return url.Any(ch => ch > 255);
Missing Default,Encog.App.Analyst.Wizard,AnalystWizard,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Analyst\Wizard\AnalystWizard.cs,GenerateProcess,The following switch statement is missing a default case: switch (prediction)              {                  case PredictionType.fieldmax:                      c.Append("fieldmax(\"");                      c.Append(predictField);                      c.Append("\"'");                      c.Append(-forwardWindow);                      c.Append("'");                      c.Append(-1);                      c.Append(")");                      break;                  case PredictionType.fieldmaxpip:                      c.Append("fieldmaxpip(\"");                      c.Append(predictField);                      c.Append("\"'");                      c.Append(-forwardWindow);                      c.Append("'");                      c.Append(-1);                      c.Append(")");                      break;              }
Missing Default,Encog.App.Generate,EncogCodeGeneration,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Generate\EncogCodeGeneration.cs,EncogCodeGeneration,The following switch statement is missing a default case: switch (theTargetLanguage)              {                  case TargetLanguage.NoGeneration:                      throw new AnalystCodeGenerationError(                          "No target language has been specified for code generation.");                  case TargetLanguage.Java:                      generator = new GenerateEncogJava();                      break;                  case TargetLanguage.CSharp:                      generator = new GenerateCS();                      break;                  case TargetLanguage.MQL4:                      generator = new GenerateMQL4();                      break;                  case TargetLanguage.NinjaScript:                      generator = new GenerateNinjaScript();                      break;                  case TargetLanguage.JavaScript:                      generator = new GenerateEncogJavaScript();                      break;              }
Missing Default,Encog.App.Generate.Generators.CS,GenerateCS,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Generate\Generators\CS\GenerateCS.cs,GenerateNode,The following switch statement is missing a default case: switch (node.Type)              {                  case NodeType.Comment:                      GenerateComment(node);                      break;                  case NodeType.Class:                      GenerateClass(node);                      break;                  case NodeType.MainFunction:                      GenerateMainFunction(node);                      break;                  case NodeType.Const:                      GenerateConst(node);                      break;                  case NodeType.StaticFunction:                      GenerateFunction(node);                      break;                  case NodeType.FunctionCall:                      GenerateFunctionCall(node);                      break;                  case NodeType.CreateNetwork:                      GenerateCreateNetwork(node);                      break;                  case NodeType.InitArray:                      GenerateArrayInit(node);                      break;                  case NodeType.EmbedTraining:                      GenerateEmbedTraining(node);                      break;                  case NodeType.LoadTraining:                      GenerateLoadTraining(node);                      break;              }
Missing Default,Encog.App.Generate.Generators.Java,GenerateEncogJava,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Generate\Generators\Java\GenerateEncogJava.cs,GenerateNode,The following switch statement is missing a default case: switch (node.Type)              {                  case NodeType.Comment:                      GenerateComment(node);                      break;                  case NodeType.Class:                      GenerateClass(node);                      break;                  case NodeType.MainFunction:                      GenerateMainFunction(node);                      break;                  case NodeType.Const:                      GenerateConst(node);                      break;                  case NodeType.StaticFunction:                      GenerateFunction(node);                      break;                  case NodeType.FunctionCall:                      GenerateFunctionCall(node);                      break;                  case NodeType.CreateNetwork:                      GenerateCreateNetwork(node);                      break;                  case NodeType.InitArray:                      GenerateArrayInit(node);                      break;                  case NodeType.EmbedTraining:                      GenerateEmbedTraining(node);                      break;                  case NodeType.LoadTraining:                      GenerateLoadTraining(node);                      break;              }
Missing Default,Encog.App.Generate.Generators.JS,GenerateEncogJavaScript,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Generate\Generators\JS\GenerateEncogJavaScript.cs,GenerateNode,The following switch statement is missing a default case: switch (node.Type)              {                  case NodeType.Comment:                      GenerateComment(node);                      break;                  case NodeType.Class:                      GenerateClass(node);                      break;                  case NodeType.MainFunction:                      GenerateMainFunction(node);                      break;                  case NodeType.Const:                      GenerateConst(node);                      break;                  case NodeType.StaticFunction:                      GenerateFunction(node);                      break;                  case NodeType.FunctionCall:                      GenerateFunctionCall(node);                      break;                  case NodeType.CreateNetwork:                      EmbedNetwork(node);                      break;                  case NodeType.InitArray:                      GenerateArrayInit(node);                      break;                  case NodeType.EmbedTraining:                      EmbedTraining(node);                      break;              }
Missing Default,Encog.App.Quant.Loader.OpenQuant.Data,Bar,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\App\Quant\Loader\OpenQuant\Bar.cs,GetPrice,The following switch statement is missing a default case: switch (option)                  {                      case BarPrice.High:                          return High;                        case BarPrice.Low:                          return Low;                        case BarPrice.Open:                          return Open;                        case BarPrice.Close:                          return Close;                        case BarPrice.Median:                          return Median;                        case BarPrice.Typical:                          return Typical;                        case BarPrice.Weighted:                          return Weighted;                  }
Missing Default,Encog.MathUtil.LIBSVM,svm,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\LIBSVM\svm.cs,svm_train_one,The following switch statement is missing a default case: switch (param.svm_type)              {                  case svm_parameter.C_SVC:                      solve_c_svc(prob' param' alpha' si' Cp' Cn);                      break;                    case svm_parameter.NU_SVC:                      solve_nu_svc(prob' param' alpha' si);                      break;                    case svm_parameter.ONE_CLASS:                      solve_one_class(prob' param' alpha' si);                      break;                    case svm_parameter.EPSILON_SVR:                      solve_epsilon_svr(prob' param' alpha' si);                      break;                    case svm_parameter.NU_SVR:                      solve_nu_svr(prob' param' alpha' si);                      break;              }
Missing Default,Encog.MathUtil.Matrices.Decomposition,SingularValueDecomposition,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\MathUtil\Matrices\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following switch statement is missing a default case: switch (kase)                  {                          // Deflate negligible s(p).                        case 1:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for (int j = p - 2; j >= k; j--)                              {                                  double t = EncogMath.Hypot(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  if (j != k)                                  {                                      f = -sn*e[j - 1];                                      e[j - 1] = cs*e[j - 1];                                  }                                  if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*vmatrix[i][j] + sn*vmatrix[i][p - 1];                                          vmatrix[i][p - 1] = -sn*vmatrix[i][j] + cs*vmatrix[i][p - 1];                                          vmatrix[i][j] = t;                                      }                                  }                              }                          }                          break;                            // Split at negligible s(k).                        case 2:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for (int j = k; j < p; j++)                              {                                  double t = EncogMath.Hypot(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  f = -sn*e[j];                                  e[j] = cs*e[j];                                  if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*umatrix[i][j] + sn*umatrix[i][k - 1];                                          umatrix[i][k - 1] = -sn*umatrix[i][j] + cs*umatrix[i][k - 1];                                          umatrix[i][j] = t;                                      }                                  }                              }                          }                          break;                            // Perform one qr step.                        case 3:                          {                              // Calculate the shift.                                double scale = Math.Max(Math.Max(Math                                                                   .Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))'                                                                        Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math                                                                                                                  .Abs(                                                                                                                      e[k]));                              double sp = s[p - 1]/scale;                              double spm1 = s[p - 2]/scale;                              double epm1 = e[p - 2]/scale;                              double sk = s[k]/scale;                              double ek = e[k]/scale;                              double b = ((spm1 + sp)*(spm1 - sp) + epm1*epm1)/2.0;                              double c = (sp*epm1)*(sp*epm1);                              double shift = 0.0;                              if ((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt(b*b + c);                                  if (b < 0.0)                                  {                                      shift = -shift;                                  }                                  shift = c/(b + shift);                              }                              double f = (sk + sp)*(sk - sp) + shift;                              double g = sk*ek;                                // Chase zeros.                                for (int j = k; j < p - 1; j++)                              {                                  double t = EncogMath.Hypot(f' g);                                  double cs = f/t;                                  double sn = g/t;                                  if (j != k)                                  {                                      e[j - 1] = t;                                  }                                  f = cs*s[j] + sn*e[j];                                  e[j] = cs*e[j] - sn*s[j];                                  g = sn*s[j + 1];                                  s[j + 1] = cs*s[j + 1];                                  if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*vmatrix[i][j] + sn*vmatrix[i][j + 1];                                          vmatrix[i][j + 1] = -sn*vmatrix[i][j] + cs*vmatrix[i][j + 1];                                          vmatrix[i][j] = t;                                      }                                  }                                  t = EncogMath.Hypot(f' g);                                  cs = f/t;                                  sn = g/t;                                  s[j] = t;                                  f = cs*e[j] + sn*s[j + 1];                                  s[j + 1] = -sn*e[j] + cs*s[j + 1];                                  g = sn*e[j + 1];                                  e[j + 1] = cs*e[j + 1];                                  if (wantu && (j < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*umatrix[i][j] + sn*umatrix[i][j + 1];                                          umatrix[i][j + 1] = -sn*umatrix[i][j] + cs*umatrix[i][j + 1];                                          umatrix[i][j] = t;                                      }                                  }                              }                              e[p - 2] = f;                              iter = iter + 1;                          }                          break;                            // Convergence.                        case 4:                          {                              // Make the singular values positive.                                if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                  if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                      {                                          vmatrix[i][k] = -vmatrix[i][k];                                      }                                  }                              }                                // Order the singular values.                                while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                  {                                      break;                                  }                                  double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                  if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = vmatrix[i][k + 1];                                          vmatrix[i][k + 1] = vmatrix[i][k];                                          vmatrix[i][k] = t;                                      }                                  }                                  if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = umatrix[i][k + 1];                                          umatrix[i][k + 1] = umatrix[i][k];                                          umatrix[i][k] = t;                                      }                                  }                                  k++;                              }                              iter = 0;                              p--;                          }                          break;                  }
Missing Default,Encog.ML.Bayesian.Query,BasicQuery,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Bayesian\Query\BasicQuery.cs,LocateEventTypes,The following switch statement is missing a default case: switch (GetEventType(e))                  {                      case EventType.Evidence:                          _evidenceEvents.Add(e);                          break;                      case EventType.Outcome:                          _outcomeEvents.Add(e);                          break;                  }
Missing Default,Encog.ML.Bayesian.Training,TrainBayesian,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Bayesian\Training\TrainBayesian.cs,IterationInit,The following switch statement is missing a default case: switch (_initNetwork)              {                  case BayesianInit.InitEmpty:                      _network.RemoveAllRelations();                      _network.FinalizeStructure();                      break;                  case BayesianInit.InitNoChange:                      break;                  case BayesianInit.InitNaiveBayes:                      InitNaiveBayes();                      break;              }
Missing Default,Encog.ML.Bayesian.Training,TrainBayesian,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Bayesian\Training\TrainBayesian.cs,Iteration,The following switch statement is missing a default case: switch (_p)              {                  case Phase.Init:                      IterationInit();                      break;                  case Phase.Search:                      IterationSearch();                      break;                  case Phase.SearchDone:                      IterationSearchDone();                      break;                  case Phase.Probability:                      IterationProbability();                      break;                  case Phase.Finish:                      IterationFinish();                      break;              }
Missing Default,Encog.ML.Data.Versatile.Columns,ColumnDefinition,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Data\Versatile\Columns\ColumnDefinition.cs,Analyze,The following switch statement is missing a default case: switch (DataType)              {                  case ColumnType.Continuous:                      AnalyzeContinuous(value);                      break;                  case ColumnType.Ordinal:                      AnalyzeOrdinal(value);                      break;                  case ColumnType.Nominal:                      AnalyzeNominal(value);                      break;              }
Missing Default,Encog.ML.Prg,EncogProgram,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Prg\EncogProgram.cs,Compute,The following switch statement is missing a default case: switch (resultMapping.VariableType)              {                  case EPLValueType.FloatingType:                      if (v.IsNumeric)                      {                          result.Data[0] = v.ToFloatValue();                          success = true;                      }                      break;                  case EPLValueType.StringType:                      result.Data[0] = v.ToFloatValue();                      success = true;                      break;                  case EPLValueType.BooleanType:                      if (v.IsBoolean)                      {                          result.Data[0] = v.ToBooleanValue() ? 1.0 : 0.0;                          success = true;                      }                      break;                  case EPLValueType.IntType:                      if (v.IsNumeric)                      {                          result[0] = v.ToIntValue();                          success = true;                      }                      break;                  case EPLValueType.EnumType:                      if (v.IsEnum)                      {                          result.Data[0] = v.ToIntValue();                          success = true;                      }                      break;              }
Missing Default,Encog.ML.Prg,PersistPrgPopulation,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Prg\PersistPrgPopulation.cs,GetType,The following switch statement is missing a default case: switch (mapping.VariableType)              {                  case EPLValueType.FloatingType:                      return "f";                  case EPLValueType.StringType:                      return "s";                  case EPLValueType.BooleanType:                      return "b";                  case EPLValueType.IntType:                      return "i";                  case EPLValueType.EnumType:                      return "e";              }
Missing Default,Encog.ML.Prg.Train.Rewrite,RewriteAlgebraic,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\ML\Prg\Train\Rewrite\RewriteAlgebraic.cs,TryVarOpVar,The following switch statement is missing a default case: switch (parent.Name[0])                          {                              case '-':                                  parent = CreateNumericConst(parent.Owner' 0);                                  break;                              case '+':                                  parent = parent.Owner.Functions.FactorProgramNode("*"' parent.Owner'                                                                                    new[]                                                                                        {                                                                                            CreateNumericConst(                                                                                                parent.Owner' 2)'                                                                                            child1                                                                                        });                                  break;                              case '*':                                  parent = parent                                      .Owner                                      .Functions                                      .FactorProgramNode(                                          "^"'                                          parent.Owner'                                          new[]                                              {                                                  child1'                                                  CreateNumericConst(                                                      parent.Owner' 2)                                              });                                  break;                              case '/':                                  parent = CreateNumericConst(parent.Owner' 1);                                  break;                          }
Missing Default,Encog.Neural.SOM.Training.Neighborhood,NeighborhoodRBF,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\SOM\Training\Neighborhood\NeighborhoodRBF.cs,NeighborhoodRBF,The following switch statement is missing a default case: switch (type)              {                  case RBFEnum.Gaussian:                      _rbf = new GaussianFunction(2);                      break;                  case RBFEnum.InverseMultiquadric:                      _rbf = new InverseMultiquadricFunction(2);                      break;                  case RBFEnum.Multiquadric:                      _rbf = new MultiquadricFunction(2);                      break;                  case RBFEnum.MexicanHat:                      _rbf = new MexicanHatFunction(2);                      break;              }
Missing Default,Encog.Neural.SOM.Training.Neighborhood,NeighborhoodRBF,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Neural\SOM\Training\Neighborhood\NeighborhoodRBF.cs,NeighborhoodRBF,The following switch statement is missing a default case: switch (type)              {                  case RBFEnum.Gaussian:                      _rbf = new GaussianFunction(2);                      break;                  case RBFEnum.InverseMultiquadric:                      _rbf = new InverseMultiquadricFunction(2);                      break;                  case RBFEnum.Multiquadric:                      _rbf = new MultiquadricFunction(2);                      break;                  case RBFEnum.MexicanHat:                      _rbf = new MexicanHatFunction(2);                      break;              }
Missing Default,Encog.Parse.Expression.Common,RenderCommonExpression,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Parse\Expression\Common\RenderCommonExpression.cs,RenderNode,The following switch statement is missing a default case: switch (DetermineNodeType(node))              {                  case ExpressionNodeType.ConstVal:                      result.Append(RenderConst(node));                      break;                  case ExpressionNodeType.Operator:                      result.Append(RenderOperator(node));                      break;                  case ExpressionNodeType.Variable:                      result.Append(RenderVar(node));                      break;                  case ExpressionNodeType.Function:                      result.Append(RenderFunction(node));                      break;              }
Missing Default,Encog.Parse.Expression.Latex,RenderLatexExpression,D:\research\architectureSmells\repos\encog_encog-dotnet-core\encog-core-cs\Parse\Expression\Latex\RenderLatexExpression.cs,RenderNode,The following switch statement is missing a default case: switch (DetermineNodeType(node))              {                  case ExpressionNodeType.ConstVal:                      return HandleConst(node);                  case ExpressionNodeType.Operator:                      return HandleOperator(node);                  case ExpressionNodeType.Variable:                      return HandleVar(node);                  case ExpressionNodeType.Function:                      return HandleFunction(node);              }
