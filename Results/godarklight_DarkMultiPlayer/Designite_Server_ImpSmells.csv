Implementation smell,Namespace,Class,File,Method,Description
Long Method,DarkMultiPlayerServer,Server,C:\repos\godarklight_DarkMultiPlayer\Server\Main.cs,Main,The method has 170 lines of code.
Long Method,DarkMultiPlayerServer,ClientHandler,C:\repos\godarklight_DarkMultiPlayer\Server\ClientHandler.cs,HandleMessage,The method has 113 lines of code.
Long Method,DarkMultiPlayerServer,ClientHandler,C:\repos\godarklight_DarkMultiPlayer\Server\ClientHandler.cs,SendToClient,The method has 110 lines of code.
Long Method,DarkMultiPlayerServer.Messages,Handshake,C:\repos\godarklight_DarkMultiPlayer\Server\Messages\Handshake.cs,HandleHandshakeResponse,The method has 189 lines of code.
Long Method,DarkMultiPlayerServer.Messages,Chat,C:\repos\godarklight_DarkMultiPlayer\Server\Messages\Chat.cs,HandleChatMessage,The method has 115 lines of code.
Long Method,DarkMultiPlayerServer.Messages,CraftLibrary,C:\repos\godarklight_DarkMultiPlayer\Server\Messages\CraftLibrary.cs,HandleCraftLibrary,The method has 120 lines of code.
Long Method,DarkMultiPlayerServer.Messages,ScreenshotLibrary,C:\repos\godarklight_DarkMultiPlayer\Server\Messages\ScreenshotLibrary.cs,HandleScreenshotLibrary,The method has 215 lines of code.
Long Method,DarkMultiPlayerServer.Messages,FlagSync,C:\repos\godarklight_DarkMultiPlayer\Server\Messages\FlagSync.cs,HandleFlagSync,The method has 154 lines of code.
Complex Method,DarkMultiPlayerServer,Server,C:\repos\godarklight_DarkMultiPlayer\Server\Main.cs,Main,Cyclomatic complexity of the method is 18
Complex Method,DarkMultiPlayerServer,Server,C:\repos\godarklight_DarkMultiPlayer\Server\Main.cs,CheckUniverse,Cyclomatic complexity of the method is 12
Complex Method,DarkMultiPlayerServer,DMPPluginHandler,C:\repos\godarklight_DarkMultiPlayer\Server\DMPPluginHandler.cs,LoadPlugins,Cyclomatic complexity of the method is 10
Complex Method,DarkMultiPlayerServer,BanSystem,C:\repos\godarklight_DarkMultiPlayer\Server\BanSystem.cs,LoadBans,Cyclomatic complexity of the method is 11
Complex Method,DarkMultiPlayerServer.Messages,Handshake,C:\repos\godarklight_DarkMultiPlayer\Server\Messages\Handshake.cs,HandleHandshakeResponse,Cyclomatic complexity of the method is 24
Complex Method,DarkMultiPlayerServer.Messages,WarpControl,C:\repos\godarklight_DarkMultiPlayer\Server\Messages\WarpControl.cs,HandleLowestRateChange,Cyclomatic complexity of the method is 8
Complex Method,DarkMultiPlayerServer.Messages,WarpControl,C:\repos\godarklight_DarkMultiPlayer\Server\Messages\WarpControl.cs,DisconnectPlayer,Cyclomatic complexity of the method is 9
Long Parameter List,DarkMultiPlayerServer.Messages,WarpControl,C:\repos\godarklight_DarkMultiPlayer\Server\Messages\WarpControl.cs,HandleChangeWarp,The method has 5 parameters. Parameters: client' physWarp' rateIndex' serverClock' planetTime
Long Identifier,DarkMultiPlayerServer,GameplaySettingsStore,C:\repos\godarklight_DarkMultiPlayer\Server\GameplaySettings.cs,,The length of the parameter bypassEntryPurchaseAfterResearch is 32.
Long Identifier,DarkMultiPlayerServer.Messages,ScreenshotLibrary,C:\repos\godarklight_DarkMultiPlayer\Server\Messages\ScreenshotLibrary.cs,HandleScreenshotLibrary,The length of the parameter watchPlayerScreenshotDirectory is 30.
Long Identifier,DarkMultiPlayerServer.Messages,ScreenshotLibrary,C:\repos\godarklight_DarkMultiPlayer\Server\Messages\ScreenshotLibrary.cs,,The length of the parameter playerDownloadedScreenshotIndex is 31.
Long Statement,DarkMultiPlayerServer,GameplaySettings,C:\repos\godarklight_DarkMultiPlayer\Server\GameplaySettings.cs,Reset,The length of the statement  "            gameplaySettings = new ConfigParser<GameplaySettingsStore>(new GameplaySettingsStore()' Path.Combine(Server.configDirectory' "GameplaySettings.txt")); " is 150.
Long Statement,DarkMultiPlayerServer,Server,C:\repos\godarklight_DarkMultiPlayer\Server\Main.cs,Main,The length of the statement  "            CommandHandler.RegisterCommand("admin"' AdminCommand.HandleCommand' "Sets a player as admin/removes admin from the player"); " is 124.
Long Statement,DarkMultiPlayerServer,Server,C:\repos\godarklight_DarkMultiPlayer\Server\Main.cs,Main,The length of the statement  "                DarkLog.Debug("System.IO compression works: " + Compression.sysIOCompressionWorks + "' test time: " + testTime + " ms."); " is 121.
Long Statement,DarkMultiPlayerServer,Server,C:\repos\godarklight_DarkMultiPlayer\Server\Main.cs,Main,The length of the statement  "                DarkLog.Normal("Starting " + Settings.settingsStore.warpMode + " server on port " + Settings.settingsStore.port + "... "); " is 122.
Long Statement,DarkMultiPlayerServer,Server,C:\repos\godarklight_DarkMultiPlayer\Server\Main.cs,Main,The length of the statement  "                            DarkLog.LogFilename = Path.Combine(DarkLog.LogFolder' "dmpserver " + DateTime.Now.ToString("yyyy-MM-dd HH-mm-ss") + ".log"); " is 124.
Long Statement,DarkMultiPlayerServer,Server,C:\repos\godarklight_DarkMultiPlayer\Server\Main.cs,GenerateNewModFile,The length of the statement  "            string modFileData = Common.GenerateModFileStringData(new string[0]' new string[0]' false' new string[0]' Common.GetStockParts().ToArray()); " is 140.
Long Statement,DarkMultiPlayerServer,CommandHandler,C:\repos\godarklight_DarkMultiPlayer\Server\CommandHandler.cs,ConnectionStats,The length of the statement  "                    DarkLog.Normal("Player '" + client.playerName + "'' queued out: " + client.bytesQueuedOut + "' sent: " + client.bytesSent + "' received: " + client.bytesReceived); " is 163.
Long Statement,DarkMultiPlayerServer,CommandHandler,C:\repos\godarklight_DarkMultiPlayer\Server\CommandHandler.cs,ConnectionStats,The length of the statement  "            DarkLog.Normal("Server' queued out: " + bytesQueuedOutTotal + "' sent: " + bytesSentTotal + "' received: " + bytesReceivedTotal); " is 129.
Long Statement,DarkMultiPlayerServer,ClientHandler,C:\repos\godarklight_DarkMultiPlayer\Server\ClientHandler.cs,SetupTCPServer,The length of the statement  "                        //Windows defaults to v6 only' but this option does not exist in mono so it has to be in a try/catch block along with the casted int. " is 133.
Long Statement,DarkMultiPlayerServer,ClientHandler,C:\repos\godarklight_DarkMultiPlayer\Server\ClientHandler.cs,SplitAndRewriteMessage,The length of the statement  "                    Array.Copy(message.data' message.data.Length - splitBytesLeft' currentSplitMessage.data' 0' currentSplitMessage.data.Length); " is 125.
Long Statement,DarkMultiPlayerServer,ClientHandler,C:\repos\godarklight_DarkMultiPlayer\Server\ClientHandler.cs,SendNetworkMessage,The length of the statement  "                    DarkLog.Normal("Disconnecting client " + client.playerName + "' sent CONNECTION_END (" + reason + ") to endpoint " + client.endpoint); " is 134.
Long Statement,DarkMultiPlayerServer,ClientHandler,C:\repos\godarklight_DarkMultiPlayer\Server\ClientHandler.cs,SendNetworkMessage,The length of the statement  "                        DarkLog.Normal("Disconnecting client " + client.playerName + "' sent HANDSHAKE_REPLY (" + reason + ") to endpoint " + client.endpoint); " is 135.
Long Statement,DarkMultiPlayerServer,ClientHandler,C:\repos\godarklight_DarkMultiPlayer\Server\ClientHandler.cs,StartReceivingIncomingMessages,The length of the statement  "                client.connection.GetStream().BeginRead(client.receiveMessage.data' client.receiveMessage.data.Length - client.receiveMessageBytesLeft' client.receiveMessageBytesLeft' new AsyncCallback(ReceiveCallback)' client); " is 212.
Long Statement,DarkMultiPlayerServer,ClientHandler,C:\repos\godarklight_DarkMultiPlayer\Server\ClientHandler.cs,ReceiveCallback,The length of the statement  "                    client.connection.GetStream().BeginRead(client.receiveMessage.data' client.receiveMessage.data.Length - client.receiveMessageBytesLeft' client.receiveMessageBytesLeft' new AsyncCallback(ReceiveCallback)' client); " is 212.
Long Statement,DarkMultiPlayerServer,ClientHandler,C:\repos\godarklight_DarkMultiPlayer\Server\ClientHandler.cs,HandleDisconnectException,The length of the statement  "                        DarkLog.Normal("Client " + client.playerName + " disconnected in " + location + "' endpoint " + client.endpoint + "' error: " + e.Message + " (" + e.InnerException.Message + ")"); " is 179.
Long Statement,DarkMultiPlayerServer,ClientHandler,C:\repos\godarklight_DarkMultiPlayer\Server\ClientHandler.cs,HandleDisconnectException,The length of the statement  "                        DarkLog.Normal("Client " + client.playerName + " disconnected in " + location + "' endpoint " + client.endpoint + "' error: " + e.Message); " is 139.
Long Statement,DarkMultiPlayerServer,ClientHandler,C:\repos\godarklight_DarkMultiPlayer\Server\ClientHandler.cs,HandleMessage,The length of the statement  "            if (!client.authenticated && !(message.type == ClientMessageType.HEARTBEAT || message.type == ClientMessageType.HANDSHAKE_RESPONSE || message.type == ClientMessageType.CONNECTION_END)) " is 184.
Long Statement,DarkMultiPlayerServer,ClientHandler,C:\repos\godarklight_DarkMultiPlayer\Server\ClientHandler.cs,HandleMessage,The length of the statement  "                Messages.ConnectionEnd.SendConnectionEnd(client' "You must authenticate before attempting to send a " + message.type.ToString() + " message"); " is 142.
Long Statement,DarkMultiPlayerServer,Settings,C:\repos\godarklight_DarkMultiPlayer\Server\Settings.cs,Reset,The length of the statement  "            serverSettings = new ConfigParser<SettingsStore>(new SettingsStore()' Path.Combine(Server.configDirectory' "Settings.txt")); " is 124.
Long Statement,DarkMultiPlayerServer,Dekessler,C:\repos\godarklight_DarkMultiPlayer\Server\Dekessler.cs,CheckTimer,The length of the statement  "                if (((Server.serverClock.ElapsedMilliseconds - lastDekesslerTime) > (Settings.settingsStore.autoDekessler * 60 * 1000)) || lastDekesslerTime == 0) " is 146.
Long Statement,DarkMultiPlayerServer,NukeKSC,C:\repos\godarklight_DarkMultiPlayer\Server\NukeKSC.cs,CheckTimer,The length of the statement  "                if (((Server.serverClock.ElapsedMilliseconds - lastNukeTime) > (Settings.settingsStore.autoNuke * 60 * 1000)) || lastNukeTime == 0) " is 131.
Long Statement,DarkMultiPlayerServer,DMPPluginHandler,C:\repos\godarklight_DarkMultiPlayer\Server\DMPPluginHandler.cs,CurrentDomain_AssemblyResolve,The length of the statement  "                    DarkLog.Debug("Resolved plugin assembly reference: " + args.Name + " (referenced by " + args.RequestingAssembly.FullName + ")"); " is 128.
Long Statement,DarkMultiPlayerServer,DMPPluginHandler,C:\repos\godarklight_DarkMultiPlayer\Server\DMPPluginHandler.cs,LoadPlugins,The length of the statement  "                        //UnsafeLoadFrom will not throw an exception if the dll is marked as unsafe' such as downloaded from internet in Windows " is 120.
Long Statement,DarkMultiPlayerServer,DMPPluginHandler,C:\repos\godarklight_DarkMultiPlayer\Server\DMPPluginHandler.cs,LoadPlugins,The length of the statement  "                            DarkLog.Error("Error loading plugin " + loadedType.FullName + "(" + loadedType.Assembly.FullName + ") Exception: " + ex.ToString()); " is 132.
Long Statement,DarkMultiPlayerServer,DMPPluginHandler,C:\repos\godarklight_DarkMultiPlayer\Server\DMPPluginHandler.cs,FireOnUpdate,The length of the statement  "                    DarkLog.Debug("Error thrown in OnUpdate event for " + type.FullName + " (" + type.Assembly.FullName + ")' Exception: " + e); " is 124.
Long Statement,DarkMultiPlayerServer,DMPPluginHandler,C:\repos\godarklight_DarkMultiPlayer\Server\DMPPluginHandler.cs,FireOnServerStart,The length of the statement  "                    DarkLog.Debug("Error thrown in OnServerStart event for " + type.FullName + " (" + type.Assembly.FullName + ")' Exception: " + e); " is 129.
Long Statement,DarkMultiPlayerServer,DMPPluginHandler,C:\repos\godarklight_DarkMultiPlayer\Server\DMPPluginHandler.cs,FireOnServerStop,The length of the statement  "                    DarkLog.Debug("Error thrown in OnServerStop event for " + type.FullName + " (" + type.Assembly.FullName + ")' Exception: " + e); " is 128.
Long Statement,DarkMultiPlayerServer,DMPPluginHandler,C:\repos\godarklight_DarkMultiPlayer\Server\DMPPluginHandler.cs,FireOnClientConnect,The length of the statement  "                    DarkLog.Debug("Error thrown in OnClientConnect event for " + type.FullName + " (" + type.Assembly.FullName + ")' Exception: " + e); " is 131.
Long Statement,DarkMultiPlayerServer,DMPPluginHandler,C:\repos\godarklight_DarkMultiPlayer\Server\DMPPluginHandler.cs,FireOnClientAuthenticated,The length of the statement  "                    DarkLog.Debug("Error thrown in OnClientAuthenticated event for " + type.FullName + " (" + type.Assembly.FullName + ")' Exception: " + e); " is 137.
Long Statement,DarkMultiPlayerServer,DMPPluginHandler,C:\repos\godarklight_DarkMultiPlayer\Server\DMPPluginHandler.cs,FireOnClientDisconnect,The length of the statement  "                    DarkLog.Debug("Error thrown in OnClientDisconnect event for " + type.FullName + " (" + type.Assembly.FullName + ")' Exception: " + e); " is 134.
Long Statement,DarkMultiPlayerServer,DMPPluginHandler,C:\repos\godarklight_DarkMultiPlayer\Server\DMPPluginHandler.cs,FireOnMessageReceived,The length of the statement  "                    DarkLog.Debug("Error thrown in OnMessageReceived event for " + type.FullName + " (" + type.Assembly.FullName + ")' Exception: " + e); " is 133.
Long Statement,DarkMultiPlayerServer,DMPPluginHandler,C:\repos\godarklight_DarkMultiPlayer\Server\DMPPluginHandler.cs,FireOnMessageSent,The length of the statement  "                    DarkLog.Debug("Error thrown in OnMessageSent event for " + type.FullName + " (" + type.Assembly.FullName + ")' Exception: " + e); " is 129.
Long Statement,DarkMultiPlayerServer,PMCommand,C:\repos\godarklight_DarkMultiPlayer\Server\PMCommand.cs,HandleCommand,The length of the statement  "                        if ((commandArgs.Length > (testPlayer.playerName.Length + 1)) ? commandArgs[testPlayer.playerName.Length] == ' ' : false) " is 121.
Long Statement,DarkMultiPlayerServer.Messages,Handshake,C:\repos\godarklight_DarkMultiPlayer\Server\Messages\Handshake.cs,HandleHandshakeResponse,The length of the statement  "                if (BanSystem.fetch.IsPlayerNameBanned(client.playerName) || BanSystem.fetch.IsIPBanned(client.ipAddress) || BanSystem.fetch.IsPublicKeyBanned(client.publicKey)) " is 161.
Long Statement,DarkMultiPlayerServer.Messages,Heartbeat,C:\repos\godarklight_DarkMultiPlayer\Server\Messages\Heartbeat.cs,CheckHeartBeat,The length of the statement  "                DarkLog.Normal("Disconnecting client " + client.playerName + "' endpoint " + client.endpoint + "' Connection timed out"); " is 121.
Long Statement,DarkMultiPlayerServer.Messages,Heartbeat,C:\repos\godarklight_DarkMultiPlayer\Server\Messages\Heartbeat.cs,CheckHeartBeat,The length of the statement  "                if (client.sendMessageQueueHigh.Count == 0 && client.sendMessageQueueSplit.Count == 0 && client.sendMessageQueueLow.Count == 0) " is 127.
Long Statement,DarkMultiPlayerServer.Messages,ScenarioData,C:\repos\godarklight_DarkMultiPlayer\Server\Messages\ScenarioData.cs,SendScenarioModules,The length of the statement  "            int numberOfScenarioModules = Directory.GetFiles(Path.Combine(Server.universeDirectory' "Scenarios"' client.playerName)).Length; " is 128.
Long Statement,DarkMultiPlayerServer.Messages,ScenarioData,C:\repos\godarklight_DarkMultiPlayer\Server\Messages\ScenarioData.cs,HandleScenarioModuleData,The length of the statement  "                    File.WriteAllBytes(Path.Combine(Server.universeDirectory' "Scenarios"' client.playerName' scenarioName[i] + ".txt")' scenarioData); " is 131.
Long Statement,DarkMultiPlayerServer.Messages,VesselRequest,C:\repos\godarklight_DarkMultiPlayer\Server\Messages\VesselRequest.cs,HandleVesselsRequest,The length of the statement  "                DarkLog.Debug("Sending " + client.playerName + " " + sendVesselCount + " vessels' cached: " + cachedVesselCount + "..."); " is 121.
Long Statement,DarkMultiPlayerServer.Messages,ScreenshotLibrary,C:\repos\godarklight_DarkMultiPlayer\Server\Messages\ScreenshotLibrary.cs,HandleScreenshotLibrary,The length of the statement  "                                //Notify players that aren't watching that there's a new screenshot availabe. This only works if there's a file available on the server. " is 136.
Long Statement,DarkMultiPlayerServer.Messages,WarpControl,C:\repos\godarklight_DarkMultiPlayer\Server\Messages\WarpControl.cs,HandleNewSubspace,The length of the statement  "                if (Settings.settingsStore.warpMode == WarpMode.MCW_FORCE || Settings.settingsStore.warpMode == WarpMode.MCW_VOTE || Settings.settingsStore.warpMode == WarpMode.MCW_LOWEST) " is 172.
Long Statement,DarkMultiPlayerServer.Messages,WarpControl,C:\repos\godarklight_DarkMultiPlayer\Server\Messages\WarpControl.cs,SendSetController,The length of the statement  "            if (Settings.settingsStore.warpMode == WarpMode.MCW_FORCE || Settings.settingsStore.warpMode == WarpMode.MCW_VOTE || Settings.settingsStore.warpMode == WarpMode.MCW_LOWEST) " is 172.
Long Statement,DarkMultiPlayerServer.Messages,WarpControl,C:\repos\godarklight_DarkMultiPlayer\Server\Messages\WarpControl.cs,SendSetSubspace,The length of the statement  "            if (Settings.settingsStore.warpMode != WarpMode.SUBSPACE || Settings.settingsStore.sendPlayerToLatestSubspace || !File.Exists(storedTimeFile) || !Double.TryParse(File.ReadAllText(storedTimeFile)' out storedTime)) " is 212.
Long Statement,DarkMultiPlayerServer.Messages,WarpControl,C:\repos\godarklight_DarkMultiPlayer\Server\Messages\WarpControl.cs,GetLatestSubspace,The length of the statement  "                double currentPlanetTime = subspace.Value.planetTime + (((currentTime - subspace.Value.serverClock) / 10000000) * subspace.Value.subspaceSpeed); " is 144.
Long Statement,DarkMultiPlayerServer.Messages,WarpControl,C:\repos\godarklight_DarkMultiPlayer\Server\Messages\WarpControl.cs,SaveSubspace,The length of the statement  "                sw.WriteLine("#Incorrectly editing this file will cause weirdness. If there is any errors' the universe time will be reset."); " is 126.
Long Statement,DarkMultiPlayerServer.Messages,WarpControl,C:\repos\godarklight_DarkMultiPlayer\Server\Messages\WarpControl.cs,SaveSubspace,The length of the statement  "                sw.WriteLine("#Each variable is on a new line. They are subspaceID' server clock (from DateTime.UtcNow.Ticks)' universe time' and subspace speed."); " is 148.
Long Statement,DarkMultiPlayerServer.Messages,SplitMessage,C:\repos\godarklight_DarkMultiPlayer\Server\Messages\SplitMessage.cs,HandleSplitMessage,The length of the statement  "                messageData.CopyTo(client.receiveSplitMessage.data' client.receiveSplitMessage.data.Length - client.receiveSplitMessageBytesLeft); " is 130.
Long Statement,DarkMultiPlayerServer.Messages,ServerSettings,C:\repos\godarklight_DarkMultiPlayer\Server\Messages\ServerSettings.cs,SendServerSettings,The length of the statement  "            int numberOfScenarioModules = Directory.GetFiles(Path.Combine(Server.universeDirectory' "Scenarios"' client.playerName)).Length; " is 128.
Complex Conditional,DarkMultiPlayerServer,Server,C:\repos\godarklight_DarkMultiPlayer\Server\Main.cs,StartHTTPServer,The conditional expression  "OS == "Win32NT" || OS == "Win32S" || OS == "Win32Windows" || OS == "WinCE""  is complex.
Complex Conditional,DarkMultiPlayerServer,ClientHandler,C:\repos\godarklight_DarkMultiPlayer\Server\ClientHandler.cs,HandleMessage,The conditional expression  "!client.authenticated && !(message.type == ClientMessageType.HEARTBEAT || message.type == ClientMessageType.HANDSHAKE_RESPONSE || message.type == ClientMessageType.CONNECTION_END)"  is complex.
Complex Conditional,DarkMultiPlayerServer.Messages,Handshake,C:\repos\godarklight_DarkMultiPlayer\Server\Messages\Handshake.cs,HandleHandshakeResponse,The conditional expression  "playerName.Contains("/") || playerName.Contains(@"\") || playerName.Contains("\n") || playerName.Contains("\r")"  is complex.
Complex Conditional,DarkMultiPlayerServer.Messages,WarpControl,C:\repos\godarklight_DarkMultiPlayer\Server\Messages\WarpControl.cs,SendSetSubspace,The conditional expression  "Settings.settingsStore.warpMode != WarpMode.SUBSPACE || Settings.settingsStore.sendPlayerToLatestSubspace || !File.Exists(storedTimeFile) || !Double.TryParse(File.ReadAllText(storedTimeFile)' out storedTime)"  is complex.
Empty Catch Block,DarkMultiPlayerServer,ClientHandler,C:\repos\godarklight_DarkMultiPlayer\Server\ClientHandler.cs,SetupTCPServer,The method has an empty catch block.
Magic Number,DarkMultiPlayerServer,Server,C:\repos\godarklight_DarkMultiPlayer\Server\Main.cs,Main,The following statement contains a magic number: while (serverStarting || serverRestarting)              {                  if (serverRestarting)                  {                      DarkLog.Debug("Reloading settings...");                      Settings.Reset();                      Settings.Load();                      if (Settings.settingsStore.gameDifficulty == GameDifficulty.CUSTOM)                      {                          DarkLog.Debug("Reloading gameplay settings...");                          GameplaySettings.Reset();                          GameplaySettings.Load();                      }                  }                    serverRestarting = false;                  DarkLog.Normal("Starting DMPServer " + Common.PROGRAM_VERSION + "' protocol " + Common.PROTOCOL_VERSION);                    if (Settings.settingsStore.gameDifficulty == GameDifficulty.CUSTOM)                  {                      //Generate the config file by accessing the object.                      DarkLog.Debug("Loading gameplay settings...");                      GameplaySettings.Load();                  }                    //Load universe                  DarkLog.Normal("Loading universe... ");                  CheckUniverse();                    DarkLog.Normal("Starting " + Settings.settingsStore.warpMode + " server on port " + Settings.settingsStore.port + "... ");                    serverRunning = true;                  Thread commandThread = new Thread(new ThreadStart(CommandHandler.ThreadMain));                  Thread clientThread = new Thread(new ThreadStart(ClientHandler.ThreadMain));                  commandThread.Start();                  clientThread.Start();                  while (serverStarting)                  {                      Thread.Sleep(500);                  }                    StartHTTPServer();                  DarkLog.Normal("Ready!");                  DMPPluginHandler.FireOnServerStart();                  while (serverRunning)                  {                      //Run a garbage collection every 30 seconds.                      if ((serverClock.ElapsedMilliseconds - lastGarbageCollect) > 30000)                      {                          lastGarbageCollect = serverClock.ElapsedMilliseconds;                          GC.Collect();                      }                      //Run the screenshot expire function every 10 minutes                      if ((serverClock.ElapsedMilliseconds - lastScreenshotExpiredCheck) > 600000)                      {                          lastScreenshotExpiredCheck = serverClock.ElapsedMilliseconds;                          ScreenshotExpire.ExpireScreenshots();                      }                      //Run the log expire function every 10 minutes                      if ((serverClock.ElapsedMilliseconds - lastLogExpiredCheck) > 600000)                      {                          lastLogExpiredCheck = serverClock.ElapsedMilliseconds;                          LogExpire.ExpireLogs();                      }                      // Check if the day has changed' every minute                      if ((serverClock.ElapsedMilliseconds - lastDayCheck) > 60000)                      {                          lastDayCheck = serverClock.ElapsedMilliseconds;                          if (day != DateTime.Now.Day)                          {                              DarkLog.LogFilename = Path.Combine(DarkLog.LogFolder' "dmpserver " + DateTime.Now.ToString("yyyy-MM-dd HH-mm-ss") + ".log");                              DarkLog.WriteToLog("Continued from logfile " + DateTime.Now.ToString("yyyy-MM-dd HH-mm-ss") + ".log");                              day = DateTime.Now.Day;                          }                      }                        Thread.Sleep(500);                  }                  DMPPluginHandler.FireOnServerStop();                  commandThread.Abort();                  clientThread.Join();              }
Magic Number,DarkMultiPlayerServer,Server,C:\repos\godarklight_DarkMultiPlayer\Server\Main.cs,Main,The following statement contains a magic number: while (serverStarting || serverRestarting)              {                  if (serverRestarting)                  {                      DarkLog.Debug("Reloading settings...");                      Settings.Reset();                      Settings.Load();                      if (Settings.settingsStore.gameDifficulty == GameDifficulty.CUSTOM)                      {                          DarkLog.Debug("Reloading gameplay settings...");                          GameplaySettings.Reset();                          GameplaySettings.Load();                      }                  }                    serverRestarting = false;                  DarkLog.Normal("Starting DMPServer " + Common.PROGRAM_VERSION + "' protocol " + Common.PROTOCOL_VERSION);                    if (Settings.settingsStore.gameDifficulty == GameDifficulty.CUSTOM)                  {                      //Generate the config file by accessing the object.                      DarkLog.Debug("Loading gameplay settings...");                      GameplaySettings.Load();                  }                    //Load universe                  DarkLog.Normal("Loading universe... ");                  CheckUniverse();                    DarkLog.Normal("Starting " + Settings.settingsStore.warpMode + " server on port " + Settings.settingsStore.port + "... ");                    serverRunning = true;                  Thread commandThread = new Thread(new ThreadStart(CommandHandler.ThreadMain));                  Thread clientThread = new Thread(new ThreadStart(ClientHandler.ThreadMain));                  commandThread.Start();                  clientThread.Start();                  while (serverStarting)                  {                      Thread.Sleep(500);                  }                    StartHTTPServer();                  DarkLog.Normal("Ready!");                  DMPPluginHandler.FireOnServerStart();                  while (serverRunning)                  {                      //Run a garbage collection every 30 seconds.                      if ((serverClock.ElapsedMilliseconds - lastGarbageCollect) > 30000)                      {                          lastGarbageCollect = serverClock.ElapsedMilliseconds;                          GC.Collect();                      }                      //Run the screenshot expire function every 10 minutes                      if ((serverClock.ElapsedMilliseconds - lastScreenshotExpiredCheck) > 600000)                      {                          lastScreenshotExpiredCheck = serverClock.ElapsedMilliseconds;                          ScreenshotExpire.ExpireScreenshots();                      }                      //Run the log expire function every 10 minutes                      if ((serverClock.ElapsedMilliseconds - lastLogExpiredCheck) > 600000)                      {                          lastLogExpiredCheck = serverClock.ElapsedMilliseconds;                          LogExpire.ExpireLogs();                      }                      // Check if the day has changed' every minute                      if ((serverClock.ElapsedMilliseconds - lastDayCheck) > 60000)                      {                          lastDayCheck = serverClock.ElapsedMilliseconds;                          if (day != DateTime.Now.Day)                          {                              DarkLog.LogFilename = Path.Combine(DarkLog.LogFolder' "dmpserver " + DateTime.Now.ToString("yyyy-MM-dd HH-mm-ss") + ".log");                              DarkLog.WriteToLog("Continued from logfile " + DateTime.Now.ToString("yyyy-MM-dd HH-mm-ss") + ".log");                              day = DateTime.Now.Day;                          }                      }                        Thread.Sleep(500);                  }                  DMPPluginHandler.FireOnServerStop();                  commandThread.Abort();                  clientThread.Join();              }
Magic Number,DarkMultiPlayerServer,Server,C:\repos\godarklight_DarkMultiPlayer\Server\Main.cs,Main,The following statement contains a magic number: while (serverStarting || serverRestarting)              {                  if (serverRestarting)                  {                      DarkLog.Debug("Reloading settings...");                      Settings.Reset();                      Settings.Load();                      if (Settings.settingsStore.gameDifficulty == GameDifficulty.CUSTOM)                      {                          DarkLog.Debug("Reloading gameplay settings...");                          GameplaySettings.Reset();                          GameplaySettings.Load();                      }                  }                    serverRestarting = false;                  DarkLog.Normal("Starting DMPServer " + Common.PROGRAM_VERSION + "' protocol " + Common.PROTOCOL_VERSION);                    if (Settings.settingsStore.gameDifficulty == GameDifficulty.CUSTOM)                  {                      //Generate the config file by accessing the object.                      DarkLog.Debug("Loading gameplay settings...");                      GameplaySettings.Load();                  }                    //Load universe                  DarkLog.Normal("Loading universe... ");                  CheckUniverse();                    DarkLog.Normal("Starting " + Settings.settingsStore.warpMode + " server on port " + Settings.settingsStore.port + "... ");                    serverRunning = true;                  Thread commandThread = new Thread(new ThreadStart(CommandHandler.ThreadMain));                  Thread clientThread = new Thread(new ThreadStart(ClientHandler.ThreadMain));                  commandThread.Start();                  clientThread.Start();                  while (serverStarting)                  {                      Thread.Sleep(500);                  }                    StartHTTPServer();                  DarkLog.Normal("Ready!");                  DMPPluginHandler.FireOnServerStart();                  while (serverRunning)                  {                      //Run a garbage collection every 30 seconds.                      if ((serverClock.ElapsedMilliseconds - lastGarbageCollect) > 30000)                      {                          lastGarbageCollect = serverClock.ElapsedMilliseconds;                          GC.Collect();                      }                      //Run the screenshot expire function every 10 minutes                      if ((serverClock.ElapsedMilliseconds - lastScreenshotExpiredCheck) > 600000)                      {                          lastScreenshotExpiredCheck = serverClock.ElapsedMilliseconds;                          ScreenshotExpire.ExpireScreenshots();                      }                      //Run the log expire function every 10 minutes                      if ((serverClock.ElapsedMilliseconds - lastLogExpiredCheck) > 600000)                      {                          lastLogExpiredCheck = serverClock.ElapsedMilliseconds;                          LogExpire.ExpireLogs();                      }                      // Check if the day has changed' every minute                      if ((serverClock.ElapsedMilliseconds - lastDayCheck) > 60000)                      {                          lastDayCheck = serverClock.ElapsedMilliseconds;                          if (day != DateTime.Now.Day)                          {                              DarkLog.LogFilename = Path.Combine(DarkLog.LogFolder' "dmpserver " + DateTime.Now.ToString("yyyy-MM-dd HH-mm-ss") + ".log");                              DarkLog.WriteToLog("Continued from logfile " + DateTime.Now.ToString("yyyy-MM-dd HH-mm-ss") + ".log");                              day = DateTime.Now.Day;                          }                      }                        Thread.Sleep(500);                  }                  DMPPluginHandler.FireOnServerStop();                  commandThread.Abort();                  clientThread.Join();              }
Magic Number,DarkMultiPlayerServer,Server,C:\repos\godarklight_DarkMultiPlayer\Server\Main.cs,Main,The following statement contains a magic number: while (serverStarting || serverRestarting)              {                  if (serverRestarting)                  {                      DarkLog.Debug("Reloading settings...");                      Settings.Reset();                      Settings.Load();                      if (Settings.settingsStore.gameDifficulty == GameDifficulty.CUSTOM)                      {                          DarkLog.Debug("Reloading gameplay settings...");                          GameplaySettings.Reset();                          GameplaySettings.Load();                      }                  }                    serverRestarting = false;                  DarkLog.Normal("Starting DMPServer " + Common.PROGRAM_VERSION + "' protocol " + Common.PROTOCOL_VERSION);                    if (Settings.settingsStore.gameDifficulty == GameDifficulty.CUSTOM)                  {                      //Generate the config file by accessing the object.                      DarkLog.Debug("Loading gameplay settings...");                      GameplaySettings.Load();                  }                    //Load universe                  DarkLog.Normal("Loading universe... ");                  CheckUniverse();                    DarkLog.Normal("Starting " + Settings.settingsStore.warpMode + " server on port " + Settings.settingsStore.port + "... ");                    serverRunning = true;                  Thread commandThread = new Thread(new ThreadStart(CommandHandler.ThreadMain));                  Thread clientThread = new Thread(new ThreadStart(ClientHandler.ThreadMain));                  commandThread.Start();                  clientThread.Start();                  while (serverStarting)                  {                      Thread.Sleep(500);                  }                    StartHTTPServer();                  DarkLog.Normal("Ready!");                  DMPPluginHandler.FireOnServerStart();                  while (serverRunning)                  {                      //Run a garbage collection every 30 seconds.                      if ((serverClock.ElapsedMilliseconds - lastGarbageCollect) > 30000)                      {                          lastGarbageCollect = serverClock.ElapsedMilliseconds;                          GC.Collect();                      }                      //Run the screenshot expire function every 10 minutes                      if ((serverClock.ElapsedMilliseconds - lastScreenshotExpiredCheck) > 600000)                      {                          lastScreenshotExpiredCheck = serverClock.ElapsedMilliseconds;                          ScreenshotExpire.ExpireScreenshots();                      }                      //Run the log expire function every 10 minutes                      if ((serverClock.ElapsedMilliseconds - lastLogExpiredCheck) > 600000)                      {                          lastLogExpiredCheck = serverClock.ElapsedMilliseconds;                          LogExpire.ExpireLogs();                      }                      // Check if the day has changed' every minute                      if ((serverClock.ElapsedMilliseconds - lastDayCheck) > 60000)                      {                          lastDayCheck = serverClock.ElapsedMilliseconds;                          if (day != DateTime.Now.Day)                          {                              DarkLog.LogFilename = Path.Combine(DarkLog.LogFolder' "dmpserver " + DateTime.Now.ToString("yyyy-MM-dd HH-mm-ss") + ".log");                              DarkLog.WriteToLog("Continued from logfile " + DateTime.Now.ToString("yyyy-MM-dd HH-mm-ss") + ".log");                              day = DateTime.Now.Day;                          }                      }                        Thread.Sleep(500);                  }                  DMPPluginHandler.FireOnServerStop();                  commandThread.Abort();                  clientThread.Join();              }
Magic Number,DarkMultiPlayerServer,Server,C:\repos\godarklight_DarkMultiPlayer\Server\Main.cs,Main,The following statement contains a magic number: while (serverStarting || serverRestarting)              {                  if (serverRestarting)                  {                      DarkLog.Debug("Reloading settings...");                      Settings.Reset();                      Settings.Load();                      if (Settings.settingsStore.gameDifficulty == GameDifficulty.CUSTOM)                      {                          DarkLog.Debug("Reloading gameplay settings...");                          GameplaySettings.Reset();                          GameplaySettings.Load();                      }                  }                    serverRestarting = false;                  DarkLog.Normal("Starting DMPServer " + Common.PROGRAM_VERSION + "' protocol " + Common.PROTOCOL_VERSION);                    if (Settings.settingsStore.gameDifficulty == GameDifficulty.CUSTOM)                  {                      //Generate the config file by accessing the object.                      DarkLog.Debug("Loading gameplay settings...");                      GameplaySettings.Load();                  }                    //Load universe                  DarkLog.Normal("Loading universe... ");                  CheckUniverse();                    DarkLog.Normal("Starting " + Settings.settingsStore.warpMode + " server on port " + Settings.settingsStore.port + "... ");                    serverRunning = true;                  Thread commandThread = new Thread(new ThreadStart(CommandHandler.ThreadMain));                  Thread clientThread = new Thread(new ThreadStart(ClientHandler.ThreadMain));                  commandThread.Start();                  clientThread.Start();                  while (serverStarting)                  {                      Thread.Sleep(500);                  }                    StartHTTPServer();                  DarkLog.Normal("Ready!");                  DMPPluginHandler.FireOnServerStart();                  while (serverRunning)                  {                      //Run a garbage collection every 30 seconds.                      if ((serverClock.ElapsedMilliseconds - lastGarbageCollect) > 30000)                      {                          lastGarbageCollect = serverClock.ElapsedMilliseconds;                          GC.Collect();                      }                      //Run the screenshot expire function every 10 minutes                      if ((serverClock.ElapsedMilliseconds - lastScreenshotExpiredCheck) > 600000)                      {                          lastScreenshotExpiredCheck = serverClock.ElapsedMilliseconds;                          ScreenshotExpire.ExpireScreenshots();                      }                      //Run the log expire function every 10 minutes                      if ((serverClock.ElapsedMilliseconds - lastLogExpiredCheck) > 600000)                      {                          lastLogExpiredCheck = serverClock.ElapsedMilliseconds;                          LogExpire.ExpireLogs();                      }                      // Check if the day has changed' every minute                      if ((serverClock.ElapsedMilliseconds - lastDayCheck) > 60000)                      {                          lastDayCheck = serverClock.ElapsedMilliseconds;                          if (day != DateTime.Now.Day)                          {                              DarkLog.LogFilename = Path.Combine(DarkLog.LogFolder' "dmpserver " + DateTime.Now.ToString("yyyy-MM-dd HH-mm-ss") + ".log");                              DarkLog.WriteToLog("Continued from logfile " + DateTime.Now.ToString("yyyy-MM-dd HH-mm-ss") + ".log");                              day = DateTime.Now.Day;                          }                      }                        Thread.Sleep(500);                  }                  DMPPluginHandler.FireOnServerStop();                  commandThread.Abort();                  clientThread.Join();              }
Magic Number,DarkMultiPlayerServer,Server,C:\repos\godarklight_DarkMultiPlayer\Server\Main.cs,Main,The following statement contains a magic number: while (serverStarting || serverRestarting)              {                  if (serverRestarting)                  {                      DarkLog.Debug("Reloading settings...");                      Settings.Reset();                      Settings.Load();                      if (Settings.settingsStore.gameDifficulty == GameDifficulty.CUSTOM)                      {                          DarkLog.Debug("Reloading gameplay settings...");                          GameplaySettings.Reset();                          GameplaySettings.Load();                      }                  }                    serverRestarting = false;                  DarkLog.Normal("Starting DMPServer " + Common.PROGRAM_VERSION + "' protocol " + Common.PROTOCOL_VERSION);                    if (Settings.settingsStore.gameDifficulty == GameDifficulty.CUSTOM)                  {                      //Generate the config file by accessing the object.                      DarkLog.Debug("Loading gameplay settings...");                      GameplaySettings.Load();                  }                    //Load universe                  DarkLog.Normal("Loading universe... ");                  CheckUniverse();                    DarkLog.Normal("Starting " + Settings.settingsStore.warpMode + " server on port " + Settings.settingsStore.port + "... ");                    serverRunning = true;                  Thread commandThread = new Thread(new ThreadStart(CommandHandler.ThreadMain));                  Thread clientThread = new Thread(new ThreadStart(ClientHandler.ThreadMain));                  commandThread.Start();                  clientThread.Start();                  while (serverStarting)                  {                      Thread.Sleep(500);                  }                    StartHTTPServer();                  DarkLog.Normal("Ready!");                  DMPPluginHandler.FireOnServerStart();                  while (serverRunning)                  {                      //Run a garbage collection every 30 seconds.                      if ((serverClock.ElapsedMilliseconds - lastGarbageCollect) > 30000)                      {                          lastGarbageCollect = serverClock.ElapsedMilliseconds;                          GC.Collect();                      }                      //Run the screenshot expire function every 10 minutes                      if ((serverClock.ElapsedMilliseconds - lastScreenshotExpiredCheck) > 600000)                      {                          lastScreenshotExpiredCheck = serverClock.ElapsedMilliseconds;                          ScreenshotExpire.ExpireScreenshots();                      }                      //Run the log expire function every 10 minutes                      if ((serverClock.ElapsedMilliseconds - lastLogExpiredCheck) > 600000)                      {                          lastLogExpiredCheck = serverClock.ElapsedMilliseconds;                          LogExpire.ExpireLogs();                      }                      // Check if the day has changed' every minute                      if ((serverClock.ElapsedMilliseconds - lastDayCheck) > 60000)                      {                          lastDayCheck = serverClock.ElapsedMilliseconds;                          if (day != DateTime.Now.Day)                          {                              DarkLog.LogFilename = Path.Combine(DarkLog.LogFolder' "dmpserver " + DateTime.Now.ToString("yyyy-MM-dd HH-mm-ss") + ".log");                              DarkLog.WriteToLog("Continued from logfile " + DateTime.Now.ToString("yyyy-MM-dd HH-mm-ss") + ".log");                              day = DateTime.Now.Day;                          }                      }                        Thread.Sleep(500);                  }                  DMPPluginHandler.FireOnServerStop();                  commandThread.Abort();                  clientThread.Join();              }
Magic Number,DarkMultiPlayerServer,Server,C:\repos\godarklight_DarkMultiPlayer\Server\Main.cs,GetLastPlayerActivity,The following statement contains a magic number: return (serverClock.ElapsedMilliseconds - lastPlayerActivity) / 1000;
Magic Number,DarkMultiPlayerServer,Server,C:\repos\godarklight_DarkMultiPlayer\Server\Main.cs,CatchExit,The following statement contains a magic number: if ((DateTime.UtcNow.Ticks - ctrlCTime) > 50000000)              {                  ctrlCTime = DateTime.UtcNow.Ticks;                  args.Cancel = true;                  ShutDown("Caught Ctrl+C");              }              else              {                  DarkLog.Debug("Terminating!");              }
Magic Number,DarkMultiPlayerServer,Server,C:\repos\godarklight_DarkMultiPlayer\Server\Main.cs,StartHTTPServer,The following statement contains a magic number: if (Settings.settingsStore.httpPort > 0)              {                  DarkLog.Normal("Starting HTTP server...");                  httpListener = new HttpListener();                  try                  {                      if (Settings.settingsStore.address != "0.0.0.0" && Settings.settingsStore.address != "::")                      {                          string listenAddress = Settings.settingsStore.address;                          if (listenAddress.Contains(":"))                          {                              //Sorry                              DarkLog.Error("Error: The server status port does not support specific IPv6 addresses. Sorry.");                              //listenAddress = "[" + listenAddress + "]";                              return;                            }                            httpListener.Prefixes.Add("http://" + listenAddress + ":" + Settings.settingsStore.httpPort + '/');                      }                      else                      {                          httpListener.Prefixes.Add("http://*:" + Settings.settingsStore.httpPort + '/');                      }                      httpListener.Start();                      httpListener.BeginGetContext(asyncHTTPCallback' httpListener);                  }                  catch (HttpListenerException e)                  {                      if (OS == "Win32NT" || OS == "Win32S" || OS == "Win32Windows" || OS == "WinCE") // if OS is Windows                      {                          if (e.ErrorCode == 5) // Access Denied                          {                              DarkLog.Debug("HTTP Server: access denied.");                              DarkLog.Debug("Prompting user to switch to administrator mode.");                                ProcessStartInfo startInfo = new ProcessStartInfo("DMPServer.exe") { Verb = "runas" };                              Process.Start(startInfo);                                Environment.Exit(0);                          }                      }                      else                      {                          DarkLog.Fatal("Error while starting HTTP server.\n" + e);                      }                      throw;                  }              }
Magic Number,DarkMultiPlayerServer,Server,C:\repos\godarklight_DarkMultiPlayer\Server\Main.cs,asyncHTTPCallback,The following statement contains a magic number: try              {                  HttpListener listener = (HttpListener)result.AsyncState;                    HttpListenerContext context = listener.EndGetContext(result);                  string responseText = "";                  bool handled = false;                    if (context.Request.Url.PathAndQuery.StartsWith("/modcontrol"))                  {                      if (!File.Exists(modFile))                      {                          GenerateNewModFile();                      }                      responseText = File.ReadAllText(modFile);                      handled = true;                  }                  if (!handled)                  {                      responseText = new ServerInfo(Settings.settingsStore).GetJSON();                  }                    byte[] buffer = Encoding.UTF8.GetBytes(responseText);                  context.Response.ContentLength64 = buffer.LongLength;                  context.Response.OutputStream.Write(buffer' 0' buffer.Length);                  context.Response.OutputStream.Close();                    listener.BeginGetContext(asyncHTTPCallback' listener);              }              catch (Exception e)              {                  //Ignore the EngGetContext throw while shutting down the HTTP server.                  if (serverRunning)                  {                      DarkLog.Error("Exception while listening to HTTP server!' Exception:\n" + e);                      Thread.Sleep(1000);                      httpListener.BeginGetContext(asyncHTTPCallback' httpListener);                  }              }
Magic Number,DarkMultiPlayerServer,CommandHandler,C:\repos\godarklight_DarkMultiPlayer\Server\CommandHandler.cs,ThreadMain,The following statement contains a magic number: try              {                  //Register commands                  CommandHandler.RegisterCommand("help"' CommandHandler.DisplayHelp' "Displays this help");                  CommandHandler.RegisterCommand("say"' CommandHandler.Say' "Broadcasts a message to clients");                  CommandHandler.RegisterCommand("dekessler"' Dekessler.RunDekessler' "Clears out debris from the server");                  CommandHandler.RegisterCommand("nukeksc"' NukeKSC.RunNukeKSC' "Clears ALL vessels from KSC and the Runway");                  CommandHandler.RegisterCommand("listclients"' ListClients' "Lists connected clients");                  CommandHandler.RegisterCommand("countclients"' CountClients' "Counts connected clients");                  CommandHandler.RegisterCommand("connectionstats"' ConnectionStats' "Displays network traffic usage");                    //Main loop                  while (Server.serverRunning)                  {                      string input = "";                      try                      {                          input = Console.ReadLine();                          if (input == null)                          {                              DarkLog.Debug("Terminal may be not attached or broken' Exiting out of command handler");                              return;                          }                      }                      catch                      {                          if (Server.serverRunning)                          {                              DarkLog.Debug("Ignored mono Console.ReadLine() bug");                          }                          Thread.Sleep(500);                      }                      DarkLog.Normal("Command input: " + input);                      if (input.StartsWith("/"))                      {                          HandleServerInput(input.Substring(1));                      }                      else                      {                          if (input != "")                          {                              commands["say"].func(input);                          }                      }                  }              }              catch (Exception e)              {                  if (Server.serverRunning)                  {                      DarkLog.Fatal("Error in command handler thread' Exception: " + e);                      throw;                  }              }
Magic Number,DarkMultiPlayerServer,ClientHandler,C:\repos\godarklight_DarkMultiPlayer\Server\ClientHandler.cs,ThreadMain,The following statement contains a magic number: try              {                  clients = new List<ClientObject>().AsReadOnly();                    Messages.WarpControl.Reset();                  Messages.Chat.Reset();                  Messages.ScreenshotLibrary.Reset();                    SetupTCPServer();                    while (Server.serverRunning)                  {                      //Process current clients                      foreach (ClientObject client in clients)                      {                          Messages.Heartbeat.CheckHeartBeat(client);                      }                      //Check timers                      NukeKSC.CheckTimer();                      Dekessler.CheckTimer();                      Messages.WarpControl.CheckTimer();                      //Run plugin update                      DMPPluginHandler.FireOnUpdate();                      Thread.Sleep(10);                  }              }              catch (Exception e)              {                  DarkLog.Error("Fatal error thrown' exception: " + e);                  Server.ShutDown("Crashed!");              }
Magic Number,DarkMultiPlayerServer,ClientHandler,C:\repos\godarklight_DarkMultiPlayer\Server\ClientHandler.cs,ThreadMain,The following statement contains a magic number: try              {                  long disconnectTime = DateTime.UtcNow.Ticks;                  bool sendingHighPriotityMessages = true;                  while (sendingHighPriotityMessages)                  {                      if ((DateTime.UtcNow.Ticks - disconnectTime) > 50000000)                      {                          DarkLog.Debug("Shutting down with " + Server.playerCount + " players' " + clients.Count + " connected clients");                          break;                      }                      sendingHighPriotityMessages = false;                      foreach (ClientObject client in clients)                      {                          if (client.authenticated && (client.sendMessageQueueHigh.Count > 0))                          {                              sendingHighPriotityMessages = true;                          }                      }                      Thread.Sleep(10);                  }                  ShutdownTCPServer();              }              catch (Exception e)              {                  DarkLog.Fatal("Fatal error thrown during shutdown' exception: " + e);                  throw;              }
Magic Number,DarkMultiPlayerServer,ClientHandler,C:\repos\godarklight_DarkMultiPlayer\Server\ClientHandler.cs,ThreadMain,The following statement contains a magic number: try              {                  long disconnectTime = DateTime.UtcNow.Ticks;                  bool sendingHighPriotityMessages = true;                  while (sendingHighPriotityMessages)                  {                      if ((DateTime.UtcNow.Ticks - disconnectTime) > 50000000)                      {                          DarkLog.Debug("Shutting down with " + Server.playerCount + " players' " + clients.Count + " connected clients");                          break;                      }                      sendingHighPriotityMessages = false;                      foreach (ClientObject client in clients)                      {                          if (client.authenticated && (client.sendMessageQueueHigh.Count > 0))                          {                              sendingHighPriotityMessages = true;                          }                      }                      Thread.Sleep(10);                  }                  ShutdownTCPServer();              }              catch (Exception e)              {                  DarkLog.Fatal("Fatal error thrown during shutdown' exception: " + e);                  throw;              }
Magic Number,DarkMultiPlayerServer,ClientHandler,C:\repos\godarklight_DarkMultiPlayer\Server\ClientHandler.cs,SetupTCPServer,The following statement contains a magic number: try              {                  IPAddress bindAddress = IPAddress.Parse(Settings.settingsStore.address);                  TCPServer = new TcpListener(new IPEndPoint(bindAddress' Settings.settingsStore.port));                  try                  {                      if (System.Net.Sockets.Socket.OSSupportsIPv6)                      {                          //Windows defaults to v6 only' but this option does not exist in mono so it has to be in a try/catch block along with the casted int.                          if (Environment.OSVersion.Platform != PlatformID.MacOSX && Environment.OSVersion.Platform != PlatformID.Unix)                          {                              TCPServer.Server.SetSocketOption(SocketOptionLevel.IPv6' (SocketOptionName)27' 0);                          }                      }                  }                  catch                  {                      //Don't care - On linux and mac this throws because it's already set' and on windows it just works.                  }                  TCPServer.Start(4);                  TCPServer.BeginAcceptTcpClient(new AsyncCallback(NewClientCallback)' null);              }              catch (Exception e)              {                  DarkLog.Normal("Error setting up server' Exception: " + e);                  Server.serverRunning = false;              }
Magic Number,DarkMultiPlayerServer,ClientHandler,C:\repos\godarklight_DarkMultiPlayer\Server\ClientHandler.cs,SetupTCPServer,The following statement contains a magic number: try              {                  IPAddress bindAddress = IPAddress.Parse(Settings.settingsStore.address);                  TCPServer = new TcpListener(new IPEndPoint(bindAddress' Settings.settingsStore.port));                  try                  {                      if (System.Net.Sockets.Socket.OSSupportsIPv6)                      {                          //Windows defaults to v6 only' but this option does not exist in mono so it has to be in a try/catch block along with the casted int.                          if (Environment.OSVersion.Platform != PlatformID.MacOSX && Environment.OSVersion.Platform != PlatformID.Unix)                          {                              TCPServer.Server.SetSocketOption(SocketOptionLevel.IPv6' (SocketOptionName)27' 0);                          }                      }                  }                  catch                  {                      //Don't care - On linux and mac this throws because it's already set' and on windows it just works.                  }                  TCPServer.Start(4);                  TCPServer.BeginAcceptTcpClient(new AsyncCallback(NewClientCallback)' null);              }              catch (Exception e)              {                  DarkLog.Normal("Error setting up server' Exception: " + e);                  Server.serverRunning = false;              }
Magic Number,DarkMultiPlayerServer,ClientHandler,C:\repos\godarklight_DarkMultiPlayer\Server\ClientHandler.cs,SendOutgoingMessages,The following statement contains a magic number: while (client.connectionStatus == ConnectionStatus.CONNECTED)              {                  ServerMessage message = null;                  if (message == null && client.sendMessageQueueHigh.Count > 0)                  {                      client.sendMessageQueueHigh.TryDequeue(out message);                  }                  //Don't send low or split during server shutdown.                  if (Server.serverRunning)                  {                      if (message == null && client.sendMessageQueueSplit.Count > 0)                      {                          client.sendMessageQueueSplit.TryDequeue(out message);                      }                      if (message == null && client.sendMessageQueueLow.Count > 0)                      {                          client.sendMessageQueueLow.TryDequeue(out message);                          //Splits large messages to higher priority messages can get into the queue faster                          SplitAndRewriteMessage(client' ref message);                      }                  }                  if (message != null)                  {                      SendNetworkMessage(client' message);                  }                  else                  {                      //Give the chance for the thread to terminate                      client.sendEvent.WaitOne(1000);                  }              }
Magic Number,DarkMultiPlayerServer,ClientHandler,C:\repos\godarklight_DarkMultiPlayer\Server\ClientHandler.cs,SplitAndRewriteMessage,The following statement contains a magic number: if (message.data.Length > Common.SPLIT_MESSAGE_LENGTH)              {                  ServerMessage newSplitMessage = new ServerMessage();                  newSplitMessage.type = ServerMessageType.SPLIT_MESSAGE;                  int splitBytesLeft = message.data.Length;                  using (MessageWriter mw = new MessageWriter())                  {                      mw.Write<int>((int)message.type);                      mw.Write<int>(message.data.Length);                      byte[] firstSplit = new byte[Common.SPLIT_MESSAGE_LENGTH];                      Array.Copy(message.data' 0' firstSplit' 0' Common.SPLIT_MESSAGE_LENGTH);                      mw.Write<byte[]>(firstSplit);                      splitBytesLeft -= Common.SPLIT_MESSAGE_LENGTH;                      newSplitMessage.data = mw.GetMessageBytes();                      //SPLIT_MESSAGE metadata header length.                      client.bytesQueuedOut += 8;                      client.sendMessageQueueSplit.Enqueue(newSplitMessage);                  }                      while (splitBytesLeft > 0)                  {                      ServerMessage currentSplitMessage = new ServerMessage();                      currentSplitMessage.type = ServerMessageType.SPLIT_MESSAGE;                      currentSplitMessage.data = new byte[Math.Min(splitBytesLeft' Common.SPLIT_MESSAGE_LENGTH)];                      Array.Copy(message.data' message.data.Length - splitBytesLeft' currentSplitMessage.data' 0' currentSplitMessage.data.Length);                      splitBytesLeft -= currentSplitMessage.data.Length;                      //SPLIT_MESSAGE network frame header length.                      client.bytesQueuedOut += 8;                      client.sendMessageQueueSplit.Enqueue(currentSplitMessage);                  }                  client.sendMessageQueueSplit.TryDequeue(out message);              }
Magic Number,DarkMultiPlayerServer,ClientHandler,C:\repos\godarklight_DarkMultiPlayer\Server\ClientHandler.cs,SplitAndRewriteMessage,The following statement contains a magic number: if (message.data.Length > Common.SPLIT_MESSAGE_LENGTH)              {                  ServerMessage newSplitMessage = new ServerMessage();                  newSplitMessage.type = ServerMessageType.SPLIT_MESSAGE;                  int splitBytesLeft = message.data.Length;                  using (MessageWriter mw = new MessageWriter())                  {                      mw.Write<int>((int)message.type);                      mw.Write<int>(message.data.Length);                      byte[] firstSplit = new byte[Common.SPLIT_MESSAGE_LENGTH];                      Array.Copy(message.data' 0' firstSplit' 0' Common.SPLIT_MESSAGE_LENGTH);                      mw.Write<byte[]>(firstSplit);                      splitBytesLeft -= Common.SPLIT_MESSAGE_LENGTH;                      newSplitMessage.data = mw.GetMessageBytes();                      //SPLIT_MESSAGE metadata header length.                      client.bytesQueuedOut += 8;                      client.sendMessageQueueSplit.Enqueue(newSplitMessage);                  }                      while (splitBytesLeft > 0)                  {                      ServerMessage currentSplitMessage = new ServerMessage();                      currentSplitMessage.type = ServerMessageType.SPLIT_MESSAGE;                      currentSplitMessage.data = new byte[Math.Min(splitBytesLeft' Common.SPLIT_MESSAGE_LENGTH)];                      Array.Copy(message.data' message.data.Length - splitBytesLeft' currentSplitMessage.data' 0' currentSplitMessage.data.Length);                      splitBytesLeft -= currentSplitMessage.data.Length;                      //SPLIT_MESSAGE network frame header length.                      client.bytesQueuedOut += 8;                      client.sendMessageQueueSplit.Enqueue(currentSplitMessage);                  }                  client.sendMessageQueueSplit.TryDequeue(out message);              }
Magic Number,DarkMultiPlayerServer,ClientHandler,C:\repos\godarklight_DarkMultiPlayer\Server\ClientHandler.cs,SendNetworkMessage,The following statement contains a magic number: if (message.type == ServerMessageType.SYNC_TIME_REPLY)              {                  try                  {                      using (MessageWriter mw = new MessageWriter())                      {                          using (MessageReader mr = new MessageReader(message.data))                          {                              client.bytesQueuedOut += 8;                              //Client send time                              mw.Write<long>(mr.Read<long>());                              //Server receive time                              mw.Write<long>(mr.Read<long>());                              //Server send time                              mw.Write<long>(DateTime.UtcNow.Ticks);                              message.data = mw.GetMessageBytes();                          }                      }                  }                  catch (Exception e)                  {                      DarkLog.Debug("Error rewriting SYNC_TIME packet' Exception " + e);                  }              }
Magic Number,DarkMultiPlayerServer,ClientHandler,C:\repos\godarklight_DarkMultiPlayer\Server\ClientHandler.cs,StartReceivingIncomingMessages,The following statement contains a magic number: client.receiveMessage.data = new byte[8];
Magic Number,DarkMultiPlayerServer,ClientHandler,C:\repos\godarklight_DarkMultiPlayer\Server\ClientHandler.cs,ReceiveCallback,The following statement contains a magic number: if (client.receiveMessageBytesLeft == 0)              {                  //We either have the header or the message data' let's do something                  if (!client.isReceivingMessage)                  {                      //We have the header                      using (MessageReader mr = new MessageReader(client.receiveMessage.data))                      {                            int messageType = mr.Read<int>();                          int messageLength = mr.Read<int>();                          if (messageType < 0 || messageType > (Enum.GetNames(typeof(ClientMessageType)).Length - 1))                          {                              //Malformed message' most likely from a non DMP-client.                              Messages.ConnectionEnd.SendConnectionEnd(client' "Invalid DMP message. Disconnected.");                              DarkLog.Normal("Invalid DMP message from " + client.endpoint);                              //Returning from ReceiveCallback will break the receive loop and stop processing any further messages.                              return;                          }                          client.receiveMessage.type = (ClientMessageType)messageType;                          if (messageLength == 0)                          {                              //Null message' handle it.                              client.receiveMessage.data = null;                              HandleMessage(client' client.receiveMessage);                              client.receiveMessage.type = 0;                              client.receiveMessage.data = new byte[8];                              client.receiveMessageBytesLeft = client.receiveMessage.data.Length;                          }                          else                          {                              if (messageLength > 0 && messageLength < Common.MAX_MESSAGE_SIZE)                              {                                  client.isReceivingMessage = true;                                  client.receiveMessage.data = new byte[messageLength];                                  client.receiveMessageBytesLeft = client.receiveMessage.data.Length;                              }                              else                              {                                  //Malformed message' most likely from a non DMP-client.                                  Messages.ConnectionEnd.SendConnectionEnd(client' "Invalid DMP message. Disconnected.");                                  DarkLog.Normal("Invalid DMP message from " + client.endpoint);                                  //Returning from ReceiveCallback will break the receive loop and stop processing any further messages.                                  return;                              }                          }                      }                  }                  else                  {                      //We have the message data to a non-null message' handle it                      client.isReceivingMessage = false;  #if !DEBUG                      try                      {  #endif                      HandleMessage(client' client.receiveMessage);  #if !DEBUG                      }                      catch (Exception e)                      {                          HandleDisconnectException("ReceiveCallback"' client' e);                          return;                      }  #endif                      client.receiveMessage.type = 0;                      client.receiveMessage.data = new byte[8];                      client.receiveMessageBytesLeft = client.receiveMessage.data.Length;                  }              }
Magic Number,DarkMultiPlayerServer,ClientHandler,C:\repos\godarklight_DarkMultiPlayer\Server\ClientHandler.cs,ReceiveCallback,The following statement contains a magic number: if (client.receiveMessageBytesLeft == 0)              {                  //We either have the header or the message data' let's do something                  if (!client.isReceivingMessage)                  {                      //We have the header                      using (MessageReader mr = new MessageReader(client.receiveMessage.data))                      {                            int messageType = mr.Read<int>();                          int messageLength = mr.Read<int>();                          if (messageType < 0 || messageType > (Enum.GetNames(typeof(ClientMessageType)).Length - 1))                          {                              //Malformed message' most likely from a non DMP-client.                              Messages.ConnectionEnd.SendConnectionEnd(client' "Invalid DMP message. Disconnected.");                              DarkLog.Normal("Invalid DMP message from " + client.endpoint);                              //Returning from ReceiveCallback will break the receive loop and stop processing any further messages.                              return;                          }                          client.receiveMessage.type = (ClientMessageType)messageType;                          if (messageLength == 0)                          {                              //Null message' handle it.                              client.receiveMessage.data = null;                              HandleMessage(client' client.receiveMessage);                              client.receiveMessage.type = 0;                              client.receiveMessage.data = new byte[8];                              client.receiveMessageBytesLeft = client.receiveMessage.data.Length;                          }                          else                          {                              if (messageLength > 0 && messageLength < Common.MAX_MESSAGE_SIZE)                              {                                  client.isReceivingMessage = true;                                  client.receiveMessage.data = new byte[messageLength];                                  client.receiveMessageBytesLeft = client.receiveMessage.data.Length;                              }                              else                              {                                  //Malformed message' most likely from a non DMP-client.                                  Messages.ConnectionEnd.SendConnectionEnd(client' "Invalid DMP message. Disconnected.");                                  DarkLog.Normal("Invalid DMP message from " + client.endpoint);                                  //Returning from ReceiveCallback will break the receive loop and stop processing any further messages.                                  return;                              }                          }                      }                  }                  else                  {                      //We have the message data to a non-null message' handle it                      client.isReceivingMessage = false;  #if !DEBUG                      try                      {  #endif                      HandleMessage(client' client.receiveMessage);  #if !DEBUG                      }                      catch (Exception e)                      {                          HandleDisconnectException("ReceiveCallback"' client' e);                          return;                      }  #endif                      client.receiveMessage.type = 0;                      client.receiveMessage.data = new byte[8];                      client.receiveMessageBytesLeft = client.receiveMessage.data.Length;                  }              }
Magic Number,DarkMultiPlayerServer,ClientHandler,C:\repos\godarklight_DarkMultiPlayer\Server\ClientHandler.cs,SendToClient,The following statement contains a magic number: lock (client.sendLock)              {                  if (message == null)                  {                      return;                  }                  //All messages have an 8 byte header                  client.bytesQueuedOut += 8;                  if (message.data != null)                  {                      //Count the payload if we have one.                      client.bytesQueuedOut += message.data.Length;                  }                  if (highPriority)                  {                      client.sendMessageQueueHigh.Enqueue(message);                  }                  else                  {                      client.sendMessageQueueLow.Enqueue(message);                      //If we need to optimize                      if (client.bytesQueuedOut > OPTIMIZE_QUEUE_LIMIT)                      {                          //And we haven't optimized in the last 5 seconds                          long currentTime = DateTime.UtcNow.Ticks;                          long optimizedBytes = 0;                          if ((currentTime - client.lastQueueOptimizeTime) > 50000000)                          {                              client.lastQueueOptimizeTime = currentTime;                              DarkLog.Debug("Optimizing " + client.playerName + " (" + client.bytesQueuedOut + " bytes queued)");                                //Create a temporary filter list                              List<ServerMessage> oldClientMessagesToSend = new List<ServerMessage>();                              List<ServerMessage> newClientMessagesToSend = new List<ServerMessage>();                              //Steal all the messages from the queue and put them into a list                              ServerMessage stealMessage = null;                              while (client.sendMessageQueueLow.TryDequeue(out stealMessage))                              {                                  oldClientMessagesToSend.Add(stealMessage);                              }                              //Clear the client send queue                              List<string> seenProtovesselUpdates = new List<string>();                              List<string> seenPositionUpdates = new List<string>();                              //Iterate backwards over the list                              oldClientMessagesToSend.Reverse();                              foreach (ServerMessage currentMessage in oldClientMessagesToSend)                              {                                  if (currentMessage.type != ServerMessageType.VESSEL_PROTO && currentMessage.type != ServerMessageType.VESSEL_UPDATE)                                  {                                      //Message isn't proto or position' don't skip it.                                      newClientMessagesToSend.Add(currentMessage);                                  }                                  else                                  {                                      //Message is proto or position                                      if (currentMessage.type == ServerMessageType.VESSEL_PROTO)                                      {                                          using (MessageReader mr = new MessageReader(currentMessage.data))                                          {                                              //Don't care about the send time' it's already the latest in the queue.                                              mr.Read<double>();                                              string vesselID = mr.Read<string>();                                              if (!seenProtovesselUpdates.Contains(vesselID))                                              {                                                  seenProtovesselUpdates.Add(vesselID);                                                  newClientMessagesToSend.Add(currentMessage);                                              }                                              else                                              {                                                  optimizedBytes += 8 + currentMessage.data.Length;                                              }                                          }                                      }                                        if (currentMessage.type == ServerMessageType.VESSEL_UPDATE)                                      {                                          using (MessageReader mr = new MessageReader(currentMessage.data))                                          {                                              //Don't care about the send time' it's already the latest in the queue.                                              mr.Read<double>();                                              string vesselID = mr.Read<string>();                                              if (!seenPositionUpdates.Contains(vesselID))                                              {                                                  seenPositionUpdates.Add(vesselID);                                                  newClientMessagesToSend.Add(currentMessage);                                              }                                              else                                              {                                                  //8 byte message header plus payload                                                  optimizedBytes += 8 + currentMessage.data.Length;                                              }                                          }                                      }                                  }                              }                              //Flip it back to the right order                              newClientMessagesToSend.Reverse();                              foreach (ServerMessage putBackMessage in newClientMessagesToSend)                              {                                  client.sendMessageQueueLow.Enqueue(putBackMessage);                              }                              float optimizeTime = (DateTime.UtcNow.Ticks - currentTime) / 10000f;                              client.bytesQueuedOut -= optimizedBytes;                              DarkLog.Debug("Optimized " + optimizedBytes + " bytes in " + Math.Round(optimizeTime' 3) + " ms.");                          }                      }                  }                  client.sendEvent.Set();              }
Magic Number,DarkMultiPlayerServer,ClientHandler,C:\repos\godarklight_DarkMultiPlayer\Server\ClientHandler.cs,SendToClient,The following statement contains a magic number: lock (client.sendLock)              {                  if (message == null)                  {                      return;                  }                  //All messages have an 8 byte header                  client.bytesQueuedOut += 8;                  if (message.data != null)                  {                      //Count the payload if we have one.                      client.bytesQueuedOut += message.data.Length;                  }                  if (highPriority)                  {                      client.sendMessageQueueHigh.Enqueue(message);                  }                  else                  {                      client.sendMessageQueueLow.Enqueue(message);                      //If we need to optimize                      if (client.bytesQueuedOut > OPTIMIZE_QUEUE_LIMIT)                      {                          //And we haven't optimized in the last 5 seconds                          long currentTime = DateTime.UtcNow.Ticks;                          long optimizedBytes = 0;                          if ((currentTime - client.lastQueueOptimizeTime) > 50000000)                          {                              client.lastQueueOptimizeTime = currentTime;                              DarkLog.Debug("Optimizing " + client.playerName + " (" + client.bytesQueuedOut + " bytes queued)");                                //Create a temporary filter list                              List<ServerMessage> oldClientMessagesToSend = new List<ServerMessage>();                              List<ServerMessage> newClientMessagesToSend = new List<ServerMessage>();                              //Steal all the messages from the queue and put them into a list                              ServerMessage stealMessage = null;                              while (client.sendMessageQueueLow.TryDequeue(out stealMessage))                              {                                  oldClientMessagesToSend.Add(stealMessage);                              }                              //Clear the client send queue                              List<string> seenProtovesselUpdates = new List<string>();                              List<string> seenPositionUpdates = new List<string>();                              //Iterate backwards over the list                              oldClientMessagesToSend.Reverse();                              foreach (ServerMessage currentMessage in oldClientMessagesToSend)                              {                                  if (currentMessage.type != ServerMessageType.VESSEL_PROTO && currentMessage.type != ServerMessageType.VESSEL_UPDATE)                                  {                                      //Message isn't proto or position' don't skip it.                                      newClientMessagesToSend.Add(currentMessage);                                  }                                  else                                  {                                      //Message is proto or position                                      if (currentMessage.type == ServerMessageType.VESSEL_PROTO)                                      {                                          using (MessageReader mr = new MessageReader(currentMessage.data))                                          {                                              //Don't care about the send time' it's already the latest in the queue.                                              mr.Read<double>();                                              string vesselID = mr.Read<string>();                                              if (!seenProtovesselUpdates.Contains(vesselID))                                              {                                                  seenProtovesselUpdates.Add(vesselID);                                                  newClientMessagesToSend.Add(currentMessage);                                              }                                              else                                              {                                                  optimizedBytes += 8 + currentMessage.data.Length;                                              }                                          }                                      }                                        if (currentMessage.type == ServerMessageType.VESSEL_UPDATE)                                      {                                          using (MessageReader mr = new MessageReader(currentMessage.data))                                          {                                              //Don't care about the send time' it's already the latest in the queue.                                              mr.Read<double>();                                              string vesselID = mr.Read<string>();                                              if (!seenPositionUpdates.Contains(vesselID))                                              {                                                  seenPositionUpdates.Add(vesselID);                                                  newClientMessagesToSend.Add(currentMessage);                                              }                                              else                                              {                                                  //8 byte message header plus payload                                                  optimizedBytes += 8 + currentMessage.data.Length;                                              }                                          }                                      }                                  }                              }                              //Flip it back to the right order                              newClientMessagesToSend.Reverse();                              foreach (ServerMessage putBackMessage in newClientMessagesToSend)                              {                                  client.sendMessageQueueLow.Enqueue(putBackMessage);                              }                              float optimizeTime = (DateTime.UtcNow.Ticks - currentTime) / 10000f;                              client.bytesQueuedOut -= optimizedBytes;                              DarkLog.Debug("Optimized " + optimizedBytes + " bytes in " + Math.Round(optimizeTime' 3) + " ms.");                          }                      }                  }                  client.sendEvent.Set();              }
Magic Number,DarkMultiPlayerServer,ClientHandler,C:\repos\godarklight_DarkMultiPlayer\Server\ClientHandler.cs,SendToClient,The following statement contains a magic number: lock (client.sendLock)              {                  if (message == null)                  {                      return;                  }                  //All messages have an 8 byte header                  client.bytesQueuedOut += 8;                  if (message.data != null)                  {                      //Count the payload if we have one.                      client.bytesQueuedOut += message.data.Length;                  }                  if (highPriority)                  {                      client.sendMessageQueueHigh.Enqueue(message);                  }                  else                  {                      client.sendMessageQueueLow.Enqueue(message);                      //If we need to optimize                      if (client.bytesQueuedOut > OPTIMIZE_QUEUE_LIMIT)                      {                          //And we haven't optimized in the last 5 seconds                          long currentTime = DateTime.UtcNow.Ticks;                          long optimizedBytes = 0;                          if ((currentTime - client.lastQueueOptimizeTime) > 50000000)                          {                              client.lastQueueOptimizeTime = currentTime;                              DarkLog.Debug("Optimizing " + client.playerName + " (" + client.bytesQueuedOut + " bytes queued)");                                //Create a temporary filter list                              List<ServerMessage> oldClientMessagesToSend = new List<ServerMessage>();                              List<ServerMessage> newClientMessagesToSend = new List<ServerMessage>();                              //Steal all the messages from the queue and put them into a list                              ServerMessage stealMessage = null;                              while (client.sendMessageQueueLow.TryDequeue(out stealMessage))                              {                                  oldClientMessagesToSend.Add(stealMessage);                              }                              //Clear the client send queue                              List<string> seenProtovesselUpdates = new List<string>();                              List<string> seenPositionUpdates = new List<string>();                              //Iterate backwards over the list                              oldClientMessagesToSend.Reverse();                              foreach (ServerMessage currentMessage in oldClientMessagesToSend)                              {                                  if (currentMessage.type != ServerMessageType.VESSEL_PROTO && currentMessage.type != ServerMessageType.VESSEL_UPDATE)                                  {                                      //Message isn't proto or position' don't skip it.                                      newClientMessagesToSend.Add(currentMessage);                                  }                                  else                                  {                                      //Message is proto or position                                      if (currentMessage.type == ServerMessageType.VESSEL_PROTO)                                      {                                          using (MessageReader mr = new MessageReader(currentMessage.data))                                          {                                              //Don't care about the send time' it's already the latest in the queue.                                              mr.Read<double>();                                              string vesselID = mr.Read<string>();                                              if (!seenProtovesselUpdates.Contains(vesselID))                                              {                                                  seenProtovesselUpdates.Add(vesselID);                                                  newClientMessagesToSend.Add(currentMessage);                                              }                                              else                                              {                                                  optimizedBytes += 8 + currentMessage.data.Length;                                              }                                          }                                      }                                        if (currentMessage.type == ServerMessageType.VESSEL_UPDATE)                                      {                                          using (MessageReader mr = new MessageReader(currentMessage.data))                                          {                                              //Don't care about the send time' it's already the latest in the queue.                                              mr.Read<double>();                                              string vesselID = mr.Read<string>();                                              if (!seenPositionUpdates.Contains(vesselID))                                              {                                                  seenPositionUpdates.Add(vesselID);                                                  newClientMessagesToSend.Add(currentMessage);                                              }                                              else                                              {                                                  //8 byte message header plus payload                                                  optimizedBytes += 8 + currentMessage.data.Length;                                              }                                          }                                      }                                  }                              }                              //Flip it back to the right order                              newClientMessagesToSend.Reverse();                              foreach (ServerMessage putBackMessage in newClientMessagesToSend)                              {                                  client.sendMessageQueueLow.Enqueue(putBackMessage);                              }                              float optimizeTime = (DateTime.UtcNow.Ticks - currentTime) / 10000f;                              client.bytesQueuedOut -= optimizedBytes;                              DarkLog.Debug("Optimized " + optimizedBytes + " bytes in " + Math.Round(optimizeTime' 3) + " ms.");                          }                      }                  }                  client.sendEvent.Set();              }
Magic Number,DarkMultiPlayerServer,ClientHandler,C:\repos\godarklight_DarkMultiPlayer\Server\ClientHandler.cs,SendToClient,The following statement contains a magic number: lock (client.sendLock)              {                  if (message == null)                  {                      return;                  }                  //All messages have an 8 byte header                  client.bytesQueuedOut += 8;                  if (message.data != null)                  {                      //Count the payload if we have one.                      client.bytesQueuedOut += message.data.Length;                  }                  if (highPriority)                  {                      client.sendMessageQueueHigh.Enqueue(message);                  }                  else                  {                      client.sendMessageQueueLow.Enqueue(message);                      //If we need to optimize                      if (client.bytesQueuedOut > OPTIMIZE_QUEUE_LIMIT)                      {                          //And we haven't optimized in the last 5 seconds                          long currentTime = DateTime.UtcNow.Ticks;                          long optimizedBytes = 0;                          if ((currentTime - client.lastQueueOptimizeTime) > 50000000)                          {                              client.lastQueueOptimizeTime = currentTime;                              DarkLog.Debug("Optimizing " + client.playerName + " (" + client.bytesQueuedOut + " bytes queued)");                                //Create a temporary filter list                              List<ServerMessage> oldClientMessagesToSend = new List<ServerMessage>();                              List<ServerMessage> newClientMessagesToSend = new List<ServerMessage>();                              //Steal all the messages from the queue and put them into a list                              ServerMessage stealMessage = null;                              while (client.sendMessageQueueLow.TryDequeue(out stealMessage))                              {                                  oldClientMessagesToSend.Add(stealMessage);                              }                              //Clear the client send queue                              List<string> seenProtovesselUpdates = new List<string>();                              List<string> seenPositionUpdates = new List<string>();                              //Iterate backwards over the list                              oldClientMessagesToSend.Reverse();                              foreach (ServerMessage currentMessage in oldClientMessagesToSend)                              {                                  if (currentMessage.type != ServerMessageType.VESSEL_PROTO && currentMessage.type != ServerMessageType.VESSEL_UPDATE)                                  {                                      //Message isn't proto or position' don't skip it.                                      newClientMessagesToSend.Add(currentMessage);                                  }                                  else                                  {                                      //Message is proto or position                                      if (currentMessage.type == ServerMessageType.VESSEL_PROTO)                                      {                                          using (MessageReader mr = new MessageReader(currentMessage.data))                                          {                                              //Don't care about the send time' it's already the latest in the queue.                                              mr.Read<double>();                                              string vesselID = mr.Read<string>();                                              if (!seenProtovesselUpdates.Contains(vesselID))                                              {                                                  seenProtovesselUpdates.Add(vesselID);                                                  newClientMessagesToSend.Add(currentMessage);                                              }                                              else                                              {                                                  optimizedBytes += 8 + currentMessage.data.Length;                                              }                                          }                                      }                                        if (currentMessage.type == ServerMessageType.VESSEL_UPDATE)                                      {                                          using (MessageReader mr = new MessageReader(currentMessage.data))                                          {                                              //Don't care about the send time' it's already the latest in the queue.                                              mr.Read<double>();                                              string vesselID = mr.Read<string>();                                              if (!seenPositionUpdates.Contains(vesselID))                                              {                                                  seenPositionUpdates.Add(vesselID);                                                  newClientMessagesToSend.Add(currentMessage);                                              }                                              else                                              {                                                  //8 byte message header plus payload                                                  optimizedBytes += 8 + currentMessage.data.Length;                                              }                                          }                                      }                                  }                              }                              //Flip it back to the right order                              newClientMessagesToSend.Reverse();                              foreach (ServerMessage putBackMessage in newClientMessagesToSend)                              {                                  client.sendMessageQueueLow.Enqueue(putBackMessage);                              }                              float optimizeTime = (DateTime.UtcNow.Ticks - currentTime) / 10000f;                              client.bytesQueuedOut -= optimizedBytes;                              DarkLog.Debug("Optimized " + optimizedBytes + " bytes in " + Math.Round(optimizeTime' 3) + " ms.");                          }                      }                  }                  client.sendEvent.Set();              }
Magic Number,DarkMultiPlayerServer,ClientHandler,C:\repos\godarklight_DarkMultiPlayer\Server\ClientHandler.cs,SendToClient,The following statement contains a magic number: lock (client.sendLock)              {                  if (message == null)                  {                      return;                  }                  //All messages have an 8 byte header                  client.bytesQueuedOut += 8;                  if (message.data != null)                  {                      //Count the payload if we have one.                      client.bytesQueuedOut += message.data.Length;                  }                  if (highPriority)                  {                      client.sendMessageQueueHigh.Enqueue(message);                  }                  else                  {                      client.sendMessageQueueLow.Enqueue(message);                      //If we need to optimize                      if (client.bytesQueuedOut > OPTIMIZE_QUEUE_LIMIT)                      {                          //And we haven't optimized in the last 5 seconds                          long currentTime = DateTime.UtcNow.Ticks;                          long optimizedBytes = 0;                          if ((currentTime - client.lastQueueOptimizeTime) > 50000000)                          {                              client.lastQueueOptimizeTime = currentTime;                              DarkLog.Debug("Optimizing " + client.playerName + " (" + client.bytesQueuedOut + " bytes queued)");                                //Create a temporary filter list                              List<ServerMessage> oldClientMessagesToSend = new List<ServerMessage>();                              List<ServerMessage> newClientMessagesToSend = new List<ServerMessage>();                              //Steal all the messages from the queue and put them into a list                              ServerMessage stealMessage = null;                              while (client.sendMessageQueueLow.TryDequeue(out stealMessage))                              {                                  oldClientMessagesToSend.Add(stealMessage);                              }                              //Clear the client send queue                              List<string> seenProtovesselUpdates = new List<string>();                              List<string> seenPositionUpdates = new List<string>();                              //Iterate backwards over the list                              oldClientMessagesToSend.Reverse();                              foreach (ServerMessage currentMessage in oldClientMessagesToSend)                              {                                  if (currentMessage.type != ServerMessageType.VESSEL_PROTO && currentMessage.type != ServerMessageType.VESSEL_UPDATE)                                  {                                      //Message isn't proto or position' don't skip it.                                      newClientMessagesToSend.Add(currentMessage);                                  }                                  else                                  {                                      //Message is proto or position                                      if (currentMessage.type == ServerMessageType.VESSEL_PROTO)                                      {                                          using (MessageReader mr = new MessageReader(currentMessage.data))                                          {                                              //Don't care about the send time' it's already the latest in the queue.                                              mr.Read<double>();                                              string vesselID = mr.Read<string>();                                              if (!seenProtovesselUpdates.Contains(vesselID))                                              {                                                  seenProtovesselUpdates.Add(vesselID);                                                  newClientMessagesToSend.Add(currentMessage);                                              }                                              else                                              {                                                  optimizedBytes += 8 + currentMessage.data.Length;                                              }                                          }                                      }                                        if (currentMessage.type == ServerMessageType.VESSEL_UPDATE)                                      {                                          using (MessageReader mr = new MessageReader(currentMessage.data))                                          {                                              //Don't care about the send time' it's already the latest in the queue.                                              mr.Read<double>();                                              string vesselID = mr.Read<string>();                                              if (!seenPositionUpdates.Contains(vesselID))                                              {                                                  seenPositionUpdates.Add(vesselID);                                                  newClientMessagesToSend.Add(currentMessage);                                              }                                              else                                              {                                                  //8 byte message header plus payload                                                  optimizedBytes += 8 + currentMessage.data.Length;                                              }                                          }                                      }                                  }                              }                              //Flip it back to the right order                              newClientMessagesToSend.Reverse();                              foreach (ServerMessage putBackMessage in newClientMessagesToSend)                              {                                  client.sendMessageQueueLow.Enqueue(putBackMessage);                              }                              float optimizeTime = (DateTime.UtcNow.Ticks - currentTime) / 10000f;                              client.bytesQueuedOut -= optimizedBytes;                              DarkLog.Debug("Optimized " + optimizedBytes + " bytes in " + Math.Round(optimizeTime' 3) + " ms.");                          }                      }                  }                  client.sendEvent.Set();              }
Magic Number,DarkMultiPlayerServer,Dekessler,C:\repos\godarklight_DarkMultiPlayer\Server\Dekessler.cs,RunDekessler,The following statement contains a magic number: lock (Server.universeSizeLock)              {                  string[] vesselList = Directory.GetFiles(Path.Combine(Server.universeDirectory' "Vessels"));                  int numberOfRemovals = 0;                  foreach (string vesselFile in vesselList)                  {                      string vesselID = Path.GetFileNameWithoutExtension(vesselFile);                      bool vesselIsDebris = false;                      using (StreamReader sr = new StreamReader(vesselFile))                      {                          string currentLine = sr.ReadLine();                          while (currentLine != null && !vesselIsDebris)                          {                              string trimmedLine = currentLine.Trim();                              if (trimmedLine.StartsWith("type = "))                              {                                  string vesselType = trimmedLine.Substring(trimmedLine.IndexOf("=") + 2);                                  if (vesselType == "Debris")                                  {                                      vesselIsDebris = true;                                  }                              }                              currentLine = sr.ReadLine();                          }                      }                      if (vesselIsDebris)                      {                          DarkLog.Normal("Removing vessel: " + vesselID);                          //Delete it from the universe                          if (File.Exists(vesselFile))                          {                              File.Delete(vesselFile);                          }                          //Send a vessel remove message                          ServerMessage newMessage = new ServerMessage();                          newMessage.type = ServerMessageType.VESSEL_REMOVE;                          using (MessageWriter mw = new MessageWriter())                          {                              //Send it with a delete time of 0 so it shows up for all players.                              mw.Write<double>(0);                              mw.Write<string>(vesselID);                              mw.Write<bool>(false);                              newMessage.data = mw.GetMessageBytes();                          }                          ClientHandler.SendToAll(null' newMessage' false);                          numberOfRemovals++;                          DarkLog.Debug("Removed debris vessel " + vesselID);                      }                  }                  DarkLog.Normal("Removed " + numberOfRemovals + " debris");              }
Magic Number,DarkMultiPlayerServer,Dekessler,C:\repos\godarklight_DarkMultiPlayer\Server\Dekessler.cs,CheckTimer,The following statement contains a magic number: if (Settings.settingsStore.autoDekessler > 0)              {                  //Run it on server start or if the nuke time has elapsed.                  if (((Server.serverClock.ElapsedMilliseconds - lastDekesslerTime) > (Settings.settingsStore.autoDekessler * 60 * 1000)) || lastDekesslerTime == 0)                  {                      lastDekesslerTime = Server.serverClock.ElapsedMilliseconds;                      RunDekessler("");                  }              }
Magic Number,DarkMultiPlayerServer,Dekessler,C:\repos\godarklight_DarkMultiPlayer\Server\Dekessler.cs,CheckTimer,The following statement contains a magic number: if (Settings.settingsStore.autoDekessler > 0)              {                  //Run it on server start or if the nuke time has elapsed.                  if (((Server.serverClock.ElapsedMilliseconds - lastDekesslerTime) > (Settings.settingsStore.autoDekessler * 60 * 1000)) || lastDekesslerTime == 0)                  {                      lastDekesslerTime = Server.serverClock.ElapsedMilliseconds;                      RunDekessler("");                  }              }
Magic Number,DarkMultiPlayerServer,NukeKSC,C:\repos\godarklight_DarkMultiPlayer\Server\NukeKSC.cs,RunNukeKSC,The following statement contains a magic number: lock (Server.universeSizeLock)              {                  string[] vesselList = Directory.GetFiles(Path.Combine(Server.universeDirectory' "Vessels"));                  int numberOfRemovals = 0;                  foreach (string vesselFile in vesselList)                  {                      string vesselID = Path.GetFileNameWithoutExtension(vesselFile);                      bool landedAtKSC = false;                      bool landedAtRunway = false;                      using (StreamReader sr = new StreamReader(vesselFile))                      {                          string currentLine = sr.ReadLine();                          while (currentLine != null && !landedAtKSC && !landedAtRunway)                          {                              string trimmedLine = currentLine.Trim();                              if (trimmedLine.StartsWith("landedAt = "))                              {                                  string landedAt = trimmedLine.Substring(trimmedLine.IndexOf("=") + 2);                                  if (landedAt == "KSC")                                  {                                      landedAtKSC = true;                                  }                                  if (landedAt == "Runway")                                  {                                      landedAtRunway = true;                                  }                              }                              currentLine = sr.ReadLine();                          }                      }                      if (landedAtKSC | landedAtRunway)                      {                          DarkLog.Normal("Removing vessel " + vesselID + " from KSC");                          //Delete it from the universe                          if (File.Exists(vesselFile))                          {                              File.Delete(vesselFile);                          }                          //Send a vessel remove message                          ServerMessage newMessage = new ServerMessage();                          newMessage.type = ServerMessageType.VESSEL_REMOVE;                          using (MessageWriter mw = new MessageWriter())                          {                              //Send it with a delete time of 0 so it shows up for all players.                              mw.Write<double>(0);                              mw.Write<string>(vesselID);                              mw.Write<bool>(false);                              newMessage.data = mw.GetMessageBytes();                          }                          ClientHandler.SendToAll(null' newMessage' false);                          numberOfRemovals++;                      }                  }                  DarkLog.Normal("Nuked " + numberOfRemovals + " vessels around the KSC");              }
Magic Number,DarkMultiPlayerServer,NukeKSC,C:\repos\godarklight_DarkMultiPlayer\Server\NukeKSC.cs,CheckTimer,The following statement contains a magic number: if (Settings.settingsStore.autoNuke > 0)              {                  //Run it on server start or if the nuke time has elapsed.                  if (((Server.serverClock.ElapsedMilliseconds - lastNukeTime) > (Settings.settingsStore.autoNuke * 60 * 1000)) || lastNukeTime == 0)                  {                      lastNukeTime = Server.serverClock.ElapsedMilliseconds;                      RunNukeKSC("");                  }              }
Magic Number,DarkMultiPlayerServer,NukeKSC,C:\repos\godarklight_DarkMultiPlayer\Server\NukeKSC.cs,CheckTimer,The following statement contains a magic number: if (Settings.settingsStore.autoNuke > 0)              {                  //Run it on server start or if the nuke time has elapsed.                  if (((Server.serverClock.ElapsedMilliseconds - lastNukeTime) > (Settings.settingsStore.autoNuke * 60 * 1000)) || lastNukeTime == 0)                  {                      lastNukeTime = Server.serverClock.ElapsedMilliseconds;                      RunNukeKSC("");                  }              }
Magic Number,DarkMultiPlayerServer,BackwardsCompatibility,C:\repos\godarklight_DarkMultiPlayer\Server\BackwardsCompatibility.cs,FixKerbals,The following statement contains a magic number: while (File.Exists(Path.Combine(kerbalPath' kerbalCount + ".txt")))              {                  string oldKerbalFile = Path.Combine(kerbalPath' kerbalCount + ".txt");                  string kerbalName = null;                    using (StreamReader sr = new StreamReader(oldKerbalFile))                  {                      string fileLine;                      while ((fileLine = sr.ReadLine()) != null)                      {                          if (fileLine.StartsWith("name = "))                          {                              kerbalName = fileLine.Substring(fileLine.IndexOf("name = ") + 7);                              break;                          }                      }                  }                    if (!String.IsNullOrEmpty(kerbalName))                  {                      DarkLog.Debug("Renaming kerbal " + kerbalCount + " to " + kerbalName);                      File.Move(oldKerbalFile' Path.Combine(kerbalPath' kerbalName + ".txt"));                  }                  kerbalCount++;              }
Magic Number,DarkMultiPlayerServer.Messages,Handshake,C:\repos\godarklight_DarkMultiPlayer\Server\Messages\Handshake.cs,SendHandshakeChallange,The following statement contains a magic number: client.challange = new byte[1024];
Magic Number,DarkMultiPlayerServer.Messages,Handshake,C:\repos\godarklight_DarkMultiPlayer\Server\Messages\Handshake.cs,HandleHandshakeResponse,The following statement contains a magic number: if (handshakeReponse == HandshakeReply.HANDSHOOK_SUCCESSFULLY)              {                  //Check client isn't already connected                  ClientObject testClient = ClientHandler.GetClientByName(playerName);                  if (testClient != null)                  {                      Messages.Heartbeat.Send(testClient);                      Thread.Sleep(1000);                  }                  if (ClientHandler.ClientConnected(testClient))                  {                      handshakeReponse = HandshakeReply.ALREADY_CONNECTED;                      reason = "Client already connected";                  }              }
Magic Number,DarkMultiPlayerServer.Messages,Handshake,C:\repos\godarklight_DarkMultiPlayer\Server\Messages\Handshake.cs,HandleHandshakeResponse,The following statement contains a magic number: if (handshakeReponse == HandshakeReply.HANDSHOOK_SUCCESSFULLY)              {                  //Check the client matches any database entry                  string storedPlayerFile = Path.Combine(Server.universeDirectory' "Players"' playerName + ".txt");                  string storedPlayerPublicKey = "";                  if (File.Exists(storedPlayerFile))                  {                      storedPlayerPublicKey = File.ReadAllText(storedPlayerFile);                      if (playerPublicKey != storedPlayerPublicKey)                      {                          handshakeReponse = HandshakeReply.INVALID_KEY;                          reason = "Invalid key for user";                      }                      else                      {                          using (RSACryptoServiceProvider rsa = new RSACryptoServiceProvider(1024))                          {                              rsa.PersistKeyInCsp = false;                              rsa.FromXmlString(playerPublicKey);                              bool result = rsa.VerifyData(client.challange' CryptoConfig.CreateFromName("SHA256")' playerChallangeSignature);                              if (!result)                              {                                  handshakeReponse = HandshakeReply.INVALID_KEY;                                  reason = "Public/private key mismatch";                              }                          }                      }                  }                  else                  {                      try                      {                          File.WriteAllText(storedPlayerFile' playerPublicKey);                          DarkLog.Debug("Client " + playerName + " registered!");                      }                      catch                      {                          handshakeReponse = HandshakeReply.INVALID_PLAYERNAME;                          reason = "Invalid username";                      }                  }              }
Magic Number,DarkMultiPlayerServer.Messages,Handshake,C:\repos\godarklight_DarkMultiPlayer\Server\Messages\Handshake.cs,HandleHandshakeResponse,The following statement contains a magic number: if (handshakeReponse == HandshakeReply.HANDSHOOK_SUCCESSFULLY)              {                  client.authenticated = true;                  string devClientVersion = "";                  DMPPluginHandler.FireOnClientAuthenticated(client);                    if (client.clientVersion.Length == 40)                  {                      devClientVersion = client.clientVersion.Substring(0' 7);                  }                  else                  {                      devClientVersion = client.clientVersion;                  }                  DarkLog.Normal("Client " + playerName + " handshook successfully' version: " + devClientVersion);                    if (!Directory.Exists(Path.Combine(Server.universeDirectory' "Scenarios"' client.playerName)))                  {                      Directory.CreateDirectory(Path.Combine(Server.universeDirectory' "Scenarios"' client.playerName));                      foreach (string file in Directory.GetFiles(Path.Combine(Server.universeDirectory' "Scenarios"' "Initial")))                      {                          File.Copy(file' Path.Combine(Server.universeDirectory' "Scenarios"' playerName' Path.GetFileName(file)));                      }                  }                  SendHandshakeReply(client' handshakeReponse' "success");                  Server.playerCount = ClientHandler.GetActiveClientCount();                  Server.players = ClientHandler.GetActivePlayerNames();                  DarkLog.Debug("Online players is now: " + Server.playerCount + "' connected: " + ClientHandler.GetClients().Length);                }              else              {                  DarkLog.Normal("Client " + playerName + " failed to handshake: " + reason);                  SendHandshakeReply(client' handshakeReponse' reason);              }
Magic Number,DarkMultiPlayerServer.Messages,Handshake,C:\repos\godarklight_DarkMultiPlayer\Server\Messages\Handshake.cs,HandleHandshakeResponse,The following statement contains a magic number: if (handshakeReponse == HandshakeReply.HANDSHOOK_SUCCESSFULLY)              {                  client.authenticated = true;                  string devClientVersion = "";                  DMPPluginHandler.FireOnClientAuthenticated(client);                    if (client.clientVersion.Length == 40)                  {                      devClientVersion = client.clientVersion.Substring(0' 7);                  }                  else                  {                      devClientVersion = client.clientVersion;                  }                  DarkLog.Normal("Client " + playerName + " handshook successfully' version: " + devClientVersion);                    if (!Directory.Exists(Path.Combine(Server.universeDirectory' "Scenarios"' client.playerName)))                  {                      Directory.CreateDirectory(Path.Combine(Server.universeDirectory' "Scenarios"' client.playerName));                      foreach (string file in Directory.GetFiles(Path.Combine(Server.universeDirectory' "Scenarios"' "Initial")))                      {                          File.Copy(file' Path.Combine(Server.universeDirectory' "Scenarios"' playerName' Path.GetFileName(file)));                      }                  }                  SendHandshakeReply(client' handshakeReponse' "success");                  Server.playerCount = ClientHandler.GetActiveClientCount();                  Server.players = ClientHandler.GetActivePlayerNames();                  DarkLog.Debug("Online players is now: " + Server.playerCount + "' connected: " + ClientHandler.GetClients().Length);                }              else              {                  DarkLog.Normal("Client " + playerName + " failed to handshake: " + reason);                  SendHandshakeReply(client' handshakeReponse' reason);              }
Magic Number,DarkMultiPlayerServer.Messages,FlagSync,C:\repos\godarklight_DarkMultiPlayer\Server\Messages\FlagSync.cs,HandleFlagSync,The following statement contains a magic number: using (MessageReader mr = new MessageReader(messageData))              {                  FlagMessageType messageType = (FlagMessageType)mr.Read<int>();                  string playerName = mr.Read<string>();                  if (playerName != client.playerName)                  {                      Messages.ConnectionEnd.SendConnectionEnd(client' "Kicked for sending a flag for another player");                      return;                  }                  switch (messageType)                  {                      case FlagMessageType.LIST:                          {                              //Send the list back                              List<string> serverFlagFileNames = new List<string>();                              List<string> serverFlagOwners = new List<string>();                              List<string> serverFlagShaSums = new List<string>();                                string[] clientFlags = mr.Read<string[]>();                              string[] clientFlagShas = mr.Read<string[]>();                              string[] serverFlags = Directory.GetFiles(flagPath' "*"' SearchOption.AllDirectories);                              foreach (string serverFlag in serverFlags)                              {                                  string trimmedName = Path.GetFileName(serverFlag);                                  string flagOwnerPath = Path.GetDirectoryName(serverFlag);                                  string flagOwner = flagOwnerPath.Substring(Path.GetDirectoryName(flagOwnerPath).Length + 1);                                  bool isMatched = false;                                  bool shaDifferent = false;                                  for (int i = 0; i < clientFlags.Length; i++)                                  {                                      if (clientFlags[i].ToLower() == trimmedName.ToLower())                                      {                                          isMatched = true;                                          shaDifferent = (Common.CalculateSHA256Hash(serverFlag) != clientFlagShas[i]);                                      }                                  }                                  if (!isMatched || shaDifferent)                                  {                                      if (flagOwner == client.playerName)                                      {                                          DarkLog.Debug("Deleting flag " + trimmedName);                                          File.Delete(serverFlag);                                          ServerMessage newMessage = new ServerMessage();                                          newMessage.type = ServerMessageType.FLAG_SYNC;                                          using (MessageWriter mw = new MessageWriter())                                          {                                              mw.Write<int>((int)FlagMessageType.DELETE_FILE);                                              mw.Write<string>(trimmedName);                                              newMessage.data = mw.GetMessageBytes();                                              ClientHandler.SendToAll(client' newMessage' false);                                          }                                          if (Directory.GetFiles(flagOwnerPath).Length == 0)                                          {                                              Directory.Delete(flagOwnerPath);                                          }                                      }                                      else                                      {                                          DarkLog.Debug("Sending flag " + serverFlag + " from " + flagOwner + " to " + client.playerName);                                          ServerMessage newMessage = new ServerMessage();                                          newMessage.type = ServerMessageType.FLAG_SYNC;                                          using (MessageWriter mw = new MessageWriter())                                          {                                              mw.Write<int>((int)FlagMessageType.FLAG_DATA);                                              mw.Write<string>(flagOwner);                                              mw.Write<string>(trimmedName);                                              mw.Write<byte[]>(File.ReadAllBytes(serverFlag));                                              newMessage.data = mw.GetMessageBytes();                                              ClientHandler.SendToClient(client' newMessage' false);                                          }                                      }                                  }                                  //Don't tell the client we have a different copy of the flag so it is reuploaded                                  if (File.Exists(serverFlag))                                  {                                      serverFlagFileNames.Add(trimmedName);                                      serverFlagOwners.Add(flagOwner);                                      serverFlagShaSums.Add(Common.CalculateSHA256Hash(serverFlag));                                  }                              }                              ServerMessage listMessage = new ServerMessage();                              listMessage.type = ServerMessageType.FLAG_SYNC;                              using (MessageWriter mw2 = new MessageWriter())                              {                                  mw2.Write<int>((int)FlagMessageType.LIST);                                  mw2.Write<string[]>(serverFlagFileNames.ToArray());                                  mw2.Write<string[]>(serverFlagOwners.ToArray());                                  mw2.Write<string[]>(serverFlagShaSums.ToArray());                                  listMessage.data = mw2.GetMessageBytes();                              }                              ClientHandler.SendToClient(client' listMessage' false);                          }                          break;                      case FlagMessageType.DELETE_FILE:                          {                              string flagName = mr.Read<string>();                              string playerFlagPath = Path.Combine(flagPath' client.playerName);                              if (Directory.Exists(playerFlagPath))                              {                                  string flagFile = Path.Combine(playerFlagPath' flagName);                                  if (File.Exists(flagFile))                                  {                                      File.Delete(flagFile);                                  }                                  if (Directory.GetFiles(playerFlagPath).Length == 0)                                  {                                      Directory.Delete(playerFlagPath);                                  }                              }                              ServerMessage newMessage = new ServerMessage();                              newMessage.type = ServerMessageType.FLAG_SYNC;                              using (MessageWriter mw = new MessageWriter())                              {                                  mw.Write<int>((int)FlagMessageType.DELETE_FILE);                                  mw.Write<string>(flagName);                                  newMessage.data = mw.GetMessageBytes();                              }                              ClientHandler.SendToAll(client' newMessage' false);                          }                          break;                      case FlagMessageType.UPLOAD_FILE:                          {                              string flagName = mr.Read<string>();                              byte[] flagData = mr.Read<byte[]>();                              // Do not save null files                              if (flagData.Length > 0)                              {                                  // Check if the specified file is a valid PNG file                                  byte[] pngSequence = new byte[] { 137' 80' 78' 71' 13' 10' 26' 10 };                                  if (pngSequence.SequenceEqual(flagData.Take(pngSequence.Length)))                                  {                                      string playerFlagPath = Path.Combine(flagPath' client.playerName);                                        if (!Directory.Exists(playerFlagPath))                                          Directory.CreateDirectory(playerFlagPath);                                        DarkLog.Debug("Saving flag " + flagName + " from " + client.playerName);                                      File.WriteAllBytes(Path.Combine(playerFlagPath' flagName)' flagData);                                        ServerMessage newMessage = new ServerMessage();                                      newMessage.type = ServerMessageType.FLAG_SYNC;                                      using (MessageWriter mw = new MessageWriter())                                      {                                          mw.Write<int>((int)FlagMessageType.FLAG_DATA);                                          mw.Write<string>(client.playerName);                                          mw.Write<string>(flagName);                                          mw.Write<byte[]>(flagData);                                      }                                        ClientHandler.SendToAll(client' newMessage' false);                                  }                              }                          }                          break;                  }              }
Magic Number,DarkMultiPlayerServer.Messages,FlagSync,C:\repos\godarklight_DarkMultiPlayer\Server\Messages\FlagSync.cs,HandleFlagSync,The following statement contains a magic number: using (MessageReader mr = new MessageReader(messageData))              {                  FlagMessageType messageType = (FlagMessageType)mr.Read<int>();                  string playerName = mr.Read<string>();                  if (playerName != client.playerName)                  {                      Messages.ConnectionEnd.SendConnectionEnd(client' "Kicked for sending a flag for another player");                      return;                  }                  switch (messageType)                  {                      case FlagMessageType.LIST:                          {                              //Send the list back                              List<string> serverFlagFileNames = new List<string>();                              List<string> serverFlagOwners = new List<string>();                              List<string> serverFlagShaSums = new List<string>();                                string[] clientFlags = mr.Read<string[]>();                              string[] clientFlagShas = mr.Read<string[]>();                              string[] serverFlags = Directory.GetFiles(flagPath' "*"' SearchOption.AllDirectories);                              foreach (string serverFlag in serverFlags)                              {                                  string trimmedName = Path.GetFileName(serverFlag);                                  string flagOwnerPath = Path.GetDirectoryName(serverFlag);                                  string flagOwner = flagOwnerPath.Substring(Path.GetDirectoryName(flagOwnerPath).Length + 1);                                  bool isMatched = false;                                  bool shaDifferent = false;                                  for (int i = 0; i < clientFlags.Length; i++)                                  {                                      if (clientFlags[i].ToLower() == trimmedName.ToLower())                                      {                                          isMatched = true;                                          shaDifferent = (Common.CalculateSHA256Hash(serverFlag) != clientFlagShas[i]);                                      }                                  }                                  if (!isMatched || shaDifferent)                                  {                                      if (flagOwner == client.playerName)                                      {                                          DarkLog.Debug("Deleting flag " + trimmedName);                                          File.Delete(serverFlag);                                          ServerMessage newMessage = new ServerMessage();                                          newMessage.type = ServerMessageType.FLAG_SYNC;                                          using (MessageWriter mw = new MessageWriter())                                          {                                              mw.Write<int>((int)FlagMessageType.DELETE_FILE);                                              mw.Write<string>(trimmedName);                                              newMessage.data = mw.GetMessageBytes();                                              ClientHandler.SendToAll(client' newMessage' false);                                          }                                          if (Directory.GetFiles(flagOwnerPath).Length == 0)                                          {                                              Directory.Delete(flagOwnerPath);                                          }                                      }                                      else                                      {                                          DarkLog.Debug("Sending flag " + serverFlag + " from " + flagOwner + " to " + client.playerName);                                          ServerMessage newMessage = new ServerMessage();                                          newMessage.type = ServerMessageType.FLAG_SYNC;                                          using (MessageWriter mw = new MessageWriter())                                          {                                              mw.Write<int>((int)FlagMessageType.FLAG_DATA);                                              mw.Write<string>(flagOwner);                                              mw.Write<string>(trimmedName);                                              mw.Write<byte[]>(File.ReadAllBytes(serverFlag));                                              newMessage.data = mw.GetMessageBytes();                                              ClientHandler.SendToClient(client' newMessage' false);                                          }                                      }                                  }                                  //Don't tell the client we have a different copy of the flag so it is reuploaded                                  if (File.Exists(serverFlag))                                  {                                      serverFlagFileNames.Add(trimmedName);                                      serverFlagOwners.Add(flagOwner);                                      serverFlagShaSums.Add(Common.CalculateSHA256Hash(serverFlag));                                  }                              }                              ServerMessage listMessage = new ServerMessage();                              listMessage.type = ServerMessageType.FLAG_SYNC;                              using (MessageWriter mw2 = new MessageWriter())                              {                                  mw2.Write<int>((int)FlagMessageType.LIST);                                  mw2.Write<string[]>(serverFlagFileNames.ToArray());                                  mw2.Write<string[]>(serverFlagOwners.ToArray());                                  mw2.Write<string[]>(serverFlagShaSums.ToArray());                                  listMessage.data = mw2.GetMessageBytes();                              }                              ClientHandler.SendToClient(client' listMessage' false);                          }                          break;                      case FlagMessageType.DELETE_FILE:                          {                              string flagName = mr.Read<string>();                              string playerFlagPath = Path.Combine(flagPath' client.playerName);                              if (Directory.Exists(playerFlagPath))                              {                                  string flagFile = Path.Combine(playerFlagPath' flagName);                                  if (File.Exists(flagFile))                                  {                                      File.Delete(flagFile);                                  }                                  if (Directory.GetFiles(playerFlagPath).Length == 0)                                  {                                      Directory.Delete(playerFlagPath);                                  }                              }                              ServerMessage newMessage = new ServerMessage();                              newMessage.type = ServerMessageType.FLAG_SYNC;                              using (MessageWriter mw = new MessageWriter())                              {                                  mw.Write<int>((int)FlagMessageType.DELETE_FILE);                                  mw.Write<string>(flagName);                                  newMessage.data = mw.GetMessageBytes();                              }                              ClientHandler.SendToAll(client' newMessage' false);                          }                          break;                      case FlagMessageType.UPLOAD_FILE:                          {                              string flagName = mr.Read<string>();                              byte[] flagData = mr.Read<byte[]>();                              // Do not save null files                              if (flagData.Length > 0)                              {                                  // Check if the specified file is a valid PNG file                                  byte[] pngSequence = new byte[] { 137' 80' 78' 71' 13' 10' 26' 10 };                                  if (pngSequence.SequenceEqual(flagData.Take(pngSequence.Length)))                                  {                                      string playerFlagPath = Path.Combine(flagPath' client.playerName);                                        if (!Directory.Exists(playerFlagPath))                                          Directory.CreateDirectory(playerFlagPath);                                        DarkLog.Debug("Saving flag " + flagName + " from " + client.playerName);                                      File.WriteAllBytes(Path.Combine(playerFlagPath' flagName)' flagData);                                        ServerMessage newMessage = new ServerMessage();                                      newMessage.type = ServerMessageType.FLAG_SYNC;                                      using (MessageWriter mw = new MessageWriter())                                      {                                          mw.Write<int>((int)FlagMessageType.FLAG_DATA);                                          mw.Write<string>(client.playerName);                                          mw.Write<string>(flagName);                                          mw.Write<byte[]>(flagData);                                      }                                        ClientHandler.SendToAll(client' newMessage' false);                                  }                              }                          }                          break;                  }              }
Magic Number,DarkMultiPlayerServer.Messages,FlagSync,C:\repos\godarklight_DarkMultiPlayer\Server\Messages\FlagSync.cs,HandleFlagSync,The following statement contains a magic number: using (MessageReader mr = new MessageReader(messageData))              {                  FlagMessageType messageType = (FlagMessageType)mr.Read<int>();                  string playerName = mr.Read<string>();                  if (playerName != client.playerName)                  {                      Messages.ConnectionEnd.SendConnectionEnd(client' "Kicked for sending a flag for another player");                      return;                  }                  switch (messageType)                  {                      case FlagMessageType.LIST:                          {                              //Send the list back                              List<string> serverFlagFileNames = new List<string>();                              List<string> serverFlagOwners = new List<string>();                              List<string> serverFlagShaSums = new List<string>();                                string[] clientFlags = mr.Read<string[]>();                              string[] clientFlagShas = mr.Read<string[]>();                              string[] serverFlags = Directory.GetFiles(flagPath' "*"' SearchOption.AllDirectories);                              foreach (string serverFlag in serverFlags)                              {                                  string trimmedName = Path.GetFileName(serverFlag);                                  string flagOwnerPath = Path.GetDirectoryName(serverFlag);                                  string flagOwner = flagOwnerPath.Substring(Path.GetDirectoryName(flagOwnerPath).Length + 1);                                  bool isMatched = false;                                  bool shaDifferent = false;                                  for (int i = 0; i < clientFlags.Length; i++)                                  {                                      if (clientFlags[i].ToLower() == trimmedName.ToLower())                                      {                                          isMatched = true;                                          shaDifferent = (Common.CalculateSHA256Hash(serverFlag) != clientFlagShas[i]);                                      }                                  }                                  if (!isMatched || shaDifferent)                                  {                                      if (flagOwner == client.playerName)                                      {                                          DarkLog.Debug("Deleting flag " + trimmedName);                                          File.Delete(serverFlag);                                          ServerMessage newMessage = new ServerMessage();                                          newMessage.type = ServerMessageType.FLAG_SYNC;                                          using (MessageWriter mw = new MessageWriter())                                          {                                              mw.Write<int>((int)FlagMessageType.DELETE_FILE);                                              mw.Write<string>(trimmedName);                                              newMessage.data = mw.GetMessageBytes();                                              ClientHandler.SendToAll(client' newMessage' false);                                          }                                          if (Directory.GetFiles(flagOwnerPath).Length == 0)                                          {                                              Directory.Delete(flagOwnerPath);                                          }                                      }                                      else                                      {                                          DarkLog.Debug("Sending flag " + serverFlag + " from " + flagOwner + " to " + client.playerName);                                          ServerMessage newMessage = new ServerMessage();                                          newMessage.type = ServerMessageType.FLAG_SYNC;                                          using (MessageWriter mw = new MessageWriter())                                          {                                              mw.Write<int>((int)FlagMessageType.FLAG_DATA);                                              mw.Write<string>(flagOwner);                                              mw.Write<string>(trimmedName);                                              mw.Write<byte[]>(File.ReadAllBytes(serverFlag));                                              newMessage.data = mw.GetMessageBytes();                                              ClientHandler.SendToClient(client' newMessage' false);                                          }                                      }                                  }                                  //Don't tell the client we have a different copy of the flag so it is reuploaded                                  if (File.Exists(serverFlag))                                  {                                      serverFlagFileNames.Add(trimmedName);                                      serverFlagOwners.Add(flagOwner);                                      serverFlagShaSums.Add(Common.CalculateSHA256Hash(serverFlag));                                  }                              }                              ServerMessage listMessage = new ServerMessage();                              listMessage.type = ServerMessageType.FLAG_SYNC;                              using (MessageWriter mw2 = new MessageWriter())                              {                                  mw2.Write<int>((int)FlagMessageType.LIST);                                  mw2.Write<string[]>(serverFlagFileNames.ToArray());                                  mw2.Write<string[]>(serverFlagOwners.ToArray());                                  mw2.Write<string[]>(serverFlagShaSums.ToArray());                                  listMessage.data = mw2.GetMessageBytes();                              }                              ClientHandler.SendToClient(client' listMessage' false);                          }                          break;                      case FlagMessageType.DELETE_FILE:                          {                              string flagName = mr.Read<string>();                              string playerFlagPath = Path.Combine(flagPath' client.playerName);                              if (Directory.Exists(playerFlagPath))                              {                                  string flagFile = Path.Combine(playerFlagPath' flagName);                                  if (File.Exists(flagFile))                                  {                                      File.Delete(flagFile);                                  }                                  if (Directory.GetFiles(playerFlagPath).Length == 0)                                  {                                      Directory.Delete(playerFlagPath);                                  }                              }                              ServerMessage newMessage = new ServerMessage();                              newMessage.type = ServerMessageType.FLAG_SYNC;                              using (MessageWriter mw = new MessageWriter())                              {                                  mw.Write<int>((int)FlagMessageType.DELETE_FILE);                                  mw.Write<string>(flagName);                                  newMessage.data = mw.GetMessageBytes();                              }                              ClientHandler.SendToAll(client' newMessage' false);                          }                          break;                      case FlagMessageType.UPLOAD_FILE:                          {                              string flagName = mr.Read<string>();                              byte[] flagData = mr.Read<byte[]>();                              // Do not save null files                              if (flagData.Length > 0)                              {                                  // Check if the specified file is a valid PNG file                                  byte[] pngSequence = new byte[] { 137' 80' 78' 71' 13' 10' 26' 10 };                                  if (pngSequence.SequenceEqual(flagData.Take(pngSequence.Length)))                                  {                                      string playerFlagPath = Path.Combine(flagPath' client.playerName);                                        if (!Directory.Exists(playerFlagPath))                                          Directory.CreateDirectory(playerFlagPath);                                        DarkLog.Debug("Saving flag " + flagName + " from " + client.playerName);                                      File.WriteAllBytes(Path.Combine(playerFlagPath' flagName)' flagData);                                        ServerMessage newMessage = new ServerMessage();                                      newMessage.type = ServerMessageType.FLAG_SYNC;                                      using (MessageWriter mw = new MessageWriter())                                      {                                          mw.Write<int>((int)FlagMessageType.FLAG_DATA);                                          mw.Write<string>(client.playerName);                                          mw.Write<string>(flagName);                                          mw.Write<byte[]>(flagData);                                      }                                        ClientHandler.SendToAll(client' newMessage' false);                                  }                              }                          }                          break;                  }              }
Magic Number,DarkMultiPlayerServer.Messages,FlagSync,C:\repos\godarklight_DarkMultiPlayer\Server\Messages\FlagSync.cs,HandleFlagSync,The following statement contains a magic number: using (MessageReader mr = new MessageReader(messageData))              {                  FlagMessageType messageType = (FlagMessageType)mr.Read<int>();                  string playerName = mr.Read<string>();                  if (playerName != client.playerName)                  {                      Messages.ConnectionEnd.SendConnectionEnd(client' "Kicked for sending a flag for another player");                      return;                  }                  switch (messageType)                  {                      case FlagMessageType.LIST:                          {                              //Send the list back                              List<string> serverFlagFileNames = new List<string>();                              List<string> serverFlagOwners = new List<string>();                              List<string> serverFlagShaSums = new List<string>();                                string[] clientFlags = mr.Read<string[]>();                              string[] clientFlagShas = mr.Read<string[]>();                              string[] serverFlags = Directory.GetFiles(flagPath' "*"' SearchOption.AllDirectories);                              foreach (string serverFlag in serverFlags)                              {                                  string trimmedName = Path.GetFileName(serverFlag);                                  string flagOwnerPath = Path.GetDirectoryName(serverFlag);                                  string flagOwner = flagOwnerPath.Substring(Path.GetDirectoryName(flagOwnerPath).Length + 1);                                  bool isMatched = false;                                  bool shaDifferent = false;                                  for (int i = 0; i < clientFlags.Length; i++)                                  {                                      if (clientFlags[i].ToLower() == trimmedName.ToLower())                                      {                                          isMatched = true;                                          shaDifferent = (Common.CalculateSHA256Hash(serverFlag) != clientFlagShas[i]);                                      }                                  }                                  if (!isMatched || shaDifferent)                                  {                                      if (flagOwner == client.playerName)                                      {                                          DarkLog.Debug("Deleting flag " + trimmedName);                                          File.Delete(serverFlag);                                          ServerMessage newMessage = new ServerMessage();                                          newMessage.type = ServerMessageType.FLAG_SYNC;                                          using (MessageWriter mw = new MessageWriter())                                          {                                              mw.Write<int>((int)FlagMessageType.DELETE_FILE);                                              mw.Write<string>(trimmedName);                                              newMessage.data = mw.GetMessageBytes();                                              ClientHandler.SendToAll(client' newMessage' false);                                          }                                          if (Directory.GetFiles(flagOwnerPath).Length == 0)                                          {                                              Directory.Delete(flagOwnerPath);                                          }                                      }                                      else                                      {                                          DarkLog.Debug("Sending flag " + serverFlag + " from " + flagOwner + " to " + client.playerName);                                          ServerMessage newMessage = new ServerMessage();                                          newMessage.type = ServerMessageType.FLAG_SYNC;                                          using (MessageWriter mw = new MessageWriter())                                          {                                              mw.Write<int>((int)FlagMessageType.FLAG_DATA);                                              mw.Write<string>(flagOwner);                                              mw.Write<string>(trimmedName);                                              mw.Write<byte[]>(File.ReadAllBytes(serverFlag));                                              newMessage.data = mw.GetMessageBytes();                                              ClientHandler.SendToClient(client' newMessage' false);                                          }                                      }                                  }                                  //Don't tell the client we have a different copy of the flag so it is reuploaded                                  if (File.Exists(serverFlag))                                  {                                      serverFlagFileNames.Add(trimmedName);                                      serverFlagOwners.Add(flagOwner);                                      serverFlagShaSums.Add(Common.CalculateSHA256Hash(serverFlag));                                  }                              }                              ServerMessage listMessage = new ServerMessage();                              listMessage.type = ServerMessageType.FLAG_SYNC;                              using (MessageWriter mw2 = new MessageWriter())                              {                                  mw2.Write<int>((int)FlagMessageType.LIST);                                  mw2.Write<string[]>(serverFlagFileNames.ToArray());                                  mw2.Write<string[]>(serverFlagOwners.ToArray());                                  mw2.Write<string[]>(serverFlagShaSums.ToArray());                                  listMessage.data = mw2.GetMessageBytes();                              }                              ClientHandler.SendToClient(client' listMessage' false);                          }                          break;                      case FlagMessageType.DELETE_FILE:                          {                              string flagName = mr.Read<string>();                              string playerFlagPath = Path.Combine(flagPath' client.playerName);                              if (Directory.Exists(playerFlagPath))                              {                                  string flagFile = Path.Combine(playerFlagPath' flagName);                                  if (File.Exists(flagFile))                                  {                                      File.Delete(flagFile);                                  }                                  if (Directory.GetFiles(playerFlagPath).Length == 0)                                  {                                      Directory.Delete(playerFlagPath);                                  }                              }                              ServerMessage newMessage = new ServerMessage();                              newMessage.type = ServerMessageType.FLAG_SYNC;                              using (MessageWriter mw = new MessageWriter())                              {                                  mw.Write<int>((int)FlagMessageType.DELETE_FILE);                                  mw.Write<string>(flagName);                                  newMessage.data = mw.GetMessageBytes();                              }                              ClientHandler.SendToAll(client' newMessage' false);                          }                          break;                      case FlagMessageType.UPLOAD_FILE:                          {                              string flagName = mr.Read<string>();                              byte[] flagData = mr.Read<byte[]>();                              // Do not save null files                              if (flagData.Length > 0)                              {                                  // Check if the specified file is a valid PNG file                                  byte[] pngSequence = new byte[] { 137' 80' 78' 71' 13' 10' 26' 10 };                                  if (pngSequence.SequenceEqual(flagData.Take(pngSequence.Length)))                                  {                                      string playerFlagPath = Path.Combine(flagPath' client.playerName);                                        if (!Directory.Exists(playerFlagPath))                                          Directory.CreateDirectory(playerFlagPath);                                        DarkLog.Debug("Saving flag " + flagName + " from " + client.playerName);                                      File.WriteAllBytes(Path.Combine(playerFlagPath' flagName)' flagData);                                        ServerMessage newMessage = new ServerMessage();                                      newMessage.type = ServerMessageType.FLAG_SYNC;                                      using (MessageWriter mw = new MessageWriter())                                      {                                          mw.Write<int>((int)FlagMessageType.FLAG_DATA);                                          mw.Write<string>(client.playerName);                                          mw.Write<string>(flagName);                                          mw.Write<byte[]>(flagData);                                      }                                        ClientHandler.SendToAll(client' newMessage' false);                                  }                              }                          }                          break;                  }              }
Magic Number,DarkMultiPlayerServer.Messages,FlagSync,C:\repos\godarklight_DarkMultiPlayer\Server\Messages\FlagSync.cs,HandleFlagSync,The following statement contains a magic number: using (MessageReader mr = new MessageReader(messageData))              {                  FlagMessageType messageType = (FlagMessageType)mr.Read<int>();                  string playerName = mr.Read<string>();                  if (playerName != client.playerName)                  {                      Messages.ConnectionEnd.SendConnectionEnd(client' "Kicked for sending a flag for another player");                      return;                  }                  switch (messageType)                  {                      case FlagMessageType.LIST:                          {                              //Send the list back                              List<string> serverFlagFileNames = new List<string>();                              List<string> serverFlagOwners = new List<string>();                              List<string> serverFlagShaSums = new List<string>();                                string[] clientFlags = mr.Read<string[]>();                              string[] clientFlagShas = mr.Read<string[]>();                              string[] serverFlags = Directory.GetFiles(flagPath' "*"' SearchOption.AllDirectories);                              foreach (string serverFlag in serverFlags)                              {                                  string trimmedName = Path.GetFileName(serverFlag);                                  string flagOwnerPath = Path.GetDirectoryName(serverFlag);                                  string flagOwner = flagOwnerPath.Substring(Path.GetDirectoryName(flagOwnerPath).Length + 1);                                  bool isMatched = false;                                  bool shaDifferent = false;                                  for (int i = 0; i < clientFlags.Length; i++)                                  {                                      if (clientFlags[i].ToLower() == trimmedName.ToLower())                                      {                                          isMatched = true;                                          shaDifferent = (Common.CalculateSHA256Hash(serverFlag) != clientFlagShas[i]);                                      }                                  }                                  if (!isMatched || shaDifferent)                                  {                                      if (flagOwner == client.playerName)                                      {                                          DarkLog.Debug("Deleting flag " + trimmedName);                                          File.Delete(serverFlag);                                          ServerMessage newMessage = new ServerMessage();                                          newMessage.type = ServerMessageType.FLAG_SYNC;                                          using (MessageWriter mw = new MessageWriter())                                          {                                              mw.Write<int>((int)FlagMessageType.DELETE_FILE);                                              mw.Write<string>(trimmedName);                                              newMessage.data = mw.GetMessageBytes();                                              ClientHandler.SendToAll(client' newMessage' false);                                          }                                          if (Directory.GetFiles(flagOwnerPath).Length == 0)                                          {                                              Directory.Delete(flagOwnerPath);                                          }                                      }                                      else                                      {                                          DarkLog.Debug("Sending flag " + serverFlag + " from " + flagOwner + " to " + client.playerName);                                          ServerMessage newMessage = new ServerMessage();                                          newMessage.type = ServerMessageType.FLAG_SYNC;                                          using (MessageWriter mw = new MessageWriter())                                          {                                              mw.Write<int>((int)FlagMessageType.FLAG_DATA);                                              mw.Write<string>(flagOwner);                                              mw.Write<string>(trimmedName);                                              mw.Write<byte[]>(File.ReadAllBytes(serverFlag));                                              newMessage.data = mw.GetMessageBytes();                                              ClientHandler.SendToClient(client' newMessage' false);                                          }                                      }                                  }                                  //Don't tell the client we have a different copy of the flag so it is reuploaded                                  if (File.Exists(serverFlag))                                  {                                      serverFlagFileNames.Add(trimmedName);                                      serverFlagOwners.Add(flagOwner);                                      serverFlagShaSums.Add(Common.CalculateSHA256Hash(serverFlag));                                  }                              }                              ServerMessage listMessage = new ServerMessage();                              listMessage.type = ServerMessageType.FLAG_SYNC;                              using (MessageWriter mw2 = new MessageWriter())                              {                                  mw2.Write<int>((int)FlagMessageType.LIST);                                  mw2.Write<string[]>(serverFlagFileNames.ToArray());                                  mw2.Write<string[]>(serverFlagOwners.ToArray());                                  mw2.Write<string[]>(serverFlagShaSums.ToArray());                                  listMessage.data = mw2.GetMessageBytes();                              }                              ClientHandler.SendToClient(client' listMessage' false);                          }                          break;                      case FlagMessageType.DELETE_FILE:                          {                              string flagName = mr.Read<string>();                              string playerFlagPath = Path.Combine(flagPath' client.playerName);                              if (Directory.Exists(playerFlagPath))                              {                                  string flagFile = Path.Combine(playerFlagPath' flagName);                                  if (File.Exists(flagFile))                                  {                                      File.Delete(flagFile);                                  }                                  if (Directory.GetFiles(playerFlagPath).Length == 0)                                  {                                      Directory.Delete(playerFlagPath);                                  }                              }                              ServerMessage newMessage = new ServerMessage();                              newMessage.type = ServerMessageType.FLAG_SYNC;                              using (MessageWriter mw = new MessageWriter())                              {                                  mw.Write<int>((int)FlagMessageType.DELETE_FILE);                                  mw.Write<string>(flagName);                                  newMessage.data = mw.GetMessageBytes();                              }                              ClientHandler.SendToAll(client' newMessage' false);                          }                          break;                      case FlagMessageType.UPLOAD_FILE:                          {                              string flagName = mr.Read<string>();                              byte[] flagData = mr.Read<byte[]>();                              // Do not save null files                              if (flagData.Length > 0)                              {                                  // Check if the specified file is a valid PNG file                                  byte[] pngSequence = new byte[] { 137' 80' 78' 71' 13' 10' 26' 10 };                                  if (pngSequence.SequenceEqual(flagData.Take(pngSequence.Length)))                                  {                                      string playerFlagPath = Path.Combine(flagPath' client.playerName);                                        if (!Directory.Exists(playerFlagPath))                                          Directory.CreateDirectory(playerFlagPath);                                        DarkLog.Debug("Saving flag " + flagName + " from " + client.playerName);                                      File.WriteAllBytes(Path.Combine(playerFlagPath' flagName)' flagData);                                        ServerMessage newMessage = new ServerMessage();                                      newMessage.type = ServerMessageType.FLAG_SYNC;                                      using (MessageWriter mw = new MessageWriter())                                      {                                          mw.Write<int>((int)FlagMessageType.FLAG_DATA);                                          mw.Write<string>(client.playerName);                                          mw.Write<string>(flagName);                                          mw.Write<byte[]>(flagData);                                      }                                        ClientHandler.SendToAll(client' newMessage' false);                                  }                              }                          }                          break;                  }              }
Magic Number,DarkMultiPlayerServer.Messages,FlagSync,C:\repos\godarklight_DarkMultiPlayer\Server\Messages\FlagSync.cs,HandleFlagSync,The following statement contains a magic number: using (MessageReader mr = new MessageReader(messageData))              {                  FlagMessageType messageType = (FlagMessageType)mr.Read<int>();                  string playerName = mr.Read<string>();                  if (playerName != client.playerName)                  {                      Messages.ConnectionEnd.SendConnectionEnd(client' "Kicked for sending a flag for another player");                      return;                  }                  switch (messageType)                  {                      case FlagMessageType.LIST:                          {                              //Send the list back                              List<string> serverFlagFileNames = new List<string>();                              List<string> serverFlagOwners = new List<string>();                              List<string> serverFlagShaSums = new List<string>();                                string[] clientFlags = mr.Read<string[]>();                              string[] clientFlagShas = mr.Read<string[]>();                              string[] serverFlags = Directory.GetFiles(flagPath' "*"' SearchOption.AllDirectories);                              foreach (string serverFlag in serverFlags)                              {                                  string trimmedName = Path.GetFileName(serverFlag);                                  string flagOwnerPath = Path.GetDirectoryName(serverFlag);                                  string flagOwner = flagOwnerPath.Substring(Path.GetDirectoryName(flagOwnerPath).Length + 1);                                  bool isMatched = false;                                  bool shaDifferent = false;                                  for (int i = 0; i < clientFlags.Length; i++)                                  {                                      if (clientFlags[i].ToLower() == trimmedName.ToLower())                                      {                                          isMatched = true;                                          shaDifferent = (Common.CalculateSHA256Hash(serverFlag) != clientFlagShas[i]);                                      }                                  }                                  if (!isMatched || shaDifferent)                                  {                                      if (flagOwner == client.playerName)                                      {                                          DarkLog.Debug("Deleting flag " + trimmedName);                                          File.Delete(serverFlag);                                          ServerMessage newMessage = new ServerMessage();                                          newMessage.type = ServerMessageType.FLAG_SYNC;                                          using (MessageWriter mw = new MessageWriter())                                          {                                              mw.Write<int>((int)FlagMessageType.DELETE_FILE);                                              mw.Write<string>(trimmedName);                                              newMessage.data = mw.GetMessageBytes();                                              ClientHandler.SendToAll(client' newMessage' false);                                          }                                          if (Directory.GetFiles(flagOwnerPath).Length == 0)                                          {                                              Directory.Delete(flagOwnerPath);                                          }                                      }                                      else                                      {                                          DarkLog.Debug("Sending flag " + serverFlag + " from " + flagOwner + " to " + client.playerName);                                          ServerMessage newMessage = new ServerMessage();                                          newMessage.type = ServerMessageType.FLAG_SYNC;                                          using (MessageWriter mw = new MessageWriter())                                          {                                              mw.Write<int>((int)FlagMessageType.FLAG_DATA);                                              mw.Write<string>(flagOwner);                                              mw.Write<string>(trimmedName);                                              mw.Write<byte[]>(File.ReadAllBytes(serverFlag));                                              newMessage.data = mw.GetMessageBytes();                                              ClientHandler.SendToClient(client' newMessage' false);                                          }                                      }                                  }                                  //Don't tell the client we have a different copy of the flag so it is reuploaded                                  if (File.Exists(serverFlag))                                  {                                      serverFlagFileNames.Add(trimmedName);                                      serverFlagOwners.Add(flagOwner);                                      serverFlagShaSums.Add(Common.CalculateSHA256Hash(serverFlag));                                  }                              }                              ServerMessage listMessage = new ServerMessage();                              listMessage.type = ServerMessageType.FLAG_SYNC;                              using (MessageWriter mw2 = new MessageWriter())                              {                                  mw2.Write<int>((int)FlagMessageType.LIST);                                  mw2.Write<string[]>(serverFlagFileNames.ToArray());                                  mw2.Write<string[]>(serverFlagOwners.ToArray());                                  mw2.Write<string[]>(serverFlagShaSums.ToArray());                                  listMessage.data = mw2.GetMessageBytes();                              }                              ClientHandler.SendToClient(client' listMessage' false);                          }                          break;                      case FlagMessageType.DELETE_FILE:                          {                              string flagName = mr.Read<string>();                              string playerFlagPath = Path.Combine(flagPath' client.playerName);                              if (Directory.Exists(playerFlagPath))                              {                                  string flagFile = Path.Combine(playerFlagPath' flagName);                                  if (File.Exists(flagFile))                                  {                                      File.Delete(flagFile);                                  }                                  if (Directory.GetFiles(playerFlagPath).Length == 0)                                  {                                      Directory.Delete(playerFlagPath);                                  }                              }                              ServerMessage newMessage = new ServerMessage();                              newMessage.type = ServerMessageType.FLAG_SYNC;                              using (MessageWriter mw = new MessageWriter())                              {                                  mw.Write<int>((int)FlagMessageType.DELETE_FILE);                                  mw.Write<string>(flagName);                                  newMessage.data = mw.GetMessageBytes();                              }                              ClientHandler.SendToAll(client' newMessage' false);                          }                          break;                      case FlagMessageType.UPLOAD_FILE:                          {                              string flagName = mr.Read<string>();                              byte[] flagData = mr.Read<byte[]>();                              // Do not save null files                              if (flagData.Length > 0)                              {                                  // Check if the specified file is a valid PNG file                                  byte[] pngSequence = new byte[] { 137' 80' 78' 71' 13' 10' 26' 10 };                                  if (pngSequence.SequenceEqual(flagData.Take(pngSequence.Length)))                                  {                                      string playerFlagPath = Path.Combine(flagPath' client.playerName);                                        if (!Directory.Exists(playerFlagPath))                                          Directory.CreateDirectory(playerFlagPath);                                        DarkLog.Debug("Saving flag " + flagName + " from " + client.playerName);                                      File.WriteAllBytes(Path.Combine(playerFlagPath' flagName)' flagData);                                        ServerMessage newMessage = new ServerMessage();                                      newMessage.type = ServerMessageType.FLAG_SYNC;                                      using (MessageWriter mw = new MessageWriter())                                      {                                          mw.Write<int>((int)FlagMessageType.FLAG_DATA);                                          mw.Write<string>(client.playerName);                                          mw.Write<string>(flagName);                                          mw.Write<byte[]>(flagData);                                      }                                        ClientHandler.SendToAll(client' newMessage' false);                                  }                              }                          }                          break;                  }              }
Magic Number,DarkMultiPlayerServer.Messages,FlagSync,C:\repos\godarklight_DarkMultiPlayer\Server\Messages\FlagSync.cs,HandleFlagSync,The following statement contains a magic number: using (MessageReader mr = new MessageReader(messageData))              {                  FlagMessageType messageType = (FlagMessageType)mr.Read<int>();                  string playerName = mr.Read<string>();                  if (playerName != client.playerName)                  {                      Messages.ConnectionEnd.SendConnectionEnd(client' "Kicked for sending a flag for another player");                      return;                  }                  switch (messageType)                  {                      case FlagMessageType.LIST:                          {                              //Send the list back                              List<string> serverFlagFileNames = new List<string>();                              List<string> serverFlagOwners = new List<string>();                              List<string> serverFlagShaSums = new List<string>();                                string[] clientFlags = mr.Read<string[]>();                              string[] clientFlagShas = mr.Read<string[]>();                              string[] serverFlags = Directory.GetFiles(flagPath' "*"' SearchOption.AllDirectories);                              foreach (string serverFlag in serverFlags)                              {                                  string trimmedName = Path.GetFileName(serverFlag);                                  string flagOwnerPath = Path.GetDirectoryName(serverFlag);                                  string flagOwner = flagOwnerPath.Substring(Path.GetDirectoryName(flagOwnerPath).Length + 1);                                  bool isMatched = false;                                  bool shaDifferent = false;                                  for (int i = 0; i < clientFlags.Length; i++)                                  {                                      if (clientFlags[i].ToLower() == trimmedName.ToLower())                                      {                                          isMatched = true;                                          shaDifferent = (Common.CalculateSHA256Hash(serverFlag) != clientFlagShas[i]);                                      }                                  }                                  if (!isMatched || shaDifferent)                                  {                                      if (flagOwner == client.playerName)                                      {                                          DarkLog.Debug("Deleting flag " + trimmedName);                                          File.Delete(serverFlag);                                          ServerMessage newMessage = new ServerMessage();                                          newMessage.type = ServerMessageType.FLAG_SYNC;                                          using (MessageWriter mw = new MessageWriter())                                          {                                              mw.Write<int>((int)FlagMessageType.DELETE_FILE);                                              mw.Write<string>(trimmedName);                                              newMessage.data = mw.GetMessageBytes();                                              ClientHandler.SendToAll(client' newMessage' false);                                          }                                          if (Directory.GetFiles(flagOwnerPath).Length == 0)                                          {                                              Directory.Delete(flagOwnerPath);                                          }                                      }                                      else                                      {                                          DarkLog.Debug("Sending flag " + serverFlag + " from " + flagOwner + " to " + client.playerName);                                          ServerMessage newMessage = new ServerMessage();                                          newMessage.type = ServerMessageType.FLAG_SYNC;                                          using (MessageWriter mw = new MessageWriter())                                          {                                              mw.Write<int>((int)FlagMessageType.FLAG_DATA);                                              mw.Write<string>(flagOwner);                                              mw.Write<string>(trimmedName);                                              mw.Write<byte[]>(File.ReadAllBytes(serverFlag));                                              newMessage.data = mw.GetMessageBytes();                                              ClientHandler.SendToClient(client' newMessage' false);                                          }                                      }                                  }                                  //Don't tell the client we have a different copy of the flag so it is reuploaded                                  if (File.Exists(serverFlag))                                  {                                      serverFlagFileNames.Add(trimmedName);                                      serverFlagOwners.Add(flagOwner);                                      serverFlagShaSums.Add(Common.CalculateSHA256Hash(serverFlag));                                  }                              }                              ServerMessage listMessage = new ServerMessage();                              listMessage.type = ServerMessageType.FLAG_SYNC;                              using (MessageWriter mw2 = new MessageWriter())                              {                                  mw2.Write<int>((int)FlagMessageType.LIST);                                  mw2.Write<string[]>(serverFlagFileNames.ToArray());                                  mw2.Write<string[]>(serverFlagOwners.ToArray());                                  mw2.Write<string[]>(serverFlagShaSums.ToArray());                                  listMessage.data = mw2.GetMessageBytes();                              }                              ClientHandler.SendToClient(client' listMessage' false);                          }                          break;                      case FlagMessageType.DELETE_FILE:                          {                              string flagName = mr.Read<string>();                              string playerFlagPath = Path.Combine(flagPath' client.playerName);                              if (Directory.Exists(playerFlagPath))                              {                                  string flagFile = Path.Combine(playerFlagPath' flagName);                                  if (File.Exists(flagFile))                                  {                                      File.Delete(flagFile);                                  }                                  if (Directory.GetFiles(playerFlagPath).Length == 0)                                  {                                      Directory.Delete(playerFlagPath);                                  }                              }                              ServerMessage newMessage = new ServerMessage();                              newMessage.type = ServerMessageType.FLAG_SYNC;                              using (MessageWriter mw = new MessageWriter())                              {                                  mw.Write<int>((int)FlagMessageType.DELETE_FILE);                                  mw.Write<string>(flagName);                                  newMessage.data = mw.GetMessageBytes();                              }                              ClientHandler.SendToAll(client' newMessage' false);                          }                          break;                      case FlagMessageType.UPLOAD_FILE:                          {                              string flagName = mr.Read<string>();                              byte[] flagData = mr.Read<byte[]>();                              // Do not save null files                              if (flagData.Length > 0)                              {                                  // Check if the specified file is a valid PNG file                                  byte[] pngSequence = new byte[] { 137' 80' 78' 71' 13' 10' 26' 10 };                                  if (pngSequence.SequenceEqual(flagData.Take(pngSequence.Length)))                                  {                                      string playerFlagPath = Path.Combine(flagPath' client.playerName);                                        if (!Directory.Exists(playerFlagPath))                                          Directory.CreateDirectory(playerFlagPath);                                        DarkLog.Debug("Saving flag " + flagName + " from " + client.playerName);                                      File.WriteAllBytes(Path.Combine(playerFlagPath' flagName)' flagData);                                        ServerMessage newMessage = new ServerMessage();                                      newMessage.type = ServerMessageType.FLAG_SYNC;                                      using (MessageWriter mw = new MessageWriter())                                      {                                          mw.Write<int>((int)FlagMessageType.FLAG_DATA);                                          mw.Write<string>(client.playerName);                                          mw.Write<string>(flagName);                                          mw.Write<byte[]>(flagData);                                      }                                        ClientHandler.SendToAll(client' newMessage' false);                                  }                              }                          }                          break;                  }              }
Magic Number,DarkMultiPlayerServer.Messages,FlagSync,C:\repos\godarklight_DarkMultiPlayer\Server\Messages\FlagSync.cs,HandleFlagSync,The following statement contains a magic number: using (MessageReader mr = new MessageReader(messageData))              {                  FlagMessageType messageType = (FlagMessageType)mr.Read<int>();                  string playerName = mr.Read<string>();                  if (playerName != client.playerName)                  {                      Messages.ConnectionEnd.SendConnectionEnd(client' "Kicked for sending a flag for another player");                      return;                  }                  switch (messageType)                  {                      case FlagMessageType.LIST:                          {                              //Send the list back                              List<string> serverFlagFileNames = new List<string>();                              List<string> serverFlagOwners = new List<string>();                              List<string> serverFlagShaSums = new List<string>();                                string[] clientFlags = mr.Read<string[]>();                              string[] clientFlagShas = mr.Read<string[]>();                              string[] serverFlags = Directory.GetFiles(flagPath' "*"' SearchOption.AllDirectories);                              foreach (string serverFlag in serverFlags)                              {                                  string trimmedName = Path.GetFileName(serverFlag);                                  string flagOwnerPath = Path.GetDirectoryName(serverFlag);                                  string flagOwner = flagOwnerPath.Substring(Path.GetDirectoryName(flagOwnerPath).Length + 1);                                  bool isMatched = false;                                  bool shaDifferent = false;                                  for (int i = 0; i < clientFlags.Length; i++)                                  {                                      if (clientFlags[i].ToLower() == trimmedName.ToLower())                                      {                                          isMatched = true;                                          shaDifferent = (Common.CalculateSHA256Hash(serverFlag) != clientFlagShas[i]);                                      }                                  }                                  if (!isMatched || shaDifferent)                                  {                                      if (flagOwner == client.playerName)                                      {                                          DarkLog.Debug("Deleting flag " + trimmedName);                                          File.Delete(serverFlag);                                          ServerMessage newMessage = new ServerMessage();                                          newMessage.type = ServerMessageType.FLAG_SYNC;                                          using (MessageWriter mw = new MessageWriter())                                          {                                              mw.Write<int>((int)FlagMessageType.DELETE_FILE);                                              mw.Write<string>(trimmedName);                                              newMessage.data = mw.GetMessageBytes();                                              ClientHandler.SendToAll(client' newMessage' false);                                          }                                          if (Directory.GetFiles(flagOwnerPath).Length == 0)                                          {                                              Directory.Delete(flagOwnerPath);                                          }                                      }                                      else                                      {                                          DarkLog.Debug("Sending flag " + serverFlag + " from " + flagOwner + " to " + client.playerName);                                          ServerMessage newMessage = new ServerMessage();                                          newMessage.type = ServerMessageType.FLAG_SYNC;                                          using (MessageWriter mw = new MessageWriter())                                          {                                              mw.Write<int>((int)FlagMessageType.FLAG_DATA);                                              mw.Write<string>(flagOwner);                                              mw.Write<string>(trimmedName);                                              mw.Write<byte[]>(File.ReadAllBytes(serverFlag));                                              newMessage.data = mw.GetMessageBytes();                                              ClientHandler.SendToClient(client' newMessage' false);                                          }                                      }                                  }                                  //Don't tell the client we have a different copy of the flag so it is reuploaded                                  if (File.Exists(serverFlag))                                  {                                      serverFlagFileNames.Add(trimmedName);                                      serverFlagOwners.Add(flagOwner);                                      serverFlagShaSums.Add(Common.CalculateSHA256Hash(serverFlag));                                  }                              }                              ServerMessage listMessage = new ServerMessage();                              listMessage.type = ServerMessageType.FLAG_SYNC;                              using (MessageWriter mw2 = new MessageWriter())                              {                                  mw2.Write<int>((int)FlagMessageType.LIST);                                  mw2.Write<string[]>(serverFlagFileNames.ToArray());                                  mw2.Write<string[]>(serverFlagOwners.ToArray());                                  mw2.Write<string[]>(serverFlagShaSums.ToArray());                                  listMessage.data = mw2.GetMessageBytes();                              }                              ClientHandler.SendToClient(client' listMessage' false);                          }                          break;                      case FlagMessageType.DELETE_FILE:                          {                              string flagName = mr.Read<string>();                              string playerFlagPath = Path.Combine(flagPath' client.playerName);                              if (Directory.Exists(playerFlagPath))                              {                                  string flagFile = Path.Combine(playerFlagPath' flagName);                                  if (File.Exists(flagFile))                                  {                                      File.Delete(flagFile);                                  }                                  if (Directory.GetFiles(playerFlagPath).Length == 0)                                  {                                      Directory.Delete(playerFlagPath);                                  }                              }                              ServerMessage newMessage = new ServerMessage();                              newMessage.type = ServerMessageType.FLAG_SYNC;                              using (MessageWriter mw = new MessageWriter())                              {                                  mw.Write<int>((int)FlagMessageType.DELETE_FILE);                                  mw.Write<string>(flagName);                                  newMessage.data = mw.GetMessageBytes();                              }                              ClientHandler.SendToAll(client' newMessage' false);                          }                          break;                      case FlagMessageType.UPLOAD_FILE:                          {                              string flagName = mr.Read<string>();                              byte[] flagData = mr.Read<byte[]>();                              // Do not save null files                              if (flagData.Length > 0)                              {                                  // Check if the specified file is a valid PNG file                                  byte[] pngSequence = new byte[] { 137' 80' 78' 71' 13' 10' 26' 10 };                                  if (pngSequence.SequenceEqual(flagData.Take(pngSequence.Length)))                                  {                                      string playerFlagPath = Path.Combine(flagPath' client.playerName);                                        if (!Directory.Exists(playerFlagPath))                                          Directory.CreateDirectory(playerFlagPath);                                        DarkLog.Debug("Saving flag " + flagName + " from " + client.playerName);                                      File.WriteAllBytes(Path.Combine(playerFlagPath' flagName)' flagData);                                        ServerMessage newMessage = new ServerMessage();                                      newMessage.type = ServerMessageType.FLAG_SYNC;                                      using (MessageWriter mw = new MessageWriter())                                      {                                          mw.Write<int>((int)FlagMessageType.FLAG_DATA);                                          mw.Write<string>(client.playerName);                                          mw.Write<string>(flagName);                                          mw.Write<byte[]>(flagData);                                      }                                        ClientHandler.SendToAll(client' newMessage' false);                                  }                              }                          }                          break;                  }              }
Magic Number,DarkMultiPlayerServer.Messages,WarpControl,C:\repos\godarklight_DarkMultiPlayer\Server\Messages\WarpControl.cs,HandleRequestController,The following statement contains a magic number: lock (mcwLock)              {                  if (Settings.settingsStore.warpMode == WarpMode.MCW_FORCE)                  {                      if (warpMaster == null)                      {                          warpMaster = client.playerName;                          warpTimeout = DateTime.UtcNow.Ticks + (long)(MAX_WARP_TIME * 10000000);                          SendSetController(client.playerName' warpTimeout);                      }                  }                  if (Settings.settingsStore.warpMode == WarpMode.MCW_VOTE)                  {                      if (voteMaster == null)                      {                          if (Server.playerCount == 1)                          {                              warpMaster = client.playerName;                              warpTimeout = DateTime.UtcNow.Ticks + (long)(MAX_WARP_TIME * 10000000);                              SendSetController(client.playerName' warpTimeout);                          }                          else                          {                              voteList = new Dictionary<string' bool>();                              voteMaster = client.playerName;                              voteTimeout = DateTime.UtcNow.Ticks + (long)(MAX_VOTE_TIME * 10000000);                              SendRequestVote(client.playerName' voteTimeout);                          }                      }                  }              }
Magic Number,DarkMultiPlayerServer.Messages,WarpControl,C:\repos\godarklight_DarkMultiPlayer\Server\Messages\WarpControl.cs,HandleRequestController,The following statement contains a magic number: lock (mcwLock)              {                  if (Settings.settingsStore.warpMode == WarpMode.MCW_FORCE)                  {                      if (warpMaster == null)                      {                          warpMaster = client.playerName;                          warpTimeout = DateTime.UtcNow.Ticks + (long)(MAX_WARP_TIME * 10000000);                          SendSetController(client.playerName' warpTimeout);                      }                  }                  if (Settings.settingsStore.warpMode == WarpMode.MCW_VOTE)                  {                      if (voteMaster == null)                      {                          if (Server.playerCount == 1)                          {                              warpMaster = client.playerName;                              warpTimeout = DateTime.UtcNow.Ticks + (long)(MAX_WARP_TIME * 10000000);                              SendSetController(client.playerName' warpTimeout);                          }                          else                          {                              voteList = new Dictionary<string' bool>();                              voteMaster = client.playerName;                              voteTimeout = DateTime.UtcNow.Ticks + (long)(MAX_VOTE_TIME * 10000000);                              SendRequestVote(client.playerName' voteTimeout);                          }                      }                  }              }
Magic Number,DarkMultiPlayerServer.Messages,WarpControl,C:\repos\godarklight_DarkMultiPlayer\Server\Messages\WarpControl.cs,HandleRequestController,The following statement contains a magic number: lock (mcwLock)              {                  if (Settings.settingsStore.warpMode == WarpMode.MCW_FORCE)                  {                      if (warpMaster == null)                      {                          warpMaster = client.playerName;                          warpTimeout = DateTime.UtcNow.Ticks + (long)(MAX_WARP_TIME * 10000000);                          SendSetController(client.playerName' warpTimeout);                      }                  }                  if (Settings.settingsStore.warpMode == WarpMode.MCW_VOTE)                  {                      if (voteMaster == null)                      {                          if (Server.playerCount == 1)                          {                              warpMaster = client.playerName;                              warpTimeout = DateTime.UtcNow.Ticks + (long)(MAX_WARP_TIME * 10000000);                              SendSetController(client.playerName' warpTimeout);                          }                          else                          {                              voteList = new Dictionary<string' bool>();                              voteMaster = client.playerName;                              voteTimeout = DateTime.UtcNow.Ticks + (long)(MAX_VOTE_TIME * 10000000);                              SendRequestVote(client.playerName' voteTimeout);                          }                      }                  }              }
Magic Number,DarkMultiPlayerServer.Messages,WarpControl,C:\repos\godarklight_DarkMultiPlayer\Server\Messages\WarpControl.cs,HandleReplyVote,The following statement contains a magic number: lock (mcwLock)              {                  voteList[client.playerName] = voteReply;                  int voteYesCount = 0;                  int voteNoCount = 0;                  foreach (bool vote in voteList.Values)                  {                      if (vote)                      {                          voteYesCount++;                      }                      else                      {                          voteNoCount++;                      }                  }                  ServerMessage newMessage = new ServerMessage();                  newMessage.type = ServerMessageType.WARP_CONTROL;                  using (MessageWriter mw = new MessageWriter())                  {                      mw.Write<int>((int)WarpMessageType.REPLY_VOTE);                      mw.Write<int>(voteYesCount);                      mw.Write<int>(voteNoCount);                      newMessage.data = mw.GetMessageBytes();                  }                  ClientHandler.SendToAll(null' newMessage' true);                  if (voteYesCount >= voteNeededCount)                  {                      warpTimeout = DateTime.UtcNow.Ticks + (long)(MAX_WARP_TIME * 10000000);                      warpMaster = voteMaster;                      voteList = null;                      voteMaster = null;                      SendSetController(warpMaster' warpTimeout);                  }                  else                  {                      if (voteNoCount >= voteFailedCount)                      {                          voteList = null;                          voteMaster = null;                          SendSetController(null' long.MinValue);                      }                  }              }
Magic Number,DarkMultiPlayerServer.Messages,WarpControl,C:\repos\godarklight_DarkMultiPlayer\Server\Messages\WarpControl.cs,GetLatestSubspace,The following statement contains a magic number: foreach (KeyValuePair<int'Subspace> subspace in subspaces)              {                  double currentPlanetTime = subspace.Value.planetTime + (((currentTime - subspace.Value.serverClock) / 10000000) * subspace.Value.subspaceSpeed);                  if (currentPlanetTime > latestPlanetTime)                  {                      latestPlanetTime = currentPlanetTime;                      latestID = subspace.Key;                  }              }
Missing Default,DarkMultiPlayerServer.Messages,Chat,C:\repos\godarklight_DarkMultiPlayer\Server\Messages\Chat.cs,HandleChatMessage,The following switch statement is missing a default case: switch (messageType)                  {                      case ChatMessageType.JOIN:                          {                              string joinChannel = mr.Read<string>();                              if (!playerChatChannels.ContainsKey(fromPlayer))                              {                                  playerChatChannels.Add(fromPlayer' new List<string>());                              }                              if (!playerChatChannels[fromPlayer].Contains(joinChannel))                              {                                  playerChatChannels[fromPlayer].Add(joinChannel);                              }                              DarkLog.Debug(fromPlayer + " joined channel: " + joinChannel);                          }                          ClientHandler.SendToAll(client' newMessage' true);                          break;                      case ChatMessageType.LEAVE:                          {                              string leaveChannel = mr.Read<string>();                              if (playerChatChannels.ContainsKey(fromPlayer))                              {                                  if (playerChatChannels[fromPlayer].Contains(leaveChannel))                                  {                                      playerChatChannels[fromPlayer].Remove(leaveChannel);                                  }                                  if (playerChatChannels[fromPlayer].Count == 0)                                  {                                      playerChatChannels.Remove(fromPlayer);                                  }                              }                              DarkLog.Debug(fromPlayer + " left channel: " + leaveChannel);                          }                          ClientHandler.SendToAll(client' newMessage' true);                          break;                      case ChatMessageType.CHANNEL_MESSAGE:                          {                              string channel = mr.Read<string>();                              string message = mr.Read<string>();                              if (channel != "")                              {                                  foreach (KeyValuePair<string' List<string>> playerEntry in playerChatChannels)                                  {                                      if (playerEntry.Value.Contains(channel))                                      {                                          ClientObject findClient = ClientHandler.GetClientByName(playerEntry.Key);                                          if (findClient != null)                                          {                                              ClientHandler.SendToClient(findClient' newMessage' true);                                          }                                      }                                  }                                  DarkLog.ChatMessage(fromPlayer + " -> #" + channel + ": " + message);                              }                              else                              {                                  ClientHandler.SendToClient(client' newMessage' true);                                  ClientHandler.SendToAll(client' newMessage' true);                                  DarkLog.ChatMessage(fromPlayer + " -> #Global: " + message);                              }                          }                          break;                      case ChatMessageType.PRIVATE_MESSAGE:                          {                              string toPlayer = mr.Read<string>();                              string message = mr.Read<string>();                              if (toPlayer != Settings.settingsStore.consoleIdentifier)                              {                                  ClientObject findClient = ClientHandler.GetClientByName(toPlayer);                                  if (findClient != null)                                  {                                      ClientHandler.SendToClient(client' newMessage' true);                                      ClientHandler.SendToClient(findClient' newMessage' true);                                      DarkLog.ChatMessage(fromPlayer + " -> @" + toPlayer + ": " + message);                                  }                                  {                                      DarkLog.ChatMessage(fromPlayer + " -X-> @" + toPlayer + ": " + message);                                  }                              }                              else                              {                                  ClientHandler.SendToClient(client' newMessage' true);                                  DarkLog.ChatMessage(fromPlayer + " -> @" + toPlayer + ": " + message);                              }                          }                          break;                      case ChatMessageType.CONSOLE_MESSAGE:                          {                              string message = mr.Read<string>();                              if (client.authenticated && DarkMultiPlayerServer.AdminSystem.fetch.IsAdmin(client.playerName))                              {                                  CommandHandler.HandleServerInput(message);                              }                              else                              {                                  Messages.ConnectionEnd.SendConnectionEnd(client' "Kicked for sending a console command as a non-admin player.");                              }                          }                          break;                  }
Missing Default,DarkMultiPlayerServer.Messages,PlayerColor,C:\repos\godarklight_DarkMultiPlayer\Server\Messages\PlayerColor.cs,HandlePlayerColor,The following switch statement is missing a default case: switch (messageType)                  {                      case PlayerColorMessageType.SET:                          {                              string playerName = mr.Read<string>();                              if (playerName != client.playerName)                              {                                  DarkLog.Debug(client.playerName + " tried to send a color update for " + playerName + "' kicking.");                                  Messages.ConnectionEnd.SendConnectionEnd(client' "Kicked for sending a color update for another player");                                  return;                              }                              client.playerColor = mr.Read<float[]>();                              //Relay the message                              ServerMessage newMessage = new ServerMessage();                              newMessage.type = ServerMessageType.PLAYER_COLOR;                              newMessage.data = messageData;                              ClientHandler.SendToAll(client' newMessage' true);                          }                          break;                  }
Missing Default,DarkMultiPlayerServer.Messages,CraftLibrary,C:\repos\godarklight_DarkMultiPlayer\Server\Messages\CraftLibrary.cs,HandleCraftLibrary,The following switch statement is missing a default case: switch (craftMessageType)                  {                        case CraftMessageType.UPLOAD_FILE:                          {                              CraftType uploadType = (CraftType)mr.Read<int>();                              string uploadName = mr.Read<string>();                              byte[] uploadData = mr.Read<byte[]>();                              string playerPath = Path.Combine(Path.Combine(Server.universeDirectory' "Crafts")' fromPlayer);                              if (!Directory.Exists(playerPath))                              {                                  Directory.CreateDirectory(playerPath);                              }                              string typePath = Path.Combine(playerPath' uploadType.ToString());                              if (!Directory.Exists(typePath))                              {                                  Directory.CreateDirectory(typePath);                              }                              string craftFile = Path.Combine(typePath' uploadName + ".craft");                              File.WriteAllBytes(craftFile' uploadData);                              DarkLog.Debug("Saving " + uploadName + "' type: " + uploadType.ToString() + " from " + fromPlayer);                              using (MessageWriter mw = new MessageWriter())                              {                                  ServerMessage newMessage = new ServerMessage();                                  newMessage.type = ServerMessageType.CRAFT_LIBRARY;                                  mw.Write<int>((int)CraftMessageType.ADD_FILE);                                  mw.Write<string>(fromPlayer);                                  mw.Write<int>((int)uploadType);                                  mw.Write<string>(uploadName);                                  newMessage.data = mw.GetMessageBytes();                                  ClientHandler.SendToAll(client' newMessage' false);                              }                          }                          break;                      case CraftMessageType.REQUEST_FILE:                          {                              string craftOwner = mr.Read<string>();                              CraftType requestedType = (CraftType)mr.Read<int>();                              bool hasCraft = false;                              string requestedName = mr.Read<string>();                              string playerPath = Path.Combine(Path.Combine(Server.universeDirectory' "Crafts")' craftOwner);                              string typePath = Path.Combine(playerPath' requestedType.ToString());                              string craftFile = Path.Combine(typePath' requestedName + ".craft");                              if (Directory.Exists(playerPath))                              {                                  if (Directory.Exists(typePath))                                  {                                      if (File.Exists(craftFile))                                      {                                          hasCraft = true;                                      }                                  }                              }                              ServerMessage newMessage = new ServerMessage();                              newMessage.type = ServerMessageType.CRAFT_LIBRARY;                              using (MessageWriter mw = new MessageWriter())                              {                                  mw.Write<int>((int)CraftMessageType.RESPOND_FILE);                                  mw.Write<string>(craftOwner);                                  mw.Write<int>((int)requestedType);                                  mw.Write<string>(requestedName);                                  mw.Write<bool>(hasCraft);                                  if (hasCraft)                                  {                                      mw.Write<byte[]>(File.ReadAllBytes(craftFile));                                      DarkLog.Debug("Sending " + fromPlayer + " " + requestedName + " from " + craftOwner);                                  }                                  newMessage.data = mw.GetMessageBytes();                              }                              ClientHandler.SendToClient(client' newMessage' false);                          }                          break;                      case CraftMessageType.DELETE_FILE:                          {                              CraftType craftType = (CraftType)mr.Read<int>();                              string craftName = mr.Read<string>();                              string playerPath = Path.Combine(Path.Combine(Server.universeDirectory' "Crafts")' fromPlayer);                              string typePath = Path.Combine(playerPath' craftType.ToString());                              string craftFile = Path.Combine(typePath' craftName + ".craft");                              if (Directory.Exists(playerPath))                              {                                  if (Directory.Exists(typePath))                                  {                                      if (File.Exists(craftFile))                                      {                                          File.Delete(craftFile);                                          DarkLog.Debug("Removing " + craftName + "' type: " + craftType.ToString() + " from " + fromPlayer);                                      }                                  }                              }                              if (Directory.Exists(playerPath))                              {                                  if (Directory.GetFiles(typePath).Length == 0)                                  {                                      Directory.Delete(typePath);                                  }                              }                              if (Directory.GetDirectories(playerPath).Length == 0)                              {                                  Directory.Delete(playerPath);                              }                              //Relay the delete message to other clients                              ServerMessage newMessage = new ServerMessage();                              newMessage.type = ServerMessageType.CRAFT_LIBRARY;                              newMessage.data = messageData;                              ClientHandler.SendToAll(client' newMessage' false);                          }                          break;                  }
Missing Default,DarkMultiPlayerServer.Messages,ScreenshotLibrary,C:\repos\godarklight_DarkMultiPlayer\Server\Messages\ScreenshotLibrary.cs,HandleScreenshotLibrary,The following switch statement is missing a default case: switch (messageType)                  {                      case ScreenshotMessageType.SCREENSHOT:                          {                              if (Settings.settingsStore.screenshotsPerPlayer > -1)                              {                                  string playerScreenshotDirectory = Path.Combine(screenshotDirectory' fromPlayer);                                  if (!Directory.Exists(playerScreenshotDirectory))                                  {                                      Directory.CreateDirectory(playerScreenshotDirectory);                                  }                                  string screenshotFile = Path.Combine(playerScreenshotDirectory' DateTime.Now.ToString("yyyy-MM-dd HH-mm-ss") + ".png");                                  DarkLog.Debug("Saving screenshot from " + fromPlayer);                                    byte[] screenshotData = mr.Read<byte[]>();                                    File.WriteAllBytes(screenshotFile' screenshotData);                                  if (Settings.settingsStore.screenshotsPerPlayer != 0)                                  {                                      while (Directory.GetFiles(playerScreenshotDirectory).Length > Settings.settingsStore.screenshotsPerPlayer)                                      {                                          string[] currentFiles = Directory.GetFiles(playerScreenshotDirectory);                                          string deleteFile = currentFiles[0];                                          //Find oldest file                                          foreach (string testFile in currentFiles)                                          {                                              if (File.GetCreationTime(testFile) < File.GetCreationTime(deleteFile))                                              {                                                  deleteFile = testFile;                                              }                                          }                                          File.Delete(deleteFile);                                          DarkLog.Debug("Removing old screenshot " + Path.GetFileName(deleteFile));                                      }                                  }                                    //Notify players that aren't watching that there's a new screenshot availabe. This only works if there's a file available on the server.                                  //The server does not keep the screenshots in memory.                                  ServerMessage notifyMessage = new ServerMessage();                                  notifyMessage.type = ServerMessageType.SCREENSHOT_LIBRARY;                                  using (MessageWriter mw = new MessageWriter())                                  {                                      mw.Write<int>((int)ScreenshotMessageType.NOTIFY);                                      mw.Write(fromPlayer);                                      notifyMessage.data = mw.GetMessageBytes();                                      ClientHandler.SendToAll(client' notifyMessage' false);                                  }                              }                              if (!playerUploadedScreenshotIndex.ContainsKey(fromPlayer))                              {                                  playerUploadedScreenshotIndex.Add(fromPlayer' 0);                              }                              else                              {                                  playerUploadedScreenshotIndex[fromPlayer]++;                              }                              if (!playerDownloadedScreenshotIndex.ContainsKey(fromPlayer))                              {                                  playerDownloadedScreenshotIndex.Add(fromPlayer' new Dictionary<string' int>());                              }                              if (!playerDownloadedScreenshotIndex[fromPlayer].ContainsKey(fromPlayer))                              {                                  playerDownloadedScreenshotIndex[fromPlayer].Add(fromPlayer' playerUploadedScreenshotIndex[fromPlayer]);                              }                              else                              {                                  playerDownloadedScreenshotIndex[fromPlayer][fromPlayer] = playerUploadedScreenshotIndex[fromPlayer];                              }                              newMessage.data = messageData;                              foreach (KeyValuePair<string' string> entry in playerWatchScreenshot)                              {                                  if (entry.Key != fromPlayer)                                  {                                      if (entry.Value == fromPlayer && entry.Key != client.playerName)                                      {                                          ClientObject toClient = ClientHandler.GetClientByName(entry.Key);                                          if (toClient != null && toClient != client)                                          {                                              if (!playerDownloadedScreenshotIndex.ContainsKey(entry.Key))                                              {                                                  playerDownloadedScreenshotIndex.Add(entry.Key' new Dictionary<string' int>());                                              }                                              if (!playerDownloadedScreenshotIndex[entry.Key].ContainsKey(fromPlayer))                                              {                                                  playerDownloadedScreenshotIndex[entry.Key].Add(fromPlayer' 0);                                              }                                              playerDownloadedScreenshotIndex[entry.Key][fromPlayer] = playerUploadedScreenshotIndex[fromPlayer];                                              DarkLog.Debug("Sending screenshot from " + fromPlayer + " to " + entry.Key);                                              using (MessageWriter mw = new MessageWriter())                                              {                                                  ServerMessage sendStartMessage = new ServerMessage();                                                  sendStartMessage.type = ServerMessageType.SCREENSHOT_LIBRARY;                                                  mw.Write<int>((int)ScreenshotMessageType.SEND_START_NOTIFY);                                                  mw.Write<string>(fromPlayer);                                                  sendStartMessage.data = mw.GetMessageBytes();                                                  ClientHandler.SendToClient(toClient' sendStartMessage' true);                                              }                                              ClientHandler.SendToClient(toClient' newMessage' false);                                          }                                      }                                  }                              }                          }                          break;                      case ScreenshotMessageType.WATCH:                          {                              newMessage.data = messageData;                              string watchPlayer = mr.Read<string>();                              if (watchPlayer == "")                              {                                  if (playerWatchScreenshot.ContainsKey(fromPlayer))                                  {                                      DarkLog.Debug(fromPlayer + " is no longer watching screenshots from " + playerWatchScreenshot[fromPlayer]);                                      playerWatchScreenshot.Remove(fromPlayer);                                  }                              }                              else                              {                                  DarkLog.Debug(fromPlayer + " is watching screenshots from " + watchPlayer);                                  playerWatchScreenshot[fromPlayer] = watchPlayer;                                  if (!playerDownloadedScreenshotIndex.ContainsKey(fromPlayer))                                  {                                      playerDownloadedScreenshotIndex.Add(fromPlayer' new Dictionary<string' int>());                                  }                                  string watchPlayerScreenshotDirectory = Path.Combine(screenshotDirectory' watchPlayer);                                  //Find latest screenshot                                  string sendFile = null;                                  if (Directory.Exists(watchPlayerScreenshotDirectory))                                  {                                      string[] playerScreenshots = Directory.GetFiles(watchPlayerScreenshotDirectory);                                      if (playerScreenshots.Length > 0)                                      {                                          sendFile = playerScreenshots[0];                                          foreach (string testFile in playerScreenshots)                                          {                                              if (File.GetCreationTime(testFile) > File.GetCreationTime(sendFile))                                              {                                                  sendFile = testFile;                                              }                                          }                                          if (!playerUploadedScreenshotIndex.ContainsKey(watchPlayer))                                          {                                              playerUploadedScreenshotIndex.Add(watchPlayer' 0);                                          }                                      }                                  }                                  //Send screenshot if needed                                  if (sendFile != null)                                  {                                      bool sendScreenshot = false;                                      if (!playerDownloadedScreenshotIndex[fromPlayer].ContainsKey(watchPlayer))                                      {                                          playerDownloadedScreenshotIndex[fromPlayer].Add(watchPlayer' playerUploadedScreenshotIndex[watchPlayer]);                                          sendScreenshot = true;                                      }                                      else                                      {                                          if (playerDownloadedScreenshotIndex[fromPlayer][watchPlayer] != playerUploadedScreenshotIndex[watchPlayer])                                          {                                              sendScreenshot = true;                                              playerDownloadedScreenshotIndex[fromPlayer][watchPlayer] = playerUploadedScreenshotIndex[watchPlayer];                                          }                                      }                                      if (sendScreenshot)                                      {                                          ServerMessage sendStartMessage = new ServerMessage();                                          sendStartMessage.type = ServerMessageType.SCREENSHOT_LIBRARY;                                          using (MessageWriter mw = new MessageWriter())                                          {                                              mw.Write<int>((int)ScreenshotMessageType.SEND_START_NOTIFY);                                              mw.Write<string>(fromPlayer);                                              sendStartMessage.data = mw.GetMessageBytes();                                          }                                          ServerMessage screenshotMessage = new ServerMessage();                                          screenshotMessage.type = ServerMessageType.SCREENSHOT_LIBRARY;                                          using (MessageWriter mw = new MessageWriter())                                          {                                              mw.Write<int>((int)ScreenshotMessageType.SCREENSHOT);                                              mw.Write<string>(watchPlayer);                                              mw.Write<byte[]>(File.ReadAllBytes(sendFile));                                              screenshotMessage.data = mw.GetMessageBytes();                                          }                                          ClientObject toClient = ClientHandler.GetClientByName(fromPlayer);                                          if (toClient != null)                                          {                                              DarkLog.Debug("Sending saved screenshot from " + watchPlayer + " to " + fromPlayer);                                              ClientHandler.SendToClient(toClient' sendStartMessage' false);                                              ClientHandler.SendToClient(toClient' screenshotMessage' false);                                          }                                      }                                  }                              }                              //Relay the message                              ClientHandler.SendToAll(client' newMessage' false);                          }                          break;                  }
Missing Default,DarkMultiPlayerServer.Messages,FlagSync,C:\repos\godarklight_DarkMultiPlayer\Server\Messages\FlagSync.cs,HandleFlagSync,The following switch statement is missing a default case: switch (messageType)                  {                      case FlagMessageType.LIST:                          {                              //Send the list back                              List<string> serverFlagFileNames = new List<string>();                              List<string> serverFlagOwners = new List<string>();                              List<string> serverFlagShaSums = new List<string>();                                string[] clientFlags = mr.Read<string[]>();                              string[] clientFlagShas = mr.Read<string[]>();                              string[] serverFlags = Directory.GetFiles(flagPath' "*"' SearchOption.AllDirectories);                              foreach (string serverFlag in serverFlags)                              {                                  string trimmedName = Path.GetFileName(serverFlag);                                  string flagOwnerPath = Path.GetDirectoryName(serverFlag);                                  string flagOwner = flagOwnerPath.Substring(Path.GetDirectoryName(flagOwnerPath).Length + 1);                                  bool isMatched = false;                                  bool shaDifferent = false;                                  for (int i = 0; i < clientFlags.Length; i++)                                  {                                      if (clientFlags[i].ToLower() == trimmedName.ToLower())                                      {                                          isMatched = true;                                          shaDifferent = (Common.CalculateSHA256Hash(serverFlag) != clientFlagShas[i]);                                      }                                  }                                  if (!isMatched || shaDifferent)                                  {                                      if (flagOwner == client.playerName)                                      {                                          DarkLog.Debug("Deleting flag " + trimmedName);                                          File.Delete(serverFlag);                                          ServerMessage newMessage = new ServerMessage();                                          newMessage.type = ServerMessageType.FLAG_SYNC;                                          using (MessageWriter mw = new MessageWriter())                                          {                                              mw.Write<int>((int)FlagMessageType.DELETE_FILE);                                              mw.Write<string>(trimmedName);                                              newMessage.data = mw.GetMessageBytes();                                              ClientHandler.SendToAll(client' newMessage' false);                                          }                                          if (Directory.GetFiles(flagOwnerPath).Length == 0)                                          {                                              Directory.Delete(flagOwnerPath);                                          }                                      }                                      else                                      {                                          DarkLog.Debug("Sending flag " + serverFlag + " from " + flagOwner + " to " + client.playerName);                                          ServerMessage newMessage = new ServerMessage();                                          newMessage.type = ServerMessageType.FLAG_SYNC;                                          using (MessageWriter mw = new MessageWriter())                                          {                                              mw.Write<int>((int)FlagMessageType.FLAG_DATA);                                              mw.Write<string>(flagOwner);                                              mw.Write<string>(trimmedName);                                              mw.Write<byte[]>(File.ReadAllBytes(serverFlag));                                              newMessage.data = mw.GetMessageBytes();                                              ClientHandler.SendToClient(client' newMessage' false);                                          }                                      }                                  }                                  //Don't tell the client we have a different copy of the flag so it is reuploaded                                  if (File.Exists(serverFlag))                                  {                                      serverFlagFileNames.Add(trimmedName);                                      serverFlagOwners.Add(flagOwner);                                      serverFlagShaSums.Add(Common.CalculateSHA256Hash(serverFlag));                                  }                              }                              ServerMessage listMessage = new ServerMessage();                              listMessage.type = ServerMessageType.FLAG_SYNC;                              using (MessageWriter mw2 = new MessageWriter())                              {                                  mw2.Write<int>((int)FlagMessageType.LIST);                                  mw2.Write<string[]>(serverFlagFileNames.ToArray());                                  mw2.Write<string[]>(serverFlagOwners.ToArray());                                  mw2.Write<string[]>(serverFlagShaSums.ToArray());                                  listMessage.data = mw2.GetMessageBytes();                              }                              ClientHandler.SendToClient(client' listMessage' false);                          }                          break;                      case FlagMessageType.DELETE_FILE:                          {                              string flagName = mr.Read<string>();                              string playerFlagPath = Path.Combine(flagPath' client.playerName);                              if (Directory.Exists(playerFlagPath))                              {                                  string flagFile = Path.Combine(playerFlagPath' flagName);                                  if (File.Exists(flagFile))                                  {                                      File.Delete(flagFile);                                  }                                  if (Directory.GetFiles(playerFlagPath).Length == 0)                                  {                                      Directory.Delete(playerFlagPath);                                  }                              }                              ServerMessage newMessage = new ServerMessage();                              newMessage.type = ServerMessageType.FLAG_SYNC;                              using (MessageWriter mw = new MessageWriter())                              {                                  mw.Write<int>((int)FlagMessageType.DELETE_FILE);                                  mw.Write<string>(flagName);                                  newMessage.data = mw.GetMessageBytes();                              }                              ClientHandler.SendToAll(client' newMessage' false);                          }                          break;                      case FlagMessageType.UPLOAD_FILE:                          {                              string flagName = mr.Read<string>();                              byte[] flagData = mr.Read<byte[]>();                              // Do not save null files                              if (flagData.Length > 0)                              {                                  // Check if the specified file is a valid PNG file                                  byte[] pngSequence = new byte[] { 137' 80' 78' 71' 13' 10' 26' 10 };                                  if (pngSequence.SequenceEqual(flagData.Take(pngSequence.Length)))                                  {                                      string playerFlagPath = Path.Combine(flagPath' client.playerName);                                        if (!Directory.Exists(playerFlagPath))                                          Directory.CreateDirectory(playerFlagPath);                                        DarkLog.Debug("Saving flag " + flagName + " from " + client.playerName);                                      File.WriteAllBytes(Path.Combine(playerFlagPath' flagName)' flagData);                                        ServerMessage newMessage = new ServerMessage();                                      newMessage.type = ServerMessageType.FLAG_SYNC;                                      using (MessageWriter mw = new MessageWriter())                                      {                                          mw.Write<int>((int)FlagMessageType.FLAG_DATA);                                          mw.Write<string>(client.playerName);                                          mw.Write<string>(flagName);                                          mw.Write<byte[]>(flagData);                                      }                                        ClientHandler.SendToAll(client' newMessage' false);                                  }                              }                          }                          break;                  }
Missing Default,DarkMultiPlayerServer.Messages,LockSystem,C:\repos\godarklight_DarkMultiPlayer\Server\Messages\LockSystem.cs,HandleLockSystemMessage,The following switch statement is missing a default case: switch (lockMessageType)                  {                      case LockMessageType.ACQUIRE:                          {                              string playerName = mr.Read<string>();                              string lockName = mr.Read<string>();                              bool force = mr.Read<bool>();                              if (playerName != client.playerName)                              {                                  Messages.ConnectionEnd.SendConnectionEnd(client' "Kicked for sending a lock message for another player");                              }                              bool lockResult = DarkMultiPlayerServer.LockSystem.fetch.AcquireLock(lockName' playerName' force);                              using (MessageWriter mw = new MessageWriter())                              {                                  mw.Write((int)LockMessageType.ACQUIRE);                                  mw.Write(playerName);                                  mw.Write(lockName);                                  mw.Write(lockResult);                                  newMessage.data = mw.GetMessageBytes();                              }                              //Send to all clients                              ClientHandler.SendToAll(null' newMessage' true);                              if (lockResult)                              {                                  DarkLog.Debug(playerName + " acquired lock " + lockName);                              }                              else                              {                                  DarkLog.Debug(playerName + " failed to acquire lock " + lockName);                              }                          }                          break;                      case LockMessageType.RELEASE:                          {                              string playerName = mr.Read<string>();                              string lockName = mr.Read<string>();                              if (playerName != client.playerName)                              {                                  Messages.ConnectionEnd.SendConnectionEnd(client' "Kicked for sending a lock message for another player");                              }                              bool lockResult = DarkMultiPlayerServer.LockSystem.fetch.ReleaseLock(lockName' playerName);                              if (!lockResult)                              {                                  Messages.ConnectionEnd.SendConnectionEnd(client' "Kicked for releasing a lock you do not own");                              }                              else                              {                                  using (MessageWriter mw = new MessageWriter())                                  {                                      mw.Write((int)LockMessageType.RELEASE);                                      mw.Write(playerName);                                      mw.Write(lockName);                                      mw.Write(lockResult);                                      newMessage.data = mw.GetMessageBytes();                                  }                                  //Send to all clients                                  ClientHandler.SendToAll(null' newMessage' true);                              }                              if (lockResult)                              {                                  DarkLog.Debug(playerName + " released lock " + lockName);                              }                              else                              {                                  DarkLog.Debug(playerName + " failed to release lock " + lockName);                              }                          }                          break;                  }
