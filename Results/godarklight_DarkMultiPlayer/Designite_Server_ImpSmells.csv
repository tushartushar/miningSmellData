Implementation smell,Namespace,Class,File,Method,Description
Long Method,DarkMultiPlayerServer,Server,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Main.cs,Main,The method has 230 lines of code.
Long Method,DarkMultiPlayerServer,ClientHandler,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\ClientHandler.cs,ReceiveCallback,The method has 103 lines of code.
Long Method,DarkMultiPlayerServer,ClientHandler,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\ClientHandler.cs,HandleMessage,The method has 122 lines of code.
Long Method,DarkMultiPlayerServer,ClientHandler,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\ClientHandler.cs,SendToClient,The method has 110 lines of code.
Long Method,DarkMultiPlayerServer.Messages,Handshake,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Messages\Handshake.cs,HandleHandshakeResponse,The method has 184 lines of code.
Long Method,DarkMultiPlayerServer.Messages,Chat,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Messages\Chat.cs,HandleChatMessage,The method has 115 lines of code.
Long Method,DarkMultiPlayerServer.Messages,CraftLibrary,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Messages\CraftLibrary.cs,HandleCraftLibrary,The method has 120 lines of code.
Long Method,DarkMultiPlayerServer.Messages,ScreenshotLibrary,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Messages\ScreenshotLibrary.cs,HandleScreenshotLibrary,The method has 215 lines of code.
Long Method,DarkMultiPlayerServer.Messages,FlagSync,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Messages\FlagSync.cs,HandleFlagSync,The method has 154 lines of code.
Complex Method,DarkMultiPlayerServer,Server,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Main.cs,Main,Cyclomatic complexity of the method is 29
Complex Method,DarkMultiPlayerServer,Server,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Main.cs,CheckUniverse,Cyclomatic complexity of the method is 12
Complex Method,DarkMultiPlayerServer,ClientHandler,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\ClientHandler.cs,ReceiveCallback,Cyclomatic complexity of the method is 8
Complex Method,DarkMultiPlayerServer,ClientHandler,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\ClientHandler.cs,HandleMessage,Cyclomatic complexity of the method is 31
Complex Method,DarkMultiPlayerServer,ClientHandler,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\ClientHandler.cs,SendToClient,Cyclomatic complexity of the method is 14
Complex Method,DarkMultiPlayerServer,NukeKSC,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\NukeKSC.cs,RunNukeKSC,Cyclomatic complexity of the method is 8
Complex Method,DarkMultiPlayerServer,DMPPluginHandler,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\DMPPluginHandler.cs,LoadPlugins,Cyclomatic complexity of the method is 10
Complex Method,DarkMultiPlayerServer,BackwardsCompatibility,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\BackwardsCompatibility.cs,UpdateModcontrolPartList,Cyclomatic complexity of the method is 16
Complex Method,DarkMultiPlayerServer,BanSystem,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\BanSystem.cs,LoadBans,Cyclomatic complexity of the method is 11
Complex Method,DarkMultiPlayerServer,WhitelistCommand,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\WhitelistCommand.cs,HandleCommand,Cyclomatic complexity of the method is 9
Complex Method,DarkMultiPlayerServer,AdminCommand,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\AdminCommand.cs,HandleCommand,Cyclomatic complexity of the method is 10
Complex Method,DarkMultiPlayerServer,ModpackSystem,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\ModpackSystem.cs,SendFilesToClients,Cyclomatic complexity of the method is 8
Complex Method,DarkMultiPlayerServer,ModpackSystem,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\ModpackSystem.cs,LoadAuto,Cyclomatic complexity of the method is 10
Complex Method,DarkMultiPlayerServer,ModpackSystem,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\ModpackSystem.cs,Load,Cyclomatic complexity of the method is 14
Complex Method,DarkMultiPlayerServer,ModpackSystem,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\ModpackSystem.cs,HandleModDone,Cyclomatic complexity of the method is 11
Complex Method,DarkMultiPlayerServer.Messages,Handshake,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Messages\Handshake.cs,HandleHandshakeResponse,Cyclomatic complexity of the method is 24
Complex Method,DarkMultiPlayerServer.Messages,Chat,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Messages\Chat.cs,HandleChatMessage,Cyclomatic complexity of the method is 18
Complex Method,DarkMultiPlayerServer.Messages,CraftLibrary,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Messages\CraftLibrary.cs,SendCraftList,Cyclomatic complexity of the method is 10
Complex Method,DarkMultiPlayerServer.Messages,CraftLibrary,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Messages\CraftLibrary.cs,HandleCraftLibrary,Cyclomatic complexity of the method is 16
Complex Method,DarkMultiPlayerServer.Messages,ScreenshotLibrary,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Messages\ScreenshotLibrary.cs,HandleScreenshotLibrary,Cyclomatic complexity of the method is 33
Complex Method,DarkMultiPlayerServer.Messages,FlagSync,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Messages\FlagSync.cs,HandleFlagSync,Cyclomatic complexity of the method is 17
Complex Method,DarkMultiPlayerServer.Messages,WarpControl,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Messages\WarpControl.cs,HandleWarpControl,Cyclomatic complexity of the method is 8
Complex Method,DarkMultiPlayerServer.Messages,WarpControl,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Messages\WarpControl.cs,HandleLowestRateChange,Cyclomatic complexity of the method is 8
Complex Method,DarkMultiPlayerServer.Messages,WarpControl,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Messages\WarpControl.cs,DisconnectPlayer,Cyclomatic complexity of the method is 9
Complex Method,DarkMultiPlayerServer.Messages,GroupMessage,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Messages\GroupMessage.cs,HandleMessage,Cyclomatic complexity of the method is 13
Complex Method,DarkMultiPlayerServer.Messages,Modpack,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Messages\Modpack.cs,HandleModpackMessage,Cyclomatic complexity of the method is 15
Long Parameter List,DarkMultiPlayerServer.Messages,WarpControl,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Messages\WarpControl.cs,HandleChangeWarp,The method has 5 parameters. Parameters: client' physWarp' rateIndex' serverClock' planetTime
Long Identifier,DarkMultiPlayerServer,GameplaySettingsStore,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\GameplaySettings.cs,,The length of the parameter bypassEntryPurchaseAfterResearch is 32.
Long Identifier,DarkMultiPlayerServer.Messages,ScreenshotLibrary,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Messages\ScreenshotLibrary.cs,HandleScreenshotLibrary,The length of the parameter watchPlayerScreenshotDirectory is 30.
Long Identifier,DarkMultiPlayerServer.Messages,ScreenshotLibrary,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Messages\ScreenshotLibrary.cs,,The length of the parameter playerDownloadedScreenshotIndex is 31.
Long Statement,DarkMultiPlayerServer,GameplaySettings,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\GameplaySettings.cs,Reset,The length of the statement  "            gameplaySettings = new ConfigParser<GameplaySettingsStore>(new GameplaySettingsStore()' Path.Combine(Server.configDirectory' "GameplaySettings.txt")); " is 150.
Long Statement,DarkMultiPlayerServer,Server,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Main.cs,Main,The length of the statement  "            CommandHandler.RegisterCommand("admin"' AdminCommand.HandleCommand' "Sets a player as admin/removes admin from the player"); " is 124.
Long Statement,DarkMultiPlayerServer,Server,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Main.cs,Main,The length of the statement  "                DarkLog.Normal("Starting " + Settings.settingsStore.warpMode + " server on port " + Settings.settingsStore.port + "... "); " is 122.
Long Statement,DarkMultiPlayerServer,Server,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Main.cs,Main,The length of the statement  "                            DarkLog.LogFilename = Path.Combine(DarkLog.LogFolder' "dmpserver " + DateTime.Now.ToString("yyyy-MM-dd HH-mm-ss") + ".log"); " is 124.
Long Statement,DarkMultiPlayerServer,Server,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Main.cs,GenerateNewModFile,The length of the statement  "            string modFileData = Common.GenerateModFileStringData(new string[0]' new string[0]' false' new string[0]' Common.GetStockParts().ToArray()); " is 140.
Long Statement,DarkMultiPlayerServer,CommandHandler,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\CommandHandler.cs,ThreadMain,The length of the statement  "                CommandHandler.RegisterCommand("addplayer"' Groups.fetch.AddPlayerToGroupCommand' "Adds player to group' first player becomes admin"); " is 134.
Long Statement,DarkMultiPlayerServer,CommandHandler,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\CommandHandler.cs,ThreadMain,The length of the statement  "                CommandHandler.RegisterCommand("editvessel"' Permissions.fetch.EditVesselCommand' "Edits vessel permissions' takes same ID from Universe/Vessels/"); " is 148.
Long Statement,DarkMultiPlayerServer,CommandHandler,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\CommandHandler.cs,ThreadMain,The length of the statement  "                CommandHandler.RegisterCommand("vesselprotection"' Permissions.fetch.SetVesselProtectionCommand' "Sets vessel protection level. Valid levels: public' group' private."); " is 168.
Long Statement,DarkMultiPlayerServer,CommandHandler,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\CommandHandler.cs,ThreadMain,The length of the statement  "                CommandHandler.RegisterCommand("showvessels"' Permissions.fetch.ShowVesselsCommand' "Shows vessel protection database"); " is 120.
Long Statement,DarkMultiPlayerServer,CommandHandler,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\CommandHandler.cs,ConnectionStats,The length of the statement  "                    DarkLog.Normal("Player '" + client.playerName + "'' queued out: " + client.bytesQueuedOut + "' sent: " + client.bytesSent + "' received: " + client.bytesReceived); " is 163.
Long Statement,DarkMultiPlayerServer,CommandHandler,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\CommandHandler.cs,ConnectionStats,The length of the statement  "            DarkLog.Normal("Server' queued out: " + bytesQueuedOutTotal + "' sent: " + bytesSentTotal + "' received: " + bytesReceivedTotal); " is 129.
Long Statement,DarkMultiPlayerServer,ClientHandler,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\ClientHandler.cs,SetupTCPServer,The length of the statement  "                        //Windows defaults to v6 only' but this option does not exist in mono so it has to be in a try/catch block along with the casted int. " is 133.
Long Statement,DarkMultiPlayerServer,ClientHandler,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\ClientHandler.cs,SplitAndRewriteMessage,The length of the statement  "                    Array.Copy(message.data' message.data.Length - splitBytesLeft' currentSplitMessage.data' 0' currentSplitMessage.data.Length); " is 125.
Long Statement,DarkMultiPlayerServer,ClientHandler,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\ClientHandler.cs,SendNetworkMessage,The length of the statement  "                    DarkLog.Normal("Disconnecting client " + client.playerName + "' sent CONNECTION_END (" + reason + ") to endpoint " + client.endpoint); " is 134.
Long Statement,DarkMultiPlayerServer,ClientHandler,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\ClientHandler.cs,SendNetworkMessage,The length of the statement  "                        DarkLog.Normal("Disconnecting client " + client.playerName + "' sent HANDSHAKE_REPLY (" + reason + ") to endpoint " + client.endpoint); " is 135.
Long Statement,DarkMultiPlayerServer,ClientHandler,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\ClientHandler.cs,StartReceivingIncomingMessages,The length of the statement  "                client.connection.GetStream().BeginRead(client.receiveMessage.data' client.receiveMessage.data.Length - client.receiveMessageBytesLeft' client.receiveMessageBytesLeft' new AsyncCallback(ReceiveCallback)' client); " is 212.
Long Statement,DarkMultiPlayerServer,ClientHandler,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\ClientHandler.cs,ReceiveCallback,The length of the statement  "                    client.connection.GetStream().BeginRead(client.receiveMessage.data' client.receiveMessage.data.Length - client.receiveMessageBytesLeft' client.receiveMessageBytesLeft' new AsyncCallback(ReceiveCallback)' client); " is 212.
Long Statement,DarkMultiPlayerServer,ClientHandler,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\ClientHandler.cs,HandleDisconnectException,The length of the statement  "                        DarkLog.Normal("Client " + client.playerName + " disconnected in " + location + "' endpoint " + client.endpoint + "' error: " + e.Message + " (" + e.InnerException.Message + ")"); " is 179.
Long Statement,DarkMultiPlayerServer,ClientHandler,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\ClientHandler.cs,HandleDisconnectException,The length of the statement  "                        DarkLog.Normal("Client " + client.playerName + " disconnected in " + location + "' endpoint " + client.endpoint + "' error: " + e.Message); " is 139.
Long Statement,DarkMultiPlayerServer,ClientHandler,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\ClientHandler.cs,HandleMessage,The length of the statement  "            if (!client.authenticated && !(message.type == ClientMessageType.HEARTBEAT || message.type == ClientMessageType.HANDSHAKE_RESPONSE || message.type == ClientMessageType.CONNECTION_END)) " is 184.
Long Statement,DarkMultiPlayerServer,ClientHandler,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\ClientHandler.cs,HandleMessage,The length of the statement  "                Messages.ConnectionEnd.SendConnectionEnd(client' "You must authenticate before attempting to send a " + message.type.ToString() + " message"); " is 142.
Long Statement,DarkMultiPlayerServer,Settings,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Settings.cs,Reset,The length of the statement  "            serverSettings = new ConfigParser<SettingsStore>(new SettingsStore()' Path.Combine(Server.configDirectory' "Settings.txt")); " is 124.
Long Statement,DarkMultiPlayerServer,Dekessler,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Dekessler.cs,CheckTimer,The length of the statement  "                if (((Server.serverClock.ElapsedMilliseconds - lastDekesslerTime) > (Settings.settingsStore.autoDekessler * 60 * 1000)) || lastDekesslerTime == 0) " is 146.
Long Statement,DarkMultiPlayerServer,NukeKSC,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\NukeKSC.cs,CheckTimer,The length of the statement  "                if (((Server.serverClock.ElapsedMilliseconds - lastNukeTime) > (Settings.settingsStore.autoNuke * 60 * 1000)) || lastNukeTime == 0) " is 131.
Long Statement,DarkMultiPlayerServer,DMPPluginHandler,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\DMPPluginHandler.cs,CurrentDomain_AssemblyResolve,The length of the statement  "                    DarkLog.Debug("Resolved plugin assembly reference: " + args.Name + " (referenced by " + args.RequestingAssembly.FullName + ")"); " is 128.
Long Statement,DarkMultiPlayerServer,DMPPluginHandler,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\DMPPluginHandler.cs,LoadPlugins,The length of the statement  "                        //UnsafeLoadFrom will not throw an exception if the dll is marked as unsafe' such as downloaded from internet in Windows " is 120.
Long Statement,DarkMultiPlayerServer,DMPPluginHandler,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\DMPPluginHandler.cs,LoadPlugins,The length of the statement  "                            DarkLog.Error("Error loading plugin " + loadedType.FullName + "(" + loadedType.Assembly.FullName + ") Exception: " + ex.ToString()); " is 132.
Long Statement,DarkMultiPlayerServer,DMPPluginHandler,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\DMPPluginHandler.cs,FireOnUpdate,The length of the statement  "                    DarkLog.Debug("Error thrown in OnUpdate event for " + type.FullName + " (" + type.Assembly.FullName + ")' Exception: " + e); " is 124.
Long Statement,DarkMultiPlayerServer,DMPPluginHandler,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\DMPPluginHandler.cs,FireOnServerStart,The length of the statement  "                    DarkLog.Debug("Error thrown in OnServerStart event for " + type.FullName + " (" + type.Assembly.FullName + ")' Exception: " + e); " is 129.
Long Statement,DarkMultiPlayerServer,DMPPluginHandler,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\DMPPluginHandler.cs,FireOnServerStop,The length of the statement  "                    DarkLog.Debug("Error thrown in OnServerStop event for " + type.FullName + " (" + type.Assembly.FullName + ")' Exception: " + e); " is 128.
Long Statement,DarkMultiPlayerServer,DMPPluginHandler,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\DMPPluginHandler.cs,FireOnClientConnect,The length of the statement  "                    DarkLog.Debug("Error thrown in OnClientConnect event for " + type.FullName + " (" + type.Assembly.FullName + ")' Exception: " + e); " is 131.
Long Statement,DarkMultiPlayerServer,DMPPluginHandler,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\DMPPluginHandler.cs,FireOnClientAuthenticated,The length of the statement  "                    DarkLog.Debug("Error thrown in OnClientAuthenticated event for " + type.FullName + " (" + type.Assembly.FullName + ")' Exception: " + e); " is 137.
Long Statement,DarkMultiPlayerServer,DMPPluginHandler,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\DMPPluginHandler.cs,FireOnClientDisconnect,The length of the statement  "                    DarkLog.Debug("Error thrown in OnClientDisconnect event for " + type.FullName + " (" + type.Assembly.FullName + ")' Exception: " + e); " is 134.
Long Statement,DarkMultiPlayerServer,DMPPluginHandler,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\DMPPluginHandler.cs,FireOnMessageReceived,The length of the statement  "                    DarkLog.Debug("Error thrown in OnMessageReceived event for " + type.FullName + " (" + type.Assembly.FullName + ")' Exception: " + e); " is 133.
Long Statement,DarkMultiPlayerServer,DMPPluginHandler,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\DMPPluginHandler.cs,FireOnMessageSent,The length of the statement  "                    DarkLog.Debug("Error thrown in OnMessageSent event for " + type.FullName + " (" + type.Assembly.FullName + ")' Exception: " + e); " is 129.
Long Statement,DarkMultiPlayerServer,PMCommand,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\PMCommand.cs,HandleCommand,The length of the statement  "                    if (commandArgs.StartsWith(testPlayer.playerName' StringComparison.Ordinal) && testPlayer.playerName.Length > matchedLength) " is 124.
Long Statement,DarkMultiPlayerServer,PMCommand,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\PMCommand.cs,HandleCommand,The length of the statement  "                        if ((commandArgs.Length > (testPlayer.playerName.Length + 1)) ? commandArgs[testPlayer.playerName.Length] == ' ' : false) " is 121.
Long Statement,DarkMultiPlayerServer.Messages,Handshake,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Messages\Handshake.cs,HandleHandshakeResponse,The length of the statement  "                if (BanSystem.fetch.IsPlayerNameBanned(client.playerName) || BanSystem.fetch.IsIPBanned(client.ipAddress) || BanSystem.fetch.IsPublicKeyBanned(client.publicKey)) " is 161.
Long Statement,DarkMultiPlayerServer.Messages,Heartbeat,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Messages\Heartbeat.cs,CheckHeartBeat,The length of the statement  "                DarkLog.Normal("Disconnecting client " + client.playerName + "' endpoint " + client.endpoint + "' Connection timed out"); " is 121.
Long Statement,DarkMultiPlayerServer.Messages,Heartbeat,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Messages\Heartbeat.cs,CheckHeartBeat,The length of the statement  "                if (client.sendMessageQueueHigh.Count == 0 && client.sendMessageQueueSplit.Count == 0 && client.sendMessageQueueLow.Count == 0) " is 127.
Long Statement,DarkMultiPlayerServer.Messages,VesselRequest,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Messages\VesselRequest.cs,HandleVesselsRequest,The length of the statement  "                DarkLog.Debug("Sending " + client.playerName + " " + sendVesselCount + " vessels' cached: " + cachedVesselCount + "..."); " is 121.
Long Statement,DarkMultiPlayerServer.Messages,ScreenshotLibrary,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Messages\ScreenshotLibrary.cs,HandleScreenshotLibrary,The length of the statement  "                                //Notify players that aren't watching that there's a new screenshot availabe. This only works if there's a file available on the server. " is 136.
Long Statement,DarkMultiPlayerServer.Messages,WarpControl,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Messages\WarpControl.cs,HandleNewSubspace,The length of the statement  "                if (Settings.settingsStore.warpMode == WarpMode.MCW_FORCE || Settings.settingsStore.warpMode == WarpMode.MCW_VOTE || Settings.settingsStore.warpMode == WarpMode.MCW_LOWEST) " is 172.
Long Statement,DarkMultiPlayerServer.Messages,WarpControl,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Messages\WarpControl.cs,SendSetController,The length of the statement  "            if (Settings.settingsStore.warpMode == WarpMode.MCW_FORCE || Settings.settingsStore.warpMode == WarpMode.MCW_VOTE || Settings.settingsStore.warpMode == WarpMode.MCW_LOWEST) " is 172.
Long Statement,DarkMultiPlayerServer.Messages,WarpControl,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Messages\WarpControl.cs,SendSetSubspace,The length of the statement  "            if (Settings.settingsStore.warpMode != WarpMode.SUBSPACE || Settings.settingsStore.sendPlayerToLatestSubspace || !File.Exists(storedTimeFile) || !Double.TryParse(File.ReadAllText(storedTimeFile)' out storedTime)) " is 212.
Long Statement,DarkMultiPlayerServer.Messages,WarpControl,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Messages\WarpControl.cs,GetLatestSubspace,The length of the statement  "                double currentPlanetTime = subspace.Value.planetTime + (((currentTime - subspace.Value.serverClock) / 10000000) * subspace.Value.subspaceSpeed); " is 144.
Long Statement,DarkMultiPlayerServer.Messages,WarpControl,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Messages\WarpControl.cs,SaveSubspace,The length of the statement  "                sw.WriteLine("#Incorrectly editing this file will cause weirdness. If there is any errors' the universe time will be reset."); " is 126.
Long Statement,DarkMultiPlayerServer.Messages,WarpControl,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Messages\WarpControl.cs,SaveSubspace,The length of the statement  "                sw.WriteLine("#Each variable is on a new line. They are subspaceID' server clock (from DateTime.UtcNow.Ticks)' universe time' and subspace speed."); " is 148.
Long Statement,DarkMultiPlayerServer.Messages,SplitMessage,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Messages\SplitMessage.cs,HandleSplitMessage,The length of the statement  "                messageData.CopyTo(client.receiveSplitMessage.data' client.receiveSplitMessage.data.Length - client.receiveSplitMessageBytesLeft); " is 130.
Long Statement,DarkMultiPlayerServer.Messages,PermissionMessage,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Messages\PermissionMessage.cs,HandleMessage,The length of the statement  "                            VesselProtectionType vesselProtection = (VesselProtectionType)Enum.Parse(typeof(VesselProtectionType)' permissionLevel); " is 120.
Long Statement,DarkMultiPlayerServer.Messages,Modpack,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Messages\Modpack.cs,HandleModpackMessage,The length of the statement  "                                ConnectionEnd.SendConnectionEnd(client' "Kicked from the server' non admin " + client.playerName + " tried to upload modpack"); " is 127.
Long Statement,DarkMultiPlayerServer.Messages,Modpack,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Messages\Modpack.cs,HandleModpackMessage,The length of the statement  "                                ConnectionEnd.SendConnectionEnd(client' "Kicked from the server' non admin " + client.playerName + " tried to upload modpack"); " is 127.
Long Statement,DarkMultiPlayerServer.Messages,Modpack,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Messages\Modpack.cs,HandleModpackMessage,The length of the statement  "                                ConnectionEnd.SendConnectionEnd(client' "Kicked from the server' non admin " + client.playerName + " tried to upload modpack"); " is 127.
Long Statement,DarkMultiPlayerServer.Messages,Modpack,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Messages\Modpack.cs,HandleModpackMessage,The length of the statement  "                                ConnectionEnd.SendConnectionEnd(client' "Kicked from the server' non admin " + client.playerName + " tried to upload modpack"); " is 127.
Complex Conditional,DarkMultiPlayerServer,Server,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Main.cs,StartHTTPServer,The conditional expression  "OS == "Win32NT" || OS == "Win32S" || OS == "Win32Windows" || OS == "WinCE""  is complex.
Complex Conditional,DarkMultiPlayerServer,ClientHandler,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\ClientHandler.cs,HandleMessage,The conditional expression  "!client.authenticated && !(message.type == ClientMessageType.HEARTBEAT || message.type == ClientMessageType.HANDSHAKE_RESPONSE || message.type == ClientMessageType.CONNECTION_END)"  is complex.
Complex Conditional,DarkMultiPlayerServer.Messages,Handshake,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Messages\Handshake.cs,HandleHandshakeResponse,The conditional expression  "playerName.Contains("/") || playerName.Contains(@"\") || playerName.Contains("\n") || playerName.Contains("\r")"  is complex.
Complex Conditional,DarkMultiPlayerServer.Messages,WarpControl,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Messages\WarpControl.cs,SendSetSubspace,The conditional expression  "Settings.settingsStore.warpMode != WarpMode.SUBSPACE || Settings.settingsStore.sendPlayerToLatestSubspace || !File.Exists(storedTimeFile) || !Double.TryParse(File.ReadAllText(storedTimeFile)' out storedTime)"  is complex.
Empty Catch Block,DarkMultiPlayerServer,ClientHandler,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\ClientHandler.cs,SetupTCPServer,The method has an empty catch block.
Magic Number,DarkMultiPlayerServer,Server,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Main.cs,Main,The following statement contains a magic number: Thread.Sleep(500);
Magic Number,DarkMultiPlayerServer,Server,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Main.cs,Main,The following statement contains a magic number: (serverClock.ElapsedMilliseconds - lastGarbageCollect) > 30000
Magic Number,DarkMultiPlayerServer,Server,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Main.cs,Main,The following statement contains a magic number: (serverClock.ElapsedMilliseconds - lastScreenshotExpiredCheck) > 600000
Magic Number,DarkMultiPlayerServer,Server,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Main.cs,Main,The following statement contains a magic number: (serverClock.ElapsedMilliseconds - lastLogExpiredCheck) > 600000
Magic Number,DarkMultiPlayerServer,Server,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Main.cs,Main,The following statement contains a magic number: (serverClock.ElapsedMilliseconds - lastDayCheck) > 60000
Magic Number,DarkMultiPlayerServer,Server,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Main.cs,Main,The following statement contains a magic number: Thread.Sleep(500);
Magic Number,DarkMultiPlayerServer,Server,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Main.cs,GetLastPlayerActivity,The following statement contains a magic number: return (serverClock.ElapsedMilliseconds - lastPlayerActivity) / 1000;
Magic Number,DarkMultiPlayerServer,Server,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Main.cs,CatchExit,The following statement contains a magic number: (DateTime.UtcNow.Ticks - ctrlCTime) > 50000000
Magic Number,DarkMultiPlayerServer,ClientHandler,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\ClientHandler.cs,ThreadMain,The following statement contains a magic number: Thread.Sleep(10);
Magic Number,DarkMultiPlayerServer,ClientHandler,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\ClientHandler.cs,ThreadMain,The following statement contains a magic number: (DateTime.UtcNow.Ticks - disconnectTime) > 50000000
Magic Number,DarkMultiPlayerServer,ClientHandler,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\ClientHandler.cs,ThreadMain,The following statement contains a magic number: Thread.Sleep(10);
Magic Number,DarkMultiPlayerServer,ClientHandler,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\ClientHandler.cs,SetupTCPServer,The following statement contains a magic number: TCPServer.Server.SetSocketOption(SocketOptionLevel.IPv6' (SocketOptionName)27' 0);
Magic Number,DarkMultiPlayerServer,ClientHandler,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\ClientHandler.cs,SetupTCPServer,The following statement contains a magic number: TCPServer.Start(4);
Magic Number,DarkMultiPlayerServer,ClientHandler,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\ClientHandler.cs,SplitAndRewriteMessage,The following statement contains a magic number: client.bytesQueuedOut += 8;
Magic Number,DarkMultiPlayerServer,ClientHandler,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\ClientHandler.cs,SplitAndRewriteMessage,The following statement contains a magic number: client.bytesQueuedOut += 8;
Magic Number,DarkMultiPlayerServer,ClientHandler,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\ClientHandler.cs,SendNetworkMessage,The following statement contains a magic number: client.bytesQueuedOut += 8;
Magic Number,DarkMultiPlayerServer,ClientHandler,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\ClientHandler.cs,StartReceivingIncomingMessages,The following statement contains a magic number: client.receiveMessage.data = new byte[8];
Magic Number,DarkMultiPlayerServer,ClientHandler,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\ClientHandler.cs,ReceiveCallback,The following statement contains a magic number: client.receiveMessage.data = new byte[8];
Magic Number,DarkMultiPlayerServer,ClientHandler,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\ClientHandler.cs,SendToClient,The following statement contains a magic number: client.bytesQueuedOut += 8;
Magic Number,DarkMultiPlayerServer,Dekessler,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Dekessler.cs,RunDekessler,The following statement contains a magic number: string vesselType = trimmedLine.Substring(trimmedLine.IndexOf("="' StringComparison.Ordinal) + 2);
Magic Number,DarkMultiPlayerServer,Dekessler,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Dekessler.cs,CheckTimer,The following statement contains a magic number: ((Server.serverClock.ElapsedMilliseconds - lastDekesslerTime) > (Settings.settingsStore.autoDekessler * 60 * 1000)) || lastDekesslerTime == 0
Magic Number,DarkMultiPlayerServer,Dekessler,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Dekessler.cs,CheckTimer,The following statement contains a magic number: ((Server.serverClock.ElapsedMilliseconds - lastDekesslerTime) > (Settings.settingsStore.autoDekessler * 60 * 1000)) || lastDekesslerTime == 0
Magic Number,DarkMultiPlayerServer,NukeKSC,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\NukeKSC.cs,RunNukeKSC,The following statement contains a magic number: string landedAt = trimmedLine.Substring(trimmedLine.IndexOf("="' StringComparison.Ordinal) + 2);
Magic Number,DarkMultiPlayerServer,NukeKSC,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\NukeKSC.cs,CheckTimer,The following statement contains a magic number: ((Server.serverClock.ElapsedMilliseconds - lastNukeTime) > (Settings.settingsStore.autoNuke * 60 * 1000)) || lastNukeTime == 0
Magic Number,DarkMultiPlayerServer,NukeKSC,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\NukeKSC.cs,CheckTimer,The following statement contains a magic number: ((Server.serverClock.ElapsedMilliseconds - lastNukeTime) > (Settings.settingsStore.autoNuke * 60 * 1000)) || lastNukeTime == 0
Magic Number,DarkMultiPlayerServer,BackwardsCompatibility,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\BackwardsCompatibility.cs,FixKerbals,The following statement contains a magic number: kerbalName = fileLine.Substring(fileLine.IndexOf("name = "' StringComparison.Ordinal) + 7);
Magic Number,DarkMultiPlayerServer,ModpackSystem,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\ModpackSystem.cs,SendFilesToClients,The following statement contains a magic number: kvp.Key.bytesQueuedOut < 1000000 && kvp.Value.position < kvp.Value.sha256sums.Length
Magic Number,DarkMultiPlayerServer.Messages,Handshake,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Messages\Handshake.cs,SendHandshakeChallange,The following statement contains a magic number: client.challange = new byte[1024];
Magic Number,DarkMultiPlayerServer.Messages,Handshake,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Messages\Handshake.cs,HandleHandshakeResponse,The following statement contains a magic number: Thread.Sleep(1000);
Magic Number,DarkMultiPlayerServer.Messages,Handshake,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Messages\Handshake.cs,HandleHandshakeResponse,The following statement contains a magic number: devClientVersion = client.clientVersion.Substring(0' 7);
Magic Number,DarkMultiPlayerServer.Messages,Handshake,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Messages\Handshake.cs,HandleHandshakeResponse,The following statement contains a magic number: client.clientVersion.Length == 40
Magic Number,DarkMultiPlayerServer.Messages,FlagSync,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Messages\FlagSync.cs,HandleFlagSync,The following statement contains a magic number: switch (messageType)                  {                      case FlagMessageType.LIST:                          {                              //Send the list back                              List<string> serverFlagFileNames = new List<string>();                              List<string> serverFlagOwners = new List<string>();                              List<string> serverFlagShaSums = new List<string>();                                string[] clientFlags = mr.Read<string[]>();                              string[] clientFlagShas = mr.Read<string[]>();                              string[] serverFlags = Directory.GetFiles(flagPath' "*"' SearchOption.AllDirectories);                              foreach (string serverFlag in serverFlags)                              {                                  string trimmedName = Path.GetFileName(serverFlag);                                  string flagOwnerPath = Path.GetDirectoryName(serverFlag);                                  string flagOwner = flagOwnerPath.Substring(Path.GetDirectoryName(flagOwnerPath).Length + 1);                                  bool isMatched = false;                                  bool shaDifferent = false;                                  for (int i = 0; i < clientFlags.Length; i++)                                  {                                      if (clientFlags[i].ToLower() == trimmedName.ToLower())                                      {                                          isMatched = true;                                          shaDifferent = (Common.CalculateSHA256Hash(serverFlag) != clientFlagShas[i]);                                      }                                  }                                  if (!isMatched || shaDifferent)                                  {                                      if (flagOwner == client.playerName)                                      {                                          DarkLog.Debug("Deleting flag " + trimmedName);                                          File.Delete(serverFlag);                                          ServerMessage newMessage = new ServerMessage();                                          newMessage.type = ServerMessageType.FLAG_SYNC;                                          using (MessageWriter mw = new MessageWriter())                                          {                                              mw.Write<int>((int)FlagMessageType.DELETE_FILE);                                              mw.Write<string>(trimmedName);                                              newMessage.data = mw.GetMessageBytes();                                              ClientHandler.SendToAll(client' newMessage' false);                                          }                                          if (Directory.GetFiles(flagOwnerPath).Length == 0)                                          {                                              Directory.Delete(flagOwnerPath);                                          }                                      }                                      else                                      {                                          DarkLog.Debug("Sending flag " + serverFlag + " from " + flagOwner + " to " + client.playerName);                                          ServerMessage newMessage = new ServerMessage();                                          newMessage.type = ServerMessageType.FLAG_SYNC;                                          using (MessageWriter mw = new MessageWriter())                                          {                                              mw.Write<int>((int)FlagMessageType.FLAG_DATA);                                              mw.Write<string>(flagOwner);                                              mw.Write<string>(trimmedName);                                              mw.Write<byte[]>(File.ReadAllBytes(serverFlag));                                              newMessage.data = mw.GetMessageBytes();                                              ClientHandler.SendToClient(client' newMessage' false);                                          }                                      }                                  }                                  //Don't tell the client we have a different copy of the flag so it is reuploaded                                  if (File.Exists(serverFlag))                                  {                                      serverFlagFileNames.Add(trimmedName);                                      serverFlagOwners.Add(flagOwner);                                      serverFlagShaSums.Add(Common.CalculateSHA256Hash(serverFlag));                                  }                              }                              ServerMessage listMessage = new ServerMessage();                              listMessage.type = ServerMessageType.FLAG_SYNC;                              using (MessageWriter mw2 = new MessageWriter())                              {                                  mw2.Write<int>((int)FlagMessageType.LIST);                                  mw2.Write<string[]>(serverFlagFileNames.ToArray());                                  mw2.Write<string[]>(serverFlagOwners.ToArray());                                  mw2.Write<string[]>(serverFlagShaSums.ToArray());                                  listMessage.data = mw2.GetMessageBytes();                              }                              ClientHandler.SendToClient(client' listMessage' false);                          }                          break;                      case FlagMessageType.DELETE_FILE:                          {                              string flagName = mr.Read<string>();                              string playerFlagPath = Path.Combine(flagPath' client.playerName);                              if (Directory.Exists(playerFlagPath))                              {                                  string flagFile = Path.Combine(playerFlagPath' flagName);                                  if (File.Exists(flagFile))                                  {                                      File.Delete(flagFile);                                  }                                  if (Directory.GetFiles(playerFlagPath).Length == 0)                                  {                                      Directory.Delete(playerFlagPath);                                  }                              }                              ServerMessage newMessage = new ServerMessage();                              newMessage.type = ServerMessageType.FLAG_SYNC;                              using (MessageWriter mw = new MessageWriter())                              {                                  mw.Write<int>((int)FlagMessageType.DELETE_FILE);                                  mw.Write<string>(flagName);                                  newMessage.data = mw.GetMessageBytes();                              }                              ClientHandler.SendToAll(client' newMessage' false);                          }                          break;                      case FlagMessageType.UPLOAD_FILE:                          {                              string flagName = mr.Read<string>();                              byte[] flagData = mr.Read<byte[]>();                              // Do not save null files                              if (flagData.Length > 0)                              {                                  // Check if the specified file is a valid PNG file                                  byte[] pngSequence = { 137' 80' 78' 71' 13' 10' 26' 10 };                                  if (pngSequence.SequenceEqual(flagData.Take(pngSequence.Length)))                                  {                                      string playerFlagPath = Path.Combine(flagPath' client.playerName);                                        if (!Directory.Exists(playerFlagPath))                                          Directory.CreateDirectory(playerFlagPath);                                        DarkLog.Debug("Saving flag " + flagName + " from " + client.playerName);                                      File.WriteAllBytes(Path.Combine(playerFlagPath' flagName)' flagData);                                        ServerMessage newMessage = new ServerMessage();                                      newMessage.type = ServerMessageType.FLAG_SYNC;                                      using (MessageWriter mw = new MessageWriter())                                      {                                          mw.Write<int>((int)FlagMessageType.FLAG_DATA);                                          mw.Write<string>(client.playerName);                                          mw.Write<string>(flagName);                                          mw.Write<byte[]>(flagData);                                      }                                        ClientHandler.SendToAll(client' newMessage' false);                                  }                              }                          }                          break;                  }
Magic Number,DarkMultiPlayerServer.Messages,FlagSync,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Messages\FlagSync.cs,HandleFlagSync,The following statement contains a magic number: switch (messageType)                  {                      case FlagMessageType.LIST:                          {                              //Send the list back                              List<string> serverFlagFileNames = new List<string>();                              List<string> serverFlagOwners = new List<string>();                              List<string> serverFlagShaSums = new List<string>();                                string[] clientFlags = mr.Read<string[]>();                              string[] clientFlagShas = mr.Read<string[]>();                              string[] serverFlags = Directory.GetFiles(flagPath' "*"' SearchOption.AllDirectories);                              foreach (string serverFlag in serverFlags)                              {                                  string trimmedName = Path.GetFileName(serverFlag);                                  string flagOwnerPath = Path.GetDirectoryName(serverFlag);                                  string flagOwner = flagOwnerPath.Substring(Path.GetDirectoryName(flagOwnerPath).Length + 1);                                  bool isMatched = false;                                  bool shaDifferent = false;                                  for (int i = 0; i < clientFlags.Length; i++)                                  {                                      if (clientFlags[i].ToLower() == trimmedName.ToLower())                                      {                                          isMatched = true;                                          shaDifferent = (Common.CalculateSHA256Hash(serverFlag) != clientFlagShas[i]);                                      }                                  }                                  if (!isMatched || shaDifferent)                                  {                                      if (flagOwner == client.playerName)                                      {                                          DarkLog.Debug("Deleting flag " + trimmedName);                                          File.Delete(serverFlag);                                          ServerMessage newMessage = new ServerMessage();                                          newMessage.type = ServerMessageType.FLAG_SYNC;                                          using (MessageWriter mw = new MessageWriter())                                          {                                              mw.Write<int>((int)FlagMessageType.DELETE_FILE);                                              mw.Write<string>(trimmedName);                                              newMessage.data = mw.GetMessageBytes();                                              ClientHandler.SendToAll(client' newMessage' false);                                          }                                          if (Directory.GetFiles(flagOwnerPath).Length == 0)                                          {                                              Directory.Delete(flagOwnerPath);                                          }                                      }                                      else                                      {                                          DarkLog.Debug("Sending flag " + serverFlag + " from " + flagOwner + " to " + client.playerName);                                          ServerMessage newMessage = new ServerMessage();                                          newMessage.type = ServerMessageType.FLAG_SYNC;                                          using (MessageWriter mw = new MessageWriter())                                          {                                              mw.Write<int>((int)FlagMessageType.FLAG_DATA);                                              mw.Write<string>(flagOwner);                                              mw.Write<string>(trimmedName);                                              mw.Write<byte[]>(File.ReadAllBytes(serverFlag));                                              newMessage.data = mw.GetMessageBytes();                                              ClientHandler.SendToClient(client' newMessage' false);                                          }                                      }                                  }                                  //Don't tell the client we have a different copy of the flag so it is reuploaded                                  if (File.Exists(serverFlag))                                  {                                      serverFlagFileNames.Add(trimmedName);                                      serverFlagOwners.Add(flagOwner);                                      serverFlagShaSums.Add(Common.CalculateSHA256Hash(serverFlag));                                  }                              }                              ServerMessage listMessage = new ServerMessage();                              listMessage.type = ServerMessageType.FLAG_SYNC;                              using (MessageWriter mw2 = new MessageWriter())                              {                                  mw2.Write<int>((int)FlagMessageType.LIST);                                  mw2.Write<string[]>(serverFlagFileNames.ToArray());                                  mw2.Write<string[]>(serverFlagOwners.ToArray());                                  mw2.Write<string[]>(serverFlagShaSums.ToArray());                                  listMessage.data = mw2.GetMessageBytes();                              }                              ClientHandler.SendToClient(client' listMessage' false);                          }                          break;                      case FlagMessageType.DELETE_FILE:                          {                              string flagName = mr.Read<string>();                              string playerFlagPath = Path.Combine(flagPath' client.playerName);                              if (Directory.Exists(playerFlagPath))                              {                                  string flagFile = Path.Combine(playerFlagPath' flagName);                                  if (File.Exists(flagFile))                                  {                                      File.Delete(flagFile);                                  }                                  if (Directory.GetFiles(playerFlagPath).Length == 0)                                  {                                      Directory.Delete(playerFlagPath);                                  }                              }                              ServerMessage newMessage = new ServerMessage();                              newMessage.type = ServerMessageType.FLAG_SYNC;                              using (MessageWriter mw = new MessageWriter())                              {                                  mw.Write<int>((int)FlagMessageType.DELETE_FILE);                                  mw.Write<string>(flagName);                                  newMessage.data = mw.GetMessageBytes();                              }                              ClientHandler.SendToAll(client' newMessage' false);                          }                          break;                      case FlagMessageType.UPLOAD_FILE:                          {                              string flagName = mr.Read<string>();                              byte[] flagData = mr.Read<byte[]>();                              // Do not save null files                              if (flagData.Length > 0)                              {                                  // Check if the specified file is a valid PNG file                                  byte[] pngSequence = { 137' 80' 78' 71' 13' 10' 26' 10 };                                  if (pngSequence.SequenceEqual(flagData.Take(pngSequence.Length)))                                  {                                      string playerFlagPath = Path.Combine(flagPath' client.playerName);                                        if (!Directory.Exists(playerFlagPath))                                          Directory.CreateDirectory(playerFlagPath);                                        DarkLog.Debug("Saving flag " + flagName + " from " + client.playerName);                                      File.WriteAllBytes(Path.Combine(playerFlagPath' flagName)' flagData);                                        ServerMessage newMessage = new ServerMessage();                                      newMessage.type = ServerMessageType.FLAG_SYNC;                                      using (MessageWriter mw = new MessageWriter())                                      {                                          mw.Write<int>((int)FlagMessageType.FLAG_DATA);                                          mw.Write<string>(client.playerName);                                          mw.Write<string>(flagName);                                          mw.Write<byte[]>(flagData);                                      }                                        ClientHandler.SendToAll(client' newMessage' false);                                  }                              }                          }                          break;                  }
Magic Number,DarkMultiPlayerServer.Messages,FlagSync,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Messages\FlagSync.cs,HandleFlagSync,The following statement contains a magic number: switch (messageType)                  {                      case FlagMessageType.LIST:                          {                              //Send the list back                              List<string> serverFlagFileNames = new List<string>();                              List<string> serverFlagOwners = new List<string>();                              List<string> serverFlagShaSums = new List<string>();                                string[] clientFlags = mr.Read<string[]>();                              string[] clientFlagShas = mr.Read<string[]>();                              string[] serverFlags = Directory.GetFiles(flagPath' "*"' SearchOption.AllDirectories);                              foreach (string serverFlag in serverFlags)                              {                                  string trimmedName = Path.GetFileName(serverFlag);                                  string flagOwnerPath = Path.GetDirectoryName(serverFlag);                                  string flagOwner = flagOwnerPath.Substring(Path.GetDirectoryName(flagOwnerPath).Length + 1);                                  bool isMatched = false;                                  bool shaDifferent = false;                                  for (int i = 0; i < clientFlags.Length; i++)                                  {                                      if (clientFlags[i].ToLower() == trimmedName.ToLower())                                      {                                          isMatched = true;                                          shaDifferent = (Common.CalculateSHA256Hash(serverFlag) != clientFlagShas[i]);                                      }                                  }                                  if (!isMatched || shaDifferent)                                  {                                      if (flagOwner == client.playerName)                                      {                                          DarkLog.Debug("Deleting flag " + trimmedName);                                          File.Delete(serverFlag);                                          ServerMessage newMessage = new ServerMessage();                                          newMessage.type = ServerMessageType.FLAG_SYNC;                                          using (MessageWriter mw = new MessageWriter())                                          {                                              mw.Write<int>((int)FlagMessageType.DELETE_FILE);                                              mw.Write<string>(trimmedName);                                              newMessage.data = mw.GetMessageBytes();                                              ClientHandler.SendToAll(client' newMessage' false);                                          }                                          if (Directory.GetFiles(flagOwnerPath).Length == 0)                                          {                                              Directory.Delete(flagOwnerPath);                                          }                                      }                                      else                                      {                                          DarkLog.Debug("Sending flag " + serverFlag + " from " + flagOwner + " to " + client.playerName);                                          ServerMessage newMessage = new ServerMessage();                                          newMessage.type = ServerMessageType.FLAG_SYNC;                                          using (MessageWriter mw = new MessageWriter())                                          {                                              mw.Write<int>((int)FlagMessageType.FLAG_DATA);                                              mw.Write<string>(flagOwner);                                              mw.Write<string>(trimmedName);                                              mw.Write<byte[]>(File.ReadAllBytes(serverFlag));                                              newMessage.data = mw.GetMessageBytes();                                              ClientHandler.SendToClient(client' newMessage' false);                                          }                                      }                                  }                                  //Don't tell the client we have a different copy of the flag so it is reuploaded                                  if (File.Exists(serverFlag))                                  {                                      serverFlagFileNames.Add(trimmedName);                                      serverFlagOwners.Add(flagOwner);                                      serverFlagShaSums.Add(Common.CalculateSHA256Hash(serverFlag));                                  }                              }                              ServerMessage listMessage = new ServerMessage();                              listMessage.type = ServerMessageType.FLAG_SYNC;                              using (MessageWriter mw2 = new MessageWriter())                              {                                  mw2.Write<int>((int)FlagMessageType.LIST);                                  mw2.Write<string[]>(serverFlagFileNames.ToArray());                                  mw2.Write<string[]>(serverFlagOwners.ToArray());                                  mw2.Write<string[]>(serverFlagShaSums.ToArray());                                  listMessage.data = mw2.GetMessageBytes();                              }                              ClientHandler.SendToClient(client' listMessage' false);                          }                          break;                      case FlagMessageType.DELETE_FILE:                          {                              string flagName = mr.Read<string>();                              string playerFlagPath = Path.Combine(flagPath' client.playerName);                              if (Directory.Exists(playerFlagPath))                              {                                  string flagFile = Path.Combine(playerFlagPath' flagName);                                  if (File.Exists(flagFile))                                  {                                      File.Delete(flagFile);                                  }                                  if (Directory.GetFiles(playerFlagPath).Length == 0)                                  {                                      Directory.Delete(playerFlagPath);                                  }                              }                              ServerMessage newMessage = new ServerMessage();                              newMessage.type = ServerMessageType.FLAG_SYNC;                              using (MessageWriter mw = new MessageWriter())                              {                                  mw.Write<int>((int)FlagMessageType.DELETE_FILE);                                  mw.Write<string>(flagName);                                  newMessage.data = mw.GetMessageBytes();                              }                              ClientHandler.SendToAll(client' newMessage' false);                          }                          break;                      case FlagMessageType.UPLOAD_FILE:                          {                              string flagName = mr.Read<string>();                              byte[] flagData = mr.Read<byte[]>();                              // Do not save null files                              if (flagData.Length > 0)                              {                                  // Check if the specified file is a valid PNG file                                  byte[] pngSequence = { 137' 80' 78' 71' 13' 10' 26' 10 };                                  if (pngSequence.SequenceEqual(flagData.Take(pngSequence.Length)))                                  {                                      string playerFlagPath = Path.Combine(flagPath' client.playerName);                                        if (!Directory.Exists(playerFlagPath))                                          Directory.CreateDirectory(playerFlagPath);                                        DarkLog.Debug("Saving flag " + flagName + " from " + client.playerName);                                      File.WriteAllBytes(Path.Combine(playerFlagPath' flagName)' flagData);                                        ServerMessage newMessage = new ServerMessage();                                      newMessage.type = ServerMessageType.FLAG_SYNC;                                      using (MessageWriter mw = new MessageWriter())                                      {                                          mw.Write<int>((int)FlagMessageType.FLAG_DATA);                                          mw.Write<string>(client.playerName);                                          mw.Write<string>(flagName);                                          mw.Write<byte[]>(flagData);                                      }                                        ClientHandler.SendToAll(client' newMessage' false);                                  }                              }                          }                          break;                  }
Magic Number,DarkMultiPlayerServer.Messages,FlagSync,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Messages\FlagSync.cs,HandleFlagSync,The following statement contains a magic number: switch (messageType)                  {                      case FlagMessageType.LIST:                          {                              //Send the list back                              List<string> serverFlagFileNames = new List<string>();                              List<string> serverFlagOwners = new List<string>();                              List<string> serverFlagShaSums = new List<string>();                                string[] clientFlags = mr.Read<string[]>();                              string[] clientFlagShas = mr.Read<string[]>();                              string[] serverFlags = Directory.GetFiles(flagPath' "*"' SearchOption.AllDirectories);                              foreach (string serverFlag in serverFlags)                              {                                  string trimmedName = Path.GetFileName(serverFlag);                                  string flagOwnerPath = Path.GetDirectoryName(serverFlag);                                  string flagOwner = flagOwnerPath.Substring(Path.GetDirectoryName(flagOwnerPath).Length + 1);                                  bool isMatched = false;                                  bool shaDifferent = false;                                  for (int i = 0; i < clientFlags.Length; i++)                                  {                                      if (clientFlags[i].ToLower() == trimmedName.ToLower())                                      {                                          isMatched = true;                                          shaDifferent = (Common.CalculateSHA256Hash(serverFlag) != clientFlagShas[i]);                                      }                                  }                                  if (!isMatched || shaDifferent)                                  {                                      if (flagOwner == client.playerName)                                      {                                          DarkLog.Debug("Deleting flag " + trimmedName);                                          File.Delete(serverFlag);                                          ServerMessage newMessage = new ServerMessage();                                          newMessage.type = ServerMessageType.FLAG_SYNC;                                          using (MessageWriter mw = new MessageWriter())                                          {                                              mw.Write<int>((int)FlagMessageType.DELETE_FILE);                                              mw.Write<string>(trimmedName);                                              newMessage.data = mw.GetMessageBytes();                                              ClientHandler.SendToAll(client' newMessage' false);                                          }                                          if (Directory.GetFiles(flagOwnerPath).Length == 0)                                          {                                              Directory.Delete(flagOwnerPath);                                          }                                      }                                      else                                      {                                          DarkLog.Debug("Sending flag " + serverFlag + " from " + flagOwner + " to " + client.playerName);                                          ServerMessage newMessage = new ServerMessage();                                          newMessage.type = ServerMessageType.FLAG_SYNC;                                          using (MessageWriter mw = new MessageWriter())                                          {                                              mw.Write<int>((int)FlagMessageType.FLAG_DATA);                                              mw.Write<string>(flagOwner);                                              mw.Write<string>(trimmedName);                                              mw.Write<byte[]>(File.ReadAllBytes(serverFlag));                                              newMessage.data = mw.GetMessageBytes();                                              ClientHandler.SendToClient(client' newMessage' false);                                          }                                      }                                  }                                  //Don't tell the client we have a different copy of the flag so it is reuploaded                                  if (File.Exists(serverFlag))                                  {                                      serverFlagFileNames.Add(trimmedName);                                      serverFlagOwners.Add(flagOwner);                                      serverFlagShaSums.Add(Common.CalculateSHA256Hash(serverFlag));                                  }                              }                              ServerMessage listMessage = new ServerMessage();                              listMessage.type = ServerMessageType.FLAG_SYNC;                              using (MessageWriter mw2 = new MessageWriter())                              {                                  mw2.Write<int>((int)FlagMessageType.LIST);                                  mw2.Write<string[]>(serverFlagFileNames.ToArray());                                  mw2.Write<string[]>(serverFlagOwners.ToArray());                                  mw2.Write<string[]>(serverFlagShaSums.ToArray());                                  listMessage.data = mw2.GetMessageBytes();                              }                              ClientHandler.SendToClient(client' listMessage' false);                          }                          break;                      case FlagMessageType.DELETE_FILE:                          {                              string flagName = mr.Read<string>();                              string playerFlagPath = Path.Combine(flagPath' client.playerName);                              if (Directory.Exists(playerFlagPath))                              {                                  string flagFile = Path.Combine(playerFlagPath' flagName);                                  if (File.Exists(flagFile))                                  {                                      File.Delete(flagFile);                                  }                                  if (Directory.GetFiles(playerFlagPath).Length == 0)                                  {                                      Directory.Delete(playerFlagPath);                                  }                              }                              ServerMessage newMessage = new ServerMessage();                              newMessage.type = ServerMessageType.FLAG_SYNC;                              using (MessageWriter mw = new MessageWriter())                              {                                  mw.Write<int>((int)FlagMessageType.DELETE_FILE);                                  mw.Write<string>(flagName);                                  newMessage.data = mw.GetMessageBytes();                              }                              ClientHandler.SendToAll(client' newMessage' false);                          }                          break;                      case FlagMessageType.UPLOAD_FILE:                          {                              string flagName = mr.Read<string>();                              byte[] flagData = mr.Read<byte[]>();                              // Do not save null files                              if (flagData.Length > 0)                              {                                  // Check if the specified file is a valid PNG file                                  byte[] pngSequence = { 137' 80' 78' 71' 13' 10' 26' 10 };                                  if (pngSequence.SequenceEqual(flagData.Take(pngSequence.Length)))                                  {                                      string playerFlagPath = Path.Combine(flagPath' client.playerName);                                        if (!Directory.Exists(playerFlagPath))                                          Directory.CreateDirectory(playerFlagPath);                                        DarkLog.Debug("Saving flag " + flagName + " from " + client.playerName);                                      File.WriteAllBytes(Path.Combine(playerFlagPath' flagName)' flagData);                                        ServerMessage newMessage = new ServerMessage();                                      newMessage.type = ServerMessageType.FLAG_SYNC;                                      using (MessageWriter mw = new MessageWriter())                                      {                                          mw.Write<int>((int)FlagMessageType.FLAG_DATA);                                          mw.Write<string>(client.playerName);                                          mw.Write<string>(flagName);                                          mw.Write<byte[]>(flagData);                                      }                                        ClientHandler.SendToAll(client' newMessage' false);                                  }                              }                          }                          break;                  }
Magic Number,DarkMultiPlayerServer.Messages,FlagSync,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Messages\FlagSync.cs,HandleFlagSync,The following statement contains a magic number: switch (messageType)                  {                      case FlagMessageType.LIST:                          {                              //Send the list back                              List<string> serverFlagFileNames = new List<string>();                              List<string> serverFlagOwners = new List<string>();                              List<string> serverFlagShaSums = new List<string>();                                string[] clientFlags = mr.Read<string[]>();                              string[] clientFlagShas = mr.Read<string[]>();                              string[] serverFlags = Directory.GetFiles(flagPath' "*"' SearchOption.AllDirectories);                              foreach (string serverFlag in serverFlags)                              {                                  string trimmedName = Path.GetFileName(serverFlag);                                  string flagOwnerPath = Path.GetDirectoryName(serverFlag);                                  string flagOwner = flagOwnerPath.Substring(Path.GetDirectoryName(flagOwnerPath).Length + 1);                                  bool isMatched = false;                                  bool shaDifferent = false;                                  for (int i = 0; i < clientFlags.Length; i++)                                  {                                      if (clientFlags[i].ToLower() == trimmedName.ToLower())                                      {                                          isMatched = true;                                          shaDifferent = (Common.CalculateSHA256Hash(serverFlag) != clientFlagShas[i]);                                      }                                  }                                  if (!isMatched || shaDifferent)                                  {                                      if (flagOwner == client.playerName)                                      {                                          DarkLog.Debug("Deleting flag " + trimmedName);                                          File.Delete(serverFlag);                                          ServerMessage newMessage = new ServerMessage();                                          newMessage.type = ServerMessageType.FLAG_SYNC;                                          using (MessageWriter mw = new MessageWriter())                                          {                                              mw.Write<int>((int)FlagMessageType.DELETE_FILE);                                              mw.Write<string>(trimmedName);                                              newMessage.data = mw.GetMessageBytes();                                              ClientHandler.SendToAll(client' newMessage' false);                                          }                                          if (Directory.GetFiles(flagOwnerPath).Length == 0)                                          {                                              Directory.Delete(flagOwnerPath);                                          }                                      }                                      else                                      {                                          DarkLog.Debug("Sending flag " + serverFlag + " from " + flagOwner + " to " + client.playerName);                                          ServerMessage newMessage = new ServerMessage();                                          newMessage.type = ServerMessageType.FLAG_SYNC;                                          using (MessageWriter mw = new MessageWriter())                                          {                                              mw.Write<int>((int)FlagMessageType.FLAG_DATA);                                              mw.Write<string>(flagOwner);                                              mw.Write<string>(trimmedName);                                              mw.Write<byte[]>(File.ReadAllBytes(serverFlag));                                              newMessage.data = mw.GetMessageBytes();                                              ClientHandler.SendToClient(client' newMessage' false);                                          }                                      }                                  }                                  //Don't tell the client we have a different copy of the flag so it is reuploaded                                  if (File.Exists(serverFlag))                                  {                                      serverFlagFileNames.Add(trimmedName);                                      serverFlagOwners.Add(flagOwner);                                      serverFlagShaSums.Add(Common.CalculateSHA256Hash(serverFlag));                                  }                              }                              ServerMessage listMessage = new ServerMessage();                              listMessage.type = ServerMessageType.FLAG_SYNC;                              using (MessageWriter mw2 = new MessageWriter())                              {                                  mw2.Write<int>((int)FlagMessageType.LIST);                                  mw2.Write<string[]>(serverFlagFileNames.ToArray());                                  mw2.Write<string[]>(serverFlagOwners.ToArray());                                  mw2.Write<string[]>(serverFlagShaSums.ToArray());                                  listMessage.data = mw2.GetMessageBytes();                              }                              ClientHandler.SendToClient(client' listMessage' false);                          }                          break;                      case FlagMessageType.DELETE_FILE:                          {                              string flagName = mr.Read<string>();                              string playerFlagPath = Path.Combine(flagPath' client.playerName);                              if (Directory.Exists(playerFlagPath))                              {                                  string flagFile = Path.Combine(playerFlagPath' flagName);                                  if (File.Exists(flagFile))                                  {                                      File.Delete(flagFile);                                  }                                  if (Directory.GetFiles(playerFlagPath).Length == 0)                                  {                                      Directory.Delete(playerFlagPath);                                  }                              }                              ServerMessage newMessage = new ServerMessage();                              newMessage.type = ServerMessageType.FLAG_SYNC;                              using (MessageWriter mw = new MessageWriter())                              {                                  mw.Write<int>((int)FlagMessageType.DELETE_FILE);                                  mw.Write<string>(flagName);                                  newMessage.data = mw.GetMessageBytes();                              }                              ClientHandler.SendToAll(client' newMessage' false);                          }                          break;                      case FlagMessageType.UPLOAD_FILE:                          {                              string flagName = mr.Read<string>();                              byte[] flagData = mr.Read<byte[]>();                              // Do not save null files                              if (flagData.Length > 0)                              {                                  // Check if the specified file is a valid PNG file                                  byte[] pngSequence = { 137' 80' 78' 71' 13' 10' 26' 10 };                                  if (pngSequence.SequenceEqual(flagData.Take(pngSequence.Length)))                                  {                                      string playerFlagPath = Path.Combine(flagPath' client.playerName);                                        if (!Directory.Exists(playerFlagPath))                                          Directory.CreateDirectory(playerFlagPath);                                        DarkLog.Debug("Saving flag " + flagName + " from " + client.playerName);                                      File.WriteAllBytes(Path.Combine(playerFlagPath' flagName)' flagData);                                        ServerMessage newMessage = new ServerMessage();                                      newMessage.type = ServerMessageType.FLAG_SYNC;                                      using (MessageWriter mw = new MessageWriter())                                      {                                          mw.Write<int>((int)FlagMessageType.FLAG_DATA);                                          mw.Write<string>(client.playerName);                                          mw.Write<string>(flagName);                                          mw.Write<byte[]>(flagData);                                      }                                        ClientHandler.SendToAll(client' newMessage' false);                                  }                              }                          }                          break;                  }
Magic Number,DarkMultiPlayerServer.Messages,FlagSync,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Messages\FlagSync.cs,HandleFlagSync,The following statement contains a magic number: switch (messageType)                  {                      case FlagMessageType.LIST:                          {                              //Send the list back                              List<string> serverFlagFileNames = new List<string>();                              List<string> serverFlagOwners = new List<string>();                              List<string> serverFlagShaSums = new List<string>();                                string[] clientFlags = mr.Read<string[]>();                              string[] clientFlagShas = mr.Read<string[]>();                              string[] serverFlags = Directory.GetFiles(flagPath' "*"' SearchOption.AllDirectories);                              foreach (string serverFlag in serverFlags)                              {                                  string trimmedName = Path.GetFileName(serverFlag);                                  string flagOwnerPath = Path.GetDirectoryName(serverFlag);                                  string flagOwner = flagOwnerPath.Substring(Path.GetDirectoryName(flagOwnerPath).Length + 1);                                  bool isMatched = false;                                  bool shaDifferent = false;                                  for (int i = 0; i < clientFlags.Length; i++)                                  {                                      if (clientFlags[i].ToLower() == trimmedName.ToLower())                                      {                                          isMatched = true;                                          shaDifferent = (Common.CalculateSHA256Hash(serverFlag) != clientFlagShas[i]);                                      }                                  }                                  if (!isMatched || shaDifferent)                                  {                                      if (flagOwner == client.playerName)                                      {                                          DarkLog.Debug("Deleting flag " + trimmedName);                                          File.Delete(serverFlag);                                          ServerMessage newMessage = new ServerMessage();                                          newMessage.type = ServerMessageType.FLAG_SYNC;                                          using (MessageWriter mw = new MessageWriter())                                          {                                              mw.Write<int>((int)FlagMessageType.DELETE_FILE);                                              mw.Write<string>(trimmedName);                                              newMessage.data = mw.GetMessageBytes();                                              ClientHandler.SendToAll(client' newMessage' false);                                          }                                          if (Directory.GetFiles(flagOwnerPath).Length == 0)                                          {                                              Directory.Delete(flagOwnerPath);                                          }                                      }                                      else                                      {                                          DarkLog.Debug("Sending flag " + serverFlag + " from " + flagOwner + " to " + client.playerName);                                          ServerMessage newMessage = new ServerMessage();                                          newMessage.type = ServerMessageType.FLAG_SYNC;                                          using (MessageWriter mw = new MessageWriter())                                          {                                              mw.Write<int>((int)FlagMessageType.FLAG_DATA);                                              mw.Write<string>(flagOwner);                                              mw.Write<string>(trimmedName);                                              mw.Write<byte[]>(File.ReadAllBytes(serverFlag));                                              newMessage.data = mw.GetMessageBytes();                                              ClientHandler.SendToClient(client' newMessage' false);                                          }                                      }                                  }                                  //Don't tell the client we have a different copy of the flag so it is reuploaded                                  if (File.Exists(serverFlag))                                  {                                      serverFlagFileNames.Add(trimmedName);                                      serverFlagOwners.Add(flagOwner);                                      serverFlagShaSums.Add(Common.CalculateSHA256Hash(serverFlag));                                  }                              }                              ServerMessage listMessage = new ServerMessage();                              listMessage.type = ServerMessageType.FLAG_SYNC;                              using (MessageWriter mw2 = new MessageWriter())                              {                                  mw2.Write<int>((int)FlagMessageType.LIST);                                  mw2.Write<string[]>(serverFlagFileNames.ToArray());                                  mw2.Write<string[]>(serverFlagOwners.ToArray());                                  mw2.Write<string[]>(serverFlagShaSums.ToArray());                                  listMessage.data = mw2.GetMessageBytes();                              }                              ClientHandler.SendToClient(client' listMessage' false);                          }                          break;                      case FlagMessageType.DELETE_FILE:                          {                              string flagName = mr.Read<string>();                              string playerFlagPath = Path.Combine(flagPath' client.playerName);                              if (Directory.Exists(playerFlagPath))                              {                                  string flagFile = Path.Combine(playerFlagPath' flagName);                                  if (File.Exists(flagFile))                                  {                                      File.Delete(flagFile);                                  }                                  if (Directory.GetFiles(playerFlagPath).Length == 0)                                  {                                      Directory.Delete(playerFlagPath);                                  }                              }                              ServerMessage newMessage = new ServerMessage();                              newMessage.type = ServerMessageType.FLAG_SYNC;                              using (MessageWriter mw = new MessageWriter())                              {                                  mw.Write<int>((int)FlagMessageType.DELETE_FILE);                                  mw.Write<string>(flagName);                                  newMessage.data = mw.GetMessageBytes();                              }                              ClientHandler.SendToAll(client' newMessage' false);                          }                          break;                      case FlagMessageType.UPLOAD_FILE:                          {                              string flagName = mr.Read<string>();                              byte[] flagData = mr.Read<byte[]>();                              // Do not save null files                              if (flagData.Length > 0)                              {                                  // Check if the specified file is a valid PNG file                                  byte[] pngSequence = { 137' 80' 78' 71' 13' 10' 26' 10 };                                  if (pngSequence.SequenceEqual(flagData.Take(pngSequence.Length)))                                  {                                      string playerFlagPath = Path.Combine(flagPath' client.playerName);                                        if (!Directory.Exists(playerFlagPath))                                          Directory.CreateDirectory(playerFlagPath);                                        DarkLog.Debug("Saving flag " + flagName + " from " + client.playerName);                                      File.WriteAllBytes(Path.Combine(playerFlagPath' flagName)' flagData);                                        ServerMessage newMessage = new ServerMessage();                                      newMessage.type = ServerMessageType.FLAG_SYNC;                                      using (MessageWriter mw = new MessageWriter())                                      {                                          mw.Write<int>((int)FlagMessageType.FLAG_DATA);                                          mw.Write<string>(client.playerName);                                          mw.Write<string>(flagName);                                          mw.Write<byte[]>(flagData);                                      }                                        ClientHandler.SendToAll(client' newMessage' false);                                  }                              }                          }                          break;                  }
Magic Number,DarkMultiPlayerServer.Messages,FlagSync,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Messages\FlagSync.cs,HandleFlagSync,The following statement contains a magic number: switch (messageType)                  {                      case FlagMessageType.LIST:                          {                              //Send the list back                              List<string> serverFlagFileNames = new List<string>();                              List<string> serverFlagOwners = new List<string>();                              List<string> serverFlagShaSums = new List<string>();                                string[] clientFlags = mr.Read<string[]>();                              string[] clientFlagShas = mr.Read<string[]>();                              string[] serverFlags = Directory.GetFiles(flagPath' "*"' SearchOption.AllDirectories);                              foreach (string serverFlag in serverFlags)                              {                                  string trimmedName = Path.GetFileName(serverFlag);                                  string flagOwnerPath = Path.GetDirectoryName(serverFlag);                                  string flagOwner = flagOwnerPath.Substring(Path.GetDirectoryName(flagOwnerPath).Length + 1);                                  bool isMatched = false;                                  bool shaDifferent = false;                                  for (int i = 0; i < clientFlags.Length; i++)                                  {                                      if (clientFlags[i].ToLower() == trimmedName.ToLower())                                      {                                          isMatched = true;                                          shaDifferent = (Common.CalculateSHA256Hash(serverFlag) != clientFlagShas[i]);                                      }                                  }                                  if (!isMatched || shaDifferent)                                  {                                      if (flagOwner == client.playerName)                                      {                                          DarkLog.Debug("Deleting flag " + trimmedName);                                          File.Delete(serverFlag);                                          ServerMessage newMessage = new ServerMessage();                                          newMessage.type = ServerMessageType.FLAG_SYNC;                                          using (MessageWriter mw = new MessageWriter())                                          {                                              mw.Write<int>((int)FlagMessageType.DELETE_FILE);                                              mw.Write<string>(trimmedName);                                              newMessage.data = mw.GetMessageBytes();                                              ClientHandler.SendToAll(client' newMessage' false);                                          }                                          if (Directory.GetFiles(flagOwnerPath).Length == 0)                                          {                                              Directory.Delete(flagOwnerPath);                                          }                                      }                                      else                                      {                                          DarkLog.Debug("Sending flag " + serverFlag + " from " + flagOwner + " to " + client.playerName);                                          ServerMessage newMessage = new ServerMessage();                                          newMessage.type = ServerMessageType.FLAG_SYNC;                                          using (MessageWriter mw = new MessageWriter())                                          {                                              mw.Write<int>((int)FlagMessageType.FLAG_DATA);                                              mw.Write<string>(flagOwner);                                              mw.Write<string>(trimmedName);                                              mw.Write<byte[]>(File.ReadAllBytes(serverFlag));                                              newMessage.data = mw.GetMessageBytes();                                              ClientHandler.SendToClient(client' newMessage' false);                                          }                                      }                                  }                                  //Don't tell the client we have a different copy of the flag so it is reuploaded                                  if (File.Exists(serverFlag))                                  {                                      serverFlagFileNames.Add(trimmedName);                                      serverFlagOwners.Add(flagOwner);                                      serverFlagShaSums.Add(Common.CalculateSHA256Hash(serverFlag));                                  }                              }                              ServerMessage listMessage = new ServerMessage();                              listMessage.type = ServerMessageType.FLAG_SYNC;                              using (MessageWriter mw2 = new MessageWriter())                              {                                  mw2.Write<int>((int)FlagMessageType.LIST);                                  mw2.Write<string[]>(serverFlagFileNames.ToArray());                                  mw2.Write<string[]>(serverFlagOwners.ToArray());                                  mw2.Write<string[]>(serverFlagShaSums.ToArray());                                  listMessage.data = mw2.GetMessageBytes();                              }                              ClientHandler.SendToClient(client' listMessage' false);                          }                          break;                      case FlagMessageType.DELETE_FILE:                          {                              string flagName = mr.Read<string>();                              string playerFlagPath = Path.Combine(flagPath' client.playerName);                              if (Directory.Exists(playerFlagPath))                              {                                  string flagFile = Path.Combine(playerFlagPath' flagName);                                  if (File.Exists(flagFile))                                  {                                      File.Delete(flagFile);                                  }                                  if (Directory.GetFiles(playerFlagPath).Length == 0)                                  {                                      Directory.Delete(playerFlagPath);                                  }                              }                              ServerMessage newMessage = new ServerMessage();                              newMessage.type = ServerMessageType.FLAG_SYNC;                              using (MessageWriter mw = new MessageWriter())                              {                                  mw.Write<int>((int)FlagMessageType.DELETE_FILE);                                  mw.Write<string>(flagName);                                  newMessage.data = mw.GetMessageBytes();                              }                              ClientHandler.SendToAll(client' newMessage' false);                          }                          break;                      case FlagMessageType.UPLOAD_FILE:                          {                              string flagName = mr.Read<string>();                              byte[] flagData = mr.Read<byte[]>();                              // Do not save null files                              if (flagData.Length > 0)                              {                                  // Check if the specified file is a valid PNG file                                  byte[] pngSequence = { 137' 80' 78' 71' 13' 10' 26' 10 };                                  if (pngSequence.SequenceEqual(flagData.Take(pngSequence.Length)))                                  {                                      string playerFlagPath = Path.Combine(flagPath' client.playerName);                                        if (!Directory.Exists(playerFlagPath))                                          Directory.CreateDirectory(playerFlagPath);                                        DarkLog.Debug("Saving flag " + flagName + " from " + client.playerName);                                      File.WriteAllBytes(Path.Combine(playerFlagPath' flagName)' flagData);                                        ServerMessage newMessage = new ServerMessage();                                      newMessage.type = ServerMessageType.FLAG_SYNC;                                      using (MessageWriter mw = new MessageWriter())                                      {                                          mw.Write<int>((int)FlagMessageType.FLAG_DATA);                                          mw.Write<string>(client.playerName);                                          mw.Write<string>(flagName);                                          mw.Write<byte[]>(flagData);                                      }                                        ClientHandler.SendToAll(client' newMessage' false);                                  }                              }                          }                          break;                  }
Magic Number,DarkMultiPlayerServer.Messages,FlagSync,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Messages\FlagSync.cs,HandleFlagSync,The following statement contains a magic number: switch (messageType)                  {                      case FlagMessageType.LIST:                          {                              //Send the list back                              List<string> serverFlagFileNames = new List<string>();                              List<string> serverFlagOwners = new List<string>();                              List<string> serverFlagShaSums = new List<string>();                                string[] clientFlags = mr.Read<string[]>();                              string[] clientFlagShas = mr.Read<string[]>();                              string[] serverFlags = Directory.GetFiles(flagPath' "*"' SearchOption.AllDirectories);                              foreach (string serverFlag in serverFlags)                              {                                  string trimmedName = Path.GetFileName(serverFlag);                                  string flagOwnerPath = Path.GetDirectoryName(serverFlag);                                  string flagOwner = flagOwnerPath.Substring(Path.GetDirectoryName(flagOwnerPath).Length + 1);                                  bool isMatched = false;                                  bool shaDifferent = false;                                  for (int i = 0; i < clientFlags.Length; i++)                                  {                                      if (clientFlags[i].ToLower() == trimmedName.ToLower())                                      {                                          isMatched = true;                                          shaDifferent = (Common.CalculateSHA256Hash(serverFlag) != clientFlagShas[i]);                                      }                                  }                                  if (!isMatched || shaDifferent)                                  {                                      if (flagOwner == client.playerName)                                      {                                          DarkLog.Debug("Deleting flag " + trimmedName);                                          File.Delete(serverFlag);                                          ServerMessage newMessage = new ServerMessage();                                          newMessage.type = ServerMessageType.FLAG_SYNC;                                          using (MessageWriter mw = new MessageWriter())                                          {                                              mw.Write<int>((int)FlagMessageType.DELETE_FILE);                                              mw.Write<string>(trimmedName);                                              newMessage.data = mw.GetMessageBytes();                                              ClientHandler.SendToAll(client' newMessage' false);                                          }                                          if (Directory.GetFiles(flagOwnerPath).Length == 0)                                          {                                              Directory.Delete(flagOwnerPath);                                          }                                      }                                      else                                      {                                          DarkLog.Debug("Sending flag " + serverFlag + " from " + flagOwner + " to " + client.playerName);                                          ServerMessage newMessage = new ServerMessage();                                          newMessage.type = ServerMessageType.FLAG_SYNC;                                          using (MessageWriter mw = new MessageWriter())                                          {                                              mw.Write<int>((int)FlagMessageType.FLAG_DATA);                                              mw.Write<string>(flagOwner);                                              mw.Write<string>(trimmedName);                                              mw.Write<byte[]>(File.ReadAllBytes(serverFlag));                                              newMessage.data = mw.GetMessageBytes();                                              ClientHandler.SendToClient(client' newMessage' false);                                          }                                      }                                  }                                  //Don't tell the client we have a different copy of the flag so it is reuploaded                                  if (File.Exists(serverFlag))                                  {                                      serverFlagFileNames.Add(trimmedName);                                      serverFlagOwners.Add(flagOwner);                                      serverFlagShaSums.Add(Common.CalculateSHA256Hash(serverFlag));                                  }                              }                              ServerMessage listMessage = new ServerMessage();                              listMessage.type = ServerMessageType.FLAG_SYNC;                              using (MessageWriter mw2 = new MessageWriter())                              {                                  mw2.Write<int>((int)FlagMessageType.LIST);                                  mw2.Write<string[]>(serverFlagFileNames.ToArray());                                  mw2.Write<string[]>(serverFlagOwners.ToArray());                                  mw2.Write<string[]>(serverFlagShaSums.ToArray());                                  listMessage.data = mw2.GetMessageBytes();                              }                              ClientHandler.SendToClient(client' listMessage' false);                          }                          break;                      case FlagMessageType.DELETE_FILE:                          {                              string flagName = mr.Read<string>();                              string playerFlagPath = Path.Combine(flagPath' client.playerName);                              if (Directory.Exists(playerFlagPath))                              {                                  string flagFile = Path.Combine(playerFlagPath' flagName);                                  if (File.Exists(flagFile))                                  {                                      File.Delete(flagFile);                                  }                                  if (Directory.GetFiles(playerFlagPath).Length == 0)                                  {                                      Directory.Delete(playerFlagPath);                                  }                              }                              ServerMessage newMessage = new ServerMessage();                              newMessage.type = ServerMessageType.FLAG_SYNC;                              using (MessageWriter mw = new MessageWriter())                              {                                  mw.Write<int>((int)FlagMessageType.DELETE_FILE);                                  mw.Write<string>(flagName);                                  newMessage.data = mw.GetMessageBytes();                              }                              ClientHandler.SendToAll(client' newMessage' false);                          }                          break;                      case FlagMessageType.UPLOAD_FILE:                          {                              string flagName = mr.Read<string>();                              byte[] flagData = mr.Read<byte[]>();                              // Do not save null files                              if (flagData.Length > 0)                              {                                  // Check if the specified file is a valid PNG file                                  byte[] pngSequence = { 137' 80' 78' 71' 13' 10' 26' 10 };                                  if (pngSequence.SequenceEqual(flagData.Take(pngSequence.Length)))                                  {                                      string playerFlagPath = Path.Combine(flagPath' client.playerName);                                        if (!Directory.Exists(playerFlagPath))                                          Directory.CreateDirectory(playerFlagPath);                                        DarkLog.Debug("Saving flag " + flagName + " from " + client.playerName);                                      File.WriteAllBytes(Path.Combine(playerFlagPath' flagName)' flagData);                                        ServerMessage newMessage = new ServerMessage();                                      newMessage.type = ServerMessageType.FLAG_SYNC;                                      using (MessageWriter mw = new MessageWriter())                                      {                                          mw.Write<int>((int)FlagMessageType.FLAG_DATA);                                          mw.Write<string>(client.playerName);                                          mw.Write<string>(flagName);                                          mw.Write<byte[]>(flagData);                                      }                                        ClientHandler.SendToAll(client' newMessage' false);                                  }                              }                          }                          break;                  }
Magic Number,DarkMultiPlayerServer.Messages,WarpControl,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Messages\WarpControl.cs,HandleRequestController,The following statement contains a magic number: warpTimeout = DateTime.UtcNow.Ticks + (long)(MAX_WARP_TIME * 10000000);
Magic Number,DarkMultiPlayerServer.Messages,WarpControl,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Messages\WarpControl.cs,HandleRequestController,The following statement contains a magic number: warpTimeout = DateTime.UtcNow.Ticks + (long)(MAX_WARP_TIME * 10000000);
Magic Number,DarkMultiPlayerServer.Messages,WarpControl,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Messages\WarpControl.cs,HandleReplyVote,The following statement contains a magic number: warpTimeout = DateTime.UtcNow.Ticks + (long)(MAX_WARP_TIME * 10000000);
Magic Number,DarkMultiPlayerServer.Messages,WarpControl,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Messages\WarpControl.cs,HandleReportRate,The following statement contains a magic number: newSubspaceRate = 0.3f;
Magic Number,DarkMultiPlayerServer.Messages,WarpControl,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Messages\WarpControl.cs,HandleReportRate,The following statement contains a magic number: newSubspaceRate < 0.3f
Magic Number,DarkMultiPlayerServer.Messages,WarpControl,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Messages\WarpControl.cs,HandleReportRate,The following statement contains a magic number: Math.Abs(subspaces[reportedSubspace].subspaceSpeed - newSubspaceRate) > 0.03f
Magic Number,DarkMultiPlayerServer.Messages,WarpControl,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Messages\WarpControl.cs,GetLatestSubspace,The following statement contains a magic number: double currentPlanetTime = subspace.Value.planetTime + (((currentTime - subspace.Value.serverClock) / 10000000) * subspace.Value.subspaceSpeed);
Magic Number,DarkMultiPlayerServer.Messages,WarpControl,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Messages\WarpControl.cs,UpdateSubspace,The following statement contains a magic number: float timeSinceLock = (DateTime.UtcNow.Ticks - subspaces[subspaceID].serverClock) / 10000000f;
Magic Number,DarkMultiPlayerServer.Messages,WarpControl,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Messages\WarpControl.cs,DisconnectPlayer,The following statement contains a magic number: double timeDelta = ((DateTime.UtcNow.Ticks - clientSubspace.serverClock) / 10000000d) * clientSubspace.subspaceSpeed;
Missing Default,DarkMultiPlayerServer.Messages,Chat,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Messages\Chat.cs,HandleChatMessage,The following switch statement is missing a default case: switch (messageType)                  {                      case ChatMessageType.JOIN:                          {                              string joinChannel = mr.Read<string>();                              if (!playerChatChannels.ContainsKey(fromPlayer))                              {                                  playerChatChannels.Add(fromPlayer' new List<string>());                              }                              if (!playerChatChannels[fromPlayer].Contains(joinChannel))                              {                                  playerChatChannels[fromPlayer].Add(joinChannel);                              }                              DarkLog.Debug(fromPlayer + " joined channel: " + joinChannel);                          }                          ClientHandler.SendToAll(client' newMessage' true);                          break;                      case ChatMessageType.LEAVE:                          {                              string leaveChannel = mr.Read<string>();                              if (playerChatChannels.ContainsKey(fromPlayer))                              {                                  if (playerChatChannels[fromPlayer].Contains(leaveChannel))                                  {                                      playerChatChannels[fromPlayer].Remove(leaveChannel);                                  }                                  if (playerChatChannels[fromPlayer].Count == 0)                                  {                                      playerChatChannels.Remove(fromPlayer);                                  }                              }                              DarkLog.Debug(fromPlayer + " left channel: " + leaveChannel);                          }                          ClientHandler.SendToAll(client' newMessage' true);                          break;                      case ChatMessageType.CHANNEL_MESSAGE:                          {                              string channel = mr.Read<string>();                              string message = mr.Read<string>();                              if (channel != "")                              {                                  foreach (KeyValuePair<string' List<string>> playerEntry in playerChatChannels)                                  {                                      if (playerEntry.Value.Contains(channel))                                      {                                          ClientObject findClient = ClientHandler.GetClientByName(playerEntry.Key);                                          if (findClient != null)                                          {                                              ClientHandler.SendToClient(findClient' newMessage' true);                                          }                                      }                                  }                                  DarkLog.ChatMessage(fromPlayer + " -> #" + channel + ": " + message);                              }                              else                              {                                  ClientHandler.SendToClient(client' newMessage' true);                                  ClientHandler.SendToAll(client' newMessage' true);                                  DarkLog.ChatMessage(fromPlayer + " -> #Global: " + message);                              }                          }                          break;                      case ChatMessageType.PRIVATE_MESSAGE:                          {                              string toPlayer = mr.Read<string>();                              string message = mr.Read<string>();                              if (toPlayer != Settings.settingsStore.consoleIdentifier)                              {                                  ClientObject findClient = ClientHandler.GetClientByName(toPlayer);                                  if (findClient != null)                                  {                                      ClientHandler.SendToClient(client' newMessage' true);                                      ClientHandler.SendToClient(findClient' newMessage' true);                                      DarkLog.ChatMessage(fromPlayer + " -> @" + toPlayer + ": " + message);                                  }                                  {                                      DarkLog.ChatMessage(fromPlayer + " -X-> @" + toPlayer + ": " + message);                                  }                              }                              else                              {                                  ClientHandler.SendToClient(client' newMessage' true);                                  DarkLog.ChatMessage(fromPlayer + " -> @" + toPlayer + ": " + message);                              }                          }                          break;                      case ChatMessageType.CONSOLE_MESSAGE:                          {                              string message = mr.Read<string>();                              if (client.authenticated && DarkMultiPlayerServer.AdminSystem.fetch.IsAdmin(client.playerName))                              {                                  CommandHandler.HandleServerInput(message);                              }                              else                              {                                  Messages.ConnectionEnd.SendConnectionEnd(client' "Kicked for sending a console command as a non-admin player.");                              }                          }                          break;                  }
Missing Default,DarkMultiPlayerServer.Messages,PlayerColor,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Messages\PlayerColor.cs,HandlePlayerColor,The following switch statement is missing a default case: switch (messageType)                  {                      case PlayerColorMessageType.SET:                          {                              string playerName = mr.Read<string>();                              if (playerName != client.playerName)                              {                                  DarkLog.Debug(client.playerName + " tried to send a color update for " + playerName + "' kicking.");                                  Messages.ConnectionEnd.SendConnectionEnd(client' "Kicked for sending a color update for another player");                                  return;                              }                              client.playerColor = mr.Read<float[]>();                              //Relay the message                              ServerMessage newMessage = new ServerMessage();                              newMessage.type = ServerMessageType.PLAYER_COLOR;                              newMessage.data = messageData;                              ClientHandler.SendToAll(client' newMessage' true);                          }                          break;                  }
Missing Default,DarkMultiPlayerServer.Messages,CraftLibrary,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Messages\CraftLibrary.cs,HandleCraftLibrary,The following switch statement is missing a default case: switch (craftMessageType)                  {                        case CraftMessageType.UPLOAD_FILE:                          {                              CraftType uploadType = (CraftType)mr.Read<int>();                              string uploadName = mr.Read<string>();                              byte[] uploadData = mr.Read<byte[]>();                              string playerPath = Path.Combine(Path.Combine(Server.universeDirectory' "Crafts")' fromPlayer);                              if (!Directory.Exists(playerPath))                              {                                  Directory.CreateDirectory(playerPath);                              }                              string typePath = Path.Combine(playerPath' uploadType.ToString());                              if (!Directory.Exists(typePath))                              {                                  Directory.CreateDirectory(typePath);                              }                              string craftFile = Path.Combine(typePath' uploadName + ".craft");                              File.WriteAllBytes(craftFile' uploadData);                              DarkLog.Debug("Saving " + uploadName + "' type: " + uploadType.ToString() + " from " + fromPlayer);                              using (MessageWriter mw = new MessageWriter())                              {                                  ServerMessage newMessage = new ServerMessage();                                  newMessage.type = ServerMessageType.CRAFT_LIBRARY;                                  mw.Write<int>((int)CraftMessageType.ADD_FILE);                                  mw.Write<string>(fromPlayer);                                  mw.Write<int>((int)uploadType);                                  mw.Write<string>(uploadName);                                  newMessage.data = mw.GetMessageBytes();                                  ClientHandler.SendToAll(client' newMessage' false);                              }                          }                          break;                      case CraftMessageType.REQUEST_FILE:                          {                              string craftOwner = mr.Read<string>();                              CraftType requestedType = (CraftType)mr.Read<int>();                              bool hasCraft = false;                              string requestedName = mr.Read<string>();                              string playerPath = Path.Combine(Path.Combine(Server.universeDirectory' "Crafts")' craftOwner);                              string typePath = Path.Combine(playerPath' requestedType.ToString());                              string craftFile = Path.Combine(typePath' requestedName + ".craft");                              if (Directory.Exists(playerPath))                              {                                  if (Directory.Exists(typePath))                                  {                                      if (File.Exists(craftFile))                                      {                                          hasCraft = true;                                      }                                  }                              }                              ServerMessage newMessage = new ServerMessage();                              newMessage.type = ServerMessageType.CRAFT_LIBRARY;                              using (MessageWriter mw = new MessageWriter())                              {                                  mw.Write<int>((int)CraftMessageType.RESPOND_FILE);                                  mw.Write<string>(craftOwner);                                  mw.Write<int>((int)requestedType);                                  mw.Write<string>(requestedName);                                  mw.Write<bool>(hasCraft);                                  if (hasCraft)                                  {                                      mw.Write<byte[]>(File.ReadAllBytes(craftFile));                                      DarkLog.Debug("Sending " + fromPlayer + " " + requestedName + " from " + craftOwner);                                  }                                  newMessage.data = mw.GetMessageBytes();                              }                              ClientHandler.SendToClient(client' newMessage' false);                          }                          break;                      case CraftMessageType.DELETE_FILE:                          {                              CraftType craftType = (CraftType)mr.Read<int>();                              string craftName = mr.Read<string>();                              string playerPath = Path.Combine(Path.Combine(Server.universeDirectory' "Crafts")' fromPlayer);                              string typePath = Path.Combine(playerPath' craftType.ToString());                              string craftFile = Path.Combine(typePath' craftName + ".craft");                              if (Directory.Exists(playerPath))                              {                                  if (Directory.Exists(typePath))                                  {                                      if (File.Exists(craftFile))                                      {                                          File.Delete(craftFile);                                          DarkLog.Debug("Removing " + craftName + "' type: " + craftType.ToString() + " from " + fromPlayer);                                      }                                  }                              }                              if (Directory.Exists(playerPath))                              {                                  if (Directory.GetFiles(typePath).Length == 0)                                  {                                      Directory.Delete(typePath);                                  }                              }                              if (Directory.GetDirectories(playerPath).Length == 0)                              {                                  Directory.Delete(playerPath);                              }                              //Relay the delete message to other clients                              ServerMessage newMessage = new ServerMessage();                              newMessage.type = ServerMessageType.CRAFT_LIBRARY;                              newMessage.data = messageData;                              ClientHandler.SendToAll(client' newMessage' false);                          }                          break;                  }
Missing Default,DarkMultiPlayerServer.Messages,ScreenshotLibrary,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Messages\ScreenshotLibrary.cs,HandleScreenshotLibrary,The following switch statement is missing a default case: switch (messageType)                  {                      case ScreenshotMessageType.SCREENSHOT:                          {                              if (Settings.settingsStore.screenshotsPerPlayer > -1)                              {                                  string playerScreenshotDirectory = Path.Combine(screenshotDirectory' fromPlayer);                                  if (!Directory.Exists(playerScreenshotDirectory))                                  {                                      Directory.CreateDirectory(playerScreenshotDirectory);                                  }                                  string screenshotFile = Path.Combine(playerScreenshotDirectory' DateTime.Now.ToString("yyyy-MM-dd HH-mm-ss") + ".png");                                  DarkLog.Debug("Saving screenshot from " + fromPlayer);                                    byte[] screenshotData = mr.Read<byte[]>();                                    File.WriteAllBytes(screenshotFile' screenshotData);                                  if (Settings.settingsStore.screenshotsPerPlayer != 0)                                  {                                      while (Directory.GetFiles(playerScreenshotDirectory).Length > Settings.settingsStore.screenshotsPerPlayer)                                      {                                          string[] currentFiles = Directory.GetFiles(playerScreenshotDirectory);                                          string deleteFile = currentFiles[0];                                          //Find oldest file                                          foreach (string testFile in currentFiles)                                          {                                              if (File.GetCreationTime(testFile) < File.GetCreationTime(deleteFile))                                              {                                                  deleteFile = testFile;                                              }                                          }                                          File.Delete(deleteFile);                                          DarkLog.Debug("Removing old screenshot " + Path.GetFileName(deleteFile));                                      }                                  }                                    //Notify players that aren't watching that there's a new screenshot availabe. This only works if there's a file available on the server.                                  //The server does not keep the screenshots in memory.                                  ServerMessage notifyMessage = new ServerMessage();                                  notifyMessage.type = ServerMessageType.SCREENSHOT_LIBRARY;                                  using (MessageWriter mw = new MessageWriter())                                  {                                      mw.Write<int>((int)ScreenshotMessageType.NOTIFY);                                      mw.Write(fromPlayer);                                      notifyMessage.data = mw.GetMessageBytes();                                      ClientHandler.SendToAll(client' notifyMessage' false);                                  }                              }                              if (!playerUploadedScreenshotIndex.ContainsKey(fromPlayer))                              {                                  playerUploadedScreenshotIndex.Add(fromPlayer' 0);                              }                              else                              {                                  playerUploadedScreenshotIndex[fromPlayer]++;                              }                              if (!playerDownloadedScreenshotIndex.ContainsKey(fromPlayer))                              {                                  playerDownloadedScreenshotIndex.Add(fromPlayer' new Dictionary<string' int>());                              }                              if (!playerDownloadedScreenshotIndex[fromPlayer].ContainsKey(fromPlayer))                              {                                  playerDownloadedScreenshotIndex[fromPlayer].Add(fromPlayer' playerUploadedScreenshotIndex[fromPlayer]);                              }                              else                              {                                  playerDownloadedScreenshotIndex[fromPlayer][fromPlayer] = playerUploadedScreenshotIndex[fromPlayer];                              }                              newMessage.data = messageData;                              foreach (KeyValuePair<string' string> entry in playerWatchScreenshot)                              {                                  if (entry.Key != fromPlayer)                                  {                                      if (entry.Value == fromPlayer && entry.Key != client.playerName)                                      {                                          ClientObject toClient = ClientHandler.GetClientByName(entry.Key);                                          if (toClient != null && toClient != client)                                          {                                              if (!playerDownloadedScreenshotIndex.ContainsKey(entry.Key))                                              {                                                  playerDownloadedScreenshotIndex.Add(entry.Key' new Dictionary<string' int>());                                              }                                              if (!playerDownloadedScreenshotIndex[entry.Key].ContainsKey(fromPlayer))                                              {                                                  playerDownloadedScreenshotIndex[entry.Key].Add(fromPlayer' 0);                                              }                                              playerDownloadedScreenshotIndex[entry.Key][fromPlayer] = playerUploadedScreenshotIndex[fromPlayer];                                              DarkLog.Debug("Sending screenshot from " + fromPlayer + " to " + entry.Key);                                              using (MessageWriter mw = new MessageWriter())                                              {                                                  ServerMessage sendStartMessage = new ServerMessage();                                                  sendStartMessage.type = ServerMessageType.SCREENSHOT_LIBRARY;                                                  mw.Write<int>((int)ScreenshotMessageType.SEND_START_NOTIFY);                                                  mw.Write<string>(fromPlayer);                                                  sendStartMessage.data = mw.GetMessageBytes();                                                  ClientHandler.SendToClient(toClient' sendStartMessage' true);                                              }                                              ClientHandler.SendToClient(toClient' newMessage' false);                                          }                                      }                                  }                              }                          }                          break;                      case ScreenshotMessageType.WATCH:                          {                              newMessage.data = messageData;                              string watchPlayer = mr.Read<string>();                              if (watchPlayer == "")                              {                                  if (playerWatchScreenshot.ContainsKey(fromPlayer))                                  {                                      DarkLog.Debug(fromPlayer + " is no longer watching screenshots from " + playerWatchScreenshot[fromPlayer]);                                      playerWatchScreenshot.Remove(fromPlayer);                                  }                              }                              else                              {                                  DarkLog.Debug(fromPlayer + " is watching screenshots from " + watchPlayer);                                  playerWatchScreenshot[fromPlayer] = watchPlayer;                                  if (!playerDownloadedScreenshotIndex.ContainsKey(fromPlayer))                                  {                                      playerDownloadedScreenshotIndex.Add(fromPlayer' new Dictionary<string' int>());                                  }                                  string watchPlayerScreenshotDirectory = Path.Combine(screenshotDirectory' watchPlayer);                                  //Find latest screenshot                                  string sendFile = null;                                  if (Directory.Exists(watchPlayerScreenshotDirectory))                                  {                                      string[] playerScreenshots = Directory.GetFiles(watchPlayerScreenshotDirectory);                                      if (playerScreenshots.Length > 0)                                      {                                          sendFile = playerScreenshots[0];                                          foreach (string testFile in playerScreenshots)                                          {                                              if (File.GetCreationTime(testFile) > File.GetCreationTime(sendFile))                                              {                                                  sendFile = testFile;                                              }                                          }                                          if (!playerUploadedScreenshotIndex.ContainsKey(watchPlayer))                                          {                                              playerUploadedScreenshotIndex.Add(watchPlayer' 0);                                          }                                      }                                  }                                  //Send screenshot if needed                                  if (sendFile != null)                                  {                                      bool sendScreenshot = false;                                      if (!playerDownloadedScreenshotIndex[fromPlayer].ContainsKey(watchPlayer))                                      {                                          playerDownloadedScreenshotIndex[fromPlayer].Add(watchPlayer' playerUploadedScreenshotIndex[watchPlayer]);                                          sendScreenshot = true;                                      }                                      else                                      {                                          if (playerDownloadedScreenshotIndex[fromPlayer][watchPlayer] != playerUploadedScreenshotIndex[watchPlayer])                                          {                                              sendScreenshot = true;                                              playerDownloadedScreenshotIndex[fromPlayer][watchPlayer] = playerUploadedScreenshotIndex[watchPlayer];                                          }                                      }                                      if (sendScreenshot)                                      {                                          ServerMessage sendStartMessage = new ServerMessage();                                          sendStartMessage.type = ServerMessageType.SCREENSHOT_LIBRARY;                                          using (MessageWriter mw = new MessageWriter())                                          {                                              mw.Write<int>((int)ScreenshotMessageType.SEND_START_NOTIFY);                                              mw.Write<string>(fromPlayer);                                              sendStartMessage.data = mw.GetMessageBytes();                                          }                                          ServerMessage screenshotMessage = new ServerMessage();                                          screenshotMessage.type = ServerMessageType.SCREENSHOT_LIBRARY;                                          using (MessageWriter mw = new MessageWriter())                                          {                                              mw.Write<int>((int)ScreenshotMessageType.SCREENSHOT);                                              mw.Write<string>(watchPlayer);                                              mw.Write<byte[]>(File.ReadAllBytes(sendFile));                                              screenshotMessage.data = mw.GetMessageBytes();                                          }                                          ClientObject toClient = ClientHandler.GetClientByName(fromPlayer);                                          if (toClient != null)                                          {                                              DarkLog.Debug("Sending saved screenshot from " + watchPlayer + " to " + fromPlayer);                                              ClientHandler.SendToClient(toClient' sendStartMessage' false);                                              ClientHandler.SendToClient(toClient' screenshotMessage' false);                                          }                                      }                                  }                              }                              //Relay the message                              ClientHandler.SendToAll(client' newMessage' false);                          }                          break;                  }
Missing Default,DarkMultiPlayerServer.Messages,FlagSync,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Messages\FlagSync.cs,HandleFlagSync,The following switch statement is missing a default case: switch (messageType)                  {                      case FlagMessageType.LIST:                          {                              //Send the list back                              List<string> serverFlagFileNames = new List<string>();                              List<string> serverFlagOwners = new List<string>();                              List<string> serverFlagShaSums = new List<string>();                                string[] clientFlags = mr.Read<string[]>();                              string[] clientFlagShas = mr.Read<string[]>();                              string[] serverFlags = Directory.GetFiles(flagPath' "*"' SearchOption.AllDirectories);                              foreach (string serverFlag in serverFlags)                              {                                  string trimmedName = Path.GetFileName(serverFlag);                                  string flagOwnerPath = Path.GetDirectoryName(serverFlag);                                  string flagOwner = flagOwnerPath.Substring(Path.GetDirectoryName(flagOwnerPath).Length + 1);                                  bool isMatched = false;                                  bool shaDifferent = false;                                  for (int i = 0; i < clientFlags.Length; i++)                                  {                                      if (clientFlags[i].ToLower() == trimmedName.ToLower())                                      {                                          isMatched = true;                                          shaDifferent = (Common.CalculateSHA256Hash(serverFlag) != clientFlagShas[i]);                                      }                                  }                                  if (!isMatched || shaDifferent)                                  {                                      if (flagOwner == client.playerName)                                      {                                          DarkLog.Debug("Deleting flag " + trimmedName);                                          File.Delete(serverFlag);                                          ServerMessage newMessage = new ServerMessage();                                          newMessage.type = ServerMessageType.FLAG_SYNC;                                          using (MessageWriter mw = new MessageWriter())                                          {                                              mw.Write<int>((int)FlagMessageType.DELETE_FILE);                                              mw.Write<string>(trimmedName);                                              newMessage.data = mw.GetMessageBytes();                                              ClientHandler.SendToAll(client' newMessage' false);                                          }                                          if (Directory.GetFiles(flagOwnerPath).Length == 0)                                          {                                              Directory.Delete(flagOwnerPath);                                          }                                      }                                      else                                      {                                          DarkLog.Debug("Sending flag " + serverFlag + " from " + flagOwner + " to " + client.playerName);                                          ServerMessage newMessage = new ServerMessage();                                          newMessage.type = ServerMessageType.FLAG_SYNC;                                          using (MessageWriter mw = new MessageWriter())                                          {                                              mw.Write<int>((int)FlagMessageType.FLAG_DATA);                                              mw.Write<string>(flagOwner);                                              mw.Write<string>(trimmedName);                                              mw.Write<byte[]>(File.ReadAllBytes(serverFlag));                                              newMessage.data = mw.GetMessageBytes();                                              ClientHandler.SendToClient(client' newMessage' false);                                          }                                      }                                  }                                  //Don't tell the client we have a different copy of the flag so it is reuploaded                                  if (File.Exists(serverFlag))                                  {                                      serverFlagFileNames.Add(trimmedName);                                      serverFlagOwners.Add(flagOwner);                                      serverFlagShaSums.Add(Common.CalculateSHA256Hash(serverFlag));                                  }                              }                              ServerMessage listMessage = new ServerMessage();                              listMessage.type = ServerMessageType.FLAG_SYNC;                              using (MessageWriter mw2 = new MessageWriter())                              {                                  mw2.Write<int>((int)FlagMessageType.LIST);                                  mw2.Write<string[]>(serverFlagFileNames.ToArray());                                  mw2.Write<string[]>(serverFlagOwners.ToArray());                                  mw2.Write<string[]>(serverFlagShaSums.ToArray());                                  listMessage.data = mw2.GetMessageBytes();                              }                              ClientHandler.SendToClient(client' listMessage' false);                          }                          break;                      case FlagMessageType.DELETE_FILE:                          {                              string flagName = mr.Read<string>();                              string playerFlagPath = Path.Combine(flagPath' client.playerName);                              if (Directory.Exists(playerFlagPath))                              {                                  string flagFile = Path.Combine(playerFlagPath' flagName);                                  if (File.Exists(flagFile))                                  {                                      File.Delete(flagFile);                                  }                                  if (Directory.GetFiles(playerFlagPath).Length == 0)                                  {                                      Directory.Delete(playerFlagPath);                                  }                              }                              ServerMessage newMessage = new ServerMessage();                              newMessage.type = ServerMessageType.FLAG_SYNC;                              using (MessageWriter mw = new MessageWriter())                              {                                  mw.Write<int>((int)FlagMessageType.DELETE_FILE);                                  mw.Write<string>(flagName);                                  newMessage.data = mw.GetMessageBytes();                              }                              ClientHandler.SendToAll(client' newMessage' false);                          }                          break;                      case FlagMessageType.UPLOAD_FILE:                          {                              string flagName = mr.Read<string>();                              byte[] flagData = mr.Read<byte[]>();                              // Do not save null files                              if (flagData.Length > 0)                              {                                  // Check if the specified file is a valid PNG file                                  byte[] pngSequence = { 137' 80' 78' 71' 13' 10' 26' 10 };                                  if (pngSequence.SequenceEqual(flagData.Take(pngSequence.Length)))                                  {                                      string playerFlagPath = Path.Combine(flagPath' client.playerName);                                        if (!Directory.Exists(playerFlagPath))                                          Directory.CreateDirectory(playerFlagPath);                                        DarkLog.Debug("Saving flag " + flagName + " from " + client.playerName);                                      File.WriteAllBytes(Path.Combine(playerFlagPath' flagName)' flagData);                                        ServerMessage newMessage = new ServerMessage();                                      newMessage.type = ServerMessageType.FLAG_SYNC;                                      using (MessageWriter mw = new MessageWriter())                                      {                                          mw.Write<int>((int)FlagMessageType.FLAG_DATA);                                          mw.Write<string>(client.playerName);                                          mw.Write<string>(flagName);                                          mw.Write<byte[]>(flagData);                                      }                                        ClientHandler.SendToAll(client' newMessage' false);                                  }                              }                          }                          break;                  }
Missing Default,DarkMultiPlayerServer.Messages,LockSystem,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Messages\LockSystem.cs,HandleLockSystemMessage,The following switch statement is missing a default case: switch (lockMessageType)                  {                      case LockMessageType.ACQUIRE:                          {                              string playerName = mr.Read<string>();                              string lockName = mr.Read<string>();                              bool force = mr.Read<bool>();                              if (playerName != client.playerName)                              {                                  Messages.ConnectionEnd.SendConnectionEnd(client' "Kicked for sending a lock message for another player");                              }                              bool lockResult = DarkMultiPlayerServer.LockSystem.fetch.AcquireLock(lockName' playerName' force);                              using (MessageWriter mw = new MessageWriter())                              {                                  mw.Write((int)LockMessageType.ACQUIRE);                                  mw.Write(playerName);                                  mw.Write(lockName);                                  mw.Write(lockResult);                                  newMessage.data = mw.GetMessageBytes();                              }                              //Send to all clients                              ClientHandler.SendToAll(null' newMessage' true);                              if (lockResult)                              {                                  DarkLog.Debug(playerName + " acquired lock " + lockName);                              }                              else                              {                                  DarkLog.Debug(playerName + " failed to acquire lock " + lockName);                              }                          }                          break;                      case LockMessageType.RELEASE:                          {                              string playerName = mr.Read<string>();                              string lockName = mr.Read<string>();                              if (playerName != client.playerName)                              {                                  Messages.ConnectionEnd.SendConnectionEnd(client' "Kicked for sending a lock message for another player");                              }                              bool lockResult = DarkMultiPlayerServer.LockSystem.fetch.ReleaseLock(lockName' playerName);                              if (!lockResult)                              {                                  Messages.ConnectionEnd.SendConnectionEnd(client' "Kicked for releasing a lock you do not own");                              }                              else                              {                                  using (MessageWriter mw = new MessageWriter())                                  {                                      mw.Write((int)LockMessageType.RELEASE);                                      mw.Write(playerName);                                      mw.Write(lockName);                                      mw.Write(lockResult);                                      newMessage.data = mw.GetMessageBytes();                                  }                                  //Send to all clients                                  ClientHandler.SendToAll(null' newMessage' true);                              }                              if (lockResult)                              {                                  DarkLog.Debug(playerName + " released lock " + lockName);                              }                              else                              {                                  DarkLog.Debug(playerName + " failed to release lock " + lockName);                              }                          }                          break;                  }
Missing Default,DarkMultiPlayerServer.Messages,GroupMessage,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Messages\GroupMessage.cs,HandleMessage,The following switch statement is missing a default case: switch ((GroupMessageType)type)                  {                      case GroupMessageType.ADD_ADMIN:                          {                                string playerName = mr.Read<string>();                              string groupName = mr.Read<string>();                              if (Groups.fetch.PlayerIsAdmin(client.playerName' groupName))                              {                                  Groups.fetch.AddPlayerAdmin(playerName' groupName);                              }                          }                          break;                      case GroupMessageType.ADD_PLAYER:                          {                              string playerName = mr.Read<string>();                              string groupName = mr.Read<string>();                              if (Groups.fetch.GroupExists(groupName))                              {                                  if (Groups.fetch.PlayerIsAdmin(client.playerName' groupName))                                  {                                      Groups.fetch.AddPlayerToGroup(playerName' groupName);                                  }                              }                              else                              {                                  //We can only add ourselves to new groups.                                  if (playerName == client.playerName)                                  {                                      Groups.fetch.AddPlayerToGroup(playerName' groupName);                                  }                              }                          }                          break;                          case GroupMessageType.REMOVE_ADMIN:                          {                              string playerName = mr.Read<string>();                              string groupName = mr.Read<string>();                              if (Groups.fetch.PlayerIsAdmin(client.playerName' groupName))                              {                                  Groups.fetch.RemovePlayerAdmin(playerName' groupName);                              }                          }                          break;                      case GroupMessageType.REMOVE_PLAYER:                          {                              string playerName = mr.Read<string>();                              string groupName = mr.Read<string>();                              if (playerName == client.playerName || Groups.fetch.PlayerIsAdmin(client.playerName' groupName))                              {                                  Groups.fetch.RemovePlayerFromGroup(playerName' groupName);                              }                          }                          break;                      case GroupMessageType.REMOVE_GROUP:                          {                              string groupName = mr.Read<string>();                              if (Groups.fetch.PlayerIsAdmin(client.playerName' groupName))                              {                                  Groups.fetch.RemoveGroup(groupName);                              }                          }                          break;                      case GroupMessageType.GROUP_REQUEST:                          Messages.GroupMessage.SendGroupsToClient(client);                          break;                  }
Missing Default,DarkMultiPlayerServer.Messages,PermissionMessage,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Messages\PermissionMessage.cs,HandleMessage,The following switch statement is missing a default case: switch ((PermissionMessageType)type)                  {                      case PermissionMessageType.PERMISSION_REQUEST:                          Messages.PermissionMessage.SendVesselPermissionsToClient(client);                          break;                      case PermissionMessageType.SET_OWNER:                          {                              Guid guid = Guid.Parse(mr.Read<string>());                              string owner = mr.Read<string>();                              if (Permissions.fetch.PlayerIsVesselOwner(client.playerName' guid))                              {                                  Permissions.fetch.SetVesselOwner(guid' owner);                              }                          }                          break;                      case PermissionMessageType.SET_GROUP:                          {                              Guid guid = Guid.Parse(mr.Read<string>());                              string group = mr.Read<string>();                              if (Permissions.fetch.PlayerIsVesselOwner(client.playerName' guid))                              {                                  Permissions.fetch.SetVesselGroup(guid' group);                              }                          }                          break;                      case PermissionMessageType.SET_PERMISSION_LEVEL:                          {                              Guid guid = Guid.Parse(mr.Read<string>());                              string permissionLevel = mr.Read<string>();                              VesselProtectionType vesselProtection = (VesselProtectionType)Enum.Parse(typeof(VesselProtectionType)' permissionLevel);                              if (Permissions.fetch.PlayerIsVesselOwner(client.playerName' guid))                              {                                  Permissions.fetch.SetVesselProtection(guid' vesselProtection);                              }                          }                          break;                  }
Missing Default,DarkMultiPlayerServer.Messages,Modpack,D:\research\architectureSmells\repos\godarklight_DarkMultiPlayer\Server\Messages\Modpack.cs,HandleModpackMessage,The following switch statement is missing a default case: switch (type)                  {                      case ModpackDataMessageType.CKAN:                          {                              if (!DarkMultiPlayerServer.AdminSystem.fetch.IsAdmin(client.playerName))                              {                                  ConnectionEnd.SendConnectionEnd(client' "Kicked from the server' non admin " + client.playerName + " tried to upload modpack");                                  return;                              }                              if (Settings.settingsStore.modpackMode != ModpackMode.CKAN)                              {                                  ConnectionEnd.SendConnectionEnd(client' "Please set server modpackMode to CKAN");                                  return;                              }                              byte[] fileBytes = mr.Read<byte[]>();                              ModpackSystem.fetch.SaveCKANData(fileBytes);                          }                          break;                      case ModpackDataMessageType.MOD_LIST:                          {                              if (!DarkMultiPlayerServer.AdminSystem.fetch.IsAdmin(client.playerName))                              {                                  ConnectionEnd.SendConnectionEnd(client' "Kicked from the server' non admin " + client.playerName + " tried to upload modpack");                                  return;                              }                              if (Settings.settingsStore.modpackMode != ModpackMode.GAMEDATA)                              {                                  ConnectionEnd.SendConnectionEnd(client' "Please set server modpackMode to GAMEDATA");                                  return;                              }                              DarkLog.Normal("Modpack uploaded from " + client.playerName);                              string[] files = mr.Read<string[]>();                              string[] sha = mr.Read<string[]>();                              ModpackSystem.fetch.HandleNewGameData(files' sha' client);                          }                          break;                      case ModpackDataMessageType.REQUEST_OBJECT:                          {                              string[] sha256sums = mr.Read<string[]>();                              ModpackSystem.fetch.HandleSendList(client' sha256sums);                          }                          break;                      case ModpackDataMessageType.RESPONSE_OBJECT:                          {                              if (!DarkMultiPlayerServer.AdminSystem.fetch.IsAdmin(client.playerName))                              {                                  ConnectionEnd.SendConnectionEnd(client' "Kicked from the server' non admin " + client.playerName + " tried to upload modpack");                                  return;                              }                              string sha256sum = mr.Read<string>();                              if (mr.Read<bool>())                              {                                  byte[] fileBytes = mr.Read<byte[]>();                                  DarkLog.Debug("Received object: " + sha256sum);                                  ModpackSystem.fetch.SaveModObject(fileBytes' sha256sum);                              }                              else                              {                                  DarkLog.Normal("Failed to recieve: " + sha256sum);                              }                          }                          break;                      case ModpackDataMessageType.MOD_DONE:                          {                              if (!DarkMultiPlayerServer.AdminSystem.fetch.IsAdmin(client.playerName))                              {                                  ConnectionEnd.SendConnectionEnd(client' "Kicked from the server' non admin " + client.playerName + " tried to upload modpack");                                  return;                              }                              //Has gamedata upload                              if (mr.Read<bool>())                              {                                  DarkLog.Debug("Mod control file updated");                                  byte[] newModControl = mr.Read<byte[]>();                                  File.WriteAllBytes(Server.modFile' newModControl);                              }                              ModpackSystem.fetch.HandleModDone();                          }                          break;                  }
