Implementation smell,Namespace,Class,File,Method,Description
Long Method,Confuser.Protections.Constants,EncodePhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\EncodePhase.cs,ExtractConstants,The method has 106 lines of code.
Long Method,Confuser.Protections.ControlFlow,SwitchMangler,C:\repos\yck1509_ConfuserEx\Confuser.Protections\ControlFlow\SwitchMangler.cs,Mangle,The method has 206 lines of code.
Complex Method,Confuser.Protections,Compressor,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Compress\Compressor.cs,PackModules,Cyclomatic complexity of the method is 10
Complex Method,Confuser.Protections,AntiDebugPhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiDebugProtection.cs,Execute,Cyclomatic complexity of the method is 9
Complex Method,Confuser.Protections.AntiTamper,JITMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\JITMode.cs,HandleInject,Cyclomatic complexity of the method is 12
Complex Method,Confuser.Protections.AntiTamper,JITMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\JITMode.cs,CreateSection,Cyclomatic complexity of the method is 8
Complex Method,Confuser.Protections.AntiTamper,NormalMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\NormalMode.cs,CreateSections,Cyclomatic complexity of the method is 8
Complex Method,Confuser.Protections.Constants,ReferenceReplacer,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\ReferenceReplacer.cs,ReplaceCFG,Cyclomatic complexity of the method is 11
Complex Method,Confuser.Protections.Constants,EncodePhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\EncodePhase.cs,Execute,Cyclomatic complexity of the method is 9
Complex Method,Confuser.Protections.Constants,EncodePhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\EncodePhase.cs,ExtractConstants,Cyclomatic complexity of the method is 10
Complex Method,Confuser.Protections.ControlFlow,BlockParser,C:\repos\yck1509_ConfuserEx\Confuser.Protections\ControlFlow\BlockParser.cs,ParseBody,Cyclomatic complexity of the method is 20
Complex Method,Confuser.Protections.ControlFlow,JumpMangler,C:\repos\yck1509_ConfuserEx\Confuser.Protections\ControlFlow\JumpMangler.cs,SpiltFragments,Cyclomatic complexity of the method is 10
Complex Method,Confuser.Protections.ControlFlow,SwitchMangler,C:\repos\yck1509_ConfuserEx\Confuser.Protections\ControlFlow\SwitchMangler.cs,Mangle,Cyclomatic complexity of the method is 19
Complex Method,Confuser.Protections.ReferenceProxy,MildMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\ReferenceProxy\MildMode.cs,ProcessCall,Cyclomatic complexity of the method is 9
Complex Method,Confuser.Protections.ReferenceProxy,ReferenceProxyPhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\ReferenceProxy\ReferenceProxyPhase.cs,ProcessMethod,Cyclomatic complexity of the method is 12
Complex Method,Confuser.Protections.Resources,MDPhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Resources\MDPhase.cs,OnWriterEvent,Cyclomatic complexity of the method is 9
Long Parameter List,Confuser.Protections,Compressor,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Compress\Compressor.cs,PackModules,The method has 5 parameters. Parameters: context' compCtx' stubModule' comp' random
Long Parameter List,Confuser.Protections.AntiTamper,JITMethodBodyWriter,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\JITBody.cs,JITMethodBodyWriter,The method has 5 parameters. Parameters: md' body' jitBody' mulSeed' keepMaxStack
Long Parameter List,Confuser.Protections.Constants,ReferenceReplacer,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\ReferenceReplacer.cs,InsertStateGetAndUpdate,The method has 5 parameters. Parameters: ctx' index' type' currentState' targetState
Long Parameter List,Confuser.Protections.Constants,EncodePhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\EncodePhase.cs,EncodeConstant64,The method has 5 parameters. Parameters: moduleCtx' hi' lo' valueType' references
Long Parameter List,Confuser.Protections.Constants,EncodePhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\EncodePhase.cs,UpdateReference,The method has 5 parameters. Parameters: moduleCtx' valueType' references' buffIndex' typeID
Long Parameter List,Confuser.Protections.Constants,EncodePhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\EncodePhase.cs,ExtractConstants,The method has 5 parameters. Parameters: context' parameters' moduleCtx' ldc' ldInit
Long Parameter List,Confuser.Protections.ControlFlow,ControlFlowPhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\ControlFlow\ControlFlowPhase.cs,ParseParameters,The method has 5 parameters. Parameters: method' context' parameters' random' disableOpti
Long Statement,Confuser.Protections,Compressor,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Compress\Compressor.cs,GetId,The length of the statement  "			assembly.Version = new Version(assemblyRow.MajorVersion' assemblyRow.MinorVersion' assemblyRow.BuildNumber' assemblyRow.RevisionNumber); " is 136.
Long Statement,Confuser.Protections,Compressor,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Compress\Compressor.cs,InjectStub,The length of the statement  "			var rtType = rt.GetRuntimeType(compCtx.CompatMode ? "Confuser.Runtime.CompressorCompat" : "Confuser.Runtime.Compressor"); " is 121.
Long Statement,Confuser.Protections,Compressor,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Compress\Compressor.cs,InjectStub,The length of the statement  "						instrs.InsertRange(i - 2' compCtx.Deriver.EmitDerivation(decrypter' context' (Local)ldDst.Operand' (Local)ldSrc.Operand)); " is 122.
Long Statement,Confuser.Protections,KeyInjector,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Compress\Compressor.cs,OnWriterEvent,The length of the statement  "						resTbl.Add(new RawManifestResourceRow(resource.Item1' resource.Item2' writer.MetaData.StringsHeap.Add(resource.Item3)' impl)); " is 126.
Long Statement,Confuser.Protections.AntiTamper,JITMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\JITMode.cs,CreateSection,The length of the statement  "				var bodyWriter = new JITMethodBodyWriter(writer.MetaData' method.Body' jitBody' random.NextUInt32()' writer.MetaData.KeepOldMaxStack || method.Body.KeepOldMaxStack); " is 165.
Long Statement,Confuser.Protections.AntiTamper,NormalMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\NormalMode.cs,HandleInject,The length of the statement  "			IEnumerable<IDnlibDef> members = InjectHelper.Inject(initType' context.CurrentModule.GlobalType' context.CurrentModule); " is 120.
Long Statement,Confuser.Protections.Compress,ResourceRecorder,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Compress\ExtractPhase.cs,OnWriterEvent,The length of the statement  "					Dictionary<uint' byte[]> stringDict = writer.MetaData.StringsHeap.GetAllRawData().ToDictionary(pair => pair.Key' pair => pair.Value); " is 133.
Long Statement,Confuser.Protections.Compress,ResourceRecorder,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Compress\ExtractPhase.cs,OnWriterEvent,The length of the statement  "						ctx.ManifestResources.Add(Tuple.Create(resource.Offset' resource.Flags' Encoding.UTF8.GetString(stringDict[resource.Name]))); " is 125.
Long Statement,Confuser.Protections.Constants,x86Encoding,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\x86Mode.cs,Compile,The length of the statement  "				native = new MethodDefUser(""' MethodSig.CreateStatic(int32' int32)' MethodAttributes.PinvokeImpl | MethodAttributes.PrivateScope | MethodAttributes.Static); " is 157.
Long Statement,Confuser.Protections.Constants,x86Encoding,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\x86Mode.cs,Compile,The length of the statement  "				native.ImplAttributes = MethodImplAttributes.Native | MethodImplAttributes.Unmanaged | MethodImplAttributes.PreserveSig; " is 120.
Long Statement,Confuser.Protections.Constants,x86Encoding,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\x86Mode.cs,Compile,The length of the statement  "				//var suppressAttr = ctx.Method.Module.CorLibTypes.GetTypeRef("System.Security"' "SuppressUnmanagedCodeSecurityAttribute").ResolveThrow(); " is 138.
Long Statement,Confuser.Protections.Constants,x86Encoding,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\x86Mode.cs,Compile,The length of the statement  "				//native.CustomAttributes.Add(new CustomAttribute((MemberRef)ctx.Method.Module.Import(suppressAttr.FindDefaultConstructor()))); " is 127.
Long Statement,Confuser.Protections.Constants,x86Encoding,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\x86Mode.cs,Compile,The length of the statement  "					reg = codeGen.GenerateX86(inverse' (v' r) => { return new[] { x86Instruction.Create(x86OpCode.POP' new x86RegisterOperand(r)) }; }); " is 132.
Long Statement,Confuser.Protections.Constants,EncodePhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\EncodePhase.cs,Execute,The length of the statement  "					EncodeConstant64(moduleCtx' (uint)((long)entry.Key >> 32)' (uint)(long)entry.Key' context.CurrentModule.CorLibTypes.Int64' entry.Value); " is 136.
Long Statement,Confuser.Protections.Constants,InjectPhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\InjectPhase.cs,InjectHelpers,The length of the statement  "			IEnumerable<IDnlibDef> members = InjectHelper.Inject(rt.GetRuntimeType("Confuser.Runtime.Constant")' context.CurrentModule.GlobalType' context.CurrentModule); " is 158.
Long Statement,Confuser.Protections.Constants,InjectPhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\InjectPhase.cs,InjectHelpers,The length of the statement  "			var dataType = new TypeDefUser(""' moduleCtx.Name.RandomName()' context.CurrentModule.CorLibTypes.GetTypeRef("System"' "ValueType")); " is 133.
Long Statement,Confuser.Protections.Constants,InjectPhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\InjectPhase.cs,InjectHelpers,The length of the statement  "				do decoderDesc.NumberID = (byte)(moduleCtx.Random.NextByte() & 3); while (decoderDesc.NumberID == decoderDesc.StringID); " is 120.
Long Statement,Confuser.Protections.Constants,InjectPhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\InjectPhase.cs,InjectHelpers,The length of the statement  "				do decoderDesc.InitializerID = (byte)(moduleCtx.Random.NextByte() & 3); while (decoderDesc.InitializerID == decoderDesc.StringID || decoderDesc.InitializerID == decoderDesc.NumberID); " is 183.
Long Statement,Confuser.Protections.Constants,InjectPhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\InjectPhase.cs,MutateInitializer,The length of the statement  "						instrs.InsertRange(i - 2' moduleCtx.ModeHandler.EmitDecrypt(moduleCtx.InitMethod' moduleCtx' (Local)ldBlock.Operand' (Local)ldKey.Operand)); " is 140.
Long Statement,Confuser.Protections.ControlFlow,ControlFlowPhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\ControlFlow\ControlFlowPhase.cs,DisabledOptimization,The length of the statement  "					disableOpti |= ((DebuggableAttribute.DebuggingModes)(int)debugAttr.ConstructorArguments[0].Value & DebuggableAttribute.DebuggingModes.DisableOptimizations) != 0; " is 161.
Long Statement,Confuser.Protections.ControlFlow,ControlFlowPhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\ControlFlow\ControlFlowPhase.cs,DisabledOptimization,The length of the statement  "					disableOpti |= ((DebuggableAttribute.DebuggingModes)(int)debugAttr.ConstructorArguments[0].Value & DebuggableAttribute.DebuggingModes.DisableOptimizations) != 0; " is 161.
Long Statement,Confuser.Protections.ControlFlow,ControlFlowPhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\ControlFlow\ControlFlowPhase.cs,Execute,The length of the statement  "			RandomGenerator random = context.Registry.GetService<IRandomService>().GetRandomGenerator(ControlFlowProtection._FullId); " is 121.
Long Statement,Confuser.Protections.ControlFlow,x86Encoding,C:\repos\yck1509_ConfuserEx\Confuser.Protections\ControlFlow\x86Predicate.cs,Compile,The length of the statement  "				native = new MethodDefUser(ctx.Context.Registry.GetService<INameService>().RandomName()' MethodSig.CreateStatic(int32' int32)' MethodAttributes.PinvokeImpl | MethodAttributes.PrivateScope | MethodAttributes.Static); " is 215.
Long Statement,Confuser.Protections.ControlFlow,x86Encoding,C:\repos\yck1509_ConfuserEx\Confuser.Protections\ControlFlow\x86Predicate.cs,Compile,The length of the statement  "				native.ImplAttributes = MethodImplAttributes.Native | MethodImplAttributes.Unmanaged | MethodImplAttributes.PreserveSig; " is 120.
Long Statement,Confuser.Protections.ControlFlow,x86Encoding,C:\repos\yck1509_ConfuserEx\Confuser.Protections\ControlFlow\x86Predicate.cs,Compile,The length of the statement  "				//var suppressAttr = ctx.Method.Module.CorLibTypes.GetTypeRef("System.Security"' "SuppressUnmanagedCodeSecurityAttribute").ResolveThrow(); " is 138.
Long Statement,Confuser.Protections.ControlFlow,x86Encoding,C:\repos\yck1509_ConfuserEx\Confuser.Protections\ControlFlow\x86Predicate.cs,Compile,The length of the statement  "				//native.CustomAttributes.Add(new CustomAttribute((MemberRef)ctx.Method.Module.Import(suppressAttr.FindDefaultConstructor()))); " is 127.
Long Statement,Confuser.Protections.ControlFlow,x86Encoding,C:\repos\yck1509_ConfuserEx\Confuser.Protections\ControlFlow\x86Predicate.cs,Compile,The length of the statement  "					reg = codeGen.GenerateX86(inverse' (v' r) => { return new[] { x86Instruction.Create(x86OpCode.POP' new x86RegisterOperand(r)) }; }); " is 132.
Long Statement,Confuser.Protections.ControlFlow,SwitchMangler,C:\repos\yck1509_ConfuserEx\Confuser.Protections\ControlFlow\SwitchMangler.cs,Mangle,The length of the statement  "								Instruction nextKeyInstr = Instruction.CreateLdcI4(xorKey ^ (predicate != null ? predicate.GetSwitchKey(nextKey) : nextKey)); " is 125.
Long Statement,Confuser.Protections.ReferenceProxy,x86Encoding,C:\repos\yck1509_ConfuserEx\Confuser.Protections\ReferenceProxy\x86Encoding.cs,Compile,The length of the statement  "			native = new MethodDefUser(ctx.Context.Registry.GetService<INameService>().RandomName()' MethodSig.CreateStatic(int32' int32)' MethodAttributes.PinvokeImpl | MethodAttributes.PrivateScope | MethodAttributes.Static); " is 215.
Long Statement,Confuser.Protections.ReferenceProxy,x86Encoding,C:\repos\yck1509_ConfuserEx\Confuser.Protections\ReferenceProxy\x86Encoding.cs,Compile,The length of the statement  "			native.ImplAttributes = MethodImplAttributes.Native | MethodImplAttributes.Unmanaged | MethodImplAttributes.PreserveSig; " is 120.
Long Statement,Confuser.Protections.ReferenceProxy,x86Encoding,C:\repos\yck1509_ConfuserEx\Confuser.Protections\ReferenceProxy\x86Encoding.cs,Compile,The length of the statement  "				reg = codeGen.GenerateX86(inverse' (v' r) => { return new[] { x86Instruction.Create(x86OpCode.POP' new x86RegisterOperand(r)) }; }); " is 132.
Long Statement,Confuser.Protections.ReferenceProxy,RPMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\ReferenceProxy\RPMode.cs,GetDelegateType,The length of the statement  "			ret = new TypeDefUser(ctx.Name.ObfuscateName(ctx.Method.DeclaringType.Namespace' RenameMode.Unicode)' ctx.Name.RandomName()' ctx.Module.CorLibTypes.GetTypeRef("System"' "MulticastDelegate")); " is 191.
Long Statement,Confuser.Protections.ReferenceProxy,RPMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\ReferenceProxy\RPMode.cs,GetDelegateType,The length of the statement  "			var ctor = new MethodDefUser(".ctor"' MethodSig.CreateInstance(ctx.Module.CorLibTypes.Void' ctx.Module.CorLibTypes.Object' ctx.Module.CorLibTypes.IntPtr)); " is 155.
Long Statement,Confuser.Protections.ReferenceProxy,RPMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\ReferenceProxy\RPMode.cs,GetDelegateType,The length of the statement  "			ctor.Attributes = MethodAttributes.Assembly | MethodAttributes.HideBySig | MethodAttributes.RTSpecialName | MethodAttributes.SpecialName; " is 137.
Long Statement,Confuser.Protections.ReferenceProxy,RPMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\ReferenceProxy\RPMode.cs,GetDelegateType,The length of the statement  "			invoke.Attributes = MethodAttributes.Assembly | MethodAttributes.HideBySig | MethodAttributes.Virtual | MethodAttributes.NewSlot; " is 129.
Long Statement,Confuser.Protections.ReferenceProxy,ReferenceProxyPhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\ReferenceProxy\ReferenceProxyPhase.cs,Execute,The length of the statement  "			RandomGenerator random = context.Registry.GetService<IRandomService>().GetRandomGenerator(ReferenceProxyProtection._FullId); " is 124.
Long Statement,Confuser.Protections.Resources,InjectPhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Resources\InjectPhase.cs,InjectHelpers,The length of the statement  "			IEnumerable<IDnlibDef> members = InjectHelper.Inject(rt.GetRuntimeType(rtName)' context.CurrentModule.GlobalType' context.CurrentModule); " is 137.
Long Statement,Confuser.Protections.Resources,InjectPhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Resources\InjectPhase.cs,InjectHelpers,The length of the statement  "			var dataType = new TypeDefUser(""' moduleCtx.Name.RandomName()' context.CurrentModule.CorLibTypes.GetTypeRef("System"' "ValueType")); " is 133.
Long Statement,Confuser.Protections.Resources,InjectPhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Resources\InjectPhase.cs,MutateInitializer,The length of the statement  "						instrs.InsertRange(i - 2' moduleCtx.ModeHandler.EmitDecrypt(moduleCtx.InitMethod' moduleCtx' (Local)ldBlock.Operand' (Local)ldKey.Operand)); " is 140.
Complex Conditional,Confuser.Protections.Constants,EncodePhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\EncodePhase.cs,ExtractConstants,The conditional expression  "operand.DeclaringType.DefinitionAssembly.IsCorLib() &&  						    operand.DeclaringType.Namespace == "System.Runtime.CompilerServices" &&  						    operand.DeclaringType.Name == "RuntimeHelpers" &&  						    operand.Name == "InitializeArray""  is complex.
Complex Conditional,Confuser.Protections.Constants,EncodePhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\EncodePhase.cs,ExtractConstants,The conditional expression  "(operand == -1 || operand == 0 || operand == 1) && (moduleCtx.Elements & EncodeElements.Primitive) == 0"  is complex.
Complex Conditional,Confuser.Protections.Constants,EncodePhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\EncodePhase.cs,ExtractConstants,The conditional expression  "(operand == -1 || operand == 0 || operand == 1) && (moduleCtx.Elements & EncodeElements.Primitive) == 0"  is complex.
Complex Conditional,Confuser.Protections.ControlFlow,CFContext,C:\repos\yck1509_ConfuserEx\Confuser.Protections\ControlFlow\CFContext.cs,AddJump,The conditional expression  "!Method.Module.IsClr40 && JunkCode &&  			    !Method.DeclaringType.HasGenericParameters && !Method.HasGenericParameters &&  			    (instrs[0].OpCode.FlowControl == FlowControl.Call || instrs[0].OpCode.FlowControl == FlowControl.Next)"  is complex.
Complex Conditional,Confuser.Protections.ControlFlow,JumpMangler,C:\repos\yck1509_ConfuserEx\Confuser.Protections\ControlFlow\JumpMangler.cs,SpiltFragments,The conditional expression  "i + 2 < block.Instructions.Count &&  				    block.Instructions[i + 0].OpCode.Code == Code.Dup &&  				    block.Instructions[i + 1].OpCode.Code == Code.Ldvirtftn &&  				    block.Instructions[i + 2].OpCode.Code == Code.Newobj"  is complex.
Complex Conditional,Confuser.Protections.ControlFlow,JumpMangler,C:\repos\yck1509_ConfuserEx\Confuser.Protections\ControlFlow\JumpMangler.cs,SpiltFragments,The conditional expression  "i + 4 < block.Instructions.Count &&  				    block.Instructions[i + 0].OpCode.Code == Code.Ldc_I4 &&  				    block.Instructions[i + 1].OpCode.Code == Code.Newarr &&  				    block.Instructions[i + 2].OpCode.Code == Code.Dup &&  				    block.Instructions[i + 3].OpCode.Code == Code.Ldtoken &&  				    block.Instructions[i + 4].OpCode.Code == Code.Call"  is complex.
Complex Conditional,Confuser.Protections.ControlFlow,SwitchMangler,C:\repos\yck1509_ConfuserEx\Confuser.Protections\ControlFlow\SwitchMangler.cs,SpiltStatements,The conditional expression  "(instr.OpCode.OpCodeType != OpCodeType.Prefix && trace.AfterStack[instr.Offset] == 0 &&  				     requiredInstr.Count == 0) &&  				    (shouldSpilt || ctx.Intensity > ctx.Random.NextDouble())"  is complex.
Magic Number,Confuser.Protections,Compressor,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Compress\Compressor.cs,PackModules,The following statement contains a magic number: byte[] key = random.NextBytes(4 + maxLen);
Magic Number,Confuser.Protections,Compressor,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Compress\Compressor.cs,PackModules,The following statement contains a magic number: key[1] = (byte)(compCtx.EntryPointToken >> 8);
Magic Number,Confuser.Protections,Compressor,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Compress\Compressor.cs,PackModules,The following statement contains a magic number: key[2] = (byte)(compCtx.EntryPointToken >> 16);
Magic Number,Confuser.Protections,Compressor,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Compress\Compressor.cs,PackModules,The following statement contains a magic number: key[2] = (byte)(compCtx.EntryPointToken >> 16);
Magic Number,Confuser.Protections,Compressor,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Compress\Compressor.cs,PackModules,The following statement contains a magic number: key[3] = (byte)(compCtx.EntryPointToken >> 24);
Magic Number,Confuser.Protections,Compressor,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Compress\Compressor.cs,PackModules,The following statement contains a magic number: key[3] = (byte)(compCtx.EntryPointToken >> 24);
Magic Number,Confuser.Protections,Compressor,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Compress\Compressor.cs,PackModules,The following statement contains a magic number: for (int i = 4; i < key.Length; i++) // no zero bytes  				key[i] |= 1;
Magic Number,Confuser.Protections,Compressor,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Compress\Compressor.cs,PackModules,The following statement contains a magic number: foreach (var entry in modules) {  				byte[] name = Encoding.UTF8.GetBytes(entry.Key);  				for (int i = 0; i < name.Length; i++)  					name[i] *= key[i + 4];    				uint state = 0x6fff61;  				foreach (byte chr in name)  					state = state * 0x5e3f1f + chr;  				byte[] encrypted = compCtx.Encrypt(comp' entry.Value' state' progress => {  					progress = (progress + moduleIndex) / modules.Count;  					context.Logger.Progress((int)(progress * 10000)' 10000);  				});  				context.CheckCancellation();    				var resource = new EmbeddedResource(Convert.ToBase64String(name)' encrypted' ManifestResourceAttributes.Private);  				stubModule.Resources.Add(resource);  				moduleIndex++;  			}
Magic Number,Confuser.Protections,Compressor,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Compress\Compressor.cs,PackModules,The following statement contains a magic number: foreach (var entry in modules) {  				byte[] name = Encoding.UTF8.GetBytes(entry.Key);  				for (int i = 0; i < name.Length; i++)  					name[i] *= key[i + 4];    				uint state = 0x6fff61;  				foreach (byte chr in name)  					state = state * 0x5e3f1f + chr;  				byte[] encrypted = compCtx.Encrypt(comp' entry.Value' state' progress => {  					progress = (progress + moduleIndex) / modules.Count;  					context.Logger.Progress((int)(progress * 10000)' 10000);  				});  				context.CheckCancellation();    				var resource = new EmbeddedResource(Convert.ToBase64String(name)' encrypted' ManifestResourceAttributes.Private);  				stubModule.Resources.Add(resource);  				moduleIndex++;  			}
Magic Number,Confuser.Protections,Compressor,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Compress\Compressor.cs,PackModules,The following statement contains a magic number: foreach (var entry in modules) {  				byte[] name = Encoding.UTF8.GetBytes(entry.Key);  				for (int i = 0; i < name.Length; i++)  					name[i] *= key[i + 4];    				uint state = 0x6fff61;  				foreach (byte chr in name)  					state = state * 0x5e3f1f + chr;  				byte[] encrypted = compCtx.Encrypt(comp' entry.Value' state' progress => {  					progress = (progress + moduleIndex) / modules.Count;  					context.Logger.Progress((int)(progress * 10000)' 10000);  				});  				context.CheckCancellation();    				var resource = new EmbeddedResource(Convert.ToBase64String(name)' encrypted' ManifestResourceAttributes.Private);  				stubModule.Resources.Add(resource);  				moduleIndex++;  			}
Magic Number,Confuser.Protections,Compressor,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Compress\Compressor.cs,InjectStub,The following statement contains a magic number: byte[] encryptedModule = compCtx.Encrypt(comp' compCtx.OriginModule' seed'  			                                         progress => context.Logger.Progress((int)(progress * 10000)' 10000));
Magic Number,Confuser.Protections,Compressor,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Compress\Compressor.cs,InjectStub,The following statement contains a magic number: byte[] encryptedModule = compCtx.Encrypt(comp' compCtx.OriginModule' seed'  			                                         progress => context.Logger.Progress((int)(progress * 10000)' 10000));
Magic Number,Confuser.Protections,Compressor,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Compress\Compressor.cs,InjectStub,The following statement contains a magic number: MutationHelper.InjectKeys(entryPoint'  			                          new[] { 0' 1 }'  			                          new[] { encryptedModule.Length >> 2' (int)seed });
Magic Number,Confuser.Protections,Compressor,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Compress\Compressor.cs,InjectStub,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  				Instruction instr = instrs[i];  				if (instr.OpCode == OpCodes.Call) {  					var method = (IMethod)instr.Operand;  					if (method.DeclaringType.Name == "Mutation" &&  					    method.Name == "Crypt") {  						Instruction ldDst = instrs[i - 2];  						Instruction ldSrc = instrs[i - 1];  						Debug.Assert(ldDst.OpCode == OpCodes.Ldloc && ldSrc.OpCode == OpCodes.Ldloc);  						instrs.RemoveAt(i);  						instrs.RemoveAt(i - 1);  						instrs.RemoveAt(i - 2);  						instrs.InsertRange(i - 2' compCtx.Deriver.EmitDerivation(decrypter' context' (Local)ldDst.Operand' (Local)ldSrc.Operand));  					}  					else if (method.DeclaringType.Name == "Lzma" &&  					         method.Name == "Decompress") {  						MethodDef decomp = comp.GetRuntimeDecompressor(stubModule' member => { });  						instr.Operand = decomp;  					}  				}  			}
Magic Number,Confuser.Protections,Compressor,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Compress\Compressor.cs,InjectStub,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  				Instruction instr = instrs[i];  				if (instr.OpCode == OpCodes.Call) {  					var method = (IMethod)instr.Operand;  					if (method.DeclaringType.Name == "Mutation" &&  					    method.Name == "Crypt") {  						Instruction ldDst = instrs[i - 2];  						Instruction ldSrc = instrs[i - 1];  						Debug.Assert(ldDst.OpCode == OpCodes.Ldloc && ldSrc.OpCode == OpCodes.Ldloc);  						instrs.RemoveAt(i);  						instrs.RemoveAt(i - 1);  						instrs.RemoveAt(i - 2);  						instrs.InsertRange(i - 2' compCtx.Deriver.EmitDerivation(decrypter' context' (Local)ldDst.Operand' (Local)ldSrc.Operand));  					}  					else if (method.DeclaringType.Name == "Lzma" &&  					         method.Name == "Decompress") {  						MethodDef decomp = comp.GetRuntimeDecompressor(stubModule' member => { });  						instr.Operand = decomp;  					}  				}  			}
Magic Number,Confuser.Protections,Compressor,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Compress\Compressor.cs,InjectStub,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  				Instruction instr = instrs[i];  				if (instr.OpCode == OpCodes.Call) {  					var method = (IMethod)instr.Operand;  					if (method.DeclaringType.Name == "Mutation" &&  					    method.Name == "Crypt") {  						Instruction ldDst = instrs[i - 2];  						Instruction ldSrc = instrs[i - 1];  						Debug.Assert(ldDst.OpCode == OpCodes.Ldloc && ldSrc.OpCode == OpCodes.Ldloc);  						instrs.RemoveAt(i);  						instrs.RemoveAt(i - 1);  						instrs.RemoveAt(i - 2);  						instrs.InsertRange(i - 2' compCtx.Deriver.EmitDerivation(decrypter' context' (Local)ldDst.Operand' (Local)ldSrc.Operand));  					}  					else if (method.DeclaringType.Name == "Lzma" &&  					         method.Name == "Decompress") {  						MethodDef decomp = comp.GetRuntimeDecompressor(stubModule' member => { });  						instr.Operand = decomp;  					}  				}  			}
Magic Number,Confuser.Protections,KeyInjector,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Compress\Compressor.cs,OnWriterEvent,The following statement contains a magic number: if (evt == ModuleWriterEvent.MDBeginCreateTables) {  					// Add key signature  					uint sigBlob = writer.MetaData.BlobHeap.Add(ctx.KeySig);  					uint sigRid = writer.MetaData.TablesHeap.StandAloneSigTable.Add(new RawStandAloneSigRow(sigBlob));  					Debug.Assert(sigRid == 1);  					uint sigToken = 0x11000000 | sigRid;  					ctx.KeyToken = sigToken;  					MutationHelper.InjectKey(writer.Module.EntryPoint' 2' (int)sigToken);  				}  				else if (evt == ModuleWriterEvent.MDBeginAddResources && !ctx.CompatMode) {  					// Compute hash  					byte[] hash = SHA1.Create().ComputeHash(ctx.OriginModule);  					uint hashBlob = writer.MetaData.BlobHeap.Add(hash);    					MDTable<RawFileRow> fileTbl = writer.MetaData.TablesHeap.FileTable;  					uint fileRid = fileTbl.Add(new RawFileRow(  						                           (uint)FileAttributes.ContainsMetaData'  						                           writer.MetaData.StringsHeap.Add("koi")'  						                           hashBlob));  					uint impl = CodedToken.Implementation.Encode(new MDToken(Table.File' fileRid));    					// Add resources  					MDTable<RawManifestResourceRow> resTbl = writer.MetaData.TablesHeap.ManifestResourceTable;  					foreach (var resource in ctx.ManifestResources)  						resTbl.Add(new RawManifestResourceRow(resource.Item1' resource.Item2' writer.MetaData.StringsHeap.Add(resource.Item3)' impl));    					// Add exported types  					var exTbl = writer.MetaData.TablesHeap.ExportedTypeTable;  					foreach (var type in ctx.OriginModuleDef.GetTypes()) {  						if (!type.IsVisibleOutside())  							continue;  						exTbl.Add(new RawExportedTypeRow((uint)type.Attributes' 0'  						                                 writer.MetaData.StringsHeap.Add(type.Name)'  						                                 writer.MetaData.StringsHeap.Add(type.Namespace)' impl));  					}  				}
Magic Number,Confuser.Protections,InvalidMDPhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\InvalidMetadataProtection.cs,OnWriterEvent,The following statement contains a magic number: if (e.WriterEvent == ModuleWriterEvent.MDEndCreateTables) {  					// These hurts reflection    					/*  					uint methodLen = (uint)writer.MetaData.TablesHeap.MethodTable.Rows + 1;  					uint fieldLen = (uint)writer.MetaData.TablesHeap.FieldTable.Rows + 1;    					var root = writer.MetaData.TablesHeap.TypeDefTable.Add(new RawTypeDefRow(  							0' 0x7fff7fff' 0' 0x3FFFD' fieldLen' methodLen));  					writer.MetaData.TablesHeap.NestedClassTable.Add(new RawNestedClassRow(root' root));    					var namespaces = writer.MetaData.TablesHeap.TypeDefTable  						.Select(row => row.Namespace)  						.Distinct()  						.ToList();  					foreach (var ns in namespaces)  					{  						if (ns == 0) continue;  						var type = writer.MetaData.TablesHeap.TypeDefTable.Add(new RawTypeDefRow(  							0' 0' ns' 0x3FFFD' fieldLen' methodLen));  						writer.MetaData.TablesHeap.NestedClassTable.Add(new RawNestedClassRow(root' type));  					}  					  					foreach (var row in writer.MetaData.TablesHeap.ParamTable)  						row.Name = 0x7fff7fff;  					*/    					writer.MetaData.TablesHeap.ModuleTable.Add(new RawModuleRow(0' 0x7fff7fff' 0' 0' 0));  					writer.MetaData.TablesHeap.AssemblyTable.Add(new RawAssemblyRow(0' 0' 0' 0' 0' 0' 0' 0x7fff7fff' 0));    					int r = random.NextInt32(8' 16);  					for (int i = 0; i < r; i++)  						writer.MetaData.TablesHeap.ENCLogTable.Add(new RawENCLogRow(random.NextUInt32()' random.NextUInt32()));  					r = random.NextInt32(8' 16);  					for (int i = 0; i < r; i++)  						writer.MetaData.TablesHeap.ENCMapTable.Add(new RawENCMapRow(random.NextUInt32()));    					//Randomize(writer.MetaData.TablesHeap.NestedClassTable);  					Randomize(writer.MetaData.TablesHeap.ManifestResourceTable);  					//Randomize(writer.MetaData.TablesHeap.GenericParamConstraintTable);    					writer.TheOptions.MetaDataOptions.TablesHeapOptions.ExtraData = random.NextUInt32();  					writer.TheOptions.MetaDataOptions.TablesHeapOptions.UseENC = false;  					writer.TheOptions.MetaDataOptions.MetaDataHeaderOptions.VersionString += "\0\0\0\0";    					/*  					We are going to create a new specific '#GUID' Heap to avoid UnConfuserEX to work.  					<sarcasm>UnConfuserEX is so well coded' it relies on static cmp between values</sarcasm>  					If you deobfuscate this tool' you can see that it check for #GUID size and compare it to  					'16'' so we have to create a new array of byte wich size is exactly 16 and put it into   					our brand new Heap  					*/  					//                      writer.TheOptions.MetaDataOptions.OtherHeapsEnd.Add(new RawHeap("#GUID"' Guid.NewGuid().ToByteArray()));  					//  					writer.TheOptions.MetaDataOptions.OtherHeapsEnd.Add(new RawHeap("#Strings"' new byte[1]));  					writer.TheOptions.MetaDataOptions.OtherHeapsEnd.Add(new RawHeap("#Blob"' new byte[1]));  					writer.TheOptions.MetaDataOptions.OtherHeapsEnd.Add(new RawHeap("#Schema"' new byte[1]));  				}  				else if (e.WriterEvent == ModuleWriterEvent.MDOnAllTablesSorted) {  					writer.MetaData.TablesHeap.DeclSecurityTable.Add(new RawDeclSecurityRow(  						                                                 unchecked(0x7fff)' 0xffff7fff' 0xffff7fff));  					/*  					writer.MetaData.TablesHeap.ManifestResourceTable.Add(new RawManifestResourceRow(  						0x7fff7fff' (uint)ManifestResourceAttributes.Private' 0x7fff7fff' 2));  					*/  				}
Magic Number,Confuser.Protections,InvalidMDPhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\InvalidMetadataProtection.cs,OnWriterEvent,The following statement contains a magic number: if (e.WriterEvent == ModuleWriterEvent.MDEndCreateTables) {  					// These hurts reflection    					/*  					uint methodLen = (uint)writer.MetaData.TablesHeap.MethodTable.Rows + 1;  					uint fieldLen = (uint)writer.MetaData.TablesHeap.FieldTable.Rows + 1;    					var root = writer.MetaData.TablesHeap.TypeDefTable.Add(new RawTypeDefRow(  							0' 0x7fff7fff' 0' 0x3FFFD' fieldLen' methodLen));  					writer.MetaData.TablesHeap.NestedClassTable.Add(new RawNestedClassRow(root' root));    					var namespaces = writer.MetaData.TablesHeap.TypeDefTable  						.Select(row => row.Namespace)  						.Distinct()  						.ToList();  					foreach (var ns in namespaces)  					{  						if (ns == 0) continue;  						var type = writer.MetaData.TablesHeap.TypeDefTable.Add(new RawTypeDefRow(  							0' 0' ns' 0x3FFFD' fieldLen' methodLen));  						writer.MetaData.TablesHeap.NestedClassTable.Add(new RawNestedClassRow(root' type));  					}  					  					foreach (var row in writer.MetaData.TablesHeap.ParamTable)  						row.Name = 0x7fff7fff;  					*/    					writer.MetaData.TablesHeap.ModuleTable.Add(new RawModuleRow(0' 0x7fff7fff' 0' 0' 0));  					writer.MetaData.TablesHeap.AssemblyTable.Add(new RawAssemblyRow(0' 0' 0' 0' 0' 0' 0' 0x7fff7fff' 0));    					int r = random.NextInt32(8' 16);  					for (int i = 0; i < r; i++)  						writer.MetaData.TablesHeap.ENCLogTable.Add(new RawENCLogRow(random.NextUInt32()' random.NextUInt32()));  					r = random.NextInt32(8' 16);  					for (int i = 0; i < r; i++)  						writer.MetaData.TablesHeap.ENCMapTable.Add(new RawENCMapRow(random.NextUInt32()));    					//Randomize(writer.MetaData.TablesHeap.NestedClassTable);  					Randomize(writer.MetaData.TablesHeap.ManifestResourceTable);  					//Randomize(writer.MetaData.TablesHeap.GenericParamConstraintTable);    					writer.TheOptions.MetaDataOptions.TablesHeapOptions.ExtraData = random.NextUInt32();  					writer.TheOptions.MetaDataOptions.TablesHeapOptions.UseENC = false;  					writer.TheOptions.MetaDataOptions.MetaDataHeaderOptions.VersionString += "\0\0\0\0";    					/*  					We are going to create a new specific '#GUID' Heap to avoid UnConfuserEX to work.  					<sarcasm>UnConfuserEX is so well coded' it relies on static cmp between values</sarcasm>  					If you deobfuscate this tool' you can see that it check for #GUID size and compare it to  					'16'' so we have to create a new array of byte wich size is exactly 16 and put it into   					our brand new Heap  					*/  					//                      writer.TheOptions.MetaDataOptions.OtherHeapsEnd.Add(new RawHeap("#GUID"' Guid.NewGuid().ToByteArray()));  					//  					writer.TheOptions.MetaDataOptions.OtherHeapsEnd.Add(new RawHeap("#Strings"' new byte[1]));  					writer.TheOptions.MetaDataOptions.OtherHeapsEnd.Add(new RawHeap("#Blob"' new byte[1]));  					writer.TheOptions.MetaDataOptions.OtherHeapsEnd.Add(new RawHeap("#Schema"' new byte[1]));  				}  				else if (e.WriterEvent == ModuleWriterEvent.MDOnAllTablesSorted) {  					writer.MetaData.TablesHeap.DeclSecurityTable.Add(new RawDeclSecurityRow(  						                                                 unchecked(0x7fff)' 0xffff7fff' 0xffff7fff));  					/*  					writer.MetaData.TablesHeap.ManifestResourceTable.Add(new RawManifestResourceRow(  						0x7fff7fff' (uint)ManifestResourceAttributes.Private' 0x7fff7fff' 2));  					*/  				}
Magic Number,Confuser.Protections,InvalidMDPhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\InvalidMetadataProtection.cs,OnWriterEvent,The following statement contains a magic number: if (e.WriterEvent == ModuleWriterEvent.MDEndCreateTables) {  					// These hurts reflection    					/*  					uint methodLen = (uint)writer.MetaData.TablesHeap.MethodTable.Rows + 1;  					uint fieldLen = (uint)writer.MetaData.TablesHeap.FieldTable.Rows + 1;    					var root = writer.MetaData.TablesHeap.TypeDefTable.Add(new RawTypeDefRow(  							0' 0x7fff7fff' 0' 0x3FFFD' fieldLen' methodLen));  					writer.MetaData.TablesHeap.NestedClassTable.Add(new RawNestedClassRow(root' root));    					var namespaces = writer.MetaData.TablesHeap.TypeDefTable  						.Select(row => row.Namespace)  						.Distinct()  						.ToList();  					foreach (var ns in namespaces)  					{  						if (ns == 0) continue;  						var type = writer.MetaData.TablesHeap.TypeDefTable.Add(new RawTypeDefRow(  							0' 0' ns' 0x3FFFD' fieldLen' methodLen));  						writer.MetaData.TablesHeap.NestedClassTable.Add(new RawNestedClassRow(root' type));  					}  					  					foreach (var row in writer.MetaData.TablesHeap.ParamTable)  						row.Name = 0x7fff7fff;  					*/    					writer.MetaData.TablesHeap.ModuleTable.Add(new RawModuleRow(0' 0x7fff7fff' 0' 0' 0));  					writer.MetaData.TablesHeap.AssemblyTable.Add(new RawAssemblyRow(0' 0' 0' 0' 0' 0' 0' 0x7fff7fff' 0));    					int r = random.NextInt32(8' 16);  					for (int i = 0; i < r; i++)  						writer.MetaData.TablesHeap.ENCLogTable.Add(new RawENCLogRow(random.NextUInt32()' random.NextUInt32()));  					r = random.NextInt32(8' 16);  					for (int i = 0; i < r; i++)  						writer.MetaData.TablesHeap.ENCMapTable.Add(new RawENCMapRow(random.NextUInt32()));    					//Randomize(writer.MetaData.TablesHeap.NestedClassTable);  					Randomize(writer.MetaData.TablesHeap.ManifestResourceTable);  					//Randomize(writer.MetaData.TablesHeap.GenericParamConstraintTable);    					writer.TheOptions.MetaDataOptions.TablesHeapOptions.ExtraData = random.NextUInt32();  					writer.TheOptions.MetaDataOptions.TablesHeapOptions.UseENC = false;  					writer.TheOptions.MetaDataOptions.MetaDataHeaderOptions.VersionString += "\0\0\0\0";    					/*  					We are going to create a new specific '#GUID' Heap to avoid UnConfuserEX to work.  					<sarcasm>UnConfuserEX is so well coded' it relies on static cmp between values</sarcasm>  					If you deobfuscate this tool' you can see that it check for #GUID size and compare it to  					'16'' so we have to create a new array of byte wich size is exactly 16 and put it into   					our brand new Heap  					*/  					//                      writer.TheOptions.MetaDataOptions.OtherHeapsEnd.Add(new RawHeap("#GUID"' Guid.NewGuid().ToByteArray()));  					//  					writer.TheOptions.MetaDataOptions.OtherHeapsEnd.Add(new RawHeap("#Strings"' new byte[1]));  					writer.TheOptions.MetaDataOptions.OtherHeapsEnd.Add(new RawHeap("#Blob"' new byte[1]));  					writer.TheOptions.MetaDataOptions.OtherHeapsEnd.Add(new RawHeap("#Schema"' new byte[1]));  				}  				else if (e.WriterEvent == ModuleWriterEvent.MDOnAllTablesSorted) {  					writer.MetaData.TablesHeap.DeclSecurityTable.Add(new RawDeclSecurityRow(  						                                                 unchecked(0x7fff)' 0xffff7fff' 0xffff7fff));  					/*  					writer.MetaData.TablesHeap.ManifestResourceTable.Add(new RawManifestResourceRow(  						0x7fff7fff' (uint)ManifestResourceAttributes.Private' 0x7fff7fff' 2));  					*/  				}
Magic Number,Confuser.Protections,InvalidMDPhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\InvalidMetadataProtection.cs,OnWriterEvent,The following statement contains a magic number: if (e.WriterEvent == ModuleWriterEvent.MDEndCreateTables) {  					// These hurts reflection    					/*  					uint methodLen = (uint)writer.MetaData.TablesHeap.MethodTable.Rows + 1;  					uint fieldLen = (uint)writer.MetaData.TablesHeap.FieldTable.Rows + 1;    					var root = writer.MetaData.TablesHeap.TypeDefTable.Add(new RawTypeDefRow(  							0' 0x7fff7fff' 0' 0x3FFFD' fieldLen' methodLen));  					writer.MetaData.TablesHeap.NestedClassTable.Add(new RawNestedClassRow(root' root));    					var namespaces = writer.MetaData.TablesHeap.TypeDefTable  						.Select(row => row.Namespace)  						.Distinct()  						.ToList();  					foreach (var ns in namespaces)  					{  						if (ns == 0) continue;  						var type = writer.MetaData.TablesHeap.TypeDefTable.Add(new RawTypeDefRow(  							0' 0' ns' 0x3FFFD' fieldLen' methodLen));  						writer.MetaData.TablesHeap.NestedClassTable.Add(new RawNestedClassRow(root' type));  					}  					  					foreach (var row in writer.MetaData.TablesHeap.ParamTable)  						row.Name = 0x7fff7fff;  					*/    					writer.MetaData.TablesHeap.ModuleTable.Add(new RawModuleRow(0' 0x7fff7fff' 0' 0' 0));  					writer.MetaData.TablesHeap.AssemblyTable.Add(new RawAssemblyRow(0' 0' 0' 0' 0' 0' 0' 0x7fff7fff' 0));    					int r = random.NextInt32(8' 16);  					for (int i = 0; i < r; i++)  						writer.MetaData.TablesHeap.ENCLogTable.Add(new RawENCLogRow(random.NextUInt32()' random.NextUInt32()));  					r = random.NextInt32(8' 16);  					for (int i = 0; i < r; i++)  						writer.MetaData.TablesHeap.ENCMapTable.Add(new RawENCMapRow(random.NextUInt32()));    					//Randomize(writer.MetaData.TablesHeap.NestedClassTable);  					Randomize(writer.MetaData.TablesHeap.ManifestResourceTable);  					//Randomize(writer.MetaData.TablesHeap.GenericParamConstraintTable);    					writer.TheOptions.MetaDataOptions.TablesHeapOptions.ExtraData = random.NextUInt32();  					writer.TheOptions.MetaDataOptions.TablesHeapOptions.UseENC = false;  					writer.TheOptions.MetaDataOptions.MetaDataHeaderOptions.VersionString += "\0\0\0\0";    					/*  					We are going to create a new specific '#GUID' Heap to avoid UnConfuserEX to work.  					<sarcasm>UnConfuserEX is so well coded' it relies on static cmp between values</sarcasm>  					If you deobfuscate this tool' you can see that it check for #GUID size and compare it to  					'16'' so we have to create a new array of byte wich size is exactly 16 and put it into   					our brand new Heap  					*/  					//                      writer.TheOptions.MetaDataOptions.OtherHeapsEnd.Add(new RawHeap("#GUID"' Guid.NewGuid().ToByteArray()));  					//  					writer.TheOptions.MetaDataOptions.OtherHeapsEnd.Add(new RawHeap("#Strings"' new byte[1]));  					writer.TheOptions.MetaDataOptions.OtherHeapsEnd.Add(new RawHeap("#Blob"' new byte[1]));  					writer.TheOptions.MetaDataOptions.OtherHeapsEnd.Add(new RawHeap("#Schema"' new byte[1]));  				}  				else if (e.WriterEvent == ModuleWriterEvent.MDOnAllTablesSorted) {  					writer.MetaData.TablesHeap.DeclSecurityTable.Add(new RawDeclSecurityRow(  						                                                 unchecked(0x7fff)' 0xffff7fff' 0xffff7fff));  					/*  					writer.MetaData.TablesHeap.ManifestResourceTable.Add(new RawManifestResourceRow(  						0x7fff7fff' (uint)ManifestResourceAttributes.Private' 0x7fff7fff' 2));  					*/  				}
Magic Number,Confuser.Protections.AntiTamper,JITMethodBody,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\JITBody.cs,GetFileLength,The following statement contains a magic number: return (uint)Body.Length + 4;
Magic Number,Confuser.Protections.AntiTamper,JITMethodBody,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\JITBody.cs,WriteTo,The following statement contains a magic number: writer.Write((uint)(Body.Length >> 2));
Magic Number,Confuser.Protections.AntiTamper,JITMethodBody,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\JITBody.cs,Serialize,The following statement contains a magic number: using (var ms = new MemoryStream()) {  				var writer = new BinaryWriter(ms);  				foreach (byte i in fieldLayout)  					switch (i) {  						case 0:  							writer.Write((uint)ILCode.Length);  							break;  						case 1:  							writer.Write(MaxStack);  							break;  						case 2:  							writer.Write((uint)EHs.Length);  							break;  						case 3:  							writer.Write((uint)LocalVars.Length);  							break;  						case 4:  							writer.Write(Options);  							break;  						case 5:  							writer.Write(MulSeed);  							break;  					}    				writer.Write(ILCode);  				writer.Write(LocalVars);  				foreach (JITEHClause clause in EHs) {  					writer.Write(clause.Flags);  					writer.Write(clause.TryOffset);  					writer.Write(clause.TryLength);  					writer.Write(clause.HandlerOffset);  					writer.Write(clause.HandlerLength);  					writer.Write(clause.ClassTokenOrFilterOffset);  				}  				writer.WriteZeros(4 - ((int)ms.Length & 3)); // pad to 4 bytes  				Body = ms.ToArray();  			}
Magic Number,Confuser.Protections.AntiTamper,JITMethodBody,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\JITBody.cs,Serialize,The following statement contains a magic number: using (var ms = new MemoryStream()) {  				var writer = new BinaryWriter(ms);  				foreach (byte i in fieldLayout)  					switch (i) {  						case 0:  							writer.Write((uint)ILCode.Length);  							break;  						case 1:  							writer.Write(MaxStack);  							break;  						case 2:  							writer.Write((uint)EHs.Length);  							break;  						case 3:  							writer.Write((uint)LocalVars.Length);  							break;  						case 4:  							writer.Write(Options);  							break;  						case 5:  							writer.Write(MulSeed);  							break;  					}    				writer.Write(ILCode);  				writer.Write(LocalVars);  				foreach (JITEHClause clause in EHs) {  					writer.Write(clause.Flags);  					writer.Write(clause.TryOffset);  					writer.Write(clause.TryLength);  					writer.Write(clause.HandlerOffset);  					writer.Write(clause.HandlerLength);  					writer.Write(clause.ClassTokenOrFilterOffset);  				}  				writer.WriteZeros(4 - ((int)ms.Length & 3)); // pad to 4 bytes  				Body = ms.ToArray();  			}
Magic Number,Confuser.Protections.AntiTamper,JITMethodBody,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\JITBody.cs,Serialize,The following statement contains a magic number: using (var ms = new MemoryStream()) {  				var writer = new BinaryWriter(ms);  				foreach (byte i in fieldLayout)  					switch (i) {  						case 0:  							writer.Write((uint)ILCode.Length);  							break;  						case 1:  							writer.Write(MaxStack);  							break;  						case 2:  							writer.Write((uint)EHs.Length);  							break;  						case 3:  							writer.Write((uint)LocalVars.Length);  							break;  						case 4:  							writer.Write(Options);  							break;  						case 5:  							writer.Write(MulSeed);  							break;  					}    				writer.Write(ILCode);  				writer.Write(LocalVars);  				foreach (JITEHClause clause in EHs) {  					writer.Write(clause.Flags);  					writer.Write(clause.TryOffset);  					writer.Write(clause.TryLength);  					writer.Write(clause.HandlerOffset);  					writer.Write(clause.HandlerLength);  					writer.Write(clause.ClassTokenOrFilterOffset);  				}  				writer.WriteZeros(4 - ((int)ms.Length & 3)); // pad to 4 bytes  				Body = ms.ToArray();  			}
Magic Number,Confuser.Protections.AntiTamper,JITMethodBody,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\JITBody.cs,Serialize,The following statement contains a magic number: using (var ms = new MemoryStream()) {  				var writer = new BinaryWriter(ms);  				foreach (byte i in fieldLayout)  					switch (i) {  						case 0:  							writer.Write((uint)ILCode.Length);  							break;  						case 1:  							writer.Write(MaxStack);  							break;  						case 2:  							writer.Write((uint)EHs.Length);  							break;  						case 3:  							writer.Write((uint)LocalVars.Length);  							break;  						case 4:  							writer.Write(Options);  							break;  						case 5:  							writer.Write(MulSeed);  							break;  					}    				writer.Write(ILCode);  				writer.Write(LocalVars);  				foreach (JITEHClause clause in EHs) {  					writer.Write(clause.Flags);  					writer.Write(clause.TryOffset);  					writer.Write(clause.TryLength);  					writer.Write(clause.HandlerOffset);  					writer.Write(clause.HandlerLength);  					writer.Write(clause.ClassTokenOrFilterOffset);  				}  				writer.WriteZeros(4 - ((int)ms.Length & 3)); // pad to 4 bytes  				Body = ms.ToArray();  			}
Magic Number,Confuser.Protections.AntiTamper,JITMethodBody,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\JITBody.cs,Serialize,The following statement contains a magic number: using (var ms = new MemoryStream()) {  				var writer = new BinaryWriter(ms);  				foreach (byte i in fieldLayout)  					switch (i) {  						case 0:  							writer.Write((uint)ILCode.Length);  							break;  						case 1:  							writer.Write(MaxStack);  							break;  						case 2:  							writer.Write((uint)EHs.Length);  							break;  						case 3:  							writer.Write((uint)LocalVars.Length);  							break;  						case 4:  							writer.Write(Options);  							break;  						case 5:  							writer.Write(MulSeed);  							break;  					}    				writer.Write(ILCode);  				writer.Write(LocalVars);  				foreach (JITEHClause clause in EHs) {  					writer.Write(clause.Flags);  					writer.Write(clause.TryOffset);  					writer.Write(clause.TryLength);  					writer.Write(clause.HandlerOffset);  					writer.Write(clause.HandlerLength);  					writer.Write(clause.ClassTokenOrFilterOffset);  				}  				writer.WriteZeros(4 - ((int)ms.Length & 3)); // pad to 4 bytes  				Body = ms.ToArray();  			}
Magic Number,Confuser.Protections.AntiTamper,JITMethodBody,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\JITBody.cs,Serialize,The following statement contains a magic number: using (var ms = new MemoryStream()) {  				var writer = new BinaryWriter(ms);  				foreach (byte i in fieldLayout)  					switch (i) {  						case 0:  							writer.Write((uint)ILCode.Length);  							break;  						case 1:  							writer.Write(MaxStack);  							break;  						case 2:  							writer.Write((uint)EHs.Length);  							break;  						case 3:  							writer.Write((uint)LocalVars.Length);  							break;  						case 4:  							writer.Write(Options);  							break;  						case 5:  							writer.Write(MulSeed);  							break;  					}    				writer.Write(ILCode);  				writer.Write(LocalVars);  				foreach (JITEHClause clause in EHs) {  					writer.Write(clause.Flags);  					writer.Write(clause.TryOffset);  					writer.Write(clause.TryLength);  					writer.Write(clause.HandlerOffset);  					writer.Write(clause.HandlerLength);  					writer.Write(clause.ClassTokenOrFilterOffset);  				}  				writer.WriteZeros(4 - ((int)ms.Length & 3)); // pad to 4 bytes  				Body = ms.ToArray();  			}
Magic Number,Confuser.Protections.AntiTamper,JITMethodBody,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\JITBody.cs,Serialize,The following statement contains a magic number: Debug.Assert(Body.Length % 4 == 0);
Magic Number,Confuser.Protections.AntiTamper,JITMethodBody,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\JITBody.cs,Serialize,The following statement contains a magic number: for (uint i = 0; i < Body.Length; i += 4) {  				uint data = Body[i] | (uint)(Body[i + 1] << 8) | (uint)(Body[i + 2] << 16) | (uint)(Body[i + 3] << 24);  				Body[i + 0] ^= (byte)(state >> 0);  				Body[i + 1] ^= (byte)(state >> 8);  				Body[i + 2] ^= (byte)(state >> 16);  				Body[i + 3] ^= (byte)(state >> 24);  				state += data ^ counter;  				counter ^= (state >> 5) | (state << 27);  			}
Magic Number,Confuser.Protections.AntiTamper,JITMethodBody,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\JITBody.cs,Serialize,The following statement contains a magic number: for (uint i = 0; i < Body.Length; i += 4) {  				uint data = Body[i] | (uint)(Body[i + 1] << 8) | (uint)(Body[i + 2] << 16) | (uint)(Body[i + 3] << 24);  				Body[i + 0] ^= (byte)(state >> 0);  				Body[i + 1] ^= (byte)(state >> 8);  				Body[i + 2] ^= (byte)(state >> 16);  				Body[i + 3] ^= (byte)(state >> 24);  				state += data ^ counter;  				counter ^= (state >> 5) | (state << 27);  			}
Magic Number,Confuser.Protections.AntiTamper,JITMethodBody,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\JITBody.cs,Serialize,The following statement contains a magic number: for (uint i = 0; i < Body.Length; i += 4) {  				uint data = Body[i] | (uint)(Body[i + 1] << 8) | (uint)(Body[i + 2] << 16) | (uint)(Body[i + 3] << 24);  				Body[i + 0] ^= (byte)(state >> 0);  				Body[i + 1] ^= (byte)(state >> 8);  				Body[i + 2] ^= (byte)(state >> 16);  				Body[i + 3] ^= (byte)(state >> 24);  				state += data ^ counter;  				counter ^= (state >> 5) | (state << 27);  			}
Magic Number,Confuser.Protections.AntiTamper,JITMethodBody,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\JITBody.cs,Serialize,The following statement contains a magic number: for (uint i = 0; i < Body.Length; i += 4) {  				uint data = Body[i] | (uint)(Body[i + 1] << 8) | (uint)(Body[i + 2] << 16) | (uint)(Body[i + 3] << 24);  				Body[i + 0] ^= (byte)(state >> 0);  				Body[i + 1] ^= (byte)(state >> 8);  				Body[i + 2] ^= (byte)(state >> 16);  				Body[i + 3] ^= (byte)(state >> 24);  				state += data ^ counter;  				counter ^= (state >> 5) | (state << 27);  			}
Magic Number,Confuser.Protections.AntiTamper,JITMethodBody,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\JITBody.cs,Serialize,The following statement contains a magic number: for (uint i = 0; i < Body.Length; i += 4) {  				uint data = Body[i] | (uint)(Body[i + 1] << 8) | (uint)(Body[i + 2] << 16) | (uint)(Body[i + 3] << 24);  				Body[i + 0] ^= (byte)(state >> 0);  				Body[i + 1] ^= (byte)(state >> 8);  				Body[i + 2] ^= (byte)(state >> 16);  				Body[i + 3] ^= (byte)(state >> 24);  				state += data ^ counter;  				counter ^= (state >> 5) | (state << 27);  			}
Magic Number,Confuser.Protections.AntiTamper,JITMethodBody,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\JITBody.cs,Serialize,The following statement contains a magic number: for (uint i = 0; i < Body.Length; i += 4) {  				uint data = Body[i] | (uint)(Body[i + 1] << 8) | (uint)(Body[i + 2] << 16) | (uint)(Body[i + 3] << 24);  				Body[i + 0] ^= (byte)(state >> 0);  				Body[i + 1] ^= (byte)(state >> 8);  				Body[i + 2] ^= (byte)(state >> 16);  				Body[i + 3] ^= (byte)(state >> 24);  				state += data ^ counter;  				counter ^= (state >> 5) | (state << 27);  			}
Magic Number,Confuser.Protections.AntiTamper,JITMethodBody,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\JITBody.cs,Serialize,The following statement contains a magic number: for (uint i = 0; i < Body.Length; i += 4) {  				uint data = Body[i] | (uint)(Body[i + 1] << 8) | (uint)(Body[i + 2] << 16) | (uint)(Body[i + 3] << 24);  				Body[i + 0] ^= (byte)(state >> 0);  				Body[i + 1] ^= (byte)(state >> 8);  				Body[i + 2] ^= (byte)(state >> 16);  				Body[i + 3] ^= (byte)(state >> 24);  				state += data ^ counter;  				counter ^= (state >> 5) | (state << 27);  			}
Magic Number,Confuser.Protections.AntiTamper,JITMethodBody,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\JITBody.cs,Serialize,The following statement contains a magic number: for (uint i = 0; i < Body.Length; i += 4) {  				uint data = Body[i] | (uint)(Body[i + 1] << 8) | (uint)(Body[i + 2] << 16) | (uint)(Body[i + 3] << 24);  				Body[i + 0] ^= (byte)(state >> 0);  				Body[i + 1] ^= (byte)(state >> 8);  				Body[i + 2] ^= (byte)(state >> 16);  				Body[i + 3] ^= (byte)(state >> 24);  				state += data ^ counter;  				counter ^= (state >> 5) | (state << 27);  			}
Magic Number,Confuser.Protections.AntiTamper,JITMethodBody,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\JITBody.cs,Serialize,The following statement contains a magic number: for (uint i = 0; i < Body.Length; i += 4) {  				uint data = Body[i] | (uint)(Body[i + 1] << 8) | (uint)(Body[i + 2] << 16) | (uint)(Body[i + 3] << 24);  				Body[i + 0] ^= (byte)(state >> 0);  				Body[i + 1] ^= (byte)(state >> 8);  				Body[i + 2] ^= (byte)(state >> 16);  				Body[i + 3] ^= (byte)(state >> 24);  				state += data ^ counter;  				counter ^= (state >> 5) | (state << 27);  			}
Magic Number,Confuser.Protections.AntiTamper,JITMethodBody,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\JITBody.cs,Serialize,The following statement contains a magic number: for (uint i = 0; i < Body.Length; i += 4) {  				uint data = Body[i] | (uint)(Body[i + 1] << 8) | (uint)(Body[i + 2] << 16) | (uint)(Body[i + 3] << 24);  				Body[i + 0] ^= (byte)(state >> 0);  				Body[i + 1] ^= (byte)(state >> 8);  				Body[i + 2] ^= (byte)(state >> 16);  				Body[i + 3] ^= (byte)(state >> 24);  				state += data ^ counter;  				counter ^= (state >> 5) | (state << 27);  			}
Magic Number,Confuser.Protections.AntiTamper,JITMethodBody,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\JITBody.cs,Serialize,The following statement contains a magic number: for (uint i = 0; i < Body.Length; i += 4) {  				uint data = Body[i] | (uint)(Body[i + 1] << 8) | (uint)(Body[i + 2] << 16) | (uint)(Body[i + 3] << 24);  				Body[i + 0] ^= (byte)(state >> 0);  				Body[i + 1] ^= (byte)(state >> 8);  				Body[i + 2] ^= (byte)(state >> 16);  				Body[i + 3] ^= (byte)(state >> 24);  				state += data ^ counter;  				counter ^= (state >> 5) | (state << 27);  			}
Magic Number,Confuser.Protections.AntiTamper,JITMethodBody,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\JITBody.cs,Serialize,The following statement contains a magic number: for (uint i = 0; i < Body.Length; i += 4) {  				uint data = Body[i] | (uint)(Body[i + 1] << 8) | (uint)(Body[i + 2] << 16) | (uint)(Body[i + 3] << 24);  				Body[i + 0] ^= (byte)(state >> 0);  				Body[i + 1] ^= (byte)(state >> 8);  				Body[i + 2] ^= (byte)(state >> 16);  				Body[i + 3] ^= (byte)(state >> 24);  				state += data ^ counter;  				counter ^= (state >> 5) | (state << 27);  			}
Magic Number,Confuser.Protections.AntiTamper,JITMethodBody,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\JITBody.cs,Serialize,The following statement contains a magic number: for (uint i = 0; i < Body.Length; i += 4) {  				uint data = Body[i] | (uint)(Body[i + 1] << 8) | (uint)(Body[i + 2] << 16) | (uint)(Body[i + 3] << 24);  				Body[i + 0] ^= (byte)(state >> 0);  				Body[i + 1] ^= (byte)(state >> 8);  				Body[i + 2] ^= (byte)(state >> 16);  				Body[i + 3] ^= (byte)(state >> 24);  				state += data ^ counter;  				counter ^= (state >> 5) | (state << 27);  			}
Magic Number,Confuser.Protections.AntiTamper,JITMethodBodyWriter,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\JITBody.cs,Write,The following statement contains a magic number: if (exceptionHandlers.Count > 0) {  				jitBody.Options |= 8;  				for (int i = 0; i < exceptionHandlers.Count; i++) {  					ExceptionHandler eh = exceptionHandlers[i];  					jitBody.EHs[i].Flags = (uint)eh.HandlerType;    					uint tryStart = GetOffset(eh.TryStart);  					uint tryEnd = GetOffset(eh.TryEnd);  					jitBody.EHs[i].TryOffset = tryStart;  					jitBody.EHs[i].TryLength = tryEnd - tryStart;    					uint handlerStart = GetOffset(eh.HandlerStart);  					uint handlerEnd = GetOffset(eh.HandlerEnd);  					jitBody.EHs[i].HandlerOffset = handlerStart;  					jitBody.EHs[i].HandlerLength = handlerEnd - handlerStart;    					if (eh.HandlerType == ExceptionHandlerType.Catch) {  						uint token = metadata.GetToken(eh.CatchType).Raw;  						if ((token & 0xff000000) == 0x1b000000)  							jitBody.Options |= 0x80;    						jitBody.EHs[i].ClassTokenOrFilterOffset = token;  					}  					else if (eh.HandlerType == ExceptionHandlerType.Filter) {  						jitBody.EHs[i].ClassTokenOrFilterOffset = GetOffset(eh.FilterStart);  					}  				}  			}
Magic Number,Confuser.Protections.AntiTamper,JITBodyIndex,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\JITBody.cs,GetFileLength,The following statement contains a magic number: return (uint)bodies.Count * 8 + 4;
Magic Number,Confuser.Protections.AntiTamper,JITBodyIndex,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\JITBody.cs,GetFileLength,The following statement contains a magic number: return (uint)bodies.Count * 8 + 4;
Magic Number,Confuser.Protections.AntiTamper,JITBodyIndex,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\JITBody.cs,WriteTo,The following statement contains a magic number: uint length = GetFileLength() - 4;
Magic Number,Confuser.Protections.AntiTamper,JITBodyIndex,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\JITBody.cs,WriteTo,The following statement contains a magic number: foreach (var entry in bodies.OrderBy(entry => entry.Key)) {  				writer.Write(entry.Key);  				Debug.Assert(entry.Value != null);  				Debug.Assert((length + entry.Value.Offset) % 4 == 0);  				writer.Write((length + entry.Value.Offset) >> 2);  			}
Magic Number,Confuser.Protections.AntiTamper,JITBodyIndex,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\JITBody.cs,WriteTo,The following statement contains a magic number: foreach (var entry in bodies.OrderBy(entry => entry.Key)) {  				writer.Write(entry.Key);  				Debug.Assert(entry.Value != null);  				Debug.Assert((length + entry.Value.Offset) % 4 == 0);  				writer.Write((length + entry.Value.Offset) >> 2);  			}
Magic Number,Confuser.Protections.AntiTamper,JITBodyIndex,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\JITBody.cs,PopulateSection,The following statement contains a magic number: foreach (var entry in bodies.OrderBy(entry => entry.Key)) {  				Debug.Assert(entry.Value != null);  				section.Add(entry.Value' 4);  				entry.Value.Offset = offset;    				Debug.Assert(entry.Value.GetFileLength() % 4 == 0);  				offset += entry.Value.GetFileLength();  			}
Magic Number,Confuser.Protections.AntiTamper,JITBodyIndex,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\JITBody.cs,PopulateSection,The following statement contains a magic number: foreach (var entry in bodies.OrderBy(entry => entry.Key)) {  				Debug.Assert(entry.Value != null);  				section.Add(entry.Value' 4);  				entry.Value.Offset = offset;    				Debug.Assert(entry.Value.GetFileLength() % 4 == 0);  				offset += entry.Value.GetFileLength();  			}
Magic Number,Confuser.Protections.AntiTamper,JITMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\JITMode.cs,HandleInject,The following statement contains a magic number: fieldLayout = new byte[6];
Magic Number,Confuser.Protections.AntiTamper,JITMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\JITMode.cs,HandleInject,The following statement contains a magic number: for (int i = 0; i < 6; i++) {  				int index = random.NextInt32(0' 6);  				while (fieldLayout[index] != 0)  					index = random.NextInt32(0' 6);  				fieldLayout[index] = (byte)i;  			}
Magic Number,Confuser.Protections.AntiTamper,JITMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\JITMode.cs,HandleInject,The following statement contains a magic number: for (int i = 0; i < 6; i++) {  				int index = random.NextInt32(0' 6);  				while (fieldLayout[index] != 0)  					index = random.NextInt32(0' 6);  				fieldLayout[index] = (byte)i;  			}
Magic Number,Confuser.Protections.AntiTamper,JITMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\JITMode.cs,HandleInject,The following statement contains a magic number: for (int i = 0; i < 6; i++) {  				int index = random.NextInt32(0' 6);  				while (fieldLayout[index] != 0)  					index = random.NextInt32(0' 6);  				fieldLayout[index] = (byte)i;  			}
Magic Number,Confuser.Protections.AntiTamper,JITMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\JITMode.cs,HandleInject,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  				Instruction instr = instrs[i];  				if (instr.OpCode == OpCodes.Ldtoken) {  					instr.Operand = context.CurrentModule.GlobalType;  				}  				else if (instr.OpCode == OpCodes.Call) {  					var method = (IMethod)instr.Operand;  					if (method.DeclaringType.Name == "Mutation" &&  					    method.Name == "Crypt") {  						Instruction ldDst = instrs[i - 2];  						Instruction ldSrc = instrs[i - 1];  						Debug.Assert(ldDst.OpCode == OpCodes.Ldloc && ldSrc.OpCode == OpCodes.Ldloc);  						instrs.RemoveAt(i);  						instrs.RemoveAt(i - 1);  						instrs.RemoveAt(i - 2);  						instrs.InsertRange(i - 2' deriver.EmitDerivation(initMethod' context' (Local)ldDst.Operand' (Local)ldSrc.Operand));  					}  				}  			}
Magic Number,Confuser.Protections.AntiTamper,JITMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\JITMode.cs,HandleInject,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  				Instruction instr = instrs[i];  				if (instr.OpCode == OpCodes.Ldtoken) {  					instr.Operand = context.CurrentModule.GlobalType;  				}  				else if (instr.OpCode == OpCodes.Call) {  					var method = (IMethod)instr.Operand;  					if (method.DeclaringType.Name == "Mutation" &&  					    method.Name == "Crypt") {  						Instruction ldDst = instrs[i - 2];  						Instruction ldSrc = instrs[i - 1];  						Debug.Assert(ldDst.OpCode == OpCodes.Ldloc && ldSrc.OpCode == OpCodes.Ldloc);  						instrs.RemoveAt(i);  						instrs.RemoveAt(i - 1);  						instrs.RemoveAt(i - 2);  						instrs.InsertRange(i - 2' deriver.EmitDerivation(initMethod' context' (Local)ldDst.Operand' (Local)ldSrc.Operand));  					}  				}  			}
Magic Number,Confuser.Protections.AntiTamper,JITMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\JITMode.cs,HandleInject,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  				Instruction instr = instrs[i];  				if (instr.OpCode == OpCodes.Ldtoken) {  					instr.Operand = context.CurrentModule.GlobalType;  				}  				else if (instr.OpCode == OpCodes.Call) {  					var method = (IMethod)instr.Operand;  					if (method.DeclaringType.Name == "Mutation" &&  					    method.Name == "Crypt") {  						Instruction ldDst = instrs[i - 2];  						Instruction ldSrc = instrs[i - 1];  						Debug.Assert(ldDst.OpCode == OpCodes.Ldloc && ldSrc.OpCode == OpCodes.Ldloc);  						instrs.RemoveAt(i);  						instrs.RemoveAt(i - 1);  						instrs.RemoveAt(i - 2);  						instrs.InsertRange(i - 2' deriver.EmitDerivation(initMethod' context' (Local)ldDst.Operand' (Local)ldSrc.Operand));  					}  				}  			}
Magic Number,Confuser.Protections.AntiTamper,JITMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\JITMode.cs,HandleInject,The following statement contains a magic number: MutationHelper.InjectKeys(initMethod'  			                          new[] { 0' 1' 2' 3' 4 }'  			                          new[] { (int)(name1 * name2)' (int)z' (int)x' (int)c' (int)v });
Magic Number,Confuser.Protections.AntiTamper,JITMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\JITMode.cs,HandleInject,The following statement contains a magic number: MutationHelper.InjectKeys(initMethod'  			                          new[] { 0' 1' 2' 3' 4 }'  			                          new[] { (int)(name1 * name2)' (int)z' (int)x' (int)c' (int)v });
Magic Number,Confuser.Protections.AntiTamper,JITMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\JITMode.cs,HandleInject,The following statement contains a magic number: MutationHelper.InjectKeys(initMethod'  			                          new[] { 0' 1' 2' 3' 4 }'  			                          new[] { (int)(name1 * name2)' (int)z' (int)x' (int)c' (int)v });
Magic Number,Confuser.Protections.AntiTamper,JITMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\JITMode.cs,HandleInject,The following statement contains a magic number: foreach (IDnlibDef def in defs) {  				if (def.Name == "MethodData") {  					var dataType = (TypeDef)def;  					FieldDef[] fields = dataType.Fields.ToArray();  					var layout = fieldLayout.Clone() as byte[];  					Array.Sort(layout' fields);  					for (byte j = 0; j < 6; j++)  						layout[j] = j;  					Array.Sort(fieldLayout' layout);  					fieldLayout = layout;  					dataType.Fields.Clear();  					foreach (FieldDef f in fields)  						dataType.Fields.Add(f);  				}  				name.MarkHelper(def' marker' parent);  				if (def is MethodDef)  					parent.ExcludeMethod(context' (MethodDef)def);  			}
Magic Number,Confuser.Protections.AntiTamper,JITMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\JITMode.cs,CreateSection,The following statement contains a magic number: var nameBuffer = new byte[8];
Magic Number,Confuser.Protections.AntiTamper,JITMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\JITMode.cs,CreateSection,The following statement contains a magic number: nameBuffer[1] = (byte)(name1 >> 8);
Magic Number,Confuser.Protections.AntiTamper,JITMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\JITMode.cs,CreateSection,The following statement contains a magic number: nameBuffer[2] = (byte)(name1 >> 16);
Magic Number,Confuser.Protections.AntiTamper,JITMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\JITMode.cs,CreateSection,The following statement contains a magic number: nameBuffer[2] = (byte)(name1 >> 16);
Magic Number,Confuser.Protections.AntiTamper,JITMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\JITMode.cs,CreateSection,The following statement contains a magic number: nameBuffer[3] = (byte)(name1 >> 24);
Magic Number,Confuser.Protections.AntiTamper,JITMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\JITMode.cs,CreateSection,The following statement contains a magic number: nameBuffer[3] = (byte)(name1 >> 24);
Magic Number,Confuser.Protections.AntiTamper,JITMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\JITMode.cs,CreateSection,The following statement contains a magic number: nameBuffer[4] = (byte)(name2 >> 0);
Magic Number,Confuser.Protections.AntiTamper,JITMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\JITMode.cs,CreateSection,The following statement contains a magic number: nameBuffer[5] = (byte)(name2 >> 8);
Magic Number,Confuser.Protections.AntiTamper,JITMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\JITMode.cs,CreateSection,The following statement contains a magic number: nameBuffer[5] = (byte)(name2 >> 8);
Magic Number,Confuser.Protections.AntiTamper,JITMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\JITMode.cs,CreateSection,The following statement contains a magic number: nameBuffer[6] = (byte)(name2 >> 16);
Magic Number,Confuser.Protections.AntiTamper,JITMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\JITMode.cs,CreateSection,The following statement contains a magic number: nameBuffer[6] = (byte)(name2 >> 16);
Magic Number,Confuser.Protections.AntiTamper,JITMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\JITMode.cs,CreateSection,The following statement contains a magic number: nameBuffer[7] = (byte)(name2 >> 24);
Magic Number,Confuser.Protections.AntiTamper,JITMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\JITMode.cs,CreateSection,The following statement contains a magic number: nameBuffer[7] = (byte)(name2 >> 24);
Magic Number,Confuser.Protections.AntiTamper,JITMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\JITMode.cs,CreateSection,The following statement contains a magic number: newSection.Add(new ByteArrayChunk(new byte[4])' 4);
Magic Number,Confuser.Protections.AntiTamper,JITMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\JITMode.cs,CreateSection,The following statement contains a magic number: newSection.Add(new ByteArrayChunk(new byte[4])' 4);
Magic Number,Confuser.Protections.AntiTamper,JITMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\JITMode.cs,EncryptSection,The following statement contains a magic number: stream.Position += 6;
Magic Number,Confuser.Protections.AntiTamper,JITMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\JITMode.cs,EncryptSection,The following statement contains a magic number: stream.Position += 2 + optSize;
Magic Number,Confuser.Protections.AntiTamper,JITMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\JITMode.cs,EncryptSection,The following statement contains a magic number: for (int i = 0; i < sections; i++) {  				uint nameHash;  				if (origSects > 0) {  					origSects--;  					stream.Write(new byte[8]' 0' 8);  					nameHash = 0;  				}  				else  					nameHash = reader.ReadUInt32() * reader.ReadUInt32();  				stream.Position += 8;  				if (nameHash == name1 * name2) {  					encSize = reader.ReadUInt32();  					encLoc = reader.ReadUInt32();  				}  				else if (nameHash != 0) {  					uint sectSize = reader.ReadUInt32();  					uint sectLoc = reader.ReadUInt32();  					Hash(stream' reader' sectLoc' sectSize);  				}  				else  					stream.Position += 8;  				stream.Position += 16;  			}
Magic Number,Confuser.Protections.AntiTamper,JITMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\JITMode.cs,EncryptSection,The following statement contains a magic number: for (int i = 0; i < sections; i++) {  				uint nameHash;  				if (origSects > 0) {  					origSects--;  					stream.Write(new byte[8]' 0' 8);  					nameHash = 0;  				}  				else  					nameHash = reader.ReadUInt32() * reader.ReadUInt32();  				stream.Position += 8;  				if (nameHash == name1 * name2) {  					encSize = reader.ReadUInt32();  					encLoc = reader.ReadUInt32();  				}  				else if (nameHash != 0) {  					uint sectSize = reader.ReadUInt32();  					uint sectLoc = reader.ReadUInt32();  					Hash(stream' reader' sectLoc' sectSize);  				}  				else  					stream.Position += 8;  				stream.Position += 16;  			}
Magic Number,Confuser.Protections.AntiTamper,JITMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\JITMode.cs,EncryptSection,The following statement contains a magic number: for (int i = 0; i < sections; i++) {  				uint nameHash;  				if (origSects > 0) {  					origSects--;  					stream.Write(new byte[8]' 0' 8);  					nameHash = 0;  				}  				else  					nameHash = reader.ReadUInt32() * reader.ReadUInt32();  				stream.Position += 8;  				if (nameHash == name1 * name2) {  					encSize = reader.ReadUInt32();  					encLoc = reader.ReadUInt32();  				}  				else if (nameHash != 0) {  					uint sectSize = reader.ReadUInt32();  					uint sectLoc = reader.ReadUInt32();  					Hash(stream' reader' sectLoc' sectSize);  				}  				else  					stream.Position += 8;  				stream.Position += 16;  			}
Magic Number,Confuser.Protections.AntiTamper,JITMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\JITMode.cs,EncryptSection,The following statement contains a magic number: for (int i = 0; i < sections; i++) {  				uint nameHash;  				if (origSects > 0) {  					origSects--;  					stream.Write(new byte[8]' 0' 8);  					nameHash = 0;  				}  				else  					nameHash = reader.ReadUInt32() * reader.ReadUInt32();  				stream.Position += 8;  				if (nameHash == name1 * name2) {  					encSize = reader.ReadUInt32();  					encLoc = reader.ReadUInt32();  				}  				else if (nameHash != 0) {  					uint sectSize = reader.ReadUInt32();  					uint sectLoc = reader.ReadUInt32();  					Hash(stream' reader' sectLoc' sectSize);  				}  				else  					stream.Position += 8;  				stream.Position += 16;  			}
Magic Number,Confuser.Protections.AntiTamper,JITMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\JITMode.cs,EncryptSection,The following statement contains a magic number: for (int i = 0; i < sections; i++) {  				uint nameHash;  				if (origSects > 0) {  					origSects--;  					stream.Write(new byte[8]' 0' 8);  					nameHash = 0;  				}  				else  					nameHash = reader.ReadUInt32() * reader.ReadUInt32();  				stream.Position += 8;  				if (nameHash == name1 * name2) {  					encSize = reader.ReadUInt32();  					encLoc = reader.ReadUInt32();  				}  				else if (nameHash != 0) {  					uint sectSize = reader.ReadUInt32();  					uint sectLoc = reader.ReadUInt32();  					Hash(stream' reader' sectLoc' sectSize);  				}  				else  					stream.Position += 8;  				stream.Position += 16;  			}
Magic Number,Confuser.Protections.AntiTamper,JITMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\JITMode.cs,EncryptSection,The following statement contains a magic number: encSize >>= 2;
Magic Number,Confuser.Protections.AntiTamper,JITMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\JITMode.cs,EncryptSection,The following statement contains a magic number: var byteResult = new byte[encSize << 2];
Magic Number,Confuser.Protections.AntiTamper,JITMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\JITMode.cs,Hash,The following statement contains a magic number: size >>= 2;
Magic Number,Confuser.Protections.AntiTamper,JITMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\JITMode.cs,DeriveKey,The following statement contains a magic number: for (int i = 0; i < 0x10; i++) {  				dst[i] = v;  				src[i] = x;  				z = (x >> 5) | (x << 27);  				x = (c >> 3) | (c << 29);  				c = (v >> 7) | (v << 25);  				v = (z >> 11) | (z << 21);  			}
Magic Number,Confuser.Protections.AntiTamper,JITMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\JITMode.cs,DeriveKey,The following statement contains a magic number: for (int i = 0; i < 0x10; i++) {  				dst[i] = v;  				src[i] = x;  				z = (x >> 5) | (x << 27);  				x = (c >> 3) | (c << 29);  				c = (v >> 7) | (v << 25);  				v = (z >> 11) | (z << 21);  			}
Magic Number,Confuser.Protections.AntiTamper,JITMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\JITMode.cs,DeriveKey,The following statement contains a magic number: for (int i = 0; i < 0x10; i++) {  				dst[i] = v;  				src[i] = x;  				z = (x >> 5) | (x << 27);  				x = (c >> 3) | (c << 29);  				c = (v >> 7) | (v << 25);  				v = (z >> 11) | (z << 21);  			}
Magic Number,Confuser.Protections.AntiTamper,JITMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\JITMode.cs,DeriveKey,The following statement contains a magic number: for (int i = 0; i < 0x10; i++) {  				dst[i] = v;  				src[i] = x;  				z = (x >> 5) | (x << 27);  				x = (c >> 3) | (c << 29);  				c = (v >> 7) | (v << 25);  				v = (z >> 11) | (z << 21);  			}
Magic Number,Confuser.Protections.AntiTamper,JITMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\JITMode.cs,DeriveKey,The following statement contains a magic number: for (int i = 0; i < 0x10; i++) {  				dst[i] = v;  				src[i] = x;  				z = (x >> 5) | (x << 27);  				x = (c >> 3) | (c << 29);  				c = (v >> 7) | (v << 25);  				v = (z >> 11) | (z << 21);  			}
Magic Number,Confuser.Protections.AntiTamper,JITMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\JITMode.cs,DeriveKey,The following statement contains a magic number: for (int i = 0; i < 0x10; i++) {  				dst[i] = v;  				src[i] = x;  				z = (x >> 5) | (x << 27);  				x = (c >> 3) | (c << 29);  				c = (v >> 7) | (v << 25);  				v = (z >> 11) | (z << 21);  			}
Magic Number,Confuser.Protections.AntiTamper,JITMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\JITMode.cs,DeriveKey,The following statement contains a magic number: for (int i = 0; i < 0x10; i++) {  				dst[i] = v;  				src[i] = x;  				z = (x >> 5) | (x << 27);  				x = (c >> 3) | (c << 29);  				c = (v >> 7) | (v << 25);  				v = (z >> 11) | (z << 21);  			}
Magic Number,Confuser.Protections.AntiTamper,JITMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\JITMode.cs,DeriveKey,The following statement contains a magic number: for (int i = 0; i < 0x10; i++) {  				dst[i] = v;  				src[i] = x;  				z = (x >> 5) | (x << 27);  				x = (c >> 3) | (c << 29);  				c = (v >> 7) | (v << 25);  				v = (z >> 11) | (z << 21);  			}
Magic Number,Confuser.Protections.AntiTamper,NormalDeriver,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\NormalDeriver.cs,DeriveKey,The following statement contains a magic number: for (int i = 0; i < 0x10; i++) {  				switch (i % 3) {  					case 0:  						ret[i] = a[i] ^ b[i];  						break;  					case 1:  						ret[i] = a[i] * b[i];  						break;  					case 2:  						ret[i] = a[i] + b[i];  						break;  				}  			}
Magic Number,Confuser.Protections.AntiTamper,NormalDeriver,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\NormalDeriver.cs,DeriveKey,The following statement contains a magic number: for (int i = 0; i < 0x10; i++) {  				switch (i % 3) {  					case 0:  						ret[i] = a[i] ^ b[i];  						break;  					case 1:  						ret[i] = a[i] * b[i];  						break;  					case 2:  						ret[i] = a[i] + b[i];  						break;  				}  			}
Magic Number,Confuser.Protections.AntiTamper,NormalDeriver,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\NormalDeriver.cs,EmitDerivation,The following statement contains a magic number: for (int i = 0; i < 0x10; i++) {  				yield return Instruction.Create(OpCodes.Ldloc' dst);  				yield return Instruction.Create(OpCodes.Ldc_I4' i);  				yield return Instruction.Create(OpCodes.Ldloc' dst);  				yield return Instruction.Create(OpCodes.Ldc_I4' i);  				yield return Instruction.Create(OpCodes.Ldelem_U4);  				yield return Instruction.Create(OpCodes.Ldloc' src);  				yield return Instruction.Create(OpCodes.Ldc_I4' i);  				yield return Instruction.Create(OpCodes.Ldelem_U4);  				switch (i % 3) {  					case 0:  						yield return Instruction.Create(OpCodes.Xor);  						break;  					case 1:  						yield return Instruction.Create(OpCodes.Mul);  						break;  					case 2:  						yield return Instruction.Create(OpCodes.Add);  						break;  				}  				yield return Instruction.Create(OpCodes.Stelem_I4);  			}
Magic Number,Confuser.Protections.AntiTamper,NormalDeriver,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\NormalDeriver.cs,EmitDerivation,The following statement contains a magic number: for (int i = 0; i < 0x10; i++) {  				yield return Instruction.Create(OpCodes.Ldloc' dst);  				yield return Instruction.Create(OpCodes.Ldc_I4' i);  				yield return Instruction.Create(OpCodes.Ldloc' dst);  				yield return Instruction.Create(OpCodes.Ldc_I4' i);  				yield return Instruction.Create(OpCodes.Ldelem_U4);  				yield return Instruction.Create(OpCodes.Ldloc' src);  				yield return Instruction.Create(OpCodes.Ldc_I4' i);  				yield return Instruction.Create(OpCodes.Ldelem_U4);  				switch (i % 3) {  					case 0:  						yield return Instruction.Create(OpCodes.Xor);  						break;  					case 1:  						yield return Instruction.Create(OpCodes.Mul);  						break;  					case 2:  						yield return Instruction.Create(OpCodes.Add);  						break;  				}  				yield return Instruction.Create(OpCodes.Stelem_I4);  			}
Magic Number,Confuser.Protections.AntiTamper,NormalMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\NormalMode.cs,HandleInject,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  				Instruction instr = instrs[i];  				if (instr.OpCode == OpCodes.Ldtoken) {  					instr.Operand = context.CurrentModule.GlobalType;  				}  				else if (instr.OpCode == OpCodes.Call) {  					var method = (IMethod)instr.Operand;  					if (method.DeclaringType.Name == "Mutation" &&  					    method.Name == "Crypt") {  						Instruction ldDst = instrs[i - 2];  						Instruction ldSrc = instrs[i - 1];  						Debug.Assert(ldDst.OpCode == OpCodes.Ldloc && ldSrc.OpCode == OpCodes.Ldloc);  						instrs.RemoveAt(i);  						instrs.RemoveAt(i - 1);  						instrs.RemoveAt(i - 2);  						instrs.InsertRange(i - 2' deriver.EmitDerivation(initMethod' context' (Local)ldDst.Operand' (Local)ldSrc.Operand));  					}  				}  			}
Magic Number,Confuser.Protections.AntiTamper,NormalMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\NormalMode.cs,HandleInject,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  				Instruction instr = instrs[i];  				if (instr.OpCode == OpCodes.Ldtoken) {  					instr.Operand = context.CurrentModule.GlobalType;  				}  				else if (instr.OpCode == OpCodes.Call) {  					var method = (IMethod)instr.Operand;  					if (method.DeclaringType.Name == "Mutation" &&  					    method.Name == "Crypt") {  						Instruction ldDst = instrs[i - 2];  						Instruction ldSrc = instrs[i - 1];  						Debug.Assert(ldDst.OpCode == OpCodes.Ldloc && ldSrc.OpCode == OpCodes.Ldloc);  						instrs.RemoveAt(i);  						instrs.RemoveAt(i - 1);  						instrs.RemoveAt(i - 2);  						instrs.InsertRange(i - 2' deriver.EmitDerivation(initMethod' context' (Local)ldDst.Operand' (Local)ldSrc.Operand));  					}  				}  			}
Magic Number,Confuser.Protections.AntiTamper,NormalMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\NormalMode.cs,HandleInject,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  				Instruction instr = instrs[i];  				if (instr.OpCode == OpCodes.Ldtoken) {  					instr.Operand = context.CurrentModule.GlobalType;  				}  				else if (instr.OpCode == OpCodes.Call) {  					var method = (IMethod)instr.Operand;  					if (method.DeclaringType.Name == "Mutation" &&  					    method.Name == "Crypt") {  						Instruction ldDst = instrs[i - 2];  						Instruction ldSrc = instrs[i - 1];  						Debug.Assert(ldDst.OpCode == OpCodes.Ldloc && ldSrc.OpCode == OpCodes.Ldloc);  						instrs.RemoveAt(i);  						instrs.RemoveAt(i - 1);  						instrs.RemoveAt(i - 2);  						instrs.InsertRange(i - 2' deriver.EmitDerivation(initMethod' context' (Local)ldDst.Operand' (Local)ldSrc.Operand));  					}  				}  			}
Magic Number,Confuser.Protections.AntiTamper,NormalMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\NormalMode.cs,HandleInject,The following statement contains a magic number: MutationHelper.InjectKeys(initMethod'  			                          new[] { 0' 1' 2' 3' 4 }'  			                          new[] { (int)(name1 * name2)' (int)z' (int)x' (int)c' (int)v });
Magic Number,Confuser.Protections.AntiTamper,NormalMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\NormalMode.cs,HandleInject,The following statement contains a magic number: MutationHelper.InjectKeys(initMethod'  			                          new[] { 0' 1' 2' 3' 4 }'  			                          new[] { (int)(name1 * name2)' (int)z' (int)x' (int)c' (int)v });
Magic Number,Confuser.Protections.AntiTamper,NormalMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\NormalMode.cs,HandleInject,The following statement contains a magic number: MutationHelper.InjectKeys(initMethod'  			                          new[] { 0' 1' 2' 3' 4 }'  			                          new[] { (int)(name1 * name2)' (int)z' (int)x' (int)c' (int)v });
Magic Number,Confuser.Protections.AntiTamper,NormalMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\NormalMode.cs,CreateSections,The following statement contains a magic number: var nameBuffer = new byte[8];
Magic Number,Confuser.Protections.AntiTamper,NormalMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\NormalMode.cs,CreateSections,The following statement contains a magic number: nameBuffer[1] = (byte)(name1 >> 8);
Magic Number,Confuser.Protections.AntiTamper,NormalMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\NormalMode.cs,CreateSections,The following statement contains a magic number: nameBuffer[2] = (byte)(name1 >> 16);
Magic Number,Confuser.Protections.AntiTamper,NormalMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\NormalMode.cs,CreateSections,The following statement contains a magic number: nameBuffer[2] = (byte)(name1 >> 16);
Magic Number,Confuser.Protections.AntiTamper,NormalMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\NormalMode.cs,CreateSections,The following statement contains a magic number: nameBuffer[3] = (byte)(name1 >> 24);
Magic Number,Confuser.Protections.AntiTamper,NormalMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\NormalMode.cs,CreateSections,The following statement contains a magic number: nameBuffer[3] = (byte)(name1 >> 24);
Magic Number,Confuser.Protections.AntiTamper,NormalMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\NormalMode.cs,CreateSections,The following statement contains a magic number: nameBuffer[4] = (byte)(name2 >> 0);
Magic Number,Confuser.Protections.AntiTamper,NormalMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\NormalMode.cs,CreateSections,The following statement contains a magic number: nameBuffer[5] = (byte)(name2 >> 8);
Magic Number,Confuser.Protections.AntiTamper,NormalMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\NormalMode.cs,CreateSections,The following statement contains a magic number: nameBuffer[5] = (byte)(name2 >> 8);
Magic Number,Confuser.Protections.AntiTamper,NormalMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\NormalMode.cs,CreateSections,The following statement contains a magic number: nameBuffer[6] = (byte)(name2 >> 16);
Magic Number,Confuser.Protections.AntiTamper,NormalMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\NormalMode.cs,CreateSections,The following statement contains a magic number: nameBuffer[6] = (byte)(name2 >> 16);
Magic Number,Confuser.Protections.AntiTamper,NormalMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\NormalMode.cs,CreateSections,The following statement contains a magic number: nameBuffer[7] = (byte)(name2 >> 24);
Magic Number,Confuser.Protections.AntiTamper,NormalMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\NormalMode.cs,CreateSections,The following statement contains a magic number: nameBuffer[7] = (byte)(name2 >> 24);
Magic Number,Confuser.Protections.AntiTamper,NormalMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\NormalMode.cs,CreateSections,The following statement contains a magic number: newSection.Add(encryptedChunk' 4);
Magic Number,Confuser.Protections.AntiTamper,NormalMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\NormalMode.cs,CreateSections,The following statement contains a magic number: newSection.Add(new ByteArrayChunk(new byte[4])' 4);
Magic Number,Confuser.Protections.AntiTamper,NormalMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\NormalMode.cs,CreateSections,The following statement contains a magic number: newSection.Add(new ByteArrayChunk(new byte[4])' 4);
Magic Number,Confuser.Protections.AntiTamper,NormalMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\NormalMode.cs,EncryptSection,The following statement contains a magic number: stream.Position += 6;
Magic Number,Confuser.Protections.AntiTamper,NormalMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\NormalMode.cs,EncryptSection,The following statement contains a magic number: stream.Position += 2 + optSize;
Magic Number,Confuser.Protections.AntiTamper,NormalMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\NormalMode.cs,EncryptSection,The following statement contains a magic number: for (int i = 0; i < sections; i++) {  				uint nameHash;  				if (origSects > 0) {  					origSects--;  					stream.Write(new byte[8]' 0' 8);  					nameHash = 0;  				}  				else  					nameHash = reader.ReadUInt32() * reader.ReadUInt32();  				stream.Position += 8;  				if (nameHash == name1 * name2) {  					encSize = reader.ReadUInt32();  					encLoc = reader.ReadUInt32();  				}  				else if (nameHash != 0) {  					uint sectSize = reader.ReadUInt32();  					uint sectLoc = reader.ReadUInt32();  					Hash(stream' reader' sectLoc' sectSize);  				}  				else  					stream.Position += 8;  				stream.Position += 16;  			}
Magic Number,Confuser.Protections.AntiTamper,NormalMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\NormalMode.cs,EncryptSection,The following statement contains a magic number: for (int i = 0; i < sections; i++) {  				uint nameHash;  				if (origSects > 0) {  					origSects--;  					stream.Write(new byte[8]' 0' 8);  					nameHash = 0;  				}  				else  					nameHash = reader.ReadUInt32() * reader.ReadUInt32();  				stream.Position += 8;  				if (nameHash == name1 * name2) {  					encSize = reader.ReadUInt32();  					encLoc = reader.ReadUInt32();  				}  				else if (nameHash != 0) {  					uint sectSize = reader.ReadUInt32();  					uint sectLoc = reader.ReadUInt32();  					Hash(stream' reader' sectLoc' sectSize);  				}  				else  					stream.Position += 8;  				stream.Position += 16;  			}
Magic Number,Confuser.Protections.AntiTamper,NormalMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\NormalMode.cs,EncryptSection,The following statement contains a magic number: for (int i = 0; i < sections; i++) {  				uint nameHash;  				if (origSects > 0) {  					origSects--;  					stream.Write(new byte[8]' 0' 8);  					nameHash = 0;  				}  				else  					nameHash = reader.ReadUInt32() * reader.ReadUInt32();  				stream.Position += 8;  				if (nameHash == name1 * name2) {  					encSize = reader.ReadUInt32();  					encLoc = reader.ReadUInt32();  				}  				else if (nameHash != 0) {  					uint sectSize = reader.ReadUInt32();  					uint sectLoc = reader.ReadUInt32();  					Hash(stream' reader' sectLoc' sectSize);  				}  				else  					stream.Position += 8;  				stream.Position += 16;  			}
Magic Number,Confuser.Protections.AntiTamper,NormalMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\NormalMode.cs,EncryptSection,The following statement contains a magic number: for (int i = 0; i < sections; i++) {  				uint nameHash;  				if (origSects > 0) {  					origSects--;  					stream.Write(new byte[8]' 0' 8);  					nameHash = 0;  				}  				else  					nameHash = reader.ReadUInt32() * reader.ReadUInt32();  				stream.Position += 8;  				if (nameHash == name1 * name2) {  					encSize = reader.ReadUInt32();  					encLoc = reader.ReadUInt32();  				}  				else if (nameHash != 0) {  					uint sectSize = reader.ReadUInt32();  					uint sectLoc = reader.ReadUInt32();  					Hash(stream' reader' sectLoc' sectSize);  				}  				else  					stream.Position += 8;  				stream.Position += 16;  			}
Magic Number,Confuser.Protections.AntiTamper,NormalMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\NormalMode.cs,EncryptSection,The following statement contains a magic number: for (int i = 0; i < sections; i++) {  				uint nameHash;  				if (origSects > 0) {  					origSects--;  					stream.Write(new byte[8]' 0' 8);  					nameHash = 0;  				}  				else  					nameHash = reader.ReadUInt32() * reader.ReadUInt32();  				stream.Position += 8;  				if (nameHash == name1 * name2) {  					encSize = reader.ReadUInt32();  					encLoc = reader.ReadUInt32();  				}  				else if (nameHash != 0) {  					uint sectSize = reader.ReadUInt32();  					uint sectLoc = reader.ReadUInt32();  					Hash(stream' reader' sectLoc' sectSize);  				}  				else  					stream.Position += 8;  				stream.Position += 16;  			}
Magic Number,Confuser.Protections.AntiTamper,NormalMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\NormalMode.cs,EncryptSection,The following statement contains a magic number: encSize >>= 2;
Magic Number,Confuser.Protections.AntiTamper,NormalMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\NormalMode.cs,EncryptSection,The following statement contains a magic number: var byteResult = new byte[encSize << 2];
Magic Number,Confuser.Protections.AntiTamper,NormalMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\NormalMode.cs,Hash,The following statement contains a magic number: size >>= 2;
Magic Number,Confuser.Protections.AntiTamper,NormalMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\NormalMode.cs,DeriveKey,The following statement contains a magic number: for (int i = 0; i < 0x10; i++) {  				dst[i] = v;  				src[i] = x;  				z = (x >> 5) | (x << 27);  				x = (c >> 3) | (c << 29);  				c = (v >> 7) | (v << 25);  				v = (z >> 11) | (z << 21);  			}
Magic Number,Confuser.Protections.AntiTamper,NormalMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\NormalMode.cs,DeriveKey,The following statement contains a magic number: for (int i = 0; i < 0x10; i++) {  				dst[i] = v;  				src[i] = x;  				z = (x >> 5) | (x << 27);  				x = (c >> 3) | (c << 29);  				c = (v >> 7) | (v << 25);  				v = (z >> 11) | (z << 21);  			}
Magic Number,Confuser.Protections.AntiTamper,NormalMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\NormalMode.cs,DeriveKey,The following statement contains a magic number: for (int i = 0; i < 0x10; i++) {  				dst[i] = v;  				src[i] = x;  				z = (x >> 5) | (x << 27);  				x = (c >> 3) | (c << 29);  				c = (v >> 7) | (v << 25);  				v = (z >> 11) | (z << 21);  			}
Magic Number,Confuser.Protections.AntiTamper,NormalMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\NormalMode.cs,DeriveKey,The following statement contains a magic number: for (int i = 0; i < 0x10; i++) {  				dst[i] = v;  				src[i] = x;  				z = (x >> 5) | (x << 27);  				x = (c >> 3) | (c << 29);  				c = (v >> 7) | (v << 25);  				v = (z >> 11) | (z << 21);  			}
Magic Number,Confuser.Protections.AntiTamper,NormalMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\NormalMode.cs,DeriveKey,The following statement contains a magic number: for (int i = 0; i < 0x10; i++) {  				dst[i] = v;  				src[i] = x;  				z = (x >> 5) | (x << 27);  				x = (c >> 3) | (c << 29);  				c = (v >> 7) | (v << 25);  				v = (z >> 11) | (z << 21);  			}
Magic Number,Confuser.Protections.AntiTamper,NormalMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\NormalMode.cs,DeriveKey,The following statement contains a magic number: for (int i = 0; i < 0x10; i++) {  				dst[i] = v;  				src[i] = x;  				z = (x >> 5) | (x << 27);  				x = (c >> 3) | (c << 29);  				c = (v >> 7) | (v << 25);  				v = (z >> 11) | (z << 21);  			}
Magic Number,Confuser.Protections.AntiTamper,NormalMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\NormalMode.cs,DeriveKey,The following statement contains a magic number: for (int i = 0; i < 0x10; i++) {  				dst[i] = v;  				src[i] = x;  				z = (x >> 5) | (x << 27);  				x = (c >> 3) | (c << 29);  				c = (v >> 7) | (v << 25);  				v = (z >> 11) | (z << 21);  			}
Magic Number,Confuser.Protections.AntiTamper,NormalMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\NormalMode.cs,DeriveKey,The following statement contains a magic number: for (int i = 0; i < 0x10; i++) {  				dst[i] = v;  				src[i] = x;  				z = (x >> 5) | (x << 27);  				x = (c >> 3) | (c << 29);  				c = (v >> 7) | (v << 25);  				v = (z >> 11) | (z << 21);  			}
Magic Number,Confuser.Protections.Compress,CompressorContext,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Compress\CompressorContext.cs,Encrypt,The following statement contains a magic number: Array.Resize(ref data' (data.Length + 3) & ~3);
Magic Number,Confuser.Protections.Compress,CompressorContext,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Compress\CompressorContext.cs,Encrypt,The following statement contains a magic number: Array.Resize(ref data' (data.Length + 3) & ~3);
Magic Number,Confuser.Protections.Compress,CompressorContext,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Compress\CompressorContext.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i < data.Length; i += 4) {  				var datum = (uint)(data[i + 0] | (data[i + 1] << 8) | (data[i + 2] << 16) | (data[i + 3] << 24));  				uint encrypted = datum ^ key[keyIndex & 0xf];  				key[keyIndex & 0xf] = (key[keyIndex & 0xf] ^ datum) + 0x3ddb2819;  				encryptedData[i + 0] = (byte)(encrypted >> 0);  				encryptedData[i + 1] = (byte)(encrypted >> 8);  				encryptedData[i + 2] = (byte)(encrypted >> 16);  				encryptedData[i + 3] = (byte)(encrypted >> 24);  				keyIndex++;  			}
Magic Number,Confuser.Protections.Compress,CompressorContext,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Compress\CompressorContext.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i < data.Length; i += 4) {  				var datum = (uint)(data[i + 0] | (data[i + 1] << 8) | (data[i + 2] << 16) | (data[i + 3] << 24));  				uint encrypted = datum ^ key[keyIndex & 0xf];  				key[keyIndex & 0xf] = (key[keyIndex & 0xf] ^ datum) + 0x3ddb2819;  				encryptedData[i + 0] = (byte)(encrypted >> 0);  				encryptedData[i + 1] = (byte)(encrypted >> 8);  				encryptedData[i + 2] = (byte)(encrypted >> 16);  				encryptedData[i + 3] = (byte)(encrypted >> 24);  				keyIndex++;  			}
Magic Number,Confuser.Protections.Compress,CompressorContext,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Compress\CompressorContext.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i < data.Length; i += 4) {  				var datum = (uint)(data[i + 0] | (data[i + 1] << 8) | (data[i + 2] << 16) | (data[i + 3] << 24));  				uint encrypted = datum ^ key[keyIndex & 0xf];  				key[keyIndex & 0xf] = (key[keyIndex & 0xf] ^ datum) + 0x3ddb2819;  				encryptedData[i + 0] = (byte)(encrypted >> 0);  				encryptedData[i + 1] = (byte)(encrypted >> 8);  				encryptedData[i + 2] = (byte)(encrypted >> 16);  				encryptedData[i + 3] = (byte)(encrypted >> 24);  				keyIndex++;  			}
Magic Number,Confuser.Protections.Compress,CompressorContext,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Compress\CompressorContext.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i < data.Length; i += 4) {  				var datum = (uint)(data[i + 0] | (data[i + 1] << 8) | (data[i + 2] << 16) | (data[i + 3] << 24));  				uint encrypted = datum ^ key[keyIndex & 0xf];  				key[keyIndex & 0xf] = (key[keyIndex & 0xf] ^ datum) + 0x3ddb2819;  				encryptedData[i + 0] = (byte)(encrypted >> 0);  				encryptedData[i + 1] = (byte)(encrypted >> 8);  				encryptedData[i + 2] = (byte)(encrypted >> 16);  				encryptedData[i + 3] = (byte)(encrypted >> 24);  				keyIndex++;  			}
Magic Number,Confuser.Protections.Compress,CompressorContext,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Compress\CompressorContext.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i < data.Length; i += 4) {  				var datum = (uint)(data[i + 0] | (data[i + 1] << 8) | (data[i + 2] << 16) | (data[i + 3] << 24));  				uint encrypted = datum ^ key[keyIndex & 0xf];  				key[keyIndex & 0xf] = (key[keyIndex & 0xf] ^ datum) + 0x3ddb2819;  				encryptedData[i + 0] = (byte)(encrypted >> 0);  				encryptedData[i + 1] = (byte)(encrypted >> 8);  				encryptedData[i + 2] = (byte)(encrypted >> 16);  				encryptedData[i + 3] = (byte)(encrypted >> 24);  				keyIndex++;  			}
Magic Number,Confuser.Protections.Compress,CompressorContext,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Compress\CompressorContext.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i < data.Length; i += 4) {  				var datum = (uint)(data[i + 0] | (data[i + 1] << 8) | (data[i + 2] << 16) | (data[i + 3] << 24));  				uint encrypted = datum ^ key[keyIndex & 0xf];  				key[keyIndex & 0xf] = (key[keyIndex & 0xf] ^ datum) + 0x3ddb2819;  				encryptedData[i + 0] = (byte)(encrypted >> 0);  				encryptedData[i + 1] = (byte)(encrypted >> 8);  				encryptedData[i + 2] = (byte)(encrypted >> 16);  				encryptedData[i + 3] = (byte)(encrypted >> 24);  				keyIndex++;  			}
Magic Number,Confuser.Protections.Compress,CompressorContext,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Compress\CompressorContext.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i < data.Length; i += 4) {  				var datum = (uint)(data[i + 0] | (data[i + 1] << 8) | (data[i + 2] << 16) | (data[i + 3] << 24));  				uint encrypted = datum ^ key[keyIndex & 0xf];  				key[keyIndex & 0xf] = (key[keyIndex & 0xf] ^ datum) + 0x3ddb2819;  				encryptedData[i + 0] = (byte)(encrypted >> 0);  				encryptedData[i + 1] = (byte)(encrypted >> 8);  				encryptedData[i + 2] = (byte)(encrypted >> 16);  				encryptedData[i + 3] = (byte)(encrypted >> 24);  				keyIndex++;  			}
Magic Number,Confuser.Protections.Compress,CompressorContext,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Compress\CompressorContext.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i < data.Length; i += 4) {  				var datum = (uint)(data[i + 0] | (data[i + 1] << 8) | (data[i + 2] << 16) | (data[i + 3] << 24));  				uint encrypted = datum ^ key[keyIndex & 0xf];  				key[keyIndex & 0xf] = (key[keyIndex & 0xf] ^ datum) + 0x3ddb2819;  				encryptedData[i + 0] = (byte)(encrypted >> 0);  				encryptedData[i + 1] = (byte)(encrypted >> 8);  				encryptedData[i + 2] = (byte)(encrypted >> 16);  				encryptedData[i + 3] = (byte)(encrypted >> 24);  				keyIndex++;  			}
Magic Number,Confuser.Protections.Compress,CompressorContext,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Compress\CompressorContext.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i < data.Length; i += 4) {  				var datum = (uint)(data[i + 0] | (data[i + 1] << 8) | (data[i + 2] << 16) | (data[i + 3] << 24));  				uint encrypted = datum ^ key[keyIndex & 0xf];  				key[keyIndex & 0xf] = (key[keyIndex & 0xf] ^ datum) + 0x3ddb2819;  				encryptedData[i + 0] = (byte)(encrypted >> 0);  				encryptedData[i + 1] = (byte)(encrypted >> 8);  				encryptedData[i + 2] = (byte)(encrypted >> 16);  				encryptedData[i + 3] = (byte)(encrypted >> 24);  				keyIndex++;  			}
Magic Number,Confuser.Protections.Compress,CompressorContext,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Compress\CompressorContext.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i < data.Length; i += 4) {  				var datum = (uint)(data[i + 0] | (data[i + 1] << 8) | (data[i + 2] << 16) | (data[i + 3] << 24));  				uint encrypted = datum ^ key[keyIndex & 0xf];  				key[keyIndex & 0xf] = (key[keyIndex & 0xf] ^ datum) + 0x3ddb2819;  				encryptedData[i + 0] = (byte)(encrypted >> 0);  				encryptedData[i + 1] = (byte)(encrypted >> 8);  				encryptedData[i + 2] = (byte)(encrypted >> 16);  				encryptedData[i + 3] = (byte)(encrypted >> 24);  				keyIndex++;  			}
Magic Number,Confuser.Protections.Compress,CompressorContext,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Compress\CompressorContext.cs,Encrypt,The following statement contains a magic number: for (int i = 0; i < data.Length; i += 4) {  				var datum = (uint)(data[i + 0] | (data[i + 1] << 8) | (data[i + 2] << 16) | (data[i + 3] << 24));  				uint encrypted = datum ^ key[keyIndex & 0xf];  				key[keyIndex & 0xf] = (key[keyIndex & 0xf] ^ datum) + 0x3ddb2819;  				encryptedData[i + 0] = (byte)(encrypted >> 0);  				encryptedData[i + 1] = (byte)(encrypted >> 8);  				encryptedData[i + 2] = (byte)(encrypted >> 16);  				encryptedData[i + 3] = (byte)(encrypted >> 24);  				keyIndex++;  			}
Magic Number,Confuser.Protections.Compress,NormalDeriver,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Compress\NormalDeriver.cs,DeriveKey,The following statement contains a magic number: for (int i = 0; i < 0x10; i++) {  				switch (state % 3) {  					case 0:  						ret[i] = a[i] ^ b[i];  						break;  					case 1:  						ret[i] = a[i] * b[i];  						break;  					case 2:  						ret[i] = a[i] + b[i];  						break;  				}  				state = (state * state) % 0x2E082D35;  				switch (state % 3) {  					case 0:  						ret[i] += k1;  						break;  					case 1:  						ret[i] ^= k2;  						break;  					case 2:  						ret[i] *= k3;  						break;  				}  				state = (state * state) % 0x2E082D35;  			}
Magic Number,Confuser.Protections.Compress,NormalDeriver,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Compress\NormalDeriver.cs,DeriveKey,The following statement contains a magic number: for (int i = 0; i < 0x10; i++) {  				switch (state % 3) {  					case 0:  						ret[i] = a[i] ^ b[i];  						break;  					case 1:  						ret[i] = a[i] * b[i];  						break;  					case 2:  						ret[i] = a[i] + b[i];  						break;  				}  				state = (state * state) % 0x2E082D35;  				switch (state % 3) {  					case 0:  						ret[i] += k1;  						break;  					case 1:  						ret[i] ^= k2;  						break;  					case 2:  						ret[i] *= k3;  						break;  				}  				state = (state * state) % 0x2E082D35;  			}
Magic Number,Confuser.Protections.Compress,NormalDeriver,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Compress\NormalDeriver.cs,DeriveKey,The following statement contains a magic number: for (int i = 0; i < 0x10; i++) {  				switch (state % 3) {  					case 0:  						ret[i] = a[i] ^ b[i];  						break;  					case 1:  						ret[i] = a[i] * b[i];  						break;  					case 2:  						ret[i] = a[i] + b[i];  						break;  				}  				state = (state * state) % 0x2E082D35;  				switch (state % 3) {  					case 0:  						ret[i] += k1;  						break;  					case 1:  						ret[i] ^= k2;  						break;  					case 2:  						ret[i] *= k3;  						break;  				}  				state = (state * state) % 0x2E082D35;  			}
Magic Number,Confuser.Protections.Compress,NormalDeriver,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Compress\NormalDeriver.cs,DeriveKey,The following statement contains a magic number: for (int i = 0; i < 0x10; i++) {  				switch (state % 3) {  					case 0:  						ret[i] = a[i] ^ b[i];  						break;  					case 1:  						ret[i] = a[i] * b[i];  						break;  					case 2:  						ret[i] = a[i] + b[i];  						break;  				}  				state = (state * state) % 0x2E082D35;  				switch (state % 3) {  					case 0:  						ret[i] += k1;  						break;  					case 1:  						ret[i] ^= k2;  						break;  					case 2:  						ret[i] *= k3;  						break;  				}  				state = (state * state) % 0x2E082D35;  			}
Magic Number,Confuser.Protections.Compress,NormalDeriver,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Compress\NormalDeriver.cs,EmitDerivation,The following statement contains a magic number: for (int i = 0; i < 0x10; i++) {  				yield return Instruction.Create(OpCodes.Ldloc' dst);  				yield return Instruction.Create(OpCodes.Ldc_I4' i);  				yield return Instruction.Create(OpCodes.Ldloc' dst);  				yield return Instruction.Create(OpCodes.Ldc_I4' i);  				yield return Instruction.Create(OpCodes.Ldelem_U4);  				yield return Instruction.Create(OpCodes.Ldloc' src);  				yield return Instruction.Create(OpCodes.Ldc_I4' i);  				yield return Instruction.Create(OpCodes.Ldelem_U4);  				switch (state % 3) {  					case 0:  						yield return Instruction.Create(OpCodes.Xor);  						break;  					case 1:  						yield return Instruction.Create(OpCodes.Mul);  						break;  					case 2:  						yield return Instruction.Create(OpCodes.Add);  						break;  				}  				state = (state * state) % 0x2E082D35;  				switch (state % 3) {  					case 0:  						yield return Instruction.Create(OpCodes.Ldc_I4' (int)k1);  						yield return Instruction.Create(OpCodes.Add);  						break;  					case 1:  						yield return Instruction.Create(OpCodes.Ldc_I4' (int)k2);  						yield return Instruction.Create(OpCodes.Xor);  						break;  					case 2:  						yield return Instruction.Create(OpCodes.Ldc_I4' (int)k3);  						yield return Instruction.Create(OpCodes.Mul);  						break;  				}  				state = (state * state) % 0x2E082D35;  				yield return Instruction.Create(OpCodes.Stelem_I4);  			}
Magic Number,Confuser.Protections.Compress,NormalDeriver,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Compress\NormalDeriver.cs,EmitDerivation,The following statement contains a magic number: for (int i = 0; i < 0x10; i++) {  				yield return Instruction.Create(OpCodes.Ldloc' dst);  				yield return Instruction.Create(OpCodes.Ldc_I4' i);  				yield return Instruction.Create(OpCodes.Ldloc' dst);  				yield return Instruction.Create(OpCodes.Ldc_I4' i);  				yield return Instruction.Create(OpCodes.Ldelem_U4);  				yield return Instruction.Create(OpCodes.Ldloc' src);  				yield return Instruction.Create(OpCodes.Ldc_I4' i);  				yield return Instruction.Create(OpCodes.Ldelem_U4);  				switch (state % 3) {  					case 0:  						yield return Instruction.Create(OpCodes.Xor);  						break;  					case 1:  						yield return Instruction.Create(OpCodes.Mul);  						break;  					case 2:  						yield return Instruction.Create(OpCodes.Add);  						break;  				}  				state = (state * state) % 0x2E082D35;  				switch (state % 3) {  					case 0:  						yield return Instruction.Create(OpCodes.Ldc_I4' (int)k1);  						yield return Instruction.Create(OpCodes.Add);  						break;  					case 1:  						yield return Instruction.Create(OpCodes.Ldc_I4' (int)k2);  						yield return Instruction.Create(OpCodes.Xor);  						break;  					case 2:  						yield return Instruction.Create(OpCodes.Ldc_I4' (int)k3);  						yield return Instruction.Create(OpCodes.Mul);  						break;  				}  				state = (state * state) % 0x2E082D35;  				yield return Instruction.Create(OpCodes.Stelem_I4);  			}
Magic Number,Confuser.Protections.Compress,NormalDeriver,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Compress\NormalDeriver.cs,EmitDerivation,The following statement contains a magic number: for (int i = 0; i < 0x10; i++) {  				yield return Instruction.Create(OpCodes.Ldloc' dst);  				yield return Instruction.Create(OpCodes.Ldc_I4' i);  				yield return Instruction.Create(OpCodes.Ldloc' dst);  				yield return Instruction.Create(OpCodes.Ldc_I4' i);  				yield return Instruction.Create(OpCodes.Ldelem_U4);  				yield return Instruction.Create(OpCodes.Ldloc' src);  				yield return Instruction.Create(OpCodes.Ldc_I4' i);  				yield return Instruction.Create(OpCodes.Ldelem_U4);  				switch (state % 3) {  					case 0:  						yield return Instruction.Create(OpCodes.Xor);  						break;  					case 1:  						yield return Instruction.Create(OpCodes.Mul);  						break;  					case 2:  						yield return Instruction.Create(OpCodes.Add);  						break;  				}  				state = (state * state) % 0x2E082D35;  				switch (state % 3) {  					case 0:  						yield return Instruction.Create(OpCodes.Ldc_I4' (int)k1);  						yield return Instruction.Create(OpCodes.Add);  						break;  					case 1:  						yield return Instruction.Create(OpCodes.Ldc_I4' (int)k2);  						yield return Instruction.Create(OpCodes.Xor);  						break;  					case 2:  						yield return Instruction.Create(OpCodes.Ldc_I4' (int)k3);  						yield return Instruction.Create(OpCodes.Mul);  						break;  				}  				state = (state * state) % 0x2E082D35;  				yield return Instruction.Create(OpCodes.Stelem_I4);  			}
Magic Number,Confuser.Protections.Compress,NormalDeriver,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Compress\NormalDeriver.cs,EmitDerivation,The following statement contains a magic number: for (int i = 0; i < 0x10; i++) {  				yield return Instruction.Create(OpCodes.Ldloc' dst);  				yield return Instruction.Create(OpCodes.Ldc_I4' i);  				yield return Instruction.Create(OpCodes.Ldloc' dst);  				yield return Instruction.Create(OpCodes.Ldc_I4' i);  				yield return Instruction.Create(OpCodes.Ldelem_U4);  				yield return Instruction.Create(OpCodes.Ldloc' src);  				yield return Instruction.Create(OpCodes.Ldc_I4' i);  				yield return Instruction.Create(OpCodes.Ldelem_U4);  				switch (state % 3) {  					case 0:  						yield return Instruction.Create(OpCodes.Xor);  						break;  					case 1:  						yield return Instruction.Create(OpCodes.Mul);  						break;  					case 2:  						yield return Instruction.Create(OpCodes.Add);  						break;  				}  				state = (state * state) % 0x2E082D35;  				switch (state % 3) {  					case 0:  						yield return Instruction.Create(OpCodes.Ldc_I4' (int)k1);  						yield return Instruction.Create(OpCodes.Add);  						break;  					case 1:  						yield return Instruction.Create(OpCodes.Ldc_I4' (int)k2);  						yield return Instruction.Create(OpCodes.Xor);  						break;  					case 2:  						yield return Instruction.Create(OpCodes.Ldc_I4' (int)k3);  						yield return Instruction.Create(OpCodes.Mul);  						break;  				}  				state = (state * state) % 0x2E082D35;  				yield return Instruction.Create(OpCodes.Stelem_I4);  			}
Magic Number,Confuser.Protections.Constants,ReferenceReplacer,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\ReferenceReplacer.cs,InsertEmptyStateUpdate,The following statement contains a magic number: if (key.Type == BlockKeyType.Incremental) {  				// Incremental    				CFGState exit;  				if (!ctx.StatesMap.TryGetValue(key.ExitState' out exit)) {  					// Create new exit state  					// Update one of the entry states to be exit state  					exit = entry;  					int updateId = ctx.Random.NextInt32(3);  					uint targetValue = ctx.Random.NextUInt32();  					exit.UpdateExplicit(updateId' targetValue);    					int getId = ctx.Random.NextInt32(3);  					var fl = CFGState.EncodeFlag(false' updateId' getId);  					var incr = entry.GetIncrementalUpdate(updateId' targetValue);    					body.Instructions.Insert(targetIndex++' first = Instruction.Create(OpCodes.Ldloca' ctx.StateVariable));  					body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Ldc_I4_S' (sbyte)fl));  					body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Ldc_I4' (int)incr));  					body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Call' ctx.Ctx.CfgCtxNext));  					body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Pop));    					ctx.StatesMap[key.ExitState] = exit;  				}  				else {  					// Scan for updated state  					var headerIndex = targetIndex;  					for (int stateId = 0; stateId < 4; stateId++) {  						if (entry.Get(stateId) == exit.Get(stateId))  							continue;    						uint targetValue = exit.Get(stateId);  						int getId = ctx.Random.NextInt32(3);  						var fl = CFGState.EncodeFlag(false' stateId' getId);  						var incr = entry.GetIncrementalUpdate(stateId' targetValue);    						body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Ldloca' ctx.StateVariable));  						body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Ldc_I4_S' (sbyte)fl));  						body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Ldc_I4' (int)incr));  						body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Call' ctx.Ctx.CfgCtxNext));  						body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Pop));  					}  					first = body.Instructions[headerIndex];  				}  			}  			else {  				// Explicit    				CFGState exit;  				if (!ctx.StatesMap.TryGetValue(key.ExitState' out exit)) {  					// Create new exit state from random seed  					var seed = ctx.Random.NextUInt32();  					exit = new CFGState(seed);  					body.Instructions.Insert(targetIndex++' first = Instruction.Create(OpCodes.Ldloca' ctx.StateVariable));  					body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Ldc_I4' (int)seed));  					body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Call' ctx.Ctx.CfgCtxCtor));    					ctx.StatesMap[key.ExitState] = exit;  				}  				else {  					// Scan for updated state  					var headerIndex = targetIndex;  					for (int stateId = 0; stateId < 4; stateId++) {  						uint targetValue = exit.Get(stateId);  						int getId = ctx.Random.NextInt32(3);  						var fl = CFGState.EncodeFlag(true' stateId' getId);    						body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Ldloca' ctx.StateVariable));  						body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Ldc_I4_S' (sbyte)fl));  						body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Ldc_I4' (int)targetValue));  						body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Call' ctx.Ctx.CfgCtxNext));  						body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Pop));  					}  					first = body.Instructions[headerIndex];  				}  			}
Magic Number,Confuser.Protections.Constants,ReferenceReplacer,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\ReferenceReplacer.cs,InsertEmptyStateUpdate,The following statement contains a magic number: if (key.Type == BlockKeyType.Incremental) {  				// Incremental    				CFGState exit;  				if (!ctx.StatesMap.TryGetValue(key.ExitState' out exit)) {  					// Create new exit state  					// Update one of the entry states to be exit state  					exit = entry;  					int updateId = ctx.Random.NextInt32(3);  					uint targetValue = ctx.Random.NextUInt32();  					exit.UpdateExplicit(updateId' targetValue);    					int getId = ctx.Random.NextInt32(3);  					var fl = CFGState.EncodeFlag(false' updateId' getId);  					var incr = entry.GetIncrementalUpdate(updateId' targetValue);    					body.Instructions.Insert(targetIndex++' first = Instruction.Create(OpCodes.Ldloca' ctx.StateVariable));  					body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Ldc_I4_S' (sbyte)fl));  					body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Ldc_I4' (int)incr));  					body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Call' ctx.Ctx.CfgCtxNext));  					body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Pop));    					ctx.StatesMap[key.ExitState] = exit;  				}  				else {  					// Scan for updated state  					var headerIndex = targetIndex;  					for (int stateId = 0; stateId < 4; stateId++) {  						if (entry.Get(stateId) == exit.Get(stateId))  							continue;    						uint targetValue = exit.Get(stateId);  						int getId = ctx.Random.NextInt32(3);  						var fl = CFGState.EncodeFlag(false' stateId' getId);  						var incr = entry.GetIncrementalUpdate(stateId' targetValue);    						body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Ldloca' ctx.StateVariable));  						body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Ldc_I4_S' (sbyte)fl));  						body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Ldc_I4' (int)incr));  						body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Call' ctx.Ctx.CfgCtxNext));  						body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Pop));  					}  					first = body.Instructions[headerIndex];  				}  			}  			else {  				// Explicit    				CFGState exit;  				if (!ctx.StatesMap.TryGetValue(key.ExitState' out exit)) {  					// Create new exit state from random seed  					var seed = ctx.Random.NextUInt32();  					exit = new CFGState(seed);  					body.Instructions.Insert(targetIndex++' first = Instruction.Create(OpCodes.Ldloca' ctx.StateVariable));  					body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Ldc_I4' (int)seed));  					body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Call' ctx.Ctx.CfgCtxCtor));    					ctx.StatesMap[key.ExitState] = exit;  				}  				else {  					// Scan for updated state  					var headerIndex = targetIndex;  					for (int stateId = 0; stateId < 4; stateId++) {  						uint targetValue = exit.Get(stateId);  						int getId = ctx.Random.NextInt32(3);  						var fl = CFGState.EncodeFlag(true' stateId' getId);    						body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Ldloca' ctx.StateVariable));  						body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Ldc_I4_S' (sbyte)fl));  						body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Ldc_I4' (int)targetValue));  						body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Call' ctx.Ctx.CfgCtxNext));  						body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Pop));  					}  					first = body.Instructions[headerIndex];  				}  			}
Magic Number,Confuser.Protections.Constants,ReferenceReplacer,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\ReferenceReplacer.cs,InsertEmptyStateUpdate,The following statement contains a magic number: if (key.Type == BlockKeyType.Incremental) {  				// Incremental    				CFGState exit;  				if (!ctx.StatesMap.TryGetValue(key.ExitState' out exit)) {  					// Create new exit state  					// Update one of the entry states to be exit state  					exit = entry;  					int updateId = ctx.Random.NextInt32(3);  					uint targetValue = ctx.Random.NextUInt32();  					exit.UpdateExplicit(updateId' targetValue);    					int getId = ctx.Random.NextInt32(3);  					var fl = CFGState.EncodeFlag(false' updateId' getId);  					var incr = entry.GetIncrementalUpdate(updateId' targetValue);    					body.Instructions.Insert(targetIndex++' first = Instruction.Create(OpCodes.Ldloca' ctx.StateVariable));  					body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Ldc_I4_S' (sbyte)fl));  					body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Ldc_I4' (int)incr));  					body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Call' ctx.Ctx.CfgCtxNext));  					body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Pop));    					ctx.StatesMap[key.ExitState] = exit;  				}  				else {  					// Scan for updated state  					var headerIndex = targetIndex;  					for (int stateId = 0; stateId < 4; stateId++) {  						if (entry.Get(stateId) == exit.Get(stateId))  							continue;    						uint targetValue = exit.Get(stateId);  						int getId = ctx.Random.NextInt32(3);  						var fl = CFGState.EncodeFlag(false' stateId' getId);  						var incr = entry.GetIncrementalUpdate(stateId' targetValue);    						body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Ldloca' ctx.StateVariable));  						body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Ldc_I4_S' (sbyte)fl));  						body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Ldc_I4' (int)incr));  						body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Call' ctx.Ctx.CfgCtxNext));  						body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Pop));  					}  					first = body.Instructions[headerIndex];  				}  			}  			else {  				// Explicit    				CFGState exit;  				if (!ctx.StatesMap.TryGetValue(key.ExitState' out exit)) {  					// Create new exit state from random seed  					var seed = ctx.Random.NextUInt32();  					exit = new CFGState(seed);  					body.Instructions.Insert(targetIndex++' first = Instruction.Create(OpCodes.Ldloca' ctx.StateVariable));  					body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Ldc_I4' (int)seed));  					body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Call' ctx.Ctx.CfgCtxCtor));    					ctx.StatesMap[key.ExitState] = exit;  				}  				else {  					// Scan for updated state  					var headerIndex = targetIndex;  					for (int stateId = 0; stateId < 4; stateId++) {  						uint targetValue = exit.Get(stateId);  						int getId = ctx.Random.NextInt32(3);  						var fl = CFGState.EncodeFlag(true' stateId' getId);    						body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Ldloca' ctx.StateVariable));  						body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Ldc_I4_S' (sbyte)fl));  						body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Ldc_I4' (int)targetValue));  						body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Call' ctx.Ctx.CfgCtxNext));  						body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Pop));  					}  					first = body.Instructions[headerIndex];  				}  			}
Magic Number,Confuser.Protections.Constants,ReferenceReplacer,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\ReferenceReplacer.cs,InsertEmptyStateUpdate,The following statement contains a magic number: if (key.Type == BlockKeyType.Incremental) {  				// Incremental    				CFGState exit;  				if (!ctx.StatesMap.TryGetValue(key.ExitState' out exit)) {  					// Create new exit state  					// Update one of the entry states to be exit state  					exit = entry;  					int updateId = ctx.Random.NextInt32(3);  					uint targetValue = ctx.Random.NextUInt32();  					exit.UpdateExplicit(updateId' targetValue);    					int getId = ctx.Random.NextInt32(3);  					var fl = CFGState.EncodeFlag(false' updateId' getId);  					var incr = entry.GetIncrementalUpdate(updateId' targetValue);    					body.Instructions.Insert(targetIndex++' first = Instruction.Create(OpCodes.Ldloca' ctx.StateVariable));  					body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Ldc_I4_S' (sbyte)fl));  					body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Ldc_I4' (int)incr));  					body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Call' ctx.Ctx.CfgCtxNext));  					body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Pop));    					ctx.StatesMap[key.ExitState] = exit;  				}  				else {  					// Scan for updated state  					var headerIndex = targetIndex;  					for (int stateId = 0; stateId < 4; stateId++) {  						if (entry.Get(stateId) == exit.Get(stateId))  							continue;    						uint targetValue = exit.Get(stateId);  						int getId = ctx.Random.NextInt32(3);  						var fl = CFGState.EncodeFlag(false' stateId' getId);  						var incr = entry.GetIncrementalUpdate(stateId' targetValue);    						body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Ldloca' ctx.StateVariable));  						body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Ldc_I4_S' (sbyte)fl));  						body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Ldc_I4' (int)incr));  						body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Call' ctx.Ctx.CfgCtxNext));  						body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Pop));  					}  					first = body.Instructions[headerIndex];  				}  			}  			else {  				// Explicit    				CFGState exit;  				if (!ctx.StatesMap.TryGetValue(key.ExitState' out exit)) {  					// Create new exit state from random seed  					var seed = ctx.Random.NextUInt32();  					exit = new CFGState(seed);  					body.Instructions.Insert(targetIndex++' first = Instruction.Create(OpCodes.Ldloca' ctx.StateVariable));  					body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Ldc_I4' (int)seed));  					body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Call' ctx.Ctx.CfgCtxCtor));    					ctx.StatesMap[key.ExitState] = exit;  				}  				else {  					// Scan for updated state  					var headerIndex = targetIndex;  					for (int stateId = 0; stateId < 4; stateId++) {  						uint targetValue = exit.Get(stateId);  						int getId = ctx.Random.NextInt32(3);  						var fl = CFGState.EncodeFlag(true' stateId' getId);    						body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Ldloca' ctx.StateVariable));  						body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Ldc_I4_S' (sbyte)fl));  						body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Ldc_I4' (int)targetValue));  						body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Call' ctx.Ctx.CfgCtxNext));  						body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Pop));  					}  					first = body.Instructions[headerIndex];  				}  			}
Magic Number,Confuser.Protections.Constants,ReferenceReplacer,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\ReferenceReplacer.cs,InsertEmptyStateUpdate,The following statement contains a magic number: if (key.Type == BlockKeyType.Incremental) {  				// Incremental    				CFGState exit;  				if (!ctx.StatesMap.TryGetValue(key.ExitState' out exit)) {  					// Create new exit state  					// Update one of the entry states to be exit state  					exit = entry;  					int updateId = ctx.Random.NextInt32(3);  					uint targetValue = ctx.Random.NextUInt32();  					exit.UpdateExplicit(updateId' targetValue);    					int getId = ctx.Random.NextInt32(3);  					var fl = CFGState.EncodeFlag(false' updateId' getId);  					var incr = entry.GetIncrementalUpdate(updateId' targetValue);    					body.Instructions.Insert(targetIndex++' first = Instruction.Create(OpCodes.Ldloca' ctx.StateVariable));  					body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Ldc_I4_S' (sbyte)fl));  					body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Ldc_I4' (int)incr));  					body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Call' ctx.Ctx.CfgCtxNext));  					body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Pop));    					ctx.StatesMap[key.ExitState] = exit;  				}  				else {  					// Scan for updated state  					var headerIndex = targetIndex;  					for (int stateId = 0; stateId < 4; stateId++) {  						if (entry.Get(stateId) == exit.Get(stateId))  							continue;    						uint targetValue = exit.Get(stateId);  						int getId = ctx.Random.NextInt32(3);  						var fl = CFGState.EncodeFlag(false' stateId' getId);  						var incr = entry.GetIncrementalUpdate(stateId' targetValue);    						body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Ldloca' ctx.StateVariable));  						body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Ldc_I4_S' (sbyte)fl));  						body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Ldc_I4' (int)incr));  						body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Call' ctx.Ctx.CfgCtxNext));  						body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Pop));  					}  					first = body.Instructions[headerIndex];  				}  			}  			else {  				// Explicit    				CFGState exit;  				if (!ctx.StatesMap.TryGetValue(key.ExitState' out exit)) {  					// Create new exit state from random seed  					var seed = ctx.Random.NextUInt32();  					exit = new CFGState(seed);  					body.Instructions.Insert(targetIndex++' first = Instruction.Create(OpCodes.Ldloca' ctx.StateVariable));  					body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Ldc_I4' (int)seed));  					body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Call' ctx.Ctx.CfgCtxCtor));    					ctx.StatesMap[key.ExitState] = exit;  				}  				else {  					// Scan for updated state  					var headerIndex = targetIndex;  					for (int stateId = 0; stateId < 4; stateId++) {  						uint targetValue = exit.Get(stateId);  						int getId = ctx.Random.NextInt32(3);  						var fl = CFGState.EncodeFlag(true' stateId' getId);    						body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Ldloca' ctx.StateVariable));  						body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Ldc_I4_S' (sbyte)fl));  						body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Ldc_I4' (int)targetValue));  						body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Call' ctx.Ctx.CfgCtxNext));  						body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Pop));  					}  					first = body.Instructions[headerIndex];  				}  			}
Magic Number,Confuser.Protections.Constants,ReferenceReplacer,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\ReferenceReplacer.cs,InsertEmptyStateUpdate,The following statement contains a magic number: if (key.Type == BlockKeyType.Incremental) {  				// Incremental    				CFGState exit;  				if (!ctx.StatesMap.TryGetValue(key.ExitState' out exit)) {  					// Create new exit state  					// Update one of the entry states to be exit state  					exit = entry;  					int updateId = ctx.Random.NextInt32(3);  					uint targetValue = ctx.Random.NextUInt32();  					exit.UpdateExplicit(updateId' targetValue);    					int getId = ctx.Random.NextInt32(3);  					var fl = CFGState.EncodeFlag(false' updateId' getId);  					var incr = entry.GetIncrementalUpdate(updateId' targetValue);    					body.Instructions.Insert(targetIndex++' first = Instruction.Create(OpCodes.Ldloca' ctx.StateVariable));  					body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Ldc_I4_S' (sbyte)fl));  					body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Ldc_I4' (int)incr));  					body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Call' ctx.Ctx.CfgCtxNext));  					body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Pop));    					ctx.StatesMap[key.ExitState] = exit;  				}  				else {  					// Scan for updated state  					var headerIndex = targetIndex;  					for (int stateId = 0; stateId < 4; stateId++) {  						if (entry.Get(stateId) == exit.Get(stateId))  							continue;    						uint targetValue = exit.Get(stateId);  						int getId = ctx.Random.NextInt32(3);  						var fl = CFGState.EncodeFlag(false' stateId' getId);  						var incr = entry.GetIncrementalUpdate(stateId' targetValue);    						body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Ldloca' ctx.StateVariable));  						body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Ldc_I4_S' (sbyte)fl));  						body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Ldc_I4' (int)incr));  						body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Call' ctx.Ctx.CfgCtxNext));  						body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Pop));  					}  					first = body.Instructions[headerIndex];  				}  			}  			else {  				// Explicit    				CFGState exit;  				if (!ctx.StatesMap.TryGetValue(key.ExitState' out exit)) {  					// Create new exit state from random seed  					var seed = ctx.Random.NextUInt32();  					exit = new CFGState(seed);  					body.Instructions.Insert(targetIndex++' first = Instruction.Create(OpCodes.Ldloca' ctx.StateVariable));  					body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Ldc_I4' (int)seed));  					body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Call' ctx.Ctx.CfgCtxCtor));    					ctx.StatesMap[key.ExitState] = exit;  				}  				else {  					// Scan for updated state  					var headerIndex = targetIndex;  					for (int stateId = 0; stateId < 4; stateId++) {  						uint targetValue = exit.Get(stateId);  						int getId = ctx.Random.NextInt32(3);  						var fl = CFGState.EncodeFlag(true' stateId' getId);    						body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Ldloca' ctx.StateVariable));  						body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Ldc_I4_S' (sbyte)fl));  						body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Ldc_I4' (int)targetValue));  						body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Call' ctx.Ctx.CfgCtxNext));  						body.Instructions.Insert(targetIndex++' Instruction.Create(OpCodes.Pop));  					}  					first = body.Instructions[headerIndex];  				}  			}
Magic Number,Confuser.Protections.Constants,ReferenceReplacer,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\ReferenceReplacer.cs,InsertStateGetAndUpdate,The following statement contains a magic number: if (type == BlockKeyType.Incremental) {  				// Incremental    				if (targetState == null) {  					// Randomly update and get state  					int updateId = ctx.Random.NextInt32(3);  					uint targetValue = ctx.Random.NextUInt32();    					int getId = ctx.Random.NextInt32(3);  					var fl = CFGState.EncodeFlag(false' updateId' getId);  					var incr = currentState.GetIncrementalUpdate(updateId' targetValue);  					currentState.UpdateExplicit(updateId' targetValue);    					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldloca' ctx.StateVariable));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4_S' (sbyte)fl));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4' (int)incr));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Call' ctx.Ctx.CfgCtxNext));    					return currentState.Get(getId);  				}  				// Scan for updated state  				int[] stateIds = { 0' 1' 2' 3 };  				ctx.Random.Shuffle(stateIds);  				int i = 0;  				uint getValue = 0;  				foreach (var stateId in stateIds) {  					// There must be at least one update&get  					if (currentState.Get(stateId) == targetState.Value.Get(stateId) &&  					    i != stateIds.Length - 1) {  						i++;  						continue;  					}    					uint targetValue = targetState.Value.Get(stateId);  					int getId = ctx.Random.NextInt32(3);  					var fl = CFGState.EncodeFlag(false' stateId' getId);  					var incr = currentState.GetIncrementalUpdate(stateId' targetValue);  					currentState.UpdateExplicit(stateId' targetValue);    					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldloca' ctx.StateVariable));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4_S' (sbyte)fl));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4' (int)incr));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Call' ctx.Ctx.CfgCtxNext));    					i++;  					if (i == stateIds.Length)  						getValue = currentState.Get(getId);  					else  						body.Instructions.Insert(index++' Instruction.Create(OpCodes.Pop));  				}  				return getValue;  			}  			else {  				// Explicit    				if (targetState == null) {  					// Create new exit state from random seed  					var seed = ctx.Random.NextUInt32();  					currentState = new CFGState(seed);  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldloca' ctx.StateVariable));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Dup));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4' (int)seed));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Call' ctx.Ctx.CfgCtxCtor));    					// Randomly get state  					int updateId = ctx.Random.NextInt32(3);  					uint targetValue = ctx.Random.NextUInt32();    					int getId = ctx.Random.NextInt32(3);  					var fl = CFGState.EncodeFlag(false' updateId' getId);  					var incr = currentState.GetIncrementalUpdate(updateId' targetValue);  					currentState.UpdateExplicit(updateId' targetValue);    					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4_S' (sbyte)fl));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4' (int)incr));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Call' ctx.Ctx.CfgCtxNext));    					return currentState.Get(getId);  				}  				else {  					// Scan for updated state  					int[] stateIds = { 0' 1' 2' 3 };  					ctx.Random.Shuffle(stateIds);  					int i = 0;  					uint getValue = 0;  					foreach (var stateId in stateIds) {  						uint targetValue = targetState.Value.Get(stateId);  						int getId = ctx.Random.NextInt32(3);  						var fl = CFGState.EncodeFlag(true' stateId' getId);  						currentState.UpdateExplicit(stateId' targetValue);    						body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldloca' ctx.StateVariable));  						body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4_S' (sbyte)fl));  						body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4' (int)targetValue));  						body.Instructions.Insert(index++' Instruction.Create(OpCodes.Call' ctx.Ctx.CfgCtxNext));    						i++;  						if (i == stateIds.Length)  							getValue = targetState.Value.Get(getId);  						else  							body.Instructions.Insert(index++' Instruction.Create(OpCodes.Pop));  					}  					return getValue;  				}  			}
Magic Number,Confuser.Protections.Constants,ReferenceReplacer,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\ReferenceReplacer.cs,InsertStateGetAndUpdate,The following statement contains a magic number: if (type == BlockKeyType.Incremental) {  				// Incremental    				if (targetState == null) {  					// Randomly update and get state  					int updateId = ctx.Random.NextInt32(3);  					uint targetValue = ctx.Random.NextUInt32();    					int getId = ctx.Random.NextInt32(3);  					var fl = CFGState.EncodeFlag(false' updateId' getId);  					var incr = currentState.GetIncrementalUpdate(updateId' targetValue);  					currentState.UpdateExplicit(updateId' targetValue);    					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldloca' ctx.StateVariable));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4_S' (sbyte)fl));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4' (int)incr));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Call' ctx.Ctx.CfgCtxNext));    					return currentState.Get(getId);  				}  				// Scan for updated state  				int[] stateIds = { 0' 1' 2' 3 };  				ctx.Random.Shuffle(stateIds);  				int i = 0;  				uint getValue = 0;  				foreach (var stateId in stateIds) {  					// There must be at least one update&get  					if (currentState.Get(stateId) == targetState.Value.Get(stateId) &&  					    i != stateIds.Length - 1) {  						i++;  						continue;  					}    					uint targetValue = targetState.Value.Get(stateId);  					int getId = ctx.Random.NextInt32(3);  					var fl = CFGState.EncodeFlag(false' stateId' getId);  					var incr = currentState.GetIncrementalUpdate(stateId' targetValue);  					currentState.UpdateExplicit(stateId' targetValue);    					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldloca' ctx.StateVariable));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4_S' (sbyte)fl));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4' (int)incr));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Call' ctx.Ctx.CfgCtxNext));    					i++;  					if (i == stateIds.Length)  						getValue = currentState.Get(getId);  					else  						body.Instructions.Insert(index++' Instruction.Create(OpCodes.Pop));  				}  				return getValue;  			}  			else {  				// Explicit    				if (targetState == null) {  					// Create new exit state from random seed  					var seed = ctx.Random.NextUInt32();  					currentState = new CFGState(seed);  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldloca' ctx.StateVariable));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Dup));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4' (int)seed));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Call' ctx.Ctx.CfgCtxCtor));    					// Randomly get state  					int updateId = ctx.Random.NextInt32(3);  					uint targetValue = ctx.Random.NextUInt32();    					int getId = ctx.Random.NextInt32(3);  					var fl = CFGState.EncodeFlag(false' updateId' getId);  					var incr = currentState.GetIncrementalUpdate(updateId' targetValue);  					currentState.UpdateExplicit(updateId' targetValue);    					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4_S' (sbyte)fl));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4' (int)incr));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Call' ctx.Ctx.CfgCtxNext));    					return currentState.Get(getId);  				}  				else {  					// Scan for updated state  					int[] stateIds = { 0' 1' 2' 3 };  					ctx.Random.Shuffle(stateIds);  					int i = 0;  					uint getValue = 0;  					foreach (var stateId in stateIds) {  						uint targetValue = targetState.Value.Get(stateId);  						int getId = ctx.Random.NextInt32(3);  						var fl = CFGState.EncodeFlag(true' stateId' getId);  						currentState.UpdateExplicit(stateId' targetValue);    						body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldloca' ctx.StateVariable));  						body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4_S' (sbyte)fl));  						body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4' (int)targetValue));  						body.Instructions.Insert(index++' Instruction.Create(OpCodes.Call' ctx.Ctx.CfgCtxNext));    						i++;  						if (i == stateIds.Length)  							getValue = targetState.Value.Get(getId);  						else  							body.Instructions.Insert(index++' Instruction.Create(OpCodes.Pop));  					}  					return getValue;  				}  			}
Magic Number,Confuser.Protections.Constants,ReferenceReplacer,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\ReferenceReplacer.cs,InsertStateGetAndUpdate,The following statement contains a magic number: if (type == BlockKeyType.Incremental) {  				// Incremental    				if (targetState == null) {  					// Randomly update and get state  					int updateId = ctx.Random.NextInt32(3);  					uint targetValue = ctx.Random.NextUInt32();    					int getId = ctx.Random.NextInt32(3);  					var fl = CFGState.EncodeFlag(false' updateId' getId);  					var incr = currentState.GetIncrementalUpdate(updateId' targetValue);  					currentState.UpdateExplicit(updateId' targetValue);    					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldloca' ctx.StateVariable));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4_S' (sbyte)fl));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4' (int)incr));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Call' ctx.Ctx.CfgCtxNext));    					return currentState.Get(getId);  				}  				// Scan for updated state  				int[] stateIds = { 0' 1' 2' 3 };  				ctx.Random.Shuffle(stateIds);  				int i = 0;  				uint getValue = 0;  				foreach (var stateId in stateIds) {  					// There must be at least one update&get  					if (currentState.Get(stateId) == targetState.Value.Get(stateId) &&  					    i != stateIds.Length - 1) {  						i++;  						continue;  					}    					uint targetValue = targetState.Value.Get(stateId);  					int getId = ctx.Random.NextInt32(3);  					var fl = CFGState.EncodeFlag(false' stateId' getId);  					var incr = currentState.GetIncrementalUpdate(stateId' targetValue);  					currentState.UpdateExplicit(stateId' targetValue);    					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldloca' ctx.StateVariable));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4_S' (sbyte)fl));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4' (int)incr));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Call' ctx.Ctx.CfgCtxNext));    					i++;  					if (i == stateIds.Length)  						getValue = currentState.Get(getId);  					else  						body.Instructions.Insert(index++' Instruction.Create(OpCodes.Pop));  				}  				return getValue;  			}  			else {  				// Explicit    				if (targetState == null) {  					// Create new exit state from random seed  					var seed = ctx.Random.NextUInt32();  					currentState = new CFGState(seed);  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldloca' ctx.StateVariable));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Dup));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4' (int)seed));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Call' ctx.Ctx.CfgCtxCtor));    					// Randomly get state  					int updateId = ctx.Random.NextInt32(3);  					uint targetValue = ctx.Random.NextUInt32();    					int getId = ctx.Random.NextInt32(3);  					var fl = CFGState.EncodeFlag(false' updateId' getId);  					var incr = currentState.GetIncrementalUpdate(updateId' targetValue);  					currentState.UpdateExplicit(updateId' targetValue);    					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4_S' (sbyte)fl));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4' (int)incr));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Call' ctx.Ctx.CfgCtxNext));    					return currentState.Get(getId);  				}  				else {  					// Scan for updated state  					int[] stateIds = { 0' 1' 2' 3 };  					ctx.Random.Shuffle(stateIds);  					int i = 0;  					uint getValue = 0;  					foreach (var stateId in stateIds) {  						uint targetValue = targetState.Value.Get(stateId);  						int getId = ctx.Random.NextInt32(3);  						var fl = CFGState.EncodeFlag(true' stateId' getId);  						currentState.UpdateExplicit(stateId' targetValue);    						body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldloca' ctx.StateVariable));  						body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4_S' (sbyte)fl));  						body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4' (int)targetValue));  						body.Instructions.Insert(index++' Instruction.Create(OpCodes.Call' ctx.Ctx.CfgCtxNext));    						i++;  						if (i == stateIds.Length)  							getValue = targetState.Value.Get(getId);  						else  							body.Instructions.Insert(index++' Instruction.Create(OpCodes.Pop));  					}  					return getValue;  				}  			}
Magic Number,Confuser.Protections.Constants,ReferenceReplacer,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\ReferenceReplacer.cs,InsertStateGetAndUpdate,The following statement contains a magic number: if (type == BlockKeyType.Incremental) {  				// Incremental    				if (targetState == null) {  					// Randomly update and get state  					int updateId = ctx.Random.NextInt32(3);  					uint targetValue = ctx.Random.NextUInt32();    					int getId = ctx.Random.NextInt32(3);  					var fl = CFGState.EncodeFlag(false' updateId' getId);  					var incr = currentState.GetIncrementalUpdate(updateId' targetValue);  					currentState.UpdateExplicit(updateId' targetValue);    					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldloca' ctx.StateVariable));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4_S' (sbyte)fl));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4' (int)incr));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Call' ctx.Ctx.CfgCtxNext));    					return currentState.Get(getId);  				}  				// Scan for updated state  				int[] stateIds = { 0' 1' 2' 3 };  				ctx.Random.Shuffle(stateIds);  				int i = 0;  				uint getValue = 0;  				foreach (var stateId in stateIds) {  					// There must be at least one update&get  					if (currentState.Get(stateId) == targetState.Value.Get(stateId) &&  					    i != stateIds.Length - 1) {  						i++;  						continue;  					}    					uint targetValue = targetState.Value.Get(stateId);  					int getId = ctx.Random.NextInt32(3);  					var fl = CFGState.EncodeFlag(false' stateId' getId);  					var incr = currentState.GetIncrementalUpdate(stateId' targetValue);  					currentState.UpdateExplicit(stateId' targetValue);    					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldloca' ctx.StateVariable));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4_S' (sbyte)fl));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4' (int)incr));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Call' ctx.Ctx.CfgCtxNext));    					i++;  					if (i == stateIds.Length)  						getValue = currentState.Get(getId);  					else  						body.Instructions.Insert(index++' Instruction.Create(OpCodes.Pop));  				}  				return getValue;  			}  			else {  				// Explicit    				if (targetState == null) {  					// Create new exit state from random seed  					var seed = ctx.Random.NextUInt32();  					currentState = new CFGState(seed);  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldloca' ctx.StateVariable));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Dup));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4' (int)seed));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Call' ctx.Ctx.CfgCtxCtor));    					// Randomly get state  					int updateId = ctx.Random.NextInt32(3);  					uint targetValue = ctx.Random.NextUInt32();    					int getId = ctx.Random.NextInt32(3);  					var fl = CFGState.EncodeFlag(false' updateId' getId);  					var incr = currentState.GetIncrementalUpdate(updateId' targetValue);  					currentState.UpdateExplicit(updateId' targetValue);    					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4_S' (sbyte)fl));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4' (int)incr));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Call' ctx.Ctx.CfgCtxNext));    					return currentState.Get(getId);  				}  				else {  					// Scan for updated state  					int[] stateIds = { 0' 1' 2' 3 };  					ctx.Random.Shuffle(stateIds);  					int i = 0;  					uint getValue = 0;  					foreach (var stateId in stateIds) {  						uint targetValue = targetState.Value.Get(stateId);  						int getId = ctx.Random.NextInt32(3);  						var fl = CFGState.EncodeFlag(true' stateId' getId);  						currentState.UpdateExplicit(stateId' targetValue);    						body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldloca' ctx.StateVariable));  						body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4_S' (sbyte)fl));  						body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4' (int)targetValue));  						body.Instructions.Insert(index++' Instruction.Create(OpCodes.Call' ctx.Ctx.CfgCtxNext));    						i++;  						if (i == stateIds.Length)  							getValue = targetState.Value.Get(getId);  						else  							body.Instructions.Insert(index++' Instruction.Create(OpCodes.Pop));  					}  					return getValue;  				}  			}
Magic Number,Confuser.Protections.Constants,ReferenceReplacer,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\ReferenceReplacer.cs,InsertStateGetAndUpdate,The following statement contains a magic number: if (type == BlockKeyType.Incremental) {  				// Incremental    				if (targetState == null) {  					// Randomly update and get state  					int updateId = ctx.Random.NextInt32(3);  					uint targetValue = ctx.Random.NextUInt32();    					int getId = ctx.Random.NextInt32(3);  					var fl = CFGState.EncodeFlag(false' updateId' getId);  					var incr = currentState.GetIncrementalUpdate(updateId' targetValue);  					currentState.UpdateExplicit(updateId' targetValue);    					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldloca' ctx.StateVariable));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4_S' (sbyte)fl));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4' (int)incr));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Call' ctx.Ctx.CfgCtxNext));    					return currentState.Get(getId);  				}  				// Scan for updated state  				int[] stateIds = { 0' 1' 2' 3 };  				ctx.Random.Shuffle(stateIds);  				int i = 0;  				uint getValue = 0;  				foreach (var stateId in stateIds) {  					// There must be at least one update&get  					if (currentState.Get(stateId) == targetState.Value.Get(stateId) &&  					    i != stateIds.Length - 1) {  						i++;  						continue;  					}    					uint targetValue = targetState.Value.Get(stateId);  					int getId = ctx.Random.NextInt32(3);  					var fl = CFGState.EncodeFlag(false' stateId' getId);  					var incr = currentState.GetIncrementalUpdate(stateId' targetValue);  					currentState.UpdateExplicit(stateId' targetValue);    					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldloca' ctx.StateVariable));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4_S' (sbyte)fl));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4' (int)incr));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Call' ctx.Ctx.CfgCtxNext));    					i++;  					if (i == stateIds.Length)  						getValue = currentState.Get(getId);  					else  						body.Instructions.Insert(index++' Instruction.Create(OpCodes.Pop));  				}  				return getValue;  			}  			else {  				// Explicit    				if (targetState == null) {  					// Create new exit state from random seed  					var seed = ctx.Random.NextUInt32();  					currentState = new CFGState(seed);  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldloca' ctx.StateVariable));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Dup));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4' (int)seed));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Call' ctx.Ctx.CfgCtxCtor));    					// Randomly get state  					int updateId = ctx.Random.NextInt32(3);  					uint targetValue = ctx.Random.NextUInt32();    					int getId = ctx.Random.NextInt32(3);  					var fl = CFGState.EncodeFlag(false' updateId' getId);  					var incr = currentState.GetIncrementalUpdate(updateId' targetValue);  					currentState.UpdateExplicit(updateId' targetValue);    					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4_S' (sbyte)fl));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4' (int)incr));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Call' ctx.Ctx.CfgCtxNext));    					return currentState.Get(getId);  				}  				else {  					// Scan for updated state  					int[] stateIds = { 0' 1' 2' 3 };  					ctx.Random.Shuffle(stateIds);  					int i = 0;  					uint getValue = 0;  					foreach (var stateId in stateIds) {  						uint targetValue = targetState.Value.Get(stateId);  						int getId = ctx.Random.NextInt32(3);  						var fl = CFGState.EncodeFlag(true' stateId' getId);  						currentState.UpdateExplicit(stateId' targetValue);    						body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldloca' ctx.StateVariable));  						body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4_S' (sbyte)fl));  						body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4' (int)targetValue));  						body.Instructions.Insert(index++' Instruction.Create(OpCodes.Call' ctx.Ctx.CfgCtxNext));    						i++;  						if (i == stateIds.Length)  							getValue = targetState.Value.Get(getId);  						else  							body.Instructions.Insert(index++' Instruction.Create(OpCodes.Pop));  					}  					return getValue;  				}  			}
Magic Number,Confuser.Protections.Constants,ReferenceReplacer,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\ReferenceReplacer.cs,InsertStateGetAndUpdate,The following statement contains a magic number: if (type == BlockKeyType.Incremental) {  				// Incremental    				if (targetState == null) {  					// Randomly update and get state  					int updateId = ctx.Random.NextInt32(3);  					uint targetValue = ctx.Random.NextUInt32();    					int getId = ctx.Random.NextInt32(3);  					var fl = CFGState.EncodeFlag(false' updateId' getId);  					var incr = currentState.GetIncrementalUpdate(updateId' targetValue);  					currentState.UpdateExplicit(updateId' targetValue);    					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldloca' ctx.StateVariable));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4_S' (sbyte)fl));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4' (int)incr));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Call' ctx.Ctx.CfgCtxNext));    					return currentState.Get(getId);  				}  				// Scan for updated state  				int[] stateIds = { 0' 1' 2' 3 };  				ctx.Random.Shuffle(stateIds);  				int i = 0;  				uint getValue = 0;  				foreach (var stateId in stateIds) {  					// There must be at least one update&get  					if (currentState.Get(stateId) == targetState.Value.Get(stateId) &&  					    i != stateIds.Length - 1) {  						i++;  						continue;  					}    					uint targetValue = targetState.Value.Get(stateId);  					int getId = ctx.Random.NextInt32(3);  					var fl = CFGState.EncodeFlag(false' stateId' getId);  					var incr = currentState.GetIncrementalUpdate(stateId' targetValue);  					currentState.UpdateExplicit(stateId' targetValue);    					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldloca' ctx.StateVariable));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4_S' (sbyte)fl));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4' (int)incr));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Call' ctx.Ctx.CfgCtxNext));    					i++;  					if (i == stateIds.Length)  						getValue = currentState.Get(getId);  					else  						body.Instructions.Insert(index++' Instruction.Create(OpCodes.Pop));  				}  				return getValue;  			}  			else {  				// Explicit    				if (targetState == null) {  					// Create new exit state from random seed  					var seed = ctx.Random.NextUInt32();  					currentState = new CFGState(seed);  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldloca' ctx.StateVariable));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Dup));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4' (int)seed));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Call' ctx.Ctx.CfgCtxCtor));    					// Randomly get state  					int updateId = ctx.Random.NextInt32(3);  					uint targetValue = ctx.Random.NextUInt32();    					int getId = ctx.Random.NextInt32(3);  					var fl = CFGState.EncodeFlag(false' updateId' getId);  					var incr = currentState.GetIncrementalUpdate(updateId' targetValue);  					currentState.UpdateExplicit(updateId' targetValue);    					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4_S' (sbyte)fl));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4' (int)incr));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Call' ctx.Ctx.CfgCtxNext));    					return currentState.Get(getId);  				}  				else {  					// Scan for updated state  					int[] stateIds = { 0' 1' 2' 3 };  					ctx.Random.Shuffle(stateIds);  					int i = 0;  					uint getValue = 0;  					foreach (var stateId in stateIds) {  						uint targetValue = targetState.Value.Get(stateId);  						int getId = ctx.Random.NextInt32(3);  						var fl = CFGState.EncodeFlag(true' stateId' getId);  						currentState.UpdateExplicit(stateId' targetValue);    						body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldloca' ctx.StateVariable));  						body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4_S' (sbyte)fl));  						body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4' (int)targetValue));  						body.Instructions.Insert(index++' Instruction.Create(OpCodes.Call' ctx.Ctx.CfgCtxNext));    						i++;  						if (i == stateIds.Length)  							getValue = targetState.Value.Get(getId);  						else  							body.Instructions.Insert(index++' Instruction.Create(OpCodes.Pop));  					}  					return getValue;  				}  			}
Magic Number,Confuser.Protections.Constants,ReferenceReplacer,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\ReferenceReplacer.cs,InsertStateGetAndUpdate,The following statement contains a magic number: if (type == BlockKeyType.Incremental) {  				// Incremental    				if (targetState == null) {  					// Randomly update and get state  					int updateId = ctx.Random.NextInt32(3);  					uint targetValue = ctx.Random.NextUInt32();    					int getId = ctx.Random.NextInt32(3);  					var fl = CFGState.EncodeFlag(false' updateId' getId);  					var incr = currentState.GetIncrementalUpdate(updateId' targetValue);  					currentState.UpdateExplicit(updateId' targetValue);    					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldloca' ctx.StateVariable));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4_S' (sbyte)fl));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4' (int)incr));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Call' ctx.Ctx.CfgCtxNext));    					return currentState.Get(getId);  				}  				// Scan for updated state  				int[] stateIds = { 0' 1' 2' 3 };  				ctx.Random.Shuffle(stateIds);  				int i = 0;  				uint getValue = 0;  				foreach (var stateId in stateIds) {  					// There must be at least one update&get  					if (currentState.Get(stateId) == targetState.Value.Get(stateId) &&  					    i != stateIds.Length - 1) {  						i++;  						continue;  					}    					uint targetValue = targetState.Value.Get(stateId);  					int getId = ctx.Random.NextInt32(3);  					var fl = CFGState.EncodeFlag(false' stateId' getId);  					var incr = currentState.GetIncrementalUpdate(stateId' targetValue);  					currentState.UpdateExplicit(stateId' targetValue);    					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldloca' ctx.StateVariable));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4_S' (sbyte)fl));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4' (int)incr));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Call' ctx.Ctx.CfgCtxNext));    					i++;  					if (i == stateIds.Length)  						getValue = currentState.Get(getId);  					else  						body.Instructions.Insert(index++' Instruction.Create(OpCodes.Pop));  				}  				return getValue;  			}  			else {  				// Explicit    				if (targetState == null) {  					// Create new exit state from random seed  					var seed = ctx.Random.NextUInt32();  					currentState = new CFGState(seed);  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldloca' ctx.StateVariable));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Dup));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4' (int)seed));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Call' ctx.Ctx.CfgCtxCtor));    					// Randomly get state  					int updateId = ctx.Random.NextInt32(3);  					uint targetValue = ctx.Random.NextUInt32();    					int getId = ctx.Random.NextInt32(3);  					var fl = CFGState.EncodeFlag(false' updateId' getId);  					var incr = currentState.GetIncrementalUpdate(updateId' targetValue);  					currentState.UpdateExplicit(updateId' targetValue);    					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4_S' (sbyte)fl));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4' (int)incr));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Call' ctx.Ctx.CfgCtxNext));    					return currentState.Get(getId);  				}  				else {  					// Scan for updated state  					int[] stateIds = { 0' 1' 2' 3 };  					ctx.Random.Shuffle(stateIds);  					int i = 0;  					uint getValue = 0;  					foreach (var stateId in stateIds) {  						uint targetValue = targetState.Value.Get(stateId);  						int getId = ctx.Random.NextInt32(3);  						var fl = CFGState.EncodeFlag(true' stateId' getId);  						currentState.UpdateExplicit(stateId' targetValue);    						body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldloca' ctx.StateVariable));  						body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4_S' (sbyte)fl));  						body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4' (int)targetValue));  						body.Instructions.Insert(index++' Instruction.Create(OpCodes.Call' ctx.Ctx.CfgCtxNext));    						i++;  						if (i == stateIds.Length)  							getValue = targetState.Value.Get(getId);  						else  							body.Instructions.Insert(index++' Instruction.Create(OpCodes.Pop));  					}  					return getValue;  				}  			}
Magic Number,Confuser.Protections.Constants,ReferenceReplacer,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\ReferenceReplacer.cs,InsertStateGetAndUpdate,The following statement contains a magic number: if (type == BlockKeyType.Incremental) {  				// Incremental    				if (targetState == null) {  					// Randomly update and get state  					int updateId = ctx.Random.NextInt32(3);  					uint targetValue = ctx.Random.NextUInt32();    					int getId = ctx.Random.NextInt32(3);  					var fl = CFGState.EncodeFlag(false' updateId' getId);  					var incr = currentState.GetIncrementalUpdate(updateId' targetValue);  					currentState.UpdateExplicit(updateId' targetValue);    					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldloca' ctx.StateVariable));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4_S' (sbyte)fl));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4' (int)incr));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Call' ctx.Ctx.CfgCtxNext));    					return currentState.Get(getId);  				}  				// Scan for updated state  				int[] stateIds = { 0' 1' 2' 3 };  				ctx.Random.Shuffle(stateIds);  				int i = 0;  				uint getValue = 0;  				foreach (var stateId in stateIds) {  					// There must be at least one update&get  					if (currentState.Get(stateId) == targetState.Value.Get(stateId) &&  					    i != stateIds.Length - 1) {  						i++;  						continue;  					}    					uint targetValue = targetState.Value.Get(stateId);  					int getId = ctx.Random.NextInt32(3);  					var fl = CFGState.EncodeFlag(false' stateId' getId);  					var incr = currentState.GetIncrementalUpdate(stateId' targetValue);  					currentState.UpdateExplicit(stateId' targetValue);    					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldloca' ctx.StateVariable));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4_S' (sbyte)fl));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4' (int)incr));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Call' ctx.Ctx.CfgCtxNext));    					i++;  					if (i == stateIds.Length)  						getValue = currentState.Get(getId);  					else  						body.Instructions.Insert(index++' Instruction.Create(OpCodes.Pop));  				}  				return getValue;  			}  			else {  				// Explicit    				if (targetState == null) {  					// Create new exit state from random seed  					var seed = ctx.Random.NextUInt32();  					currentState = new CFGState(seed);  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldloca' ctx.StateVariable));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Dup));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4' (int)seed));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Call' ctx.Ctx.CfgCtxCtor));    					// Randomly get state  					int updateId = ctx.Random.NextInt32(3);  					uint targetValue = ctx.Random.NextUInt32();    					int getId = ctx.Random.NextInt32(3);  					var fl = CFGState.EncodeFlag(false' updateId' getId);  					var incr = currentState.GetIncrementalUpdate(updateId' targetValue);  					currentState.UpdateExplicit(updateId' targetValue);    					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4_S' (sbyte)fl));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4' (int)incr));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Call' ctx.Ctx.CfgCtxNext));    					return currentState.Get(getId);  				}  				else {  					// Scan for updated state  					int[] stateIds = { 0' 1' 2' 3 };  					ctx.Random.Shuffle(stateIds);  					int i = 0;  					uint getValue = 0;  					foreach (var stateId in stateIds) {  						uint targetValue = targetState.Value.Get(stateId);  						int getId = ctx.Random.NextInt32(3);  						var fl = CFGState.EncodeFlag(true' stateId' getId);  						currentState.UpdateExplicit(stateId' targetValue);    						body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldloca' ctx.StateVariable));  						body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4_S' (sbyte)fl));  						body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4' (int)targetValue));  						body.Instructions.Insert(index++' Instruction.Create(OpCodes.Call' ctx.Ctx.CfgCtxNext));    						i++;  						if (i == stateIds.Length)  							getValue = targetState.Value.Get(getId);  						else  							body.Instructions.Insert(index++' Instruction.Create(OpCodes.Pop));  					}  					return getValue;  				}  			}
Magic Number,Confuser.Protections.Constants,ReferenceReplacer,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\ReferenceReplacer.cs,InsertStateGetAndUpdate,The following statement contains a magic number: if (type == BlockKeyType.Incremental) {  				// Incremental    				if (targetState == null) {  					// Randomly update and get state  					int updateId = ctx.Random.NextInt32(3);  					uint targetValue = ctx.Random.NextUInt32();    					int getId = ctx.Random.NextInt32(3);  					var fl = CFGState.EncodeFlag(false' updateId' getId);  					var incr = currentState.GetIncrementalUpdate(updateId' targetValue);  					currentState.UpdateExplicit(updateId' targetValue);    					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldloca' ctx.StateVariable));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4_S' (sbyte)fl));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4' (int)incr));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Call' ctx.Ctx.CfgCtxNext));    					return currentState.Get(getId);  				}  				// Scan for updated state  				int[] stateIds = { 0' 1' 2' 3 };  				ctx.Random.Shuffle(stateIds);  				int i = 0;  				uint getValue = 0;  				foreach (var stateId in stateIds) {  					// There must be at least one update&get  					if (currentState.Get(stateId) == targetState.Value.Get(stateId) &&  					    i != stateIds.Length - 1) {  						i++;  						continue;  					}    					uint targetValue = targetState.Value.Get(stateId);  					int getId = ctx.Random.NextInt32(3);  					var fl = CFGState.EncodeFlag(false' stateId' getId);  					var incr = currentState.GetIncrementalUpdate(stateId' targetValue);  					currentState.UpdateExplicit(stateId' targetValue);    					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldloca' ctx.StateVariable));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4_S' (sbyte)fl));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4' (int)incr));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Call' ctx.Ctx.CfgCtxNext));    					i++;  					if (i == stateIds.Length)  						getValue = currentState.Get(getId);  					else  						body.Instructions.Insert(index++' Instruction.Create(OpCodes.Pop));  				}  				return getValue;  			}  			else {  				// Explicit    				if (targetState == null) {  					// Create new exit state from random seed  					var seed = ctx.Random.NextUInt32();  					currentState = new CFGState(seed);  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldloca' ctx.StateVariable));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Dup));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4' (int)seed));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Call' ctx.Ctx.CfgCtxCtor));    					// Randomly get state  					int updateId = ctx.Random.NextInt32(3);  					uint targetValue = ctx.Random.NextUInt32();    					int getId = ctx.Random.NextInt32(3);  					var fl = CFGState.EncodeFlag(false' updateId' getId);  					var incr = currentState.GetIncrementalUpdate(updateId' targetValue);  					currentState.UpdateExplicit(updateId' targetValue);    					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4_S' (sbyte)fl));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4' (int)incr));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Call' ctx.Ctx.CfgCtxNext));    					return currentState.Get(getId);  				}  				else {  					// Scan for updated state  					int[] stateIds = { 0' 1' 2' 3 };  					ctx.Random.Shuffle(stateIds);  					int i = 0;  					uint getValue = 0;  					foreach (var stateId in stateIds) {  						uint targetValue = targetState.Value.Get(stateId);  						int getId = ctx.Random.NextInt32(3);  						var fl = CFGState.EncodeFlag(true' stateId' getId);  						currentState.UpdateExplicit(stateId' targetValue);    						body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldloca' ctx.StateVariable));  						body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4_S' (sbyte)fl));  						body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4' (int)targetValue));  						body.Instructions.Insert(index++' Instruction.Create(OpCodes.Call' ctx.Ctx.CfgCtxNext));    						i++;  						if (i == stateIds.Length)  							getValue = targetState.Value.Get(getId);  						else  							body.Instructions.Insert(index++' Instruction.Create(OpCodes.Pop));  					}  					return getValue;  				}  			}
Magic Number,Confuser.Protections.Constants,ReferenceReplacer,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\ReferenceReplacer.cs,InsertStateGetAndUpdate,The following statement contains a magic number: if (type == BlockKeyType.Incremental) {  				// Incremental    				if (targetState == null) {  					// Randomly update and get state  					int updateId = ctx.Random.NextInt32(3);  					uint targetValue = ctx.Random.NextUInt32();    					int getId = ctx.Random.NextInt32(3);  					var fl = CFGState.EncodeFlag(false' updateId' getId);  					var incr = currentState.GetIncrementalUpdate(updateId' targetValue);  					currentState.UpdateExplicit(updateId' targetValue);    					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldloca' ctx.StateVariable));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4_S' (sbyte)fl));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4' (int)incr));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Call' ctx.Ctx.CfgCtxNext));    					return currentState.Get(getId);  				}  				// Scan for updated state  				int[] stateIds = { 0' 1' 2' 3 };  				ctx.Random.Shuffle(stateIds);  				int i = 0;  				uint getValue = 0;  				foreach (var stateId in stateIds) {  					// There must be at least one update&get  					if (currentState.Get(stateId) == targetState.Value.Get(stateId) &&  					    i != stateIds.Length - 1) {  						i++;  						continue;  					}    					uint targetValue = targetState.Value.Get(stateId);  					int getId = ctx.Random.NextInt32(3);  					var fl = CFGState.EncodeFlag(false' stateId' getId);  					var incr = currentState.GetIncrementalUpdate(stateId' targetValue);  					currentState.UpdateExplicit(stateId' targetValue);    					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldloca' ctx.StateVariable));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4_S' (sbyte)fl));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4' (int)incr));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Call' ctx.Ctx.CfgCtxNext));    					i++;  					if (i == stateIds.Length)  						getValue = currentState.Get(getId);  					else  						body.Instructions.Insert(index++' Instruction.Create(OpCodes.Pop));  				}  				return getValue;  			}  			else {  				// Explicit    				if (targetState == null) {  					// Create new exit state from random seed  					var seed = ctx.Random.NextUInt32();  					currentState = new CFGState(seed);  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldloca' ctx.StateVariable));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Dup));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4' (int)seed));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Call' ctx.Ctx.CfgCtxCtor));    					// Randomly get state  					int updateId = ctx.Random.NextInt32(3);  					uint targetValue = ctx.Random.NextUInt32();    					int getId = ctx.Random.NextInt32(3);  					var fl = CFGState.EncodeFlag(false' updateId' getId);  					var incr = currentState.GetIncrementalUpdate(updateId' targetValue);  					currentState.UpdateExplicit(updateId' targetValue);    					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4_S' (sbyte)fl));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4' (int)incr));  					body.Instructions.Insert(index++' Instruction.Create(OpCodes.Call' ctx.Ctx.CfgCtxNext));    					return currentState.Get(getId);  				}  				else {  					// Scan for updated state  					int[] stateIds = { 0' 1' 2' 3 };  					ctx.Random.Shuffle(stateIds);  					int i = 0;  					uint getValue = 0;  					foreach (var stateId in stateIds) {  						uint targetValue = targetState.Value.Get(stateId);  						int getId = ctx.Random.NextInt32(3);  						var fl = CFGState.EncodeFlag(true' stateId' getId);  						currentState.UpdateExplicit(stateId' targetValue);    						body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldloca' ctx.StateVariable));  						body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4_S' (sbyte)fl));  						body.Instructions.Insert(index++' Instruction.Create(OpCodes.Ldc_I4' (int)targetValue));  						body.Instructions.Insert(index++' Instruction.Create(OpCodes.Call' ctx.Ctx.CfgCtxNext));    						i++;  						if (i == stateIds.Length)  							getValue = targetState.Value.Get(getId);  						else  							body.Instructions.Insert(index++' Instruction.Create(OpCodes.Pop));  					}  					return getValue;  				}  			}
Magic Number,Confuser.Protections.Constants,CFGState,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\ReferenceReplacer.cs,UpdateExplicit,The following statement contains a magic number: switch (id) {  					case 0:  						A = value;  						break;  					case 1:  						B = value;  						break;  					case 2:  						C = value;  						break;  					case 3:  						D = value;  						break;  				}
Magic Number,Confuser.Protections.Constants,CFGState,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\ReferenceReplacer.cs,UpdateExplicit,The following statement contains a magic number: switch (id) {  					case 0:  						A = value;  						break;  					case 1:  						B = value;  						break;  					case 2:  						C = value;  						break;  					case 3:  						D = value;  						break;  				}
Magic Number,Confuser.Protections.Constants,CFGState,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\ReferenceReplacer.cs,UpdateIncremental,The following statement contains a magic number: switch (id) {  					case 0:  						A *= value;  						break;  					case 1:  						B += value;  						break;  					case 2:  						C ^= value;  						break;  					case 3:  						D -= value;  						break;  				}
Magic Number,Confuser.Protections.Constants,CFGState,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\ReferenceReplacer.cs,UpdateIncremental,The following statement contains a magic number: switch (id) {  					case 0:  						A *= value;  						break;  					case 1:  						B += value;  						break;  					case 2:  						C ^= value;  						break;  					case 3:  						D -= value;  						break;  				}
Magic Number,Confuser.Protections.Constants,CFGState,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\ReferenceReplacer.cs,GetIncrementalUpdate,The following statement contains a magic number: switch (id) {  					case 0:  						return A ^ target;  					case 1:  						return target - B;  					case 2:  						return C ^ target;  					case 3:  						return D - target;  				}
Magic Number,Confuser.Protections.Constants,CFGState,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\ReferenceReplacer.cs,GetIncrementalUpdate,The following statement contains a magic number: switch (id) {  					case 0:  						return A ^ target;  					case 1:  						return target - B;  					case 2:  						return C ^ target;  					case 3:  						return D - target;  				}
Magic Number,Confuser.Protections.Constants,CFGState,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\ReferenceReplacer.cs,Get,The following statement contains a magic number: switch (id) {  					case 0:  						return A;  					case 1:  						return B;  					case 2:  						return C;  					case 3:  						return D;  				}
Magic Number,Confuser.Protections.Constants,CFGState,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\ReferenceReplacer.cs,Get,The following statement contains a magic number: switch (id) {  					case 0:  						return A;  					case 1:  						return B;  					case 2:  						return C;  					case 3:  						return D;  				}
Magic Number,Confuser.Protections.Constants,CFGState,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\ReferenceReplacer.cs,EncodeFlag,The following statement contains a magic number: fl |= (byte)(getId << 2);
Magic Number,Confuser.Protections.Constants,x86Encoding,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\x86Mode.cs,Compile,The following statement contains a magic number: do {  					ctx.DynCipher.GenerateExpressionPair(  						ctx.Random'  						new VariableExpression { Variable = var }' new VariableExpression { Variable = result }'  						4' out expression' out inverse);    					reg = codeGen.GenerateX86(inverse' (v' r) => { return new[] { x86Instruction.Create(x86OpCode.POP' new x86RegisterOperand(r)) }; });  				} while (reg == null);
Magic Number,Confuser.Protections.Constants,EncodePhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\EncodePhase.cs,Execute,The following statement contains a magic number: foreach (var entry in ldc.WithProgress(context.Logger)) {  				if (entry.Key is string) {  					EncodeString(moduleCtx' (string)entry.Key' entry.Value);  				}  				else if (entry.Key is int) {  					EncodeConstant32(moduleCtx' (uint)(int)entry.Key' context.CurrentModule.CorLibTypes.Int32' entry.Value);  				}  				else if (entry.Key is long) {  					EncodeConstant64(moduleCtx' (uint)((long)entry.Key >> 32)' (uint)(long)entry.Key' context.CurrentModule.CorLibTypes.Int64' entry.Value);  				}  				else if (entry.Key is float) {  					var t = new RTransform();  					t.R4 = (float)entry.Key;  					EncodeConstant32(moduleCtx' t.Lo' context.CurrentModule.CorLibTypes.Single' entry.Value);  				}  				else if (entry.Key is double) {  					var t = new RTransform();  					t.R8 = (double)entry.Key;  					EncodeConstant64(moduleCtx' t.Hi' t.Lo' context.CurrentModule.CorLibTypes.Double' entry.Value);  				}  				else  					throw new UnreachableException();  				context.CheckCancellation();  			}
Magic Number,Confuser.Protections.Constants,EncodePhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\EncodePhase.cs,Execute,The following statement contains a magic number: var encodedBuff = new byte[moduleCtx.EncodedBuffer.Count * 4];
Magic Number,Confuser.Protections.Constants,EncodePhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\EncodePhase.cs,Execute,The following statement contains a magic number: foreach (uint dat in moduleCtx.EncodedBuffer) {  				encodedBuff[buffIndex++] = (byte)((dat >> 0) & 0xff);  				encodedBuff[buffIndex++] = (byte)((dat >> 8) & 0xff);  				encodedBuff[buffIndex++] = (byte)((dat >> 16) & 0xff);  				encodedBuff[buffIndex++] = (byte)((dat >> 24) & 0xff);  			}
Magic Number,Confuser.Protections.Constants,EncodePhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\EncodePhase.cs,Execute,The following statement contains a magic number: foreach (uint dat in moduleCtx.EncodedBuffer) {  				encodedBuff[buffIndex++] = (byte)((dat >> 0) & 0xff);  				encodedBuff[buffIndex++] = (byte)((dat >> 8) & 0xff);  				encodedBuff[buffIndex++] = (byte)((dat >> 16) & 0xff);  				encodedBuff[buffIndex++] = (byte)((dat >> 24) & 0xff);  			}
Magic Number,Confuser.Protections.Constants,EncodePhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\EncodePhase.cs,Execute,The following statement contains a magic number: foreach (uint dat in moduleCtx.EncodedBuffer) {  				encodedBuff[buffIndex++] = (byte)((dat >> 0) & 0xff);  				encodedBuff[buffIndex++] = (byte)((dat >> 8) & 0xff);  				encodedBuff[buffIndex++] = (byte)((dat >> 16) & 0xff);  				encodedBuff[buffIndex++] = (byte)((dat >> 24) & 0xff);  			}
Magic Number,Confuser.Protections.Constants,EncodePhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\EncodePhase.cs,Execute,The following statement contains a magic number: uint compressedLen = (uint)(encodedBuff.Length + 3) / 4;
Magic Number,Confuser.Protections.Constants,EncodePhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\EncodePhase.cs,Execute,The following statement contains a magic number: uint compressedLen = (uint)(encodedBuff.Length + 3) / 4;
Magic Number,Confuser.Protections.Constants,EncodePhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\EncodePhase.cs,Execute,The following statement contains a magic number: for (int i = 0; i < 0x10; i++) {  				state ^= state >> 12;  				state ^= state << 25;  				state ^= state >> 27;  				key[i] = state;  			}
Magic Number,Confuser.Protections.Constants,EncodePhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\EncodePhase.cs,Execute,The following statement contains a magic number: for (int i = 0; i < 0x10; i++) {  				state ^= state >> 12;  				state ^= state << 25;  				state ^= state >> 27;  				key[i] = state;  			}
Magic Number,Confuser.Protections.Constants,EncodePhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\EncodePhase.cs,Execute,The following statement contains a magic number: for (int i = 0; i < 0x10; i++) {  				state ^= state >> 12;  				state ^= state << 25;  				state ^= state >> 27;  				key[i] = state;  			}
Magic Number,Confuser.Protections.Constants,EncodePhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\EncodePhase.cs,Execute,The following statement contains a magic number: var encryptedBuffer = new byte[compressedBuff.Length * 4];
Magic Number,Confuser.Protections.Constants,EncodePhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\EncodePhase.cs,Execute,The following statement contains a magic number: while (buffIndex < compressedBuff.Length) {  				uint[] enc = moduleCtx.ModeHandler.Encrypt(compressedBuff' buffIndex' key);  				for (int j = 0; j < 0x10; j++)  					key[j] ^= compressedBuff[buffIndex + j];  				Buffer.BlockCopy(enc' 0' encryptedBuffer' buffIndex * 4' 0x40);  				buffIndex += 0x10;  			}
Magic Number,Confuser.Protections.Constants,EncodePhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\EncodePhase.cs,Execute,The following statement contains a magic number: MutationHelper.InjectKeys(moduleCtx.InitMethod'  			                          new[] { 0' 1 }'  			                          new[] { encryptedBuffer.Length / 4' (int)keySeed });
Magic Number,Confuser.Protections.Constants,EncodePhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\EncodePhase.cs,EncodeInitializer,The following statement contains a magic number: foreach (var instr in references) {  				IList<Instruction> instrs = instr.Item1.Body.Instructions;  				int i = instrs.IndexOf(instr.Item2);    				if (buffIndex == -1)  					buffIndex = EncodeByteArray(moduleCtx' init);    				Tuple<MethodDef' DecoderDesc> decoder = moduleCtx.Decoders[moduleCtx.Random.NextInt32(moduleCtx.Decoders.Count)];  				uint id = (uint)buffIndex | (uint)(decoder.Item2.InitializerID << 30);  				id = moduleCtx.ModeHandler.Encode(decoder.Item2.Data' moduleCtx' id);    				instrs[i - 4].Operand = (int)id;  				instrs[i - 3].OpCode = OpCodes.Call;  				var arrType = new SZArraySig(((ITypeDefOrRef)instrs[i - 3].Operand).ToTypeSig());  				instrs[i - 3].Operand = new MethodSpecUser(decoder.Item1' new GenericInstMethodSig(arrType));  				instrs.RemoveAt(i - 2);  				instrs.RemoveAt(i - 2);  				instrs.RemoveAt(i - 2);  			}
Magic Number,Confuser.Protections.Constants,EncodePhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\EncodePhase.cs,EncodeInitializer,The following statement contains a magic number: foreach (var instr in references) {  				IList<Instruction> instrs = instr.Item1.Body.Instructions;  				int i = instrs.IndexOf(instr.Item2);    				if (buffIndex == -1)  					buffIndex = EncodeByteArray(moduleCtx' init);    				Tuple<MethodDef' DecoderDesc> decoder = moduleCtx.Decoders[moduleCtx.Random.NextInt32(moduleCtx.Decoders.Count)];  				uint id = (uint)buffIndex | (uint)(decoder.Item2.InitializerID << 30);  				id = moduleCtx.ModeHandler.Encode(decoder.Item2.Data' moduleCtx' id);    				instrs[i - 4].Operand = (int)id;  				instrs[i - 3].OpCode = OpCodes.Call;  				var arrType = new SZArraySig(((ITypeDefOrRef)instrs[i - 3].Operand).ToTypeSig());  				instrs[i - 3].Operand = new MethodSpecUser(decoder.Item1' new GenericInstMethodSig(arrType));  				instrs.RemoveAt(i - 2);  				instrs.RemoveAt(i - 2);  				instrs.RemoveAt(i - 2);  			}
Magic Number,Confuser.Protections.Constants,EncodePhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\EncodePhase.cs,EncodeInitializer,The following statement contains a magic number: foreach (var instr in references) {  				IList<Instruction> instrs = instr.Item1.Body.Instructions;  				int i = instrs.IndexOf(instr.Item2);    				if (buffIndex == -1)  					buffIndex = EncodeByteArray(moduleCtx' init);    				Tuple<MethodDef' DecoderDesc> decoder = moduleCtx.Decoders[moduleCtx.Random.NextInt32(moduleCtx.Decoders.Count)];  				uint id = (uint)buffIndex | (uint)(decoder.Item2.InitializerID << 30);  				id = moduleCtx.ModeHandler.Encode(decoder.Item2.Data' moduleCtx' id);    				instrs[i - 4].Operand = (int)id;  				instrs[i - 3].OpCode = OpCodes.Call;  				var arrType = new SZArraySig(((ITypeDefOrRef)instrs[i - 3].Operand).ToTypeSig());  				instrs[i - 3].Operand = new MethodSpecUser(decoder.Item1' new GenericInstMethodSig(arrType));  				instrs.RemoveAt(i - 2);  				instrs.RemoveAt(i - 2);  				instrs.RemoveAt(i - 2);  			}
Magic Number,Confuser.Protections.Constants,EncodePhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\EncodePhase.cs,EncodeInitializer,The following statement contains a magic number: foreach (var instr in references) {  				IList<Instruction> instrs = instr.Item1.Body.Instructions;  				int i = instrs.IndexOf(instr.Item2);    				if (buffIndex == -1)  					buffIndex = EncodeByteArray(moduleCtx' init);    				Tuple<MethodDef' DecoderDesc> decoder = moduleCtx.Decoders[moduleCtx.Random.NextInt32(moduleCtx.Decoders.Count)];  				uint id = (uint)buffIndex | (uint)(decoder.Item2.InitializerID << 30);  				id = moduleCtx.ModeHandler.Encode(decoder.Item2.Data' moduleCtx' id);    				instrs[i - 4].Operand = (int)id;  				instrs[i - 3].OpCode = OpCodes.Call;  				var arrType = new SZArraySig(((ITypeDefOrRef)instrs[i - 3].Operand).ToTypeSig());  				instrs[i - 3].Operand = new MethodSpecUser(decoder.Item1' new GenericInstMethodSig(arrType));  				instrs.RemoveAt(i - 2);  				instrs.RemoveAt(i - 2);  				instrs.RemoveAt(i - 2);  			}
Magic Number,Confuser.Protections.Constants,EncodePhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\EncodePhase.cs,EncodeInitializer,The following statement contains a magic number: foreach (var instr in references) {  				IList<Instruction> instrs = instr.Item1.Body.Instructions;  				int i = instrs.IndexOf(instr.Item2);    				if (buffIndex == -1)  					buffIndex = EncodeByteArray(moduleCtx' init);    				Tuple<MethodDef' DecoderDesc> decoder = moduleCtx.Decoders[moduleCtx.Random.NextInt32(moduleCtx.Decoders.Count)];  				uint id = (uint)buffIndex | (uint)(decoder.Item2.InitializerID << 30);  				id = moduleCtx.ModeHandler.Encode(decoder.Item2.Data' moduleCtx' id);    				instrs[i - 4].Operand = (int)id;  				instrs[i - 3].OpCode = OpCodes.Call;  				var arrType = new SZArraySig(((ITypeDefOrRef)instrs[i - 3].Operand).ToTypeSig());  				instrs[i - 3].Operand = new MethodSpecUser(decoder.Item1' new GenericInstMethodSig(arrType));  				instrs.RemoveAt(i - 2);  				instrs.RemoveAt(i - 2);  				instrs.RemoveAt(i - 2);  			}
Magic Number,Confuser.Protections.Constants,EncodePhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\EncodePhase.cs,EncodeInitializer,The following statement contains a magic number: foreach (var instr in references) {  				IList<Instruction> instrs = instr.Item1.Body.Instructions;  				int i = instrs.IndexOf(instr.Item2);    				if (buffIndex == -1)  					buffIndex = EncodeByteArray(moduleCtx' init);    				Tuple<MethodDef' DecoderDesc> decoder = moduleCtx.Decoders[moduleCtx.Random.NextInt32(moduleCtx.Decoders.Count)];  				uint id = (uint)buffIndex | (uint)(decoder.Item2.InitializerID << 30);  				id = moduleCtx.ModeHandler.Encode(decoder.Item2.Data' moduleCtx' id);    				instrs[i - 4].Operand = (int)id;  				instrs[i - 3].OpCode = OpCodes.Call;  				var arrType = new SZArraySig(((ITypeDefOrRef)instrs[i - 3].Operand).ToTypeSig());  				instrs[i - 3].Operand = new MethodSpecUser(decoder.Item1' new GenericInstMethodSig(arrType));  				instrs.RemoveAt(i - 2);  				instrs.RemoveAt(i - 2);  				instrs.RemoveAt(i - 2);  			}
Magic Number,Confuser.Protections.Constants,EncodePhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\EncodePhase.cs,EncodeInitializer,The following statement contains a magic number: foreach (var instr in references) {  				IList<Instruction> instrs = instr.Item1.Body.Instructions;  				int i = instrs.IndexOf(instr.Item2);    				if (buffIndex == -1)  					buffIndex = EncodeByteArray(moduleCtx' init);    				Tuple<MethodDef' DecoderDesc> decoder = moduleCtx.Decoders[moduleCtx.Random.NextInt32(moduleCtx.Decoders.Count)];  				uint id = (uint)buffIndex | (uint)(decoder.Item2.InitializerID << 30);  				id = moduleCtx.ModeHandler.Encode(decoder.Item2.Data' moduleCtx' id);    				instrs[i - 4].Operand = (int)id;  				instrs[i - 3].OpCode = OpCodes.Call;  				var arrType = new SZArraySig(((ITypeDefOrRef)instrs[i - 3].Operand).ToTypeSig());  				instrs[i - 3].Operand = new MethodSpecUser(decoder.Item1' new GenericInstMethodSig(arrType));  				instrs.RemoveAt(i - 2);  				instrs.RemoveAt(i - 2);  				instrs.RemoveAt(i - 2);  			}
Magic Number,Confuser.Protections.Constants,EncodePhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\EncodePhase.cs,EncodeInitializer,The following statement contains a magic number: foreach (var instr in references) {  				IList<Instruction> instrs = instr.Item1.Body.Instructions;  				int i = instrs.IndexOf(instr.Item2);    				if (buffIndex == -1)  					buffIndex = EncodeByteArray(moduleCtx' init);    				Tuple<MethodDef' DecoderDesc> decoder = moduleCtx.Decoders[moduleCtx.Random.NextInt32(moduleCtx.Decoders.Count)];  				uint id = (uint)buffIndex | (uint)(decoder.Item2.InitializerID << 30);  				id = moduleCtx.ModeHandler.Encode(decoder.Item2.Data' moduleCtx' id);    				instrs[i - 4].Operand = (int)id;  				instrs[i - 3].OpCode = OpCodes.Call;  				var arrType = new SZArraySig(((ITypeDefOrRef)instrs[i - 3].Operand).ToTypeSig());  				instrs[i - 3].Operand = new MethodSpecUser(decoder.Item1' new GenericInstMethodSig(arrType));  				instrs.RemoveAt(i - 2);  				instrs.RemoveAt(i - 2);  				instrs.RemoveAt(i - 2);  			}
Magic Number,Confuser.Protections.Constants,EncodePhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\EncodePhase.cs,EncodeByteArray,The following statement contains a magic number: int integral = buff.Length / 4' remainder = buff.Length % 4;
Magic Number,Confuser.Protections.Constants,EncodePhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\EncodePhase.cs,EncodeByteArray,The following statement contains a magic number: int integral = buff.Length / 4' remainder = buff.Length % 4;
Magic Number,Confuser.Protections.Constants,EncodePhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\EncodePhase.cs,EncodeByteArray,The following statement contains a magic number: for (int i = 0; i < integral; i++) {  				var data = (uint)(buff[i * 4] | (buff[i * 4 + 1] << 8) | (buff[i * 4 + 2] << 16) | (buff[i * 4 + 3] << 24));  				moduleCtx.EncodedBuffer.Add(data);  			}
Magic Number,Confuser.Protections.Constants,EncodePhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\EncodePhase.cs,EncodeByteArray,The following statement contains a magic number: for (int i = 0; i < integral; i++) {  				var data = (uint)(buff[i * 4] | (buff[i * 4 + 1] << 8) | (buff[i * 4 + 2] << 16) | (buff[i * 4 + 3] << 24));  				moduleCtx.EncodedBuffer.Add(data);  			}
Magic Number,Confuser.Protections.Constants,EncodePhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\EncodePhase.cs,EncodeByteArray,The following statement contains a magic number: for (int i = 0; i < integral; i++) {  				var data = (uint)(buff[i * 4] | (buff[i * 4 + 1] << 8) | (buff[i * 4 + 2] << 16) | (buff[i * 4 + 3] << 24));  				moduleCtx.EncodedBuffer.Add(data);  			}
Magic Number,Confuser.Protections.Constants,EncodePhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\EncodePhase.cs,EncodeByteArray,The following statement contains a magic number: for (int i = 0; i < integral; i++) {  				var data = (uint)(buff[i * 4] | (buff[i * 4 + 1] << 8) | (buff[i * 4 + 2] << 16) | (buff[i * 4 + 3] << 24));  				moduleCtx.EncodedBuffer.Add(data);  			}
Magic Number,Confuser.Protections.Constants,EncodePhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\EncodePhase.cs,EncodeByteArray,The following statement contains a magic number: for (int i = 0; i < integral; i++) {  				var data = (uint)(buff[i * 4] | (buff[i * 4 + 1] << 8) | (buff[i * 4 + 2] << 16) | (buff[i * 4 + 3] << 24));  				moduleCtx.EncodedBuffer.Add(data);  			}
Magic Number,Confuser.Protections.Constants,EncodePhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\EncodePhase.cs,EncodeByteArray,The following statement contains a magic number: for (int i = 0; i < integral; i++) {  				var data = (uint)(buff[i * 4] | (buff[i * 4 + 1] << 8) | (buff[i * 4 + 2] << 16) | (buff[i * 4 + 3] << 24));  				moduleCtx.EncodedBuffer.Add(data);  			}
Magic Number,Confuser.Protections.Constants,EncodePhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\EncodePhase.cs,EncodeByteArray,The following statement contains a magic number: for (int i = 0; i < integral; i++) {  				var data = (uint)(buff[i * 4] | (buff[i * 4 + 1] << 8) | (buff[i * 4 + 2] << 16) | (buff[i * 4 + 3] << 24));  				moduleCtx.EncodedBuffer.Add(data);  			}
Magic Number,Confuser.Protections.Constants,EncodePhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\EncodePhase.cs,EncodeByteArray,The following statement contains a magic number: for (int i = 0; i < integral; i++) {  				var data = (uint)(buff[i * 4] | (buff[i * 4 + 1] << 8) | (buff[i * 4 + 2] << 16) | (buff[i * 4 + 3] << 24));  				moduleCtx.EncodedBuffer.Add(data);  			}
Magic Number,Confuser.Protections.Constants,EncodePhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\EncodePhase.cs,EncodeByteArray,The following statement contains a magic number: for (int i = 0; i < integral; i++) {  				var data = (uint)(buff[i * 4] | (buff[i * 4 + 1] << 8) | (buff[i * 4 + 2] << 16) | (buff[i * 4 + 3] << 24));  				moduleCtx.EncodedBuffer.Add(data);  			}
Magic Number,Confuser.Protections.Constants,EncodePhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\EncodePhase.cs,EncodeByteArray,The following statement contains a magic number: if (remainder > 0) {  				int baseIndex = integral * 4;  				uint r = 0;  				for (int i = 0; i < remainder; i++)  					r |= (uint)(buff[baseIndex + i] << (i * 8));  				moduleCtx.EncodedBuffer.Add(r);  			}
Magic Number,Confuser.Protections.Constants,EncodePhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\EncodePhase.cs,EncodeByteArray,The following statement contains a magic number: if (remainder > 0) {  				int baseIndex = integral * 4;  				uint r = 0;  				for (int i = 0; i < remainder; i++)  					r |= (uint)(buff[baseIndex + i] << (i * 8));  				moduleCtx.EncodedBuffer.Add(r);  			}
Magic Number,Confuser.Protections.Constants,EncodePhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\EncodePhase.cs,UpdateReference,The following statement contains a magic number: foreach (var instr in references) {  				Tuple<MethodDef' DecoderDesc> decoder = moduleCtx.Decoders[moduleCtx.Random.NextInt32(moduleCtx.Decoders.Count)];  				uint id = (uint)buffIndex | (uint)(typeID(decoder.Item2) << 30);  				id = moduleCtx.ModeHandler.Encode(decoder.Item2.Data' moduleCtx' id);    				var targetDecoder = new MethodSpecUser(decoder.Item1' new GenericInstMethodSig(valueType));  				moduleCtx.ReferenceRepl.AddListEntry(instr.Item1' Tuple.Create(instr.Item2' id' (IMethod)targetDecoder));  			}
Magic Number,Confuser.Protections.Constants,EncodePhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\EncodePhase.cs,ExtractConstants,The following statement contains a magic number: foreach (MethodDef method in parameters.Targets.OfType<MethodDef>().WithProgress(context.Logger)) {  				if (!method.HasBody)  					continue;    				moduleCtx.Elements = 0;  				string elements = parameters.GetParameter(context' method' "elements"' "SI");  				foreach (char elem in elements)  					switch (elem) {  						case 'S':  						case 's':  							moduleCtx.Elements |= EncodeElements.Strings;  							break;  						case 'N':  						case 'n':  							moduleCtx.Elements |= EncodeElements.Numbers;  							break;  						case 'P':  						case 'p':  							moduleCtx.Elements |= EncodeElements.Primitive;  							break;  						case 'I':  						case 'i':  							moduleCtx.Elements |= EncodeElements.Initializers;  							break;  					}    				if (moduleCtx.Elements == 0)  					continue;    				foreach (Instruction instr in method.Body.Instructions) {  					bool eligible = false;  					if (instr.OpCode == OpCodes.Ldstr && (moduleCtx.Elements & EncodeElements.Strings) != 0) {  						var operand = (string)instr.Operand;  						if (string.IsNullOrEmpty(operand) && (moduleCtx.Elements & EncodeElements.Primitive) == 0)  							continue;  						eligible = true;  					}  					else if (instr.OpCode == OpCodes.Call && (moduleCtx.Elements & EncodeElements.Initializers) != 0) {  						var operand = (IMethod)instr.Operand;  						if (operand.DeclaringType.DefinitionAssembly.IsCorLib() &&  						    operand.DeclaringType.Namespace == "System.Runtime.CompilerServices" &&  						    operand.DeclaringType.Name == "RuntimeHelpers" &&  						    operand.Name == "InitializeArray") {  							IList<Instruction> instrs = method.Body.Instructions;  							int i = instrs.IndexOf(instr);  							if (instrs[i - 1].OpCode != OpCodes.Ldtoken) continue;  							if (instrs[i - 2].OpCode != OpCodes.Dup) continue;  							if (instrs[i - 3].OpCode != OpCodes.Newarr) continue;  							if (instrs[i - 4].OpCode != OpCodes.Ldc_I4) continue;    							var dataField = instrs[i - 1].Operand as FieldDef;  							if (dataField == null)  								continue;  							if (!dataField.HasFieldRVA || dataField.InitialValue == null)  								continue;    							// Prevent array length from being encoded  							var arrLen = (int)instrs[i - 4].Operand;  							if (ldc.ContainsKey(arrLen)) {  								List<Tuple<MethodDef' Instruction>> list = ldc[arrLen];  								list.RemoveWhere(entry => entry.Item2 == instrs[i - 4]);  								if (list.Count == 0)  									ldc.Remove(arrLen);  							}    							dataFields.Add(dataField);  							fieldRefs.Add(instrs[i - 1]);    							var value = new byte[dataField.InitialValue.Length + 4];  							value[0] = (byte)(arrLen >> 0);  							value[1] = (byte)(arrLen >> 8);  							value[2] = (byte)(arrLen >> 16);  							value[3] = (byte)(arrLen >> 24);  							Buffer.BlockCopy(dataField.InitialValue' 0' value' 4' dataField.InitialValue.Length);  							ldInit.AddListEntry(value' Tuple.Create(method' instr));  						}  					}  					else if ((moduleCtx.Elements & EncodeElements.Numbers) != 0) {  						if (instr.OpCode == OpCodes.Ldc_I4) {  							var operand = (int)instr.Operand;  							if ((operand >= -1 && operand <= 8) && (moduleCtx.Elements & EncodeElements.Primitive) == 0)  								continue;  							eligible = true;  						}  						else if (instr.OpCode == OpCodes.Ldc_I8) {  							var operand = (long)instr.Operand;  							if ((operand >= -1 && operand <= 1) && (moduleCtx.Elements & EncodeElements.Primitive) == 0)  								continue;  							eligible = true;  						}  						else if (instr.OpCode == OpCodes.Ldc_R4) {  							var operand = (float)instr.Operand;  							if ((operand == -1 || operand == 0 || operand == 1) && (moduleCtx.Elements & EncodeElements.Primitive) == 0)  								continue;  							eligible = true;  						}  						else if (instr.OpCode == OpCodes.Ldc_R8) {  							var operand = (double)instr.Operand;  							if ((operand == -1 || operand == 0 || operand == 1) && (moduleCtx.Elements & EncodeElements.Primitive) == 0)  								continue;  							eligible = true;  						}  					}    					if (eligible)  						ldc.AddListEntry(instr.Operand' Tuple.Create(method' instr));  				}    				context.CheckCancellation();  			}
Magic Number,Confuser.Protections.Constants,EncodePhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\EncodePhase.cs,ExtractConstants,The following statement contains a magic number: foreach (MethodDef method in parameters.Targets.OfType<MethodDef>().WithProgress(context.Logger)) {  				if (!method.HasBody)  					continue;    				moduleCtx.Elements = 0;  				string elements = parameters.GetParameter(context' method' "elements"' "SI");  				foreach (char elem in elements)  					switch (elem) {  						case 'S':  						case 's':  							moduleCtx.Elements |= EncodeElements.Strings;  							break;  						case 'N':  						case 'n':  							moduleCtx.Elements |= EncodeElements.Numbers;  							break;  						case 'P':  						case 'p':  							moduleCtx.Elements |= EncodeElements.Primitive;  							break;  						case 'I':  						case 'i':  							moduleCtx.Elements |= EncodeElements.Initializers;  							break;  					}    				if (moduleCtx.Elements == 0)  					continue;    				foreach (Instruction instr in method.Body.Instructions) {  					bool eligible = false;  					if (instr.OpCode == OpCodes.Ldstr && (moduleCtx.Elements & EncodeElements.Strings) != 0) {  						var operand = (string)instr.Operand;  						if (string.IsNullOrEmpty(operand) && (moduleCtx.Elements & EncodeElements.Primitive) == 0)  							continue;  						eligible = true;  					}  					else if (instr.OpCode == OpCodes.Call && (moduleCtx.Elements & EncodeElements.Initializers) != 0) {  						var operand = (IMethod)instr.Operand;  						if (operand.DeclaringType.DefinitionAssembly.IsCorLib() &&  						    operand.DeclaringType.Namespace == "System.Runtime.CompilerServices" &&  						    operand.DeclaringType.Name == "RuntimeHelpers" &&  						    operand.Name == "InitializeArray") {  							IList<Instruction> instrs = method.Body.Instructions;  							int i = instrs.IndexOf(instr);  							if (instrs[i - 1].OpCode != OpCodes.Ldtoken) continue;  							if (instrs[i - 2].OpCode != OpCodes.Dup) continue;  							if (instrs[i - 3].OpCode != OpCodes.Newarr) continue;  							if (instrs[i - 4].OpCode != OpCodes.Ldc_I4) continue;    							var dataField = instrs[i - 1].Operand as FieldDef;  							if (dataField == null)  								continue;  							if (!dataField.HasFieldRVA || dataField.InitialValue == null)  								continue;    							// Prevent array length from being encoded  							var arrLen = (int)instrs[i - 4].Operand;  							if (ldc.ContainsKey(arrLen)) {  								List<Tuple<MethodDef' Instruction>> list = ldc[arrLen];  								list.RemoveWhere(entry => entry.Item2 == instrs[i - 4]);  								if (list.Count == 0)  									ldc.Remove(arrLen);  							}    							dataFields.Add(dataField);  							fieldRefs.Add(instrs[i - 1]);    							var value = new byte[dataField.InitialValue.Length + 4];  							value[0] = (byte)(arrLen >> 0);  							value[1] = (byte)(arrLen >> 8);  							value[2] = (byte)(arrLen >> 16);  							value[3] = (byte)(arrLen >> 24);  							Buffer.BlockCopy(dataField.InitialValue' 0' value' 4' dataField.InitialValue.Length);  							ldInit.AddListEntry(value' Tuple.Create(method' instr));  						}  					}  					else if ((moduleCtx.Elements & EncodeElements.Numbers) != 0) {  						if (instr.OpCode == OpCodes.Ldc_I4) {  							var operand = (int)instr.Operand;  							if ((operand >= -1 && operand <= 8) && (moduleCtx.Elements & EncodeElements.Primitive) == 0)  								continue;  							eligible = true;  						}  						else if (instr.OpCode == OpCodes.Ldc_I8) {  							var operand = (long)instr.Operand;  							if ((operand >= -1 && operand <= 1) && (moduleCtx.Elements & EncodeElements.Primitive) == 0)  								continue;  							eligible = true;  						}  						else if (instr.OpCode == OpCodes.Ldc_R4) {  							var operand = (float)instr.Operand;  							if ((operand == -1 || operand == 0 || operand == 1) && (moduleCtx.Elements & EncodeElements.Primitive) == 0)  								continue;  							eligible = true;  						}  						else if (instr.OpCode == OpCodes.Ldc_R8) {  							var operand = (double)instr.Operand;  							if ((operand == -1 || operand == 0 || operand == 1) && (moduleCtx.Elements & EncodeElements.Primitive) == 0)  								continue;  							eligible = true;  						}  					}    					if (eligible)  						ldc.AddListEntry(instr.Operand' Tuple.Create(method' instr));  				}    				context.CheckCancellation();  			}
Magic Number,Confuser.Protections.Constants,EncodePhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\EncodePhase.cs,ExtractConstants,The following statement contains a magic number: foreach (MethodDef method in parameters.Targets.OfType<MethodDef>().WithProgress(context.Logger)) {  				if (!method.HasBody)  					continue;    				moduleCtx.Elements = 0;  				string elements = parameters.GetParameter(context' method' "elements"' "SI");  				foreach (char elem in elements)  					switch (elem) {  						case 'S':  						case 's':  							moduleCtx.Elements |= EncodeElements.Strings;  							break;  						case 'N':  						case 'n':  							moduleCtx.Elements |= EncodeElements.Numbers;  							break;  						case 'P':  						case 'p':  							moduleCtx.Elements |= EncodeElements.Primitive;  							break;  						case 'I':  						case 'i':  							moduleCtx.Elements |= EncodeElements.Initializers;  							break;  					}    				if (moduleCtx.Elements == 0)  					continue;    				foreach (Instruction instr in method.Body.Instructions) {  					bool eligible = false;  					if (instr.OpCode == OpCodes.Ldstr && (moduleCtx.Elements & EncodeElements.Strings) != 0) {  						var operand = (string)instr.Operand;  						if (string.IsNullOrEmpty(operand) && (moduleCtx.Elements & EncodeElements.Primitive) == 0)  							continue;  						eligible = true;  					}  					else if (instr.OpCode == OpCodes.Call && (moduleCtx.Elements & EncodeElements.Initializers) != 0) {  						var operand = (IMethod)instr.Operand;  						if (operand.DeclaringType.DefinitionAssembly.IsCorLib() &&  						    operand.DeclaringType.Namespace == "System.Runtime.CompilerServices" &&  						    operand.DeclaringType.Name == "RuntimeHelpers" &&  						    operand.Name == "InitializeArray") {  							IList<Instruction> instrs = method.Body.Instructions;  							int i = instrs.IndexOf(instr);  							if (instrs[i - 1].OpCode != OpCodes.Ldtoken) continue;  							if (instrs[i - 2].OpCode != OpCodes.Dup) continue;  							if (instrs[i - 3].OpCode != OpCodes.Newarr) continue;  							if (instrs[i - 4].OpCode != OpCodes.Ldc_I4) continue;    							var dataField = instrs[i - 1].Operand as FieldDef;  							if (dataField == null)  								continue;  							if (!dataField.HasFieldRVA || dataField.InitialValue == null)  								continue;    							// Prevent array length from being encoded  							var arrLen = (int)instrs[i - 4].Operand;  							if (ldc.ContainsKey(arrLen)) {  								List<Tuple<MethodDef' Instruction>> list = ldc[arrLen];  								list.RemoveWhere(entry => entry.Item2 == instrs[i - 4]);  								if (list.Count == 0)  									ldc.Remove(arrLen);  							}    							dataFields.Add(dataField);  							fieldRefs.Add(instrs[i - 1]);    							var value = new byte[dataField.InitialValue.Length + 4];  							value[0] = (byte)(arrLen >> 0);  							value[1] = (byte)(arrLen >> 8);  							value[2] = (byte)(arrLen >> 16);  							value[3] = (byte)(arrLen >> 24);  							Buffer.BlockCopy(dataField.InitialValue' 0' value' 4' dataField.InitialValue.Length);  							ldInit.AddListEntry(value' Tuple.Create(method' instr));  						}  					}  					else if ((moduleCtx.Elements & EncodeElements.Numbers) != 0) {  						if (instr.OpCode == OpCodes.Ldc_I4) {  							var operand = (int)instr.Operand;  							if ((operand >= -1 && operand <= 8) && (moduleCtx.Elements & EncodeElements.Primitive) == 0)  								continue;  							eligible = true;  						}  						else if (instr.OpCode == OpCodes.Ldc_I8) {  							var operand = (long)instr.Operand;  							if ((operand >= -1 && operand <= 1) && (moduleCtx.Elements & EncodeElements.Primitive) == 0)  								continue;  							eligible = true;  						}  						else if (instr.OpCode == OpCodes.Ldc_R4) {  							var operand = (float)instr.Operand;  							if ((operand == -1 || operand == 0 || operand == 1) && (moduleCtx.Elements & EncodeElements.Primitive) == 0)  								continue;  							eligible = true;  						}  						else if (instr.OpCode == OpCodes.Ldc_R8) {  							var operand = (double)instr.Operand;  							if ((operand == -1 || operand == 0 || operand == 1) && (moduleCtx.Elements & EncodeElements.Primitive) == 0)  								continue;  							eligible = true;  						}  					}    					if (eligible)  						ldc.AddListEntry(instr.Operand' Tuple.Create(method' instr));  				}    				context.CheckCancellation();  			}
Magic Number,Confuser.Protections.Constants,EncodePhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\EncodePhase.cs,ExtractConstants,The following statement contains a magic number: foreach (MethodDef method in parameters.Targets.OfType<MethodDef>().WithProgress(context.Logger)) {  				if (!method.HasBody)  					continue;    				moduleCtx.Elements = 0;  				string elements = parameters.GetParameter(context' method' "elements"' "SI");  				foreach (char elem in elements)  					switch (elem) {  						case 'S':  						case 's':  							moduleCtx.Elements |= EncodeElements.Strings;  							break;  						case 'N':  						case 'n':  							moduleCtx.Elements |= EncodeElements.Numbers;  							break;  						case 'P':  						case 'p':  							moduleCtx.Elements |= EncodeElements.Primitive;  							break;  						case 'I':  						case 'i':  							moduleCtx.Elements |= EncodeElements.Initializers;  							break;  					}    				if (moduleCtx.Elements == 0)  					continue;    				foreach (Instruction instr in method.Body.Instructions) {  					bool eligible = false;  					if (instr.OpCode == OpCodes.Ldstr && (moduleCtx.Elements & EncodeElements.Strings) != 0) {  						var operand = (string)instr.Operand;  						if (string.IsNullOrEmpty(operand) && (moduleCtx.Elements & EncodeElements.Primitive) == 0)  							continue;  						eligible = true;  					}  					else if (instr.OpCode == OpCodes.Call && (moduleCtx.Elements & EncodeElements.Initializers) != 0) {  						var operand = (IMethod)instr.Operand;  						if (operand.DeclaringType.DefinitionAssembly.IsCorLib() &&  						    operand.DeclaringType.Namespace == "System.Runtime.CompilerServices" &&  						    operand.DeclaringType.Name == "RuntimeHelpers" &&  						    operand.Name == "InitializeArray") {  							IList<Instruction> instrs = method.Body.Instructions;  							int i = instrs.IndexOf(instr);  							if (instrs[i - 1].OpCode != OpCodes.Ldtoken) continue;  							if (instrs[i - 2].OpCode != OpCodes.Dup) continue;  							if (instrs[i - 3].OpCode != OpCodes.Newarr) continue;  							if (instrs[i - 4].OpCode != OpCodes.Ldc_I4) continue;    							var dataField = instrs[i - 1].Operand as FieldDef;  							if (dataField == null)  								continue;  							if (!dataField.HasFieldRVA || dataField.InitialValue == null)  								continue;    							// Prevent array length from being encoded  							var arrLen = (int)instrs[i - 4].Operand;  							if (ldc.ContainsKey(arrLen)) {  								List<Tuple<MethodDef' Instruction>> list = ldc[arrLen];  								list.RemoveWhere(entry => entry.Item2 == instrs[i - 4]);  								if (list.Count == 0)  									ldc.Remove(arrLen);  							}    							dataFields.Add(dataField);  							fieldRefs.Add(instrs[i - 1]);    							var value = new byte[dataField.InitialValue.Length + 4];  							value[0] = (byte)(arrLen >> 0);  							value[1] = (byte)(arrLen >> 8);  							value[2] = (byte)(arrLen >> 16);  							value[3] = (byte)(arrLen >> 24);  							Buffer.BlockCopy(dataField.InitialValue' 0' value' 4' dataField.InitialValue.Length);  							ldInit.AddListEntry(value' Tuple.Create(method' instr));  						}  					}  					else if ((moduleCtx.Elements & EncodeElements.Numbers) != 0) {  						if (instr.OpCode == OpCodes.Ldc_I4) {  							var operand = (int)instr.Operand;  							if ((operand >= -1 && operand <= 8) && (moduleCtx.Elements & EncodeElements.Primitive) == 0)  								continue;  							eligible = true;  						}  						else if (instr.OpCode == OpCodes.Ldc_I8) {  							var operand = (long)instr.Operand;  							if ((operand >= -1 && operand <= 1) && (moduleCtx.Elements & EncodeElements.Primitive) == 0)  								continue;  							eligible = true;  						}  						else if (instr.OpCode == OpCodes.Ldc_R4) {  							var operand = (float)instr.Operand;  							if ((operand == -1 || operand == 0 || operand == 1) && (moduleCtx.Elements & EncodeElements.Primitive) == 0)  								continue;  							eligible = true;  						}  						else if (instr.OpCode == OpCodes.Ldc_R8) {  							var operand = (double)instr.Operand;  							if ((operand == -1 || operand == 0 || operand == 1) && (moduleCtx.Elements & EncodeElements.Primitive) == 0)  								continue;  							eligible = true;  						}  					}    					if (eligible)  						ldc.AddListEntry(instr.Operand' Tuple.Create(method' instr));  				}    				context.CheckCancellation();  			}
Magic Number,Confuser.Protections.Constants,EncodePhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\EncodePhase.cs,ExtractConstants,The following statement contains a magic number: foreach (MethodDef method in parameters.Targets.OfType<MethodDef>().WithProgress(context.Logger)) {  				if (!method.HasBody)  					continue;    				moduleCtx.Elements = 0;  				string elements = parameters.GetParameter(context' method' "elements"' "SI");  				foreach (char elem in elements)  					switch (elem) {  						case 'S':  						case 's':  							moduleCtx.Elements |= EncodeElements.Strings;  							break;  						case 'N':  						case 'n':  							moduleCtx.Elements |= EncodeElements.Numbers;  							break;  						case 'P':  						case 'p':  							moduleCtx.Elements |= EncodeElements.Primitive;  							break;  						case 'I':  						case 'i':  							moduleCtx.Elements |= EncodeElements.Initializers;  							break;  					}    				if (moduleCtx.Elements == 0)  					continue;    				foreach (Instruction instr in method.Body.Instructions) {  					bool eligible = false;  					if (instr.OpCode == OpCodes.Ldstr && (moduleCtx.Elements & EncodeElements.Strings) != 0) {  						var operand = (string)instr.Operand;  						if (string.IsNullOrEmpty(operand) && (moduleCtx.Elements & EncodeElements.Primitive) == 0)  							continue;  						eligible = true;  					}  					else if (instr.OpCode == OpCodes.Call && (moduleCtx.Elements & EncodeElements.Initializers) != 0) {  						var operand = (IMethod)instr.Operand;  						if (operand.DeclaringType.DefinitionAssembly.IsCorLib() &&  						    operand.DeclaringType.Namespace == "System.Runtime.CompilerServices" &&  						    operand.DeclaringType.Name == "RuntimeHelpers" &&  						    operand.Name == "InitializeArray") {  							IList<Instruction> instrs = method.Body.Instructions;  							int i = instrs.IndexOf(instr);  							if (instrs[i - 1].OpCode != OpCodes.Ldtoken) continue;  							if (instrs[i - 2].OpCode != OpCodes.Dup) continue;  							if (instrs[i - 3].OpCode != OpCodes.Newarr) continue;  							if (instrs[i - 4].OpCode != OpCodes.Ldc_I4) continue;    							var dataField = instrs[i - 1].Operand as FieldDef;  							if (dataField == null)  								continue;  							if (!dataField.HasFieldRVA || dataField.InitialValue == null)  								continue;    							// Prevent array length from being encoded  							var arrLen = (int)instrs[i - 4].Operand;  							if (ldc.ContainsKey(arrLen)) {  								List<Tuple<MethodDef' Instruction>> list = ldc[arrLen];  								list.RemoveWhere(entry => entry.Item2 == instrs[i - 4]);  								if (list.Count == 0)  									ldc.Remove(arrLen);  							}    							dataFields.Add(dataField);  							fieldRefs.Add(instrs[i - 1]);    							var value = new byte[dataField.InitialValue.Length + 4];  							value[0] = (byte)(arrLen >> 0);  							value[1] = (byte)(arrLen >> 8);  							value[2] = (byte)(arrLen >> 16);  							value[3] = (byte)(arrLen >> 24);  							Buffer.BlockCopy(dataField.InitialValue' 0' value' 4' dataField.InitialValue.Length);  							ldInit.AddListEntry(value' Tuple.Create(method' instr));  						}  					}  					else if ((moduleCtx.Elements & EncodeElements.Numbers) != 0) {  						if (instr.OpCode == OpCodes.Ldc_I4) {  							var operand = (int)instr.Operand;  							if ((operand >= -1 && operand <= 8) && (moduleCtx.Elements & EncodeElements.Primitive) == 0)  								continue;  							eligible = true;  						}  						else if (instr.OpCode == OpCodes.Ldc_I8) {  							var operand = (long)instr.Operand;  							if ((operand >= -1 && operand <= 1) && (moduleCtx.Elements & EncodeElements.Primitive) == 0)  								continue;  							eligible = true;  						}  						else if (instr.OpCode == OpCodes.Ldc_R4) {  							var operand = (float)instr.Operand;  							if ((operand == -1 || operand == 0 || operand == 1) && (moduleCtx.Elements & EncodeElements.Primitive) == 0)  								continue;  							eligible = true;  						}  						else if (instr.OpCode == OpCodes.Ldc_R8) {  							var operand = (double)instr.Operand;  							if ((operand == -1 || operand == 0 || operand == 1) && (moduleCtx.Elements & EncodeElements.Primitive) == 0)  								continue;  							eligible = true;  						}  					}    					if (eligible)  						ldc.AddListEntry(instr.Operand' Tuple.Create(method' instr));  				}    				context.CheckCancellation();  			}
Magic Number,Confuser.Protections.Constants,EncodePhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\EncodePhase.cs,ExtractConstants,The following statement contains a magic number: foreach (MethodDef method in parameters.Targets.OfType<MethodDef>().WithProgress(context.Logger)) {  				if (!method.HasBody)  					continue;    				moduleCtx.Elements = 0;  				string elements = parameters.GetParameter(context' method' "elements"' "SI");  				foreach (char elem in elements)  					switch (elem) {  						case 'S':  						case 's':  							moduleCtx.Elements |= EncodeElements.Strings;  							break;  						case 'N':  						case 'n':  							moduleCtx.Elements |= EncodeElements.Numbers;  							break;  						case 'P':  						case 'p':  							moduleCtx.Elements |= EncodeElements.Primitive;  							break;  						case 'I':  						case 'i':  							moduleCtx.Elements |= EncodeElements.Initializers;  							break;  					}    				if (moduleCtx.Elements == 0)  					continue;    				foreach (Instruction instr in method.Body.Instructions) {  					bool eligible = false;  					if (instr.OpCode == OpCodes.Ldstr && (moduleCtx.Elements & EncodeElements.Strings) != 0) {  						var operand = (string)instr.Operand;  						if (string.IsNullOrEmpty(operand) && (moduleCtx.Elements & EncodeElements.Primitive) == 0)  							continue;  						eligible = true;  					}  					else if (instr.OpCode == OpCodes.Call && (moduleCtx.Elements & EncodeElements.Initializers) != 0) {  						var operand = (IMethod)instr.Operand;  						if (operand.DeclaringType.DefinitionAssembly.IsCorLib() &&  						    operand.DeclaringType.Namespace == "System.Runtime.CompilerServices" &&  						    operand.DeclaringType.Name == "RuntimeHelpers" &&  						    operand.Name == "InitializeArray") {  							IList<Instruction> instrs = method.Body.Instructions;  							int i = instrs.IndexOf(instr);  							if (instrs[i - 1].OpCode != OpCodes.Ldtoken) continue;  							if (instrs[i - 2].OpCode != OpCodes.Dup) continue;  							if (instrs[i - 3].OpCode != OpCodes.Newarr) continue;  							if (instrs[i - 4].OpCode != OpCodes.Ldc_I4) continue;    							var dataField = instrs[i - 1].Operand as FieldDef;  							if (dataField == null)  								continue;  							if (!dataField.HasFieldRVA || dataField.InitialValue == null)  								continue;    							// Prevent array length from being encoded  							var arrLen = (int)instrs[i - 4].Operand;  							if (ldc.ContainsKey(arrLen)) {  								List<Tuple<MethodDef' Instruction>> list = ldc[arrLen];  								list.RemoveWhere(entry => entry.Item2 == instrs[i - 4]);  								if (list.Count == 0)  									ldc.Remove(arrLen);  							}    							dataFields.Add(dataField);  							fieldRefs.Add(instrs[i - 1]);    							var value = new byte[dataField.InitialValue.Length + 4];  							value[0] = (byte)(arrLen >> 0);  							value[1] = (byte)(arrLen >> 8);  							value[2] = (byte)(arrLen >> 16);  							value[3] = (byte)(arrLen >> 24);  							Buffer.BlockCopy(dataField.InitialValue' 0' value' 4' dataField.InitialValue.Length);  							ldInit.AddListEntry(value' Tuple.Create(method' instr));  						}  					}  					else if ((moduleCtx.Elements & EncodeElements.Numbers) != 0) {  						if (instr.OpCode == OpCodes.Ldc_I4) {  							var operand = (int)instr.Operand;  							if ((operand >= -1 && operand <= 8) && (moduleCtx.Elements & EncodeElements.Primitive) == 0)  								continue;  							eligible = true;  						}  						else if (instr.OpCode == OpCodes.Ldc_I8) {  							var operand = (long)instr.Operand;  							if ((operand >= -1 && operand <= 1) && (moduleCtx.Elements & EncodeElements.Primitive) == 0)  								continue;  							eligible = true;  						}  						else if (instr.OpCode == OpCodes.Ldc_R4) {  							var operand = (float)instr.Operand;  							if ((operand == -1 || operand == 0 || operand == 1) && (moduleCtx.Elements & EncodeElements.Primitive) == 0)  								continue;  							eligible = true;  						}  						else if (instr.OpCode == OpCodes.Ldc_R8) {  							var operand = (double)instr.Operand;  							if ((operand == -1 || operand == 0 || operand == 1) && (moduleCtx.Elements & EncodeElements.Primitive) == 0)  								continue;  							eligible = true;  						}  					}    					if (eligible)  						ldc.AddListEntry(instr.Operand' Tuple.Create(method' instr));  				}    				context.CheckCancellation();  			}
Magic Number,Confuser.Protections.Constants,EncodePhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\EncodePhase.cs,ExtractConstants,The following statement contains a magic number: foreach (MethodDef method in parameters.Targets.OfType<MethodDef>().WithProgress(context.Logger)) {  				if (!method.HasBody)  					continue;    				moduleCtx.Elements = 0;  				string elements = parameters.GetParameter(context' method' "elements"' "SI");  				foreach (char elem in elements)  					switch (elem) {  						case 'S':  						case 's':  							moduleCtx.Elements |= EncodeElements.Strings;  							break;  						case 'N':  						case 'n':  							moduleCtx.Elements |= EncodeElements.Numbers;  							break;  						case 'P':  						case 'p':  							moduleCtx.Elements |= EncodeElements.Primitive;  							break;  						case 'I':  						case 'i':  							moduleCtx.Elements |= EncodeElements.Initializers;  							break;  					}    				if (moduleCtx.Elements == 0)  					continue;    				foreach (Instruction instr in method.Body.Instructions) {  					bool eligible = false;  					if (instr.OpCode == OpCodes.Ldstr && (moduleCtx.Elements & EncodeElements.Strings) != 0) {  						var operand = (string)instr.Operand;  						if (string.IsNullOrEmpty(operand) && (moduleCtx.Elements & EncodeElements.Primitive) == 0)  							continue;  						eligible = true;  					}  					else if (instr.OpCode == OpCodes.Call && (moduleCtx.Elements & EncodeElements.Initializers) != 0) {  						var operand = (IMethod)instr.Operand;  						if (operand.DeclaringType.DefinitionAssembly.IsCorLib() &&  						    operand.DeclaringType.Namespace == "System.Runtime.CompilerServices" &&  						    operand.DeclaringType.Name == "RuntimeHelpers" &&  						    operand.Name == "InitializeArray") {  							IList<Instruction> instrs = method.Body.Instructions;  							int i = instrs.IndexOf(instr);  							if (instrs[i - 1].OpCode != OpCodes.Ldtoken) continue;  							if (instrs[i - 2].OpCode != OpCodes.Dup) continue;  							if (instrs[i - 3].OpCode != OpCodes.Newarr) continue;  							if (instrs[i - 4].OpCode != OpCodes.Ldc_I4) continue;    							var dataField = instrs[i - 1].Operand as FieldDef;  							if (dataField == null)  								continue;  							if (!dataField.HasFieldRVA || dataField.InitialValue == null)  								continue;    							// Prevent array length from being encoded  							var arrLen = (int)instrs[i - 4].Operand;  							if (ldc.ContainsKey(arrLen)) {  								List<Tuple<MethodDef' Instruction>> list = ldc[arrLen];  								list.RemoveWhere(entry => entry.Item2 == instrs[i - 4]);  								if (list.Count == 0)  									ldc.Remove(arrLen);  							}    							dataFields.Add(dataField);  							fieldRefs.Add(instrs[i - 1]);    							var value = new byte[dataField.InitialValue.Length + 4];  							value[0] = (byte)(arrLen >> 0);  							value[1] = (byte)(arrLen >> 8);  							value[2] = (byte)(arrLen >> 16);  							value[3] = (byte)(arrLen >> 24);  							Buffer.BlockCopy(dataField.InitialValue' 0' value' 4' dataField.InitialValue.Length);  							ldInit.AddListEntry(value' Tuple.Create(method' instr));  						}  					}  					else if ((moduleCtx.Elements & EncodeElements.Numbers) != 0) {  						if (instr.OpCode == OpCodes.Ldc_I4) {  							var operand = (int)instr.Operand;  							if ((operand >= -1 && operand <= 8) && (moduleCtx.Elements & EncodeElements.Primitive) == 0)  								continue;  							eligible = true;  						}  						else if (instr.OpCode == OpCodes.Ldc_I8) {  							var operand = (long)instr.Operand;  							if ((operand >= -1 && operand <= 1) && (moduleCtx.Elements & EncodeElements.Primitive) == 0)  								continue;  							eligible = true;  						}  						else if (instr.OpCode == OpCodes.Ldc_R4) {  							var operand = (float)instr.Operand;  							if ((operand == -1 || operand == 0 || operand == 1) && (moduleCtx.Elements & EncodeElements.Primitive) == 0)  								continue;  							eligible = true;  						}  						else if (instr.OpCode == OpCodes.Ldc_R8) {  							var operand = (double)instr.Operand;  							if ((operand == -1 || operand == 0 || operand == 1) && (moduleCtx.Elements & EncodeElements.Primitive) == 0)  								continue;  							eligible = true;  						}  					}    					if (eligible)  						ldc.AddListEntry(instr.Operand' Tuple.Create(method' instr));  				}    				context.CheckCancellation();  			}
Magic Number,Confuser.Protections.Constants,EncodePhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\EncodePhase.cs,ExtractConstants,The following statement contains a magic number: foreach (MethodDef method in parameters.Targets.OfType<MethodDef>().WithProgress(context.Logger)) {  				if (!method.HasBody)  					continue;    				moduleCtx.Elements = 0;  				string elements = parameters.GetParameter(context' method' "elements"' "SI");  				foreach (char elem in elements)  					switch (elem) {  						case 'S':  						case 's':  							moduleCtx.Elements |= EncodeElements.Strings;  							break;  						case 'N':  						case 'n':  							moduleCtx.Elements |= EncodeElements.Numbers;  							break;  						case 'P':  						case 'p':  							moduleCtx.Elements |= EncodeElements.Primitive;  							break;  						case 'I':  						case 'i':  							moduleCtx.Elements |= EncodeElements.Initializers;  							break;  					}    				if (moduleCtx.Elements == 0)  					continue;    				foreach (Instruction instr in method.Body.Instructions) {  					bool eligible = false;  					if (instr.OpCode == OpCodes.Ldstr && (moduleCtx.Elements & EncodeElements.Strings) != 0) {  						var operand = (string)instr.Operand;  						if (string.IsNullOrEmpty(operand) && (moduleCtx.Elements & EncodeElements.Primitive) == 0)  							continue;  						eligible = true;  					}  					else if (instr.OpCode == OpCodes.Call && (moduleCtx.Elements & EncodeElements.Initializers) != 0) {  						var operand = (IMethod)instr.Operand;  						if (operand.DeclaringType.DefinitionAssembly.IsCorLib() &&  						    operand.DeclaringType.Namespace == "System.Runtime.CompilerServices" &&  						    operand.DeclaringType.Name == "RuntimeHelpers" &&  						    operand.Name == "InitializeArray") {  							IList<Instruction> instrs = method.Body.Instructions;  							int i = instrs.IndexOf(instr);  							if (instrs[i - 1].OpCode != OpCodes.Ldtoken) continue;  							if (instrs[i - 2].OpCode != OpCodes.Dup) continue;  							if (instrs[i - 3].OpCode != OpCodes.Newarr) continue;  							if (instrs[i - 4].OpCode != OpCodes.Ldc_I4) continue;    							var dataField = instrs[i - 1].Operand as FieldDef;  							if (dataField == null)  								continue;  							if (!dataField.HasFieldRVA || dataField.InitialValue == null)  								continue;    							// Prevent array length from being encoded  							var arrLen = (int)instrs[i - 4].Operand;  							if (ldc.ContainsKey(arrLen)) {  								List<Tuple<MethodDef' Instruction>> list = ldc[arrLen];  								list.RemoveWhere(entry => entry.Item2 == instrs[i - 4]);  								if (list.Count == 0)  									ldc.Remove(arrLen);  							}    							dataFields.Add(dataField);  							fieldRefs.Add(instrs[i - 1]);    							var value = new byte[dataField.InitialValue.Length + 4];  							value[0] = (byte)(arrLen >> 0);  							value[1] = (byte)(arrLen >> 8);  							value[2] = (byte)(arrLen >> 16);  							value[3] = (byte)(arrLen >> 24);  							Buffer.BlockCopy(dataField.InitialValue' 0' value' 4' dataField.InitialValue.Length);  							ldInit.AddListEntry(value' Tuple.Create(method' instr));  						}  					}  					else if ((moduleCtx.Elements & EncodeElements.Numbers) != 0) {  						if (instr.OpCode == OpCodes.Ldc_I4) {  							var operand = (int)instr.Operand;  							if ((operand >= -1 && operand <= 8) && (moduleCtx.Elements & EncodeElements.Primitive) == 0)  								continue;  							eligible = true;  						}  						else if (instr.OpCode == OpCodes.Ldc_I8) {  							var operand = (long)instr.Operand;  							if ((operand >= -1 && operand <= 1) && (moduleCtx.Elements & EncodeElements.Primitive) == 0)  								continue;  							eligible = true;  						}  						else if (instr.OpCode == OpCodes.Ldc_R4) {  							var operand = (float)instr.Operand;  							if ((operand == -1 || operand == 0 || operand == 1) && (moduleCtx.Elements & EncodeElements.Primitive) == 0)  								continue;  							eligible = true;  						}  						else if (instr.OpCode == OpCodes.Ldc_R8) {  							var operand = (double)instr.Operand;  							if ((operand == -1 || operand == 0 || operand == 1) && (moduleCtx.Elements & EncodeElements.Primitive) == 0)  								continue;  							eligible = true;  						}  					}    					if (eligible)  						ldc.AddListEntry(instr.Operand' Tuple.Create(method' instr));  				}    				context.CheckCancellation();  			}
Magic Number,Confuser.Protections.Constants,EncodePhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\EncodePhase.cs,ExtractConstants,The following statement contains a magic number: foreach (MethodDef method in parameters.Targets.OfType<MethodDef>().WithProgress(context.Logger)) {  				if (!method.HasBody)  					continue;    				moduleCtx.Elements = 0;  				string elements = parameters.GetParameter(context' method' "elements"' "SI");  				foreach (char elem in elements)  					switch (elem) {  						case 'S':  						case 's':  							moduleCtx.Elements |= EncodeElements.Strings;  							break;  						case 'N':  						case 'n':  							moduleCtx.Elements |= EncodeElements.Numbers;  							break;  						case 'P':  						case 'p':  							moduleCtx.Elements |= EncodeElements.Primitive;  							break;  						case 'I':  						case 'i':  							moduleCtx.Elements |= EncodeElements.Initializers;  							break;  					}    				if (moduleCtx.Elements == 0)  					continue;    				foreach (Instruction instr in method.Body.Instructions) {  					bool eligible = false;  					if (instr.OpCode == OpCodes.Ldstr && (moduleCtx.Elements & EncodeElements.Strings) != 0) {  						var operand = (string)instr.Operand;  						if (string.IsNullOrEmpty(operand) && (moduleCtx.Elements & EncodeElements.Primitive) == 0)  							continue;  						eligible = true;  					}  					else if (instr.OpCode == OpCodes.Call && (moduleCtx.Elements & EncodeElements.Initializers) != 0) {  						var operand = (IMethod)instr.Operand;  						if (operand.DeclaringType.DefinitionAssembly.IsCorLib() &&  						    operand.DeclaringType.Namespace == "System.Runtime.CompilerServices" &&  						    operand.DeclaringType.Name == "RuntimeHelpers" &&  						    operand.Name == "InitializeArray") {  							IList<Instruction> instrs = method.Body.Instructions;  							int i = instrs.IndexOf(instr);  							if (instrs[i - 1].OpCode != OpCodes.Ldtoken) continue;  							if (instrs[i - 2].OpCode != OpCodes.Dup) continue;  							if (instrs[i - 3].OpCode != OpCodes.Newarr) continue;  							if (instrs[i - 4].OpCode != OpCodes.Ldc_I4) continue;    							var dataField = instrs[i - 1].Operand as FieldDef;  							if (dataField == null)  								continue;  							if (!dataField.HasFieldRVA || dataField.InitialValue == null)  								continue;    							// Prevent array length from being encoded  							var arrLen = (int)instrs[i - 4].Operand;  							if (ldc.ContainsKey(arrLen)) {  								List<Tuple<MethodDef' Instruction>> list = ldc[arrLen];  								list.RemoveWhere(entry => entry.Item2 == instrs[i - 4]);  								if (list.Count == 0)  									ldc.Remove(arrLen);  							}    							dataFields.Add(dataField);  							fieldRefs.Add(instrs[i - 1]);    							var value = new byte[dataField.InitialValue.Length + 4];  							value[0] = (byte)(arrLen >> 0);  							value[1] = (byte)(arrLen >> 8);  							value[2] = (byte)(arrLen >> 16);  							value[3] = (byte)(arrLen >> 24);  							Buffer.BlockCopy(dataField.InitialValue' 0' value' 4' dataField.InitialValue.Length);  							ldInit.AddListEntry(value' Tuple.Create(method' instr));  						}  					}  					else if ((moduleCtx.Elements & EncodeElements.Numbers) != 0) {  						if (instr.OpCode == OpCodes.Ldc_I4) {  							var operand = (int)instr.Operand;  							if ((operand >= -1 && operand <= 8) && (moduleCtx.Elements & EncodeElements.Primitive) == 0)  								continue;  							eligible = true;  						}  						else if (instr.OpCode == OpCodes.Ldc_I8) {  							var operand = (long)instr.Operand;  							if ((operand >= -1 && operand <= 1) && (moduleCtx.Elements & EncodeElements.Primitive) == 0)  								continue;  							eligible = true;  						}  						else if (instr.OpCode == OpCodes.Ldc_R4) {  							var operand = (float)instr.Operand;  							if ((operand == -1 || operand == 0 || operand == 1) && (moduleCtx.Elements & EncodeElements.Primitive) == 0)  								continue;  							eligible = true;  						}  						else if (instr.OpCode == OpCodes.Ldc_R8) {  							var operand = (double)instr.Operand;  							if ((operand == -1 || operand == 0 || operand == 1) && (moduleCtx.Elements & EncodeElements.Primitive) == 0)  								continue;  							eligible = true;  						}  					}    					if (eligible)  						ldc.AddListEntry(instr.Operand' Tuple.Create(method' instr));  				}    				context.CheckCancellation();  			}
Magic Number,Confuser.Protections.Constants,EncodePhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\EncodePhase.cs,ExtractConstants,The following statement contains a magic number: foreach (MethodDef method in parameters.Targets.OfType<MethodDef>().WithProgress(context.Logger)) {  				if (!method.HasBody)  					continue;    				moduleCtx.Elements = 0;  				string elements = parameters.GetParameter(context' method' "elements"' "SI");  				foreach (char elem in elements)  					switch (elem) {  						case 'S':  						case 's':  							moduleCtx.Elements |= EncodeElements.Strings;  							break;  						case 'N':  						case 'n':  							moduleCtx.Elements |= EncodeElements.Numbers;  							break;  						case 'P':  						case 'p':  							moduleCtx.Elements |= EncodeElements.Primitive;  							break;  						case 'I':  						case 'i':  							moduleCtx.Elements |= EncodeElements.Initializers;  							break;  					}    				if (moduleCtx.Elements == 0)  					continue;    				foreach (Instruction instr in method.Body.Instructions) {  					bool eligible = false;  					if (instr.OpCode == OpCodes.Ldstr && (moduleCtx.Elements & EncodeElements.Strings) != 0) {  						var operand = (string)instr.Operand;  						if (string.IsNullOrEmpty(operand) && (moduleCtx.Elements & EncodeElements.Primitive) == 0)  							continue;  						eligible = true;  					}  					else if (instr.OpCode == OpCodes.Call && (moduleCtx.Elements & EncodeElements.Initializers) != 0) {  						var operand = (IMethod)instr.Operand;  						if (operand.DeclaringType.DefinitionAssembly.IsCorLib() &&  						    operand.DeclaringType.Namespace == "System.Runtime.CompilerServices" &&  						    operand.DeclaringType.Name == "RuntimeHelpers" &&  						    operand.Name == "InitializeArray") {  							IList<Instruction> instrs = method.Body.Instructions;  							int i = instrs.IndexOf(instr);  							if (instrs[i - 1].OpCode != OpCodes.Ldtoken) continue;  							if (instrs[i - 2].OpCode != OpCodes.Dup) continue;  							if (instrs[i - 3].OpCode != OpCodes.Newarr) continue;  							if (instrs[i - 4].OpCode != OpCodes.Ldc_I4) continue;    							var dataField = instrs[i - 1].Operand as FieldDef;  							if (dataField == null)  								continue;  							if (!dataField.HasFieldRVA || dataField.InitialValue == null)  								continue;    							// Prevent array length from being encoded  							var arrLen = (int)instrs[i - 4].Operand;  							if (ldc.ContainsKey(arrLen)) {  								List<Tuple<MethodDef' Instruction>> list = ldc[arrLen];  								list.RemoveWhere(entry => entry.Item2 == instrs[i - 4]);  								if (list.Count == 0)  									ldc.Remove(arrLen);  							}    							dataFields.Add(dataField);  							fieldRefs.Add(instrs[i - 1]);    							var value = new byte[dataField.InitialValue.Length + 4];  							value[0] = (byte)(arrLen >> 0);  							value[1] = (byte)(arrLen >> 8);  							value[2] = (byte)(arrLen >> 16);  							value[3] = (byte)(arrLen >> 24);  							Buffer.BlockCopy(dataField.InitialValue' 0' value' 4' dataField.InitialValue.Length);  							ldInit.AddListEntry(value' Tuple.Create(method' instr));  						}  					}  					else if ((moduleCtx.Elements & EncodeElements.Numbers) != 0) {  						if (instr.OpCode == OpCodes.Ldc_I4) {  							var operand = (int)instr.Operand;  							if ((operand >= -1 && operand <= 8) && (moduleCtx.Elements & EncodeElements.Primitive) == 0)  								continue;  							eligible = true;  						}  						else if (instr.OpCode == OpCodes.Ldc_I8) {  							var operand = (long)instr.Operand;  							if ((operand >= -1 && operand <= 1) && (moduleCtx.Elements & EncodeElements.Primitive) == 0)  								continue;  							eligible = true;  						}  						else if (instr.OpCode == OpCodes.Ldc_R4) {  							var operand = (float)instr.Operand;  							if ((operand == -1 || operand == 0 || operand == 1) && (moduleCtx.Elements & EncodeElements.Primitive) == 0)  								continue;  							eligible = true;  						}  						else if (instr.OpCode == OpCodes.Ldc_R8) {  							var operand = (double)instr.Operand;  							if ((operand == -1 || operand == 0 || operand == 1) && (moduleCtx.Elements & EncodeElements.Primitive) == 0)  								continue;  							eligible = true;  						}  					}    					if (eligible)  						ldc.AddListEntry(instr.Operand' Tuple.Create(method' instr));  				}    				context.CheckCancellation();  			}
Magic Number,Confuser.Protections.Constants,EncodePhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\EncodePhase.cs,ExtractConstants,The following statement contains a magic number: foreach (MethodDef method in parameters.Targets.OfType<MethodDef>().WithProgress(context.Logger)) {  				if (!method.HasBody)  					continue;    				moduleCtx.Elements = 0;  				string elements = parameters.GetParameter(context' method' "elements"' "SI");  				foreach (char elem in elements)  					switch (elem) {  						case 'S':  						case 's':  							moduleCtx.Elements |= EncodeElements.Strings;  							break;  						case 'N':  						case 'n':  							moduleCtx.Elements |= EncodeElements.Numbers;  							break;  						case 'P':  						case 'p':  							moduleCtx.Elements |= EncodeElements.Primitive;  							break;  						case 'I':  						case 'i':  							moduleCtx.Elements |= EncodeElements.Initializers;  							break;  					}    				if (moduleCtx.Elements == 0)  					continue;    				foreach (Instruction instr in method.Body.Instructions) {  					bool eligible = false;  					if (instr.OpCode == OpCodes.Ldstr && (moduleCtx.Elements & EncodeElements.Strings) != 0) {  						var operand = (string)instr.Operand;  						if (string.IsNullOrEmpty(operand) && (moduleCtx.Elements & EncodeElements.Primitive) == 0)  							continue;  						eligible = true;  					}  					else if (instr.OpCode == OpCodes.Call && (moduleCtx.Elements & EncodeElements.Initializers) != 0) {  						var operand = (IMethod)instr.Operand;  						if (operand.DeclaringType.DefinitionAssembly.IsCorLib() &&  						    operand.DeclaringType.Namespace == "System.Runtime.CompilerServices" &&  						    operand.DeclaringType.Name == "RuntimeHelpers" &&  						    operand.Name == "InitializeArray") {  							IList<Instruction> instrs = method.Body.Instructions;  							int i = instrs.IndexOf(instr);  							if (instrs[i - 1].OpCode != OpCodes.Ldtoken) continue;  							if (instrs[i - 2].OpCode != OpCodes.Dup) continue;  							if (instrs[i - 3].OpCode != OpCodes.Newarr) continue;  							if (instrs[i - 4].OpCode != OpCodes.Ldc_I4) continue;    							var dataField = instrs[i - 1].Operand as FieldDef;  							if (dataField == null)  								continue;  							if (!dataField.HasFieldRVA || dataField.InitialValue == null)  								continue;    							// Prevent array length from being encoded  							var arrLen = (int)instrs[i - 4].Operand;  							if (ldc.ContainsKey(arrLen)) {  								List<Tuple<MethodDef' Instruction>> list = ldc[arrLen];  								list.RemoveWhere(entry => entry.Item2 == instrs[i - 4]);  								if (list.Count == 0)  									ldc.Remove(arrLen);  							}    							dataFields.Add(dataField);  							fieldRefs.Add(instrs[i - 1]);    							var value = new byte[dataField.InitialValue.Length + 4];  							value[0] = (byte)(arrLen >> 0);  							value[1] = (byte)(arrLen >> 8);  							value[2] = (byte)(arrLen >> 16);  							value[3] = (byte)(arrLen >> 24);  							Buffer.BlockCopy(dataField.InitialValue' 0' value' 4' dataField.InitialValue.Length);  							ldInit.AddListEntry(value' Tuple.Create(method' instr));  						}  					}  					else if ((moduleCtx.Elements & EncodeElements.Numbers) != 0) {  						if (instr.OpCode == OpCodes.Ldc_I4) {  							var operand = (int)instr.Operand;  							if ((operand >= -1 && operand <= 8) && (moduleCtx.Elements & EncodeElements.Primitive) == 0)  								continue;  							eligible = true;  						}  						else if (instr.OpCode == OpCodes.Ldc_I8) {  							var operand = (long)instr.Operand;  							if ((operand >= -1 && operand <= 1) && (moduleCtx.Elements & EncodeElements.Primitive) == 0)  								continue;  							eligible = true;  						}  						else if (instr.OpCode == OpCodes.Ldc_R4) {  							var operand = (float)instr.Operand;  							if ((operand == -1 || operand == 0 || operand == 1) && (moduleCtx.Elements & EncodeElements.Primitive) == 0)  								continue;  							eligible = true;  						}  						else if (instr.OpCode == OpCodes.Ldc_R8) {  							var operand = (double)instr.Operand;  							if ((operand == -1 || operand == 0 || operand == 1) && (moduleCtx.Elements & EncodeElements.Primitive) == 0)  								continue;  							eligible = true;  						}  					}    					if (eligible)  						ldc.AddListEntry(instr.Operand' Tuple.Create(method' instr));  				}    				context.CheckCancellation();  			}
Magic Number,Confuser.Protections.Constants,EncodePhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\EncodePhase.cs,ExtractConstants,The following statement contains a magic number: foreach (MethodDef method in parameters.Targets.OfType<MethodDef>().WithProgress(context.Logger)) {  				if (!method.HasBody)  					continue;    				moduleCtx.Elements = 0;  				string elements = parameters.GetParameter(context' method' "elements"' "SI");  				foreach (char elem in elements)  					switch (elem) {  						case 'S':  						case 's':  							moduleCtx.Elements |= EncodeElements.Strings;  							break;  						case 'N':  						case 'n':  							moduleCtx.Elements |= EncodeElements.Numbers;  							break;  						case 'P':  						case 'p':  							moduleCtx.Elements |= EncodeElements.Primitive;  							break;  						case 'I':  						case 'i':  							moduleCtx.Elements |= EncodeElements.Initializers;  							break;  					}    				if (moduleCtx.Elements == 0)  					continue;    				foreach (Instruction instr in method.Body.Instructions) {  					bool eligible = false;  					if (instr.OpCode == OpCodes.Ldstr && (moduleCtx.Elements & EncodeElements.Strings) != 0) {  						var operand = (string)instr.Operand;  						if (string.IsNullOrEmpty(operand) && (moduleCtx.Elements & EncodeElements.Primitive) == 0)  							continue;  						eligible = true;  					}  					else if (instr.OpCode == OpCodes.Call && (moduleCtx.Elements & EncodeElements.Initializers) != 0) {  						var operand = (IMethod)instr.Operand;  						if (operand.DeclaringType.DefinitionAssembly.IsCorLib() &&  						    operand.DeclaringType.Namespace == "System.Runtime.CompilerServices" &&  						    operand.DeclaringType.Name == "RuntimeHelpers" &&  						    operand.Name == "InitializeArray") {  							IList<Instruction> instrs = method.Body.Instructions;  							int i = instrs.IndexOf(instr);  							if (instrs[i - 1].OpCode != OpCodes.Ldtoken) continue;  							if (instrs[i - 2].OpCode != OpCodes.Dup) continue;  							if (instrs[i - 3].OpCode != OpCodes.Newarr) continue;  							if (instrs[i - 4].OpCode != OpCodes.Ldc_I4) continue;    							var dataField = instrs[i - 1].Operand as FieldDef;  							if (dataField == null)  								continue;  							if (!dataField.HasFieldRVA || dataField.InitialValue == null)  								continue;    							// Prevent array length from being encoded  							var arrLen = (int)instrs[i - 4].Operand;  							if (ldc.ContainsKey(arrLen)) {  								List<Tuple<MethodDef' Instruction>> list = ldc[arrLen];  								list.RemoveWhere(entry => entry.Item2 == instrs[i - 4]);  								if (list.Count == 0)  									ldc.Remove(arrLen);  							}    							dataFields.Add(dataField);  							fieldRefs.Add(instrs[i - 1]);    							var value = new byte[dataField.InitialValue.Length + 4];  							value[0] = (byte)(arrLen >> 0);  							value[1] = (byte)(arrLen >> 8);  							value[2] = (byte)(arrLen >> 16);  							value[3] = (byte)(arrLen >> 24);  							Buffer.BlockCopy(dataField.InitialValue' 0' value' 4' dataField.InitialValue.Length);  							ldInit.AddListEntry(value' Tuple.Create(method' instr));  						}  					}  					else if ((moduleCtx.Elements & EncodeElements.Numbers) != 0) {  						if (instr.OpCode == OpCodes.Ldc_I4) {  							var operand = (int)instr.Operand;  							if ((operand >= -1 && operand <= 8) && (moduleCtx.Elements & EncodeElements.Primitive) == 0)  								continue;  							eligible = true;  						}  						else if (instr.OpCode == OpCodes.Ldc_I8) {  							var operand = (long)instr.Operand;  							if ((operand >= -1 && operand <= 1) && (moduleCtx.Elements & EncodeElements.Primitive) == 0)  								continue;  							eligible = true;  						}  						else if (instr.OpCode == OpCodes.Ldc_R4) {  							var operand = (float)instr.Operand;  							if ((operand == -1 || operand == 0 || operand == 1) && (moduleCtx.Elements & EncodeElements.Primitive) == 0)  								continue;  							eligible = true;  						}  						else if (instr.OpCode == OpCodes.Ldc_R8) {  							var operand = (double)instr.Operand;  							if ((operand == -1 || operand == 0 || operand == 1) && (moduleCtx.Elements & EncodeElements.Primitive) == 0)  								continue;  							eligible = true;  						}  					}    					if (eligible)  						ldc.AddListEntry(instr.Operand' Tuple.Create(method' instr));  				}    				context.CheckCancellation();  			}
Magic Number,Confuser.Protections.Constants,EncodePhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\EncodePhase.cs,ExtractConstants,The following statement contains a magic number: foreach (MethodDef method in parameters.Targets.OfType<MethodDef>().WithProgress(context.Logger)) {  				if (!method.HasBody)  					continue;    				moduleCtx.Elements = 0;  				string elements = parameters.GetParameter(context' method' "elements"' "SI");  				foreach (char elem in elements)  					switch (elem) {  						case 'S':  						case 's':  							moduleCtx.Elements |= EncodeElements.Strings;  							break;  						case 'N':  						case 'n':  							moduleCtx.Elements |= EncodeElements.Numbers;  							break;  						case 'P':  						case 'p':  							moduleCtx.Elements |= EncodeElements.Primitive;  							break;  						case 'I':  						case 'i':  							moduleCtx.Elements |= EncodeElements.Initializers;  							break;  					}    				if (moduleCtx.Elements == 0)  					continue;    				foreach (Instruction instr in method.Body.Instructions) {  					bool eligible = false;  					if (instr.OpCode == OpCodes.Ldstr && (moduleCtx.Elements & EncodeElements.Strings) != 0) {  						var operand = (string)instr.Operand;  						if (string.IsNullOrEmpty(operand) && (moduleCtx.Elements & EncodeElements.Primitive) == 0)  							continue;  						eligible = true;  					}  					else if (instr.OpCode == OpCodes.Call && (moduleCtx.Elements & EncodeElements.Initializers) != 0) {  						var operand = (IMethod)instr.Operand;  						if (operand.DeclaringType.DefinitionAssembly.IsCorLib() &&  						    operand.DeclaringType.Namespace == "System.Runtime.CompilerServices" &&  						    operand.DeclaringType.Name == "RuntimeHelpers" &&  						    operand.Name == "InitializeArray") {  							IList<Instruction> instrs = method.Body.Instructions;  							int i = instrs.IndexOf(instr);  							if (instrs[i - 1].OpCode != OpCodes.Ldtoken) continue;  							if (instrs[i - 2].OpCode != OpCodes.Dup) continue;  							if (instrs[i - 3].OpCode != OpCodes.Newarr) continue;  							if (instrs[i - 4].OpCode != OpCodes.Ldc_I4) continue;    							var dataField = instrs[i - 1].Operand as FieldDef;  							if (dataField == null)  								continue;  							if (!dataField.HasFieldRVA || dataField.InitialValue == null)  								continue;    							// Prevent array length from being encoded  							var arrLen = (int)instrs[i - 4].Operand;  							if (ldc.ContainsKey(arrLen)) {  								List<Tuple<MethodDef' Instruction>> list = ldc[arrLen];  								list.RemoveWhere(entry => entry.Item2 == instrs[i - 4]);  								if (list.Count == 0)  									ldc.Remove(arrLen);  							}    							dataFields.Add(dataField);  							fieldRefs.Add(instrs[i - 1]);    							var value = new byte[dataField.InitialValue.Length + 4];  							value[0] = (byte)(arrLen >> 0);  							value[1] = (byte)(arrLen >> 8);  							value[2] = (byte)(arrLen >> 16);  							value[3] = (byte)(arrLen >> 24);  							Buffer.BlockCopy(dataField.InitialValue' 0' value' 4' dataField.InitialValue.Length);  							ldInit.AddListEntry(value' Tuple.Create(method' instr));  						}  					}  					else if ((moduleCtx.Elements & EncodeElements.Numbers) != 0) {  						if (instr.OpCode == OpCodes.Ldc_I4) {  							var operand = (int)instr.Operand;  							if ((operand >= -1 && operand <= 8) && (moduleCtx.Elements & EncodeElements.Primitive) == 0)  								continue;  							eligible = true;  						}  						else if (instr.OpCode == OpCodes.Ldc_I8) {  							var operand = (long)instr.Operand;  							if ((operand >= -1 && operand <= 1) && (moduleCtx.Elements & EncodeElements.Primitive) == 0)  								continue;  							eligible = true;  						}  						else if (instr.OpCode == OpCodes.Ldc_R4) {  							var operand = (float)instr.Operand;  							if ((operand == -1 || operand == 0 || operand == 1) && (moduleCtx.Elements & EncodeElements.Primitive) == 0)  								continue;  							eligible = true;  						}  						else if (instr.OpCode == OpCodes.Ldc_R8) {  							var operand = (double)instr.Operand;  							if ((operand == -1 || operand == 0 || operand == 1) && (moduleCtx.Elements & EncodeElements.Primitive) == 0)  								continue;  							eligible = true;  						}  					}    					if (eligible)  						ldc.AddListEntry(instr.Operand' Tuple.Create(method' instr));  				}    				context.CheckCancellation();  			}
Magic Number,Confuser.Protections.Constants,ByteArrayComparer,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\EncodePhase.cs,GetHashCode,The following statement contains a magic number: int ret = 31;
Magic Number,Confuser.Protections.Constants,ByteArrayComparer,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\EncodePhase.cs,GetHashCode,The following statement contains a magic number: foreach (byte v in obj)  					ret = ret * 17 + v;
Magic Number,Confuser.Protections.Constants,InjectPhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\InjectPhase.cs,Execute,The following statement contains a magic number: if (parameters.Targets.Any()) {  				var compression = context.Registry.GetService<ICompressionService>();  				var name = context.Registry.GetService<INameService>();  				var marker = context.Registry.GetService<IMarkerService>();  				var rt = context.Registry.GetService<IRuntimeService>();  				var moduleCtx = new CEContext {  					Protection = (ConstantProtection)Parent'  					Random = context.Registry.GetService<IRandomService>().GetRandomGenerator(Parent.Id)'  					Context = context'  					Module = context.CurrentModule'  					Marker = marker'  					DynCipher = context.Registry.GetService<IDynCipherService>()'  					Name = name  				};    				// Extract parameters  				moduleCtx.Mode = parameters.GetParameter(context' context.CurrentModule' "mode"' Mode.Normal);  				moduleCtx.DecoderCount = parameters.GetParameter(context' context.CurrentModule' "decoderCount"' 5);    				switch (moduleCtx.Mode) {  					case Mode.Normal:  						moduleCtx.ModeHandler = new NormalMode();  						break;  					case Mode.Dynamic:  						moduleCtx.ModeHandler = new DynamicMode();  						break;  					case Mode.x86:  						moduleCtx.ModeHandler = new x86Mode();  						if ((context.CurrentModule.Cor20HeaderFlags & ComImageFlags.ILOnly) != 0)  							context.CurrentModuleWriterOptions.Cor20HeaderOptions.Flags &= ~ComImageFlags.ILOnly;  						break;  					default:  						throw new UnreachableException();  				}    				// Inject helpers  				MethodDef decomp = compression.GetRuntimeDecompressor(context.CurrentModule' member => {  					name.MarkHelper(member' marker' (Protection)Parent);  					if (member is MethodDef)  						ProtectionParameters.GetParameters(context' member).Remove(Parent);  				});  				InjectHelpers(context' compression' rt' moduleCtx);    				// Mutate codes  				MutateInitializer(moduleCtx' decomp);    				MethodDef cctor = context.CurrentModule.GlobalType.FindStaticConstructor();  				cctor.Body.Instructions.Insert(0' Instruction.Create(OpCodes.Call' moduleCtx.InitMethod));    				context.Annotations.Set(context.CurrentModule' ConstantProtection.ContextKey' moduleCtx);  			}
Magic Number,Confuser.Protections.Constants,InjectPhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\InjectPhase.cs,InjectHelpers,The following statement contains a magic number: for (int i = 0; i < moduleCtx.DecoderCount; i++) {  				MethodDef decoderInst = InjectHelper.Inject(decoder' context.CurrentModule);  				for (int j = 0; j < decoderInst.Body.Instructions.Count; j++) {  					Instruction instr = decoderInst.Body.Instructions[j];  					var method = instr.Operand as IMethod;  					var field = instr.Operand as IField;  					if (instr.OpCode == OpCodes.Call &&  					    method.DeclaringType.Name == "Mutation" &&  					    method.Name == "Value") {  						decoderInst.Body.Instructions[j] = Instruction.Create(OpCodes.Sizeof' new GenericMVar(0).ToTypeDefOrRef());  					}  					else if (instr.OpCode == OpCodes.Ldsfld &&  					         method.DeclaringType.Name == "Constant") {  						if (field.Name == "b") instr.Operand = moduleCtx.BufferField;  						else throw new UnreachableException();  					}  				}  				context.CurrentModule.GlobalType.Methods.Add(decoderInst);  				moduleCtx.Name.MarkHelper(decoderInst' moduleCtx.Marker' (Protection)Parent);  				ProtectionParameters.GetParameters(context' decoderInst).Remove(Parent);    				var decoderDesc = new DecoderDesc();    				decoderDesc.StringID = (byte)(moduleCtx.Random.NextByte() & 3);    				do decoderDesc.NumberID = (byte)(moduleCtx.Random.NextByte() & 3); while (decoderDesc.NumberID == decoderDesc.StringID);    				do decoderDesc.InitializerID = (byte)(moduleCtx.Random.NextByte() & 3); while (decoderDesc.InitializerID == decoderDesc.StringID || decoderDesc.InitializerID == decoderDesc.NumberID);    				MutationHelper.InjectKeys(decoderInst'  				                          new[] { 0' 1' 2 }'  				                          new int[] { decoderDesc.StringID' decoderDesc.NumberID' decoderDesc.InitializerID });  				decoderDesc.Data = moduleCtx.ModeHandler.CreateDecoder(decoderInst' moduleCtx);  				moduleCtx.Decoders.Add(Tuple.Create(decoderInst' decoderDesc));  			}
Magic Number,Confuser.Protections.Constants,InjectPhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\InjectPhase.cs,InjectHelpers,The following statement contains a magic number: for (int i = 0; i < moduleCtx.DecoderCount; i++) {  				MethodDef decoderInst = InjectHelper.Inject(decoder' context.CurrentModule);  				for (int j = 0; j < decoderInst.Body.Instructions.Count; j++) {  					Instruction instr = decoderInst.Body.Instructions[j];  					var method = instr.Operand as IMethod;  					var field = instr.Operand as IField;  					if (instr.OpCode == OpCodes.Call &&  					    method.DeclaringType.Name == "Mutation" &&  					    method.Name == "Value") {  						decoderInst.Body.Instructions[j] = Instruction.Create(OpCodes.Sizeof' new GenericMVar(0).ToTypeDefOrRef());  					}  					else if (instr.OpCode == OpCodes.Ldsfld &&  					         method.DeclaringType.Name == "Constant") {  						if (field.Name == "b") instr.Operand = moduleCtx.BufferField;  						else throw new UnreachableException();  					}  				}  				context.CurrentModule.GlobalType.Methods.Add(decoderInst);  				moduleCtx.Name.MarkHelper(decoderInst' moduleCtx.Marker' (Protection)Parent);  				ProtectionParameters.GetParameters(context' decoderInst).Remove(Parent);    				var decoderDesc = new DecoderDesc();    				decoderDesc.StringID = (byte)(moduleCtx.Random.NextByte() & 3);    				do decoderDesc.NumberID = (byte)(moduleCtx.Random.NextByte() & 3); while (decoderDesc.NumberID == decoderDesc.StringID);    				do decoderDesc.InitializerID = (byte)(moduleCtx.Random.NextByte() & 3); while (decoderDesc.InitializerID == decoderDesc.StringID || decoderDesc.InitializerID == decoderDesc.NumberID);    				MutationHelper.InjectKeys(decoderInst'  				                          new[] { 0' 1' 2 }'  				                          new int[] { decoderDesc.StringID' decoderDesc.NumberID' decoderDesc.InitializerID });  				decoderDesc.Data = moduleCtx.ModeHandler.CreateDecoder(decoderInst' moduleCtx);  				moduleCtx.Decoders.Add(Tuple.Create(decoderInst' decoderDesc));  			}
Magic Number,Confuser.Protections.Constants,InjectPhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\InjectPhase.cs,InjectHelpers,The following statement contains a magic number: for (int i = 0; i < moduleCtx.DecoderCount; i++) {  				MethodDef decoderInst = InjectHelper.Inject(decoder' context.CurrentModule);  				for (int j = 0; j < decoderInst.Body.Instructions.Count; j++) {  					Instruction instr = decoderInst.Body.Instructions[j];  					var method = instr.Operand as IMethod;  					var field = instr.Operand as IField;  					if (instr.OpCode == OpCodes.Call &&  					    method.DeclaringType.Name == "Mutation" &&  					    method.Name == "Value") {  						decoderInst.Body.Instructions[j] = Instruction.Create(OpCodes.Sizeof' new GenericMVar(0).ToTypeDefOrRef());  					}  					else if (instr.OpCode == OpCodes.Ldsfld &&  					         method.DeclaringType.Name == "Constant") {  						if (field.Name == "b") instr.Operand = moduleCtx.BufferField;  						else throw new UnreachableException();  					}  				}  				context.CurrentModule.GlobalType.Methods.Add(decoderInst);  				moduleCtx.Name.MarkHelper(decoderInst' moduleCtx.Marker' (Protection)Parent);  				ProtectionParameters.GetParameters(context' decoderInst).Remove(Parent);    				var decoderDesc = new DecoderDesc();    				decoderDesc.StringID = (byte)(moduleCtx.Random.NextByte() & 3);    				do decoderDesc.NumberID = (byte)(moduleCtx.Random.NextByte() & 3); while (decoderDesc.NumberID == decoderDesc.StringID);    				do decoderDesc.InitializerID = (byte)(moduleCtx.Random.NextByte() & 3); while (decoderDesc.InitializerID == decoderDesc.StringID || decoderDesc.InitializerID == decoderDesc.NumberID);    				MutationHelper.InjectKeys(decoderInst'  				                          new[] { 0' 1' 2 }'  				                          new int[] { decoderDesc.StringID' decoderDesc.NumberID' decoderDesc.InitializerID });  				decoderDesc.Data = moduleCtx.ModeHandler.CreateDecoder(decoderInst' moduleCtx);  				moduleCtx.Decoders.Add(Tuple.Create(decoderInst' decoderDesc));  			}
Magic Number,Confuser.Protections.Constants,InjectPhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\InjectPhase.cs,InjectHelpers,The following statement contains a magic number: for (int i = 0; i < moduleCtx.DecoderCount; i++) {  				MethodDef decoderInst = InjectHelper.Inject(decoder' context.CurrentModule);  				for (int j = 0; j < decoderInst.Body.Instructions.Count; j++) {  					Instruction instr = decoderInst.Body.Instructions[j];  					var method = instr.Operand as IMethod;  					var field = instr.Operand as IField;  					if (instr.OpCode == OpCodes.Call &&  					    method.DeclaringType.Name == "Mutation" &&  					    method.Name == "Value") {  						decoderInst.Body.Instructions[j] = Instruction.Create(OpCodes.Sizeof' new GenericMVar(0).ToTypeDefOrRef());  					}  					else if (instr.OpCode == OpCodes.Ldsfld &&  					         method.DeclaringType.Name == "Constant") {  						if (field.Name == "b") instr.Operand = moduleCtx.BufferField;  						else throw new UnreachableException();  					}  				}  				context.CurrentModule.GlobalType.Methods.Add(decoderInst);  				moduleCtx.Name.MarkHelper(decoderInst' moduleCtx.Marker' (Protection)Parent);  				ProtectionParameters.GetParameters(context' decoderInst).Remove(Parent);    				var decoderDesc = new DecoderDesc();    				decoderDesc.StringID = (byte)(moduleCtx.Random.NextByte() & 3);    				do decoderDesc.NumberID = (byte)(moduleCtx.Random.NextByte() & 3); while (decoderDesc.NumberID == decoderDesc.StringID);    				do decoderDesc.InitializerID = (byte)(moduleCtx.Random.NextByte() & 3); while (decoderDesc.InitializerID == decoderDesc.StringID || decoderDesc.InitializerID == decoderDesc.NumberID);    				MutationHelper.InjectKeys(decoderInst'  				                          new[] { 0' 1' 2 }'  				                          new int[] { decoderDesc.StringID' decoderDesc.NumberID' decoderDesc.InitializerID });  				decoderDesc.Data = moduleCtx.ModeHandler.CreateDecoder(decoderInst' moduleCtx);  				moduleCtx.Decoders.Add(Tuple.Create(decoderInst' decoderDesc));  			}
Magic Number,Confuser.Protections.Constants,InjectPhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\InjectPhase.cs,MutateInitializer,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  				Instruction instr = instrs[i];  				var method = instr.Operand as IMethod;  				if (instr.OpCode == OpCodes.Call) {  					if (method.DeclaringType.Name == "Mutation" &&  					    method.Name == "Crypt") {  						Instruction ldBlock = instrs[i - 2];  						Instruction ldKey = instrs[i - 1];  						Debug.Assert(ldBlock.OpCode == OpCodes.Ldloc && ldKey.OpCode == OpCodes.Ldloc);  						instrs.RemoveAt(i);  						instrs.RemoveAt(i - 1);  						instrs.RemoveAt(i - 2);  						instrs.InsertRange(i - 2' moduleCtx.ModeHandler.EmitDecrypt(moduleCtx.InitMethod' moduleCtx' (Local)ldBlock.Operand' (Local)ldKey.Operand));  					}  					else if (method.DeclaringType.Name == "Lzma" &&  					         method.Name == "Decompress") {  						instr.Operand = decomp;  					}  				}  			}
Magic Number,Confuser.Protections.Constants,InjectPhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\InjectPhase.cs,MutateInitializer,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  				Instruction instr = instrs[i];  				var method = instr.Operand as IMethod;  				if (instr.OpCode == OpCodes.Call) {  					if (method.DeclaringType.Name == "Mutation" &&  					    method.Name == "Crypt") {  						Instruction ldBlock = instrs[i - 2];  						Instruction ldKey = instrs[i - 1];  						Debug.Assert(ldBlock.OpCode == OpCodes.Ldloc && ldKey.OpCode == OpCodes.Ldloc);  						instrs.RemoveAt(i);  						instrs.RemoveAt(i - 1);  						instrs.RemoveAt(i - 2);  						instrs.InsertRange(i - 2' moduleCtx.ModeHandler.EmitDecrypt(moduleCtx.InitMethod' moduleCtx' (Local)ldBlock.Operand' (Local)ldKey.Operand));  					}  					else if (method.DeclaringType.Name == "Lzma" &&  					         method.Name == "Decompress") {  						instr.Operand = decomp;  					}  				}  			}
Magic Number,Confuser.Protections.Constants,InjectPhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\InjectPhase.cs,MutateInitializer,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  				Instruction instr = instrs[i];  				var method = instr.Operand as IMethod;  				if (instr.OpCode == OpCodes.Call) {  					if (method.DeclaringType.Name == "Mutation" &&  					    method.Name == "Crypt") {  						Instruction ldBlock = instrs[i - 2];  						Instruction ldKey = instrs[i - 1];  						Debug.Assert(ldBlock.OpCode == OpCodes.Ldloc && ldKey.OpCode == OpCodes.Ldloc);  						instrs.RemoveAt(i);  						instrs.RemoveAt(i - 1);  						instrs.RemoveAt(i - 2);  						instrs.InsertRange(i - 2' moduleCtx.ModeHandler.EmitDecrypt(moduleCtx.InitMethod' moduleCtx' (Local)ldBlock.Operand' (Local)ldKey.Operand));  					}  					else if (method.DeclaringType.Name == "Lzma" &&  					         method.Name == "Decompress") {  						instr.Operand = decomp;  					}  				}  			}
Magic Number,Confuser.Protections.ControlFlow,CFContext,C:\repos\yck1509_ConfuserEx\Confuser.Protections\ControlFlow\CFContext.cs,AddJump,The following statement contains a magic number: if (!Method.Module.IsClr40 && JunkCode &&  			    !Method.DeclaringType.HasGenericParameters && !Method.HasGenericParameters &&  			    (instrs[0].OpCode.FlowControl == FlowControl.Call || instrs[0].OpCode.FlowControl == FlowControl.Next)) {  				switch (Random.NextInt32(3)) {  					case 0:  						instrs.Add(Instruction.Create(OpCodes.Ldc_I4_0));  						instrs.Add(Instruction.Create(OpCodes.Brtrue' instrs[0]));  						break;    					case 1:  						instrs.Add(Instruction.Create(OpCodes.Ldc_I4_1));  						instrs.Add(Instruction.Create(OpCodes.Brfalse' instrs[0]));  						break;    					case 2: // Take that' de4dot + ILSpy :)  						bool addDefOk = false;  						if (Random.NextBoolean()) {  							TypeDef randomType;  							randomType = Method.Module.Types[Random.NextInt32(Method.Module.Types.Count)];    							if (randomType.HasMethods) {  								instrs.Add(Instruction.Create(OpCodes.Ldtoken' randomType.Methods[Random.NextInt32(randomType.Methods.Count)]));  								instrs.Add(Instruction.Create(OpCodes.Box' Method.Module.CorLibTypes.GetTypeRef("System"' "RuntimeMethodHandle")));  								addDefOk = true;  							}  						}    						if (!addDefOk) {  							instrs.Add(Instruction.Create(OpCodes.Ldc_I4' Random.NextBoolean() ? 0 : 1));  							instrs.Add(Instruction.Create(OpCodes.Box' Method.Module.CorLibTypes.Int32.TypeDefOrRef));  						}  						Instruction pop = Instruction.Create(OpCodes.Pop);  						instrs.Add(Instruction.Create(OpCodes.Brfalse' instrs[0]));  						instrs.Add(Instruction.Create(OpCodes.Ldc_I4' Random.NextBoolean() ? 0 : 1));  						instrs.Add(pop);  						break;  				}  			}
Magic Number,Confuser.Protections.ControlFlow,CFContext,C:\repos\yck1509_ConfuserEx\Confuser.Protections\ControlFlow\CFContext.cs,AddJump,The following statement contains a magic number: if (!Method.Module.IsClr40 && JunkCode &&  			    !Method.DeclaringType.HasGenericParameters && !Method.HasGenericParameters &&  			    (instrs[0].OpCode.FlowControl == FlowControl.Call || instrs[0].OpCode.FlowControl == FlowControl.Next)) {  				switch (Random.NextInt32(3)) {  					case 0:  						instrs.Add(Instruction.Create(OpCodes.Ldc_I4_0));  						instrs.Add(Instruction.Create(OpCodes.Brtrue' instrs[0]));  						break;    					case 1:  						instrs.Add(Instruction.Create(OpCodes.Ldc_I4_1));  						instrs.Add(Instruction.Create(OpCodes.Brfalse' instrs[0]));  						break;    					case 2: // Take that' de4dot + ILSpy :)  						bool addDefOk = false;  						if (Random.NextBoolean()) {  							TypeDef randomType;  							randomType = Method.Module.Types[Random.NextInt32(Method.Module.Types.Count)];    							if (randomType.HasMethods) {  								instrs.Add(Instruction.Create(OpCodes.Ldtoken' randomType.Methods[Random.NextInt32(randomType.Methods.Count)]));  								instrs.Add(Instruction.Create(OpCodes.Box' Method.Module.CorLibTypes.GetTypeRef("System"' "RuntimeMethodHandle")));  								addDefOk = true;  							}  						}    						if (!addDefOk) {  							instrs.Add(Instruction.Create(OpCodes.Ldc_I4' Random.NextBoolean() ? 0 : 1));  							instrs.Add(Instruction.Create(OpCodes.Box' Method.Module.CorLibTypes.Int32.TypeDefOrRef));  						}  						Instruction pop = Instruction.Create(OpCodes.Pop);  						instrs.Add(Instruction.Create(OpCodes.Brfalse' instrs[0]));  						instrs.Add(Instruction.Create(OpCodes.Ldc_I4' Random.NextBoolean() ? 0 : 1));  						instrs.Add(pop);  						break;  				}  			}
Magic Number,Confuser.Protections.ControlFlow,CFContext,C:\repos\yck1509_ConfuserEx\Confuser.Protections\ControlFlow\CFContext.cs,AddJunk,The following statement contains a magic number: switch (Random.NextInt32(6)) {  				case 0:  					instrs.Add(Instruction.Create(OpCodes.Pop));  					break;  				case 1:  					instrs.Add(Instruction.Create(OpCodes.Dup));  					break;  				case 2:  					instrs.Add(Instruction.Create(OpCodes.Throw));  					break;  				case 3:  					instrs.Add(Instruction.Create(OpCodes.Ldarg' new Parameter(0xff)));  					break;  				case 4:  					instrs.Add(Instruction.Create(OpCodes.Ldloc' new Local(null) { Index = 0xff }));  					break;  				case 5:  					instrs.Add(Instruction.Create(OpCodes.Ldtoken' Method));  					break;  			}
Magic Number,Confuser.Protections.ControlFlow,CFContext,C:\repos\yck1509_ConfuserEx\Confuser.Protections\ControlFlow\CFContext.cs,AddJunk,The following statement contains a magic number: switch (Random.NextInt32(6)) {  				case 0:  					instrs.Add(Instruction.Create(OpCodes.Pop));  					break;  				case 1:  					instrs.Add(Instruction.Create(OpCodes.Dup));  					break;  				case 2:  					instrs.Add(Instruction.Create(OpCodes.Throw));  					break;  				case 3:  					instrs.Add(Instruction.Create(OpCodes.Ldarg' new Parameter(0xff)));  					break;  				case 4:  					instrs.Add(Instruction.Create(OpCodes.Ldloc' new Local(null) { Index = 0xff }));  					break;  				case 5:  					instrs.Add(Instruction.Create(OpCodes.Ldtoken' Method));  					break;  			}
Magic Number,Confuser.Protections.ControlFlow,CFContext,C:\repos\yck1509_ConfuserEx\Confuser.Protections\ControlFlow\CFContext.cs,AddJunk,The following statement contains a magic number: switch (Random.NextInt32(6)) {  				case 0:  					instrs.Add(Instruction.Create(OpCodes.Pop));  					break;  				case 1:  					instrs.Add(Instruction.Create(OpCodes.Dup));  					break;  				case 2:  					instrs.Add(Instruction.Create(OpCodes.Throw));  					break;  				case 3:  					instrs.Add(Instruction.Create(OpCodes.Ldarg' new Parameter(0xff)));  					break;  				case 4:  					instrs.Add(Instruction.Create(OpCodes.Ldloc' new Local(null) { Index = 0xff }));  					break;  				case 5:  					instrs.Add(Instruction.Create(OpCodes.Ldtoken' Method));  					break;  			}
Magic Number,Confuser.Protections.ControlFlow,CFContext,C:\repos\yck1509_ConfuserEx\Confuser.Protections\ControlFlow\CFContext.cs,AddJunk,The following statement contains a magic number: switch (Random.NextInt32(6)) {  				case 0:  					instrs.Add(Instruction.Create(OpCodes.Pop));  					break;  				case 1:  					instrs.Add(Instruction.Create(OpCodes.Dup));  					break;  				case 2:  					instrs.Add(Instruction.Create(OpCodes.Throw));  					break;  				case 3:  					instrs.Add(Instruction.Create(OpCodes.Ldarg' new Parameter(0xff)));  					break;  				case 4:  					instrs.Add(Instruction.Create(OpCodes.Ldloc' new Local(null) { Index = 0xff }));  					break;  				case 5:  					instrs.Add(Instruction.Create(OpCodes.Ldtoken' Method));  					break;  			}
Magic Number,Confuser.Protections.ControlFlow,CFContext,C:\repos\yck1509_ConfuserEx\Confuser.Protections\ControlFlow\CFContext.cs,AddJunk,The following statement contains a magic number: switch (Random.NextInt32(6)) {  				case 0:  					instrs.Add(Instruction.Create(OpCodes.Pop));  					break;  				case 1:  					instrs.Add(Instruction.Create(OpCodes.Dup));  					break;  				case 2:  					instrs.Add(Instruction.Create(OpCodes.Throw));  					break;  				case 3:  					instrs.Add(Instruction.Create(OpCodes.Ldarg' new Parameter(0xff)));  					break;  				case 4:  					instrs.Add(Instruction.Create(OpCodes.Ldloc' new Local(null) { Index = 0xff }));  					break;  				case 5:  					instrs.Add(Instruction.Create(OpCodes.Ldtoken' Method));  					break;  			}
Magic Number,Confuser.Protections.ControlFlow,ControlFlowPhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\ControlFlow\ControlFlowPhase.cs,ParseParameters,The following statement contains a magic number: int rawIntensity = parameters.GetParameter(context' method' "intensity"' 60);
Magic Number,Confuser.Protections.ControlFlow,ControlFlowPhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\ControlFlow\ControlFlowPhase.cs,ParseParameters,The following statement contains a magic number: ret.Intensity = rawIntensity / 100.0;
Magic Number,Confuser.Protections.ControlFlow,ControlFlowPhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\ControlFlow\ControlFlowPhase.cs,ParseParameters,The following statement contains a magic number: ret.Depth = parameters.GetParameter(context' method' "depth"' 4);
Magic Number,Confuser.Protections.ControlFlow,JumpMangler,C:\repos\yck1509_ConfuserEx\Confuser.Protections\ControlFlow\JumpMangler.cs,SpiltFragments,The following statement contains a magic number: for (int i = 0; i < block.Instructions.Count; i++) {  				if (skipCount != -1) {  					if (skipCount > 0) {  						currentFragment.Add(block.Instructions[i]);  						skipCount--;  						continue;  					}  					fragments.AddLast(currentFragment.ToArray());  					currentFragment.Clear();    					skipCount = -1;  				}    				if (block.Instructions[i].OpCode.OpCodeType == OpCodeType.Prefix) {  					skipCount = 1;  					currentFragment.Add(block.Instructions[i]);  				}  				if (i + 2 < block.Instructions.Count &&  				    block.Instructions[i + 0].OpCode.Code == Code.Dup &&  				    block.Instructions[i + 1].OpCode.Code == Code.Ldvirtftn &&  				    block.Instructions[i + 2].OpCode.Code == Code.Newobj) {  					skipCount = 2;  					currentFragment.Add(block.Instructions[i]);  				}  				if (i + 4 < block.Instructions.Count &&  				    block.Instructions[i + 0].OpCode.Code == Code.Ldc_I4 &&  				    block.Instructions[i + 1].OpCode.Code == Code.Newarr &&  				    block.Instructions[i + 2].OpCode.Code == Code.Dup &&  				    block.Instructions[i + 3].OpCode.Code == Code.Ldtoken &&  				    block.Instructions[i + 4].OpCode.Code == Code.Call) // Array initializer  				{  					skipCount = 4;  					currentFragment.Add(block.Instructions[i]);  				}  				if (i + 1 < block.Instructions.Count &&  				    block.Instructions[i + 0].OpCode.Code == Code.Ldftn &&  				    block.Instructions[i + 1].OpCode.Code == Code.Newobj) {  					skipCount = 1;  					currentFragment.Add(block.Instructions[i]);  				}  				currentFragment.Add(block.Instructions[i]);    				if (ctx.Intensity > ctx.Random.NextDouble()) {  					fragments.AddLast(currentFragment.ToArray());  					currentFragment.Clear();  				}  			}
Magic Number,Confuser.Protections.ControlFlow,JumpMangler,C:\repos\yck1509_ConfuserEx\Confuser.Protections\ControlFlow\JumpMangler.cs,SpiltFragments,The following statement contains a magic number: for (int i = 0; i < block.Instructions.Count; i++) {  				if (skipCount != -1) {  					if (skipCount > 0) {  						currentFragment.Add(block.Instructions[i]);  						skipCount--;  						continue;  					}  					fragments.AddLast(currentFragment.ToArray());  					currentFragment.Clear();    					skipCount = -1;  				}    				if (block.Instructions[i].OpCode.OpCodeType == OpCodeType.Prefix) {  					skipCount = 1;  					currentFragment.Add(block.Instructions[i]);  				}  				if (i + 2 < block.Instructions.Count &&  				    block.Instructions[i + 0].OpCode.Code == Code.Dup &&  				    block.Instructions[i + 1].OpCode.Code == Code.Ldvirtftn &&  				    block.Instructions[i + 2].OpCode.Code == Code.Newobj) {  					skipCount = 2;  					currentFragment.Add(block.Instructions[i]);  				}  				if (i + 4 < block.Instructions.Count &&  				    block.Instructions[i + 0].OpCode.Code == Code.Ldc_I4 &&  				    block.Instructions[i + 1].OpCode.Code == Code.Newarr &&  				    block.Instructions[i + 2].OpCode.Code == Code.Dup &&  				    block.Instructions[i + 3].OpCode.Code == Code.Ldtoken &&  				    block.Instructions[i + 4].OpCode.Code == Code.Call) // Array initializer  				{  					skipCount = 4;  					currentFragment.Add(block.Instructions[i]);  				}  				if (i + 1 < block.Instructions.Count &&  				    block.Instructions[i + 0].OpCode.Code == Code.Ldftn &&  				    block.Instructions[i + 1].OpCode.Code == Code.Newobj) {  					skipCount = 1;  					currentFragment.Add(block.Instructions[i]);  				}  				currentFragment.Add(block.Instructions[i]);    				if (ctx.Intensity > ctx.Random.NextDouble()) {  					fragments.AddLast(currentFragment.ToArray());  					currentFragment.Clear();  				}  			}
Magic Number,Confuser.Protections.ControlFlow,JumpMangler,C:\repos\yck1509_ConfuserEx\Confuser.Protections\ControlFlow\JumpMangler.cs,SpiltFragments,The following statement contains a magic number: for (int i = 0; i < block.Instructions.Count; i++) {  				if (skipCount != -1) {  					if (skipCount > 0) {  						currentFragment.Add(block.Instructions[i]);  						skipCount--;  						continue;  					}  					fragments.AddLast(currentFragment.ToArray());  					currentFragment.Clear();    					skipCount = -1;  				}    				if (block.Instructions[i].OpCode.OpCodeType == OpCodeType.Prefix) {  					skipCount = 1;  					currentFragment.Add(block.Instructions[i]);  				}  				if (i + 2 < block.Instructions.Count &&  				    block.Instructions[i + 0].OpCode.Code == Code.Dup &&  				    block.Instructions[i + 1].OpCode.Code == Code.Ldvirtftn &&  				    block.Instructions[i + 2].OpCode.Code == Code.Newobj) {  					skipCount = 2;  					currentFragment.Add(block.Instructions[i]);  				}  				if (i + 4 < block.Instructions.Count &&  				    block.Instructions[i + 0].OpCode.Code == Code.Ldc_I4 &&  				    block.Instructions[i + 1].OpCode.Code == Code.Newarr &&  				    block.Instructions[i + 2].OpCode.Code == Code.Dup &&  				    block.Instructions[i + 3].OpCode.Code == Code.Ldtoken &&  				    block.Instructions[i + 4].OpCode.Code == Code.Call) // Array initializer  				{  					skipCount = 4;  					currentFragment.Add(block.Instructions[i]);  				}  				if (i + 1 < block.Instructions.Count &&  				    block.Instructions[i + 0].OpCode.Code == Code.Ldftn &&  				    block.Instructions[i + 1].OpCode.Code == Code.Newobj) {  					skipCount = 1;  					currentFragment.Add(block.Instructions[i]);  				}  				currentFragment.Add(block.Instructions[i]);    				if (ctx.Intensity > ctx.Random.NextDouble()) {  					fragments.AddLast(currentFragment.ToArray());  					currentFragment.Clear();  				}  			}
Magic Number,Confuser.Protections.ControlFlow,JumpMangler,C:\repos\yck1509_ConfuserEx\Confuser.Protections\ControlFlow\JumpMangler.cs,SpiltFragments,The following statement contains a magic number: for (int i = 0; i < block.Instructions.Count; i++) {  				if (skipCount != -1) {  					if (skipCount > 0) {  						currentFragment.Add(block.Instructions[i]);  						skipCount--;  						continue;  					}  					fragments.AddLast(currentFragment.ToArray());  					currentFragment.Clear();    					skipCount = -1;  				}    				if (block.Instructions[i].OpCode.OpCodeType == OpCodeType.Prefix) {  					skipCount = 1;  					currentFragment.Add(block.Instructions[i]);  				}  				if (i + 2 < block.Instructions.Count &&  				    block.Instructions[i + 0].OpCode.Code == Code.Dup &&  				    block.Instructions[i + 1].OpCode.Code == Code.Ldvirtftn &&  				    block.Instructions[i + 2].OpCode.Code == Code.Newobj) {  					skipCount = 2;  					currentFragment.Add(block.Instructions[i]);  				}  				if (i + 4 < block.Instructions.Count &&  				    block.Instructions[i + 0].OpCode.Code == Code.Ldc_I4 &&  				    block.Instructions[i + 1].OpCode.Code == Code.Newarr &&  				    block.Instructions[i + 2].OpCode.Code == Code.Dup &&  				    block.Instructions[i + 3].OpCode.Code == Code.Ldtoken &&  				    block.Instructions[i + 4].OpCode.Code == Code.Call) // Array initializer  				{  					skipCount = 4;  					currentFragment.Add(block.Instructions[i]);  				}  				if (i + 1 < block.Instructions.Count &&  				    block.Instructions[i + 0].OpCode.Code == Code.Ldftn &&  				    block.Instructions[i + 1].OpCode.Code == Code.Newobj) {  					skipCount = 1;  					currentFragment.Add(block.Instructions[i]);  				}  				currentFragment.Add(block.Instructions[i]);    				if (ctx.Intensity > ctx.Random.NextDouble()) {  					fragments.AddLast(currentFragment.ToArray());  					currentFragment.Clear();  				}  			}
Magic Number,Confuser.Protections.ControlFlow,JumpMangler,C:\repos\yck1509_ConfuserEx\Confuser.Protections\ControlFlow\JumpMangler.cs,SpiltFragments,The following statement contains a magic number: for (int i = 0; i < block.Instructions.Count; i++) {  				if (skipCount != -1) {  					if (skipCount > 0) {  						currentFragment.Add(block.Instructions[i]);  						skipCount--;  						continue;  					}  					fragments.AddLast(currentFragment.ToArray());  					currentFragment.Clear();    					skipCount = -1;  				}    				if (block.Instructions[i].OpCode.OpCodeType == OpCodeType.Prefix) {  					skipCount = 1;  					currentFragment.Add(block.Instructions[i]);  				}  				if (i + 2 < block.Instructions.Count &&  				    block.Instructions[i + 0].OpCode.Code == Code.Dup &&  				    block.Instructions[i + 1].OpCode.Code == Code.Ldvirtftn &&  				    block.Instructions[i + 2].OpCode.Code == Code.Newobj) {  					skipCount = 2;  					currentFragment.Add(block.Instructions[i]);  				}  				if (i + 4 < block.Instructions.Count &&  				    block.Instructions[i + 0].OpCode.Code == Code.Ldc_I4 &&  				    block.Instructions[i + 1].OpCode.Code == Code.Newarr &&  				    block.Instructions[i + 2].OpCode.Code == Code.Dup &&  				    block.Instructions[i + 3].OpCode.Code == Code.Ldtoken &&  				    block.Instructions[i + 4].OpCode.Code == Code.Call) // Array initializer  				{  					skipCount = 4;  					currentFragment.Add(block.Instructions[i]);  				}  				if (i + 1 < block.Instructions.Count &&  				    block.Instructions[i + 0].OpCode.Code == Code.Ldftn &&  				    block.Instructions[i + 1].OpCode.Code == Code.Newobj) {  					skipCount = 1;  					currentFragment.Add(block.Instructions[i]);  				}  				currentFragment.Add(block.Instructions[i]);    				if (ctx.Intensity > ctx.Random.NextDouble()) {  					fragments.AddLast(currentFragment.ToArray());  					currentFragment.Clear();  				}  			}
Magic Number,Confuser.Protections.ControlFlow,JumpMangler,C:\repos\yck1509_ConfuserEx\Confuser.Protections\ControlFlow\JumpMangler.cs,SpiltFragments,The following statement contains a magic number: for (int i = 0; i < block.Instructions.Count; i++) {  				if (skipCount != -1) {  					if (skipCount > 0) {  						currentFragment.Add(block.Instructions[i]);  						skipCount--;  						continue;  					}  					fragments.AddLast(currentFragment.ToArray());  					currentFragment.Clear();    					skipCount = -1;  				}    				if (block.Instructions[i].OpCode.OpCodeType == OpCodeType.Prefix) {  					skipCount = 1;  					currentFragment.Add(block.Instructions[i]);  				}  				if (i + 2 < block.Instructions.Count &&  				    block.Instructions[i + 0].OpCode.Code == Code.Dup &&  				    block.Instructions[i + 1].OpCode.Code == Code.Ldvirtftn &&  				    block.Instructions[i + 2].OpCode.Code == Code.Newobj) {  					skipCount = 2;  					currentFragment.Add(block.Instructions[i]);  				}  				if (i + 4 < block.Instructions.Count &&  				    block.Instructions[i + 0].OpCode.Code == Code.Ldc_I4 &&  				    block.Instructions[i + 1].OpCode.Code == Code.Newarr &&  				    block.Instructions[i + 2].OpCode.Code == Code.Dup &&  				    block.Instructions[i + 3].OpCode.Code == Code.Ldtoken &&  				    block.Instructions[i + 4].OpCode.Code == Code.Call) // Array initializer  				{  					skipCount = 4;  					currentFragment.Add(block.Instructions[i]);  				}  				if (i + 1 < block.Instructions.Count &&  				    block.Instructions[i + 0].OpCode.Code == Code.Ldftn &&  				    block.Instructions[i + 1].OpCode.Code == Code.Newobj) {  					skipCount = 1;  					currentFragment.Add(block.Instructions[i]);  				}  				currentFragment.Add(block.Instructions[i]);    				if (ctx.Intensity > ctx.Random.NextDouble()) {  					fragments.AddLast(currentFragment.ToArray());  					currentFragment.Clear();  				}  			}
Magic Number,Confuser.Protections.ControlFlow,JumpMangler,C:\repos\yck1509_ConfuserEx\Confuser.Protections\ControlFlow\JumpMangler.cs,SpiltFragments,The following statement contains a magic number: for (int i = 0; i < block.Instructions.Count; i++) {  				if (skipCount != -1) {  					if (skipCount > 0) {  						currentFragment.Add(block.Instructions[i]);  						skipCount--;  						continue;  					}  					fragments.AddLast(currentFragment.ToArray());  					currentFragment.Clear();    					skipCount = -1;  				}    				if (block.Instructions[i].OpCode.OpCodeType == OpCodeType.Prefix) {  					skipCount = 1;  					currentFragment.Add(block.Instructions[i]);  				}  				if (i + 2 < block.Instructions.Count &&  				    block.Instructions[i + 0].OpCode.Code == Code.Dup &&  				    block.Instructions[i + 1].OpCode.Code == Code.Ldvirtftn &&  				    block.Instructions[i + 2].OpCode.Code == Code.Newobj) {  					skipCount = 2;  					currentFragment.Add(block.Instructions[i]);  				}  				if (i + 4 < block.Instructions.Count &&  				    block.Instructions[i + 0].OpCode.Code == Code.Ldc_I4 &&  				    block.Instructions[i + 1].OpCode.Code == Code.Newarr &&  				    block.Instructions[i + 2].OpCode.Code == Code.Dup &&  				    block.Instructions[i + 3].OpCode.Code == Code.Ldtoken &&  				    block.Instructions[i + 4].OpCode.Code == Code.Call) // Array initializer  				{  					skipCount = 4;  					currentFragment.Add(block.Instructions[i]);  				}  				if (i + 1 < block.Instructions.Count &&  				    block.Instructions[i + 0].OpCode.Code == Code.Ldftn &&  				    block.Instructions[i + 1].OpCode.Code == Code.Newobj) {  					skipCount = 1;  					currentFragment.Add(block.Instructions[i]);  				}  				currentFragment.Add(block.Instructions[i]);    				if (ctx.Intensity > ctx.Random.NextDouble()) {  					fragments.AddLast(currentFragment.ToArray());  					currentFragment.Clear();  				}  			}
Magic Number,Confuser.Protections.ControlFlow,JumpMangler,C:\repos\yck1509_ConfuserEx\Confuser.Protections\ControlFlow\JumpMangler.cs,SpiltFragments,The following statement contains a magic number: for (int i = 0; i < block.Instructions.Count; i++) {  				if (skipCount != -1) {  					if (skipCount > 0) {  						currentFragment.Add(block.Instructions[i]);  						skipCount--;  						continue;  					}  					fragments.AddLast(currentFragment.ToArray());  					currentFragment.Clear();    					skipCount = -1;  				}    				if (block.Instructions[i].OpCode.OpCodeType == OpCodeType.Prefix) {  					skipCount = 1;  					currentFragment.Add(block.Instructions[i]);  				}  				if (i + 2 < block.Instructions.Count &&  				    block.Instructions[i + 0].OpCode.Code == Code.Dup &&  				    block.Instructions[i + 1].OpCode.Code == Code.Ldvirtftn &&  				    block.Instructions[i + 2].OpCode.Code == Code.Newobj) {  					skipCount = 2;  					currentFragment.Add(block.Instructions[i]);  				}  				if (i + 4 < block.Instructions.Count &&  				    block.Instructions[i + 0].OpCode.Code == Code.Ldc_I4 &&  				    block.Instructions[i + 1].OpCode.Code == Code.Newarr &&  				    block.Instructions[i + 2].OpCode.Code == Code.Dup &&  				    block.Instructions[i + 3].OpCode.Code == Code.Ldtoken &&  				    block.Instructions[i + 4].OpCode.Code == Code.Call) // Array initializer  				{  					skipCount = 4;  					currentFragment.Add(block.Instructions[i]);  				}  				if (i + 1 < block.Instructions.Count &&  				    block.Instructions[i + 0].OpCode.Code == Code.Ldftn &&  				    block.Instructions[i + 1].OpCode.Code == Code.Newobj) {  					skipCount = 1;  					currentFragment.Add(block.Instructions[i]);  				}  				currentFragment.Add(block.Instructions[i]);    				if (ctx.Intensity > ctx.Random.NextDouble()) {  					fragments.AddLast(currentFragment.ToArray());  					currentFragment.Clear();  				}  			}
Magic Number,Confuser.Protections.ControlFlow,JumpMangler,C:\repos\yck1509_ConfuserEx\Confuser.Protections\ControlFlow\JumpMangler.cs,Mangle,The following statement contains a magic number: foreach (InstrBlock block in GetAllBlocks(root)) {  				LinkedList<Instruction[]> fragments = SpiltFragments(block' ctx);  				if (fragments.Count < 4) continue;    				LinkedListNode<Instruction[]> current = fragments.First;  				while (current.Next != null) {  					var newFragment = new List<Instruction>(current.Value);  					ctx.AddJump(newFragment' current.Next.Value[0]);  					ctx.AddJunk(newFragment);  					current.Value = newFragment.ToArray();  					current = current.Next;  				}  				Instruction[] first = fragments.First.Value;  				fragments.RemoveFirst();  				Instruction[] last = fragments.Last.Value;  				fragments.RemoveLast();    				List<Instruction[]> newFragments = fragments.ToList();  				ctx.Random.Shuffle(newFragments);    				block.Instructions = first  					.Concat(newFragments.SelectMany(fragment => fragment))  					.Concat(last).ToList();  			}
Magic Number,Confuser.Protections.ControlFlow,SwitchMangler,C:\repos\yck1509_ConfuserEx\Confuser.Protections\ControlFlow\SwitchMangler.cs,Mangle,The following statement contains a magic number: body.MaxStack += 2;
Magic Number,Confuser.Protections.ControlFlow,SwitchMangler,C:\repos\yck1509_ConfuserEx\Confuser.Protections\ControlFlow\SwitchMangler.cs,Mangle,The following statement contains a magic number: foreach (InstrBlock block in GetAllBlocks(root)) {  				LinkedList<Instruction[]> statements = SpiltStatements(block' trace' ctx);    				// Make sure .ctor is executed before switch  				if (ctx.Method.IsInstanceConstructor) {  					var newStatement = new List<Instruction>();  					while (statements.First != null) {  						newStatement.AddRange(statements.First.Value);  						Instruction lastInstr = statements.First.Value.Last();  						statements.RemoveFirst();  						if (lastInstr.OpCode == OpCodes.Call && ((IMethod)lastInstr.Operand).Name == ".ctor")  							break;  					}  					statements.AddFirst(newStatement.ToArray());  				}    				if (statements.Count < 3) continue;    				int i;    				var keyId = Enumerable.Range(0' statements.Count).ToArray();  				ctx.Random.Shuffle(keyId);  				var key = new int[keyId.Length];  				for (i = 0; i < key.Length; i++) {  					var q = ctx.Random.NextInt32() & 0x7fffffff;  					key[i] = q - q % statements.Count + keyId[i];  				}    				var statementKeys = new Dictionary<Instruction' int>();  				LinkedListNode<Instruction[]> current = statements.First;  				i = 0;  				while (current != null) {  					if (i != 0)  						statementKeys[current.Value[0]] = key[i];  					i++;  					current = current.Next;  				}    				var statementLast = new HashSet<Instruction>(statements.Select(st => st.Last()));    				Func<IList<Instruction>' bool> hasUnknownSource;  				hasUnknownSource = instrs => instrs.Any(instr => {  					if (trace.HasMultipleSources(instr.Offset))  						return true;  					List<Instruction> srcs;  					if (trace.BrRefs.TryGetValue(instr.Offset' out srcs)) {  						// Target of switch => assume unknown  						if (srcs.Any(src => src.Operand is Instruction[]))  							return true;    						// Not within current instruction block / targeted in first statement  						if (srcs.Any(src => src.Offset <= statements.First.Value.Last().Offset ||  						                    src.Offset >= block.Instructions.Last().Offset))  							return true;    						// Not targeted by the last of statements  						if (srcs.Any(src => statementLast.Contains(src)))  							return true;  					}  					return false;  				});    				var switchInstr = new Instruction(OpCodes.Switch);  				var switchHdr = new List<Instruction>();    				if (predicate != null) {  					predicate.Init(body);  					switchHdr.Add(Instruction.CreateLdcI4(predicate.GetSwitchKey(key[1])));  					predicate.EmitSwitchLoad(switchHdr);  				}  				else {  					switchHdr.Add(Instruction.CreateLdcI4(key[1]));  				}    				switchHdr.Add(Instruction.Create(OpCodes.Dup));  				switchHdr.Add(Instruction.Create(OpCodes.Stloc' local));  				switchHdr.Add(Instruction.Create(OpCodes.Ldc_I4' statements.Count));  				switchHdr.Add(Instruction.Create(OpCodes.Rem_Un));  				switchHdr.Add(switchInstr);    				ctx.AddJump(switchHdr' statements.Last.Value[0]);  				ctx.AddJunk(switchHdr);    				var operands = new Instruction[statements.Count];  				current = statements.First;  				i = 0;  				while (current.Next != null) {  					var newStatement = new List<Instruction>(current.Value);    					if (i != 0) {  						// Convert to switch  						bool converted = false;    						if (newStatement.Last().IsBr()) {  							// Unconditional    							var target = (Instruction)newStatement.Last().Operand;  							int brKey;  							if (!trace.IsBranchTarget(newStatement.Last().Offset) &&  							    statementKeys.TryGetValue(target' out brKey)) {  								var targetKey = predicate != null ? predicate.GetSwitchKey(brKey) : brKey;  								var unkSrc = hasUnknownSource(newStatement);    								newStatement.RemoveAt(newStatement.Count - 1);    								if (unkSrc) {  									newStatement.Add(Instruction.Create(OpCodes.Ldc_I4' targetKey));  								}  								else {  									var thisKey = key[i];  									var r = ctx.Random.NextInt32();  									newStatement.Add(Instruction.Create(OpCodes.Ldloc' local));  									newStatement.Add(Instruction.CreateLdcI4(r));  									newStatement.Add(Instruction.Create(OpCodes.Mul));  									newStatement.Add(Instruction.Create(OpCodes.Ldc_I4' (thisKey * r) ^ targetKey));  									newStatement.Add(Instruction.Create(OpCodes.Xor));  								}    								ctx.AddJump(newStatement' switchHdr[1]);  								ctx.AddJunk(newStatement);  								operands[keyId[i]] = newStatement[0];  								converted = true;  							}  						}  						else if (newStatement.Last().IsConditionalBranch()) {  							// Conditional    							var target = (Instruction)newStatement.Last().Operand;  							int brKey;  							if (!trace.IsBranchTarget(newStatement.Last().Offset) &&  							    statementKeys.TryGetValue(target' out brKey)) {  								bool unkSrc = hasUnknownSource(newStatement);  								int nextKey = key[i + 1];  								OpCode condBr = newStatement.Last().OpCode;  								newStatement.RemoveAt(newStatement.Count - 1);    								if (ctx.Random.NextBoolean()) {  									condBr = InverseBranch(condBr);  									int tmp = brKey;  									brKey = nextKey;  									nextKey = tmp;  								}    								var thisKey = key[i];  								int r = 0' xorKey = 0;  								if (!unkSrc) {  									r = ctx.Random.NextInt32();  									xorKey = thisKey * r;  								}    								Instruction brKeyInstr = Instruction.CreateLdcI4(xorKey ^ (predicate != null ? predicate.GetSwitchKey(brKey) : brKey));  								Instruction nextKeyInstr = Instruction.CreateLdcI4(xorKey ^ (predicate != null ? predicate.GetSwitchKey(nextKey) : nextKey));  								Instruction pop = Instruction.Create(OpCodes.Pop);    								newStatement.Add(Instruction.Create(condBr' brKeyInstr));  								newStatement.Add(nextKeyInstr);  								newStatement.Add(Instruction.Create(OpCodes.Dup));  								newStatement.Add(Instruction.Create(OpCodes.Br' pop));  								newStatement.Add(brKeyInstr);  								newStatement.Add(Instruction.Create(OpCodes.Dup));  								newStatement.Add(pop);    								if (!unkSrc) {  									newStatement.Add(Instruction.Create(OpCodes.Ldloc' local));  									newStatement.Add(Instruction.CreateLdcI4(r));  									newStatement.Add(Instruction.Create(OpCodes.Mul));  									newStatement.Add(Instruction.Create(OpCodes.Xor));  								}    								ctx.AddJump(newStatement' switchHdr[1]);  								ctx.AddJunk(newStatement);  								operands[keyId[i]] = newStatement[0];  								converted = true;  							}  						}    						if (!converted) {  							// Normal    							var targetKey = predicate != null ? predicate.GetSwitchKey(key[i + 1]) : key[i + 1];  							if (!hasUnknownSource(newStatement)) {  								var thisKey = key[i];  								var r = ctx.Random.NextInt32();  								newStatement.Add(Instruction.Create(OpCodes.Ldloc' local));  								newStatement.Add(Instruction.CreateLdcI4(r));  								newStatement.Add(Instruction.Create(OpCodes.Mul));  								newStatement.Add(Instruction.Create(OpCodes.Ldc_I4' (thisKey * r) ^ targetKey));  								newStatement.Add(Instruction.Create(OpCodes.Xor));  							}  							else {  								newStatement.Add(Instruction.Create(OpCodes.Ldc_I4' targetKey));  							}    							ctx.AddJump(newStatement' switchHdr[1]);  							ctx.AddJunk(newStatement);  							operands[keyId[i]] = newStatement[0];  						}  					}  					else  						operands[keyId[i]] = switchHdr[0];    					current.Value = newStatement.ToArray();  					current = current.Next;  					i++;  				}  				operands[keyId[i]] = current.Value[0];  				switchInstr.Operand = operands;    				Instruction[] first = statements.First.Value;  				statements.RemoveFirst();  				Instruction[] last = statements.Last.Value;  				statements.RemoveLast();    				List<Instruction[]> newStatements = statements.ToList();  				ctx.Random.Shuffle(newStatements);    				block.Instructions.Clear();  				block.Instructions.AddRange(first);  				block.Instructions.AddRange(switchHdr);  				foreach (var statement in newStatements)  					block.Instructions.AddRange(statement);  				block.Instructions.AddRange(last);  			}
Magic Number,Confuser.Protections.ReferenceProxy,StrongMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\ReferenceProxy\StrongMode.cs,GetInitMethod,The following statement contains a magic number: if (initDescs[index] == null) {  				TypeDef rtType = ctx.Context.Registry.GetService<IRuntimeService>().GetRuntimeType("Confuser.Runtime.RefProxyStrong");  				MethodDef injectedMethod = InjectHelper.Inject(rtType.FindMethod("Initialize")' ctx.Module);  				ctx.Module.GlobalType.Methods.Add(injectedMethod);    				injectedMethod.Access = MethodAttributes.PrivateScope;  				injectedMethod.Name = ctx.Name.RandomName();  				ctx.Name.SetCanRename(injectedMethod' false);  				ctx.Marker.Mark(injectedMethod' ctx.Protection);    				var desc = new InitMethodDesc { Method = injectedMethod };    				// Field name has five bytes' each bytes has different order & meaning  				int[] order = Enumerable.Range(0' 5).ToArray();  				ctx.Random.Shuffle(order);  				desc.OpCodeIndex = order[4];    				desc.TokenNameOrder = new int[4];  				Array.Copy(order' 0' desc.TokenNameOrder' 0' 4);  				desc.TokenByteOrder = Enumerable.Range(0' 4).Select(x => x * 8).ToArray();  				ctx.Random.Shuffle(desc.TokenByteOrder);    				var keyInjection = new int[9];  				Array.Copy(desc.TokenNameOrder' 0' keyInjection' 0' 4);  				Array.Copy(desc.TokenByteOrder' 0' keyInjection' 4' 4);  				keyInjection[8] = desc.OpCodeIndex;  				MutationHelper.InjectKeys(injectedMethod' Enumerable.Range(0' 9).ToArray()' keyInjection);    				// Encoding  				MutationHelper.ReplacePlaceholder(injectedMethod' arg => { return encoding.EmitDecode(injectedMethod' ctx' arg); });  				desc.Encoding = encoding;    				initDescs[index] = desc;  			}
Magic Number,Confuser.Protections.ReferenceProxy,StrongMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\ReferenceProxy\StrongMode.cs,GetInitMethod,The following statement contains a magic number: if (initDescs[index] == null) {  				TypeDef rtType = ctx.Context.Registry.GetService<IRuntimeService>().GetRuntimeType("Confuser.Runtime.RefProxyStrong");  				MethodDef injectedMethod = InjectHelper.Inject(rtType.FindMethod("Initialize")' ctx.Module);  				ctx.Module.GlobalType.Methods.Add(injectedMethod);    				injectedMethod.Access = MethodAttributes.PrivateScope;  				injectedMethod.Name = ctx.Name.RandomName();  				ctx.Name.SetCanRename(injectedMethod' false);  				ctx.Marker.Mark(injectedMethod' ctx.Protection);    				var desc = new InitMethodDesc { Method = injectedMethod };    				// Field name has five bytes' each bytes has different order & meaning  				int[] order = Enumerable.Range(0' 5).ToArray();  				ctx.Random.Shuffle(order);  				desc.OpCodeIndex = order[4];    				desc.TokenNameOrder = new int[4];  				Array.Copy(order' 0' desc.TokenNameOrder' 0' 4);  				desc.TokenByteOrder = Enumerable.Range(0' 4).Select(x => x * 8).ToArray();  				ctx.Random.Shuffle(desc.TokenByteOrder);    				var keyInjection = new int[9];  				Array.Copy(desc.TokenNameOrder' 0' keyInjection' 0' 4);  				Array.Copy(desc.TokenByteOrder' 0' keyInjection' 4' 4);  				keyInjection[8] = desc.OpCodeIndex;  				MutationHelper.InjectKeys(injectedMethod' Enumerable.Range(0' 9).ToArray()' keyInjection);    				// Encoding  				MutationHelper.ReplacePlaceholder(injectedMethod' arg => { return encoding.EmitDecode(injectedMethod' ctx' arg); });  				desc.Encoding = encoding;    				initDescs[index] = desc;  			}
Magic Number,Confuser.Protections.ReferenceProxy,StrongMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\ReferenceProxy\StrongMode.cs,GetInitMethod,The following statement contains a magic number: if (initDescs[index] == null) {  				TypeDef rtType = ctx.Context.Registry.GetService<IRuntimeService>().GetRuntimeType("Confuser.Runtime.RefProxyStrong");  				MethodDef injectedMethod = InjectHelper.Inject(rtType.FindMethod("Initialize")' ctx.Module);  				ctx.Module.GlobalType.Methods.Add(injectedMethod);    				injectedMethod.Access = MethodAttributes.PrivateScope;  				injectedMethod.Name = ctx.Name.RandomName();  				ctx.Name.SetCanRename(injectedMethod' false);  				ctx.Marker.Mark(injectedMethod' ctx.Protection);    				var desc = new InitMethodDesc { Method = injectedMethod };    				// Field name has five bytes' each bytes has different order & meaning  				int[] order = Enumerable.Range(0' 5).ToArray();  				ctx.Random.Shuffle(order);  				desc.OpCodeIndex = order[4];    				desc.TokenNameOrder = new int[4];  				Array.Copy(order' 0' desc.TokenNameOrder' 0' 4);  				desc.TokenByteOrder = Enumerable.Range(0' 4).Select(x => x * 8).ToArray();  				ctx.Random.Shuffle(desc.TokenByteOrder);    				var keyInjection = new int[9];  				Array.Copy(desc.TokenNameOrder' 0' keyInjection' 0' 4);  				Array.Copy(desc.TokenByteOrder' 0' keyInjection' 4' 4);  				keyInjection[8] = desc.OpCodeIndex;  				MutationHelper.InjectKeys(injectedMethod' Enumerable.Range(0' 9).ToArray()' keyInjection);    				// Encoding  				MutationHelper.ReplacePlaceholder(injectedMethod' arg => { return encoding.EmitDecode(injectedMethod' ctx' arg); });  				desc.Encoding = encoding;    				initDescs[index] = desc;  			}
Magic Number,Confuser.Protections.ReferenceProxy,StrongMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\ReferenceProxy\StrongMode.cs,GetInitMethod,The following statement contains a magic number: if (initDescs[index] == null) {  				TypeDef rtType = ctx.Context.Registry.GetService<IRuntimeService>().GetRuntimeType("Confuser.Runtime.RefProxyStrong");  				MethodDef injectedMethod = InjectHelper.Inject(rtType.FindMethod("Initialize")' ctx.Module);  				ctx.Module.GlobalType.Methods.Add(injectedMethod);    				injectedMethod.Access = MethodAttributes.PrivateScope;  				injectedMethod.Name = ctx.Name.RandomName();  				ctx.Name.SetCanRename(injectedMethod' false);  				ctx.Marker.Mark(injectedMethod' ctx.Protection);    				var desc = new InitMethodDesc { Method = injectedMethod };    				// Field name has five bytes' each bytes has different order & meaning  				int[] order = Enumerable.Range(0' 5).ToArray();  				ctx.Random.Shuffle(order);  				desc.OpCodeIndex = order[4];    				desc.TokenNameOrder = new int[4];  				Array.Copy(order' 0' desc.TokenNameOrder' 0' 4);  				desc.TokenByteOrder = Enumerable.Range(0' 4).Select(x => x * 8).ToArray();  				ctx.Random.Shuffle(desc.TokenByteOrder);    				var keyInjection = new int[9];  				Array.Copy(desc.TokenNameOrder' 0' keyInjection' 0' 4);  				Array.Copy(desc.TokenByteOrder' 0' keyInjection' 4' 4);  				keyInjection[8] = desc.OpCodeIndex;  				MutationHelper.InjectKeys(injectedMethod' Enumerable.Range(0' 9).ToArray()' keyInjection);    				// Encoding  				MutationHelper.ReplacePlaceholder(injectedMethod' arg => { return encoding.EmitDecode(injectedMethod' ctx' arg); });  				desc.Encoding = encoding;    				initDescs[index] = desc;  			}
Magic Number,Confuser.Protections.ReferenceProxy,StrongMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\ReferenceProxy\StrongMode.cs,GetInitMethod,The following statement contains a magic number: if (initDescs[index] == null) {  				TypeDef rtType = ctx.Context.Registry.GetService<IRuntimeService>().GetRuntimeType("Confuser.Runtime.RefProxyStrong");  				MethodDef injectedMethod = InjectHelper.Inject(rtType.FindMethod("Initialize")' ctx.Module);  				ctx.Module.GlobalType.Methods.Add(injectedMethod);    				injectedMethod.Access = MethodAttributes.PrivateScope;  				injectedMethod.Name = ctx.Name.RandomName();  				ctx.Name.SetCanRename(injectedMethod' false);  				ctx.Marker.Mark(injectedMethod' ctx.Protection);    				var desc = new InitMethodDesc { Method = injectedMethod };    				// Field name has five bytes' each bytes has different order & meaning  				int[] order = Enumerable.Range(0' 5).ToArray();  				ctx.Random.Shuffle(order);  				desc.OpCodeIndex = order[4];    				desc.TokenNameOrder = new int[4];  				Array.Copy(order' 0' desc.TokenNameOrder' 0' 4);  				desc.TokenByteOrder = Enumerable.Range(0' 4).Select(x => x * 8).ToArray();  				ctx.Random.Shuffle(desc.TokenByteOrder);    				var keyInjection = new int[9];  				Array.Copy(desc.TokenNameOrder' 0' keyInjection' 0' 4);  				Array.Copy(desc.TokenByteOrder' 0' keyInjection' 4' 4);  				keyInjection[8] = desc.OpCodeIndex;  				MutationHelper.InjectKeys(injectedMethod' Enumerable.Range(0' 9).ToArray()' keyInjection);    				// Encoding  				MutationHelper.ReplacePlaceholder(injectedMethod' arg => { return encoding.EmitDecode(injectedMethod' ctx' arg); });  				desc.Encoding = encoding;    				initDescs[index] = desc;  			}
Magic Number,Confuser.Protections.ReferenceProxy,StrongMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\ReferenceProxy\StrongMode.cs,GetInitMethod,The following statement contains a magic number: if (initDescs[index] == null) {  				TypeDef rtType = ctx.Context.Registry.GetService<IRuntimeService>().GetRuntimeType("Confuser.Runtime.RefProxyStrong");  				MethodDef injectedMethod = InjectHelper.Inject(rtType.FindMethod("Initialize")' ctx.Module);  				ctx.Module.GlobalType.Methods.Add(injectedMethod);    				injectedMethod.Access = MethodAttributes.PrivateScope;  				injectedMethod.Name = ctx.Name.RandomName();  				ctx.Name.SetCanRename(injectedMethod' false);  				ctx.Marker.Mark(injectedMethod' ctx.Protection);    				var desc = new InitMethodDesc { Method = injectedMethod };    				// Field name has five bytes' each bytes has different order & meaning  				int[] order = Enumerable.Range(0' 5).ToArray();  				ctx.Random.Shuffle(order);  				desc.OpCodeIndex = order[4];    				desc.TokenNameOrder = new int[4];  				Array.Copy(order' 0' desc.TokenNameOrder' 0' 4);  				desc.TokenByteOrder = Enumerable.Range(0' 4).Select(x => x * 8).ToArray();  				ctx.Random.Shuffle(desc.TokenByteOrder);    				var keyInjection = new int[9];  				Array.Copy(desc.TokenNameOrder' 0' keyInjection' 0' 4);  				Array.Copy(desc.TokenByteOrder' 0' keyInjection' 4' 4);  				keyInjection[8] = desc.OpCodeIndex;  				MutationHelper.InjectKeys(injectedMethod' Enumerable.Range(0' 9).ToArray()' keyInjection);    				// Encoding  				MutationHelper.ReplacePlaceholder(injectedMethod' arg => { return encoding.EmitDecode(injectedMethod' ctx' arg); });  				desc.Encoding = encoding;    				initDescs[index] = desc;  			}
Magic Number,Confuser.Protections.ReferenceProxy,StrongMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\ReferenceProxy\StrongMode.cs,GetInitMethod,The following statement contains a magic number: if (initDescs[index] == null) {  				TypeDef rtType = ctx.Context.Registry.GetService<IRuntimeService>().GetRuntimeType("Confuser.Runtime.RefProxyStrong");  				MethodDef injectedMethod = InjectHelper.Inject(rtType.FindMethod("Initialize")' ctx.Module);  				ctx.Module.GlobalType.Methods.Add(injectedMethod);    				injectedMethod.Access = MethodAttributes.PrivateScope;  				injectedMethod.Name = ctx.Name.RandomName();  				ctx.Name.SetCanRename(injectedMethod' false);  				ctx.Marker.Mark(injectedMethod' ctx.Protection);    				var desc = new InitMethodDesc { Method = injectedMethod };    				// Field name has five bytes' each bytes has different order & meaning  				int[] order = Enumerable.Range(0' 5).ToArray();  				ctx.Random.Shuffle(order);  				desc.OpCodeIndex = order[4];    				desc.TokenNameOrder = new int[4];  				Array.Copy(order' 0' desc.TokenNameOrder' 0' 4);  				desc.TokenByteOrder = Enumerable.Range(0' 4).Select(x => x * 8).ToArray();  				ctx.Random.Shuffle(desc.TokenByteOrder);    				var keyInjection = new int[9];  				Array.Copy(desc.TokenNameOrder' 0' keyInjection' 0' 4);  				Array.Copy(desc.TokenByteOrder' 0' keyInjection' 4' 4);  				keyInjection[8] = desc.OpCodeIndex;  				MutationHelper.InjectKeys(injectedMethod' Enumerable.Range(0' 9).ToArray()' keyInjection);    				// Encoding  				MutationHelper.ReplacePlaceholder(injectedMethod' arg => { return encoding.EmitDecode(injectedMethod' ctx' arg); });  				desc.Encoding = encoding;    				initDescs[index] = desc;  			}
Magic Number,Confuser.Protections.ReferenceProxy,StrongMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\ReferenceProxy\StrongMode.cs,GetInitMethod,The following statement contains a magic number: if (initDescs[index] == null) {  				TypeDef rtType = ctx.Context.Registry.GetService<IRuntimeService>().GetRuntimeType("Confuser.Runtime.RefProxyStrong");  				MethodDef injectedMethod = InjectHelper.Inject(rtType.FindMethod("Initialize")' ctx.Module);  				ctx.Module.GlobalType.Methods.Add(injectedMethod);    				injectedMethod.Access = MethodAttributes.PrivateScope;  				injectedMethod.Name = ctx.Name.RandomName();  				ctx.Name.SetCanRename(injectedMethod' false);  				ctx.Marker.Mark(injectedMethod' ctx.Protection);    				var desc = new InitMethodDesc { Method = injectedMethod };    				// Field name has five bytes' each bytes has different order & meaning  				int[] order = Enumerable.Range(0' 5).ToArray();  				ctx.Random.Shuffle(order);  				desc.OpCodeIndex = order[4];    				desc.TokenNameOrder = new int[4];  				Array.Copy(order' 0' desc.TokenNameOrder' 0' 4);  				desc.TokenByteOrder = Enumerable.Range(0' 4).Select(x => x * 8).ToArray();  				ctx.Random.Shuffle(desc.TokenByteOrder);    				var keyInjection = new int[9];  				Array.Copy(desc.TokenNameOrder' 0' keyInjection' 0' 4);  				Array.Copy(desc.TokenByteOrder' 0' keyInjection' 4' 4);  				keyInjection[8] = desc.OpCodeIndex;  				MutationHelper.InjectKeys(injectedMethod' Enumerable.Range(0' 9).ToArray()' keyInjection);    				// Encoding  				MutationHelper.ReplacePlaceholder(injectedMethod' arg => { return encoding.EmitDecode(injectedMethod' ctx' arg); });  				desc.Encoding = encoding;    				initDescs[index] = desc;  			}
Magic Number,Confuser.Protections.ReferenceProxy,StrongMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\ReferenceProxy\StrongMode.cs,GetInitMethod,The following statement contains a magic number: if (initDescs[index] == null) {  				TypeDef rtType = ctx.Context.Registry.GetService<IRuntimeService>().GetRuntimeType("Confuser.Runtime.RefProxyStrong");  				MethodDef injectedMethod = InjectHelper.Inject(rtType.FindMethod("Initialize")' ctx.Module);  				ctx.Module.GlobalType.Methods.Add(injectedMethod);    				injectedMethod.Access = MethodAttributes.PrivateScope;  				injectedMethod.Name = ctx.Name.RandomName();  				ctx.Name.SetCanRename(injectedMethod' false);  				ctx.Marker.Mark(injectedMethod' ctx.Protection);    				var desc = new InitMethodDesc { Method = injectedMethod };    				// Field name has five bytes' each bytes has different order & meaning  				int[] order = Enumerable.Range(0' 5).ToArray();  				ctx.Random.Shuffle(order);  				desc.OpCodeIndex = order[4];    				desc.TokenNameOrder = new int[4];  				Array.Copy(order' 0' desc.TokenNameOrder' 0' 4);  				desc.TokenByteOrder = Enumerable.Range(0' 4).Select(x => x * 8).ToArray();  				ctx.Random.Shuffle(desc.TokenByteOrder);    				var keyInjection = new int[9];  				Array.Copy(desc.TokenNameOrder' 0' keyInjection' 0' 4);  				Array.Copy(desc.TokenByteOrder' 0' keyInjection' 4' 4);  				keyInjection[8] = desc.OpCodeIndex;  				MutationHelper.InjectKeys(injectedMethod' Enumerable.Range(0' 9).ToArray()' keyInjection);    				// Encoding  				MutationHelper.ReplacePlaceholder(injectedMethod' arg => { return encoding.EmitDecode(injectedMethod' ctx' arg); });  				desc.Encoding = encoding;    				initDescs[index] = desc;  			}
Magic Number,Confuser.Protections.ReferenceProxy,StrongMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\ReferenceProxy\StrongMode.cs,GetInitMethod,The following statement contains a magic number: if (initDescs[index] == null) {  				TypeDef rtType = ctx.Context.Registry.GetService<IRuntimeService>().GetRuntimeType("Confuser.Runtime.RefProxyStrong");  				MethodDef injectedMethod = InjectHelper.Inject(rtType.FindMethod("Initialize")' ctx.Module);  				ctx.Module.GlobalType.Methods.Add(injectedMethod);    				injectedMethod.Access = MethodAttributes.PrivateScope;  				injectedMethod.Name = ctx.Name.RandomName();  				ctx.Name.SetCanRename(injectedMethod' false);  				ctx.Marker.Mark(injectedMethod' ctx.Protection);    				var desc = new InitMethodDesc { Method = injectedMethod };    				// Field name has five bytes' each bytes has different order & meaning  				int[] order = Enumerable.Range(0' 5).ToArray();  				ctx.Random.Shuffle(order);  				desc.OpCodeIndex = order[4];    				desc.TokenNameOrder = new int[4];  				Array.Copy(order' 0' desc.TokenNameOrder' 0' 4);  				desc.TokenByteOrder = Enumerable.Range(0' 4).Select(x => x * 8).ToArray();  				ctx.Random.Shuffle(desc.TokenByteOrder);    				var keyInjection = new int[9];  				Array.Copy(desc.TokenNameOrder' 0' keyInjection' 0' 4);  				Array.Copy(desc.TokenByteOrder' 0' keyInjection' 4' 4);  				keyInjection[8] = desc.OpCodeIndex;  				MutationHelper.InjectKeys(injectedMethod' Enumerable.Range(0' 9).ToArray()' keyInjection);    				// Encoding  				MutationHelper.ReplacePlaceholder(injectedMethod' arg => { return encoding.EmitDecode(injectedMethod' ctx' arg); });  				desc.Encoding = encoding;    				initDescs[index] = desc;  			}
Magic Number,Confuser.Protections.ReferenceProxy,StrongMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\ReferenceProxy\StrongMode.cs,GetInitMethod,The following statement contains a magic number: if (initDescs[index] == null) {  				TypeDef rtType = ctx.Context.Registry.GetService<IRuntimeService>().GetRuntimeType("Confuser.Runtime.RefProxyStrong");  				MethodDef injectedMethod = InjectHelper.Inject(rtType.FindMethod("Initialize")' ctx.Module);  				ctx.Module.GlobalType.Methods.Add(injectedMethod);    				injectedMethod.Access = MethodAttributes.PrivateScope;  				injectedMethod.Name = ctx.Name.RandomName();  				ctx.Name.SetCanRename(injectedMethod' false);  				ctx.Marker.Mark(injectedMethod' ctx.Protection);    				var desc = new InitMethodDesc { Method = injectedMethod };    				// Field name has five bytes' each bytes has different order & meaning  				int[] order = Enumerable.Range(0' 5).ToArray();  				ctx.Random.Shuffle(order);  				desc.OpCodeIndex = order[4];    				desc.TokenNameOrder = new int[4];  				Array.Copy(order' 0' desc.TokenNameOrder' 0' 4);  				desc.TokenByteOrder = Enumerable.Range(0' 4).Select(x => x * 8).ToArray();  				ctx.Random.Shuffle(desc.TokenByteOrder);    				var keyInjection = new int[9];  				Array.Copy(desc.TokenNameOrder' 0' keyInjection' 0' 4);  				Array.Copy(desc.TokenByteOrder' 0' keyInjection' 4' 4);  				keyInjection[8] = desc.OpCodeIndex;  				MutationHelper.InjectKeys(injectedMethod' Enumerable.Range(0' 9).ToArray()' keyInjection);    				// Encoding  				MutationHelper.ReplacePlaceholder(injectedMethod' arg => { return encoding.EmitDecode(injectedMethod' ctx' arg); });  				desc.Encoding = encoding;    				initDescs[index] = desc;  			}
Magic Number,Confuser.Protections.ReferenceProxy,StrongMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\ReferenceProxy\StrongMode.cs,GetInitMethod,The following statement contains a magic number: if (initDescs[index] == null) {  				TypeDef rtType = ctx.Context.Registry.GetService<IRuntimeService>().GetRuntimeType("Confuser.Runtime.RefProxyStrong");  				MethodDef injectedMethod = InjectHelper.Inject(rtType.FindMethod("Initialize")' ctx.Module);  				ctx.Module.GlobalType.Methods.Add(injectedMethod);    				injectedMethod.Access = MethodAttributes.PrivateScope;  				injectedMethod.Name = ctx.Name.RandomName();  				ctx.Name.SetCanRename(injectedMethod' false);  				ctx.Marker.Mark(injectedMethod' ctx.Protection);    				var desc = new InitMethodDesc { Method = injectedMethod };    				// Field name has five bytes' each bytes has different order & meaning  				int[] order = Enumerable.Range(0' 5).ToArray();  				ctx.Random.Shuffle(order);  				desc.OpCodeIndex = order[4];    				desc.TokenNameOrder = new int[4];  				Array.Copy(order' 0' desc.TokenNameOrder' 0' 4);  				desc.TokenByteOrder = Enumerable.Range(0' 4).Select(x => x * 8).ToArray();  				ctx.Random.Shuffle(desc.TokenByteOrder);    				var keyInjection = new int[9];  				Array.Copy(desc.TokenNameOrder' 0' keyInjection' 0' 4);  				Array.Copy(desc.TokenByteOrder' 0' keyInjection' 4' 4);  				keyInjection[8] = desc.OpCodeIndex;  				MutationHelper.InjectKeys(injectedMethod' Enumerable.Range(0' 9).ToArray()' keyInjection);    				// Encoding  				MutationHelper.ReplacePlaceholder(injectedMethod' arg => { return encoding.EmitDecode(injectedMethod' ctx' arg); });  				desc.Encoding = encoding;    				initDescs[index] = desc;  			}
Magic Number,Confuser.Protections.ReferenceProxy,StrongMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\ReferenceProxy\StrongMode.cs,EncodeField,The following statement contains a magic number: if (e.WriterEvent == ModuleWriterEvent.MDMemberDefRidsAllocated && keyAttrs != null) {  				Dictionary<TypeDef' Func<int' int>> keyFuncs = keyAttrs  					.Where(entry => entry != null)  					.ToDictionary(entry => entry.Item1' entry => entry.Item2);  				foreach (FieldDesc desc in fieldDescs) {  					uint token = writer.MetaData.GetToken(desc.Method).Raw;  					uint key = encodeCtx.Random.NextUInt32() | 1;    					// CA  					CustomAttribute ca = desc.Field.CustomAttributes[0];  					int encodedKey = keyFuncs[(TypeDef)ca.AttributeType]((int)MathsUtils.modInv(key));  					ca.ConstructorArguments.Add(new CAArgument(encodeCtx.Module.CorLibTypes.Int32' encodedKey));  					token *= key;    					// Encoding  					token = (uint)desc.InitDesc.Encoding.Encode(desc.InitDesc.Method' encodeCtx' (int)token);    					// Field name  					var name = new char[5];  					name[desc.InitDesc.OpCodeIndex] = (char)((byte)desc.OpCode ^ desc.OpKey);    					byte[] nameKey = encodeCtx.Random.NextBytes(4);  					uint encodedNameKey = 0;  					for (int i = 0; i < 4; i++) {  						// No zero bytes  						while (nameKey[i] == 0)  							nameKey[i] = encodeCtx.Random.NextByte();  						name[desc.InitDesc.TokenNameOrder[i]] = (char)nameKey[i];  						encodedNameKey |= (uint)nameKey[i] << desc.InitDesc.TokenByteOrder[i];  					}  					desc.Field.Name = new string(name);    					// Field sig  					FieldSig sig = desc.Field.FieldSig;  					uint encodedToken = (token - writer.MetaData.GetToken(((CModOptSig)sig.Type).Modifier).Raw) ^ encodedNameKey;      					var extra = new byte[8];  					extra[0] = 0xc0;  					extra[3] = (byte)(encodedToken >> desc.InitDesc.TokenByteOrder[3]);  					extra[4] = 0xc0;  					extra[5] = (byte)(encodedToken >> desc.InitDesc.TokenByteOrder[2]);  					extra[6] = (byte)(encodedToken >> desc.InitDesc.TokenByteOrder[1]);  					extra[7] = (byte)(encodedToken >> desc.InitDesc.TokenByteOrder[0]);  					sig.ExtraData = extra;  				}  			}
Magic Number,Confuser.Protections.ReferenceProxy,StrongMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\ReferenceProxy\StrongMode.cs,EncodeField,The following statement contains a magic number: if (e.WriterEvent == ModuleWriterEvent.MDMemberDefRidsAllocated && keyAttrs != null) {  				Dictionary<TypeDef' Func<int' int>> keyFuncs = keyAttrs  					.Where(entry => entry != null)  					.ToDictionary(entry => entry.Item1' entry => entry.Item2);  				foreach (FieldDesc desc in fieldDescs) {  					uint token = writer.MetaData.GetToken(desc.Method).Raw;  					uint key = encodeCtx.Random.NextUInt32() | 1;    					// CA  					CustomAttribute ca = desc.Field.CustomAttributes[0];  					int encodedKey = keyFuncs[(TypeDef)ca.AttributeType]((int)MathsUtils.modInv(key));  					ca.ConstructorArguments.Add(new CAArgument(encodeCtx.Module.CorLibTypes.Int32' encodedKey));  					token *= key;    					// Encoding  					token = (uint)desc.InitDesc.Encoding.Encode(desc.InitDesc.Method' encodeCtx' (int)token);    					// Field name  					var name = new char[5];  					name[desc.InitDesc.OpCodeIndex] = (char)((byte)desc.OpCode ^ desc.OpKey);    					byte[] nameKey = encodeCtx.Random.NextBytes(4);  					uint encodedNameKey = 0;  					for (int i = 0; i < 4; i++) {  						// No zero bytes  						while (nameKey[i] == 0)  							nameKey[i] = encodeCtx.Random.NextByte();  						name[desc.InitDesc.TokenNameOrder[i]] = (char)nameKey[i];  						encodedNameKey |= (uint)nameKey[i] << desc.InitDesc.TokenByteOrder[i];  					}  					desc.Field.Name = new string(name);    					// Field sig  					FieldSig sig = desc.Field.FieldSig;  					uint encodedToken = (token - writer.MetaData.GetToken(((CModOptSig)sig.Type).Modifier).Raw) ^ encodedNameKey;      					var extra = new byte[8];  					extra[0] = 0xc0;  					extra[3] = (byte)(encodedToken >> desc.InitDesc.TokenByteOrder[3]);  					extra[4] = 0xc0;  					extra[5] = (byte)(encodedToken >> desc.InitDesc.TokenByteOrder[2]);  					extra[6] = (byte)(encodedToken >> desc.InitDesc.TokenByteOrder[1]);  					extra[7] = (byte)(encodedToken >> desc.InitDesc.TokenByteOrder[0]);  					sig.ExtraData = extra;  				}  			}
Magic Number,Confuser.Protections.ReferenceProxy,StrongMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\ReferenceProxy\StrongMode.cs,EncodeField,The following statement contains a magic number: if (e.WriterEvent == ModuleWriterEvent.MDMemberDefRidsAllocated && keyAttrs != null) {  				Dictionary<TypeDef' Func<int' int>> keyFuncs = keyAttrs  					.Where(entry => entry != null)  					.ToDictionary(entry => entry.Item1' entry => entry.Item2);  				foreach (FieldDesc desc in fieldDescs) {  					uint token = writer.MetaData.GetToken(desc.Method).Raw;  					uint key = encodeCtx.Random.NextUInt32() | 1;    					// CA  					CustomAttribute ca = desc.Field.CustomAttributes[0];  					int encodedKey = keyFuncs[(TypeDef)ca.AttributeType]((int)MathsUtils.modInv(key));  					ca.ConstructorArguments.Add(new CAArgument(encodeCtx.Module.CorLibTypes.Int32' encodedKey));  					token *= key;    					// Encoding  					token = (uint)desc.InitDesc.Encoding.Encode(desc.InitDesc.Method' encodeCtx' (int)token);    					// Field name  					var name = new char[5];  					name[desc.InitDesc.OpCodeIndex] = (char)((byte)desc.OpCode ^ desc.OpKey);    					byte[] nameKey = encodeCtx.Random.NextBytes(4);  					uint encodedNameKey = 0;  					for (int i = 0; i < 4; i++) {  						// No zero bytes  						while (nameKey[i] == 0)  							nameKey[i] = encodeCtx.Random.NextByte();  						name[desc.InitDesc.TokenNameOrder[i]] = (char)nameKey[i];  						encodedNameKey |= (uint)nameKey[i] << desc.InitDesc.TokenByteOrder[i];  					}  					desc.Field.Name = new string(name);    					// Field sig  					FieldSig sig = desc.Field.FieldSig;  					uint encodedToken = (token - writer.MetaData.GetToken(((CModOptSig)sig.Type).Modifier).Raw) ^ encodedNameKey;      					var extra = new byte[8];  					extra[0] = 0xc0;  					extra[3] = (byte)(encodedToken >> desc.InitDesc.TokenByteOrder[3]);  					extra[4] = 0xc0;  					extra[5] = (byte)(encodedToken >> desc.InitDesc.TokenByteOrder[2]);  					extra[6] = (byte)(encodedToken >> desc.InitDesc.TokenByteOrder[1]);  					extra[7] = (byte)(encodedToken >> desc.InitDesc.TokenByteOrder[0]);  					sig.ExtraData = extra;  				}  			}
Magic Number,Confuser.Protections.ReferenceProxy,StrongMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\ReferenceProxy\StrongMode.cs,EncodeField,The following statement contains a magic number: if (e.WriterEvent == ModuleWriterEvent.MDMemberDefRidsAllocated && keyAttrs != null) {  				Dictionary<TypeDef' Func<int' int>> keyFuncs = keyAttrs  					.Where(entry => entry != null)  					.ToDictionary(entry => entry.Item1' entry => entry.Item2);  				foreach (FieldDesc desc in fieldDescs) {  					uint token = writer.MetaData.GetToken(desc.Method).Raw;  					uint key = encodeCtx.Random.NextUInt32() | 1;    					// CA  					CustomAttribute ca = desc.Field.CustomAttributes[0];  					int encodedKey = keyFuncs[(TypeDef)ca.AttributeType]((int)MathsUtils.modInv(key));  					ca.ConstructorArguments.Add(new CAArgument(encodeCtx.Module.CorLibTypes.Int32' encodedKey));  					token *= key;    					// Encoding  					token = (uint)desc.InitDesc.Encoding.Encode(desc.InitDesc.Method' encodeCtx' (int)token);    					// Field name  					var name = new char[5];  					name[desc.InitDesc.OpCodeIndex] = (char)((byte)desc.OpCode ^ desc.OpKey);    					byte[] nameKey = encodeCtx.Random.NextBytes(4);  					uint encodedNameKey = 0;  					for (int i = 0; i < 4; i++) {  						// No zero bytes  						while (nameKey[i] == 0)  							nameKey[i] = encodeCtx.Random.NextByte();  						name[desc.InitDesc.TokenNameOrder[i]] = (char)nameKey[i];  						encodedNameKey |= (uint)nameKey[i] << desc.InitDesc.TokenByteOrder[i];  					}  					desc.Field.Name = new string(name);    					// Field sig  					FieldSig sig = desc.Field.FieldSig;  					uint encodedToken = (token - writer.MetaData.GetToken(((CModOptSig)sig.Type).Modifier).Raw) ^ encodedNameKey;      					var extra = new byte[8];  					extra[0] = 0xc0;  					extra[3] = (byte)(encodedToken >> desc.InitDesc.TokenByteOrder[3]);  					extra[4] = 0xc0;  					extra[5] = (byte)(encodedToken >> desc.InitDesc.TokenByteOrder[2]);  					extra[6] = (byte)(encodedToken >> desc.InitDesc.TokenByteOrder[1]);  					extra[7] = (byte)(encodedToken >> desc.InitDesc.TokenByteOrder[0]);  					sig.ExtraData = extra;  				}  			}
Magic Number,Confuser.Protections.ReferenceProxy,StrongMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\ReferenceProxy\StrongMode.cs,EncodeField,The following statement contains a magic number: if (e.WriterEvent == ModuleWriterEvent.MDMemberDefRidsAllocated && keyAttrs != null) {  				Dictionary<TypeDef' Func<int' int>> keyFuncs = keyAttrs  					.Where(entry => entry != null)  					.ToDictionary(entry => entry.Item1' entry => entry.Item2);  				foreach (FieldDesc desc in fieldDescs) {  					uint token = writer.MetaData.GetToken(desc.Method).Raw;  					uint key = encodeCtx.Random.NextUInt32() | 1;    					// CA  					CustomAttribute ca = desc.Field.CustomAttributes[0];  					int encodedKey = keyFuncs[(TypeDef)ca.AttributeType]((int)MathsUtils.modInv(key));  					ca.ConstructorArguments.Add(new CAArgument(encodeCtx.Module.CorLibTypes.Int32' encodedKey));  					token *= key;    					// Encoding  					token = (uint)desc.InitDesc.Encoding.Encode(desc.InitDesc.Method' encodeCtx' (int)token);    					// Field name  					var name = new char[5];  					name[desc.InitDesc.OpCodeIndex] = (char)((byte)desc.OpCode ^ desc.OpKey);    					byte[] nameKey = encodeCtx.Random.NextBytes(4);  					uint encodedNameKey = 0;  					for (int i = 0; i < 4; i++) {  						// No zero bytes  						while (nameKey[i] == 0)  							nameKey[i] = encodeCtx.Random.NextByte();  						name[desc.InitDesc.TokenNameOrder[i]] = (char)nameKey[i];  						encodedNameKey |= (uint)nameKey[i] << desc.InitDesc.TokenByteOrder[i];  					}  					desc.Field.Name = new string(name);    					// Field sig  					FieldSig sig = desc.Field.FieldSig;  					uint encodedToken = (token - writer.MetaData.GetToken(((CModOptSig)sig.Type).Modifier).Raw) ^ encodedNameKey;      					var extra = new byte[8];  					extra[0] = 0xc0;  					extra[3] = (byte)(encodedToken >> desc.InitDesc.TokenByteOrder[3]);  					extra[4] = 0xc0;  					extra[5] = (byte)(encodedToken >> desc.InitDesc.TokenByteOrder[2]);  					extra[6] = (byte)(encodedToken >> desc.InitDesc.TokenByteOrder[1]);  					extra[7] = (byte)(encodedToken >> desc.InitDesc.TokenByteOrder[0]);  					sig.ExtraData = extra;  				}  			}
Magic Number,Confuser.Protections.ReferenceProxy,StrongMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\ReferenceProxy\StrongMode.cs,EncodeField,The following statement contains a magic number: if (e.WriterEvent == ModuleWriterEvent.MDMemberDefRidsAllocated && keyAttrs != null) {  				Dictionary<TypeDef' Func<int' int>> keyFuncs = keyAttrs  					.Where(entry => entry != null)  					.ToDictionary(entry => entry.Item1' entry => entry.Item2);  				foreach (FieldDesc desc in fieldDescs) {  					uint token = writer.MetaData.GetToken(desc.Method).Raw;  					uint key = encodeCtx.Random.NextUInt32() | 1;    					// CA  					CustomAttribute ca = desc.Field.CustomAttributes[0];  					int encodedKey = keyFuncs[(TypeDef)ca.AttributeType]((int)MathsUtils.modInv(key));  					ca.ConstructorArguments.Add(new CAArgument(encodeCtx.Module.CorLibTypes.Int32' encodedKey));  					token *= key;    					// Encoding  					token = (uint)desc.InitDesc.Encoding.Encode(desc.InitDesc.Method' encodeCtx' (int)token);    					// Field name  					var name = new char[5];  					name[desc.InitDesc.OpCodeIndex] = (char)((byte)desc.OpCode ^ desc.OpKey);    					byte[] nameKey = encodeCtx.Random.NextBytes(4);  					uint encodedNameKey = 0;  					for (int i = 0; i < 4; i++) {  						// No zero bytes  						while (nameKey[i] == 0)  							nameKey[i] = encodeCtx.Random.NextByte();  						name[desc.InitDesc.TokenNameOrder[i]] = (char)nameKey[i];  						encodedNameKey |= (uint)nameKey[i] << desc.InitDesc.TokenByteOrder[i];  					}  					desc.Field.Name = new string(name);    					// Field sig  					FieldSig sig = desc.Field.FieldSig;  					uint encodedToken = (token - writer.MetaData.GetToken(((CModOptSig)sig.Type).Modifier).Raw) ^ encodedNameKey;      					var extra = new byte[8];  					extra[0] = 0xc0;  					extra[3] = (byte)(encodedToken >> desc.InitDesc.TokenByteOrder[3]);  					extra[4] = 0xc0;  					extra[5] = (byte)(encodedToken >> desc.InitDesc.TokenByteOrder[2]);  					extra[6] = (byte)(encodedToken >> desc.InitDesc.TokenByteOrder[1]);  					extra[7] = (byte)(encodedToken >> desc.InitDesc.TokenByteOrder[0]);  					sig.ExtraData = extra;  				}  			}
Magic Number,Confuser.Protections.ReferenceProxy,StrongMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\ReferenceProxy\StrongMode.cs,EncodeField,The following statement contains a magic number: if (e.WriterEvent == ModuleWriterEvent.MDMemberDefRidsAllocated && keyAttrs != null) {  				Dictionary<TypeDef' Func<int' int>> keyFuncs = keyAttrs  					.Where(entry => entry != null)  					.ToDictionary(entry => entry.Item1' entry => entry.Item2);  				foreach (FieldDesc desc in fieldDescs) {  					uint token = writer.MetaData.GetToken(desc.Method).Raw;  					uint key = encodeCtx.Random.NextUInt32() | 1;    					// CA  					CustomAttribute ca = desc.Field.CustomAttributes[0];  					int encodedKey = keyFuncs[(TypeDef)ca.AttributeType]((int)MathsUtils.modInv(key));  					ca.ConstructorArguments.Add(new CAArgument(encodeCtx.Module.CorLibTypes.Int32' encodedKey));  					token *= key;    					// Encoding  					token = (uint)desc.InitDesc.Encoding.Encode(desc.InitDesc.Method' encodeCtx' (int)token);    					// Field name  					var name = new char[5];  					name[desc.InitDesc.OpCodeIndex] = (char)((byte)desc.OpCode ^ desc.OpKey);    					byte[] nameKey = encodeCtx.Random.NextBytes(4);  					uint encodedNameKey = 0;  					for (int i = 0; i < 4; i++) {  						// No zero bytes  						while (nameKey[i] == 0)  							nameKey[i] = encodeCtx.Random.NextByte();  						name[desc.InitDesc.TokenNameOrder[i]] = (char)nameKey[i];  						encodedNameKey |= (uint)nameKey[i] << desc.InitDesc.TokenByteOrder[i];  					}  					desc.Field.Name = new string(name);    					// Field sig  					FieldSig sig = desc.Field.FieldSig;  					uint encodedToken = (token - writer.MetaData.GetToken(((CModOptSig)sig.Type).Modifier).Raw) ^ encodedNameKey;      					var extra = new byte[8];  					extra[0] = 0xc0;  					extra[3] = (byte)(encodedToken >> desc.InitDesc.TokenByteOrder[3]);  					extra[4] = 0xc0;  					extra[5] = (byte)(encodedToken >> desc.InitDesc.TokenByteOrder[2]);  					extra[6] = (byte)(encodedToken >> desc.InitDesc.TokenByteOrder[1]);  					extra[7] = (byte)(encodedToken >> desc.InitDesc.TokenByteOrder[0]);  					sig.ExtraData = extra;  				}  			}
Magic Number,Confuser.Protections.ReferenceProxy,StrongMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\ReferenceProxy\StrongMode.cs,EncodeField,The following statement contains a magic number: if (e.WriterEvent == ModuleWriterEvent.MDMemberDefRidsAllocated && keyAttrs != null) {  				Dictionary<TypeDef' Func<int' int>> keyFuncs = keyAttrs  					.Where(entry => entry != null)  					.ToDictionary(entry => entry.Item1' entry => entry.Item2);  				foreach (FieldDesc desc in fieldDescs) {  					uint token = writer.MetaData.GetToken(desc.Method).Raw;  					uint key = encodeCtx.Random.NextUInt32() | 1;    					// CA  					CustomAttribute ca = desc.Field.CustomAttributes[0];  					int encodedKey = keyFuncs[(TypeDef)ca.AttributeType]((int)MathsUtils.modInv(key));  					ca.ConstructorArguments.Add(new CAArgument(encodeCtx.Module.CorLibTypes.Int32' encodedKey));  					token *= key;    					// Encoding  					token = (uint)desc.InitDesc.Encoding.Encode(desc.InitDesc.Method' encodeCtx' (int)token);    					// Field name  					var name = new char[5];  					name[desc.InitDesc.OpCodeIndex] = (char)((byte)desc.OpCode ^ desc.OpKey);    					byte[] nameKey = encodeCtx.Random.NextBytes(4);  					uint encodedNameKey = 0;  					for (int i = 0; i < 4; i++) {  						// No zero bytes  						while (nameKey[i] == 0)  							nameKey[i] = encodeCtx.Random.NextByte();  						name[desc.InitDesc.TokenNameOrder[i]] = (char)nameKey[i];  						encodedNameKey |= (uint)nameKey[i] << desc.InitDesc.TokenByteOrder[i];  					}  					desc.Field.Name = new string(name);    					// Field sig  					FieldSig sig = desc.Field.FieldSig;  					uint encodedToken = (token - writer.MetaData.GetToken(((CModOptSig)sig.Type).Modifier).Raw) ^ encodedNameKey;      					var extra = new byte[8];  					extra[0] = 0xc0;  					extra[3] = (byte)(encodedToken >> desc.InitDesc.TokenByteOrder[3]);  					extra[4] = 0xc0;  					extra[5] = (byte)(encodedToken >> desc.InitDesc.TokenByteOrder[2]);  					extra[6] = (byte)(encodedToken >> desc.InitDesc.TokenByteOrder[1]);  					extra[7] = (byte)(encodedToken >> desc.InitDesc.TokenByteOrder[0]);  					sig.ExtraData = extra;  				}  			}
Magic Number,Confuser.Protections.ReferenceProxy,StrongMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\ReferenceProxy\StrongMode.cs,EncodeField,The following statement contains a magic number: if (e.WriterEvent == ModuleWriterEvent.MDMemberDefRidsAllocated && keyAttrs != null) {  				Dictionary<TypeDef' Func<int' int>> keyFuncs = keyAttrs  					.Where(entry => entry != null)  					.ToDictionary(entry => entry.Item1' entry => entry.Item2);  				foreach (FieldDesc desc in fieldDescs) {  					uint token = writer.MetaData.GetToken(desc.Method).Raw;  					uint key = encodeCtx.Random.NextUInt32() | 1;    					// CA  					CustomAttribute ca = desc.Field.CustomAttributes[0];  					int encodedKey = keyFuncs[(TypeDef)ca.AttributeType]((int)MathsUtils.modInv(key));  					ca.ConstructorArguments.Add(new CAArgument(encodeCtx.Module.CorLibTypes.Int32' encodedKey));  					token *= key;    					// Encoding  					token = (uint)desc.InitDesc.Encoding.Encode(desc.InitDesc.Method' encodeCtx' (int)token);    					// Field name  					var name = new char[5];  					name[desc.InitDesc.OpCodeIndex] = (char)((byte)desc.OpCode ^ desc.OpKey);    					byte[] nameKey = encodeCtx.Random.NextBytes(4);  					uint encodedNameKey = 0;  					for (int i = 0; i < 4; i++) {  						// No zero bytes  						while (nameKey[i] == 0)  							nameKey[i] = encodeCtx.Random.NextByte();  						name[desc.InitDesc.TokenNameOrder[i]] = (char)nameKey[i];  						encodedNameKey |= (uint)nameKey[i] << desc.InitDesc.TokenByteOrder[i];  					}  					desc.Field.Name = new string(name);    					// Field sig  					FieldSig sig = desc.Field.FieldSig;  					uint encodedToken = (token - writer.MetaData.GetToken(((CModOptSig)sig.Type).Modifier).Raw) ^ encodedNameKey;      					var extra = new byte[8];  					extra[0] = 0xc0;  					extra[3] = (byte)(encodedToken >> desc.InitDesc.TokenByteOrder[3]);  					extra[4] = 0xc0;  					extra[5] = (byte)(encodedToken >> desc.InitDesc.TokenByteOrder[2]);  					extra[6] = (byte)(encodedToken >> desc.InitDesc.TokenByteOrder[1]);  					extra[7] = (byte)(encodedToken >> desc.InitDesc.TokenByteOrder[0]);  					sig.ExtraData = extra;  				}  			}
Magic Number,Confuser.Protections.ReferenceProxy,StrongMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\ReferenceProxy\StrongMode.cs,EncodeField,The following statement contains a magic number: if (e.WriterEvent == ModuleWriterEvent.MDMemberDefRidsAllocated && keyAttrs != null) {  				Dictionary<TypeDef' Func<int' int>> keyFuncs = keyAttrs  					.Where(entry => entry != null)  					.ToDictionary(entry => entry.Item1' entry => entry.Item2);  				foreach (FieldDesc desc in fieldDescs) {  					uint token = writer.MetaData.GetToken(desc.Method).Raw;  					uint key = encodeCtx.Random.NextUInt32() | 1;    					// CA  					CustomAttribute ca = desc.Field.CustomAttributes[0];  					int encodedKey = keyFuncs[(TypeDef)ca.AttributeType]((int)MathsUtils.modInv(key));  					ca.ConstructorArguments.Add(new CAArgument(encodeCtx.Module.CorLibTypes.Int32' encodedKey));  					token *= key;    					// Encoding  					token = (uint)desc.InitDesc.Encoding.Encode(desc.InitDesc.Method' encodeCtx' (int)token);    					// Field name  					var name = new char[5];  					name[desc.InitDesc.OpCodeIndex] = (char)((byte)desc.OpCode ^ desc.OpKey);    					byte[] nameKey = encodeCtx.Random.NextBytes(4);  					uint encodedNameKey = 0;  					for (int i = 0; i < 4; i++) {  						// No zero bytes  						while (nameKey[i] == 0)  							nameKey[i] = encodeCtx.Random.NextByte();  						name[desc.InitDesc.TokenNameOrder[i]] = (char)nameKey[i];  						encodedNameKey |= (uint)nameKey[i] << desc.InitDesc.TokenByteOrder[i];  					}  					desc.Field.Name = new string(name);    					// Field sig  					FieldSig sig = desc.Field.FieldSig;  					uint encodedToken = (token - writer.MetaData.GetToken(((CModOptSig)sig.Type).Modifier).Raw) ^ encodedNameKey;      					var extra = new byte[8];  					extra[0] = 0xc0;  					extra[3] = (byte)(encodedToken >> desc.InitDesc.TokenByteOrder[3]);  					extra[4] = 0xc0;  					extra[5] = (byte)(encodedToken >> desc.InitDesc.TokenByteOrder[2]);  					extra[6] = (byte)(encodedToken >> desc.InitDesc.TokenByteOrder[1]);  					extra[7] = (byte)(encodedToken >> desc.InitDesc.TokenByteOrder[0]);  					sig.ExtraData = extra;  				}  			}
Magic Number,Confuser.Protections.ReferenceProxy,StrongMode,C:\repos\yck1509_ConfuserEx\Confuser.Protections\ReferenceProxy\StrongMode.cs,EncodeField,The following statement contains a magic number: if (e.WriterEvent == ModuleWriterEvent.MDMemberDefRidsAllocated && keyAttrs != null) {  				Dictionary<TypeDef' Func<int' int>> keyFuncs = keyAttrs  					.Where(entry => entry != null)  					.ToDictionary(entry => entry.Item1' entry => entry.Item2);  				foreach (FieldDesc desc in fieldDescs) {  					uint token = writer.MetaData.GetToken(desc.Method).Raw;  					uint key = encodeCtx.Random.NextUInt32() | 1;    					// CA  					CustomAttribute ca = desc.Field.CustomAttributes[0];  					int encodedKey = keyFuncs[(TypeDef)ca.AttributeType]((int)MathsUtils.modInv(key));  					ca.ConstructorArguments.Add(new CAArgument(encodeCtx.Module.CorLibTypes.Int32' encodedKey));  					token *= key;    					// Encoding  					token = (uint)desc.InitDesc.Encoding.Encode(desc.InitDesc.Method' encodeCtx' (int)token);    					// Field name  					var name = new char[5];  					name[desc.InitDesc.OpCodeIndex] = (char)((byte)desc.OpCode ^ desc.OpKey);    					byte[] nameKey = encodeCtx.Random.NextBytes(4);  					uint encodedNameKey = 0;  					for (int i = 0; i < 4; i++) {  						// No zero bytes  						while (nameKey[i] == 0)  							nameKey[i] = encodeCtx.Random.NextByte();  						name[desc.InitDesc.TokenNameOrder[i]] = (char)nameKey[i];  						encodedNameKey |= (uint)nameKey[i] << desc.InitDesc.TokenByteOrder[i];  					}  					desc.Field.Name = new string(name);    					// Field sig  					FieldSig sig = desc.Field.FieldSig;  					uint encodedToken = (token - writer.MetaData.GetToken(((CModOptSig)sig.Type).Modifier).Raw) ^ encodedNameKey;      					var extra = new byte[8];  					extra[0] = 0xc0;  					extra[3] = (byte)(encodedToken >> desc.InitDesc.TokenByteOrder[3]);  					extra[4] = 0xc0;  					extra[5] = (byte)(encodedToken >> desc.InitDesc.TokenByteOrder[2]);  					extra[6] = (byte)(encodedToken >> desc.InitDesc.TokenByteOrder[1]);  					extra[7] = (byte)(encodedToken >> desc.InitDesc.TokenByteOrder[0]);  					sig.ExtraData = extra;  				}  			}
Magic Number,Confuser.Protections.ReferenceProxy,ReferenceProxyPhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\ReferenceProxy\ReferenceProxyPhase.cs,ParseParameters,The following statement contains a magic number: ret.Depth = parameters.GetParameter(context' method' "depth"' 3);
Magic Number,Confuser.Protections.ReferenceProxy,ReferenceProxyPhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\ReferenceProxy\ReferenceProxyPhase.cs,ParseParameters,The following statement contains a magic number: ret.Depth = parameters.GetParameter(context' module' "depth"' 3);
Magic Number,Confuser.Protections.Resources,InjectPhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Resources\InjectPhase.cs,MutateInitializer,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  				Instruction instr = instrs[i];  				var method = instr.Operand as IMethod;  				if (instr.OpCode == OpCodes.Call) {  					if (method.DeclaringType.Name == "Mutation" &&  					    method.Name == "Crypt") {  						Instruction ldBlock = instrs[i - 2];  						Instruction ldKey = instrs[i - 1];  						Debug.Assert(ldBlock.OpCode == OpCodes.Ldloc && ldKey.OpCode == OpCodes.Ldloc);  						instrs.RemoveAt(i);  						instrs.RemoveAt(i - 1);  						instrs.RemoveAt(i - 2);  						instrs.InsertRange(i - 2' moduleCtx.ModeHandler.EmitDecrypt(moduleCtx.InitMethod' moduleCtx' (Local)ldBlock.Operand' (Local)ldKey.Operand));  					}  					else if (method.DeclaringType.Name == "Lzma" &&  					         method.Name == "Decompress") {  						instr.Operand = decomp;  					}  				}  			}
Magic Number,Confuser.Protections.Resources,InjectPhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Resources\InjectPhase.cs,MutateInitializer,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  				Instruction instr = instrs[i];  				var method = instr.Operand as IMethod;  				if (instr.OpCode == OpCodes.Call) {  					if (method.DeclaringType.Name == "Mutation" &&  					    method.Name == "Crypt") {  						Instruction ldBlock = instrs[i - 2];  						Instruction ldKey = instrs[i - 1];  						Debug.Assert(ldBlock.OpCode == OpCodes.Ldloc && ldKey.OpCode == OpCodes.Ldloc);  						instrs.RemoveAt(i);  						instrs.RemoveAt(i - 1);  						instrs.RemoveAt(i - 2);  						instrs.InsertRange(i - 2' moduleCtx.ModeHandler.EmitDecrypt(moduleCtx.InitMethod' moduleCtx' (Local)ldBlock.Operand' (Local)ldKey.Operand));  					}  					else if (method.DeclaringType.Name == "Lzma" &&  					         method.Name == "Decompress") {  						instr.Operand = decomp;  					}  				}  			}
Magic Number,Confuser.Protections.Resources,InjectPhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Resources\InjectPhase.cs,MutateInitializer,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  				Instruction instr = instrs[i];  				var method = instr.Operand as IMethod;  				if (instr.OpCode == OpCodes.Call) {  					if (method.DeclaringType.Name == "Mutation" &&  					    method.Name == "Crypt") {  						Instruction ldBlock = instrs[i - 2];  						Instruction ldKey = instrs[i - 1];  						Debug.Assert(ldBlock.OpCode == OpCodes.Ldloc && ldKey.OpCode == OpCodes.Ldloc);  						instrs.RemoveAt(i);  						instrs.RemoveAt(i - 1);  						instrs.RemoveAt(i - 2);  						instrs.InsertRange(i - 2' moduleCtx.ModeHandler.EmitDecrypt(moduleCtx.InitMethod' moduleCtx' (Local)ldBlock.Operand' (Local)ldKey.Operand));  					}  					else if (method.DeclaringType.Name == "Lzma" &&  					         method.Name == "Decompress") {  						instr.Operand = decomp;  					}  				}  			}
Magic Number,Confuser.Protections.Resources,MDPhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Resources\MDPhase.cs,OnWriterEvent,The following statement contains a magic number: if (e.WriterEvent == ModuleWriterEvent.MDBeginAddResources) {  				ctx.Context.CheckCancellation();  				ctx.Context.Logger.Debug("Encrypting resources...");  				bool hasPacker = ctx.Context.Packer != null;    				List<EmbeddedResource> resources = ctx.Module.Resources.OfType<EmbeddedResource>().ToList();  				if (!hasPacker)  					ctx.Module.Resources.RemoveWhere(res => res is EmbeddedResource);    				// move resources  				string asmName = ctx.Name.RandomName(RenameMode.Letters);  				PublicKey pubKey = null;  				if (writer.TheOptions.StrongNameKey != null)  					pubKey = PublicKeyBase.CreatePublicKey(writer.TheOptions.StrongNameKey.PublicKey);  				var assembly = new AssemblyDefUser(asmName' new Version(0' 0)' pubKey);  				assembly.Modules.Add(new ModuleDefUser(asmName + ".dll"));  				ModuleDef module = assembly.ManifestModule;  				assembly.ManifestModule.Kind = ModuleKind.Dll;  				var asmRef = new AssemblyRefUser(module.Assembly);  				if (!hasPacker) {  					foreach (EmbeddedResource res in resources) {  						res.Attributes = ManifestResourceAttributes.Public;  						module.Resources.Add(res);  						ctx.Module.Resources.Add(new AssemblyLinkedResource(res.Name' asmRef' res.Attributes));  					}  				}  				byte[] moduleBuff;  				using (var ms = new MemoryStream()) {  					module.Write(ms' new ModuleWriterOptions { StrongNameKey = writer.TheOptions.StrongNameKey });  					moduleBuff = ms.ToArray();  				}    				// compress  				moduleBuff = ctx.Context.Registry.GetService<ICompressionService>().Compress(  					moduleBuff'  					progress => ctx.Context.Logger.Progress((int)(progress * 10000)' 10000));  				ctx.Context.Logger.EndProgress();  				ctx.Context.CheckCancellation();    				uint compressedLen = (uint)(moduleBuff.Length + 3) / 4;  				compressedLen = (compressedLen + 0xfu) & ~0xfu;  				var compressedBuff = new uint[compressedLen];  				Buffer.BlockCopy(moduleBuff' 0' compressedBuff' 0' moduleBuff.Length);  				Debug.Assert(compressedLen % 0x10 == 0);    				// encrypt  				uint keySeed = ctx.Random.NextUInt32() | 0x10;  				var key = new uint[0x10];  				uint state = keySeed;  				for (int i = 0; i < 0x10; i++) {  					state ^= state >> 13;  					state ^= state << 25;  					state ^= state >> 27;  					key[i] = state;  				}    				var encryptedBuffer = new byte[compressedBuff.Length * 4];  				int buffIndex = 0;  				while (buffIndex < compressedBuff.Length) {  					uint[] enc = ctx.ModeHandler.Encrypt(compressedBuff' buffIndex' key);  					for (int j = 0; j < 0x10; j++)  						key[j] ^= compressedBuff[buffIndex + j];  					Buffer.BlockCopy(enc' 0' encryptedBuffer' buffIndex * 4' 0x40);  					buffIndex += 0x10;  				}  				Debug.Assert(buffIndex == compressedBuff.Length);  				var size = (uint)encryptedBuffer.Length;    				TablesHeap tblHeap = writer.MetaData.TablesHeap;  				tblHeap.ClassLayoutTable[writer.MetaData.GetClassLayoutRid(ctx.DataType)].ClassSize = size;  				tblHeap.FieldTable[writer.MetaData.GetRid(ctx.DataField)].Flags |= (ushort)FieldAttributes.HasFieldRVA;  				encryptedResource = writer.Constants.Add(new ByteArrayChunk(encryptedBuffer)' 8);    				// inject key values  				MutationHelper.InjectKeys(ctx.InitMethod'  				                          new[] { 0' 1 }'  				                          new[] { (int)(size / 4)' (int)(keySeed) });  			}  			else if (e.WriterEvent == ModuleWriterEvent.EndCalculateRvasAndFileOffsets) {  				TablesHeap tblHeap = writer.MetaData.TablesHeap;  				tblHeap.FieldRVATable[writer.MetaData.GetFieldRVARid(ctx.DataField)].RVA = (uint)encryptedResource.RVA;  			}
Magic Number,Confuser.Protections.Resources,MDPhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Resources\MDPhase.cs,OnWriterEvent,The following statement contains a magic number: if (e.WriterEvent == ModuleWriterEvent.MDBeginAddResources) {  				ctx.Context.CheckCancellation();  				ctx.Context.Logger.Debug("Encrypting resources...");  				bool hasPacker = ctx.Context.Packer != null;    				List<EmbeddedResource> resources = ctx.Module.Resources.OfType<EmbeddedResource>().ToList();  				if (!hasPacker)  					ctx.Module.Resources.RemoveWhere(res => res is EmbeddedResource);    				// move resources  				string asmName = ctx.Name.RandomName(RenameMode.Letters);  				PublicKey pubKey = null;  				if (writer.TheOptions.StrongNameKey != null)  					pubKey = PublicKeyBase.CreatePublicKey(writer.TheOptions.StrongNameKey.PublicKey);  				var assembly = new AssemblyDefUser(asmName' new Version(0' 0)' pubKey);  				assembly.Modules.Add(new ModuleDefUser(asmName + ".dll"));  				ModuleDef module = assembly.ManifestModule;  				assembly.ManifestModule.Kind = ModuleKind.Dll;  				var asmRef = new AssemblyRefUser(module.Assembly);  				if (!hasPacker) {  					foreach (EmbeddedResource res in resources) {  						res.Attributes = ManifestResourceAttributes.Public;  						module.Resources.Add(res);  						ctx.Module.Resources.Add(new AssemblyLinkedResource(res.Name' asmRef' res.Attributes));  					}  				}  				byte[] moduleBuff;  				using (var ms = new MemoryStream()) {  					module.Write(ms' new ModuleWriterOptions { StrongNameKey = writer.TheOptions.StrongNameKey });  					moduleBuff = ms.ToArray();  				}    				// compress  				moduleBuff = ctx.Context.Registry.GetService<ICompressionService>().Compress(  					moduleBuff'  					progress => ctx.Context.Logger.Progress((int)(progress * 10000)' 10000));  				ctx.Context.Logger.EndProgress();  				ctx.Context.CheckCancellation();    				uint compressedLen = (uint)(moduleBuff.Length + 3) / 4;  				compressedLen = (compressedLen + 0xfu) & ~0xfu;  				var compressedBuff = new uint[compressedLen];  				Buffer.BlockCopy(moduleBuff' 0' compressedBuff' 0' moduleBuff.Length);  				Debug.Assert(compressedLen % 0x10 == 0);    				// encrypt  				uint keySeed = ctx.Random.NextUInt32() | 0x10;  				var key = new uint[0x10];  				uint state = keySeed;  				for (int i = 0; i < 0x10; i++) {  					state ^= state >> 13;  					state ^= state << 25;  					state ^= state >> 27;  					key[i] = state;  				}    				var encryptedBuffer = new byte[compressedBuff.Length * 4];  				int buffIndex = 0;  				while (buffIndex < compressedBuff.Length) {  					uint[] enc = ctx.ModeHandler.Encrypt(compressedBuff' buffIndex' key);  					for (int j = 0; j < 0x10; j++)  						key[j] ^= compressedBuff[buffIndex + j];  					Buffer.BlockCopy(enc' 0' encryptedBuffer' buffIndex * 4' 0x40);  					buffIndex += 0x10;  				}  				Debug.Assert(buffIndex == compressedBuff.Length);  				var size = (uint)encryptedBuffer.Length;    				TablesHeap tblHeap = writer.MetaData.TablesHeap;  				tblHeap.ClassLayoutTable[writer.MetaData.GetClassLayoutRid(ctx.DataType)].ClassSize = size;  				tblHeap.FieldTable[writer.MetaData.GetRid(ctx.DataField)].Flags |= (ushort)FieldAttributes.HasFieldRVA;  				encryptedResource = writer.Constants.Add(new ByteArrayChunk(encryptedBuffer)' 8);    				// inject key values  				MutationHelper.InjectKeys(ctx.InitMethod'  				                          new[] { 0' 1 }'  				                          new[] { (int)(size / 4)' (int)(keySeed) });  			}  			else if (e.WriterEvent == ModuleWriterEvent.EndCalculateRvasAndFileOffsets) {  				TablesHeap tblHeap = writer.MetaData.TablesHeap;  				tblHeap.FieldRVATable[writer.MetaData.GetFieldRVARid(ctx.DataField)].RVA = (uint)encryptedResource.RVA;  			}
Magic Number,Confuser.Protections.Resources,MDPhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Resources\MDPhase.cs,OnWriterEvent,The following statement contains a magic number: if (e.WriterEvent == ModuleWriterEvent.MDBeginAddResources) {  				ctx.Context.CheckCancellation();  				ctx.Context.Logger.Debug("Encrypting resources...");  				bool hasPacker = ctx.Context.Packer != null;    				List<EmbeddedResource> resources = ctx.Module.Resources.OfType<EmbeddedResource>().ToList();  				if (!hasPacker)  					ctx.Module.Resources.RemoveWhere(res => res is EmbeddedResource);    				// move resources  				string asmName = ctx.Name.RandomName(RenameMode.Letters);  				PublicKey pubKey = null;  				if (writer.TheOptions.StrongNameKey != null)  					pubKey = PublicKeyBase.CreatePublicKey(writer.TheOptions.StrongNameKey.PublicKey);  				var assembly = new AssemblyDefUser(asmName' new Version(0' 0)' pubKey);  				assembly.Modules.Add(new ModuleDefUser(asmName + ".dll"));  				ModuleDef module = assembly.ManifestModule;  				assembly.ManifestModule.Kind = ModuleKind.Dll;  				var asmRef = new AssemblyRefUser(module.Assembly);  				if (!hasPacker) {  					foreach (EmbeddedResource res in resources) {  						res.Attributes = ManifestResourceAttributes.Public;  						module.Resources.Add(res);  						ctx.Module.Resources.Add(new AssemblyLinkedResource(res.Name' asmRef' res.Attributes));  					}  				}  				byte[] moduleBuff;  				using (var ms = new MemoryStream()) {  					module.Write(ms' new ModuleWriterOptions { StrongNameKey = writer.TheOptions.StrongNameKey });  					moduleBuff = ms.ToArray();  				}    				// compress  				moduleBuff = ctx.Context.Registry.GetService<ICompressionService>().Compress(  					moduleBuff'  					progress => ctx.Context.Logger.Progress((int)(progress * 10000)' 10000));  				ctx.Context.Logger.EndProgress();  				ctx.Context.CheckCancellation();    				uint compressedLen = (uint)(moduleBuff.Length + 3) / 4;  				compressedLen = (compressedLen + 0xfu) & ~0xfu;  				var compressedBuff = new uint[compressedLen];  				Buffer.BlockCopy(moduleBuff' 0' compressedBuff' 0' moduleBuff.Length);  				Debug.Assert(compressedLen % 0x10 == 0);    				// encrypt  				uint keySeed = ctx.Random.NextUInt32() | 0x10;  				var key = new uint[0x10];  				uint state = keySeed;  				for (int i = 0; i < 0x10; i++) {  					state ^= state >> 13;  					state ^= state << 25;  					state ^= state >> 27;  					key[i] = state;  				}    				var encryptedBuffer = new byte[compressedBuff.Length * 4];  				int buffIndex = 0;  				while (buffIndex < compressedBuff.Length) {  					uint[] enc = ctx.ModeHandler.Encrypt(compressedBuff' buffIndex' key);  					for (int j = 0; j < 0x10; j++)  						key[j] ^= compressedBuff[buffIndex + j];  					Buffer.BlockCopy(enc' 0' encryptedBuffer' buffIndex * 4' 0x40);  					buffIndex += 0x10;  				}  				Debug.Assert(buffIndex == compressedBuff.Length);  				var size = (uint)encryptedBuffer.Length;    				TablesHeap tblHeap = writer.MetaData.TablesHeap;  				tblHeap.ClassLayoutTable[writer.MetaData.GetClassLayoutRid(ctx.DataType)].ClassSize = size;  				tblHeap.FieldTable[writer.MetaData.GetRid(ctx.DataField)].Flags |= (ushort)FieldAttributes.HasFieldRVA;  				encryptedResource = writer.Constants.Add(new ByteArrayChunk(encryptedBuffer)' 8);    				// inject key values  				MutationHelper.InjectKeys(ctx.InitMethod'  				                          new[] { 0' 1 }'  				                          new[] { (int)(size / 4)' (int)(keySeed) });  			}  			else if (e.WriterEvent == ModuleWriterEvent.EndCalculateRvasAndFileOffsets) {  				TablesHeap tblHeap = writer.MetaData.TablesHeap;  				tblHeap.FieldRVATable[writer.MetaData.GetFieldRVARid(ctx.DataField)].RVA = (uint)encryptedResource.RVA;  			}
Magic Number,Confuser.Protections.Resources,MDPhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Resources\MDPhase.cs,OnWriterEvent,The following statement contains a magic number: if (e.WriterEvent == ModuleWriterEvent.MDBeginAddResources) {  				ctx.Context.CheckCancellation();  				ctx.Context.Logger.Debug("Encrypting resources...");  				bool hasPacker = ctx.Context.Packer != null;    				List<EmbeddedResource> resources = ctx.Module.Resources.OfType<EmbeddedResource>().ToList();  				if (!hasPacker)  					ctx.Module.Resources.RemoveWhere(res => res is EmbeddedResource);    				// move resources  				string asmName = ctx.Name.RandomName(RenameMode.Letters);  				PublicKey pubKey = null;  				if (writer.TheOptions.StrongNameKey != null)  					pubKey = PublicKeyBase.CreatePublicKey(writer.TheOptions.StrongNameKey.PublicKey);  				var assembly = new AssemblyDefUser(asmName' new Version(0' 0)' pubKey);  				assembly.Modules.Add(new ModuleDefUser(asmName + ".dll"));  				ModuleDef module = assembly.ManifestModule;  				assembly.ManifestModule.Kind = ModuleKind.Dll;  				var asmRef = new AssemblyRefUser(module.Assembly);  				if (!hasPacker) {  					foreach (EmbeddedResource res in resources) {  						res.Attributes = ManifestResourceAttributes.Public;  						module.Resources.Add(res);  						ctx.Module.Resources.Add(new AssemblyLinkedResource(res.Name' asmRef' res.Attributes));  					}  				}  				byte[] moduleBuff;  				using (var ms = new MemoryStream()) {  					module.Write(ms' new ModuleWriterOptions { StrongNameKey = writer.TheOptions.StrongNameKey });  					moduleBuff = ms.ToArray();  				}    				// compress  				moduleBuff = ctx.Context.Registry.GetService<ICompressionService>().Compress(  					moduleBuff'  					progress => ctx.Context.Logger.Progress((int)(progress * 10000)' 10000));  				ctx.Context.Logger.EndProgress();  				ctx.Context.CheckCancellation();    				uint compressedLen = (uint)(moduleBuff.Length + 3) / 4;  				compressedLen = (compressedLen + 0xfu) & ~0xfu;  				var compressedBuff = new uint[compressedLen];  				Buffer.BlockCopy(moduleBuff' 0' compressedBuff' 0' moduleBuff.Length);  				Debug.Assert(compressedLen % 0x10 == 0);    				// encrypt  				uint keySeed = ctx.Random.NextUInt32() | 0x10;  				var key = new uint[0x10];  				uint state = keySeed;  				for (int i = 0; i < 0x10; i++) {  					state ^= state >> 13;  					state ^= state << 25;  					state ^= state >> 27;  					key[i] = state;  				}    				var encryptedBuffer = new byte[compressedBuff.Length * 4];  				int buffIndex = 0;  				while (buffIndex < compressedBuff.Length) {  					uint[] enc = ctx.ModeHandler.Encrypt(compressedBuff' buffIndex' key);  					for (int j = 0; j < 0x10; j++)  						key[j] ^= compressedBuff[buffIndex + j];  					Buffer.BlockCopy(enc' 0' encryptedBuffer' buffIndex * 4' 0x40);  					buffIndex += 0x10;  				}  				Debug.Assert(buffIndex == compressedBuff.Length);  				var size = (uint)encryptedBuffer.Length;    				TablesHeap tblHeap = writer.MetaData.TablesHeap;  				tblHeap.ClassLayoutTable[writer.MetaData.GetClassLayoutRid(ctx.DataType)].ClassSize = size;  				tblHeap.FieldTable[writer.MetaData.GetRid(ctx.DataField)].Flags |= (ushort)FieldAttributes.HasFieldRVA;  				encryptedResource = writer.Constants.Add(new ByteArrayChunk(encryptedBuffer)' 8);    				// inject key values  				MutationHelper.InjectKeys(ctx.InitMethod'  				                          new[] { 0' 1 }'  				                          new[] { (int)(size / 4)' (int)(keySeed) });  			}  			else if (e.WriterEvent == ModuleWriterEvent.EndCalculateRvasAndFileOffsets) {  				TablesHeap tblHeap = writer.MetaData.TablesHeap;  				tblHeap.FieldRVATable[writer.MetaData.GetFieldRVARid(ctx.DataField)].RVA = (uint)encryptedResource.RVA;  			}
Magic Number,Confuser.Protections.Resources,MDPhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Resources\MDPhase.cs,OnWriterEvent,The following statement contains a magic number: if (e.WriterEvent == ModuleWriterEvent.MDBeginAddResources) {  				ctx.Context.CheckCancellation();  				ctx.Context.Logger.Debug("Encrypting resources...");  				bool hasPacker = ctx.Context.Packer != null;    				List<EmbeddedResource> resources = ctx.Module.Resources.OfType<EmbeddedResource>().ToList();  				if (!hasPacker)  					ctx.Module.Resources.RemoveWhere(res => res is EmbeddedResource);    				// move resources  				string asmName = ctx.Name.RandomName(RenameMode.Letters);  				PublicKey pubKey = null;  				if (writer.TheOptions.StrongNameKey != null)  					pubKey = PublicKeyBase.CreatePublicKey(writer.TheOptions.StrongNameKey.PublicKey);  				var assembly = new AssemblyDefUser(asmName' new Version(0' 0)' pubKey);  				assembly.Modules.Add(new ModuleDefUser(asmName + ".dll"));  				ModuleDef module = assembly.ManifestModule;  				assembly.ManifestModule.Kind = ModuleKind.Dll;  				var asmRef = new AssemblyRefUser(module.Assembly);  				if (!hasPacker) {  					foreach (EmbeddedResource res in resources) {  						res.Attributes = ManifestResourceAttributes.Public;  						module.Resources.Add(res);  						ctx.Module.Resources.Add(new AssemblyLinkedResource(res.Name' asmRef' res.Attributes));  					}  				}  				byte[] moduleBuff;  				using (var ms = new MemoryStream()) {  					module.Write(ms' new ModuleWriterOptions { StrongNameKey = writer.TheOptions.StrongNameKey });  					moduleBuff = ms.ToArray();  				}    				// compress  				moduleBuff = ctx.Context.Registry.GetService<ICompressionService>().Compress(  					moduleBuff'  					progress => ctx.Context.Logger.Progress((int)(progress * 10000)' 10000));  				ctx.Context.Logger.EndProgress();  				ctx.Context.CheckCancellation();    				uint compressedLen = (uint)(moduleBuff.Length + 3) / 4;  				compressedLen = (compressedLen + 0xfu) & ~0xfu;  				var compressedBuff = new uint[compressedLen];  				Buffer.BlockCopy(moduleBuff' 0' compressedBuff' 0' moduleBuff.Length);  				Debug.Assert(compressedLen % 0x10 == 0);    				// encrypt  				uint keySeed = ctx.Random.NextUInt32() | 0x10;  				var key = new uint[0x10];  				uint state = keySeed;  				for (int i = 0; i < 0x10; i++) {  					state ^= state >> 13;  					state ^= state << 25;  					state ^= state >> 27;  					key[i] = state;  				}    				var encryptedBuffer = new byte[compressedBuff.Length * 4];  				int buffIndex = 0;  				while (buffIndex < compressedBuff.Length) {  					uint[] enc = ctx.ModeHandler.Encrypt(compressedBuff' buffIndex' key);  					for (int j = 0; j < 0x10; j++)  						key[j] ^= compressedBuff[buffIndex + j];  					Buffer.BlockCopy(enc' 0' encryptedBuffer' buffIndex * 4' 0x40);  					buffIndex += 0x10;  				}  				Debug.Assert(buffIndex == compressedBuff.Length);  				var size = (uint)encryptedBuffer.Length;    				TablesHeap tblHeap = writer.MetaData.TablesHeap;  				tblHeap.ClassLayoutTable[writer.MetaData.GetClassLayoutRid(ctx.DataType)].ClassSize = size;  				tblHeap.FieldTable[writer.MetaData.GetRid(ctx.DataField)].Flags |= (ushort)FieldAttributes.HasFieldRVA;  				encryptedResource = writer.Constants.Add(new ByteArrayChunk(encryptedBuffer)' 8);    				// inject key values  				MutationHelper.InjectKeys(ctx.InitMethod'  				                          new[] { 0' 1 }'  				                          new[] { (int)(size / 4)' (int)(keySeed) });  			}  			else if (e.WriterEvent == ModuleWriterEvent.EndCalculateRvasAndFileOffsets) {  				TablesHeap tblHeap = writer.MetaData.TablesHeap;  				tblHeap.FieldRVATable[writer.MetaData.GetFieldRVARid(ctx.DataField)].RVA = (uint)encryptedResource.RVA;  			}
Magic Number,Confuser.Protections.Resources,MDPhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Resources\MDPhase.cs,OnWriterEvent,The following statement contains a magic number: if (e.WriterEvent == ModuleWriterEvent.MDBeginAddResources) {  				ctx.Context.CheckCancellation();  				ctx.Context.Logger.Debug("Encrypting resources...");  				bool hasPacker = ctx.Context.Packer != null;    				List<EmbeddedResource> resources = ctx.Module.Resources.OfType<EmbeddedResource>().ToList();  				if (!hasPacker)  					ctx.Module.Resources.RemoveWhere(res => res is EmbeddedResource);    				// move resources  				string asmName = ctx.Name.RandomName(RenameMode.Letters);  				PublicKey pubKey = null;  				if (writer.TheOptions.StrongNameKey != null)  					pubKey = PublicKeyBase.CreatePublicKey(writer.TheOptions.StrongNameKey.PublicKey);  				var assembly = new AssemblyDefUser(asmName' new Version(0' 0)' pubKey);  				assembly.Modules.Add(new ModuleDefUser(asmName + ".dll"));  				ModuleDef module = assembly.ManifestModule;  				assembly.ManifestModule.Kind = ModuleKind.Dll;  				var asmRef = new AssemblyRefUser(module.Assembly);  				if (!hasPacker) {  					foreach (EmbeddedResource res in resources) {  						res.Attributes = ManifestResourceAttributes.Public;  						module.Resources.Add(res);  						ctx.Module.Resources.Add(new AssemblyLinkedResource(res.Name' asmRef' res.Attributes));  					}  				}  				byte[] moduleBuff;  				using (var ms = new MemoryStream()) {  					module.Write(ms' new ModuleWriterOptions { StrongNameKey = writer.TheOptions.StrongNameKey });  					moduleBuff = ms.ToArray();  				}    				// compress  				moduleBuff = ctx.Context.Registry.GetService<ICompressionService>().Compress(  					moduleBuff'  					progress => ctx.Context.Logger.Progress((int)(progress * 10000)' 10000));  				ctx.Context.Logger.EndProgress();  				ctx.Context.CheckCancellation();    				uint compressedLen = (uint)(moduleBuff.Length + 3) / 4;  				compressedLen = (compressedLen + 0xfu) & ~0xfu;  				var compressedBuff = new uint[compressedLen];  				Buffer.BlockCopy(moduleBuff' 0' compressedBuff' 0' moduleBuff.Length);  				Debug.Assert(compressedLen % 0x10 == 0);    				// encrypt  				uint keySeed = ctx.Random.NextUInt32() | 0x10;  				var key = new uint[0x10];  				uint state = keySeed;  				for (int i = 0; i < 0x10; i++) {  					state ^= state >> 13;  					state ^= state << 25;  					state ^= state >> 27;  					key[i] = state;  				}    				var encryptedBuffer = new byte[compressedBuff.Length * 4];  				int buffIndex = 0;  				while (buffIndex < compressedBuff.Length) {  					uint[] enc = ctx.ModeHandler.Encrypt(compressedBuff' buffIndex' key);  					for (int j = 0; j < 0x10; j++)  						key[j] ^= compressedBuff[buffIndex + j];  					Buffer.BlockCopy(enc' 0' encryptedBuffer' buffIndex * 4' 0x40);  					buffIndex += 0x10;  				}  				Debug.Assert(buffIndex == compressedBuff.Length);  				var size = (uint)encryptedBuffer.Length;    				TablesHeap tblHeap = writer.MetaData.TablesHeap;  				tblHeap.ClassLayoutTable[writer.MetaData.GetClassLayoutRid(ctx.DataType)].ClassSize = size;  				tblHeap.FieldTable[writer.MetaData.GetRid(ctx.DataField)].Flags |= (ushort)FieldAttributes.HasFieldRVA;  				encryptedResource = writer.Constants.Add(new ByteArrayChunk(encryptedBuffer)' 8);    				// inject key values  				MutationHelper.InjectKeys(ctx.InitMethod'  				                          new[] { 0' 1 }'  				                          new[] { (int)(size / 4)' (int)(keySeed) });  			}  			else if (e.WriterEvent == ModuleWriterEvent.EndCalculateRvasAndFileOffsets) {  				TablesHeap tblHeap = writer.MetaData.TablesHeap;  				tblHeap.FieldRVATable[writer.MetaData.GetFieldRVARid(ctx.DataField)].RVA = (uint)encryptedResource.RVA;  			}
Magic Number,Confuser.Protections.Resources,MDPhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Resources\MDPhase.cs,OnWriterEvent,The following statement contains a magic number: if (e.WriterEvent == ModuleWriterEvent.MDBeginAddResources) {  				ctx.Context.CheckCancellation();  				ctx.Context.Logger.Debug("Encrypting resources...");  				bool hasPacker = ctx.Context.Packer != null;    				List<EmbeddedResource> resources = ctx.Module.Resources.OfType<EmbeddedResource>().ToList();  				if (!hasPacker)  					ctx.Module.Resources.RemoveWhere(res => res is EmbeddedResource);    				// move resources  				string asmName = ctx.Name.RandomName(RenameMode.Letters);  				PublicKey pubKey = null;  				if (writer.TheOptions.StrongNameKey != null)  					pubKey = PublicKeyBase.CreatePublicKey(writer.TheOptions.StrongNameKey.PublicKey);  				var assembly = new AssemblyDefUser(asmName' new Version(0' 0)' pubKey);  				assembly.Modules.Add(new ModuleDefUser(asmName + ".dll"));  				ModuleDef module = assembly.ManifestModule;  				assembly.ManifestModule.Kind = ModuleKind.Dll;  				var asmRef = new AssemblyRefUser(module.Assembly);  				if (!hasPacker) {  					foreach (EmbeddedResource res in resources) {  						res.Attributes = ManifestResourceAttributes.Public;  						module.Resources.Add(res);  						ctx.Module.Resources.Add(new AssemblyLinkedResource(res.Name' asmRef' res.Attributes));  					}  				}  				byte[] moduleBuff;  				using (var ms = new MemoryStream()) {  					module.Write(ms' new ModuleWriterOptions { StrongNameKey = writer.TheOptions.StrongNameKey });  					moduleBuff = ms.ToArray();  				}    				// compress  				moduleBuff = ctx.Context.Registry.GetService<ICompressionService>().Compress(  					moduleBuff'  					progress => ctx.Context.Logger.Progress((int)(progress * 10000)' 10000));  				ctx.Context.Logger.EndProgress();  				ctx.Context.CheckCancellation();    				uint compressedLen = (uint)(moduleBuff.Length + 3) / 4;  				compressedLen = (compressedLen + 0xfu) & ~0xfu;  				var compressedBuff = new uint[compressedLen];  				Buffer.BlockCopy(moduleBuff' 0' compressedBuff' 0' moduleBuff.Length);  				Debug.Assert(compressedLen % 0x10 == 0);    				// encrypt  				uint keySeed = ctx.Random.NextUInt32() | 0x10;  				var key = new uint[0x10];  				uint state = keySeed;  				for (int i = 0; i < 0x10; i++) {  					state ^= state >> 13;  					state ^= state << 25;  					state ^= state >> 27;  					key[i] = state;  				}    				var encryptedBuffer = new byte[compressedBuff.Length * 4];  				int buffIndex = 0;  				while (buffIndex < compressedBuff.Length) {  					uint[] enc = ctx.ModeHandler.Encrypt(compressedBuff' buffIndex' key);  					for (int j = 0; j < 0x10; j++)  						key[j] ^= compressedBuff[buffIndex + j];  					Buffer.BlockCopy(enc' 0' encryptedBuffer' buffIndex * 4' 0x40);  					buffIndex += 0x10;  				}  				Debug.Assert(buffIndex == compressedBuff.Length);  				var size = (uint)encryptedBuffer.Length;    				TablesHeap tblHeap = writer.MetaData.TablesHeap;  				tblHeap.ClassLayoutTable[writer.MetaData.GetClassLayoutRid(ctx.DataType)].ClassSize = size;  				tblHeap.FieldTable[writer.MetaData.GetRid(ctx.DataField)].Flags |= (ushort)FieldAttributes.HasFieldRVA;  				encryptedResource = writer.Constants.Add(new ByteArrayChunk(encryptedBuffer)' 8);    				// inject key values  				MutationHelper.InjectKeys(ctx.InitMethod'  				                          new[] { 0' 1 }'  				                          new[] { (int)(size / 4)' (int)(keySeed) });  			}  			else if (e.WriterEvent == ModuleWriterEvent.EndCalculateRvasAndFileOffsets) {  				TablesHeap tblHeap = writer.MetaData.TablesHeap;  				tblHeap.FieldRVATable[writer.MetaData.GetFieldRVARid(ctx.DataField)].RVA = (uint)encryptedResource.RVA;  			}
Magic Number,Confuser.Protections.Resources,MDPhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Resources\MDPhase.cs,OnWriterEvent,The following statement contains a magic number: if (e.WriterEvent == ModuleWriterEvent.MDBeginAddResources) {  				ctx.Context.CheckCancellation();  				ctx.Context.Logger.Debug("Encrypting resources...");  				bool hasPacker = ctx.Context.Packer != null;    				List<EmbeddedResource> resources = ctx.Module.Resources.OfType<EmbeddedResource>().ToList();  				if (!hasPacker)  					ctx.Module.Resources.RemoveWhere(res => res is EmbeddedResource);    				// move resources  				string asmName = ctx.Name.RandomName(RenameMode.Letters);  				PublicKey pubKey = null;  				if (writer.TheOptions.StrongNameKey != null)  					pubKey = PublicKeyBase.CreatePublicKey(writer.TheOptions.StrongNameKey.PublicKey);  				var assembly = new AssemblyDefUser(asmName' new Version(0' 0)' pubKey);  				assembly.Modules.Add(new ModuleDefUser(asmName + ".dll"));  				ModuleDef module = assembly.ManifestModule;  				assembly.ManifestModule.Kind = ModuleKind.Dll;  				var asmRef = new AssemblyRefUser(module.Assembly);  				if (!hasPacker) {  					foreach (EmbeddedResource res in resources) {  						res.Attributes = ManifestResourceAttributes.Public;  						module.Resources.Add(res);  						ctx.Module.Resources.Add(new AssemblyLinkedResource(res.Name' asmRef' res.Attributes));  					}  				}  				byte[] moduleBuff;  				using (var ms = new MemoryStream()) {  					module.Write(ms' new ModuleWriterOptions { StrongNameKey = writer.TheOptions.StrongNameKey });  					moduleBuff = ms.ToArray();  				}    				// compress  				moduleBuff = ctx.Context.Registry.GetService<ICompressionService>().Compress(  					moduleBuff'  					progress => ctx.Context.Logger.Progress((int)(progress * 10000)' 10000));  				ctx.Context.Logger.EndProgress();  				ctx.Context.CheckCancellation();    				uint compressedLen = (uint)(moduleBuff.Length + 3) / 4;  				compressedLen = (compressedLen + 0xfu) & ~0xfu;  				var compressedBuff = new uint[compressedLen];  				Buffer.BlockCopy(moduleBuff' 0' compressedBuff' 0' moduleBuff.Length);  				Debug.Assert(compressedLen % 0x10 == 0);    				// encrypt  				uint keySeed = ctx.Random.NextUInt32() | 0x10;  				var key = new uint[0x10];  				uint state = keySeed;  				for (int i = 0; i < 0x10; i++) {  					state ^= state >> 13;  					state ^= state << 25;  					state ^= state >> 27;  					key[i] = state;  				}    				var encryptedBuffer = new byte[compressedBuff.Length * 4];  				int buffIndex = 0;  				while (buffIndex < compressedBuff.Length) {  					uint[] enc = ctx.ModeHandler.Encrypt(compressedBuff' buffIndex' key);  					for (int j = 0; j < 0x10; j++)  						key[j] ^= compressedBuff[buffIndex + j];  					Buffer.BlockCopy(enc' 0' encryptedBuffer' buffIndex * 4' 0x40);  					buffIndex += 0x10;  				}  				Debug.Assert(buffIndex == compressedBuff.Length);  				var size = (uint)encryptedBuffer.Length;    				TablesHeap tblHeap = writer.MetaData.TablesHeap;  				tblHeap.ClassLayoutTable[writer.MetaData.GetClassLayoutRid(ctx.DataType)].ClassSize = size;  				tblHeap.FieldTable[writer.MetaData.GetRid(ctx.DataField)].Flags |= (ushort)FieldAttributes.HasFieldRVA;  				encryptedResource = writer.Constants.Add(new ByteArrayChunk(encryptedBuffer)' 8);    				// inject key values  				MutationHelper.InjectKeys(ctx.InitMethod'  				                          new[] { 0' 1 }'  				                          new[] { (int)(size / 4)' (int)(keySeed) });  			}  			else if (e.WriterEvent == ModuleWriterEvent.EndCalculateRvasAndFileOffsets) {  				TablesHeap tblHeap = writer.MetaData.TablesHeap;  				tblHeap.FieldRVATable[writer.MetaData.GetFieldRVARid(ctx.DataField)].RVA = (uint)encryptedResource.RVA;  			}
Magic Number,Confuser.Protections.Resources,MDPhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Resources\MDPhase.cs,OnWriterEvent,The following statement contains a magic number: if (e.WriterEvent == ModuleWriterEvent.MDBeginAddResources) {  				ctx.Context.CheckCancellation();  				ctx.Context.Logger.Debug("Encrypting resources...");  				bool hasPacker = ctx.Context.Packer != null;    				List<EmbeddedResource> resources = ctx.Module.Resources.OfType<EmbeddedResource>().ToList();  				if (!hasPacker)  					ctx.Module.Resources.RemoveWhere(res => res is EmbeddedResource);    				// move resources  				string asmName = ctx.Name.RandomName(RenameMode.Letters);  				PublicKey pubKey = null;  				if (writer.TheOptions.StrongNameKey != null)  					pubKey = PublicKeyBase.CreatePublicKey(writer.TheOptions.StrongNameKey.PublicKey);  				var assembly = new AssemblyDefUser(asmName' new Version(0' 0)' pubKey);  				assembly.Modules.Add(new ModuleDefUser(asmName + ".dll"));  				ModuleDef module = assembly.ManifestModule;  				assembly.ManifestModule.Kind = ModuleKind.Dll;  				var asmRef = new AssemblyRefUser(module.Assembly);  				if (!hasPacker) {  					foreach (EmbeddedResource res in resources) {  						res.Attributes = ManifestResourceAttributes.Public;  						module.Resources.Add(res);  						ctx.Module.Resources.Add(new AssemblyLinkedResource(res.Name' asmRef' res.Attributes));  					}  				}  				byte[] moduleBuff;  				using (var ms = new MemoryStream()) {  					module.Write(ms' new ModuleWriterOptions { StrongNameKey = writer.TheOptions.StrongNameKey });  					moduleBuff = ms.ToArray();  				}    				// compress  				moduleBuff = ctx.Context.Registry.GetService<ICompressionService>().Compress(  					moduleBuff'  					progress => ctx.Context.Logger.Progress((int)(progress * 10000)' 10000));  				ctx.Context.Logger.EndProgress();  				ctx.Context.CheckCancellation();    				uint compressedLen = (uint)(moduleBuff.Length + 3) / 4;  				compressedLen = (compressedLen + 0xfu) & ~0xfu;  				var compressedBuff = new uint[compressedLen];  				Buffer.BlockCopy(moduleBuff' 0' compressedBuff' 0' moduleBuff.Length);  				Debug.Assert(compressedLen % 0x10 == 0);    				// encrypt  				uint keySeed = ctx.Random.NextUInt32() | 0x10;  				var key = new uint[0x10];  				uint state = keySeed;  				for (int i = 0; i < 0x10; i++) {  					state ^= state >> 13;  					state ^= state << 25;  					state ^= state >> 27;  					key[i] = state;  				}    				var encryptedBuffer = new byte[compressedBuff.Length * 4];  				int buffIndex = 0;  				while (buffIndex < compressedBuff.Length) {  					uint[] enc = ctx.ModeHandler.Encrypt(compressedBuff' buffIndex' key);  					for (int j = 0; j < 0x10; j++)  						key[j] ^= compressedBuff[buffIndex + j];  					Buffer.BlockCopy(enc' 0' encryptedBuffer' buffIndex * 4' 0x40);  					buffIndex += 0x10;  				}  				Debug.Assert(buffIndex == compressedBuff.Length);  				var size = (uint)encryptedBuffer.Length;    				TablesHeap tblHeap = writer.MetaData.TablesHeap;  				tblHeap.ClassLayoutTable[writer.MetaData.GetClassLayoutRid(ctx.DataType)].ClassSize = size;  				tblHeap.FieldTable[writer.MetaData.GetRid(ctx.DataField)].Flags |= (ushort)FieldAttributes.HasFieldRVA;  				encryptedResource = writer.Constants.Add(new ByteArrayChunk(encryptedBuffer)' 8);    				// inject key values  				MutationHelper.InjectKeys(ctx.InitMethod'  				                          new[] { 0' 1 }'  				                          new[] { (int)(size / 4)' (int)(keySeed) });  			}  			else if (e.WriterEvent == ModuleWriterEvent.EndCalculateRvasAndFileOffsets) {  				TablesHeap tblHeap = writer.MetaData.TablesHeap;  				tblHeap.FieldRVATable[writer.MetaData.GetFieldRVARid(ctx.DataField)].RVA = (uint)encryptedResource.RVA;  			}
Magic Number,Confuser.Protections.Resources,MDPhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Resources\MDPhase.cs,OnWriterEvent,The following statement contains a magic number: if (e.WriterEvent == ModuleWriterEvent.MDBeginAddResources) {  				ctx.Context.CheckCancellation();  				ctx.Context.Logger.Debug("Encrypting resources...");  				bool hasPacker = ctx.Context.Packer != null;    				List<EmbeddedResource> resources = ctx.Module.Resources.OfType<EmbeddedResource>().ToList();  				if (!hasPacker)  					ctx.Module.Resources.RemoveWhere(res => res is EmbeddedResource);    				// move resources  				string asmName = ctx.Name.RandomName(RenameMode.Letters);  				PublicKey pubKey = null;  				if (writer.TheOptions.StrongNameKey != null)  					pubKey = PublicKeyBase.CreatePublicKey(writer.TheOptions.StrongNameKey.PublicKey);  				var assembly = new AssemblyDefUser(asmName' new Version(0' 0)' pubKey);  				assembly.Modules.Add(new ModuleDefUser(asmName + ".dll"));  				ModuleDef module = assembly.ManifestModule;  				assembly.ManifestModule.Kind = ModuleKind.Dll;  				var asmRef = new AssemblyRefUser(module.Assembly);  				if (!hasPacker) {  					foreach (EmbeddedResource res in resources) {  						res.Attributes = ManifestResourceAttributes.Public;  						module.Resources.Add(res);  						ctx.Module.Resources.Add(new AssemblyLinkedResource(res.Name' asmRef' res.Attributes));  					}  				}  				byte[] moduleBuff;  				using (var ms = new MemoryStream()) {  					module.Write(ms' new ModuleWriterOptions { StrongNameKey = writer.TheOptions.StrongNameKey });  					moduleBuff = ms.ToArray();  				}    				// compress  				moduleBuff = ctx.Context.Registry.GetService<ICompressionService>().Compress(  					moduleBuff'  					progress => ctx.Context.Logger.Progress((int)(progress * 10000)' 10000));  				ctx.Context.Logger.EndProgress();  				ctx.Context.CheckCancellation();    				uint compressedLen = (uint)(moduleBuff.Length + 3) / 4;  				compressedLen = (compressedLen + 0xfu) & ~0xfu;  				var compressedBuff = new uint[compressedLen];  				Buffer.BlockCopy(moduleBuff' 0' compressedBuff' 0' moduleBuff.Length);  				Debug.Assert(compressedLen % 0x10 == 0);    				// encrypt  				uint keySeed = ctx.Random.NextUInt32() | 0x10;  				var key = new uint[0x10];  				uint state = keySeed;  				for (int i = 0; i < 0x10; i++) {  					state ^= state >> 13;  					state ^= state << 25;  					state ^= state >> 27;  					key[i] = state;  				}    				var encryptedBuffer = new byte[compressedBuff.Length * 4];  				int buffIndex = 0;  				while (buffIndex < compressedBuff.Length) {  					uint[] enc = ctx.ModeHandler.Encrypt(compressedBuff' buffIndex' key);  					for (int j = 0; j < 0x10; j++)  						key[j] ^= compressedBuff[buffIndex + j];  					Buffer.BlockCopy(enc' 0' encryptedBuffer' buffIndex * 4' 0x40);  					buffIndex += 0x10;  				}  				Debug.Assert(buffIndex == compressedBuff.Length);  				var size = (uint)encryptedBuffer.Length;    				TablesHeap tblHeap = writer.MetaData.TablesHeap;  				tblHeap.ClassLayoutTable[writer.MetaData.GetClassLayoutRid(ctx.DataType)].ClassSize = size;  				tblHeap.FieldTable[writer.MetaData.GetRid(ctx.DataField)].Flags |= (ushort)FieldAttributes.HasFieldRVA;  				encryptedResource = writer.Constants.Add(new ByteArrayChunk(encryptedBuffer)' 8);    				// inject key values  				MutationHelper.InjectKeys(ctx.InitMethod'  				                          new[] { 0' 1 }'  				                          new[] { (int)(size / 4)' (int)(keySeed) });  			}  			else if (e.WriterEvent == ModuleWriterEvent.EndCalculateRvasAndFileOffsets) {  				TablesHeap tblHeap = writer.MetaData.TablesHeap;  				tblHeap.FieldRVATable[writer.MetaData.GetFieldRVARid(ctx.DataField)].RVA = (uint)encryptedResource.RVA;  			}
Magic Number,Confuser.Protections.Resources,MDPhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Resources\MDPhase.cs,OnWriterEvent,The following statement contains a magic number: if (e.WriterEvent == ModuleWriterEvent.MDBeginAddResources) {  				ctx.Context.CheckCancellation();  				ctx.Context.Logger.Debug("Encrypting resources...");  				bool hasPacker = ctx.Context.Packer != null;    				List<EmbeddedResource> resources = ctx.Module.Resources.OfType<EmbeddedResource>().ToList();  				if (!hasPacker)  					ctx.Module.Resources.RemoveWhere(res => res is EmbeddedResource);    				// move resources  				string asmName = ctx.Name.RandomName(RenameMode.Letters);  				PublicKey pubKey = null;  				if (writer.TheOptions.StrongNameKey != null)  					pubKey = PublicKeyBase.CreatePublicKey(writer.TheOptions.StrongNameKey.PublicKey);  				var assembly = new AssemblyDefUser(asmName' new Version(0' 0)' pubKey);  				assembly.Modules.Add(new ModuleDefUser(asmName + ".dll"));  				ModuleDef module = assembly.ManifestModule;  				assembly.ManifestModule.Kind = ModuleKind.Dll;  				var asmRef = new AssemblyRefUser(module.Assembly);  				if (!hasPacker) {  					foreach (EmbeddedResource res in resources) {  						res.Attributes = ManifestResourceAttributes.Public;  						module.Resources.Add(res);  						ctx.Module.Resources.Add(new AssemblyLinkedResource(res.Name' asmRef' res.Attributes));  					}  				}  				byte[] moduleBuff;  				using (var ms = new MemoryStream()) {  					module.Write(ms' new ModuleWriterOptions { StrongNameKey = writer.TheOptions.StrongNameKey });  					moduleBuff = ms.ToArray();  				}    				// compress  				moduleBuff = ctx.Context.Registry.GetService<ICompressionService>().Compress(  					moduleBuff'  					progress => ctx.Context.Logger.Progress((int)(progress * 10000)' 10000));  				ctx.Context.Logger.EndProgress();  				ctx.Context.CheckCancellation();    				uint compressedLen = (uint)(moduleBuff.Length + 3) / 4;  				compressedLen = (compressedLen + 0xfu) & ~0xfu;  				var compressedBuff = new uint[compressedLen];  				Buffer.BlockCopy(moduleBuff' 0' compressedBuff' 0' moduleBuff.Length);  				Debug.Assert(compressedLen % 0x10 == 0);    				// encrypt  				uint keySeed = ctx.Random.NextUInt32() | 0x10;  				var key = new uint[0x10];  				uint state = keySeed;  				for (int i = 0; i < 0x10; i++) {  					state ^= state >> 13;  					state ^= state << 25;  					state ^= state >> 27;  					key[i] = state;  				}    				var encryptedBuffer = new byte[compressedBuff.Length * 4];  				int buffIndex = 0;  				while (buffIndex < compressedBuff.Length) {  					uint[] enc = ctx.ModeHandler.Encrypt(compressedBuff' buffIndex' key);  					for (int j = 0; j < 0x10; j++)  						key[j] ^= compressedBuff[buffIndex + j];  					Buffer.BlockCopy(enc' 0' encryptedBuffer' buffIndex * 4' 0x40);  					buffIndex += 0x10;  				}  				Debug.Assert(buffIndex == compressedBuff.Length);  				var size = (uint)encryptedBuffer.Length;    				TablesHeap tblHeap = writer.MetaData.TablesHeap;  				tblHeap.ClassLayoutTable[writer.MetaData.GetClassLayoutRid(ctx.DataType)].ClassSize = size;  				tblHeap.FieldTable[writer.MetaData.GetRid(ctx.DataField)].Flags |= (ushort)FieldAttributes.HasFieldRVA;  				encryptedResource = writer.Constants.Add(new ByteArrayChunk(encryptedBuffer)' 8);    				// inject key values  				MutationHelper.InjectKeys(ctx.InitMethod'  				                          new[] { 0' 1 }'  				                          new[] { (int)(size / 4)' (int)(keySeed) });  			}  			else if (e.WriterEvent == ModuleWriterEvent.EndCalculateRvasAndFileOffsets) {  				TablesHeap tblHeap = writer.MetaData.TablesHeap;  				tblHeap.FieldRVATable[writer.MetaData.GetFieldRVARid(ctx.DataField)].RVA = (uint)encryptedResource.RVA;  			}
Missing Default,Confuser.Protections.AntiTamper,JITMethodBody,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\JITBody.cs,Serialize,The following switch statement is missing a default case: switch (i) {  						case 0:  							writer.Write((uint)ILCode.Length);  							break;  						case 1:  							writer.Write(MaxStack);  							break;  						case 2:  							writer.Write((uint)EHs.Length);  							break;  						case 3:  							writer.Write((uint)LocalVars.Length);  							break;  						case 4:  							writer.Write(Options);  							break;  						case 5:  							writer.Write(MulSeed);  							break;  					}
Missing Default,Confuser.Protections.AntiTamper,NormalDeriver,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\NormalDeriver.cs,DeriveKey,The following switch statement is missing a default case: switch (i % 3) {  					case 0:  						ret[i] = a[i] ^ b[i];  						break;  					case 1:  						ret[i] = a[i] * b[i];  						break;  					case 2:  						ret[i] = a[i] + b[i];  						break;  				}
Missing Default,Confuser.Protections.AntiTamper,NormalDeriver,C:\repos\yck1509_ConfuserEx\Confuser.Protections\AntiTamper\NormalDeriver.cs,EmitDerivation,The following switch statement is missing a default case: switch (i % 3) {  					case 0:  						yield return Instruction.Create(OpCodes.Xor);  						break;  					case 1:  						yield return Instruction.Create(OpCodes.Mul);  						break;  					case 2:  						yield return Instruction.Create(OpCodes.Add);  						break;  				}
Missing Default,Confuser.Protections.Compress,NormalDeriver,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Compress\NormalDeriver.cs,DeriveKey,The following switch statement is missing a default case: switch (state % 3) {  					case 0:  						ret[i] = a[i] ^ b[i];  						break;  					case 1:  						ret[i] = a[i] * b[i];  						break;  					case 2:  						ret[i] = a[i] + b[i];  						break;  				}
Missing Default,Confuser.Protections.Compress,NormalDeriver,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Compress\NormalDeriver.cs,DeriveKey,The following switch statement is missing a default case: switch (state % 3) {  					case 0:  						ret[i] += k1;  						break;  					case 1:  						ret[i] ^= k2;  						break;  					case 2:  						ret[i] *= k3;  						break;  				}
Missing Default,Confuser.Protections.Compress,NormalDeriver,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Compress\NormalDeriver.cs,EmitDerivation,The following switch statement is missing a default case: switch (state % 3) {  					case 0:  						yield return Instruction.Create(OpCodes.Xor);  						break;  					case 1:  						yield return Instruction.Create(OpCodes.Mul);  						break;  					case 2:  						yield return Instruction.Create(OpCodes.Add);  						break;  				}
Missing Default,Confuser.Protections.Compress,NormalDeriver,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Compress\NormalDeriver.cs,EmitDerivation,The following switch statement is missing a default case: switch (state % 3) {  					case 0:  						yield return Instruction.Create(OpCodes.Ldc_I4' (int)k1);  						yield return Instruction.Create(OpCodes.Add);  						break;  					case 1:  						yield return Instruction.Create(OpCodes.Ldc_I4' (int)k2);  						yield return Instruction.Create(OpCodes.Xor);  						break;  					case 2:  						yield return Instruction.Create(OpCodes.Ldc_I4' (int)k3);  						yield return Instruction.Create(OpCodes.Mul);  						break;  				}
Missing Default,Confuser.Protections.Constants,CFGState,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\ReferenceReplacer.cs,UpdateExplicit,The following switch statement is missing a default case: switch (id) {  					case 0:  						A = value;  						break;  					case 1:  						B = value;  						break;  					case 2:  						C = value;  						break;  					case 3:  						D = value;  						break;  				}
Missing Default,Confuser.Protections.Constants,CFGState,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\ReferenceReplacer.cs,UpdateIncremental,The following switch statement is missing a default case: switch (id) {  					case 0:  						A *= value;  						break;  					case 1:  						B += value;  						break;  					case 2:  						C ^= value;  						break;  					case 3:  						D -= value;  						break;  				}
Missing Default,Confuser.Protections.Constants,CFGState,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\ReferenceReplacer.cs,GetIncrementalUpdate,The following switch statement is missing a default case: switch (id) {  					case 0:  						return A ^ target;  					case 1:  						return target - B;  					case 2:  						return C ^ target;  					case 3:  						return D - target;  				}
Missing Default,Confuser.Protections.Constants,CFGState,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\ReferenceReplacer.cs,Get,The following switch statement is missing a default case: switch (id) {  					case 0:  						return A;  					case 1:  						return B;  					case 2:  						return C;  					case 3:  						return D;  				}
Missing Default,Confuser.Protections.Constants,EncodePhase,C:\repos\yck1509_ConfuserEx\Confuser.Protections\Constants\EncodePhase.cs,ExtractConstants,The following switch statement is missing a default case: switch (elem) {  						case 'S':  						case 's':  							moduleCtx.Elements |= EncodeElements.Strings;  							break;  						case 'N':  						case 'n':  							moduleCtx.Elements |= EncodeElements.Numbers;  							break;  						case 'P':  						case 'p':  							moduleCtx.Elements |= EncodeElements.Primitive;  							break;  						case 'I':  						case 'i':  							moduleCtx.Elements |= EncodeElements.Initializers;  							break;  					}
Missing Default,Confuser.Protections.ControlFlow,CFContext,C:\repos\yck1509_ConfuserEx\Confuser.Protections\ControlFlow\CFContext.cs,AddJump,The following switch statement is missing a default case: switch (Random.NextInt32(3)) {  					case 0:  						instrs.Add(Instruction.Create(OpCodes.Ldc_I4_0));  						instrs.Add(Instruction.Create(OpCodes.Brtrue' instrs[0]));  						break;    					case 1:  						instrs.Add(Instruction.Create(OpCodes.Ldc_I4_1));  						instrs.Add(Instruction.Create(OpCodes.Brfalse' instrs[0]));  						break;    					case 2: // Take that' de4dot + ILSpy :)  						bool addDefOk = false;  						if (Random.NextBoolean()) {  							TypeDef randomType;  							randomType = Method.Module.Types[Random.NextInt32(Method.Module.Types.Count)];    							if (randomType.HasMethods) {  								instrs.Add(Instruction.Create(OpCodes.Ldtoken' randomType.Methods[Random.NextInt32(randomType.Methods.Count)]));  								instrs.Add(Instruction.Create(OpCodes.Box' Method.Module.CorLibTypes.GetTypeRef("System"' "RuntimeMethodHandle")));  								addDefOk = true;  							}  						}    						if (!addDefOk) {  							instrs.Add(Instruction.Create(OpCodes.Ldc_I4' Random.NextBoolean() ? 0 : 1));  							instrs.Add(Instruction.Create(OpCodes.Box' Method.Module.CorLibTypes.Int32.TypeDefOrRef));  						}  						Instruction pop = Instruction.Create(OpCodes.Pop);  						instrs.Add(Instruction.Create(OpCodes.Brfalse' instrs[0]));  						instrs.Add(Instruction.Create(OpCodes.Ldc_I4' Random.NextBoolean() ? 0 : 1));  						instrs.Add(pop);  						break;  				}
Missing Default,Confuser.Protections.ControlFlow,CFContext,C:\repos\yck1509_ConfuserEx\Confuser.Protections\ControlFlow\CFContext.cs,AddJunk,The following switch statement is missing a default case: switch (Random.NextInt32(6)) {  				case 0:  					instrs.Add(Instruction.Create(OpCodes.Pop));  					break;  				case 1:  					instrs.Add(Instruction.Create(OpCodes.Dup));  					break;  				case 2:  					instrs.Add(Instruction.Create(OpCodes.Throw));  					break;  				case 3:  					instrs.Add(Instruction.Create(OpCodes.Ldarg' new Parameter(0xff)));  					break;  				case 4:  					instrs.Add(Instruction.Create(OpCodes.Ldloc' new Local(null) { Index = 0xff }));  					break;  				case 5:  					instrs.Add(Instruction.Create(OpCodes.Ldtoken' Method));  					break;  			}
Missing Default,Confuser.Protections.ControlFlow,SwitchMangler,C:\repos\yck1509_ConfuserEx\Confuser.Protections\ControlFlow\SwitchMangler.cs,SpiltStatements,The following switch statement is missing a default case: switch (instr.OpCode.FlowControl) {  					case FlowControl.Branch:  					case FlowControl.Cond_Branch:  					case FlowControl.Return:  					case FlowControl.Throw:  						shouldSpilt = true;  						if (trace.AfterStack[instr.Offset] != 0) {  							if (instr.Operand is Instruction)  								requiredInstr.Add((Instruction)instr.Operand);  							else if (instr.Operand is Instruction[]) {  								foreach (var target in (Instruction[])instr.Operand)  									requiredInstr.Add(target);  							}  						}  						break;  				}
Missing Default,Confuser.Protections.ControlFlow,SwitchMangler,C:\repos\yck1509_ConfuserEx\Confuser.Protections\ControlFlow\SwitchMangler.cs,InverseBranch,The following switch statement is missing a default case: switch (opCode.Code) {  				case Code.Bge:  					return OpCodes.Blt;  				case Code.Bge_Un:  					return OpCodes.Blt_Un;  				case Code.Blt:  					return OpCodes.Bge;  				case Code.Blt_Un:  					return OpCodes.Bge_Un;  				case Code.Bgt:  					return OpCodes.Ble;  				case Code.Bgt_Un:  					return OpCodes.Ble_Un;  				case Code.Ble:  					return OpCodes.Bgt;  				case Code.Ble_Un:  					return OpCodes.Bgt_Un;  				case Code.Brfalse:  					return OpCodes.Brtrue;  				case Code.Brtrue:  					return OpCodes.Brfalse;  				case Code.Beq:  					return OpCodes.Bne_Un;  				case Code.Bne_Un:  					return OpCodes.Beq;  			}
