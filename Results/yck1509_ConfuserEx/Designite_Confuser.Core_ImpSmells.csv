Implementation smell,Namespace,Class,File,Method,Description
Long Method,Confuser.Core,ConfuserEngine,C:\repos\yck1509_ConfuserEx\Confuser.Core\ConfuserEngine.cs,RunInternal,The method has 112 lines of code.
Long Method,Confuser.Core,ObfAttrParser,C:\repos\yck1509_ConfuserEx\Confuser.Core\ObfAttrParser.cs,ParseProtectionString,The method has 131 lines of code.
Long Method,Confuser.Core.Helpers,KeySequence,C:\repos\yck1509_ConfuserEx\Confuser.Core\Helpers\KeySequence.cs,ProcessBlocks,The method has 120 lines of code.
Long Method,SevenZip.Compression.LZMA,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The method has 394 lines of code.
Long Method,SevenZip.Compression.LZMA,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,CodeOneBlock,The method has 139 lines of code.
Long Method,SevenZip.Compression.LZ,BinTree,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZ\LzBinTree.cs,GetMatches,The method has 105 lines of code.
Complex Method,Confuser.Core,ConfuserEngine,C:\repos\yck1509_ConfuserEx\Confuser.Core\ConfuserEngine.cs,Inspection,Cyclomatic complexity of the method is 8
Complex Method,Confuser.Core,DnlibUtils,C:\repos\yck1509_ConfuserEx\Confuser.Core\DnlibUtils.cs,ReplaceReference,Cyclomatic complexity of the method is 8
Complex Method,Confuser.Core,Marker,C:\repos\yck1509_ConfuserEx\Confuser.Core\Marker.cs,MarkProject,Cyclomatic complexity of the method is 10
Complex Method,Confuser.Core,ObfAttrMarker,C:\repos\yck1509_ConfuserEx\Confuser.Core\ObfAttrMarker.cs,MarkProject,Cyclomatic complexity of the method is 8
Complex Method,Confuser.Core,ProtectionParameters,C:\repos\yck1509_ConfuserEx\Confuser.Core\ProtectionParameters.cs,GetParameter,Cyclomatic complexity of the method is 8
Complex Method,Confuser.Core,ProtectionPipeline,C:\repos\yck1509_ConfuserEx\Confuser.Core\ProtectionPipeline.cs,Filter,Cyclomatic complexity of the method is 8
Complex Method,Confuser.Core.Helpers,ControlFlowGraph,C:\repos\yck1509_ConfuserEx\Confuser.Core\Helpers\ControlFlowGraph.cs,SplitBlocks,Cyclomatic complexity of the method is 9
Complex Method,Confuser.Core.Helpers,InjectHelper,C:\repos\yck1509_ConfuserEx\Confuser.Core\Helpers\InjectHelper.cs,CopyMethodDef,Cyclomatic complexity of the method is 10
Complex Method,SevenZip.Compression.LZMA,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,Cyclomatic complexity of the method is 58
Complex Method,SevenZip.Compression.LZMA,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,CodeOneBlock,Cyclomatic complexity of the method is 15
Complex Method,SevenZip.Compression.LZ,BinTree,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZ\LzBinTree.cs,GetMatches,Cyclomatic complexity of the method is 21
Complex Method,Confuser.Core.Project,ConfuserProject,C:\repos\yck1509_ConfuserEx\Confuser.Core\Project\ConfuserProject.cs,Save,Cyclomatic complexity of the method is 8
Complex Method,Confuser.Core.Project.Patterns,IsTypeFunction,C:\repos\yck1509_ConfuserEx\Confuser.Core\Project\Patterns\IsTypeFunction.cs,Evaluate,Cyclomatic complexity of the method is 10
Complex Method,Confuser.Core.Project.Patterns,IsPublicFunction,C:\repos\yck1509_ConfuserEx\Confuser.Core\Project\Patterns\IsPublicFunction.cs,Evaluate,Cyclomatic complexity of the method is 9
Complex Method,Confuser.Core.Project.Patterns,MemberTypeFunction,C:\repos\yck1509_ConfuserEx\Confuser.Core\Project\Patterns\MemberTypeFunction.cs,Evaluate,Cyclomatic complexity of the method is 8
Complex Method,Confuser.Core.Services,RandomGenerator,C:\repos\yck1509_ConfuserEx\Confuser.Core\Services\RandomService.cs,NextBytes,Cyclomatic complexity of the method is 8
Complex Method,Confuser.Core.Services,MethodTrace,C:\repos\yck1509_ConfuserEx\Confuser.Core\Services\TraceService.cs,Trace,Cyclomatic complexity of the method is 11
Complex Method,Confuser.Core.Services,MethodTrace,C:\repos\yck1509_ConfuserEx\Confuser.Core\Services\TraceService.cs,TraceArguments,Cyclomatic complexity of the method is 19
Long Parameter List,Confuser.Core,PluginDiscovery,C:\repos\yck1509_ConfuserEx\Confuser.Core\PluginDiscovery.cs,AddPlugins,The method has 5 parameters. Parameters: context' protections' packers' components' asm
Long Parameter List,Confuser.Core,Packer,C:\repos\yck1509_ConfuserEx\Confuser.Core\Packer.cs,ProtectStub,The method has 5 parameters. Parameters: context' fileName' module' snKey' prot
Long Parameter List,SevenZip,ICoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\ICoder.cs,Code,The method has 5 parameters. Parameters: inStream' outStream' inSize' outSize' progress
Long Parameter List,SevenZip.Compression.LZMA,Decoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaDecoder.cs,Code,The method has 5 parameters. Parameters: inStream' outStream' inSize' outSize' progress
Long Parameter List,SevenZip.Compression.LZMA,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,Code,The method has 5 parameters. Parameters: inStream' outStream' inSize' outSize' progress
Long Parameter List,SevenZip.Compression.RangeCoder,BitTreeEncoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\RangeCoder\RangeCoderBitTree.cs,ReverseEncode,The method has 5 parameters. Parameters: Models' startIndex' rangeEncoder' NumBitLevels' symbol
Long Identifier,SevenZip.Compression.LZMA,Base,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaBase.cs,,The length of the parameter kNumLitPosStatesBitsEncodingMax is 31.
Long Statement,Confuser.Core,ConfuserEngine,C:\repos\yck1509_ConfuserEx\Confuser.Core\ConfuserEngine.cs,RunInternal,The length of the statement  "				context.BaseDirectory = Path.Combine(Environment.CurrentDirectory' parameters.Project.BaseDirectory.TrimEnd(Path.DirectorySeparatorChar) + Path.DirectorySeparatorChar); " is 168.
Long Statement,Confuser.Core,ConfuserEngine,C:\repos\yck1509_ConfuserEx\Confuser.Core\ConfuserEngine.cs,RunInternal,The length of the statement  "				context.OutputDirectory = Path.Combine(parameters.Project.BaseDirectory' parameters.Project.OutputDirectory.TrimEnd(Path.DirectorySeparatorChar) + Path.DirectorySeparatorChar); " is 176.
Long Statement,Confuser.Core,ConfuserEngine,C:\repos\yck1509_ConfuserEx\Confuser.Core\ConfuserEngine.cs,RunInternal,The length of the statement  "				context.Logger.ErrorException("Failed to resolve an assembly' check if all dependencies are present in the correct version."' ex); " is 130.
Long Statement,Confuser.Core,ConfuserEngine,C:\repos\yck1509_ConfuserEx\Confuser.Core\ConfuserEngine.cs,RunInternal,The length of the statement  "                context.Logger.ErrorException("Failed to resolve a type' check if all dependencies are present in the correct version."' ex); " is 125.
Long Statement,Confuser.Core,ConfuserEngine,C:\repos\yck1509_ConfuserEx\Confuser.Core\ConfuserEngine.cs,RunInternal,The length of the statement  "				context.Logger.ErrorException("Failed to resolve a member' check if all dependencies are present in the correct version."' ex); " is 127.
Long Statement,Confuser.Core,ConfuserEngine,C:\repos\yck1509_ConfuserEx\Confuser.Core\ConfuserEngine.cs,RunPipeline,The length of the statement  "				pipeline.ExecuteStage(PipelineStage.OptimizeMethods' OptimizeMethods' () => getModuleDefs(context.CurrentModule)' context); " is 123.
Long Statement,Confuser.Core,ConfuserEngine,C:\repos\yck1509_ConfuserEx\Confuser.Core\ConfuserEngine.cs,Inspection,The length of the statement  "					context.Logger.WarnFormat("[{0}] SN Key is not provided for a signed module' the output may not be working."' module.Name); " is 123.
Long Statement,Confuser.Core,ConfuserEngine,C:\repos\yck1509_ConfuserEx\Confuser.Core\ConfuserEngine.cs,Inspection,The length of the statement  "					context.Logger.WarnFormat("[{0}] SN Key is provided for an unsigned module' the output may not be working."' module.Name); " is 122.
Long Statement,Confuser.Core,ConfuserEngine,C:\repos\yck1509_ConfuserEx\Confuser.Core\ConfuserEngine.cs,Inspection,The length of the statement  "					context.Logger.WarnFormat("[{0}] Provided SN Key and signed module's public key do not match' the output may not be working."' module.Name); " is 140.
Long Statement,Confuser.Core,ConfuserEngine,C:\repos\yck1509_ConfuserEx\Confuser.Core\ConfuserEngine.cs,Inspection,The length of the statement  "				ctor.Body.Instructions.Add(OpCodes.Call.ToInstruction(new MemberRefUser(module' ".ctor"' MethodSig.CreateInstance(module.CorLibTypes.Void)' attrRef))); " is 151.
Long Statement,Confuser.Core,ConfuserEngine,C:\repos\yck1509_ConfuserEx\Confuser.Core\ConfuserEngine.cs,BeginModule,The length of the statement  "			context.CurrentModuleWriterOptions = new ModuleWriterOptions(context.CurrentModule' context.CurrentModuleWriterListener); " is 121.
Long Statement,Confuser.Core,ConfuserEngine,C:\repos\yck1509_ConfuserEx\Confuser.Core\ConfuserEngine.cs,WriteModule,The length of the statement  "				context.CurrentModuleWriterOptions.PdbFileName = Path.ChangeExtension(Path.GetFileName(context.OutputPaths[context.CurrentModuleIndex])' "pdb"); " is 144.
Long Statement,Confuser.Core,Marker,C:\repos\yck1509_ConfuserEx\Confuser.Core\Marker.cs,MarkProject,The length of the statement  "				context.Annotations.Set(module.Item2' SNKey' LoadSNKey(context' module.Item1.SNKeyPath == null ? null : Path.Combine(proj.BaseDirectory' module.Item1.SNKeyPath)' module.Item1.SNKeyPassword)); " is 191.
Long Statement,Confuser.Core.Helpers,ControlFlowBlock,C:\repos\yck1509_ConfuserEx\Confuser.Core\Helpers\ControlFlowGraph.cs,ToString,The length of the statement  "			return string.Format("Block {0} => {1} {2}"' Id' Type' string.Join("' "' Targets.Select(block => block.Id.ToString()).ToArray())); " is 130.
Long Statement,Confuser.Core.Helpers,InjectHelper,C:\repos\yck1509_ConfuserEx\Confuser.Core\Helpers\InjectHelper.cs,CopyMethodDef,The length of the statement  "				newMethodDef.ImplMap = new ImplMapUser(new ModuleRefUser(ctx.TargetModule' methodDef.ImplMap.Module.Name)' methodDef.ImplMap.Name' methodDef.ImplMap.Attributes); " is 161.
Long Statement,Confuser.Core.Helpers,InjectHelper,C:\repos\yck1509_ConfuserEx\Confuser.Core\Helpers\InjectHelper.cs,CopyMethodDef,The length of the statement  "				newMethodDef.Body = new CilBody(methodDef.Body.InitLocals' new List<Instruction>()' new List<ExceptionHandler>()' new List<Local>()); " is 133.
Long Statement,SevenZip.Compression.LZMA,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The length of the statement  "							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1(); " is 126.
Long Statement,SevenZip.Compression.LZMA,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The length of the statement  "									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1(); " is 126.
Long Statement,Confuser.Core.Project,SettingItem<T>,C:\repos\yck1509_ConfuserEx\Confuser.Core\Project\ConfuserProject.cs,Save,The length of the statement  "			XmlElement elem = xmlDoc.CreateElement(typeof(T) == typeof(Packer) ? "packer" : "protection"' ConfuserProject.Namespace); " is 121.
Long Statement,Confuser.Core.Project,PatternParser,C:\repos\yck1509_ConfuserEx\Confuser.Core\Project\PatternParser.cs,UnexpectedToken,The length of the statement  "			throw new InvalidPatternException(string.Format("Unexpected token '{0}' at position {1}."' token.Value' token.Position)); " is 121.
Long Statement,Confuser.Core.Project,PatternParser,C:\repos\yck1509_ConfuserEx\Confuser.Core\Project\PatternParser.cs,UnexpectedToken,The length of the statement  "			throw new InvalidPatternException(string.Format("Unexpected token '{0}' at position {1}. Expected '{2}'."' token.Value' token.Position' expect)); " is 145.
Long Statement,Confuser.Core.Project,PatternParser,C:\repos\yck1509_ConfuserEx\Confuser.Core\Project\PatternParser.cs,BadArgCount,The length of the statement  "			throw new InvalidPatternException(string.Format("Invalid argument count for '{0}' at position {1}. Expected {2}"' token.Value' token.Position' expected)); " is 154.
Long Statement,Confuser.Core.Services,CompressionService,C:\repos\yck1509_ConfuserEx\Confuser.Core\Services\CompressionService.cs,GetRuntimeDecompressor,The length of the statement  "				List<IDnlibDef> members = InjectHelper.Inject(rt.GetRuntimeType("Confuser.Runtime.Lzma")' module.GlobalType' module).ToList(); " is 126.
Complex Conditional,Confuser.Core,ProtectionSettingsStack,C:\repos\yck1509_ConfuserEx\Confuser.Core\ObfAttrMarker.cs,ApplyInfo,The conditional expression  "(type == ApplyInfoType.ParentInfo && info.Condition != null && info.ApplyToMember) ||  							type == ApplyInfoType.CurrentInfoOnly ||  							(type == ApplyInfoType.CurrentInfoInherits && info.Condition == null && info.ApplyToMember)"  is complex.
Complex Conditional,Confuser.Core.API,APIStore,C:\repos\yck1509_ConfuserEx\Confuser.Core\API\APIStore.cs,GetPredicate,The conditional expression  "predicate.IsUsable(method) &&  				    (type == null || predicate.Type == type.Value) &&  				    (argCount == null || Array.IndexOf(argCount' predicate.ArgumentCount) != -1)"  is complex.
Complex Conditional,Confuser.Core.Project,PatternTokenizer,C:\repos\yck1509_ConfuserEx\Confuser.Core\Project\PatternTokenizer.cs,ReadIdentifier,The conditional expression  "chr != null && (char.IsLetterOrDigit(chr.Value) || chr == '_' || chr == '-')"  is complex.
Empty Catch Block,Confuser.Core,ConfuserEngine,C:\repos\yck1509_ConfuserEx\Confuser.Core\ConfuserEngine.cs,RunInternal,The method has an empty catch block.
Magic Number,Confuser.Core,ConfuserEngine,C:\repos\yck1509_ConfuserEx\Confuser.Core\ConfuserEngine.cs,PrintInfo,The following statement contains a magic number: if (context.PackerInitiated) {  				context.Logger.Info("Protecting packer stub...");  			}  			else {  				context.Logger.InfoFormat("{0} {1}"' Version' Copyright);    				Type mono = Type.GetType("Mono.Runtime");  				context.Logger.InfoFormat("Running on {0}' {1}' {2} bits"'  				                          Environment.OSVersion'  				                          mono == null ?  					                          ".NET Framework v" + Environment.Version :  					                          mono.GetMethod("GetDisplayName"' BindingFlags.NonPublic | BindingFlags.Static).Invoke(null' null)'  				                          IntPtr.Size * 8);  			}
Magic Number,Confuser.Core,NativeEraser,C:\repos\yck1509_ConfuserEx\Confuser.Core\NativeEraser.cs,Erase,The following statement contains a magic number: foreach (var sect in sections)  				if (methodOffset >= sect.Item1 && methodOffset - sect.Item1 < sect.Item3.Length) {  					uint f = sect.Item3[methodOffset - sect.Item1];  					uint size;  					switch ((f & 7)) {  						case 2:  						case 6:  							size = (f >> 2) + 1;  							break;    						case 3:  							f |= (uint)((sect.Item3[methodOffset - sect.Item1 + 1]) << 8);  							size = (f >> 12) * 4;  							uint codeSize = BitConverter.ToUInt32(sect.Item3' (int)(methodOffset - sect.Item1 + 4));  							size += codeSize;  							break;  						default:  							return;  					}  					Erase(sect' methodOffset' size);  				}
Magic Number,Confuser.Core,NativeEraser,C:\repos\yck1509_ConfuserEx\Confuser.Core\NativeEraser.cs,Erase,The following statement contains a magic number: foreach (var sect in sections)  				if (methodOffset >= sect.Item1 && methodOffset - sect.Item1 < sect.Item3.Length) {  					uint f = sect.Item3[methodOffset - sect.Item1];  					uint size;  					switch ((f & 7)) {  						case 2:  						case 6:  							size = (f >> 2) + 1;  							break;    						case 3:  							f |= (uint)((sect.Item3[methodOffset - sect.Item1 + 1]) << 8);  							size = (f >> 12) * 4;  							uint codeSize = BitConverter.ToUInt32(sect.Item3' (int)(methodOffset - sect.Item1 + 4));  							size += codeSize;  							break;  						default:  							return;  					}  					Erase(sect' methodOffset' size);  				}
Magic Number,Confuser.Core,NativeEraser,C:\repos\yck1509_ConfuserEx\Confuser.Core\NativeEraser.cs,Erase,The following statement contains a magic number: foreach (var sect in sections)  				if (methodOffset >= sect.Item1 && methodOffset - sect.Item1 < sect.Item3.Length) {  					uint f = sect.Item3[methodOffset - sect.Item1];  					uint size;  					switch ((f & 7)) {  						case 2:  						case 6:  							size = (f >> 2) + 1;  							break;    						case 3:  							f |= (uint)((sect.Item3[methodOffset - sect.Item1 + 1]) << 8);  							size = (f >> 12) * 4;  							uint codeSize = BitConverter.ToUInt32(sect.Item3' (int)(methodOffset - sect.Item1 + 4));  							size += codeSize;  							break;  						default:  							return;  					}  					Erase(sect' methodOffset' size);  				}
Magic Number,Confuser.Core,NativeEraser,C:\repos\yck1509_ConfuserEx\Confuser.Core\NativeEraser.cs,Erase,The following statement contains a magic number: foreach (var sect in sections)  				if (methodOffset >= sect.Item1 && methodOffset - sect.Item1 < sect.Item3.Length) {  					uint f = sect.Item3[methodOffset - sect.Item1];  					uint size;  					switch ((f & 7)) {  						case 2:  						case 6:  							size = (f >> 2) + 1;  							break;    						case 3:  							f |= (uint)((sect.Item3[methodOffset - sect.Item1 + 1]) << 8);  							size = (f >> 12) * 4;  							uint codeSize = BitConverter.ToUInt32(sect.Item3' (int)(methodOffset - sect.Item1 + 4));  							size += codeSize;  							break;  						default:  							return;  					}  					Erase(sect' methodOffset' size);  				}
Magic Number,Confuser.Core,NativeEraser,C:\repos\yck1509_ConfuserEx\Confuser.Core\NativeEraser.cs,Erase,The following statement contains a magic number: foreach (var sect in sections)  				if (methodOffset >= sect.Item1 && methodOffset - sect.Item1 < sect.Item3.Length) {  					uint f = sect.Item3[methodOffset - sect.Item1];  					uint size;  					switch ((f & 7)) {  						case 2:  						case 6:  							size = (f >> 2) + 1;  							break;    						case 3:  							f |= (uint)((sect.Item3[methodOffset - sect.Item1 + 1]) << 8);  							size = (f >> 12) * 4;  							uint codeSize = BitConverter.ToUInt32(sect.Item3' (int)(methodOffset - sect.Item1 + 4));  							size += codeSize;  							break;  						default:  							return;  					}  					Erase(sect' methodOffset' size);  				}
Magic Number,Confuser.Core,NativeEraser,C:\repos\yck1509_ConfuserEx\Confuser.Core\NativeEraser.cs,Erase,The following statement contains a magic number: foreach (var sect in sections)  				if (methodOffset >= sect.Item1 && methodOffset - sect.Item1 < sect.Item3.Length) {  					uint f = sect.Item3[methodOffset - sect.Item1];  					uint size;  					switch ((f & 7)) {  						case 2:  						case 6:  							size = (f >> 2) + 1;  							break;    						case 3:  							f |= (uint)((sect.Item3[methodOffset - sect.Item1 + 1]) << 8);  							size = (f >> 12) * 4;  							uint codeSize = BitConverter.ToUInt32(sect.Item3' (int)(methodOffset - sect.Item1 + 4));  							size += codeSize;  							break;  						default:  							return;  					}  					Erase(sect' methodOffset' size);  				}
Magic Number,Confuser.Core,NativeEraser,C:\repos\yck1509_ConfuserEx\Confuser.Core\NativeEraser.cs,Erase,The following statement contains a magic number: foreach (var sect in sections)  				if (methodOffset >= sect.Item1 && methodOffset - sect.Item1 < sect.Item3.Length) {  					uint f = sect.Item3[methodOffset - sect.Item1];  					uint size;  					switch ((f & 7)) {  						case 2:  						case 6:  							size = (f >> 2) + 1;  							break;    						case 3:  							f |= (uint)((sect.Item3[methodOffset - sect.Item1 + 1]) << 8);  							size = (f >> 12) * 4;  							uint codeSize = BitConverter.ToUInt32(sect.Item3' (int)(methodOffset - sect.Item1 + 4));  							size += codeSize;  							break;  						default:  							return;  					}  					Erase(sect' methodOffset' size);  				}
Magic Number,Confuser.Core,NativeEraser,C:\repos\yck1509_ConfuserEx\Confuser.Core\NativeEraser.cs,Erase,The following statement contains a magic number: foreach (var sect in sections)  				if (methodOffset >= sect.Item1 && methodOffset - sect.Item1 < sect.Item3.Length) {  					uint f = sect.Item3[methodOffset - sect.Item1];  					uint size;  					switch ((f & 7)) {  						case 2:  						case 6:  							size = (f >> 2) + 1;  							break;    						case 3:  							f |= (uint)((sect.Item3[methodOffset - sect.Item1 + 1]) << 8);  							size = (f >> 12) * 4;  							uint codeSize = BitConverter.ToUInt32(sect.Item3' (int)(methodOffset - sect.Item1 + 4));  							size += codeSize;  							break;  						default:  							return;  					}  					Erase(sect' methodOffset' size);  				}
Magic Number,Confuser.Core,NativeEraser,C:\repos\yck1509_ConfuserEx\Confuser.Core\NativeEraser.cs,Erase,The following statement contains a magic number: foreach (var sect in sections)  				if (methodOffset >= sect.Item1 && methodOffset - sect.Item1 < sect.Item3.Length) {  					uint f = sect.Item3[methodOffset - sect.Item1];  					uint size;  					switch ((f & 7)) {  						case 2:  						case 6:  							size = (f >> 2) + 1;  							break;    						case 3:  							f |= (uint)((sect.Item3[methodOffset - sect.Item1 + 1]) << 8);  							size = (f >> 12) * 4;  							uint codeSize = BitConverter.ToUInt32(sect.Item3' (int)(methodOffset - sect.Item1 + 4));  							size += codeSize;  							break;  						default:  							return;  					}  					Erase(sect' methodOffset' size);  				}
Magic Number,Confuser.Core,ObfAttrMarker,C:\repos\yck1509_ConfuserEx\Confuser.Core\ObfAttrMarker.cs,ReadObfuscationAttributes,The following statement contains a magic number: for (int i = item.CustomAttributes.Count - 1; i >= 0; i--) {  				var ca = item.CustomAttributes[i];  				if (ca.TypeFullName != "System.Reflection.ObfuscationAttribute")  					continue;    				var info = new ObfuscationAttributeInfo();  				int? order = null;    				info.Owner = item;  				bool strip = true;  				foreach (var prop in ca.Properties) {  					switch (prop.Name) {  						case "ApplyToMembers":  							Debug.Assert(prop.Type.ElementType == ElementType.Boolean);  							info.ApplyToMembers = (bool)prop.Value;  							break;    						case "Exclude":  							Debug.Assert(prop.Type.ElementType == ElementType.Boolean);  							info.Exclude = (bool)prop.Value;  							break;    						case "StripAfterObfuscation":  							Debug.Assert(prop.Type.ElementType == ElementType.Boolean);  							strip = (bool)prop.Value;  							break;    						case "Feature":  							Debug.Assert(prop.Type.ElementType == ElementType.String);  							string feature = (UTF8String)prop.Value;    							var match = OrderPattern.Match(feature);  							if (match.Success) {  								var orderStr = match.Groups[1].Value;  								var f = match.Groups[2].Value;  								int o;  								if (!int.TryParse(orderStr' out o))  									throw new NotSupportedException(string.Format("Failed to parse feature '{0}' in {1} "' feature' item));  								order = o;  								feature = f;  							}    							int sepIndex = feature.IndexOf(':');  							if (sepIndex == -1) {  								info.FeatureName = "";  								info.FeatureValue = feature;  							}  							else {  								info.FeatureName = feature.Substring(0' sepIndex);  								info.FeatureValue = feature.Substring(sepIndex + 1);  							}  							break;    						default:  							throw new NotSupportedException("Unsupported property: " + prop.Name);  					}  				}  				if (strip)  					item.CustomAttributes.RemoveAt(i);    				ret.Add(Tuple.Create(order' info));  			}
Magic Number,Confuser.Core,Utils,C:\repos\yck1509_ConfuserEx\Confuser.Core\Utils.cs,EncodeString,The following statement contains a magic number: for (int i = 1; i < buff.Length; i++) {  				current = (current << 8) + buff[i];  				while (current >= charset.Length) {  					ret.Append(charset[current % charset.Length]);  					current /= charset.Length;  				}  			}
Magic Number,Confuser.Core,Utils,C:\repos\yck1509_ConfuserEx\Confuser.Core\Utils.cs,ToHexString,The following statement contains a magic number: var ret = new char[buff.Length * 2];
Magic Number,Confuser.Core,Utils,C:\repos\yck1509_ConfuserEx\Confuser.Core\Utils.cs,ToHexString,The following statement contains a magic number: foreach (byte val in buff) {  				ret[i++] = hexCharset[val >> 4];  				ret[i++] = hexCharset[val & 0xf];  			}
Magic Number,SevenZip,CRC,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Common\CRC.cs,CRC,The following statement contains a magic number: Table = new uint[256];
Magic Number,SevenZip,CRC,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Common\CRC.cs,CRC,The following statement contains a magic number: for (uint i = 0; i < 256; i++) {  				uint r = i;  				for (int j = 0; j < 8; j++)  					if ((r & 1) != 0)  						r = (r >> 1) ^ kPoly;  					else  						r >>= 1;  				Table[i] = r;  			}
Magic Number,SevenZip,CRC,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Common\CRC.cs,CRC,The following statement contains a magic number: for (uint i = 0; i < 256; i++) {  				uint r = i;  				for (int j = 0; j < 8; j++)  					if ((r & 1) != 0)  						r = (r >> 1) ^ kPoly;  					else  						r >>= 1;  				Table[i] = r;  			}
Magic Number,SevenZip,CRC,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Common\CRC.cs,UpdateByte,The following statement contains a magic number: _value = Table[(((byte)(_value)) ^ b)] ^ (_value >> 8);
Magic Number,SevenZip,CRC,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Common\CRC.cs,Update,The following statement contains a magic number: for (uint i = 0; i < size; i++)  				_value = Table[(((byte)(_value)) ^ data[offset + i])] ^ (_value >> 8);
Magic Number,SevenZip.Compression.LZMA,State,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaBase.cs,UpdateChar,The following statement contains a magic number: if (Index < 4) Index = 0;  				else if (Index < 10) Index -= 3;  				else Index -= 6;
Magic Number,SevenZip.Compression.LZMA,State,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaBase.cs,UpdateChar,The following statement contains a magic number: if (Index < 4) Index = 0;  				else if (Index < 10) Index -= 3;  				else Index -= 6;
Magic Number,SevenZip.Compression.LZMA,State,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaBase.cs,UpdateChar,The following statement contains a magic number: if (Index < 4) Index = 0;  				else if (Index < 10) Index -= 3;  				else Index -= 6;
Magic Number,SevenZip.Compression.LZMA,State,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaBase.cs,UpdateChar,The following statement contains a magic number: if (Index < 4) Index = 0;  				else if (Index < 10) Index -= 3;  				else Index -= 6;
Magic Number,SevenZip.Compression.LZMA,State,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaBase.cs,UpdateMatch,The following statement contains a magic number: Index = (uint)(Index < 7 ? 7 : 10);
Magic Number,SevenZip.Compression.LZMA,State,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaBase.cs,UpdateMatch,The following statement contains a magic number: Index = (uint)(Index < 7 ? 7 : 10);
Magic Number,SevenZip.Compression.LZMA,State,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaBase.cs,UpdateMatch,The following statement contains a magic number: Index = (uint)(Index < 7 ? 7 : 10);
Magic Number,SevenZip.Compression.LZMA,State,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaBase.cs,UpdateRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 8 : 11);
Magic Number,SevenZip.Compression.LZMA,State,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaBase.cs,UpdateRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 8 : 11);
Magic Number,SevenZip.Compression.LZMA,State,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaBase.cs,UpdateRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 8 : 11);
Magic Number,SevenZip.Compression.LZMA,State,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaBase.cs,UpdateShortRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 9 : 11);
Magic Number,SevenZip.Compression.LZMA,State,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaBase.cs,UpdateShortRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 9 : 11);
Magic Number,SevenZip.Compression.LZMA,State,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaBase.cs,UpdateShortRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 9 : 11);
Magic Number,SevenZip.Compression.LZMA,State,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaBase.cs,IsCharState,The following statement contains a magic number: return Index < 7;
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaDecoder.cs,Code,The following statement contains a magic number: while (nowPos64 < outSize64) {  				// UInt64 next = Math.Min(nowPos64 + (1 << 18)' outSize64);  				// while(nowPos64 < next)  				{  					uint posState = (uint)nowPos64 & m_PosStateMask;  					if (m_IsMatchDecoders[(state.Index << Base.kNumPosStatesBitsMax) + posState].Decode(m_RangeDecoder) == 0) {  						byte b;  						byte prevByte = m_OutWindow.GetByte(0);  						if (!state.IsCharState())  							b = m_LiteralDecoder.DecodeWithMatchByte(m_RangeDecoder'  							                                         (uint)nowPos64' prevByte' m_OutWindow.GetByte(rep0));  						else  							b = m_LiteralDecoder.DecodeNormal(m_RangeDecoder' (uint)nowPos64' prevByte);  						m_OutWindow.PutByte(b);  						state.UpdateChar();  						nowPos64++;  					}  					else {  						uint len;  						if (m_IsRepDecoders[state.Index].Decode(m_RangeDecoder) == 1) {  							if (m_IsRepG0Decoders[state.Index].Decode(m_RangeDecoder) == 0) {  								if (m_IsRep0LongDecoders[(state.Index << Base.kNumPosStatesBitsMax) + posState].Decode(m_RangeDecoder) == 0) {  									state.UpdateShortRep();  									m_OutWindow.PutByte(m_OutWindow.GetByte(rep0));  									nowPos64++;  									continue;  								}  							}  							else {  								UInt32 distance;  								if (m_IsRepG1Decoders[state.Index].Decode(m_RangeDecoder) == 0) {  									distance = rep1;  								}  								else {  									if (m_IsRepG2Decoders[state.Index].Decode(m_RangeDecoder) == 0)  										distance = rep2;  									else {  										distance = rep3;  										rep3 = rep2;  									}  									rep2 = rep1;  								}  								rep1 = rep0;  								rep0 = distance;  							}  							len = m_RepLenDecoder.Decode(m_RangeDecoder' posState) + Base.kMatchMinLen;  							state.UpdateRep();  						}  						else {  							rep3 = rep2;  							rep2 = rep1;  							rep1 = rep0;  							len = Base.kMatchMinLen + m_LenDecoder.Decode(m_RangeDecoder' posState);  							state.UpdateMatch();  							uint posSlot = m_PosSlotDecoder[Base.GetLenToPosState(len)].Decode(m_RangeDecoder);  							if (posSlot >= Base.kStartPosModelIndex) {  								var numDirectBits = (int)((posSlot >> 1) - 1);  								rep0 = ((2 | (posSlot & 1)) << numDirectBits);  								if (posSlot < Base.kEndPosModelIndex)  									rep0 += BitTreeDecoder.ReverseDecode(m_PosDecoders'  									                                     rep0 - posSlot - 1' m_RangeDecoder' numDirectBits);  								else {  									rep0 += (m_RangeDecoder.DecodeDirectBits(  										numDirectBits - Base.kNumAlignBits) << Base.kNumAlignBits);  									rep0 += m_PosAlignDecoder.ReverseDecode(m_RangeDecoder);  								}  							}  							else  								rep0 = posSlot;  						}  						if (rep0 >= m_OutWindow.TrainSize + nowPos64 || rep0 >= m_DictionarySizeCheck) {  							if (rep0 == 0xFFFFFFFF)  								break;  							throw new DataErrorException();  						}  						m_OutWindow.CopyBlock(rep0' len);  						nowPos64 += len;  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: if (properties.Length < 5)  				throw new InvalidParamException();
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: int lc = properties[0] % 9;
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: int remainder = properties[0] / 9;
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: int lp = remainder % 5;
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: int pb = remainder / 5;
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: for (int i = 0; i < 4; i++)  				dictionarySize += ((UInt32)(properties[1 + i])) << (i * 8);
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: for (int i = 0; i < 4; i++)  				dictionarySize += ((UInt32)(properties[1 + i])) << (i * 8);
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaDecoder.cs,SetDictionarySize,The following statement contains a magic number: if (m_DictionarySize != dictionarySize) {  				m_DictionarySize = dictionarySize;  				m_DictionarySizeCheck = Math.Max(m_DictionarySize' 1);  				uint blockSize = Math.Max(m_DictionarySizeCheck' (1 << 12));  				m_OutWindow.Create(blockSize);  			}
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaDecoder.cs,SetLiteralProperties,The following statement contains a magic number: if (lp > 8)  				throw new InvalidParamException();
Magic Number,SevenZip.Compression.LZMA,Decoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaDecoder.cs,SetLiteralProperties,The following statement contains a magic number: if (lc > 8)  				throw new InvalidParamException();
Magic Number,SevenZip.Compression.LZMA,LiteralDecoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaDecoder.cs,GetState,The following statement contains a magic number: return ((pos & m_PosMask) << m_NumPrevBits) + (uint)(prevByte >> (8 - m_NumPrevBits));
Magic Number,SevenZip.Compression.LZMA,Decoder2,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaDecoder.cs,DecodeWithMatchByte,The following statement contains a magic number: do {  						uint matchBit = (uint)(matchByte >> 7) & 1;  						matchByte <<= 1;  						uint bit = m_Decoders[((1 + matchBit) << 8) + symbol].Decode(rangeDecoder);  						symbol = (symbol << 1) | bit;  						if (matchBit != bit) {  							while (symbol < 0x100)  								symbol = (symbol << 1) | m_Decoders[symbol].Decode(rangeDecoder);  							break;  						}  					} while (symbol < 0x100);
Magic Number,SevenZip.Compression.LZMA,Decoder2,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaDecoder.cs,DecodeWithMatchByte,The following statement contains a magic number: do {  						uint matchBit = (uint)(matchByte >> 7) & 1;  						matchByte <<= 1;  						uint bit = m_Decoders[((1 + matchBit) << 8) + symbol].Decode(rangeDecoder);  						symbol = (symbol << 1) | bit;  						if (matchBit != bit) {  							while (symbol < 0x100)  								symbol = (symbol << 1) | m_Decoders[symbol].Decode(rangeDecoder);  							break;  						}  					} while (symbol < 0x100);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,Encoder,The following statement contains a magic number: const Byte kFastSlots = 22;
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,Encoder,The following statement contains a magic number: int c = 2;
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,Encoder,The following statement contains a magic number: for (Byte slotFast = 2; slotFast < kFastSlots; slotFast++) {  				UInt32 k = ((UInt32)1 << ((slotFast >> 1) - 1));  				for (UInt32 j = 0; j < k; j++' c++)  					g_FastPos[c] = slotFast;  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,SetCoderProperties,The following statement contains a magic number: for (UInt32 i = 0; i < properties.Length; i++) {  				object prop = properties[i];  				switch (propIDs[i]) {  					case CoderPropID.NumFastBytes: {  						if (!(prop is Int32))  							throw new InvalidParamException();  						var numFastBytes = (Int32)prop;  						if (numFastBytes < 5 || numFastBytes > Base.kMatchMaxLen)  							throw new InvalidParamException();  						_numFastBytes = (UInt32)numFastBytes;  						break;  					}  					case CoderPropID.Algorithm: {  						/*                              if (!(prop is Int32))                                  throw new InvalidParamException();                              Int32 maximize = (Int32)prop;                              _fastMode = (maximize == 0);                              _maxMode = (maximize >= 2);                              */  						break;  					}  					case CoderPropID.MatchFinder: {  						if (!(prop is String))  							throw new InvalidParamException();  						EMatchFinderType matchFinderIndexPrev = _matchFinderType;  						int m = FindMatchFinder(((string)prop).ToUpper());  						if (m < 0)  							throw new InvalidParamException();  						_matchFinderType = (EMatchFinderType)m;  						if (_matchFinder != null && matchFinderIndexPrev != _matchFinderType) {  							_dictionarySizePrev = 0xFFFFFFFF;  							_matchFinder = null;  						}  						break;  					}  					case CoderPropID.DictionarySize: {  						const int kDicLogSizeMaxCompress = 30;  						if (!(prop is Int32))  							throw new InvalidParamException();  						;  						var dictionarySize = (Int32)prop;  						if (dictionarySize < (UInt32)(1 << Base.kDicLogSizeMin) ||  						    dictionarySize > (UInt32)(1 << kDicLogSizeMaxCompress))  							throw new InvalidParamException();  						_dictionarySize = (UInt32)dictionarySize;  						int dicLogSize;  						for (dicLogSize = 0; dicLogSize < (UInt32)kDicLogSizeMaxCompress; dicLogSize++)  							if (dictionarySize <= ((UInt32)(1) << dicLogSize))  								break;  						_distTableSize = (UInt32)dicLogSize * 2;  						break;  					}  					case CoderPropID.PosStateBits: {  						if (!(prop is Int32))  							throw new InvalidParamException();  						var v = (Int32)prop;  						if (v < 0 || v > (UInt32)Base.kNumPosStatesBitsEncodingMax)  							throw new InvalidParamException();  						_posStateBits = v;  						_posStateMask = (((UInt32)1) << _posStateBits) - 1;  						break;  					}  					case CoderPropID.LitPosBits: {  						if (!(prop is Int32))  							throw new InvalidParamException();  						var v = (Int32)prop;  						if (v < 0 || v > Base.kNumLitPosStatesBitsEncodingMax)  							throw new InvalidParamException();  						_numLiteralPosStateBits = v;  						break;  					}  					case CoderPropID.LitContextBits: {  						if (!(prop is Int32))  							throw new InvalidParamException();  						var v = (Int32)prop;  						if (v < 0 || v > Base.kNumLitContextBitsMax)  							throw new InvalidParamException();  						;  						_numLiteralContextBits = v;  						break;  					}  					case CoderPropID.EndMarker: {  						if (!(prop is Boolean))  							throw new InvalidParamException();  						SetWriteEndMarkerMode((Boolean)prop);  						break;  					}  					default:  						throw new InvalidParamException();  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,SetCoderProperties,The following statement contains a magic number: for (UInt32 i = 0; i < properties.Length; i++) {  				object prop = properties[i];  				switch (propIDs[i]) {  					case CoderPropID.NumFastBytes: {  						if (!(prop is Int32))  							throw new InvalidParamException();  						var numFastBytes = (Int32)prop;  						if (numFastBytes < 5 || numFastBytes > Base.kMatchMaxLen)  							throw new InvalidParamException();  						_numFastBytes = (UInt32)numFastBytes;  						break;  					}  					case CoderPropID.Algorithm: {  						/*                              if (!(prop is Int32))                                  throw new InvalidParamException();                              Int32 maximize = (Int32)prop;                              _fastMode = (maximize == 0);                              _maxMode = (maximize >= 2);                              */  						break;  					}  					case CoderPropID.MatchFinder: {  						if (!(prop is String))  							throw new InvalidParamException();  						EMatchFinderType matchFinderIndexPrev = _matchFinderType;  						int m = FindMatchFinder(((string)prop).ToUpper());  						if (m < 0)  							throw new InvalidParamException();  						_matchFinderType = (EMatchFinderType)m;  						if (_matchFinder != null && matchFinderIndexPrev != _matchFinderType) {  							_dictionarySizePrev = 0xFFFFFFFF;  							_matchFinder = null;  						}  						break;  					}  					case CoderPropID.DictionarySize: {  						const int kDicLogSizeMaxCompress = 30;  						if (!(prop is Int32))  							throw new InvalidParamException();  						;  						var dictionarySize = (Int32)prop;  						if (dictionarySize < (UInt32)(1 << Base.kDicLogSizeMin) ||  						    dictionarySize > (UInt32)(1 << kDicLogSizeMaxCompress))  							throw new InvalidParamException();  						_dictionarySize = (UInt32)dictionarySize;  						int dicLogSize;  						for (dicLogSize = 0; dicLogSize < (UInt32)kDicLogSizeMaxCompress; dicLogSize++)  							if (dictionarySize <= ((UInt32)(1) << dicLogSize))  								break;  						_distTableSize = (UInt32)dicLogSize * 2;  						break;  					}  					case CoderPropID.PosStateBits: {  						if (!(prop is Int32))  							throw new InvalidParamException();  						var v = (Int32)prop;  						if (v < 0 || v > (UInt32)Base.kNumPosStatesBitsEncodingMax)  							throw new InvalidParamException();  						_posStateBits = v;  						_posStateMask = (((UInt32)1) << _posStateBits) - 1;  						break;  					}  					case CoderPropID.LitPosBits: {  						if (!(prop is Int32))  							throw new InvalidParamException();  						var v = (Int32)prop;  						if (v < 0 || v > Base.kNumLitPosStatesBitsEncodingMax)  							throw new InvalidParamException();  						_numLiteralPosStateBits = v;  						break;  					}  					case CoderPropID.LitContextBits: {  						if (!(prop is Int32))  							throw new InvalidParamException();  						var v = (Int32)prop;  						if (v < 0 || v > Base.kNumLitContextBitsMax)  							throw new InvalidParamException();  						;  						_numLiteralContextBits = v;  						break;  					}  					case CoderPropID.EndMarker: {  						if (!(prop is Boolean))  							throw new InvalidParamException();  						SetWriteEndMarkerMode((Boolean)prop);  						break;  					}  					default:  						throw new InvalidParamException();  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,SetCoderProperties,The following statement contains a magic number: for (UInt32 i = 0; i < properties.Length; i++) {  				object prop = properties[i];  				switch (propIDs[i]) {  					case CoderPropID.NumFastBytes: {  						if (!(prop is Int32))  							throw new InvalidParamException();  						var numFastBytes = (Int32)prop;  						if (numFastBytes < 5 || numFastBytes > Base.kMatchMaxLen)  							throw new InvalidParamException();  						_numFastBytes = (UInt32)numFastBytes;  						break;  					}  					case CoderPropID.Algorithm: {  						/*                              if (!(prop is Int32))                                  throw new InvalidParamException();                              Int32 maximize = (Int32)prop;                              _fastMode = (maximize == 0);                              _maxMode = (maximize >= 2);                              */  						break;  					}  					case CoderPropID.MatchFinder: {  						if (!(prop is String))  							throw new InvalidParamException();  						EMatchFinderType matchFinderIndexPrev = _matchFinderType;  						int m = FindMatchFinder(((string)prop).ToUpper());  						if (m < 0)  							throw new InvalidParamException();  						_matchFinderType = (EMatchFinderType)m;  						if (_matchFinder != null && matchFinderIndexPrev != _matchFinderType) {  							_dictionarySizePrev = 0xFFFFFFFF;  							_matchFinder = null;  						}  						break;  					}  					case CoderPropID.DictionarySize: {  						const int kDicLogSizeMaxCompress = 30;  						if (!(prop is Int32))  							throw new InvalidParamException();  						;  						var dictionarySize = (Int32)prop;  						if (dictionarySize < (UInt32)(1 << Base.kDicLogSizeMin) ||  						    dictionarySize > (UInt32)(1 << kDicLogSizeMaxCompress))  							throw new InvalidParamException();  						_dictionarySize = (UInt32)dictionarySize;  						int dicLogSize;  						for (dicLogSize = 0; dicLogSize < (UInt32)kDicLogSizeMaxCompress; dicLogSize++)  							if (dictionarySize <= ((UInt32)(1) << dicLogSize))  								break;  						_distTableSize = (UInt32)dicLogSize * 2;  						break;  					}  					case CoderPropID.PosStateBits: {  						if (!(prop is Int32))  							throw new InvalidParamException();  						var v = (Int32)prop;  						if (v < 0 || v > (UInt32)Base.kNumPosStatesBitsEncodingMax)  							throw new InvalidParamException();  						_posStateBits = v;  						_posStateMask = (((UInt32)1) << _posStateBits) - 1;  						break;  					}  					case CoderPropID.LitPosBits: {  						if (!(prop is Int32))  							throw new InvalidParamException();  						var v = (Int32)prop;  						if (v < 0 || v > Base.kNumLitPosStatesBitsEncodingMax)  							throw new InvalidParamException();  						_numLiteralPosStateBits = v;  						break;  					}  					case CoderPropID.LitContextBits: {  						if (!(prop is Int32))  							throw new InvalidParamException();  						var v = (Int32)prop;  						if (v < 0 || v > Base.kNumLitContextBitsMax)  							throw new InvalidParamException();  						;  						_numLiteralContextBits = v;  						break;  					}  					case CoderPropID.EndMarker: {  						if (!(prop is Boolean))  							throw new InvalidParamException();  						SetWriteEndMarkerMode((Boolean)prop);  						break;  					}  					default:  						throw new InvalidParamException();  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,WriteCoderProperties,The following statement contains a magic number: properties[0] = (Byte)((_posStateBits * 5 + _numLiteralPosStateBits) * 9 + _numLiteralContextBits);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,WriteCoderProperties,The following statement contains a magic number: properties[0] = (Byte)((_posStateBits * 5 + _numLiteralPosStateBits) * 9 + _numLiteralContextBits);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,WriteCoderProperties,The following statement contains a magic number: for (int i = 0; i < 4; i++)  				properties[1 + i] = (Byte)((_dictionarySize >> (8 * i)) & 0xFF);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,WriteCoderProperties,The following statement contains a magic number: for (int i = 0; i < 4; i++)  				properties[1 + i] = (Byte)((_dictionarySize >> (8 * i)) & 0xFF);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: if (pos < (1 << 11))  				return g_FastPos[pos];
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: if (pos < (1 << 21))  				return (UInt32)(g_FastPos[pos >> 10] + 20);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: if (pos < (1 << 21))  				return (UInt32)(g_FastPos[pos >> 10] + 20);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: if (pos < (1 << 21))  				return (UInt32)(g_FastPos[pos >> 10] + 20);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: return (UInt32)(g_FastPos[pos >> 20] + 40);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: return (UInt32)(g_FastPos[pos >> 20] + 40);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: if (pos < (1 << 17))  				return (UInt32)(g_FastPos[pos >> 6] + 12);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: if (pos < (1 << 17))  				return (UInt32)(g_FastPos[pos >> 6] + 12);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: if (pos < (1 << 17))  				return (UInt32)(g_FastPos[pos >> 6] + 12);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: if (pos < (1 << 27))  				return (UInt32)(g_FastPos[pos >> 16] + 32);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: if (pos < (1 << 27))  				return (UInt32)(g_FastPos[pos >> 16] + 32);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: if (pos < (1 << 27))  				return (UInt32)(g_FastPos[pos >> 16] + 32);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: return (UInt32)(g_FastPos[pos >> 26] + 52);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: return (UInt32)(g_FastPos[pos >> 26] + 52);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,Create,The following statement contains a magic number: if (_matchFinder == null) {  				var bt = new BinTree();  				int numHashBytes = 4;  				if (_matchFinderType == EMatchFinderType.BT2)  					numHashBytes = 2;  				bt.SetType(numHashBytes);  				_matchFinder = bt;  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,Create,The following statement contains a magic number: if (_matchFinder == null) {  				var bt = new BinTree();  				int numHashBytes = 4;  				if (_matchFinderType == EMatchFinderType.BT2)  					numHashBytes = 2;  				bt.SetType(numHashBytes);  				_matchFinder = bt;  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,ReadMatchDistances,The following statement contains a magic number: if (numDistancePairs > 0) {  				lenRes = _matchDistances[numDistancePairs - 2];  				if (lenRes == _numFastBytes)  					lenRes += _matchFinder.GetMatchLen((int)lenRes - 1' _matchDistances[numDistancePairs - 1]'  					                                   Base.kMatchMaxLen - lenRes);  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,GetPureRepPrice,The following statement contains a magic number: if (repIndex == 0) {  				price = _isRepG0[state.Index].GetPrice0();  				price += _isRep0Long[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  			}  			else {  				price = _isRepG0[state.Index].GetPrice1();  				if (repIndex == 1)  					price += _isRepG1[state.Index].GetPrice0();  				else {  					price += _isRepG1[state.Index].GetPrice1();  					price += _isRepG2[state.Index].GetPrice(repIndex - 2);  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (numAvailableBytes < 2) {  				backRes = 0xFFFFFFFF;  				return 1;  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (lenMain < 2 && currentByte != matchByte && repLens[repMaxIndex] < 2) {  				backRes = 0xFFFFFFFF;  				return 1;  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (lenMain < 2 && currentByte != matchByte && repLens[repMaxIndex] < 2) {  				backRes = 0xFFFFFFFF;  				return 1;  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (lenEnd < 2) {  				backRes = _optimum[1].BackPrev;  				return 1;  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: _optimum[0].Backs2 = reps[2];
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: _optimum[0].Backs3 = reps[3];
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: do  				_optimum[len--].Price = kIfinityPrice; while (len >= 2);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: for (i = 0; i < Base.kNumRepDistances; i++) {  				UInt32 repLen = repLens[i];  				if (repLen < 2)  					continue;  				UInt32 price = repMatchPrice + GetPureRepPrice(i' _state' posState);  				do {  					UInt32 curAndLenPrice = price + _repMatchLenEncoder.GetPrice(repLen - 2' posState);  					Optimal optimum = _optimum[repLen];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = 0;  						optimum.BackPrev = i;  						optimum.Prev1IsChar = false;  					}  				} while (--repLen >= 2);  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: for (i = 0; i < Base.kNumRepDistances; i++) {  				UInt32 repLen = repLens[i];  				if (repLen < 2)  					continue;  				UInt32 price = repMatchPrice + GetPureRepPrice(i' _state' posState);  				do {  					UInt32 curAndLenPrice = price + _repMatchLenEncoder.GetPrice(repLen - 2' posState);  					Optimal optimum = _optimum[repLen];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = 0;  						optimum.BackPrev = i;  						optimum.Prev1IsChar = false;  					}  				} while (--repLen >= 2);  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: for (i = 0; i < Base.kNumRepDistances; i++) {  				UInt32 repLen = repLens[i];  				if (repLen < 2)  					continue;  				UInt32 price = repMatchPrice + GetPureRepPrice(i' _state' posState);  				do {  					UInt32 curAndLenPrice = price + _repMatchLenEncoder.GetPrice(repLen - 2' posState);  					Optimal optimum = _optimum[repLen];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = 0;  						optimum.BackPrev = i;  						optimum.Prev1IsChar = false;  					}  				} while (--repLen >= 2);  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: len = ((repLens[0] >= 2) ? repLens[0] + 1 : 2);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: len = ((repLens[0] >= 2) ? repLens[0] + 1 : 2);
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (len <= lenMain) {  				UInt32 offs = 0;  				while (len > _matchDistances[offs])  					offs += 2;  				for (;; len++) {  					UInt32 distance = _matchDistances[offs + 1];  					UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(distance' len' posState);  					Optimal optimum = _optimum[len];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = 0;  						optimum.BackPrev = distance + Base.kNumRepDistances;  						optimum.Prev1IsChar = false;  					}  					if (len == _matchDistances[offs]) {  						offs += 2;  						if (offs == numDistancePairs)  							break;  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (len <= lenMain) {  				UInt32 offs = 0;  				while (len > _matchDistances[offs])  					offs += 2;  				for (;; len++) {  					UInt32 distance = _matchDistances[offs + 1];  					UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(distance' len' posState);  					Optimal optimum = _optimum[len];  					if (curAndLenPrice < optimum.Price) {  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = 0;  						optimum.BackPrev = distance + Base.kNumRepDistances;  						optimum.Prev1IsChar = false;  					}  					if (len == _matchDistances[offs]) {  						offs += 2;  						if (offs == numDistancePairs)  							break;  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes) {  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar) {  					posPrev--;  					if (_optimum[cur].Prev2) {  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1) {  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else {  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2) {  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else {  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances) {  						if (pos == 0) {  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1) {  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2) {  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else {  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else {  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  				                      _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  				                      _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  				                                      GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price) {  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  				    !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price) {  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte) {  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  						                           _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  						                           _isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price) {  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do {  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					} while (--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull) {  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2) {  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =  								repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +  								_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  								_literalEncoder.GetSubCoder(position + lenTest'  								                            _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  								                                                                                        _matchFinder.GetIndexByte((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1))'  								                                                                                        _matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while (lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price) {  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes) {  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen) {  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen;; lenTest++) {  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs]) {  							if (lenTest < numAvailableBytesFull) {  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2) {  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  									                            _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									                            _literalEncoder.GetSubCoder(position + lenTest'  									                                                        _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  									                                            GetPrice(true'  									                                                     _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  									                                                     _matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price) {  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes) {  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar) {  					posPrev--;  					if (_optimum[cur].Prev2) {  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1) {  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else {  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2) {  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else {  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances) {  						if (pos == 0) {  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1) {  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2) {  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else {  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else {  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  				                      _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  				                      _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  				                                      GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price) {  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  				    !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price) {  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte) {  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  						                           _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  						                           _isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price) {  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do {  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					} while (--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull) {  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2) {  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =  								repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +  								_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  								_literalEncoder.GetSubCoder(position + lenTest'  								                            _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  								                                                                                        _matchFinder.GetIndexByte((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1))'  								                                                                                        _matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while (lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price) {  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes) {  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen) {  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen;; lenTest++) {  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs]) {  							if (lenTest < numAvailableBytesFull) {  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2) {  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  									                            _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									                            _literalEncoder.GetSubCoder(position + lenTest'  									                                                        _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  									                                            GetPrice(true'  									                                                     _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  									                                                     _matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price) {  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes) {  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar) {  					posPrev--;  					if (_optimum[cur].Prev2) {  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1) {  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else {  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2) {  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else {  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances) {  						if (pos == 0) {  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1) {  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2) {  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else {  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else {  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  				                      _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  				                      _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  				                                      GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price) {  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  				    !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price) {  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte) {  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  						                           _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  						                           _isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price) {  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do {  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					} while (--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull) {  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2) {  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =  								repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +  								_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  								_literalEncoder.GetSubCoder(position + lenTest'  								                            _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  								                                                                                        _matchFinder.GetIndexByte((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1))'  								                                                                                        _matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while (lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price) {  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes) {  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen) {  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen;; lenTest++) {  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs]) {  							if (lenTest < numAvailableBytesFull) {  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2) {  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  									                            _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									                            _literalEncoder.GetSubCoder(position + lenTest'  									                                                        _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  									                                            GetPrice(true'  									                                                     _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  									                                                     _matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price) {  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes) {  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar) {  					posPrev--;  					if (_optimum[cur].Prev2) {  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1) {  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else {  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2) {  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else {  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances) {  						if (pos == 0) {  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1) {  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2) {  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else {  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else {  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  				                      _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  				                      _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  				                                      GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price) {  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  				    !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price) {  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte) {  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  						                           _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  						                           _isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price) {  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do {  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					} while (--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull) {  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2) {  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =  								repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +  								_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  								_literalEncoder.GetSubCoder(position + lenTest'  								                            _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  								                                                                                        _matchFinder.GetIndexByte((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1))'  								                                                                                        _matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while (lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price) {  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes) {  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen) {  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen;; lenTest++) {  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs]) {  							if (lenTest < numAvailableBytesFull) {  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2) {  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  									                            _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									                            _literalEncoder.GetSubCoder(position + lenTest'  									                                                        _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  									                                            GetPrice(true'  									                                                     _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  									                                                     _matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price) {  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes) {  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar) {  					posPrev--;  					if (_optimum[cur].Prev2) {  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1) {  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else {  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2) {  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else {  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances) {  						if (pos == 0) {  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1) {  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2) {  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else {  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else {  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  				                      _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  				                      _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  				                                      GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price) {  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  				    !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price) {  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte) {  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  						                           _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  						                           _isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price) {  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do {  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					} while (--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull) {  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2) {  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =  								repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +  								_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  								_literalEncoder.GetSubCoder(position + lenTest'  								                            _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  								                                                                                        _matchFinder.GetIndexByte((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1))'  								                                                                                        _matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while (lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price) {  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes) {  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen) {  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen;; lenTest++) {  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs]) {  							if (lenTest < numAvailableBytesFull) {  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2) {  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  									                            _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									                            _literalEncoder.GetSubCoder(position + lenTest'  									                                                        _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  									                                            GetPrice(true'  									                                                     _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  									                                                     _matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price) {  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes) {  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar) {  					posPrev--;  					if (_optimum[cur].Prev2) {  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1) {  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else {  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2) {  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else {  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances) {  						if (pos == 0) {  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1) {  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2) {  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else {  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else {  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  				                      _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  				                      _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  				                                      GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price) {  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  				    !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price) {  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte) {  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  						                           _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  						                           _isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price) {  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do {  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					} while (--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull) {  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2) {  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =  								repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +  								_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  								_literalEncoder.GetSubCoder(position + lenTest'  								                            _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  								                                                                                        _matchFinder.GetIndexByte((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1))'  								                                                                                        _matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while (lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price) {  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes) {  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen) {  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen;; lenTest++) {  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs]) {  							if (lenTest < numAvailableBytesFull) {  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2) {  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  									                            _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									                            _literalEncoder.GetSubCoder(position + lenTest'  									                                                        _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  									                                            GetPrice(true'  									                                                     _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  									                                                     _matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price) {  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes) {  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar) {  					posPrev--;  					if (_optimum[cur].Prev2) {  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1) {  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else {  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2) {  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else {  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances) {  						if (pos == 0) {  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1) {  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2) {  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else {  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else {  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  				                      _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  				                      _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  				                                      GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price) {  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  				    !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price) {  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte) {  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  						                           _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  						                           _isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price) {  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do {  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					} while (--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull) {  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2) {  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =  								repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +  								_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  								_literalEncoder.GetSubCoder(position + lenTest'  								                            _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  								                                                                                        _matchFinder.GetIndexByte((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1))'  								                                                                                        _matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while (lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price) {  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes) {  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen) {  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen;; lenTest++) {  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs]) {  							if (lenTest < numAvailableBytesFull) {  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2) {  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  									                            _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									                            _literalEncoder.GetSubCoder(position + lenTest'  									                                                        _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  									                                            GetPrice(true'  									                                                     _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  									                                                     _matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price) {  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes) {  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar) {  					posPrev--;  					if (_optimum[cur].Prev2) {  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1) {  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else {  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2) {  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else {  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances) {  						if (pos == 0) {  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1) {  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2) {  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else {  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else {  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  				                      _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  				                      _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  				                                      GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price) {  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  				    !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price) {  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte) {  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  						                           _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  						                           _isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price) {  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do {  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					} while (--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull) {  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2) {  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =  								repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +  								_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  								_literalEncoder.GetSubCoder(position + lenTest'  								                            _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  								                                                                                        _matchFinder.GetIndexByte((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1))'  								                                                                                        _matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while (lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price) {  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes) {  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen) {  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen;; lenTest++) {  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs]) {  							if (lenTest < numAvailableBytesFull) {  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2) {  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  									                            _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									                            _literalEncoder.GetSubCoder(position + lenTest'  									                                                        _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  									                                            GetPrice(true'  									                                                     _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  									                                                     _matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price) {  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes) {  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar) {  					posPrev--;  					if (_optimum[cur].Prev2) {  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1) {  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else {  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2) {  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else {  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances) {  						if (pos == 0) {  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1) {  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2) {  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else {  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else {  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  				                      _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  				                      _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  				                                      GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price) {  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  				    !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price) {  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte) {  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  						                           _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  						                           _isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price) {  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do {  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					} while (--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull) {  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2) {  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =  								repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +  								_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  								_literalEncoder.GetSubCoder(position + lenTest'  								                            _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  								                                                                                        _matchFinder.GetIndexByte((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1))'  								                                                                                        _matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while (lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price) {  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes) {  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen) {  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen;; lenTest++) {  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs]) {  							if (lenTest < numAvailableBytesFull) {  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2) {  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  									                            _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									                            _literalEncoder.GetSubCoder(position + lenTest'  									                                                        _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  									                                            GetPrice(true'  									                                                     _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  									                                                     _matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price) {  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes) {  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar) {  					posPrev--;  					if (_optimum[cur].Prev2) {  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1) {  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else {  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2) {  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else {  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances) {  						if (pos == 0) {  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1) {  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2) {  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else {  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else {  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  				                      _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  				                      _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  				                                      GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price) {  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  				    !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price) {  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte) {  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  						                           _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  						                           _isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price) {  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do {  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					} while (--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull) {  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2) {  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =  								repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +  								_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  								_literalEncoder.GetSubCoder(position + lenTest'  								                            _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  								                                                                                        _matchFinder.GetIndexByte((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1))'  								                                                                                        _matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while (lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price) {  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes) {  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen) {  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen;; lenTest++) {  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs]) {  							if (lenTest < numAvailableBytesFull) {  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2) {  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  									                            _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									                            _literalEncoder.GetSubCoder(position + lenTest'  									                                                        _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  									                                            GetPrice(true'  									                                                     _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  									                                                     _matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price) {  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes) {  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar) {  					posPrev--;  					if (_optimum[cur].Prev2) {  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1) {  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else {  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2) {  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else {  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances) {  						if (pos == 0) {  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1) {  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2) {  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else {  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else {  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  				                      _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  				                      _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  				                                      GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price) {  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  				    !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price) {  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte) {  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  						                           _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  						                           _isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price) {  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do {  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					} while (--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull) {  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2) {  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =  								repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +  								_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  								_literalEncoder.GetSubCoder(position + lenTest'  								                            _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  								                                                                                        _matchFinder.GetIndexByte((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1))'  								                                                                                        _matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while (lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price) {  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes) {  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen) {  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen;; lenTest++) {  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs]) {  							if (lenTest < numAvailableBytesFull) {  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2) {  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  									                            _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									                            _literalEncoder.GetSubCoder(position + lenTest'  									                                                        _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  									                                            GetPrice(true'  									                                                     _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  									                                                     _matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price) {  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes) {  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar) {  					posPrev--;  					if (_optimum[cur].Prev2) {  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1) {  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else {  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2) {  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else {  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances) {  						if (pos == 0) {  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1) {  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2) {  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else {  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else {  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  				                      _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  				                      _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  				                                      GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price) {  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  				    !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price) {  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte) {  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  						                           _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  						                           _isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price) {  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do {  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					} while (--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull) {  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2) {  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =  								repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +  								_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  								_literalEncoder.GetSubCoder(position + lenTest'  								                            _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  								                                                                                        _matchFinder.GetIndexByte((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1))'  								                                                                                        _matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while (lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price) {  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes) {  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen) {  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen;; lenTest++) {  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs]) {  							if (lenTest < numAvailableBytesFull) {  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2) {  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  									                            _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									                            _literalEncoder.GetSubCoder(position + lenTest'  									                                                        _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  									                                            GetPrice(true'  									                                                     _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  									                                                     _matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price) {  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes) {  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar) {  					posPrev--;  					if (_optimum[cur].Prev2) {  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1) {  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else {  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2) {  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else {  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances) {  						if (pos == 0) {  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1) {  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2) {  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else {  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else {  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  				                      _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  				                      _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  				                                      GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price) {  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  				    !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price) {  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte) {  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  						                           _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  						                           _isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price) {  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do {  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					} while (--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull) {  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2) {  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =  								repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +  								_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  								_literalEncoder.GetSubCoder(position + lenTest'  								                            _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  								                                                                                        _matchFinder.GetIndexByte((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1))'  								                                                                                        _matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while (lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price) {  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes) {  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen) {  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen;; lenTest++) {  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs]) {  							if (lenTest < numAvailableBytesFull) {  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2) {  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  									                            _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									                            _literalEncoder.GetSubCoder(position + lenTest'  									                                                        _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  									                                            GetPrice(true'  									                                                     _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  									                                                     _matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price) {  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes) {  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar) {  					posPrev--;  					if (_optimum[cur].Prev2) {  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1) {  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else {  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2) {  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else {  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances) {  						if (pos == 0) {  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1) {  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2) {  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else {  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else {  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  				                      _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  				                      _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  				                                      GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price) {  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  				    !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price) {  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte) {  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  						                           _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  						                           _isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price) {  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do {  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					} while (--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull) {  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2) {  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =  								repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +  								_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  								_literalEncoder.GetSubCoder(position + lenTest'  								                            _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  								                                                                                        _matchFinder.GetIndexByte((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1))'  								                                                                                        _matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while (lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price) {  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes) {  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen) {  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen;; lenTest++) {  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs]) {  							if (lenTest < numAvailableBytesFull) {  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2) {  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  									                            _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									                            _literalEncoder.GetSubCoder(position + lenTest'  									                                                        _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  									                                            GetPrice(true'  									                                                     _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  									                                                     _matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price) {  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes) {  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar) {  					posPrev--;  					if (_optimum[cur].Prev2) {  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1) {  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else {  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2) {  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else {  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances) {  						if (pos == 0) {  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1) {  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2) {  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else {  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else {  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  				                      _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  				                      _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  				                                      GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price) {  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  				    !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price) {  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte) {  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  						                           _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  						                           _isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price) {  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do {  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					} while (--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull) {  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2) {  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =  								repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +  								_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  								_literalEncoder.GetSubCoder(position + lenTest'  								                            _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  								                                                                                        _matchFinder.GetIndexByte((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1))'  								                                                                                        _matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while (lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price) {  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes) {  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen) {  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen;; lenTest++) {  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs]) {  							if (lenTest < numAvailableBytesFull) {  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2) {  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  									                            _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									                            _literalEncoder.GetSubCoder(position + lenTest'  									                                                        _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  									                                            GetPrice(true'  									                                                     _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  									                                                     _matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price) {  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes) {  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar) {  					posPrev--;  					if (_optimum[cur].Prev2) {  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1) {  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else {  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2) {  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else {  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances) {  						if (pos == 0) {  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1) {  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2) {  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else {  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else {  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  				                      _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  				                      _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  				                                      GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price) {  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  				    !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price) {  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte) {  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  						                           _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  						                           _isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price) {  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do {  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					} while (--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull) {  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2) {  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =  								repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +  								_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  								_literalEncoder.GetSubCoder(position + lenTest'  								                            _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  								                                                                                        _matchFinder.GetIndexByte((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1))'  								                                                                                        _matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while (lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price) {  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes) {  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen) {  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen;; lenTest++) {  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs]) {  							if (lenTest < numAvailableBytesFull) {  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2) {  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  									                            _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									                            _literalEncoder.GetSubCoder(position + lenTest'  									                                                        _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  									                                            GetPrice(true'  									                                                     _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  									                                                     _matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price) {  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes) {  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar) {  					posPrev--;  					if (_optimum[cur].Prev2) {  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1) {  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else {  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2) {  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else {  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances) {  						if (pos == 0) {  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1) {  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2) {  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else {  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else {  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  				                      _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  				                      _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  				                                      GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price) {  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  				    !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price) {  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte) {  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  						                           _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  						                           _isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price) {  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do {  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					} while (--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull) {  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2) {  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =  								repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +  								_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  								_literalEncoder.GetSubCoder(position + lenTest'  								                            _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  								                                                                                        _matchFinder.GetIndexByte((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1))'  								                                                                                        _matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while (lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price) {  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes) {  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen) {  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen;; lenTest++) {  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs]) {  							if (lenTest < numAvailableBytesFull) {  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2) {  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  									                            _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									                            _literalEncoder.GetSubCoder(position + lenTest'  									                                                        _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  									                                            GetPrice(true'  									                                                     _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  									                                                     _matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price) {  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes) {  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar) {  					posPrev--;  					if (_optimum[cur].Prev2) {  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1) {  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else {  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2) {  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else {  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances) {  						if (pos == 0) {  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1) {  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2) {  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else {  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else {  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  				                      _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  				                      _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  				                                      GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price) {  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  				    !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price) {  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte) {  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  						                           _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  						                           _isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price) {  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do {  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					} while (--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull) {  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2) {  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =  								repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +  								_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  								_literalEncoder.GetSubCoder(position + lenTest'  								                            _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  								                                                                                        _matchFinder.GetIndexByte((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1))'  								                                                                                        _matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while (lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price) {  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes) {  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen) {  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen;; lenTest++) {  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs]) {  							if (lenTest < numAvailableBytesFull) {  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2) {  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  									                            _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									                            _literalEncoder.GetSubCoder(position + lenTest'  									                                                        _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  									                                            GetPrice(true'  									                                                     _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  									                                                     _matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price) {  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes) {  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar) {  					posPrev--;  					if (_optimum[cur].Prev2) {  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1) {  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else {  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2) {  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else {  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances) {  						if (pos == 0) {  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1) {  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2) {  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else {  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else {  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  				                      _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  				                      _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  				                                      GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price) {  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  				    !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price) {  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte) {  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  						                           _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  						                           _isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price) {  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do {  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					} while (--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull) {  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2) {  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =  								repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +  								_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  								_literalEncoder.GetSubCoder(position + lenTest'  								                            _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  								                                                                                        _matchFinder.GetIndexByte((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1))'  								                                                                                        _matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while (lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price) {  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes) {  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen) {  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen;; lenTest++) {  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs]) {  							if (lenTest < numAvailableBytesFull) {  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2) {  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  									                            _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									                            _literalEncoder.GetSubCoder(position + lenTest'  									                                                        _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  									                                            GetPrice(true'  									                                                     _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  									                                                     _matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price) {  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes) {  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar) {  					posPrev--;  					if (_optimum[cur].Prev2) {  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1) {  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else {  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2) {  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else {  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances) {  						if (pos == 0) {  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1) {  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2) {  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else {  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else {  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  				                      _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  				                      _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  				                                      GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price) {  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  				    !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price) {  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte) {  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  						                           _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  						                           _isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price) {  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do {  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					} while (--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull) {  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2) {  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =  								repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +  								_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  								_literalEncoder.GetSubCoder(position + lenTest'  								                            _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  								                                                                                        _matchFinder.GetIndexByte((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1))'  								                                                                                        _matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while (lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price) {  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes) {  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen) {  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen;; lenTest++) {  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs]) {  							if (lenTest < numAvailableBytesFull) {  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2) {  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  									                            _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									                            _literalEncoder.GetSubCoder(position + lenTest'  									                                                        _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  									                                            GetPrice(true'  									                                                     _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  									                                                     _matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price) {  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes) {  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar) {  					posPrev--;  					if (_optimum[cur].Prev2) {  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1) {  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else {  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2) {  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else {  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances) {  						if (pos == 0) {  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1) {  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2) {  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else {  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else {  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  				                      _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  				                      _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  				                                      GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price) {  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  				    !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price) {  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte) {  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  						                           _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  						                           _isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price) {  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do {  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					} while (--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull) {  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2) {  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =  								repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +  								_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  								_literalEncoder.GetSubCoder(position + lenTest'  								                            _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  								                                                                                        _matchFinder.GetIndexByte((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1))'  								                                                                                        _matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while (lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price) {  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes) {  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen) {  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen;; lenTest++) {  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs]) {  							if (lenTest < numAvailableBytesFull) {  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2) {  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  									                            _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									                            _literalEncoder.GetSubCoder(position + lenTest'  									                                                        _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  									                                            GetPrice(true'  									                                                     _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  									                                                     _matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price) {  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes) {  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar) {  					posPrev--;  					if (_optimum[cur].Prev2) {  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1) {  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else {  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2) {  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else {  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances) {  						if (pos == 0) {  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1) {  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2) {  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else {  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else {  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  				                      _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  				                      _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  				                                      GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price) {  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  				    !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price) {  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte) {  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  						                           _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  						                           _isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price) {  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do {  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					} while (--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull) {  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2) {  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =  								repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +  								_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  								_literalEncoder.GetSubCoder(position + lenTest'  								                            _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  								                                                                                        _matchFinder.GetIndexByte((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1))'  								                                                                                        _matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while (lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price) {  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes) {  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen) {  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen;; lenTest++) {  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs]) {  							if (lenTest < numAvailableBytesFull) {  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2) {  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  									                            _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									                            _literalEncoder.GetSubCoder(position + lenTest'  									                                                        _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  									                                            GetPrice(true'  									                                                     _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  									                                                     _matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price) {  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes) {  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar) {  					posPrev--;  					if (_optimum[cur].Prev2) {  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1) {  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else {  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2) {  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else {  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances) {  						if (pos == 0) {  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1) {  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2) {  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else {  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else {  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  				                      _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  				                      _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  				                                      GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price) {  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  				    !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price) {  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte) {  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  						                           _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  						                           _isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price) {  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do {  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					} while (--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull) {  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2) {  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =  								repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +  								_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  								_literalEncoder.GetSubCoder(position + lenTest'  								                            _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  								                                                                                        _matchFinder.GetIndexByte((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1))'  								                                                                                        _matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while (lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price) {  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes) {  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen) {  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen;; lenTest++) {  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs]) {  							if (lenTest < numAvailableBytesFull) {  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2) {  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  									                            _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									                            _literalEncoder.GetSubCoder(position + lenTest'  									                                                        _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  									                                            GetPrice(true'  									                                                     _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  									                                                     _matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price) {  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes) {  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar) {  					posPrev--;  					if (_optimum[cur].Prev2) {  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1) {  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else {  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2) {  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else {  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances) {  						if (pos == 0) {  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1) {  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2) {  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else {  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else {  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  				                      _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  				                      _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  				                                      GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price) {  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  				    !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price) {  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte) {  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  						                           _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  						                           _isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price) {  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do {  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					} while (--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull) {  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2) {  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =  								repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +  								_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  								_literalEncoder.GetSubCoder(position + lenTest'  								                            _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  								                                                                                        _matchFinder.GetIndexByte((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1))'  								                                                                                        _matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while (lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price) {  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes) {  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen) {  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen;; lenTest++) {  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs]) {  							if (lenTest < numAvailableBytesFull) {  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2) {  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  									                            _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									                            _literalEncoder.GetSubCoder(position + lenTest'  									                                                        _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  									                                            GetPrice(true'  									                                                     _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  									                                                     _matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price) {  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true) {  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes) {  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar) {  					posPrev--;  					if (_optimum[cur].Prev2) {  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1) {  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else {  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2) {  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else {  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances) {  						if (pos == 0) {  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1) {  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2) {  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else {  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else {  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  				                      _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  				                      _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  				                                      GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price) {  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  				    !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0)) {  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price) {  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte) {  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2) {  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  						                           _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  						                           _isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price) {  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do {  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					} while (--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull) {  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2) {  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =  								repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +  								_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  								_literalEncoder.GetSubCoder(position + lenTest'  								                            _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  								                                                                                        _matchFinder.GetIndexByte((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1))'  								                                                                                        _matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while (lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price) {  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes) {  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen) {  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen;; lenTest++) {  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price) {  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs]) {  							if (lenTest < numAvailableBytesFull) {  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2) {  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  									                            _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									                            _literalEncoder.GetSubCoder(position + lenTest'  									                                                        _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  									                                            GetPrice(true'  									                                                     _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  									                                                     _matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price) {  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,ChangePair,The following statement contains a magic number: const int kDif = 7;
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,ChangePair,The following statement contains a magic number: return (smallDist < ((UInt32)(1) << (32 - kDif)) && bigDist >= (smallDist << kDif));
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,WriteEndMarker,The following statement contains a magic number: int footerBits = 30;
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,CodeOneBlock,The following statement contains a magic number: while (true) {  				UInt32 pos;  				UInt32 len = GetOptimum((UInt32)nowPos64' out pos);    				UInt32 posState = ((UInt32)nowPos64) & _posStateMask;  				UInt32 complexState = (_state.Index << Base.kNumPosStatesBitsMax) + posState;  				if (len == 1 && pos == 0xFFFFFFFF) {  					_isMatch[complexState].Encode(_rangeEncoder' 0);  					Byte curByte = _matchFinder.GetIndexByte((Int32)(0 - _additionalOffset));  					LiteralEncoder.Encoder2 subCoder = _literalEncoder.GetSubCoder((UInt32)nowPos64' _previousByte);  					if (!_state.IsCharState()) {  						Byte matchByte = _matchFinder.GetIndexByte((Int32)(0 - _repDistances[0] - 1 - _additionalOffset));  						subCoder.EncodeMatched(_rangeEncoder' matchByte' curByte);  					}  					else  						subCoder.Encode(_rangeEncoder' curByte);  					_previousByte = curByte;  					_state.UpdateChar();  				}  				else {  					_isMatch[complexState].Encode(_rangeEncoder' 1);  					if (pos < Base.kNumRepDistances) {  						_isRep[_state.Index].Encode(_rangeEncoder' 1);  						if (pos == 0) {  							_isRepG0[_state.Index].Encode(_rangeEncoder' 0);  							if (len == 1)  								_isRep0Long[complexState].Encode(_rangeEncoder' 0);  							else  								_isRep0Long[complexState].Encode(_rangeEncoder' 1);  						}  						else {  							_isRepG0[_state.Index].Encode(_rangeEncoder' 1);  							if (pos == 1)  								_isRepG1[_state.Index].Encode(_rangeEncoder' 0);  							else {  								_isRepG1[_state.Index].Encode(_rangeEncoder' 1);  								_isRepG2[_state.Index].Encode(_rangeEncoder' pos - 2);  							}  						}  						if (len == 1)  							_state.UpdateShortRep();  						else {  							_repMatchLenEncoder.Encode(_rangeEncoder' len - Base.kMatchMinLen' posState);  							_state.UpdateRep();  						}  						UInt32 distance = _repDistances[pos];  						if (pos != 0) {  							for (UInt32 i = pos; i >= 1; i--)  								_repDistances[i] = _repDistances[i - 1];  							_repDistances[0] = distance;  						}  					}  					else {  						_isRep[_state.Index].Encode(_rangeEncoder' 0);  						_state.UpdateMatch();  						_lenEncoder.Encode(_rangeEncoder' len - Base.kMatchMinLen' posState);  						pos -= Base.kNumRepDistances;  						UInt32 posSlot = GetPosSlot(pos);  						UInt32 lenToPosState = Base.GetLenToPosState(len);  						_posSlotEncoder[lenToPosState].Encode(_rangeEncoder' posSlot);    						if (posSlot >= Base.kStartPosModelIndex) {  							var footerBits = (int)((posSlot >> 1) - 1);  							UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);  							UInt32 posReduced = pos - baseVal;    							if (posSlot < Base.kEndPosModelIndex)  								BitTreeEncoder.ReverseEncode(_posEncoders'  								                             baseVal - posSlot - 1' _rangeEncoder' footerBits' posReduced);  							else {  								_rangeEncoder.EncodeDirectBits(posReduced >> Base.kNumAlignBits' footerBits - Base.kNumAlignBits);  								_posAlignEncoder.ReverseEncode(_rangeEncoder' posReduced & Base.kAlignMask);  								_alignPriceCount++;  							}  						}  						UInt32 distance = pos;  						for (UInt32 i = Base.kNumRepDistances - 1; i >= 1; i--)  							_repDistances[i] = _repDistances[i - 1];  						_repDistances[0] = distance;  						_matchPriceCount++;  					}  					_previousByte = _matchFinder.GetIndexByte((Int32)(len - 1 - _additionalOffset));  				}  				_additionalOffset -= len;  				nowPos64 += len;  				if (_additionalOffset == 0) {  					// if (!_fastMode)  					if (_matchPriceCount >= (1 << 7))  						FillDistancesPrices();  					if (_alignPriceCount >= Base.kAlignTableSize)  						FillAlignPrices();  					inSize = nowPos64;  					outSize = _rangeEncoder.GetProcessedSizeAdd();  					if (_matchFinder.GetNumAvailableBytes() == 0) {  						Flush((UInt32)nowPos64);  						return;  					}    					if (nowPos64 - progressPosValuePrev >= (1 << 12)) {  						_finished = false;  						finished = false;  						return;  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,CodeOneBlock,The following statement contains a magic number: while (true) {  				UInt32 pos;  				UInt32 len = GetOptimum((UInt32)nowPos64' out pos);    				UInt32 posState = ((UInt32)nowPos64) & _posStateMask;  				UInt32 complexState = (_state.Index << Base.kNumPosStatesBitsMax) + posState;  				if (len == 1 && pos == 0xFFFFFFFF) {  					_isMatch[complexState].Encode(_rangeEncoder' 0);  					Byte curByte = _matchFinder.GetIndexByte((Int32)(0 - _additionalOffset));  					LiteralEncoder.Encoder2 subCoder = _literalEncoder.GetSubCoder((UInt32)nowPos64' _previousByte);  					if (!_state.IsCharState()) {  						Byte matchByte = _matchFinder.GetIndexByte((Int32)(0 - _repDistances[0] - 1 - _additionalOffset));  						subCoder.EncodeMatched(_rangeEncoder' matchByte' curByte);  					}  					else  						subCoder.Encode(_rangeEncoder' curByte);  					_previousByte = curByte;  					_state.UpdateChar();  				}  				else {  					_isMatch[complexState].Encode(_rangeEncoder' 1);  					if (pos < Base.kNumRepDistances) {  						_isRep[_state.Index].Encode(_rangeEncoder' 1);  						if (pos == 0) {  							_isRepG0[_state.Index].Encode(_rangeEncoder' 0);  							if (len == 1)  								_isRep0Long[complexState].Encode(_rangeEncoder' 0);  							else  								_isRep0Long[complexState].Encode(_rangeEncoder' 1);  						}  						else {  							_isRepG0[_state.Index].Encode(_rangeEncoder' 1);  							if (pos == 1)  								_isRepG1[_state.Index].Encode(_rangeEncoder' 0);  							else {  								_isRepG1[_state.Index].Encode(_rangeEncoder' 1);  								_isRepG2[_state.Index].Encode(_rangeEncoder' pos - 2);  							}  						}  						if (len == 1)  							_state.UpdateShortRep();  						else {  							_repMatchLenEncoder.Encode(_rangeEncoder' len - Base.kMatchMinLen' posState);  							_state.UpdateRep();  						}  						UInt32 distance = _repDistances[pos];  						if (pos != 0) {  							for (UInt32 i = pos; i >= 1; i--)  								_repDistances[i] = _repDistances[i - 1];  							_repDistances[0] = distance;  						}  					}  					else {  						_isRep[_state.Index].Encode(_rangeEncoder' 0);  						_state.UpdateMatch();  						_lenEncoder.Encode(_rangeEncoder' len - Base.kMatchMinLen' posState);  						pos -= Base.kNumRepDistances;  						UInt32 posSlot = GetPosSlot(pos);  						UInt32 lenToPosState = Base.GetLenToPosState(len);  						_posSlotEncoder[lenToPosState].Encode(_rangeEncoder' posSlot);    						if (posSlot >= Base.kStartPosModelIndex) {  							var footerBits = (int)((posSlot >> 1) - 1);  							UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);  							UInt32 posReduced = pos - baseVal;    							if (posSlot < Base.kEndPosModelIndex)  								BitTreeEncoder.ReverseEncode(_posEncoders'  								                             baseVal - posSlot - 1' _rangeEncoder' footerBits' posReduced);  							else {  								_rangeEncoder.EncodeDirectBits(posReduced >> Base.kNumAlignBits' footerBits - Base.kNumAlignBits);  								_posAlignEncoder.ReverseEncode(_rangeEncoder' posReduced & Base.kAlignMask);  								_alignPriceCount++;  							}  						}  						UInt32 distance = pos;  						for (UInt32 i = Base.kNumRepDistances - 1; i >= 1; i--)  							_repDistances[i] = _repDistances[i - 1];  						_repDistances[0] = distance;  						_matchPriceCount++;  					}  					_previousByte = _matchFinder.GetIndexByte((Int32)(len - 1 - _additionalOffset));  				}  				_additionalOffset -= len;  				nowPos64 += len;  				if (_additionalOffset == 0) {  					// if (!_fastMode)  					if (_matchPriceCount >= (1 << 7))  						FillDistancesPrices();  					if (_alignPriceCount >= Base.kAlignTableSize)  						FillAlignPrices();  					inSize = nowPos64;  					outSize = _rangeEncoder.GetProcessedSizeAdd();  					if (_matchFinder.GetNumAvailableBytes() == 0) {  						Flush((UInt32)nowPos64);  						return;  					}    					if (nowPos64 - progressPosValuePrev >= (1 << 12)) {  						_finished = false;  						finished = false;  						return;  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,CodeOneBlock,The following statement contains a magic number: while (true) {  				UInt32 pos;  				UInt32 len = GetOptimum((UInt32)nowPos64' out pos);    				UInt32 posState = ((UInt32)nowPos64) & _posStateMask;  				UInt32 complexState = (_state.Index << Base.kNumPosStatesBitsMax) + posState;  				if (len == 1 && pos == 0xFFFFFFFF) {  					_isMatch[complexState].Encode(_rangeEncoder' 0);  					Byte curByte = _matchFinder.GetIndexByte((Int32)(0 - _additionalOffset));  					LiteralEncoder.Encoder2 subCoder = _literalEncoder.GetSubCoder((UInt32)nowPos64' _previousByte);  					if (!_state.IsCharState()) {  						Byte matchByte = _matchFinder.GetIndexByte((Int32)(0 - _repDistances[0] - 1 - _additionalOffset));  						subCoder.EncodeMatched(_rangeEncoder' matchByte' curByte);  					}  					else  						subCoder.Encode(_rangeEncoder' curByte);  					_previousByte = curByte;  					_state.UpdateChar();  				}  				else {  					_isMatch[complexState].Encode(_rangeEncoder' 1);  					if (pos < Base.kNumRepDistances) {  						_isRep[_state.Index].Encode(_rangeEncoder' 1);  						if (pos == 0) {  							_isRepG0[_state.Index].Encode(_rangeEncoder' 0);  							if (len == 1)  								_isRep0Long[complexState].Encode(_rangeEncoder' 0);  							else  								_isRep0Long[complexState].Encode(_rangeEncoder' 1);  						}  						else {  							_isRepG0[_state.Index].Encode(_rangeEncoder' 1);  							if (pos == 1)  								_isRepG1[_state.Index].Encode(_rangeEncoder' 0);  							else {  								_isRepG1[_state.Index].Encode(_rangeEncoder' 1);  								_isRepG2[_state.Index].Encode(_rangeEncoder' pos - 2);  							}  						}  						if (len == 1)  							_state.UpdateShortRep();  						else {  							_repMatchLenEncoder.Encode(_rangeEncoder' len - Base.kMatchMinLen' posState);  							_state.UpdateRep();  						}  						UInt32 distance = _repDistances[pos];  						if (pos != 0) {  							for (UInt32 i = pos; i >= 1; i--)  								_repDistances[i] = _repDistances[i - 1];  							_repDistances[0] = distance;  						}  					}  					else {  						_isRep[_state.Index].Encode(_rangeEncoder' 0);  						_state.UpdateMatch();  						_lenEncoder.Encode(_rangeEncoder' len - Base.kMatchMinLen' posState);  						pos -= Base.kNumRepDistances;  						UInt32 posSlot = GetPosSlot(pos);  						UInt32 lenToPosState = Base.GetLenToPosState(len);  						_posSlotEncoder[lenToPosState].Encode(_rangeEncoder' posSlot);    						if (posSlot >= Base.kStartPosModelIndex) {  							var footerBits = (int)((posSlot >> 1) - 1);  							UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);  							UInt32 posReduced = pos - baseVal;    							if (posSlot < Base.kEndPosModelIndex)  								BitTreeEncoder.ReverseEncode(_posEncoders'  								                             baseVal - posSlot - 1' _rangeEncoder' footerBits' posReduced);  							else {  								_rangeEncoder.EncodeDirectBits(posReduced >> Base.kNumAlignBits' footerBits - Base.kNumAlignBits);  								_posAlignEncoder.ReverseEncode(_rangeEncoder' posReduced & Base.kAlignMask);  								_alignPriceCount++;  							}  						}  						UInt32 distance = pos;  						for (UInt32 i = Base.kNumRepDistances - 1; i >= 1; i--)  							_repDistances[i] = _repDistances[i - 1];  						_repDistances[0] = distance;  						_matchPriceCount++;  					}  					_previousByte = _matchFinder.GetIndexByte((Int32)(len - 1 - _additionalOffset));  				}  				_additionalOffset -= len;  				nowPos64 += len;  				if (_additionalOffset == 0) {  					// if (!_fastMode)  					if (_matchPriceCount >= (1 << 7))  						FillDistancesPrices();  					if (_alignPriceCount >= Base.kAlignTableSize)  						FillAlignPrices();  					inSize = nowPos64;  					outSize = _rangeEncoder.GetProcessedSizeAdd();  					if (_matchFinder.GetNumAvailableBytes() == 0) {  						Flush((UInt32)nowPos64);  						return;  					}    					if (nowPos64 - progressPosValuePrev >= (1 << 12)) {  						_finished = false;  						finished = false;  						return;  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,CodeOneBlock,The following statement contains a magic number: while (true) {  				UInt32 pos;  				UInt32 len = GetOptimum((UInt32)nowPos64' out pos);    				UInt32 posState = ((UInt32)nowPos64) & _posStateMask;  				UInt32 complexState = (_state.Index << Base.kNumPosStatesBitsMax) + posState;  				if (len == 1 && pos == 0xFFFFFFFF) {  					_isMatch[complexState].Encode(_rangeEncoder' 0);  					Byte curByte = _matchFinder.GetIndexByte((Int32)(0 - _additionalOffset));  					LiteralEncoder.Encoder2 subCoder = _literalEncoder.GetSubCoder((UInt32)nowPos64' _previousByte);  					if (!_state.IsCharState()) {  						Byte matchByte = _matchFinder.GetIndexByte((Int32)(0 - _repDistances[0] - 1 - _additionalOffset));  						subCoder.EncodeMatched(_rangeEncoder' matchByte' curByte);  					}  					else  						subCoder.Encode(_rangeEncoder' curByte);  					_previousByte = curByte;  					_state.UpdateChar();  				}  				else {  					_isMatch[complexState].Encode(_rangeEncoder' 1);  					if (pos < Base.kNumRepDistances) {  						_isRep[_state.Index].Encode(_rangeEncoder' 1);  						if (pos == 0) {  							_isRepG0[_state.Index].Encode(_rangeEncoder' 0);  							if (len == 1)  								_isRep0Long[complexState].Encode(_rangeEncoder' 0);  							else  								_isRep0Long[complexState].Encode(_rangeEncoder' 1);  						}  						else {  							_isRepG0[_state.Index].Encode(_rangeEncoder' 1);  							if (pos == 1)  								_isRepG1[_state.Index].Encode(_rangeEncoder' 0);  							else {  								_isRepG1[_state.Index].Encode(_rangeEncoder' 1);  								_isRepG2[_state.Index].Encode(_rangeEncoder' pos - 2);  							}  						}  						if (len == 1)  							_state.UpdateShortRep();  						else {  							_repMatchLenEncoder.Encode(_rangeEncoder' len - Base.kMatchMinLen' posState);  							_state.UpdateRep();  						}  						UInt32 distance = _repDistances[pos];  						if (pos != 0) {  							for (UInt32 i = pos; i >= 1; i--)  								_repDistances[i] = _repDistances[i - 1];  							_repDistances[0] = distance;  						}  					}  					else {  						_isRep[_state.Index].Encode(_rangeEncoder' 0);  						_state.UpdateMatch();  						_lenEncoder.Encode(_rangeEncoder' len - Base.kMatchMinLen' posState);  						pos -= Base.kNumRepDistances;  						UInt32 posSlot = GetPosSlot(pos);  						UInt32 lenToPosState = Base.GetLenToPosState(len);  						_posSlotEncoder[lenToPosState].Encode(_rangeEncoder' posSlot);    						if (posSlot >= Base.kStartPosModelIndex) {  							var footerBits = (int)((posSlot >> 1) - 1);  							UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);  							UInt32 posReduced = pos - baseVal;    							if (posSlot < Base.kEndPosModelIndex)  								BitTreeEncoder.ReverseEncode(_posEncoders'  								                             baseVal - posSlot - 1' _rangeEncoder' footerBits' posReduced);  							else {  								_rangeEncoder.EncodeDirectBits(posReduced >> Base.kNumAlignBits' footerBits - Base.kNumAlignBits);  								_posAlignEncoder.ReverseEncode(_rangeEncoder' posReduced & Base.kAlignMask);  								_alignPriceCount++;  							}  						}  						UInt32 distance = pos;  						for (UInt32 i = Base.kNumRepDistances - 1; i >= 1; i--)  							_repDistances[i] = _repDistances[i - 1];  						_repDistances[0] = distance;  						_matchPriceCount++;  					}  					_previousByte = _matchFinder.GetIndexByte((Int32)(len - 1 - _additionalOffset));  				}  				_additionalOffset -= len;  				nowPos64 += len;  				if (_additionalOffset == 0) {  					// if (!_fastMode)  					if (_matchPriceCount >= (1 << 7))  						FillDistancesPrices();  					if (_alignPriceCount >= Base.kAlignTableSize)  						FillAlignPrices();  					inSize = nowPos64;  					outSize = _rangeEncoder.GetProcessedSizeAdd();  					if (_matchFinder.GetNumAvailableBytes() == 0) {  						Flush((UInt32)nowPos64);  						return;  					}    					if (nowPos64 - progressPosValuePrev >= (1 << 12)) {  						_finished = false;  						finished = false;  						return;  					}  				}  			}
Magic Number,SevenZip.Compression.LZMA,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,FillDistancesPrices,The following statement contains a magic number: for (UInt32 i = Base.kStartPosModelIndex; i < Base.kNumFullDistances; i++) {  				UInt32 posSlot = GetPosSlot(i);  				var footerBits = (int)((posSlot >> 1) - 1);  				UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);  				tempPrices[i] = BitTreeEncoder.ReverseGetPrice(_posEncoders'  				                                               baseVal - posSlot - 1' footerBits' i - baseVal);  			}
Magic Number,SevenZip.Compression.LZMA,LiteralEncoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,GetSubCoder,The following statement contains a magic number: return m_Coders[((pos & m_PosMask) << m_NumPrevBits) + (uint)(prevByte >> (8 - m_NumPrevBits))];
Magic Number,SevenZip.Compression.LZMA,Encoder2,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,Encode,The following statement contains a magic number: for (int i = 7; i >= 0; i--) {  						var bit = (uint)((symbol >> i) & 1);  						m_Encoders[context].Encode(rangeEncoder' bit);  						context = (context << 1) | bit;  					}
Magic Number,SevenZip.Compression.LZMA,Encoder2,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,EncodeMatched,The following statement contains a magic number: for (int i = 7; i >= 0; i--) {  						var bit = (uint)((symbol >> i) & 1);  						uint state = context;  						if (same) {  							var matchBit = (uint)((matchByte >> i) & 1);  							state += ((1 + matchBit) << 8);  							same = (matchBit == bit);  						}  						m_Encoders[state].Encode(rangeEncoder' bit);  						context = (context << 1) | bit;  					}
Magic Number,SevenZip.Compression.LZMA,Encoder2,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,EncodeMatched,The following statement contains a magic number: for (int i = 7; i >= 0; i--) {  						var bit = (uint)((symbol >> i) & 1);  						uint state = context;  						if (same) {  							var matchBit = (uint)((matchByte >> i) & 1);  							state += ((1 + matchBit) << 8);  							same = (matchBit == bit);  						}  						m_Encoders[state].Encode(rangeEncoder' bit);  						context = (context << 1) | bit;  					}
Magic Number,SevenZip.Compression.LZMA,Encoder2,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,GetPrice,The following statement contains a magic number: int i = 7;
Magic Number,SevenZip.Compression.LZMA,Encoder2,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZMA\LzmaEncoder.cs,GetPrice,The following statement contains a magic number: if (matchMode) {  						for (; i >= 0; i--) {  							uint matchBit = (uint)(matchByte >> i) & 1;  							uint bit = (uint)(symbol >> i) & 1;  							price += m_Encoders[((1 + matchBit) << 8) + context].GetPrice(bit);  							context = (context << 1) | bit;  							if (matchBit != bit) {  								i--;  								break;  							}  						}  					}
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZ\LzBinTree.cs,Create,The following statement contains a magic number: if (historySize > kMaxValForNormalize - 256)  				throw new Exception();
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZ\LzBinTree.cs,Create,The following statement contains a magic number: _cutValue = 16 + (matchMaxLen >> 1);
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZ\LzBinTree.cs,Create,The following statement contains a magic number: UInt32 windowReservSize = (historySize + keepAddBufferBefore +  			                           matchMaxLen + keepAddBufferAfter) / 2 + 256;
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZ\LzBinTree.cs,Create,The following statement contains a magic number: UInt32 windowReservSize = (historySize + keepAddBufferBefore +  			                           matchMaxLen + keepAddBufferAfter) / 2 + 256;
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZ\LzBinTree.cs,Create,The following statement contains a magic number: if (_cyclicBufferSize != cyclicBufferSize)  				_son = new UInt32[(_cyclicBufferSize = cyclicBufferSize) * 2];
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZ\LzBinTree.cs,Create,The following statement contains a magic number: if (HASH_ARRAY) {  				hs = historySize - 1;  				hs |= (hs >> 1);  				hs |= (hs >> 2);  				hs |= (hs >> 4);  				hs |= (hs >> 8);  				hs >>= 1;  				hs |= 0xFFFF;  				if (hs > (1 << 24))  					hs >>= 1;  				_hashMask = hs;  				hs++;  				hs += kFixHashSize;  			}
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZ\LzBinTree.cs,Create,The following statement contains a magic number: if (HASH_ARRAY) {  				hs = historySize - 1;  				hs |= (hs >> 1);  				hs |= (hs >> 2);  				hs |= (hs >> 4);  				hs |= (hs >> 8);  				hs >>= 1;  				hs |= 0xFFFF;  				if (hs > (1 << 24))  					hs >>= 1;  				_hashMask = hs;  				hs++;  				hs += kFixHashSize;  			}
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZ\LzBinTree.cs,Create,The following statement contains a magic number: if (HASH_ARRAY) {  				hs = historySize - 1;  				hs |= (hs >> 1);  				hs |= (hs >> 2);  				hs |= (hs >> 4);  				hs |= (hs >> 8);  				hs >>= 1;  				hs |= 0xFFFF;  				if (hs > (1 << 24))  					hs >>= 1;  				_hashMask = hs;  				hs++;  				hs += kFixHashSize;  			}
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZ\LzBinTree.cs,Create,The following statement contains a magic number: if (HASH_ARRAY) {  				hs = historySize - 1;  				hs |= (hs >> 1);  				hs |= (hs >> 2);  				hs |= (hs >> 4);  				hs |= (hs >> 8);  				hs >>= 1;  				hs |= 0xFFFF;  				if (hs > (1 << 24))  					hs >>= 1;  				_hashMask = hs;  				hs++;  				hs += kFixHashSize;  			}
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY) {  				UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];  				hash2Value = temp & (kHash2Size - 1);  				temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);  				hash3Value = temp & (kHash3Size - 1);  				hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;  			}  			else  				hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY) {  				UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];  				hash2Value = temp & (kHash2Size - 1);  				temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);  				hash3Value = temp & (kHash3Size - 1);  				hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;  			}  			else  				hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY) {  				UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];  				hash2Value = temp & (kHash2Size - 1);  				temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);  				hash3Value = temp & (kHash3Size - 1);  				hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;  			}  			else  				hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY) {  				UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];  				hash2Value = temp & (kHash2Size - 1);  				temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);  				hash3Value = temp & (kHash3Size - 1);  				hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;  			}  			else  				hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY) {  				UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];  				hash2Value = temp & (kHash2Size - 1);  				temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);  				hash3Value = temp & (kHash3Size - 1);  				hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;  			}  			else  				hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY) {  				UInt32 curMatch2 = _hash[hash2Value];  				UInt32 curMatch3 = _hash[kHash3Offset + hash3Value];  				_hash[hash2Value] = _pos;  				_hash[kHash3Offset + hash3Value] = _pos;  				if (curMatch2 > matchMinPos)  					if (_bufferBase[_bufferOffset + curMatch2] == _bufferBase[cur]) {  						distances[offset++] = maxLen = 2;  						distances[offset++] = _pos - curMatch2 - 1;  					}  				if (curMatch3 > matchMinPos)  					if (_bufferBase[_bufferOffset + curMatch3] == _bufferBase[cur]) {  						if (curMatch3 == curMatch2)  							offset -= 2;  						distances[offset++] = maxLen = 3;  						distances[offset++] = _pos - curMatch3 - 1;  						curMatch2 = curMatch3;  					}  				if (offset != 0 && curMatch2 == curMatch) {  					offset -= 2;  					maxLen = kStartMaxLen;  				}  			}
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY) {  				UInt32 curMatch2 = _hash[hash2Value];  				UInt32 curMatch3 = _hash[kHash3Offset + hash3Value];  				_hash[hash2Value] = _pos;  				_hash[kHash3Offset + hash3Value] = _pos;  				if (curMatch2 > matchMinPos)  					if (_bufferBase[_bufferOffset + curMatch2] == _bufferBase[cur]) {  						distances[offset++] = maxLen = 2;  						distances[offset++] = _pos - curMatch2 - 1;  					}  				if (curMatch3 > matchMinPos)  					if (_bufferBase[_bufferOffset + curMatch3] == _bufferBase[cur]) {  						if (curMatch3 == curMatch2)  							offset -= 2;  						distances[offset++] = maxLen = 3;  						distances[offset++] = _pos - curMatch3 - 1;  						curMatch2 = curMatch3;  					}  				if (offset != 0 && curMatch2 == curMatch) {  					offset -= 2;  					maxLen = kStartMaxLen;  				}  			}
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY) {  				UInt32 curMatch2 = _hash[hash2Value];  				UInt32 curMatch3 = _hash[kHash3Offset + hash3Value];  				_hash[hash2Value] = _pos;  				_hash[kHash3Offset + hash3Value] = _pos;  				if (curMatch2 > matchMinPos)  					if (_bufferBase[_bufferOffset + curMatch2] == _bufferBase[cur]) {  						distances[offset++] = maxLen = 2;  						distances[offset++] = _pos - curMatch2 - 1;  					}  				if (curMatch3 > matchMinPos)  					if (_bufferBase[_bufferOffset + curMatch3] == _bufferBase[cur]) {  						if (curMatch3 == curMatch2)  							offset -= 2;  						distances[offset++] = maxLen = 3;  						distances[offset++] = _pos - curMatch3 - 1;  						curMatch2 = curMatch3;  					}  				if (offset != 0 && curMatch2 == curMatch) {  					offset -= 2;  					maxLen = kStartMaxLen;  				}  			}
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY) {  				UInt32 curMatch2 = _hash[hash2Value];  				UInt32 curMatch3 = _hash[kHash3Offset + hash3Value];  				_hash[hash2Value] = _pos;  				_hash[kHash3Offset + hash3Value] = _pos;  				if (curMatch2 > matchMinPos)  					if (_bufferBase[_bufferOffset + curMatch2] == _bufferBase[cur]) {  						distances[offset++] = maxLen = 2;  						distances[offset++] = _pos - curMatch2 - 1;  					}  				if (curMatch3 > matchMinPos)  					if (_bufferBase[_bufferOffset + curMatch3] == _bufferBase[cur]) {  						if (curMatch3 == curMatch2)  							offset -= 2;  						distances[offset++] = maxLen = 3;  						distances[offset++] = _pos - curMatch3 - 1;  						curMatch2 = curMatch3;  					}  				if (offset != 0 && curMatch2 == curMatch) {  					offset -= 2;  					maxLen = kStartMaxLen;  				}  			}
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZ\LzBinTree.cs,Skip,The following statement contains a magic number: do {  				UInt32 lenLimit;  				if (_pos + _matchMaxLen <= _streamPos)  					lenLimit = _matchMaxLen;  				else {  					lenLimit = _streamPos - _pos;  					if (lenLimit < kMinMatchCheck) {  						MovePos();  						continue;  					}  				}    				UInt32 matchMinPos = (_pos > _cyclicBufferSize) ? (_pos - _cyclicBufferSize) : 0;  				UInt32 cur = _bufferOffset + _pos;    				UInt32 hashValue;    				if (HASH_ARRAY) {  					UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];  					UInt32 hash2Value = temp & (kHash2Size - 1);  					_hash[hash2Value] = _pos;  					temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);  					UInt32 hash3Value = temp & (kHash3Size - 1);  					_hash[kHash3Offset + hash3Value] = _pos;  					hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;  				}  				else  					hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);    				UInt32 curMatch = _hash[kFixHashSize + hashValue];  				_hash[kFixHashSize + hashValue] = _pos;    				UInt32 ptr0 = (_cyclicBufferPos << 1) + 1;  				UInt32 ptr1 = (_cyclicBufferPos << 1);    				UInt32 len0' len1;  				len0 = len1 = kNumHashDirectBytes;    				UInt32 count = _cutValue;  				while (true) {  					if (curMatch <= matchMinPos || count-- == 0) {  						_son[ptr0] = _son[ptr1] = kEmptyHashValue;  						break;  					}    					UInt32 delta = _pos - curMatch;  					UInt32 cyclicPos = ((delta <= _cyclicBufferPos) ?  						                    (_cyclicBufferPos - delta) :  						                    (_cyclicBufferPos - delta + _cyclicBufferSize)) << 1;    					UInt32 pby1 = _bufferOffset + curMatch;  					UInt32 len = Math.Min(len0' len1);  					if (_bufferBase[pby1 + len] == _bufferBase[cur + len]) {  						while (++len != lenLimit)  							if (_bufferBase[pby1 + len] != _bufferBase[cur + len])  								break;  						if (len == lenLimit) {  							_son[ptr1] = _son[cyclicPos];  							_son[ptr0] = _son[cyclicPos + 1];  							break;  						}  					}  					if (_bufferBase[pby1 + len] < _bufferBase[cur + len]) {  						_son[ptr1] = curMatch;  						ptr1 = cyclicPos + 1;  						curMatch = _son[ptr1];  						len1 = len;  					}  					else {  						_son[ptr0] = curMatch;  						ptr0 = cyclicPos;  						curMatch = _son[ptr0];  						len0 = len;  					}  				}  				MovePos();  			} while (--num != 0);
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZ\LzBinTree.cs,Skip,The following statement contains a magic number: do {  				UInt32 lenLimit;  				if (_pos + _matchMaxLen <= _streamPos)  					lenLimit = _matchMaxLen;  				else {  					lenLimit = _streamPos - _pos;  					if (lenLimit < kMinMatchCheck) {  						MovePos();  						continue;  					}  				}    				UInt32 matchMinPos = (_pos > _cyclicBufferSize) ? (_pos - _cyclicBufferSize) : 0;  				UInt32 cur = _bufferOffset + _pos;    				UInt32 hashValue;    				if (HASH_ARRAY) {  					UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];  					UInt32 hash2Value = temp & (kHash2Size - 1);  					_hash[hash2Value] = _pos;  					temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);  					UInt32 hash3Value = temp & (kHash3Size - 1);  					_hash[kHash3Offset + hash3Value] = _pos;  					hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;  				}  				else  					hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);    				UInt32 curMatch = _hash[kFixHashSize + hashValue];  				_hash[kFixHashSize + hashValue] = _pos;    				UInt32 ptr0 = (_cyclicBufferPos << 1) + 1;  				UInt32 ptr1 = (_cyclicBufferPos << 1);    				UInt32 len0' len1;  				len0 = len1 = kNumHashDirectBytes;    				UInt32 count = _cutValue;  				while (true) {  					if (curMatch <= matchMinPos || count-- == 0) {  						_son[ptr0] = _son[ptr1] = kEmptyHashValue;  						break;  					}    					UInt32 delta = _pos - curMatch;  					UInt32 cyclicPos = ((delta <= _cyclicBufferPos) ?  						                    (_cyclicBufferPos - delta) :  						                    (_cyclicBufferPos - delta + _cyclicBufferSize)) << 1;    					UInt32 pby1 = _bufferOffset + curMatch;  					UInt32 len = Math.Min(len0' len1);  					if (_bufferBase[pby1 + len] == _bufferBase[cur + len]) {  						while (++len != lenLimit)  							if (_bufferBase[pby1 + len] != _bufferBase[cur + len])  								break;  						if (len == lenLimit) {  							_son[ptr1] = _son[cyclicPos];  							_son[ptr0] = _son[cyclicPos + 1];  							break;  						}  					}  					if (_bufferBase[pby1 + len] < _bufferBase[cur + len]) {  						_son[ptr1] = curMatch;  						ptr1 = cyclicPos + 1;  						curMatch = _son[ptr1];  						len1 = len;  					}  					else {  						_son[ptr0] = curMatch;  						ptr0 = cyclicPos;  						curMatch = _son[ptr0];  						len0 = len;  					}  				}  				MovePos();  			} while (--num != 0);
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZ\LzBinTree.cs,Skip,The following statement contains a magic number: do {  				UInt32 lenLimit;  				if (_pos + _matchMaxLen <= _streamPos)  					lenLimit = _matchMaxLen;  				else {  					lenLimit = _streamPos - _pos;  					if (lenLimit < kMinMatchCheck) {  						MovePos();  						continue;  					}  				}    				UInt32 matchMinPos = (_pos > _cyclicBufferSize) ? (_pos - _cyclicBufferSize) : 0;  				UInt32 cur = _bufferOffset + _pos;    				UInt32 hashValue;    				if (HASH_ARRAY) {  					UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];  					UInt32 hash2Value = temp & (kHash2Size - 1);  					_hash[hash2Value] = _pos;  					temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);  					UInt32 hash3Value = temp & (kHash3Size - 1);  					_hash[kHash3Offset + hash3Value] = _pos;  					hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;  				}  				else  					hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);    				UInt32 curMatch = _hash[kFixHashSize + hashValue];  				_hash[kFixHashSize + hashValue] = _pos;    				UInt32 ptr0 = (_cyclicBufferPos << 1) + 1;  				UInt32 ptr1 = (_cyclicBufferPos << 1);    				UInt32 len0' len1;  				len0 = len1 = kNumHashDirectBytes;    				UInt32 count = _cutValue;  				while (true) {  					if (curMatch <= matchMinPos || count-- == 0) {  						_son[ptr0] = _son[ptr1] = kEmptyHashValue;  						break;  					}    					UInt32 delta = _pos - curMatch;  					UInt32 cyclicPos = ((delta <= _cyclicBufferPos) ?  						                    (_cyclicBufferPos - delta) :  						                    (_cyclicBufferPos - delta + _cyclicBufferSize)) << 1;    					UInt32 pby1 = _bufferOffset + curMatch;  					UInt32 len = Math.Min(len0' len1);  					if (_bufferBase[pby1 + len] == _bufferBase[cur + len]) {  						while (++len != lenLimit)  							if (_bufferBase[pby1 + len] != _bufferBase[cur + len])  								break;  						if (len == lenLimit) {  							_son[ptr1] = _son[cyclicPos];  							_son[ptr0] = _son[cyclicPos + 1];  							break;  						}  					}  					if (_bufferBase[pby1 + len] < _bufferBase[cur + len]) {  						_son[ptr1] = curMatch;  						ptr1 = cyclicPos + 1;  						curMatch = _son[ptr1];  						len1 = len;  					}  					else {  						_son[ptr0] = curMatch;  						ptr0 = cyclicPos;  						curMatch = _son[ptr0];  						len0 = len;  					}  				}  				MovePos();  			} while (--num != 0);
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZ\LzBinTree.cs,Skip,The following statement contains a magic number: do {  				UInt32 lenLimit;  				if (_pos + _matchMaxLen <= _streamPos)  					lenLimit = _matchMaxLen;  				else {  					lenLimit = _streamPos - _pos;  					if (lenLimit < kMinMatchCheck) {  						MovePos();  						continue;  					}  				}    				UInt32 matchMinPos = (_pos > _cyclicBufferSize) ? (_pos - _cyclicBufferSize) : 0;  				UInt32 cur = _bufferOffset + _pos;    				UInt32 hashValue;    				if (HASH_ARRAY) {  					UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];  					UInt32 hash2Value = temp & (kHash2Size - 1);  					_hash[hash2Value] = _pos;  					temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);  					UInt32 hash3Value = temp & (kHash3Size - 1);  					_hash[kHash3Offset + hash3Value] = _pos;  					hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;  				}  				else  					hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);    				UInt32 curMatch = _hash[kFixHashSize + hashValue];  				_hash[kFixHashSize + hashValue] = _pos;    				UInt32 ptr0 = (_cyclicBufferPos << 1) + 1;  				UInt32 ptr1 = (_cyclicBufferPos << 1);    				UInt32 len0' len1;  				len0 = len1 = kNumHashDirectBytes;    				UInt32 count = _cutValue;  				while (true) {  					if (curMatch <= matchMinPos || count-- == 0) {  						_son[ptr0] = _son[ptr1] = kEmptyHashValue;  						break;  					}    					UInt32 delta = _pos - curMatch;  					UInt32 cyclicPos = ((delta <= _cyclicBufferPos) ?  						                    (_cyclicBufferPos - delta) :  						                    (_cyclicBufferPos - delta + _cyclicBufferSize)) << 1;    					UInt32 pby1 = _bufferOffset + curMatch;  					UInt32 len = Math.Min(len0' len1);  					if (_bufferBase[pby1 + len] == _bufferBase[cur + len]) {  						while (++len != lenLimit)  							if (_bufferBase[pby1 + len] != _bufferBase[cur + len])  								break;  						if (len == lenLimit) {  							_son[ptr1] = _son[cyclicPos];  							_son[ptr0] = _son[cyclicPos + 1];  							break;  						}  					}  					if (_bufferBase[pby1 + len] < _bufferBase[cur + len]) {  						_son[ptr1] = curMatch;  						ptr1 = cyclicPos + 1;  						curMatch = _son[ptr1];  						len1 = len;  					}  					else {  						_son[ptr0] = curMatch;  						ptr0 = cyclicPos;  						curMatch = _son[ptr0];  						len0 = len;  					}  				}  				MovePos();  			} while (--num != 0);
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZ\LzBinTree.cs,Skip,The following statement contains a magic number: do {  				UInt32 lenLimit;  				if (_pos + _matchMaxLen <= _streamPos)  					lenLimit = _matchMaxLen;  				else {  					lenLimit = _streamPos - _pos;  					if (lenLimit < kMinMatchCheck) {  						MovePos();  						continue;  					}  				}    				UInt32 matchMinPos = (_pos > _cyclicBufferSize) ? (_pos - _cyclicBufferSize) : 0;  				UInt32 cur = _bufferOffset + _pos;    				UInt32 hashValue;    				if (HASH_ARRAY) {  					UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];  					UInt32 hash2Value = temp & (kHash2Size - 1);  					_hash[hash2Value] = _pos;  					temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);  					UInt32 hash3Value = temp & (kHash3Size - 1);  					_hash[kHash3Offset + hash3Value] = _pos;  					hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;  				}  				else  					hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);    				UInt32 curMatch = _hash[kFixHashSize + hashValue];  				_hash[kFixHashSize + hashValue] = _pos;    				UInt32 ptr0 = (_cyclicBufferPos << 1) + 1;  				UInt32 ptr1 = (_cyclicBufferPos << 1);    				UInt32 len0' len1;  				len0 = len1 = kNumHashDirectBytes;    				UInt32 count = _cutValue;  				while (true) {  					if (curMatch <= matchMinPos || count-- == 0) {  						_son[ptr0] = _son[ptr1] = kEmptyHashValue;  						break;  					}    					UInt32 delta = _pos - curMatch;  					UInt32 cyclicPos = ((delta <= _cyclicBufferPos) ?  						                    (_cyclicBufferPos - delta) :  						                    (_cyclicBufferPos - delta + _cyclicBufferSize)) << 1;    					UInt32 pby1 = _bufferOffset + curMatch;  					UInt32 len = Math.Min(len0' len1);  					if (_bufferBase[pby1 + len] == _bufferBase[cur + len]) {  						while (++len != lenLimit)  							if (_bufferBase[pby1 + len] != _bufferBase[cur + len])  								break;  						if (len == lenLimit) {  							_son[ptr1] = _son[cyclicPos];  							_son[ptr0] = _son[cyclicPos + 1];  							break;  						}  					}  					if (_bufferBase[pby1 + len] < _bufferBase[cur + len]) {  						_son[ptr1] = curMatch;  						ptr1 = cyclicPos + 1;  						curMatch = _son[ptr1];  						len1 = len;  					}  					else {  						_son[ptr0] = curMatch;  						ptr0 = cyclicPos;  						curMatch = _son[ptr0];  						len0 = len;  					}  				}  				MovePos();  			} while (--num != 0);
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZ\LzBinTree.cs,SetType,The following statement contains a magic number: HASH_ARRAY = (numHashBytes > 2);
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZ\LzBinTree.cs,SetType,The following statement contains a magic number: if (HASH_ARRAY) {  				kNumHashDirectBytes = 0;  				kMinMatchCheck = 4;  				kFixHashSize = kHash2Size + kHash3Size;  			}  			else {  				kNumHashDirectBytes = 2;  				kMinMatchCheck = 2 + 1;  				kFixHashSize = 0;  			}
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZ\LzBinTree.cs,SetType,The following statement contains a magic number: if (HASH_ARRAY) {  				kNumHashDirectBytes = 0;  				kMinMatchCheck = 4;  				kFixHashSize = kHash2Size + kHash3Size;  			}  			else {  				kNumHashDirectBytes = 2;  				kMinMatchCheck = 2 + 1;  				kFixHashSize = 0;  			}
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZ\LzBinTree.cs,SetType,The following statement contains a magic number: if (HASH_ARRAY) {  				kNumHashDirectBytes = 0;  				kMinMatchCheck = 4;  				kFixHashSize = kHash2Size + kHash3Size;  			}  			else {  				kNumHashDirectBytes = 2;  				kMinMatchCheck = 2 + 1;  				kFixHashSize = 0;  			}
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\LZ\LzBinTree.cs,Normalize,The following statement contains a magic number: NormalizeLinks(_son' _cyclicBufferSize * 2' subValue);
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\RangeCoder\RangeCoder.cs,FlushData,The following statement contains a magic number: for (int i = 0; i < 5; i++)  				ShiftLow();
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\RangeCoder\RangeCoder.cs,Encode,The following statement contains a magic number: while (Range < kTopValue) {  				Range <<= 8;  				ShiftLow();  			}
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\RangeCoder\RangeCoder.cs,ShiftLow,The following statement contains a magic number: if ((uint)Low < 0xFF000000 || (uint)(Low >> 32) == 1) {  				byte temp = _cache;  				do {  					Stream.WriteByte((byte)(temp + (Low >> 32)));  					temp = 0xFF;  				} while (--_cacheSize != 0);  				_cache = (byte)(((uint)Low) >> 24);  			}
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\RangeCoder\RangeCoder.cs,ShiftLow,The following statement contains a magic number: if ((uint)Low < 0xFF000000 || (uint)(Low >> 32) == 1) {  				byte temp = _cache;  				do {  					Stream.WriteByte((byte)(temp + (Low >> 32)));  					temp = 0xFF;  				} while (--_cacheSize != 0);  				_cache = (byte)(((uint)Low) >> 24);  			}
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\RangeCoder\RangeCoder.cs,ShiftLow,The following statement contains a magic number: if ((uint)Low < 0xFF000000 || (uint)(Low >> 32) == 1) {  				byte temp = _cache;  				do {  					Stream.WriteByte((byte)(temp + (Low >> 32)));  					temp = 0xFF;  				} while (--_cacheSize != 0);  				_cache = (byte)(((uint)Low) >> 24);  			}
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\RangeCoder\RangeCoder.cs,ShiftLow,The following statement contains a magic number: Low = ((uint)Low) << 8;
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\RangeCoder\RangeCoder.cs,EncodeDirectBits,The following statement contains a magic number: for (int i = numTotalBits - 1; i >= 0; i--) {  				Range >>= 1;  				if (((v >> i) & 1) == 1)  					Low += Range;  				if (Range < kTopValue) {  					Range <<= 8;  					ShiftLow();  				}  			}
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\RangeCoder\RangeCoder.cs,EncodeBit,The following statement contains a magic number: while (Range < kTopValue) {  				Range <<= 8;  				ShiftLow();  			}
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\RangeCoder\RangeCoder.cs,GetProcessedSizeAdd,The following statement contains a magic number: return _cacheSize +  			       Stream.Position - StartPosition + 4;
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\RangeCoder\RangeCoder.cs,Init,The following statement contains a magic number: for (int i = 0; i < 5; i++)  				Code = (Code << 8) | (byte)Stream.ReadByte();
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\RangeCoder\RangeCoder.cs,Init,The following statement contains a magic number: for (int i = 0; i < 5; i++)  				Code = (Code << 8) | (byte)Stream.ReadByte();
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\RangeCoder\RangeCoder.cs,Normalize,The following statement contains a magic number: while (Range < kTopValue) {  				Code = (Code << 8) | (byte)Stream.ReadByte();  				Range <<= 8;  			}
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\RangeCoder\RangeCoder.cs,Normalize,The following statement contains a magic number: while (Range < kTopValue) {  				Code = (Code << 8) | (byte)Stream.ReadByte();  				Range <<= 8;  			}
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\RangeCoder\RangeCoder.cs,Normalize2,The following statement contains a magic number: if (Range < kTopValue) {  				Code = (Code << 8) | (byte)Stream.ReadByte();  				Range <<= 8;  			}
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\RangeCoder\RangeCoder.cs,Normalize2,The following statement contains a magic number: if (Range < kTopValue) {  				Code = (Code << 8) | (byte)Stream.ReadByte();  				Range <<= 8;  			}
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\RangeCoder\RangeCoder.cs,DecodeDirectBits,The following statement contains a magic number: for (int i = numTotalBits; i > 0; i--) {  				range >>= 1;  				/*                  result <<= 1;                  if (code >= range)                  {                      code -= range;                      result |= 1;                  }                  */  				uint t = (code - range) >> 31;  				code -= range & (t - 1);  				result = (result << 1) | (1 - t);    				if (range < kTopValue) {  					code = (code << 8) | (byte)Stream.ReadByte();  					range <<= 8;  				}  			}
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\RangeCoder\RangeCoder.cs,DecodeDirectBits,The following statement contains a magic number: for (int i = numTotalBits; i > 0; i--) {  				range >>= 1;  				/*                  result <<= 1;                  if (code >= range)                  {                      code -= range;                      result |= 1;                  }                  */  				uint t = (code - range) >> 31;  				code -= range & (t - 1);  				result = (result << 1) | (1 - t);    				if (range < kTopValue) {  					code = (code << 8) | (byte)Stream.ReadByte();  					range <<= 8;  				}  			}
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\RangeCoder\RangeCoder.cs,DecodeDirectBits,The following statement contains a magic number: for (int i = numTotalBits; i > 0; i--) {  				range >>= 1;  				/*                  result <<= 1;                  if (code >= range)                  {                      code -= range;                      result |= 1;                  }                  */  				uint t = (code - range) >> 31;  				code -= range & (t - 1);  				result = (result << 1) | (1 - t);    				if (range < kTopValue) {  					code = (code << 8) | (byte)Stream.ReadByte();  					range <<= 8;  				}  			}
Magic Number,SevenZip.Compression.RangeCoder,BitEncoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\RangeCoder\RangeCoderBit.cs,Encode,The following statement contains a magic number: if (encoder.Range < Encoder.kTopValue) {  				encoder.Range <<= 8;  				encoder.ShiftLow();  			}
Magic Number,SevenZip.Compression.RangeCoder,BitDecoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\RangeCoder\RangeCoderBit.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Code < newBound) {  				rangeDecoder.Range = newBound;  				Prob += (kBitModelTotal - Prob) >> kNumMoveBits;  				if (rangeDecoder.Range < Decoder.kTopValue) {  					rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();  					rangeDecoder.Range <<= 8;  				}  				return 0;  			}
Magic Number,SevenZip.Compression.RangeCoder,BitDecoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\RangeCoder\RangeCoderBit.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Code < newBound) {  				rangeDecoder.Range = newBound;  				Prob += (kBitModelTotal - Prob) >> kNumMoveBits;  				if (rangeDecoder.Range < Decoder.kTopValue) {  					rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();  					rangeDecoder.Range <<= 8;  				}  				return 0;  			}
Magic Number,SevenZip.Compression.RangeCoder,BitDecoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\RangeCoder\RangeCoderBit.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Range < Decoder.kTopValue) {  				rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();  				rangeDecoder.Range <<= 8;  			}
Magic Number,SevenZip.Compression.RangeCoder,BitDecoder,C:\repos\yck1509_ConfuserEx\Confuser.Core\LZMA\Compress\RangeCoder\RangeCoderBit.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Range < Decoder.kTopValue) {  				rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();  				rangeDecoder.Range <<= 8;  			}
Magic Number,Confuser.Core.Services,CompressionService,C:\repos\yck1509_ConfuserEx\Confuser.Core\Services\CompressionService.cs,Compress,The following statement contains a magic number: object[] properties = {  				1 << 23'  				2'  				3'  				0'  				2'  				128'  				"bt4"'  				false  			};
Magic Number,Confuser.Core.Services,CompressionService,C:\repos\yck1509_ConfuserEx\Confuser.Core\Services\CompressionService.cs,Compress,The following statement contains a magic number: object[] properties = {  				1 << 23'  				2'  				3'  				0'  				2'  				128'  				"bt4"'  				false  			};
Magic Number,Confuser.Core.Services,CompressionService,C:\repos\yck1509_ConfuserEx\Confuser.Core\Services\CompressionService.cs,Compress,The following statement contains a magic number: object[] properties = {  				1 << 23'  				2'  				3'  				0'  				2'  				128'  				"bt4"'  				false  			};
Magic Number,Confuser.Core.Services,CompressionService,C:\repos\yck1509_ConfuserEx\Confuser.Core\Services\CompressionService.cs,Compress,The following statement contains a magic number: object[] properties = {  				1 << 23'  				2'  				3'  				0'  				2'  				128'  				"bt4"'  				false  			};
Magic Number,Confuser.Core.Services,CompressionService,C:\repos\yck1509_ConfuserEx\Confuser.Core\Services\CompressionService.cs,Compress,The following statement contains a magic number: object[] properties = {  				1 << 23'  				2'  				3'  				0'  				2'  				128'  				"bt4"'  				false  			};
Magic Number,Confuser.Core.Services,CompressionService,C:\repos\yck1509_ConfuserEx\Confuser.Core\Services\CompressionService.cs,Compress,The following statement contains a magic number: for (int i = 0; i < 8; i++)  				x.WriteByte((Byte)(fileSize >> (8 * i)));
Magic Number,Confuser.Core.Services,CompressionService,C:\repos\yck1509_ConfuserEx\Confuser.Core\Services\CompressionService.cs,Compress,The following statement contains a magic number: for (int i = 0; i < 8; i++)  				x.WriteByte((Byte)(fileSize >> (8 * i)));
Magic Number,Confuser.Core.Services,RandomGenerator,C:\repos\yck1509_ConfuserEx\Confuser.Core\Services\RandomService.cs,RandomGenerator,The following statement contains a magic number: stateFilled = 32;
Magic Number,Confuser.Core.Services,RandomGenerator,C:\repos\yck1509_ConfuserEx\Confuser.Core\Services\RandomService.cs,Seed,The following statement contains a magic number: for (int i = 0; i < 32; i++) {  				ret[i] *= primes[i % primes.Length];  				ret = Utils.SHA256(ret);  			}
Magic Number,Confuser.Core.Services,RandomGenerator,C:\repos\yck1509_ConfuserEx\Confuser.Core\Services\RandomService.cs,NextState,The following statement contains a magic number: for (int i = 0; i < 32; i++)  				state[i] ^= primes[mixIndex = (mixIndex + 1) % primes.Length];
Magic Number,Confuser.Core.Services,RandomGenerator,C:\repos\yck1509_ConfuserEx\Confuser.Core\Services\RandomService.cs,NextState,The following statement contains a magic number: stateFilled = 32;
Magic Number,Confuser.Core.Services,RandomGenerator,C:\repos\yck1509_ConfuserEx\Confuser.Core\Services\RandomService.cs,NextBytes,The following statement contains a magic number: while (length > 0) {  				if (length >= stateFilled) {  					Buffer.BlockCopy(state' 32 - stateFilled' buffer' offset' stateFilled);  					offset += stateFilled;  					length -= stateFilled;  					stateFilled = 0;  				}  				else {  					Buffer.BlockCopy(state' 32 - stateFilled' buffer' offset' length);  					stateFilled -= length;  					length = 0;  				}  				if (stateFilled == 0)  					NextState();  			}
Magic Number,Confuser.Core.Services,RandomGenerator,C:\repos\yck1509_ConfuserEx\Confuser.Core\Services\RandomService.cs,NextBytes,The following statement contains a magic number: while (length > 0) {  				if (length >= stateFilled) {  					Buffer.BlockCopy(state' 32 - stateFilled' buffer' offset' stateFilled);  					offset += stateFilled;  					length -= stateFilled;  					stateFilled = 0;  				}  				else {  					Buffer.BlockCopy(state' 32 - stateFilled' buffer' offset' length);  					stateFilled -= length;  					length = 0;  				}  				if (stateFilled == 0)  					NextState();  			}
Magic Number,Confuser.Core.Services,RandomGenerator,C:\repos\yck1509_ConfuserEx\Confuser.Core\Services\RandomService.cs,NextByte,The following statement contains a magic number: byte ret = state[32 - stateFilled];
Magic Number,Confuser.Core.Services,RandomGenerator,C:\repos\yck1509_ConfuserEx\Confuser.Core\Services\RandomService.cs,NextInt32,The following statement contains a magic number: return BitConverter.ToInt32(NextBytes(4)' 0);
Magic Number,Confuser.Core.Services,RandomGenerator,C:\repos\yck1509_ConfuserEx\Confuser.Core\Services\RandomService.cs,NextUInt32,The following statement contains a magic number: return BitConverter.ToUInt32(NextBytes(4)' 0);
Magic Number,Confuser.Core.Services,RandomGenerator,C:\repos\yck1509_ConfuserEx\Confuser.Core\Services\RandomService.cs,NextBoolean,The following statement contains a magic number: byte s = state[32 - stateFilled];
Magic Number,Confuser.Core.Services,RandomGenerator,C:\repos\yck1509_ConfuserEx\Confuser.Core\Services\RandomService.cs,NextBoolean,The following statement contains a magic number: return s % 2 == 0;
Magic Number,Confuser.Core.Services,RandomService,C:\repos\yck1509_ConfuserEx\Confuser.Core\Services\RandomService.cs,GetRandomGenerator,The following statement contains a magic number: for (int i = 0; i < 32; i++)  				newSeed[i] ^= idHash[i];
Missing Default,Confuser.Core,ImageStream,C:\repos\yck1509_ConfuserEx\Confuser.Core\DnlibUtils.cs,Seek,The following switch statement is missing a default case: switch (origin) {  				case SeekOrigin.Begin:  					BaseStream.Position = offset;  					break;  				case SeekOrigin.Current:  					BaseStream.Position += offset;  					break;  				case SeekOrigin.End:  					BaseStream.Position = BaseStream.Length + offset;  					break;  			}
Missing Default,Confuser.Core,ObfAttrParser,C:\repos\yck1509_ConfuserEx\Confuser.Core\ObfAttrParser.cs,ParseProtectionString,The following switch statement is missing a default case: switch (state) {  					case ParseState.Init:  						ReadId(buffer);  						if (buffer.ToString().Equals("preset"' StringComparison.OrdinalIgnoreCase)) {  							if (IsEnd())  								throw new ArgumentException("Unexpected end of string in Init state.");  							Expect('(');  							buffer.Length = 0;  							state = ParseState.ReadPreset;  						}  						else if (buffer.Length == 0) {  							if (IsEnd())  								throw new ArgumentException("Unexpected end of string in Init state.");  							state = ParseState.ReadItemName;  						}  						else {  							protAct = true;  							state = ParseState.ProcessItemName;  						}  						break;    					case ParseState.ReadPreset:  						if (!ReadId(buffer))  							throw new ArgumentException("Unexpected end of string in ReadPreset state.");  						Expect(')');    						var preset = (ProtectionPreset)Enum.Parse(typeof(ProtectionPreset)' buffer.ToString()' true);  						foreach (var item in items.Values.OfType<Protection>().Where(prot => prot.Preset <= preset)) {  							if (item.Preset != ProtectionPreset.None && settings != null && !settings.ContainsKey(item))  								settings.Add(item' new Dictionary<string' string>(StringComparer.OrdinalIgnoreCase));  						}  						buffer.Length = 0;    						if (IsEnd())  							state = ParseState.End;  						else {  							Expect(';');  							if (IsEnd())  								state = ParseState.End;  							else  								state = ParseState.ReadItemName;  						}  						break;    					case ParseState.ReadItemName:  						protAct = true;  						if (Peek() == '+') {  							protAct = true;  							Next();  						}  						else if (Peek() == '-') {  							protAct = false;  							Next();  						}  						ReadId(buffer);  						state = ParseState.ProcessItemName;  						break;    					case ParseState.ProcessItemName:  						protId = buffer.ToString();  						buffer.Length = 0;  						if (IsEnd() || Peek() == ';')  							state = ParseState.EndItem;  						else if (Peek() == '(') {  							if (!protAct)  								throw new ArgumentException("No parameters is allowed when removing protection.");  							Next();  							state = ParseState.ReadParam;  						}  						else  							throw new ArgumentException("Unexpected character in ProcessItemName state at " + index + ".");  						break;    					case ParseState.ReadParam:  						string paramName' paramValue;    						if (!ReadId(buffer))  							throw new ArgumentException("Unexpected end of string in ReadParam state.");  						paramName = buffer.ToString();  						buffer.Length = 0;    						Expect('=');  						if (!(Peek() == '\'' ? ReadString(buffer) : ReadId(buffer)))  							throw new ArgumentException("Unexpected end of string in ReadParam state.");    						paramValue = buffer.ToString();  						buffer.Length = 0;    						protParams.Add(paramName' paramValue);    						if (Peek() == ''') {  							Next();  							state = ParseState.ReadParam;  						}  						else if (Peek() == ')') {  							Next();  							state = ParseState.EndItem;  						}  						else  							throw new ArgumentException("Unexpected character in ReadParam state at " + index + ".");  						break;    					case ParseState.EndItem:  						if (settings != null) {  							if (!items.Contains(protId))  								throw new KeyNotFoundException("Cannot find protection with id '" + protId + "'.");    							if (protAct) {  								if (settings.ContainsKey((Protection)items[protId])) {  									var p = settings[(Protection)items[protId]];  									foreach (var kvp in protParams)  										p[kvp.Key] = kvp.Value;  								}  								else  									settings[(Protection)items[protId]] = protParams;  							}  							else  								settings.Remove((Protection)items[protId]);  						}  						protParams = new Dictionary<string' string>(StringComparer.OrdinalIgnoreCase);    						if (IsEnd())  							state = ParseState.End;  						else {  							Expect(';');  							if (IsEnd())  								state = ParseState.End;  							else  								state = ParseState.ReadItemName;  						}  						break;  				}
Missing Default,Confuser.Core,ObfAttrParser,C:\repos\yck1509_ConfuserEx\Confuser.Core\ObfAttrParser.cs,ParsePackerString,The following switch statement is missing a default case: switch (state) {  					case ParseState.ReadItemName:  						ReadId(buffer);    						var packerId = buffer.ToString();  						if (!items.Contains(packerId))  							throw new KeyNotFoundException("Cannot find packer with id '" + packerId + "'.");    						packer = (Packer)items[packerId];  						buffer.Length = 0;    						if (IsEnd() || Peek() == ';')  							state = ParseState.EndItem;  						else if (Peek() == '(') {  							Next();  							state = ParseState.ReadParam;  						}  						else  							throw new ArgumentException("Unexpected character in ReadItemName state at " + index + ".");  						break;    					case ParseState.ReadParam:  						string paramName' paramValue;    						if (!ReadId(buffer))  							throw new ArgumentException("Unexpected end of string in ReadParam state.");  						paramName = buffer.ToString();  						buffer.Length = 0;    						Expect('=');  						if (!ReadId(buffer))  							throw new ArgumentException("Unexpected end of string in ReadParam state.");  						paramValue = buffer.ToString();  						buffer.Length = 0;    						packerParams.Add(paramName' paramValue);    						if (Peek() == ''') {  							Next();  							state = ParseState.ReadParam;  						}  						else if (Peek() == ')') {  							Next();  							state = ParseState.EndItem;  						}  						else  							throw new ArgumentException("Unexpected character in ReadParam state at " + index + ".");  						break;    					case ParseState.EndItem:  						if (IsEnd())  							state = ParseState.End;  						else {  							Expect(';');  							if (!IsEnd())  								throw new ArgumentException("Unexpected character in EndItem state at " + index + ".");  							state = ParseState.End;  						}  						break;  				}
