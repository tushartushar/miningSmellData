Implementation smell,Namespace,Class,File,Method,Description
Long Method,Confuser.DynCipher.Generation,x86Instruction,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\x86CodeGen.cs,Assemble,The method has 149 lines of code.
Complex Method,Confuser.DynCipher.Generation,CipherGenerator,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\CipherGenerator.cs,GeneratePair,Cyclomatic complexity of the method is 13
Complex Method,Confuser.DynCipher.Transforms,MulToShiftTransform,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Transforms\MulToShiftTransform.cs,ProcessExpression,Cyclomatic complexity of the method is 10
Long Parameter List,Confuser.DynCipher,IDynCipherService,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\DynCipherService.cs,GenerateExpressionPair,The method has 6 parameters. Parameters: random' var' result' depth' expression' inverse
Long Parameter List,Confuser.DynCipher,DynCipherService,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\DynCipherService.cs,GenerateExpressionPair,The method has 6 parameters. Parameters: random' var' result' depth' expression' inverse
Long Parameter List,Confuser.DynCipher.Generation,ExpressionGenerator,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\ExpressionGenerator.cs,GeneratePair,The method has 6 parameters. Parameters: random' var' result' depth' expression' inverse
Long Statement,Confuser.DynCipher,CodeGenUtils,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Utils.cs,AssembleCode,The length of the statement  "					writer.Write(x86Instruction.Create(x86OpCode.MOV' new x86RegisterOperand(x86Register.EAX)' new x86RegisterOperand(reg)).Assemble()); " is 132.
Long Statement,Confuser.DynCipher.Generation,ExpressionGenerator,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\ExpressionGenerator.cs,GenerateExpression,The length of the statement  "					return GenerateExpression(random' current' currentDepth + 1' targetDepth) * (LiteralExpression)(random.NextUInt32() | 1); " is 121.
Complex Conditional,Confuser.DynCipher.Transforms,NormalizeBinOpTransform,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Transforms\NormalizeBinOpTransform.cs,ProcessExpression,The conditional expression  "binOpRight != null && binOpRight.Operation == binOp.Operation &&  				    (binOp.Operation == BinOps.Add || binOp.Operation == BinOps.Mul ||  				     binOp.Operation == BinOps.Or || binOp.Operation == BinOps.And ||  				     binOp.Operation == BinOps.Xor)"  is complex.
Magic Number,Confuser.DynCipher.Elements,BinOp,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\BinOp.cs,Initialize,The following statement contains a magic number: Operation = (CryptoBinOps)random.NextInt32(3);
Magic Number,Confuser.DynCipher.Elements,Matrix,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,GenerateUnimodularMatrix,The following statement contains a magic number: Func<uint> next = () => (uint)random.NextInt32(4);
Magic Number,Confuser.DynCipher.Elements,Matrix,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,cofactor4,The following statement contains a magic number: var sub = new uint[3' 3];
Magic Number,Confuser.DynCipher.Elements,Matrix,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,cofactor4,The following statement contains a magic number: var sub = new uint[3' 3];
Magic Number,Confuser.DynCipher.Elements,Matrix,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,cofactor4,The following statement contains a magic number: for (int ci = 0' si = 0; ci < 4; ci++' si++) {  				if (ci == i) {  					si--;  					continue;  				}  				for (int cj = 0' sj = 0; cj < 4; cj++' sj++) {  					if (cj == j) {  						sj--;  						continue;  					}  					sub[si' sj] = mat[ci' cj];  				}  			}
Magic Number,Confuser.DynCipher.Elements,Matrix,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,cofactor4,The following statement contains a magic number: for (int ci = 0' si = 0; ci < 4; ci++' si++) {  				if (ci == i) {  					si--;  					continue;  				}  				for (int cj = 0' sj = 0; cj < 4; cj++' sj++) {  					if (cj == j) {  						sj--;  						continue;  					}  					sub[si' sj] = mat[ci' cj];  				}  			}
Magic Number,Confuser.DynCipher.Elements,Matrix,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,cofactor4,The following statement contains a magic number: if ((i + j) % 2 == 0) return ret;
Magic Number,Confuser.DynCipher.Elements,Matrix,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,det3,The following statement contains a magic number: return mat[0' 0] * mat[1' 1] * mat[2' 2] +  			       mat[0' 1] * mat[1' 2] * mat[2' 0] +  			       mat[0' 2] * mat[1' 0] * mat[2' 1] -  			       mat[0' 2] * mat[1' 1] * mat[2' 0] -  			       mat[0' 1] * mat[1' 0] * mat[2' 2] -  			       mat[0' 0] * mat[1' 2] * mat[2' 1];
Magic Number,Confuser.DynCipher.Elements,Matrix,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,det3,The following statement contains a magic number: return mat[0' 0] * mat[1' 1] * mat[2' 2] +  			       mat[0' 1] * mat[1' 2] * mat[2' 0] +  			       mat[0' 2] * mat[1' 0] * mat[2' 1] -  			       mat[0' 2] * mat[1' 1] * mat[2' 0] -  			       mat[0' 1] * mat[1' 0] * mat[2' 2] -  			       mat[0' 0] * mat[1' 2] * mat[2' 1];
Magic Number,Confuser.DynCipher.Elements,Matrix,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,det3,The following statement contains a magic number: return mat[0' 0] * mat[1' 1] * mat[2' 2] +  			       mat[0' 1] * mat[1' 2] * mat[2' 0] +  			       mat[0' 2] * mat[1' 0] * mat[2' 1] -  			       mat[0' 2] * mat[1' 1] * mat[2' 0] -  			       mat[0' 1] * mat[1' 0] * mat[2' 2] -  			       mat[0' 0] * mat[1' 2] * mat[2' 1];
Magic Number,Confuser.DynCipher.Elements,Matrix,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,det3,The following statement contains a magic number: return mat[0' 0] * mat[1' 1] * mat[2' 2] +  			       mat[0' 1] * mat[1' 2] * mat[2' 0] +  			       mat[0' 2] * mat[1' 0] * mat[2' 1] -  			       mat[0' 2] * mat[1' 1] * mat[2' 0] -  			       mat[0' 1] * mat[1' 0] * mat[2' 2] -  			       mat[0' 0] * mat[1' 2] * mat[2' 1];
Magic Number,Confuser.DynCipher.Elements,Matrix,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,det3,The following statement contains a magic number: return mat[0' 0] * mat[1' 1] * mat[2' 2] +  			       mat[0' 1] * mat[1' 2] * mat[2' 0] +  			       mat[0' 2] * mat[1' 0] * mat[2' 1] -  			       mat[0' 2] * mat[1' 1] * mat[2' 0] -  			       mat[0' 1] * mat[1' 0] * mat[2' 2] -  			       mat[0' 0] * mat[1' 2] * mat[2' 1];
Magic Number,Confuser.DynCipher.Elements,Matrix,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,det3,The following statement contains a magic number: return mat[0' 0] * mat[1' 1] * mat[2' 2] +  			       mat[0' 1] * mat[1' 2] * mat[2' 0] +  			       mat[0' 2] * mat[1' 0] * mat[2' 1] -  			       mat[0' 2] * mat[1' 1] * mat[2' 0] -  			       mat[0' 1] * mat[1' 0] * mat[2' 2] -  			       mat[0' 0] * mat[1' 2] * mat[2' 1];
Magic Number,Confuser.DynCipher.Elements,Matrix,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,det3,The following statement contains a magic number: return mat[0' 0] * mat[1' 1] * mat[2' 2] +  			       mat[0' 1] * mat[1' 2] * mat[2' 0] +  			       mat[0' 2] * mat[1' 0] * mat[2' 1] -  			       mat[0' 2] * mat[1' 1] * mat[2' 0] -  			       mat[0' 1] * mat[1' 0] * mat[2' 2] -  			       mat[0' 0] * mat[1' 2] * mat[2' 1];
Magic Number,Confuser.DynCipher.Elements,Matrix,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,det3,The following statement contains a magic number: return mat[0' 0] * mat[1' 1] * mat[2' 2] +  			       mat[0' 1] * mat[1' 2] * mat[2' 0] +  			       mat[0' 2] * mat[1' 0] * mat[2' 1] -  			       mat[0' 2] * mat[1' 1] * mat[2' 0] -  			       mat[0' 1] * mat[1' 0] * mat[2' 2] -  			       mat[0' 0] * mat[1' 2] * mat[2' 1];
Magic Number,Confuser.DynCipher.Elements,Matrix,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,det3,The following statement contains a magic number: return mat[0' 0] * mat[1' 1] * mat[2' 2] +  			       mat[0' 1] * mat[1' 2] * mat[2' 0] +  			       mat[0' 2] * mat[1' 0] * mat[2' 1] -  			       mat[0' 2] * mat[1' 1] * mat[2' 0] -  			       mat[0' 1] * mat[1' 0] * mat[2' 2] -  			       mat[0' 0] * mat[1' 2] * mat[2' 1];
Magic Number,Confuser.DynCipher.Elements,Matrix,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,det3,The following statement contains a magic number: return mat[0' 0] * mat[1' 1] * mat[2' 2] +  			       mat[0' 1] * mat[1' 2] * mat[2' 0] +  			       mat[0' 2] * mat[1' 0] * mat[2' 1] -  			       mat[0' 2] * mat[1' 1] * mat[2' 0] -  			       mat[0' 1] * mat[1' 0] * mat[2' 2] -  			       mat[0' 0] * mat[1' 2] * mat[2' 1];
Magic Number,Confuser.DynCipher.Elements,Matrix,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,det3,The following statement contains a magic number: return mat[0' 0] * mat[1' 1] * mat[2' 2] +  			       mat[0' 1] * mat[1' 2] * mat[2' 0] +  			       mat[0' 2] * mat[1' 0] * mat[2' 1] -  			       mat[0' 2] * mat[1' 1] * mat[2' 0] -  			       mat[0' 1] * mat[1' 0] * mat[2' 2] -  			       mat[0' 0] * mat[1' 2] * mat[2' 1];
Magic Number,Confuser.DynCipher.Elements,Matrix,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,det3,The following statement contains a magic number: return mat[0' 0] * mat[1' 1] * mat[2' 2] +  			       mat[0' 1] * mat[1' 2] * mat[2' 0] +  			       mat[0' 2] * mat[1' 0] * mat[2' 1] -  			       mat[0' 2] * mat[1' 1] * mat[2' 0] -  			       mat[0' 1] * mat[1' 0] * mat[2' 2] -  			       mat[0' 0] * mat[1' 2] * mat[2' 1];
Magic Number,Confuser.DynCipher.Elements,Matrix,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,transpose4,The following statement contains a magic number: var ret = new uint[4' 4];
Magic Number,Confuser.DynCipher.Elements,Matrix,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,transpose4,The following statement contains a magic number: var ret = new uint[4' 4];
Magic Number,Confuser.DynCipher.Elements,Matrix,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,transpose4,The following statement contains a magic number: for (int i = 0; i < 4; i++)  				for (int j = 0; j < 4; j++)  					ret[j' i] = mat[i' j];
Magic Number,Confuser.DynCipher.Elements,Matrix,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,transpose4,The following statement contains a magic number: for (int i = 0; i < 4; i++)  				for (int j = 0; j < 4; j++)  					ret[j' i] = mat[i' j];
Magic Number,Confuser.DynCipher.Elements,Matrix,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,Initialize,The following statement contains a magic number: var cof = new uint[4' 4];
Magic Number,Confuser.DynCipher.Elements,Matrix,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,Initialize,The following statement contains a magic number: var cof = new uint[4' 4];
Magic Number,Confuser.DynCipher.Elements,Matrix,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < 4; i++)  				for (int j = 0; j < 4; j++)  					cof[i' j] = cofactor4(InverseKey' i' j);
Magic Number,Confuser.DynCipher.Elements,Matrix,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < 4; i++)  				for (int j = 0; j < 4; j++)  					cof[i' j] = cofactor4(InverseKey' i' j);
Magic Number,Confuser.DynCipher.Elements,Matrix,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,EmitCore,The following statement contains a magic number: Expression c = context.GetDataExpression(DataIndexes[2]);
Magic Number,Confuser.DynCipher.Elements,Matrix,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,EmitCore,The following statement contains a magic number: Expression d = context.GetDataExpression(DataIndexes[3]);
Magic Number,Confuser.DynCipher.Elements,Matrix,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,EmitCore,The following statement contains a magic number: using (context.AcquireTempVar(out ta))  			using (context.AcquireTempVar(out tb))  			using (context.AcquireTempVar(out tc))  			using (context.AcquireTempVar(out td)) {  				context.Emit(new AssignmentStatement {  					Value = a * l(k[0' 0]) + b * l(k[0' 1]) + c * l(k[0' 2]) + d * l(k[0' 3])'  					Target = ta  				}).Emit(new AssignmentStatement {  					Value = a * l(k[1' 0]) + b * l(k[1' 1]) + c * l(k[1' 2]) + d * l(k[1' 3])'  					Target = tb  				}).Emit(new AssignmentStatement {  					Value = a * l(k[2' 0]) + b * l(k[2' 1]) + c * l(k[2' 2]) + d * l(k[2' 3])'  					Target = tc  				}).Emit(new AssignmentStatement {  					Value = a * l(k[3' 0]) + b * l(k[3' 1]) + c * l(k[3' 2]) + d * l(k[3' 3])'  					Target = td  				})  				       .Emit(new AssignmentStatement { Value = ta' Target = a })  				       .Emit(new AssignmentStatement { Value = tb' Target = b })  				       .Emit(new AssignmentStatement { Value = tc' Target = c })  				       .Emit(new AssignmentStatement { Value = td' Target = d });  			}
Magic Number,Confuser.DynCipher.Elements,Matrix,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,EmitCore,The following statement contains a magic number: using (context.AcquireTempVar(out ta))  			using (context.AcquireTempVar(out tb))  			using (context.AcquireTempVar(out tc))  			using (context.AcquireTempVar(out td)) {  				context.Emit(new AssignmentStatement {  					Value = a * l(k[0' 0]) + b * l(k[0' 1]) + c * l(k[0' 2]) + d * l(k[0' 3])'  					Target = ta  				}).Emit(new AssignmentStatement {  					Value = a * l(k[1' 0]) + b * l(k[1' 1]) + c * l(k[1' 2]) + d * l(k[1' 3])'  					Target = tb  				}).Emit(new AssignmentStatement {  					Value = a * l(k[2' 0]) + b * l(k[2' 1]) + c * l(k[2' 2]) + d * l(k[2' 3])'  					Target = tc  				}).Emit(new AssignmentStatement {  					Value = a * l(k[3' 0]) + b * l(k[3' 1]) + c * l(k[3' 2]) + d * l(k[3' 3])'  					Target = td  				})  				       .Emit(new AssignmentStatement { Value = ta' Target = a })  				       .Emit(new AssignmentStatement { Value = tb' Target = b })  				       .Emit(new AssignmentStatement { Value = tc' Target = c })  				       .Emit(new AssignmentStatement { Value = td' Target = d });  			}
Magic Number,Confuser.DynCipher.Elements,Matrix,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,EmitCore,The following statement contains a magic number: using (context.AcquireTempVar(out ta))  			using (context.AcquireTempVar(out tb))  			using (context.AcquireTempVar(out tc))  			using (context.AcquireTempVar(out td)) {  				context.Emit(new AssignmentStatement {  					Value = a * l(k[0' 0]) + b * l(k[0' 1]) + c * l(k[0' 2]) + d * l(k[0' 3])'  					Target = ta  				}).Emit(new AssignmentStatement {  					Value = a * l(k[1' 0]) + b * l(k[1' 1]) + c * l(k[1' 2]) + d * l(k[1' 3])'  					Target = tb  				}).Emit(new AssignmentStatement {  					Value = a * l(k[2' 0]) + b * l(k[2' 1]) + c * l(k[2' 2]) + d * l(k[2' 3])'  					Target = tc  				}).Emit(new AssignmentStatement {  					Value = a * l(k[3' 0]) + b * l(k[3' 1]) + c * l(k[3' 2]) + d * l(k[3' 3])'  					Target = td  				})  				       .Emit(new AssignmentStatement { Value = ta' Target = a })  				       .Emit(new AssignmentStatement { Value = tb' Target = b })  				       .Emit(new AssignmentStatement { Value = tc' Target = c })  				       .Emit(new AssignmentStatement { Value = td' Target = d });  			}
Magic Number,Confuser.DynCipher.Elements,Matrix,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,EmitCore,The following statement contains a magic number: using (context.AcquireTempVar(out ta))  			using (context.AcquireTempVar(out tb))  			using (context.AcquireTempVar(out tc))  			using (context.AcquireTempVar(out td)) {  				context.Emit(new AssignmentStatement {  					Value = a * l(k[0' 0]) + b * l(k[0' 1]) + c * l(k[0' 2]) + d * l(k[0' 3])'  					Target = ta  				}).Emit(new AssignmentStatement {  					Value = a * l(k[1' 0]) + b * l(k[1' 1]) + c * l(k[1' 2]) + d * l(k[1' 3])'  					Target = tb  				}).Emit(new AssignmentStatement {  					Value = a * l(k[2' 0]) + b * l(k[2' 1]) + c * l(k[2' 2]) + d * l(k[2' 3])'  					Target = tc  				}).Emit(new AssignmentStatement {  					Value = a * l(k[3' 0]) + b * l(k[3' 1]) + c * l(k[3' 2]) + d * l(k[3' 3])'  					Target = td  				})  				       .Emit(new AssignmentStatement { Value = ta' Target = a })  				       .Emit(new AssignmentStatement { Value = tb' Target = b })  				       .Emit(new AssignmentStatement { Value = tc' Target = c })  				       .Emit(new AssignmentStatement { Value = td' Target = d });  			}
Magic Number,Confuser.DynCipher.Elements,Matrix,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,EmitCore,The following statement contains a magic number: using (context.AcquireTempVar(out ta))  			using (context.AcquireTempVar(out tb))  			using (context.AcquireTempVar(out tc))  			using (context.AcquireTempVar(out td)) {  				context.Emit(new AssignmentStatement {  					Value = a * l(k[0' 0]) + b * l(k[0' 1]) + c * l(k[0' 2]) + d * l(k[0' 3])'  					Target = ta  				}).Emit(new AssignmentStatement {  					Value = a * l(k[1' 0]) + b * l(k[1' 1]) + c * l(k[1' 2]) + d * l(k[1' 3])'  					Target = tb  				}).Emit(new AssignmentStatement {  					Value = a * l(k[2' 0]) + b * l(k[2' 1]) + c * l(k[2' 2]) + d * l(k[2' 3])'  					Target = tc  				}).Emit(new AssignmentStatement {  					Value = a * l(k[3' 0]) + b * l(k[3' 1]) + c * l(k[3' 2]) + d * l(k[3' 3])'  					Target = td  				})  				       .Emit(new AssignmentStatement { Value = ta' Target = a })  				       .Emit(new AssignmentStatement { Value = tb' Target = b })  				       .Emit(new AssignmentStatement { Value = tc' Target = c })  				       .Emit(new AssignmentStatement { Value = td' Target = d });  			}
Magic Number,Confuser.DynCipher.Elements,Matrix,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,EmitCore,The following statement contains a magic number: using (context.AcquireTempVar(out ta))  			using (context.AcquireTempVar(out tb))  			using (context.AcquireTempVar(out tc))  			using (context.AcquireTempVar(out td)) {  				context.Emit(new AssignmentStatement {  					Value = a * l(k[0' 0]) + b * l(k[0' 1]) + c * l(k[0' 2]) + d * l(k[0' 3])'  					Target = ta  				}).Emit(new AssignmentStatement {  					Value = a * l(k[1' 0]) + b * l(k[1' 1]) + c * l(k[1' 2]) + d * l(k[1' 3])'  					Target = tb  				}).Emit(new AssignmentStatement {  					Value = a * l(k[2' 0]) + b * l(k[2' 1]) + c * l(k[2' 2]) + d * l(k[2' 3])'  					Target = tc  				}).Emit(new AssignmentStatement {  					Value = a * l(k[3' 0]) + b * l(k[3' 1]) + c * l(k[3' 2]) + d * l(k[3' 3])'  					Target = td  				})  				       .Emit(new AssignmentStatement { Value = ta' Target = a })  				       .Emit(new AssignmentStatement { Value = tb' Target = b })  				       .Emit(new AssignmentStatement { Value = tc' Target = c })  				       .Emit(new AssignmentStatement { Value = td' Target = d });  			}
Magic Number,Confuser.DynCipher.Elements,Matrix,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,EmitCore,The following statement contains a magic number: using (context.AcquireTempVar(out ta))  			using (context.AcquireTempVar(out tb))  			using (context.AcquireTempVar(out tc))  			using (context.AcquireTempVar(out td)) {  				context.Emit(new AssignmentStatement {  					Value = a * l(k[0' 0]) + b * l(k[0' 1]) + c * l(k[0' 2]) + d * l(k[0' 3])'  					Target = ta  				}).Emit(new AssignmentStatement {  					Value = a * l(k[1' 0]) + b * l(k[1' 1]) + c * l(k[1' 2]) + d * l(k[1' 3])'  					Target = tb  				}).Emit(new AssignmentStatement {  					Value = a * l(k[2' 0]) + b * l(k[2' 1]) + c * l(k[2' 2]) + d * l(k[2' 3])'  					Target = tc  				}).Emit(new AssignmentStatement {  					Value = a * l(k[3' 0]) + b * l(k[3' 1]) + c * l(k[3' 2]) + d * l(k[3' 3])'  					Target = td  				})  				       .Emit(new AssignmentStatement { Value = ta' Target = a })  				       .Emit(new AssignmentStatement { Value = tb' Target = b })  				       .Emit(new AssignmentStatement { Value = tc' Target = c })  				       .Emit(new AssignmentStatement { Value = td' Target = d });  			}
Magic Number,Confuser.DynCipher.Elements,Matrix,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,EmitCore,The following statement contains a magic number: using (context.AcquireTempVar(out ta))  			using (context.AcquireTempVar(out tb))  			using (context.AcquireTempVar(out tc))  			using (context.AcquireTempVar(out td)) {  				context.Emit(new AssignmentStatement {  					Value = a * l(k[0' 0]) + b * l(k[0' 1]) + c * l(k[0' 2]) + d * l(k[0' 3])'  					Target = ta  				}).Emit(new AssignmentStatement {  					Value = a * l(k[1' 0]) + b * l(k[1' 1]) + c * l(k[1' 2]) + d * l(k[1' 3])'  					Target = tb  				}).Emit(new AssignmentStatement {  					Value = a * l(k[2' 0]) + b * l(k[2' 1]) + c * l(k[2' 2]) + d * l(k[2' 3])'  					Target = tc  				}).Emit(new AssignmentStatement {  					Value = a * l(k[3' 0]) + b * l(k[3' 1]) + c * l(k[3' 2]) + d * l(k[3' 3])'  					Target = td  				})  				       .Emit(new AssignmentStatement { Value = ta' Target = a })  				       .Emit(new AssignmentStatement { Value = tb' Target = b })  				       .Emit(new AssignmentStatement { Value = tc' Target = c })  				       .Emit(new AssignmentStatement { Value = td' Target = d });  			}
Magic Number,Confuser.DynCipher.Elements,Matrix,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,EmitCore,The following statement contains a magic number: using (context.AcquireTempVar(out ta))  			using (context.AcquireTempVar(out tb))  			using (context.AcquireTempVar(out tc))  			using (context.AcquireTempVar(out td)) {  				context.Emit(new AssignmentStatement {  					Value = a * l(k[0' 0]) + b * l(k[0' 1]) + c * l(k[0' 2]) + d * l(k[0' 3])'  					Target = ta  				}).Emit(new AssignmentStatement {  					Value = a * l(k[1' 0]) + b * l(k[1' 1]) + c * l(k[1' 2]) + d * l(k[1' 3])'  					Target = tb  				}).Emit(new AssignmentStatement {  					Value = a * l(k[2' 0]) + b * l(k[2' 1]) + c * l(k[2' 2]) + d * l(k[2' 3])'  					Target = tc  				}).Emit(new AssignmentStatement {  					Value = a * l(k[3' 0]) + b * l(k[3' 1]) + c * l(k[3' 2]) + d * l(k[3' 3])'  					Target = td  				})  				       .Emit(new AssignmentStatement { Value = ta' Target = a })  				       .Emit(new AssignmentStatement { Value = tb' Target = b })  				       .Emit(new AssignmentStatement { Value = tc' Target = c })  				       .Emit(new AssignmentStatement { Value = td' Target = d });  			}
Magic Number,Confuser.DynCipher.Elements,Matrix,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,EmitCore,The following statement contains a magic number: using (context.AcquireTempVar(out ta))  			using (context.AcquireTempVar(out tb))  			using (context.AcquireTempVar(out tc))  			using (context.AcquireTempVar(out td)) {  				context.Emit(new AssignmentStatement {  					Value = a * l(k[0' 0]) + b * l(k[0' 1]) + c * l(k[0' 2]) + d * l(k[0' 3])'  					Target = ta  				}).Emit(new AssignmentStatement {  					Value = a * l(k[1' 0]) + b * l(k[1' 1]) + c * l(k[1' 2]) + d * l(k[1' 3])'  					Target = tb  				}).Emit(new AssignmentStatement {  					Value = a * l(k[2' 0]) + b * l(k[2' 1]) + c * l(k[2' 2]) + d * l(k[2' 3])'  					Target = tc  				}).Emit(new AssignmentStatement {  					Value = a * l(k[3' 0]) + b * l(k[3' 1]) + c * l(k[3' 2]) + d * l(k[3' 3])'  					Target = td  				})  				       .Emit(new AssignmentStatement { Value = ta' Target = a })  				       .Emit(new AssignmentStatement { Value = tb' Target = b })  				       .Emit(new AssignmentStatement { Value = tc' Target = c })  				       .Emit(new AssignmentStatement { Value = td' Target = d });  			}
Magic Number,Confuser.DynCipher.Elements,Matrix,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,EmitCore,The following statement contains a magic number: using (context.AcquireTempVar(out ta))  			using (context.AcquireTempVar(out tb))  			using (context.AcquireTempVar(out tc))  			using (context.AcquireTempVar(out td)) {  				context.Emit(new AssignmentStatement {  					Value = a * l(k[0' 0]) + b * l(k[0' 1]) + c * l(k[0' 2]) + d * l(k[0' 3])'  					Target = ta  				}).Emit(new AssignmentStatement {  					Value = a * l(k[1' 0]) + b * l(k[1' 1]) + c * l(k[1' 2]) + d * l(k[1' 3])'  					Target = tb  				}).Emit(new AssignmentStatement {  					Value = a * l(k[2' 0]) + b * l(k[2' 1]) + c * l(k[2' 2]) + d * l(k[2' 3])'  					Target = tc  				}).Emit(new AssignmentStatement {  					Value = a * l(k[3' 0]) + b * l(k[3' 1]) + c * l(k[3' 2]) + d * l(k[3' 3])'  					Target = td  				})  				       .Emit(new AssignmentStatement { Value = ta' Target = a })  				       .Emit(new AssignmentStatement { Value = tb' Target = b })  				       .Emit(new AssignmentStatement { Value = tc' Target = c })  				       .Emit(new AssignmentStatement { Value = td' Target = d });  			}
Magic Number,Confuser.DynCipher.Elements,Matrix,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,EmitCore,The following statement contains a magic number: using (context.AcquireTempVar(out ta))  			using (context.AcquireTempVar(out tb))  			using (context.AcquireTempVar(out tc))  			using (context.AcquireTempVar(out td)) {  				context.Emit(new AssignmentStatement {  					Value = a * l(k[0' 0]) + b * l(k[0' 1]) + c * l(k[0' 2]) + d * l(k[0' 3])'  					Target = ta  				}).Emit(new AssignmentStatement {  					Value = a * l(k[1' 0]) + b * l(k[1' 1]) + c * l(k[1' 2]) + d * l(k[1' 3])'  					Target = tb  				}).Emit(new AssignmentStatement {  					Value = a * l(k[2' 0]) + b * l(k[2' 1]) + c * l(k[2' 2]) + d * l(k[2' 3])'  					Target = tc  				}).Emit(new AssignmentStatement {  					Value = a * l(k[3' 0]) + b * l(k[3' 1]) + c * l(k[3' 2]) + d * l(k[3' 3])'  					Target = td  				})  				       .Emit(new AssignmentStatement { Value = ta' Target = a })  				       .Emit(new AssignmentStatement { Value = tb' Target = b })  				       .Emit(new AssignmentStatement { Value = tc' Target = c })  				       .Emit(new AssignmentStatement { Value = td' Target = d });  			}
Magic Number,Confuser.DynCipher.Elements,Matrix,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,EmitCore,The following statement contains a magic number: using (context.AcquireTempVar(out ta))  			using (context.AcquireTempVar(out tb))  			using (context.AcquireTempVar(out tc))  			using (context.AcquireTempVar(out td)) {  				context.Emit(new AssignmentStatement {  					Value = a * l(k[0' 0]) + b * l(k[0' 1]) + c * l(k[0' 2]) + d * l(k[0' 3])'  					Target = ta  				}).Emit(new AssignmentStatement {  					Value = a * l(k[1' 0]) + b * l(k[1' 1]) + c * l(k[1' 2]) + d * l(k[1' 3])'  					Target = tb  				}).Emit(new AssignmentStatement {  					Value = a * l(k[2' 0]) + b * l(k[2' 1]) + c * l(k[2' 2]) + d * l(k[2' 3])'  					Target = tc  				}).Emit(new AssignmentStatement {  					Value = a * l(k[3' 0]) + b * l(k[3' 1]) + c * l(k[3' 2]) + d * l(k[3' 3])'  					Target = td  				})  				       .Emit(new AssignmentStatement { Value = ta' Target = a })  				       .Emit(new AssignmentStatement { Value = tb' Target = b })  				       .Emit(new AssignmentStatement { Value = tc' Target = c })  				       .Emit(new AssignmentStatement { Value = td' Target = d });  			}
Magic Number,Confuser.DynCipher.Elements,Matrix,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,EmitCore,The following statement contains a magic number: using (context.AcquireTempVar(out ta))  			using (context.AcquireTempVar(out tb))  			using (context.AcquireTempVar(out tc))  			using (context.AcquireTempVar(out td)) {  				context.Emit(new AssignmentStatement {  					Value = a * l(k[0' 0]) + b * l(k[0' 1]) + c * l(k[0' 2]) + d * l(k[0' 3])'  					Target = ta  				}).Emit(new AssignmentStatement {  					Value = a * l(k[1' 0]) + b * l(k[1' 1]) + c * l(k[1' 2]) + d * l(k[1' 3])'  					Target = tb  				}).Emit(new AssignmentStatement {  					Value = a * l(k[2' 0]) + b * l(k[2' 1]) + c * l(k[2' 2]) + d * l(k[2' 3])'  					Target = tc  				}).Emit(new AssignmentStatement {  					Value = a * l(k[3' 0]) + b * l(k[3' 1]) + c * l(k[3' 2]) + d * l(k[3' 3])'  					Target = td  				})  				       .Emit(new AssignmentStatement { Value = ta' Target = a })  				       .Emit(new AssignmentStatement { Value = tb' Target = b })  				       .Emit(new AssignmentStatement { Value = tc' Target = c })  				       .Emit(new AssignmentStatement { Value = td' Target = d });  			}
Magic Number,Confuser.DynCipher.Elements,Matrix,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,EmitCore,The following statement contains a magic number: using (context.AcquireTempVar(out ta))  			using (context.AcquireTempVar(out tb))  			using (context.AcquireTempVar(out tc))  			using (context.AcquireTempVar(out td)) {  				context.Emit(new AssignmentStatement {  					Value = a * l(k[0' 0]) + b * l(k[0' 1]) + c * l(k[0' 2]) + d * l(k[0' 3])'  					Target = ta  				}).Emit(new AssignmentStatement {  					Value = a * l(k[1' 0]) + b * l(k[1' 1]) + c * l(k[1' 2]) + d * l(k[1' 3])'  					Target = tb  				}).Emit(new AssignmentStatement {  					Value = a * l(k[2' 0]) + b * l(k[2' 1]) + c * l(k[2' 2]) + d * l(k[2' 3])'  					Target = tc  				}).Emit(new AssignmentStatement {  					Value = a * l(k[3' 0]) + b * l(k[3' 1]) + c * l(k[3' 2]) + d * l(k[3' 3])'  					Target = td  				})  				       .Emit(new AssignmentStatement { Value = ta' Target = a })  				       .Emit(new AssignmentStatement { Value = tb' Target = b })  				       .Emit(new AssignmentStatement { Value = tc' Target = c })  				       .Emit(new AssignmentStatement { Value = td' Target = d });  			}
Magic Number,Confuser.DynCipher.Elements,Matrix,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,EmitCore,The following statement contains a magic number: using (context.AcquireTempVar(out ta))  			using (context.AcquireTempVar(out tb))  			using (context.AcquireTempVar(out tc))  			using (context.AcquireTempVar(out td)) {  				context.Emit(new AssignmentStatement {  					Value = a * l(k[0' 0]) + b * l(k[0' 1]) + c * l(k[0' 2]) + d * l(k[0' 3])'  					Target = ta  				}).Emit(new AssignmentStatement {  					Value = a * l(k[1' 0]) + b * l(k[1' 1]) + c * l(k[1' 2]) + d * l(k[1' 3])'  					Target = tb  				}).Emit(new AssignmentStatement {  					Value = a * l(k[2' 0]) + b * l(k[2' 1]) + c * l(k[2' 2]) + d * l(k[2' 3])'  					Target = tc  				}).Emit(new AssignmentStatement {  					Value = a * l(k[3' 0]) + b * l(k[3' 1]) + c * l(k[3' 2]) + d * l(k[3' 3])'  					Target = td  				})  				       .Emit(new AssignmentStatement { Value = ta' Target = a })  				       .Emit(new AssignmentStatement { Value = tb' Target = b })  				       .Emit(new AssignmentStatement { Value = tc' Target = c })  				       .Emit(new AssignmentStatement { Value = td' Target = d });  			}
Magic Number,Confuser.DynCipher.Elements,NumOp,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\NumOp.cs,Initialize,The following statement contains a magic number: Operation = (CryptoNumOps)(random.NextInt32(4));
Magic Number,Confuser.DynCipher.Elements,RotateBit,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\RotateBit.cs,Initialize,The following statement contains a magic number: Bits = random.NextInt32(1' 32);
Magic Number,Confuser.DynCipher.Elements,RotateBit,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\RotateBit.cs,Initialize,The following statement contains a magic number: IsAlternate = (random.NextInt32() % 2 == 0);
Magic Number,Confuser.DynCipher.Elements,RotateBit,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\RotateBit.cs,Emit,The following statement contains a magic number: using (context.AcquireTempVar(out tmp)) {  				if (IsAlternate)  					context.Emit(new AssignmentStatement {  						Value = (val >> (32 - Bits))'  						Target = tmp  					}).Emit(new AssignmentStatement {  						Value = (val << Bits) | tmp'  						Target = val  					});  				else  					context.Emit(new AssignmentStatement {  						Value = (val << (32 - Bits))'  						Target = tmp  					}).Emit(new AssignmentStatement {  						Value = (val >> Bits) | tmp'  						Target = val  					});  			}
Magic Number,Confuser.DynCipher.Elements,RotateBit,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\RotateBit.cs,Emit,The following statement contains a magic number: using (context.AcquireTempVar(out tmp)) {  				if (IsAlternate)  					context.Emit(new AssignmentStatement {  						Value = (val >> (32 - Bits))'  						Target = tmp  					}).Emit(new AssignmentStatement {  						Value = (val << Bits) | tmp'  						Target = val  					});  				else  					context.Emit(new AssignmentStatement {  						Value = (val << (32 - Bits))'  						Target = tmp  					}).Emit(new AssignmentStatement {  						Value = (val >> Bits) | tmp'  						Target = val  					});  			}
Magic Number,Confuser.DynCipher.Elements,RotateBit,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\RotateBit.cs,EmitInverse,The following statement contains a magic number: using (context.AcquireTempVar(out tmp)) {  				if (IsAlternate)  					context.Emit(new AssignmentStatement {  						Value = (val << (32 - Bits))'  						Target = tmp  					}).Emit(new AssignmentStatement {  						Value = (val >> Bits) | tmp'  						Target = val  					});  				else  					context.Emit(new AssignmentStatement {  						Value = (val >> (32 - Bits))'  						Target = tmp  					}).Emit(new AssignmentStatement {  						Value = (val << Bits) | tmp'  						Target = val  					});  			}
Magic Number,Confuser.DynCipher.Elements,RotateBit,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\RotateBit.cs,EmitInverse,The following statement contains a magic number: using (context.AcquireTempVar(out tmp)) {  				if (IsAlternate)  					context.Emit(new AssignmentStatement {  						Value = (val << (32 - Bits))'  						Target = tmp  					}).Emit(new AssignmentStatement {  						Value = (val >> Bits) | tmp'  						Target = val  					});  				else  					context.Emit(new AssignmentStatement {  						Value = (val >> (32 - Bits))'  						Target = tmp  					}).Emit(new AssignmentStatement {  						Value = (val << Bits) | tmp'  						Target = val  					});  			}
Magic Number,Confuser.DynCipher.Elements,Swap,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Swap.cs,Initialize,The following statement contains a magic number: if (random.NextInt32(3) == 0)  				Mask = 0xffffffff;  			else  				Mask = random.NextUInt32();
Magic Number,Confuser.DynCipher.Generation,CipherGenerator,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\CipherGenerator.cs,GeneratePair,The following statement contains a magic number: double varPrecentage = 1 + ((random.NextDouble() * 2) - 1) * VARIANCE;
Magic Number,Confuser.DynCipher.Generation,CipherGenerator,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\CipherGenerator.cs,GeneratePair,The following statement contains a magic number: for (int i = 0; i < 16; i++)  				elems.Add(new AddKey(i));
Magic Number,Confuser.DynCipher.Generation,CipherGenerator,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\CipherGenerator.cs,GeneratePair,The following statement contains a magic number: int[] x = Enumerable.Range(0' 16).ToArray();
Magic Number,Confuser.DynCipher.Generation,CipherGenerator,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\CipherGenerator.cs,GeneratePair,The following statement contains a magic number: int index = 16;
Magic Number,Confuser.DynCipher.Generation,CipherGenerator,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\CipherGenerator.cs,GeneratePair,The following statement contains a magic number: foreach (CryptoElement elem in elems) {  				elem.Initialize(random);  				for (int i = 0; i < elem.DataCount; i++) {  					if (index == 16) {  						overdue = true; // Can't shuffle now to prevent duplication  						index = 0;  					}  					elem.DataIndexes[i] = x[index++];  				}  				if (overdue) {  					Shuffle(random' x);  					index = 0;  					overdue = false;  				}  			}
Magic Number,Confuser.DynCipher.Generation,CipherGenerator,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\CipherGenerator.cs,GeneratePair,The following statement contains a magic number: var encryptContext = new CipherGenContext(random' 16);
Magic Number,Confuser.DynCipher.Generation,CipherGenerator,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\CipherGenerator.cs,GeneratePair,The following statement contains a magic number: var decryptContext = new CipherGenContext(random' 16);
Magic Number,Confuser.DynCipher.Generation,ExpressionGenerator,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\ExpressionGenerator.cs,GenerateExpression,The following statement contains a magic number: if (currentDepth == targetDepth || (currentDepth > targetDepth / 3 && random.NextInt32(100) > 85))  				return current;
Magic Number,Confuser.DynCipher.Generation,ExpressionGenerator,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\ExpressionGenerator.cs,GenerateExpression,The following statement contains a magic number: if (currentDepth == targetDepth || (currentDepth > targetDepth / 3 && random.NextInt32(100) > 85))  				return current;
Magic Number,Confuser.DynCipher.Generation,ExpressionGenerator,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\ExpressionGenerator.cs,GenerateExpression,The following statement contains a magic number: if (currentDepth == targetDepth || (currentDepth > targetDepth / 3 && random.NextInt32(100) > 85))  				return current;
Magic Number,Confuser.DynCipher.Generation,ExpressionGenerator,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\ExpressionGenerator.cs,GenerateExpression,The following statement contains a magic number: switch ((ExpressionOps)random.NextInt32(6)) {  				case ExpressionOps.Add:  					return GenerateExpression(random' current' currentDepth + 1' targetDepth) +  					       GenerateExpression(random' (LiteralExpression)random.NextUInt32()' currentDepth + 1' targetDepth);    				case ExpressionOps.Sub:  					return GenerateExpression(random' current' currentDepth + 1' targetDepth) -  					       GenerateExpression(random' (LiteralExpression)random.NextUInt32()' currentDepth + 1' targetDepth);    				case ExpressionOps.Mul:  					return GenerateExpression(random' current' currentDepth + 1' targetDepth) * (LiteralExpression)(random.NextUInt32() | 1);    				case ExpressionOps.Xor:  					return GenerateExpression(random' current' currentDepth + 1' targetDepth) ^  					       GenerateExpression(random' (LiteralExpression)random.NextUInt32()' currentDepth + 1' targetDepth);    				case ExpressionOps.Not:  					return ~GenerateExpression(random' current' currentDepth + 1' targetDepth);    				case ExpressionOps.Neg:  					return -GenerateExpression(random' current' currentDepth + 1' targetDepth);  			}
Magic Number,Confuser.DynCipher.Generation,x86CodeGen,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\x86CodeGen.cs,GenerateX86,The following statement contains a magic number: usedRegs = new bool[8];
Magic Number,Confuser.DynCipher.Generation,x86CodeGen,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\x86CodeGen.cs,GetFreeRegister,The following statement contains a magic number: for (int i = 0; i < 8; i++)  				if (!usedRegs[i])  					return (x86Register)i;
Magic Number,Confuser.DynCipher.Generation,x86CodeGen,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\x86CodeGen.cs,Normalize,The following statement contains a magic number: if (instr.Operands.Length == 2 &&  			    instr.Operands[0] is x86ImmediateOperand &&  			    instr.Operands[1] is x86ImmediateOperand) {  				/*                   * op imm1' imm2                   * ==>                   * mov reg' imm1                   * op reg' imm2                   */  				x86Register reg = GetFreeRegister();  				instrs.Add(x86Instruction.Create(x86OpCode.MOV' new x86RegisterOperand(reg)' instr.Operands[0]));  				instr.Operands[0] = new x86RegisterOperand(reg);  				instrs.Add(instr);    				return reg;  			}
Magic Number,Confuser.DynCipher.Generation,x86CodeGen,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\x86CodeGen.cs,Normalize,The following statement contains a magic number: if (instr.Operands.Length == 2 &&  			    instr.Operands[0] is x86ImmediateOperand &&  			    instr.Operands[1] is x86RegisterOperand) {  				/*                   * op imm' reg                   * ==>                   * op reg' imm                   */    				x86Register reg = ((x86RegisterOperand)instr.Operands[1]).Register;  				instr.Operands[1] = instr.Operands[0];  				instr.Operands[0] = new x86RegisterOperand(reg);  				instrs.Add(instr);    				return reg;  			}
Magic Number,Confuser.DynCipher.Generation,x86CodeGen,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\x86CodeGen.cs,Normalize,The following statement contains a magic number: if (instr.Operands.Length == 2 && instr.Operands[1] is x86RegisterOperand)  				ReleaseRegister(((x86RegisterOperand)instr.Operands[1]).Register);
Magic Number,Confuser.DynCipher.Generation,x86Instruction,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\x86CodeGen.cs,Assemble,The following statement contains a magic number: switch (OpCode) {  				case x86OpCode.MOV: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x89;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[5];  						ret[0] = 0xb8;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 1' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.ADD: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x01;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.SUB: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x29;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xe8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NEG: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NOT: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.XOR: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x31;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xf0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.POP: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[1];  						ret[0] = 0x58;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.IMUL: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[3];  						ret[0] = 0x0f;  						ret[1] = 0xaf;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x69;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				default:  					throw new NotSupportedException();  			}
Magic Number,Confuser.DynCipher.Generation,x86Instruction,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\x86CodeGen.cs,Assemble,The following statement contains a magic number: switch (OpCode) {  				case x86OpCode.MOV: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x89;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[5];  						ret[0] = 0xb8;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 1' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.ADD: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x01;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.SUB: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x29;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xe8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NEG: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NOT: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.XOR: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x31;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xf0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.POP: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[1];  						ret[0] = 0x58;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.IMUL: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[3];  						ret[0] = 0x0f;  						ret[1] = 0xaf;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x69;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				default:  					throw new NotSupportedException();  			}
Magic Number,Confuser.DynCipher.Generation,x86Instruction,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\x86CodeGen.cs,Assemble,The following statement contains a magic number: switch (OpCode) {  				case x86OpCode.MOV: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x89;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[5];  						ret[0] = 0xb8;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 1' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.ADD: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x01;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.SUB: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x29;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xe8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NEG: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NOT: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.XOR: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x31;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xf0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.POP: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[1];  						ret[0] = 0x58;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.IMUL: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[3];  						ret[0] = 0x0f;  						ret[1] = 0xaf;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x69;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				default:  					throw new NotSupportedException();  			}
Magic Number,Confuser.DynCipher.Generation,x86Instruction,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\x86CodeGen.cs,Assemble,The following statement contains a magic number: switch (OpCode) {  				case x86OpCode.MOV: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x89;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[5];  						ret[0] = 0xb8;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 1' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.ADD: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x01;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.SUB: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x29;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xe8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NEG: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NOT: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.XOR: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x31;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xf0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.POP: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[1];  						ret[0] = 0x58;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.IMUL: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[3];  						ret[0] = 0x0f;  						ret[1] = 0xaf;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x69;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				default:  					throw new NotSupportedException();  			}
Magic Number,Confuser.DynCipher.Generation,x86Instruction,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\x86CodeGen.cs,Assemble,The following statement contains a magic number: switch (OpCode) {  				case x86OpCode.MOV: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x89;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[5];  						ret[0] = 0xb8;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 1' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.ADD: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x01;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.SUB: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x29;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xe8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NEG: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NOT: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.XOR: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x31;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xf0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.POP: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[1];  						ret[0] = 0x58;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.IMUL: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[3];  						ret[0] = 0x0f;  						ret[1] = 0xaf;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x69;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				default:  					throw new NotSupportedException();  			}
Magic Number,Confuser.DynCipher.Generation,x86Instruction,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\x86CodeGen.cs,Assemble,The following statement contains a magic number: switch (OpCode) {  				case x86OpCode.MOV: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x89;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[5];  						ret[0] = 0xb8;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 1' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.ADD: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x01;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.SUB: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x29;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xe8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NEG: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NOT: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.XOR: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x31;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xf0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.POP: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[1];  						ret[0] = 0x58;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.IMUL: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[3];  						ret[0] = 0x0f;  						ret[1] = 0xaf;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x69;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				default:  					throw new NotSupportedException();  			}
Magic Number,Confuser.DynCipher.Generation,x86Instruction,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\x86CodeGen.cs,Assemble,The following statement contains a magic number: switch (OpCode) {  				case x86OpCode.MOV: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x89;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[5];  						ret[0] = 0xb8;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 1' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.ADD: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x01;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.SUB: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x29;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xe8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NEG: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NOT: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.XOR: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x31;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xf0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.POP: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[1];  						ret[0] = 0x58;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.IMUL: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[3];  						ret[0] = 0x0f;  						ret[1] = 0xaf;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x69;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				default:  					throw new NotSupportedException();  			}
Magic Number,Confuser.DynCipher.Generation,x86Instruction,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\x86CodeGen.cs,Assemble,The following statement contains a magic number: switch (OpCode) {  				case x86OpCode.MOV: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x89;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[5];  						ret[0] = 0xb8;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 1' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.ADD: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x01;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.SUB: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x29;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xe8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NEG: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NOT: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.XOR: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x31;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xf0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.POP: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[1];  						ret[0] = 0x58;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.IMUL: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[3];  						ret[0] = 0x0f;  						ret[1] = 0xaf;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x69;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				default:  					throw new NotSupportedException();  			}
Magic Number,Confuser.DynCipher.Generation,x86Instruction,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\x86CodeGen.cs,Assemble,The following statement contains a magic number: switch (OpCode) {  				case x86OpCode.MOV: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x89;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[5];  						ret[0] = 0xb8;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 1' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.ADD: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x01;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.SUB: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x29;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xe8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NEG: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NOT: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.XOR: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x31;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xf0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.POP: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[1];  						ret[0] = 0x58;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.IMUL: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[3];  						ret[0] = 0x0f;  						ret[1] = 0xaf;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x69;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				default:  					throw new NotSupportedException();  			}
Magic Number,Confuser.DynCipher.Generation,x86Instruction,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\x86CodeGen.cs,Assemble,The following statement contains a magic number: switch (OpCode) {  				case x86OpCode.MOV: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x89;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[5];  						ret[0] = 0xb8;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 1' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.ADD: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x01;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.SUB: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x29;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xe8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NEG: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NOT: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.XOR: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x31;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xf0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.POP: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[1];  						ret[0] = 0x58;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.IMUL: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[3];  						ret[0] = 0x0f;  						ret[1] = 0xaf;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x69;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				default:  					throw new NotSupportedException();  			}
Magic Number,Confuser.DynCipher.Generation,x86Instruction,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\x86CodeGen.cs,Assemble,The following statement contains a magic number: switch (OpCode) {  				case x86OpCode.MOV: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x89;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[5];  						ret[0] = 0xb8;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 1' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.ADD: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x01;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.SUB: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x29;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xe8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NEG: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NOT: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.XOR: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x31;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xf0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.POP: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[1];  						ret[0] = 0x58;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.IMUL: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[3];  						ret[0] = 0x0f;  						ret[1] = 0xaf;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x69;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				default:  					throw new NotSupportedException();  			}
Magic Number,Confuser.DynCipher.Generation,x86Instruction,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\x86CodeGen.cs,Assemble,The following statement contains a magic number: switch (OpCode) {  				case x86OpCode.MOV: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x89;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[5];  						ret[0] = 0xb8;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 1' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.ADD: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x01;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.SUB: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x29;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xe8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NEG: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NOT: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.XOR: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x31;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xf0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.POP: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[1];  						ret[0] = 0x58;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.IMUL: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[3];  						ret[0] = 0x0f;  						ret[1] = 0xaf;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x69;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				default:  					throw new NotSupportedException();  			}
Magic Number,Confuser.DynCipher.Generation,x86Instruction,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\x86CodeGen.cs,Assemble,The following statement contains a magic number: switch (OpCode) {  				case x86OpCode.MOV: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x89;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[5];  						ret[0] = 0xb8;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 1' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.ADD: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x01;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.SUB: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x29;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xe8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NEG: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NOT: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.XOR: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x31;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xf0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.POP: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[1];  						ret[0] = 0x58;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.IMUL: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[3];  						ret[0] = 0x0f;  						ret[1] = 0xaf;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x69;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				default:  					throw new NotSupportedException();  			}
Magic Number,Confuser.DynCipher.Generation,x86Instruction,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\x86CodeGen.cs,Assemble,The following statement contains a magic number: switch (OpCode) {  				case x86OpCode.MOV: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x89;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[5];  						ret[0] = 0xb8;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 1' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.ADD: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x01;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.SUB: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x29;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xe8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NEG: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NOT: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.XOR: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x31;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xf0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.POP: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[1];  						ret[0] = 0x58;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.IMUL: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[3];  						ret[0] = 0x0f;  						ret[1] = 0xaf;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x69;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				default:  					throw new NotSupportedException();  			}
Magic Number,Confuser.DynCipher.Generation,x86Instruction,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\x86CodeGen.cs,Assemble,The following statement contains a magic number: switch (OpCode) {  				case x86OpCode.MOV: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x89;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[5];  						ret[0] = 0xb8;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 1' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.ADD: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x01;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.SUB: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x29;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xe8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NEG: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NOT: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.XOR: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x31;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xf0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.POP: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[1];  						ret[0] = 0x58;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.IMUL: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[3];  						ret[0] = 0x0f;  						ret[1] = 0xaf;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x69;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				default:  					throw new NotSupportedException();  			}
Magic Number,Confuser.DynCipher.Generation,x86Instruction,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\x86CodeGen.cs,Assemble,The following statement contains a magic number: switch (OpCode) {  				case x86OpCode.MOV: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x89;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[5];  						ret[0] = 0xb8;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 1' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.ADD: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x01;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.SUB: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x29;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xe8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NEG: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NOT: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.XOR: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x31;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xf0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.POP: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[1];  						ret[0] = 0x58;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.IMUL: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[3];  						ret[0] = 0x0f;  						ret[1] = 0xaf;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x69;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				default:  					throw new NotSupportedException();  			}
Magic Number,Confuser.DynCipher.Generation,x86Instruction,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\x86CodeGen.cs,Assemble,The following statement contains a magic number: switch (OpCode) {  				case x86OpCode.MOV: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x89;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[5];  						ret[0] = 0xb8;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 1' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.ADD: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x01;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.SUB: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x29;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xe8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NEG: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NOT: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.XOR: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x31;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xf0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.POP: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[1];  						ret[0] = 0x58;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.IMUL: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[3];  						ret[0] = 0x0f;  						ret[1] = 0xaf;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x69;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				default:  					throw new NotSupportedException();  			}
Magic Number,Confuser.DynCipher.Generation,x86Instruction,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\x86CodeGen.cs,Assemble,The following statement contains a magic number: switch (OpCode) {  				case x86OpCode.MOV: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x89;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[5];  						ret[0] = 0xb8;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 1' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.ADD: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x01;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.SUB: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x29;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xe8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NEG: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NOT: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.XOR: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x31;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xf0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.POP: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[1];  						ret[0] = 0x58;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.IMUL: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[3];  						ret[0] = 0x0f;  						ret[1] = 0xaf;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x69;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				default:  					throw new NotSupportedException();  			}
Magic Number,Confuser.DynCipher.Generation,x86Instruction,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\x86CodeGen.cs,Assemble,The following statement contains a magic number: switch (OpCode) {  				case x86OpCode.MOV: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x89;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[5];  						ret[0] = 0xb8;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 1' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.ADD: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x01;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.SUB: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x29;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xe8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NEG: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NOT: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.XOR: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x31;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xf0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.POP: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[1];  						ret[0] = 0x58;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.IMUL: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[3];  						ret[0] = 0x0f;  						ret[1] = 0xaf;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x69;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				default:  					throw new NotSupportedException();  			}
Magic Number,Confuser.DynCipher.Generation,x86Instruction,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\x86CodeGen.cs,Assemble,The following statement contains a magic number: switch (OpCode) {  				case x86OpCode.MOV: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x89;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[5];  						ret[0] = 0xb8;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 1' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.ADD: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x01;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.SUB: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x29;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xe8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NEG: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NOT: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.XOR: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x31;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xf0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.POP: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[1];  						ret[0] = 0x58;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.IMUL: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[3];  						ret[0] = 0x0f;  						ret[1] = 0xaf;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x69;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				default:  					throw new NotSupportedException();  			}
Magic Number,Confuser.DynCipher.Generation,x86Instruction,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\x86CodeGen.cs,Assemble,The following statement contains a magic number: switch (OpCode) {  				case x86OpCode.MOV: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x89;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[5];  						ret[0] = 0xb8;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 1' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.ADD: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x01;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.SUB: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x29;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xe8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NEG: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NOT: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.XOR: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x31;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xf0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.POP: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[1];  						ret[0] = 0x58;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.IMUL: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[3];  						ret[0] = 0x0f;  						ret[1] = 0xaf;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x69;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				default:  					throw new NotSupportedException();  			}
Magic Number,Confuser.DynCipher.Generation,x86Instruction,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\x86CodeGen.cs,Assemble,The following statement contains a magic number: switch (OpCode) {  				case x86OpCode.MOV: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x89;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[5];  						ret[0] = 0xb8;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 1' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.ADD: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x01;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.SUB: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x29;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xe8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NEG: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NOT: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.XOR: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x31;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xf0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.POP: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[1];  						ret[0] = 0x58;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.IMUL: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[3];  						ret[0] = 0x0f;  						ret[1] = 0xaf;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x69;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				default:  					throw new NotSupportedException();  			}
Magic Number,Confuser.DynCipher.Generation,x86Instruction,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\x86CodeGen.cs,Assemble,The following statement contains a magic number: switch (OpCode) {  				case x86OpCode.MOV: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x89;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[5];  						ret[0] = 0xb8;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 1' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.ADD: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x01;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.SUB: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x29;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xe8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NEG: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NOT: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.XOR: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x31;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xf0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.POP: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[1];  						ret[0] = 0x58;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.IMUL: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[3];  						ret[0] = 0x0f;  						ret[1] = 0xaf;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x69;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				default:  					throw new NotSupportedException();  			}
Magic Number,Confuser.DynCipher.Generation,x86Instruction,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\x86CodeGen.cs,Assemble,The following statement contains a magic number: switch (OpCode) {  				case x86OpCode.MOV: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x89;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[5];  						ret[0] = 0xb8;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 1' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.ADD: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x01;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.SUB: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x29;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xe8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NEG: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NOT: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.XOR: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x31;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xf0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.POP: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[1];  						ret[0] = 0x58;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.IMUL: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[3];  						ret[0] = 0x0f;  						ret[1] = 0xaf;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x69;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				default:  					throw new NotSupportedException();  			}
Magic Number,Confuser.DynCipher.Generation,x86Instruction,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\x86CodeGen.cs,Assemble,The following statement contains a magic number: switch (OpCode) {  				case x86OpCode.MOV: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x89;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[5];  						ret[0] = 0xb8;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 1' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.ADD: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x01;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.SUB: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x29;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xe8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NEG: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NOT: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.XOR: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x31;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xf0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.POP: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[1];  						ret[0] = 0x58;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.IMUL: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[3];  						ret[0] = 0x0f;  						ret[1] = 0xaf;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x69;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				default:  					throw new NotSupportedException();  			}
Magic Number,Confuser.DynCipher.Generation,x86Instruction,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\x86CodeGen.cs,Assemble,The following statement contains a magic number: switch (OpCode) {  				case x86OpCode.MOV: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x89;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[5];  						ret[0] = 0xb8;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 1' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.ADD: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x01;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.SUB: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x29;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xe8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NEG: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NOT: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.XOR: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x31;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xf0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.POP: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[1];  						ret[0] = 0x58;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.IMUL: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[3];  						ret[0] = 0x0f;  						ret[1] = 0xaf;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x69;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				default:  					throw new NotSupportedException();  			}
Magic Number,Confuser.DynCipher.Generation,x86Instruction,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\x86CodeGen.cs,Assemble,The following statement contains a magic number: switch (OpCode) {  				case x86OpCode.MOV: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x89;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[5];  						ret[0] = 0xb8;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 1' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.ADD: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x01;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.SUB: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x29;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xe8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NEG: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NOT: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.XOR: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x31;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xf0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.POP: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[1];  						ret[0] = 0x58;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.IMUL: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[3];  						ret[0] = 0x0f;  						ret[1] = 0xaf;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x69;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				default:  					throw new NotSupportedException();  			}
Magic Number,Confuser.DynCipher.Generation,x86Instruction,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\x86CodeGen.cs,Assemble,The following statement contains a magic number: switch (OpCode) {  				case x86OpCode.MOV: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x89;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[5];  						ret[0] = 0xb8;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 1' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.ADD: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x01;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.SUB: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x29;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xe8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NEG: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NOT: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.XOR: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x31;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xf0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.POP: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[1];  						ret[0] = 0x58;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.IMUL: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[3];  						ret[0] = 0x0f;  						ret[1] = 0xaf;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x69;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				default:  					throw new NotSupportedException();  			}
Magic Number,Confuser.DynCipher.Generation,x86Instruction,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\x86CodeGen.cs,Assemble,The following statement contains a magic number: switch (OpCode) {  				case x86OpCode.MOV: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x89;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[5];  						ret[0] = 0xb8;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 1' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.ADD: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x01;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.SUB: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x29;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xe8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NEG: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NOT: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.XOR: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x31;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xf0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.POP: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[1];  						ret[0] = 0x58;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.IMUL: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[3];  						ret[0] = 0x0f;  						ret[1] = 0xaf;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x69;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				default:  					throw new NotSupportedException();  			}
Magic Number,Confuser.DynCipher.Generation,x86Instruction,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\x86CodeGen.cs,Assemble,The following statement contains a magic number: switch (OpCode) {  				case x86OpCode.MOV: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x89;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[5];  						ret[0] = 0xb8;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 1' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.ADD: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x01;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.SUB: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x29;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xe8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NEG: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NOT: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.XOR: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x31;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xf0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.POP: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[1];  						ret[0] = 0x58;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.IMUL: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[3];  						ret[0] = 0x0f;  						ret[1] = 0xaf;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x69;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				default:  					throw new NotSupportedException();  			}
Magic Number,Confuser.DynCipher.Generation,x86Instruction,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\x86CodeGen.cs,Assemble,The following statement contains a magic number: switch (OpCode) {  				case x86OpCode.MOV: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x89;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[5];  						ret[0] = 0xb8;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 1' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.ADD: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x01;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.SUB: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x29;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xe8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NEG: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NOT: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.XOR: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x31;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xf0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.POP: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[1];  						ret[0] = 0x58;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.IMUL: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[3];  						ret[0] = 0x0f;  						ret[1] = 0xaf;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x69;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				default:  					throw new NotSupportedException();  			}
Magic Number,Confuser.DynCipher.Generation,x86Instruction,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\x86CodeGen.cs,Assemble,The following statement contains a magic number: switch (OpCode) {  				case x86OpCode.MOV: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x89;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[5];  						ret[0] = 0xb8;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 1' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.ADD: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x01;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.SUB: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x29;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xe8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NEG: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NOT: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.XOR: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x31;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xf0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.POP: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[1];  						ret[0] = 0x58;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.IMUL: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[3];  						ret[0] = 0x0f;  						ret[1] = 0xaf;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x69;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				default:  					throw new NotSupportedException();  			}
Magic Number,Confuser.DynCipher.Transforms,MulToShiftTransform,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Transforms\MulToShiftTransform.cs,NumberOfSetBits,The following statement contains a magic number: i = (i & 0x33333333) + ((i >> 2) & 0x33333333);
Magic Number,Confuser.DynCipher.Transforms,MulToShiftTransform,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Transforms\MulToShiftTransform.cs,NumberOfSetBits,The following statement contains a magic number: return (((i + (i >> 4)) & 0x0F0F0F0F) * 0x01010101) >> 24;
Magic Number,Confuser.DynCipher.Transforms,MulToShiftTransform,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Transforms\MulToShiftTransform.cs,NumberOfSetBits,The following statement contains a magic number: return (((i + (i >> 4)) & 0x0F0F0F0F) * 0x01010101) >> 24;
Magic Number,Confuser.DynCipher.Transforms,MulToShiftTransform,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Transforms\MulToShiftTransform.cs,ProcessExpression,The following statement contains a magic number: if (exp is BinOpExpression) {  				var binOp = (BinOpExpression)exp;  				if (binOp.Operation == BinOps.Mul && binOp.Right is LiteralExpression) {  					// Decompose multiplication into shifts' e.g. x * 3 => x << 1 + x  					uint literal = ((LiteralExpression)binOp.Right).Value;  					if (literal == 0) return (LiteralExpression)0;  					if (literal == 1) return binOp.Left;    					uint bits = NumberOfSetBits(literal);  					if (bits <= 2) {  						var sum = new List<Expression>();  						int n = 0;  						while (literal != 0) {  							if ((literal & 1) != 0) {  								if (n == 0)  									sum.Add(binOp.Left);  								else  									sum.Add(binOp.Left << n);  							}  							literal >>= 1;  							n++;  						}  						BinOpExpression x = sum.OfType<BinOpExpression>().First();  						foreach (Expression i in sum.Except(new[] { x }))  							x += i;  						return x;  					}  				}  				else {  					binOp.Left = ProcessExpression(binOp.Left);  					binOp.Right = ProcessExpression(binOp.Right);  				}  			}  			else if (exp is ArrayIndexExpression) {  				((ArrayIndexExpression)exp).Array = ProcessExpression(((ArrayIndexExpression)exp).Array);  			}  			else if (exp is UnaryOpExpression) {  				((UnaryOpExpression)exp).Value = ProcessExpression(((UnaryOpExpression)exp).Value);  			}
Missing Default,Confuser.DynCipher.Elements,BinOp,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\BinOp.cs,Emit,The following switch statement is missing a default case: switch (Operation) {  				case CryptoBinOps.Add:  					context.Emit(new AssignmentStatement {  						Value = a + b'  						Target = a  					});  					break;  				case CryptoBinOps.Xor:  					context.Emit(new AssignmentStatement {  						Value = a ^ b'  						Target = a  					});  					break;  				case CryptoBinOps.Xnor:  					context.Emit(new AssignmentStatement {  						Value = ~(a ^ b)'  						Target = a  					});  					break;  			}
Missing Default,Confuser.DynCipher.Elements,BinOp,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\BinOp.cs,EmitInverse,The following switch statement is missing a default case: switch (Operation) {  				case CryptoBinOps.Add:  					context.Emit(new AssignmentStatement {  						Value = a - b'  						Target = a  					});  					break;  				case CryptoBinOps.Xor:  					context.Emit(new AssignmentStatement {  						Value = a ^ b'  						Target = a  					});  					break;  				case CryptoBinOps.Xnor:  					context.Emit(new AssignmentStatement {  						Value = a ^ (~b)'  						Target = a  					});  					break;  			}
Missing Default,Confuser.DynCipher.Elements,NumOp,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\NumOp.cs,Initialize,The following switch statement is missing a default case: switch (Operation) {  				case CryptoNumOps.Add:  				case CryptoNumOps.Xor:  					Key = InverseKey = random.NextUInt32();  					break;  				case CryptoNumOps.Mul:  					Key = random.NextUInt32() | 1;  					InverseKey = MathsUtils.modInv(Key);  					break;  				case CryptoNumOps.Xnor:  					Key = random.NextUInt32();  					InverseKey = ~Key;  					break;  			}
Missing Default,Confuser.DynCipher.Elements,NumOp,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\NumOp.cs,Emit,The following switch statement is missing a default case: switch (Operation) {  				case CryptoNumOps.Add:  					context.Emit(new AssignmentStatement {  						Value = val + (LiteralExpression)Key'  						Target = val  					});  					break;  				case CryptoNumOps.Xor:  					context.Emit(new AssignmentStatement {  						Value = val ^ (LiteralExpression)Key'  						Target = val  					});  					break;  				case CryptoNumOps.Mul:  					context.Emit(new AssignmentStatement {  						Value = val * (LiteralExpression)Key'  						Target = val  					});  					break;  				case CryptoNumOps.Xnor:  					context.Emit(new AssignmentStatement {  						Value = ~(val ^ (LiteralExpression)Key)'  						Target = val  					});  					break;  			}
Missing Default,Confuser.DynCipher.Elements,NumOp,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\NumOp.cs,EmitInverse,The following switch statement is missing a default case: switch (Operation) {  				case CryptoNumOps.Add:  					context.Emit(new AssignmentStatement {  						Value = val - (LiteralExpression)InverseKey'  						Target = val  					});  					break;  				case CryptoNumOps.Xor:  					context.Emit(new AssignmentStatement {  						Value = val ^ (LiteralExpression)InverseKey'  						Target = val  					});  					break;  				case CryptoNumOps.Mul:  					context.Emit(new AssignmentStatement {  						Value = val * (LiteralExpression)InverseKey'  						Target = val  					});  					break;  				case CryptoNumOps.Xnor:  					context.Emit(new AssignmentStatement {  						Value = val ^ (LiteralExpression)InverseKey'  						Target = val  					});  					break;  			}
Missing Default,Confuser.DynCipher.Generation,ExpressionGenerator,C:\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\ExpressionGenerator.cs,GenerateExpression,The following switch statement is missing a default case: switch ((ExpressionOps)random.NextInt32(6)) {  				case ExpressionOps.Add:  					return GenerateExpression(random' current' currentDepth + 1' targetDepth) +  					       GenerateExpression(random' (LiteralExpression)random.NextUInt32()' currentDepth + 1' targetDepth);    				case ExpressionOps.Sub:  					return GenerateExpression(random' current' currentDepth + 1' targetDepth) -  					       GenerateExpression(random' (LiteralExpression)random.NextUInt32()' currentDepth + 1' targetDepth);    				case ExpressionOps.Mul:  					return GenerateExpression(random' current' currentDepth + 1' targetDepth) * (LiteralExpression)(random.NextUInt32() | 1);    				case ExpressionOps.Xor:  					return GenerateExpression(random' current' currentDepth + 1' targetDepth) ^  					       GenerateExpression(random' (LiteralExpression)random.NextUInt32()' currentDepth + 1' targetDepth);    				case ExpressionOps.Not:  					return ~GenerateExpression(random' current' currentDepth + 1' targetDepth);    				case ExpressionOps.Neg:  					return -GenerateExpression(random' current' currentDepth + 1' targetDepth);  			}
