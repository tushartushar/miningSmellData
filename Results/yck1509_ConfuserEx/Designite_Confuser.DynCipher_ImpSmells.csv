Implementation smell,Namespace,Class,File,Method,Description
Long Method,Confuser.DynCipher.Generation,x86Instruction,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\x86CodeGen.cs,Assemble,The method has 149 lines of code.
Complex Method,Confuser.DynCipher.AST,BinOpExpression,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\AST\BinOpExpression.cs,ToString,Cyclomatic complexity of the method is 10
Complex Method,Confuser.DynCipher.Generation,CipherGenerator,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\CipherGenerator.cs,GeneratePair,Cyclomatic complexity of the method is 13
Complex Method,Confuser.DynCipher.Generation,CILCodeGen,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\CILCodeGen.cs,EmitLoad,Cyclomatic complexity of the method is 17
Complex Method,Confuser.DynCipher.Generation,DMCodeGen,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\DMCodeGen.cs,EmitLoad,Cyclomatic complexity of the method is 17
Complex Method,Confuser.DynCipher.Generation,ExpressionGenerator,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\ExpressionGenerator.cs,GenerateInverse,Cyclomatic complexity of the method is 9
Complex Method,Confuser.DynCipher.Generation,x86CodeGen,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\x86CodeGen.cs,Emit,Cyclomatic complexity of the method is 11
Complex Method,Confuser.DynCipher.Generation,x86Instruction,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\x86CodeGen.cs,Assemble,Cyclomatic complexity of the method is 30
Complex Method,Confuser.DynCipher.Transforms,MulToShiftTransform,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Transforms\MulToShiftTransform.cs,ProcessExpression,Cyclomatic complexity of the method is 12
Complex Method,Confuser.DynCipher.Transforms,ShuffleTransform,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Transforms\ShuffleTransform.cs,GetVariableUsage,Cyclomatic complexity of the method is 8
Long Parameter List,Confuser.DynCipher,IDynCipherService,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\DynCipherService.cs,GenerateExpressionPair,The method has 6 parameters. Parameters: random' var' result' depth' expression' inverse
Long Parameter List,Confuser.DynCipher,DynCipherService,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\DynCipherService.cs,GenerateExpressionPair,The method has 6 parameters. Parameters: random' var' result' depth' expression' inverse
Long Parameter List,Confuser.DynCipher.Generation,ExpressionGenerator,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\ExpressionGenerator.cs,GeneratePair,The method has 6 parameters. Parameters: random' var' result' depth' expression' inverse
Long Statement,Confuser.DynCipher,CodeGenUtils,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Utils.cs,AssembleCode,The length of the statement  "					writer.Write(x86Instruction.Create(x86OpCode.MOV' new x86RegisterOperand(x86Register.EAX)' new x86RegisterOperand(reg)).Assemble()); " is 132.
Long Statement,Confuser.DynCipher.Generation,ExpressionGenerator,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\ExpressionGenerator.cs,GenerateExpression,The length of the statement  "					return GenerateExpression(random' current' currentDepth + 1' targetDepth) * (LiteralExpression)(random.NextUInt32() | 1); " is 121.
Complex Conditional,Confuser.DynCipher.Transforms,NormalizeBinOpTransform,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Transforms\NormalizeBinOpTransform.cs,ProcessExpression,The conditional expression  "binOpRight != null && binOpRight.Operation == binOp.Operation &&  				    (binOp.Operation == BinOps.Add || binOp.Operation == BinOps.Mul ||  				     binOp.Operation == BinOps.Or || binOp.Operation == BinOps.And ||  				     binOp.Operation == BinOps.Xor)"  is complex.
Magic Number,Confuser.DynCipher.Elements,BinOp,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\BinOp.cs,Initialize,The following statement contains a magic number: Operation = (CryptoBinOps)random.NextInt32(3);
Magic Number,Confuser.DynCipher.Elements,Matrix,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,GenerateUnimodularMatrix,The following statement contains a magic number: Func<uint> next = () => (uint)random.NextInt32(4);
Magic Number,Confuser.DynCipher.Elements,Matrix,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,cofactor4,The following statement contains a magic number: var sub = new uint[3' 3];
Magic Number,Confuser.DynCipher.Elements,Matrix,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,cofactor4,The following statement contains a magic number: var sub = new uint[3' 3];
Magic Number,Confuser.DynCipher.Elements,Matrix,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,cofactor4,The following statement contains a magic number: cj < 4
Magic Number,Confuser.DynCipher.Elements,Matrix,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,cofactor4,The following statement contains a magic number: ci < 4
Magic Number,Confuser.DynCipher.Elements,Matrix,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,cofactor4,The following statement contains a magic number: (i + j) % 2 == 0
Magic Number,Confuser.DynCipher.Elements,Matrix,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,det3,The following statement contains a magic number: return mat[0' 0] * mat[1' 1] * mat[2' 2] +  			       mat[0' 1] * mat[1' 2] * mat[2' 0] +  			       mat[0' 2] * mat[1' 0] * mat[2' 1] -  			       mat[0' 2] * mat[1' 1] * mat[2' 0] -  			       mat[0' 1] * mat[1' 0] * mat[2' 2] -  			       mat[0' 0] * mat[1' 2] * mat[2' 1];
Magic Number,Confuser.DynCipher.Elements,Matrix,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,det3,The following statement contains a magic number: return mat[0' 0] * mat[1' 1] * mat[2' 2] +  			       mat[0' 1] * mat[1' 2] * mat[2' 0] +  			       mat[0' 2] * mat[1' 0] * mat[2' 1] -  			       mat[0' 2] * mat[1' 1] * mat[2' 0] -  			       mat[0' 1] * mat[1' 0] * mat[2' 2] -  			       mat[0' 0] * mat[1' 2] * mat[2' 1];
Magic Number,Confuser.DynCipher.Elements,Matrix,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,det3,The following statement contains a magic number: return mat[0' 0] * mat[1' 1] * mat[2' 2] +  			       mat[0' 1] * mat[1' 2] * mat[2' 0] +  			       mat[0' 2] * mat[1' 0] * mat[2' 1] -  			       mat[0' 2] * mat[1' 1] * mat[2' 0] -  			       mat[0' 1] * mat[1' 0] * mat[2' 2] -  			       mat[0' 0] * mat[1' 2] * mat[2' 1];
Magic Number,Confuser.DynCipher.Elements,Matrix,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,det3,The following statement contains a magic number: return mat[0' 0] * mat[1' 1] * mat[2' 2] +  			       mat[0' 1] * mat[1' 2] * mat[2' 0] +  			       mat[0' 2] * mat[1' 0] * mat[2' 1] -  			       mat[0' 2] * mat[1' 1] * mat[2' 0] -  			       mat[0' 1] * mat[1' 0] * mat[2' 2] -  			       mat[0' 0] * mat[1' 2] * mat[2' 1];
Magic Number,Confuser.DynCipher.Elements,Matrix,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,det3,The following statement contains a magic number: return mat[0' 0] * mat[1' 1] * mat[2' 2] +  			       mat[0' 1] * mat[1' 2] * mat[2' 0] +  			       mat[0' 2] * mat[1' 0] * mat[2' 1] -  			       mat[0' 2] * mat[1' 1] * mat[2' 0] -  			       mat[0' 1] * mat[1' 0] * mat[2' 2] -  			       mat[0' 0] * mat[1' 2] * mat[2' 1];
Magic Number,Confuser.DynCipher.Elements,Matrix,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,det3,The following statement contains a magic number: return mat[0' 0] * mat[1' 1] * mat[2' 2] +  			       mat[0' 1] * mat[1' 2] * mat[2' 0] +  			       mat[0' 2] * mat[1' 0] * mat[2' 1] -  			       mat[0' 2] * mat[1' 1] * mat[2' 0] -  			       mat[0' 1] * mat[1' 0] * mat[2' 2] -  			       mat[0' 0] * mat[1' 2] * mat[2' 1];
Magic Number,Confuser.DynCipher.Elements,Matrix,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,det3,The following statement contains a magic number: return mat[0' 0] * mat[1' 1] * mat[2' 2] +  			       mat[0' 1] * mat[1' 2] * mat[2' 0] +  			       mat[0' 2] * mat[1' 0] * mat[2' 1] -  			       mat[0' 2] * mat[1' 1] * mat[2' 0] -  			       mat[0' 1] * mat[1' 0] * mat[2' 2] -  			       mat[0' 0] * mat[1' 2] * mat[2' 1];
Magic Number,Confuser.DynCipher.Elements,Matrix,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,det3,The following statement contains a magic number: return mat[0' 0] * mat[1' 1] * mat[2' 2] +  			       mat[0' 1] * mat[1' 2] * mat[2' 0] +  			       mat[0' 2] * mat[1' 0] * mat[2' 1] -  			       mat[0' 2] * mat[1' 1] * mat[2' 0] -  			       mat[0' 1] * mat[1' 0] * mat[2' 2] -  			       mat[0' 0] * mat[1' 2] * mat[2' 1];
Magic Number,Confuser.DynCipher.Elements,Matrix,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,det3,The following statement contains a magic number: return mat[0' 0] * mat[1' 1] * mat[2' 2] +  			       mat[0' 1] * mat[1' 2] * mat[2' 0] +  			       mat[0' 2] * mat[1' 0] * mat[2' 1] -  			       mat[0' 2] * mat[1' 1] * mat[2' 0] -  			       mat[0' 1] * mat[1' 0] * mat[2' 2] -  			       mat[0' 0] * mat[1' 2] * mat[2' 1];
Magic Number,Confuser.DynCipher.Elements,Matrix,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,det3,The following statement contains a magic number: return mat[0' 0] * mat[1' 1] * mat[2' 2] +  			       mat[0' 1] * mat[1' 2] * mat[2' 0] +  			       mat[0' 2] * mat[1' 0] * mat[2' 1] -  			       mat[0' 2] * mat[1' 1] * mat[2' 0] -  			       mat[0' 1] * mat[1' 0] * mat[2' 2] -  			       mat[0' 0] * mat[1' 2] * mat[2' 1];
Magic Number,Confuser.DynCipher.Elements,Matrix,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,det3,The following statement contains a magic number: return mat[0' 0] * mat[1' 1] * mat[2' 2] +  			       mat[0' 1] * mat[1' 2] * mat[2' 0] +  			       mat[0' 2] * mat[1' 0] * mat[2' 1] -  			       mat[0' 2] * mat[1' 1] * mat[2' 0] -  			       mat[0' 1] * mat[1' 0] * mat[2' 2] -  			       mat[0' 0] * mat[1' 2] * mat[2' 1];
Magic Number,Confuser.DynCipher.Elements,Matrix,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,det3,The following statement contains a magic number: return mat[0' 0] * mat[1' 1] * mat[2' 2] +  			       mat[0' 1] * mat[1' 2] * mat[2' 0] +  			       mat[0' 2] * mat[1' 0] * mat[2' 1] -  			       mat[0' 2] * mat[1' 1] * mat[2' 0] -  			       mat[0' 1] * mat[1' 0] * mat[2' 2] -  			       mat[0' 0] * mat[1' 2] * mat[2' 1];
Magic Number,Confuser.DynCipher.Elements,Matrix,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,transpose4,The following statement contains a magic number: var ret = new uint[4' 4];
Magic Number,Confuser.DynCipher.Elements,Matrix,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,transpose4,The following statement contains a magic number: var ret = new uint[4' 4];
Magic Number,Confuser.DynCipher.Elements,Matrix,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,transpose4,The following statement contains a magic number: i < 4
Magic Number,Confuser.DynCipher.Elements,Matrix,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,Initialize,The following statement contains a magic number: var cof = new uint[4' 4];
Magic Number,Confuser.DynCipher.Elements,Matrix,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,Initialize,The following statement contains a magic number: var cof = new uint[4' 4];
Magic Number,Confuser.DynCipher.Elements,Matrix,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,Initialize,The following statement contains a magic number: i < 4
Magic Number,Confuser.DynCipher.Elements,Matrix,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,EmitCore,The following statement contains a magic number: Expression c = context.GetDataExpression(DataIndexes[2]);
Magic Number,Confuser.DynCipher.Elements,Matrix,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,EmitCore,The following statement contains a magic number: Expression d = context.GetDataExpression(DataIndexes[3]);
Magic Number,Confuser.DynCipher.Elements,Matrix,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,EmitCore,The following statement contains a magic number: context.Emit(new AssignmentStatement {  					Value = a * l(k[0' 0]) + b * l(k[0' 1]) + c * l(k[0' 2]) + d * l(k[0' 3])'  					Target = ta  				}).Emit(new AssignmentStatement {  					Value = a * l(k[1' 0]) + b * l(k[1' 1]) + c * l(k[1' 2]) + d * l(k[1' 3])'  					Target = tb  				}).Emit(new AssignmentStatement {  					Value = a * l(k[2' 0]) + b * l(k[2' 1]) + c * l(k[2' 2]) + d * l(k[2' 3])'  					Target = tc  				}).Emit(new AssignmentStatement {  					Value = a * l(k[3' 0]) + b * l(k[3' 1]) + c * l(k[3' 2]) + d * l(k[3' 3])'  					Target = td  				})  				       .Emit(new AssignmentStatement { Value = ta' Target = a })  				       .Emit(new AssignmentStatement { Value = tb' Target = b })  				       .Emit(new AssignmentStatement { Value = tc' Target = c })  				       .Emit(new AssignmentStatement { Value = td' Target = d });
Magic Number,Confuser.DynCipher.Elements,Matrix,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,EmitCore,The following statement contains a magic number: context.Emit(new AssignmentStatement {  					Value = a * l(k[0' 0]) + b * l(k[0' 1]) + c * l(k[0' 2]) + d * l(k[0' 3])'  					Target = ta  				}).Emit(new AssignmentStatement {  					Value = a * l(k[1' 0]) + b * l(k[1' 1]) + c * l(k[1' 2]) + d * l(k[1' 3])'  					Target = tb  				}).Emit(new AssignmentStatement {  					Value = a * l(k[2' 0]) + b * l(k[2' 1]) + c * l(k[2' 2]) + d * l(k[2' 3])'  					Target = tc  				}).Emit(new AssignmentStatement {  					Value = a * l(k[3' 0]) + b * l(k[3' 1]) + c * l(k[3' 2]) + d * l(k[3' 3])'  					Target = td  				})  				       .Emit(new AssignmentStatement { Value = ta' Target = a })  				       .Emit(new AssignmentStatement { Value = tb' Target = b })  				       .Emit(new AssignmentStatement { Value = tc' Target = c })  				       .Emit(new AssignmentStatement { Value = td' Target = d });
Magic Number,Confuser.DynCipher.Elements,Matrix,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,EmitCore,The following statement contains a magic number: context.Emit(new AssignmentStatement {  					Value = a * l(k[0' 0]) + b * l(k[0' 1]) + c * l(k[0' 2]) + d * l(k[0' 3])'  					Target = ta  				}).Emit(new AssignmentStatement {  					Value = a * l(k[1' 0]) + b * l(k[1' 1]) + c * l(k[1' 2]) + d * l(k[1' 3])'  					Target = tb  				}).Emit(new AssignmentStatement {  					Value = a * l(k[2' 0]) + b * l(k[2' 1]) + c * l(k[2' 2]) + d * l(k[2' 3])'  					Target = tc  				}).Emit(new AssignmentStatement {  					Value = a * l(k[3' 0]) + b * l(k[3' 1]) + c * l(k[3' 2]) + d * l(k[3' 3])'  					Target = td  				})  				       .Emit(new AssignmentStatement { Value = ta' Target = a })  				       .Emit(new AssignmentStatement { Value = tb' Target = b })  				       .Emit(new AssignmentStatement { Value = tc' Target = c })  				       .Emit(new AssignmentStatement { Value = td' Target = d });
Magic Number,Confuser.DynCipher.Elements,Matrix,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,EmitCore,The following statement contains a magic number: context.Emit(new AssignmentStatement {  					Value = a * l(k[0' 0]) + b * l(k[0' 1]) + c * l(k[0' 2]) + d * l(k[0' 3])'  					Target = ta  				}).Emit(new AssignmentStatement {  					Value = a * l(k[1' 0]) + b * l(k[1' 1]) + c * l(k[1' 2]) + d * l(k[1' 3])'  					Target = tb  				}).Emit(new AssignmentStatement {  					Value = a * l(k[2' 0]) + b * l(k[2' 1]) + c * l(k[2' 2]) + d * l(k[2' 3])'  					Target = tc  				}).Emit(new AssignmentStatement {  					Value = a * l(k[3' 0]) + b * l(k[3' 1]) + c * l(k[3' 2]) + d * l(k[3' 3])'  					Target = td  				})  				       .Emit(new AssignmentStatement { Value = ta' Target = a })  				       .Emit(new AssignmentStatement { Value = tb' Target = b })  				       .Emit(new AssignmentStatement { Value = tc' Target = c })  				       .Emit(new AssignmentStatement { Value = td' Target = d });
Magic Number,Confuser.DynCipher.Elements,Matrix,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,EmitCore,The following statement contains a magic number: context.Emit(new AssignmentStatement {  					Value = a * l(k[0' 0]) + b * l(k[0' 1]) + c * l(k[0' 2]) + d * l(k[0' 3])'  					Target = ta  				}).Emit(new AssignmentStatement {  					Value = a * l(k[1' 0]) + b * l(k[1' 1]) + c * l(k[1' 2]) + d * l(k[1' 3])'  					Target = tb  				}).Emit(new AssignmentStatement {  					Value = a * l(k[2' 0]) + b * l(k[2' 1]) + c * l(k[2' 2]) + d * l(k[2' 3])'  					Target = tc  				}).Emit(new AssignmentStatement {  					Value = a * l(k[3' 0]) + b * l(k[3' 1]) + c * l(k[3' 2]) + d * l(k[3' 3])'  					Target = td  				})  				       .Emit(new AssignmentStatement { Value = ta' Target = a })  				       .Emit(new AssignmentStatement { Value = tb' Target = b })  				       .Emit(new AssignmentStatement { Value = tc' Target = c })  				       .Emit(new AssignmentStatement { Value = td' Target = d });
Magic Number,Confuser.DynCipher.Elements,Matrix,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,EmitCore,The following statement contains a magic number: context.Emit(new AssignmentStatement {  					Value = a * l(k[0' 0]) + b * l(k[0' 1]) + c * l(k[0' 2]) + d * l(k[0' 3])'  					Target = ta  				}).Emit(new AssignmentStatement {  					Value = a * l(k[1' 0]) + b * l(k[1' 1]) + c * l(k[1' 2]) + d * l(k[1' 3])'  					Target = tb  				}).Emit(new AssignmentStatement {  					Value = a * l(k[2' 0]) + b * l(k[2' 1]) + c * l(k[2' 2]) + d * l(k[2' 3])'  					Target = tc  				}).Emit(new AssignmentStatement {  					Value = a * l(k[3' 0]) + b * l(k[3' 1]) + c * l(k[3' 2]) + d * l(k[3' 3])'  					Target = td  				})  				       .Emit(new AssignmentStatement { Value = ta' Target = a })  				       .Emit(new AssignmentStatement { Value = tb' Target = b })  				       .Emit(new AssignmentStatement { Value = tc' Target = c })  				       .Emit(new AssignmentStatement { Value = td' Target = d });
Magic Number,Confuser.DynCipher.Elements,Matrix,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,EmitCore,The following statement contains a magic number: context.Emit(new AssignmentStatement {  					Value = a * l(k[0' 0]) + b * l(k[0' 1]) + c * l(k[0' 2]) + d * l(k[0' 3])'  					Target = ta  				}).Emit(new AssignmentStatement {  					Value = a * l(k[1' 0]) + b * l(k[1' 1]) + c * l(k[1' 2]) + d * l(k[1' 3])'  					Target = tb  				}).Emit(new AssignmentStatement {  					Value = a * l(k[2' 0]) + b * l(k[2' 1]) + c * l(k[2' 2]) + d * l(k[2' 3])'  					Target = tc  				}).Emit(new AssignmentStatement {  					Value = a * l(k[3' 0]) + b * l(k[3' 1]) + c * l(k[3' 2]) + d * l(k[3' 3])'  					Target = td  				})  				       .Emit(new AssignmentStatement { Value = ta' Target = a })  				       .Emit(new AssignmentStatement { Value = tb' Target = b })  				       .Emit(new AssignmentStatement { Value = tc' Target = c })  				       .Emit(new AssignmentStatement { Value = td' Target = d });
Magic Number,Confuser.DynCipher.Elements,Matrix,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,EmitCore,The following statement contains a magic number: context.Emit(new AssignmentStatement {  					Value = a * l(k[0' 0]) + b * l(k[0' 1]) + c * l(k[0' 2]) + d * l(k[0' 3])'  					Target = ta  				}).Emit(new AssignmentStatement {  					Value = a * l(k[1' 0]) + b * l(k[1' 1]) + c * l(k[1' 2]) + d * l(k[1' 3])'  					Target = tb  				}).Emit(new AssignmentStatement {  					Value = a * l(k[2' 0]) + b * l(k[2' 1]) + c * l(k[2' 2]) + d * l(k[2' 3])'  					Target = tc  				}).Emit(new AssignmentStatement {  					Value = a * l(k[3' 0]) + b * l(k[3' 1]) + c * l(k[3' 2]) + d * l(k[3' 3])'  					Target = td  				})  				       .Emit(new AssignmentStatement { Value = ta' Target = a })  				       .Emit(new AssignmentStatement { Value = tb' Target = b })  				       .Emit(new AssignmentStatement { Value = tc' Target = c })  				       .Emit(new AssignmentStatement { Value = td' Target = d });
Magic Number,Confuser.DynCipher.Elements,Matrix,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,EmitCore,The following statement contains a magic number: context.Emit(new AssignmentStatement {  					Value = a * l(k[0' 0]) + b * l(k[0' 1]) + c * l(k[0' 2]) + d * l(k[0' 3])'  					Target = ta  				}).Emit(new AssignmentStatement {  					Value = a * l(k[1' 0]) + b * l(k[1' 1]) + c * l(k[1' 2]) + d * l(k[1' 3])'  					Target = tb  				}).Emit(new AssignmentStatement {  					Value = a * l(k[2' 0]) + b * l(k[2' 1]) + c * l(k[2' 2]) + d * l(k[2' 3])'  					Target = tc  				}).Emit(new AssignmentStatement {  					Value = a * l(k[3' 0]) + b * l(k[3' 1]) + c * l(k[3' 2]) + d * l(k[3' 3])'  					Target = td  				})  				       .Emit(new AssignmentStatement { Value = ta' Target = a })  				       .Emit(new AssignmentStatement { Value = tb' Target = b })  				       .Emit(new AssignmentStatement { Value = tc' Target = c })  				       .Emit(new AssignmentStatement { Value = td' Target = d });
Magic Number,Confuser.DynCipher.Elements,Matrix,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,EmitCore,The following statement contains a magic number: context.Emit(new AssignmentStatement {  					Value = a * l(k[0' 0]) + b * l(k[0' 1]) + c * l(k[0' 2]) + d * l(k[0' 3])'  					Target = ta  				}).Emit(new AssignmentStatement {  					Value = a * l(k[1' 0]) + b * l(k[1' 1]) + c * l(k[1' 2]) + d * l(k[1' 3])'  					Target = tb  				}).Emit(new AssignmentStatement {  					Value = a * l(k[2' 0]) + b * l(k[2' 1]) + c * l(k[2' 2]) + d * l(k[2' 3])'  					Target = tc  				}).Emit(new AssignmentStatement {  					Value = a * l(k[3' 0]) + b * l(k[3' 1]) + c * l(k[3' 2]) + d * l(k[3' 3])'  					Target = td  				})  				       .Emit(new AssignmentStatement { Value = ta' Target = a })  				       .Emit(new AssignmentStatement { Value = tb' Target = b })  				       .Emit(new AssignmentStatement { Value = tc' Target = c })  				       .Emit(new AssignmentStatement { Value = td' Target = d });
Magic Number,Confuser.DynCipher.Elements,Matrix,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,EmitCore,The following statement contains a magic number: context.Emit(new AssignmentStatement {  					Value = a * l(k[0' 0]) + b * l(k[0' 1]) + c * l(k[0' 2]) + d * l(k[0' 3])'  					Target = ta  				}).Emit(new AssignmentStatement {  					Value = a * l(k[1' 0]) + b * l(k[1' 1]) + c * l(k[1' 2]) + d * l(k[1' 3])'  					Target = tb  				}).Emit(new AssignmentStatement {  					Value = a * l(k[2' 0]) + b * l(k[2' 1]) + c * l(k[2' 2]) + d * l(k[2' 3])'  					Target = tc  				}).Emit(new AssignmentStatement {  					Value = a * l(k[3' 0]) + b * l(k[3' 1]) + c * l(k[3' 2]) + d * l(k[3' 3])'  					Target = td  				})  				       .Emit(new AssignmentStatement { Value = ta' Target = a })  				       .Emit(new AssignmentStatement { Value = tb' Target = b })  				       .Emit(new AssignmentStatement { Value = tc' Target = c })  				       .Emit(new AssignmentStatement { Value = td' Target = d });
Magic Number,Confuser.DynCipher.Elements,Matrix,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,EmitCore,The following statement contains a magic number: context.Emit(new AssignmentStatement {  					Value = a * l(k[0' 0]) + b * l(k[0' 1]) + c * l(k[0' 2]) + d * l(k[0' 3])'  					Target = ta  				}).Emit(new AssignmentStatement {  					Value = a * l(k[1' 0]) + b * l(k[1' 1]) + c * l(k[1' 2]) + d * l(k[1' 3])'  					Target = tb  				}).Emit(new AssignmentStatement {  					Value = a * l(k[2' 0]) + b * l(k[2' 1]) + c * l(k[2' 2]) + d * l(k[2' 3])'  					Target = tc  				}).Emit(new AssignmentStatement {  					Value = a * l(k[3' 0]) + b * l(k[3' 1]) + c * l(k[3' 2]) + d * l(k[3' 3])'  					Target = td  				})  				       .Emit(new AssignmentStatement { Value = ta' Target = a })  				       .Emit(new AssignmentStatement { Value = tb' Target = b })  				       .Emit(new AssignmentStatement { Value = tc' Target = c })  				       .Emit(new AssignmentStatement { Value = td' Target = d });
Magic Number,Confuser.DynCipher.Elements,Matrix,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,EmitCore,The following statement contains a magic number: context.Emit(new AssignmentStatement {  					Value = a * l(k[0' 0]) + b * l(k[0' 1]) + c * l(k[0' 2]) + d * l(k[0' 3])'  					Target = ta  				}).Emit(new AssignmentStatement {  					Value = a * l(k[1' 0]) + b * l(k[1' 1]) + c * l(k[1' 2]) + d * l(k[1' 3])'  					Target = tb  				}).Emit(new AssignmentStatement {  					Value = a * l(k[2' 0]) + b * l(k[2' 1]) + c * l(k[2' 2]) + d * l(k[2' 3])'  					Target = tc  				}).Emit(new AssignmentStatement {  					Value = a * l(k[3' 0]) + b * l(k[3' 1]) + c * l(k[3' 2]) + d * l(k[3' 3])'  					Target = td  				})  				       .Emit(new AssignmentStatement { Value = ta' Target = a })  				       .Emit(new AssignmentStatement { Value = tb' Target = b })  				       .Emit(new AssignmentStatement { Value = tc' Target = c })  				       .Emit(new AssignmentStatement { Value = td' Target = d });
Magic Number,Confuser.DynCipher.Elements,Matrix,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,EmitCore,The following statement contains a magic number: context.Emit(new AssignmentStatement {  					Value = a * l(k[0' 0]) + b * l(k[0' 1]) + c * l(k[0' 2]) + d * l(k[0' 3])'  					Target = ta  				}).Emit(new AssignmentStatement {  					Value = a * l(k[1' 0]) + b * l(k[1' 1]) + c * l(k[1' 2]) + d * l(k[1' 3])'  					Target = tb  				}).Emit(new AssignmentStatement {  					Value = a * l(k[2' 0]) + b * l(k[2' 1]) + c * l(k[2' 2]) + d * l(k[2' 3])'  					Target = tc  				}).Emit(new AssignmentStatement {  					Value = a * l(k[3' 0]) + b * l(k[3' 1]) + c * l(k[3' 2]) + d * l(k[3' 3])'  					Target = td  				})  				       .Emit(new AssignmentStatement { Value = ta' Target = a })  				       .Emit(new AssignmentStatement { Value = tb' Target = b })  				       .Emit(new AssignmentStatement { Value = tc' Target = c })  				       .Emit(new AssignmentStatement { Value = td' Target = d });
Magic Number,Confuser.DynCipher.Elements,Matrix,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,EmitCore,The following statement contains a magic number: context.Emit(new AssignmentStatement {  					Value = a * l(k[0' 0]) + b * l(k[0' 1]) + c * l(k[0' 2]) + d * l(k[0' 3])'  					Target = ta  				}).Emit(new AssignmentStatement {  					Value = a * l(k[1' 0]) + b * l(k[1' 1]) + c * l(k[1' 2]) + d * l(k[1' 3])'  					Target = tb  				}).Emit(new AssignmentStatement {  					Value = a * l(k[2' 0]) + b * l(k[2' 1]) + c * l(k[2' 2]) + d * l(k[2' 3])'  					Target = tc  				}).Emit(new AssignmentStatement {  					Value = a * l(k[3' 0]) + b * l(k[3' 1]) + c * l(k[3' 2]) + d * l(k[3' 3])'  					Target = td  				})  				       .Emit(new AssignmentStatement { Value = ta' Target = a })  				       .Emit(new AssignmentStatement { Value = tb' Target = b })  				       .Emit(new AssignmentStatement { Value = tc' Target = c })  				       .Emit(new AssignmentStatement { Value = td' Target = d });
Magic Number,Confuser.DynCipher.Elements,Matrix,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Matrix.cs,EmitCore,The following statement contains a magic number: context.Emit(new AssignmentStatement {  					Value = a * l(k[0' 0]) + b * l(k[0' 1]) + c * l(k[0' 2]) + d * l(k[0' 3])'  					Target = ta  				}).Emit(new AssignmentStatement {  					Value = a * l(k[1' 0]) + b * l(k[1' 1]) + c * l(k[1' 2]) + d * l(k[1' 3])'  					Target = tb  				}).Emit(new AssignmentStatement {  					Value = a * l(k[2' 0]) + b * l(k[2' 1]) + c * l(k[2' 2]) + d * l(k[2' 3])'  					Target = tc  				}).Emit(new AssignmentStatement {  					Value = a * l(k[3' 0]) + b * l(k[3' 1]) + c * l(k[3' 2]) + d * l(k[3' 3])'  					Target = td  				})  				       .Emit(new AssignmentStatement { Value = ta' Target = a })  				       .Emit(new AssignmentStatement { Value = tb' Target = b })  				       .Emit(new AssignmentStatement { Value = tc' Target = c })  				       .Emit(new AssignmentStatement { Value = td' Target = d });
Magic Number,Confuser.DynCipher.Elements,NumOp,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\NumOp.cs,Initialize,The following statement contains a magic number: Operation = (CryptoNumOps)(random.NextInt32(4));
Magic Number,Confuser.DynCipher.Elements,RotateBit,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\RotateBit.cs,Initialize,The following statement contains a magic number: Bits = random.NextInt32(1' 32);
Magic Number,Confuser.DynCipher.Elements,RotateBit,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\RotateBit.cs,Initialize,The following statement contains a magic number: IsAlternate = (random.NextInt32() % 2 == 0);
Magic Number,Confuser.DynCipher.Elements,RotateBit,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\RotateBit.cs,Emit,The following statement contains a magic number: context.Emit(new AssignmentStatement {  						Value = (val >> (32 - Bits))'  						Target = tmp  					}).Emit(new AssignmentStatement {  						Value = (val << Bits) | tmp'  						Target = val  					});
Magic Number,Confuser.DynCipher.Elements,RotateBit,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\RotateBit.cs,EmitInverse,The following statement contains a magic number: context.Emit(new AssignmentStatement {  						Value = (val << (32 - Bits))'  						Target = tmp  					}).Emit(new AssignmentStatement {  						Value = (val >> Bits) | tmp'  						Target = val  					});
Magic Number,Confuser.DynCipher.Elements,Swap,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\Swap.cs,Initialize,The following statement contains a magic number: random.NextInt32(3) == 0
Magic Number,Confuser.DynCipher.Generation,CipherGenerator,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\CipherGenerator.cs,GeneratePair,The following statement contains a magic number: double varPrecentage = 1 + ((random.NextDouble() * 2) - 1) * VARIANCE;
Magic Number,Confuser.DynCipher.Generation,CipherGenerator,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\CipherGenerator.cs,GeneratePair,The following statement contains a magic number: i < 16
Magic Number,Confuser.DynCipher.Generation,CipherGenerator,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\CipherGenerator.cs,GeneratePair,The following statement contains a magic number: int[] x = Enumerable.Range(0' 16).ToArray();
Magic Number,Confuser.DynCipher.Generation,CipherGenerator,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\CipherGenerator.cs,GeneratePair,The following statement contains a magic number: int index = 16;
Magic Number,Confuser.DynCipher.Generation,CipherGenerator,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\CipherGenerator.cs,GeneratePair,The following statement contains a magic number: index == 16
Magic Number,Confuser.DynCipher.Generation,CipherGenerator,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\CipherGenerator.cs,GeneratePair,The following statement contains a magic number: var encryptContext = new CipherGenContext(random' 16);
Magic Number,Confuser.DynCipher.Generation,CipherGenerator,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\CipherGenerator.cs,GeneratePair,The following statement contains a magic number: var decryptContext = new CipherGenContext(random' 16);
Magic Number,Confuser.DynCipher.Generation,ExpressionGenerator,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\ExpressionGenerator.cs,GenerateExpression,The following statement contains a magic number: currentDepth == targetDepth || (currentDepth > targetDepth / 3 && random.NextInt32(100) > 85)
Magic Number,Confuser.DynCipher.Generation,ExpressionGenerator,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\ExpressionGenerator.cs,GenerateExpression,The following statement contains a magic number: currentDepth == targetDepth || (currentDepth > targetDepth / 3 && random.NextInt32(100) > 85)
Magic Number,Confuser.DynCipher.Generation,ExpressionGenerator,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\ExpressionGenerator.cs,GenerateExpression,The following statement contains a magic number: currentDepth == targetDepth || (currentDepth > targetDepth / 3 && random.NextInt32(100) > 85)
Magic Number,Confuser.DynCipher.Generation,ExpressionGenerator,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\ExpressionGenerator.cs,GenerateExpression,The following statement contains a magic number: switch ((ExpressionOps)random.NextInt32(6)) {  				case ExpressionOps.Add:  					return GenerateExpression(random' current' currentDepth + 1' targetDepth) +  					       GenerateExpression(random' (LiteralExpression)random.NextUInt32()' currentDepth + 1' targetDepth);    				case ExpressionOps.Sub:  					return GenerateExpression(random' current' currentDepth + 1' targetDepth) -  					       GenerateExpression(random' (LiteralExpression)random.NextUInt32()' currentDepth + 1' targetDepth);    				case ExpressionOps.Mul:  					return GenerateExpression(random' current' currentDepth + 1' targetDepth) * (LiteralExpression)(random.NextUInt32() | 1);    				case ExpressionOps.Xor:  					return GenerateExpression(random' current' currentDepth + 1' targetDepth) ^  					       GenerateExpression(random' (LiteralExpression)random.NextUInt32()' currentDepth + 1' targetDepth);    				case ExpressionOps.Not:  					return ~GenerateExpression(random' current' currentDepth + 1' targetDepth);    				case ExpressionOps.Neg:  					return -GenerateExpression(random' current' currentDepth + 1' targetDepth);  			}
Magic Number,Confuser.DynCipher.Generation,x86CodeGen,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\x86CodeGen.cs,GenerateX86,The following statement contains a magic number: usedRegs = new bool[8];
Magic Number,Confuser.DynCipher.Generation,x86CodeGen,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\x86CodeGen.cs,GetFreeRegister,The following statement contains a magic number: i < 8
Magic Number,Confuser.DynCipher.Generation,x86CodeGen,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\x86CodeGen.cs,Normalize,The following statement contains a magic number: instr.Operands.Length == 2 &&  			    instr.Operands[0] is x86ImmediateOperand &&  			    instr.Operands[1] is x86ImmediateOperand
Magic Number,Confuser.DynCipher.Generation,x86CodeGen,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\x86CodeGen.cs,Normalize,The following statement contains a magic number: instr.Operands.Length == 2 &&  			    instr.Operands[0] is x86ImmediateOperand &&  			    instr.Operands[1] is x86RegisterOperand
Magic Number,Confuser.DynCipher.Generation,x86CodeGen,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\x86CodeGen.cs,Normalize,The following statement contains a magic number: instr.Operands.Length == 2 && instr.Operands[1] is x86RegisterOperand
Magic Number,Confuser.DynCipher.Generation,x86Instruction,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\x86CodeGen.cs,Assemble,The following statement contains a magic number: switch (OpCode) {  				case x86OpCode.MOV: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x89;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[5];  						ret[0] = 0xb8;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 1' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.ADD: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x01;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.SUB: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x29;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xe8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NEG: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NOT: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.XOR: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x31;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xf0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.POP: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[1];  						ret[0] = 0x58;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.IMUL: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[3];  						ret[0] = 0x0f;  						ret[1] = 0xaf;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x69;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				default:  					throw new NotSupportedException();  			}
Magic Number,Confuser.DynCipher.Generation,x86Instruction,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\x86CodeGen.cs,Assemble,The following statement contains a magic number: switch (OpCode) {  				case x86OpCode.MOV: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x89;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[5];  						ret[0] = 0xb8;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 1' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.ADD: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x01;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.SUB: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x29;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xe8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NEG: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NOT: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.XOR: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x31;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xf0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.POP: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[1];  						ret[0] = 0x58;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.IMUL: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[3];  						ret[0] = 0x0f;  						ret[1] = 0xaf;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x69;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				default:  					throw new NotSupportedException();  			}
Magic Number,Confuser.DynCipher.Generation,x86Instruction,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\x86CodeGen.cs,Assemble,The following statement contains a magic number: switch (OpCode) {  				case x86OpCode.MOV: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x89;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[5];  						ret[0] = 0xb8;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 1' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.ADD: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x01;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.SUB: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x29;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xe8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NEG: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NOT: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.XOR: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x31;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xf0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.POP: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[1];  						ret[0] = 0x58;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.IMUL: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[3];  						ret[0] = 0x0f;  						ret[1] = 0xaf;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x69;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				default:  					throw new NotSupportedException();  			}
Magic Number,Confuser.DynCipher.Generation,x86Instruction,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\x86CodeGen.cs,Assemble,The following statement contains a magic number: switch (OpCode) {  				case x86OpCode.MOV: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x89;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[5];  						ret[0] = 0xb8;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 1' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.ADD: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x01;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.SUB: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x29;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xe8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NEG: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NOT: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.XOR: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x31;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xf0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.POP: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[1];  						ret[0] = 0x58;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.IMUL: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[3];  						ret[0] = 0x0f;  						ret[1] = 0xaf;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x69;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				default:  					throw new NotSupportedException();  			}
Magic Number,Confuser.DynCipher.Generation,x86Instruction,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\x86CodeGen.cs,Assemble,The following statement contains a magic number: switch (OpCode) {  				case x86OpCode.MOV: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x89;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[5];  						ret[0] = 0xb8;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 1' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.ADD: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x01;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.SUB: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x29;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xe8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NEG: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NOT: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.XOR: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x31;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xf0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.POP: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[1];  						ret[0] = 0x58;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.IMUL: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[3];  						ret[0] = 0x0f;  						ret[1] = 0xaf;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x69;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				default:  					throw new NotSupportedException();  			}
Magic Number,Confuser.DynCipher.Generation,x86Instruction,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\x86CodeGen.cs,Assemble,The following statement contains a magic number: switch (OpCode) {  				case x86OpCode.MOV: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x89;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[5];  						ret[0] = 0xb8;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 1' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.ADD: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x01;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.SUB: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x29;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xe8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NEG: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NOT: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.XOR: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x31;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xf0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.POP: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[1];  						ret[0] = 0x58;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.IMUL: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[3];  						ret[0] = 0x0f;  						ret[1] = 0xaf;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x69;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				default:  					throw new NotSupportedException();  			}
Magic Number,Confuser.DynCipher.Generation,x86Instruction,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\x86CodeGen.cs,Assemble,The following statement contains a magic number: switch (OpCode) {  				case x86OpCode.MOV: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x89;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[5];  						ret[0] = 0xb8;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 1' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.ADD: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x01;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.SUB: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x29;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xe8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NEG: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NOT: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.XOR: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x31;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xf0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.POP: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[1];  						ret[0] = 0x58;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.IMUL: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[3];  						ret[0] = 0x0f;  						ret[1] = 0xaf;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x69;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				default:  					throw new NotSupportedException();  			}
Magic Number,Confuser.DynCipher.Generation,x86Instruction,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\x86CodeGen.cs,Assemble,The following statement contains a magic number: switch (OpCode) {  				case x86OpCode.MOV: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x89;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[5];  						ret[0] = 0xb8;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 1' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.ADD: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x01;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.SUB: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x29;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xe8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NEG: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NOT: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.XOR: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x31;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xf0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.POP: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[1];  						ret[0] = 0x58;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.IMUL: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[3];  						ret[0] = 0x0f;  						ret[1] = 0xaf;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x69;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				default:  					throw new NotSupportedException();  			}
Magic Number,Confuser.DynCipher.Generation,x86Instruction,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\x86CodeGen.cs,Assemble,The following statement contains a magic number: switch (OpCode) {  				case x86OpCode.MOV: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x89;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[5];  						ret[0] = 0xb8;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 1' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.ADD: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x01;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.SUB: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x29;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xe8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NEG: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NOT: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.XOR: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x31;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xf0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.POP: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[1];  						ret[0] = 0x58;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.IMUL: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[3];  						ret[0] = 0x0f;  						ret[1] = 0xaf;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x69;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				default:  					throw new NotSupportedException();  			}
Magic Number,Confuser.DynCipher.Generation,x86Instruction,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\x86CodeGen.cs,Assemble,The following statement contains a magic number: switch (OpCode) {  				case x86OpCode.MOV: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x89;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[5];  						ret[0] = 0xb8;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 1' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.ADD: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x01;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.SUB: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x29;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xe8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NEG: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NOT: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.XOR: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x31;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xf0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.POP: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[1];  						ret[0] = 0x58;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.IMUL: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[3];  						ret[0] = 0x0f;  						ret[1] = 0xaf;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x69;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				default:  					throw new NotSupportedException();  			}
Magic Number,Confuser.DynCipher.Generation,x86Instruction,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\x86CodeGen.cs,Assemble,The following statement contains a magic number: switch (OpCode) {  				case x86OpCode.MOV: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x89;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[5];  						ret[0] = 0xb8;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 1' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.ADD: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x01;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.SUB: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x29;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xe8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NEG: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NOT: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.XOR: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x31;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xf0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.POP: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[1];  						ret[0] = 0x58;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.IMUL: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[3];  						ret[0] = 0x0f;  						ret[1] = 0xaf;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x69;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				default:  					throw new NotSupportedException();  			}
Magic Number,Confuser.DynCipher.Generation,x86Instruction,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\x86CodeGen.cs,Assemble,The following statement contains a magic number: switch (OpCode) {  				case x86OpCode.MOV: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x89;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[5];  						ret[0] = 0xb8;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 1' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.ADD: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x01;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.SUB: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x29;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xe8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NEG: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NOT: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.XOR: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x31;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xf0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.POP: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[1];  						ret[0] = 0x58;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.IMUL: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[3];  						ret[0] = 0x0f;  						ret[1] = 0xaf;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x69;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				default:  					throw new NotSupportedException();  			}
Magic Number,Confuser.DynCipher.Generation,x86Instruction,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\x86CodeGen.cs,Assemble,The following statement contains a magic number: switch (OpCode) {  				case x86OpCode.MOV: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x89;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[5];  						ret[0] = 0xb8;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 1' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.ADD: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x01;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.SUB: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x29;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xe8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NEG: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NOT: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.XOR: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x31;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xf0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.POP: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[1];  						ret[0] = 0x58;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.IMUL: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[3];  						ret[0] = 0x0f;  						ret[1] = 0xaf;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x69;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				default:  					throw new NotSupportedException();  			}
Magic Number,Confuser.DynCipher.Generation,x86Instruction,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\x86CodeGen.cs,Assemble,The following statement contains a magic number: switch (OpCode) {  				case x86OpCode.MOV: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x89;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[5];  						ret[0] = 0xb8;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 1' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.ADD: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x01;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.SUB: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x29;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xe8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NEG: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NOT: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.XOR: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x31;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xf0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.POP: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[1];  						ret[0] = 0x58;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.IMUL: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[3];  						ret[0] = 0x0f;  						ret[1] = 0xaf;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x69;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				default:  					throw new NotSupportedException();  			}
Magic Number,Confuser.DynCipher.Generation,x86Instruction,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\x86CodeGen.cs,Assemble,The following statement contains a magic number: switch (OpCode) {  				case x86OpCode.MOV: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x89;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[5];  						ret[0] = 0xb8;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 1' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.ADD: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x01;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.SUB: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x29;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xe8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NEG: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NOT: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.XOR: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x31;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xf0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.POP: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[1];  						ret[0] = 0x58;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.IMUL: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[3];  						ret[0] = 0x0f;  						ret[1] = 0xaf;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x69;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				default:  					throw new NotSupportedException();  			}
Magic Number,Confuser.DynCipher.Generation,x86Instruction,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\x86CodeGen.cs,Assemble,The following statement contains a magic number: switch (OpCode) {  				case x86OpCode.MOV: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x89;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[5];  						ret[0] = 0xb8;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 1' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.ADD: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x01;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.SUB: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x29;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xe8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NEG: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NOT: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.XOR: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x31;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xf0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.POP: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[1];  						ret[0] = 0x58;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.IMUL: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[3];  						ret[0] = 0x0f;  						ret[1] = 0xaf;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x69;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				default:  					throw new NotSupportedException();  			}
Magic Number,Confuser.DynCipher.Generation,x86Instruction,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\x86CodeGen.cs,Assemble,The following statement contains a magic number: switch (OpCode) {  				case x86OpCode.MOV: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x89;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[5];  						ret[0] = 0xb8;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 1' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.ADD: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x01;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.SUB: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x29;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xe8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NEG: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NOT: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.XOR: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x31;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xf0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.POP: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[1];  						ret[0] = 0x58;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.IMUL: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[3];  						ret[0] = 0x0f;  						ret[1] = 0xaf;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x69;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				default:  					throw new NotSupportedException();  			}
Magic Number,Confuser.DynCipher.Generation,x86Instruction,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\x86CodeGen.cs,Assemble,The following statement contains a magic number: switch (OpCode) {  				case x86OpCode.MOV: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x89;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[5];  						ret[0] = 0xb8;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 1' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.ADD: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x01;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.SUB: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x29;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xe8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NEG: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NOT: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.XOR: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x31;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xf0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.POP: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[1];  						ret[0] = 0x58;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.IMUL: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[3];  						ret[0] = 0x0f;  						ret[1] = 0xaf;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x69;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				default:  					throw new NotSupportedException();  			}
Magic Number,Confuser.DynCipher.Generation,x86Instruction,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\x86CodeGen.cs,Assemble,The following statement contains a magic number: switch (OpCode) {  				case x86OpCode.MOV: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x89;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[5];  						ret[0] = 0xb8;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 1' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.ADD: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x01;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.SUB: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x29;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xe8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NEG: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NOT: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.XOR: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x31;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xf0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.POP: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[1];  						ret[0] = 0x58;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.IMUL: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[3];  						ret[0] = 0x0f;  						ret[1] = 0xaf;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x69;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				default:  					throw new NotSupportedException();  			}
Magic Number,Confuser.DynCipher.Generation,x86Instruction,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\x86CodeGen.cs,Assemble,The following statement contains a magic number: switch (OpCode) {  				case x86OpCode.MOV: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x89;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[5];  						ret[0] = 0xb8;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 1' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.ADD: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x01;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.SUB: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x29;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xe8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NEG: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NOT: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.XOR: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x31;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xf0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.POP: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[1];  						ret[0] = 0x58;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.IMUL: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[3];  						ret[0] = 0x0f;  						ret[1] = 0xaf;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x69;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				default:  					throw new NotSupportedException();  			}
Magic Number,Confuser.DynCipher.Generation,x86Instruction,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\x86CodeGen.cs,Assemble,The following statement contains a magic number: switch (OpCode) {  				case x86OpCode.MOV: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x89;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[5];  						ret[0] = 0xb8;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 1' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.ADD: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x01;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.SUB: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x29;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xe8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NEG: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NOT: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.XOR: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x31;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xf0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.POP: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[1];  						ret[0] = 0x58;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.IMUL: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[3];  						ret[0] = 0x0f;  						ret[1] = 0xaf;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x69;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				default:  					throw new NotSupportedException();  			}
Magic Number,Confuser.DynCipher.Generation,x86Instruction,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\x86CodeGen.cs,Assemble,The following statement contains a magic number: switch (OpCode) {  				case x86OpCode.MOV: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x89;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[5];  						ret[0] = 0xb8;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 1' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.ADD: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x01;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.SUB: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x29;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xe8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NEG: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NOT: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.XOR: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x31;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xf0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.POP: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[1];  						ret[0] = 0x58;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.IMUL: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[3];  						ret[0] = 0x0f;  						ret[1] = 0xaf;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x69;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				default:  					throw new NotSupportedException();  			}
Magic Number,Confuser.DynCipher.Generation,x86Instruction,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\x86CodeGen.cs,Assemble,The following statement contains a magic number: switch (OpCode) {  				case x86OpCode.MOV: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x89;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[5];  						ret[0] = 0xb8;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 1' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.ADD: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x01;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.SUB: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x29;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xe8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NEG: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NOT: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.XOR: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x31;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xf0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.POP: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[1];  						ret[0] = 0x58;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.IMUL: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[3];  						ret[0] = 0x0f;  						ret[1] = 0xaf;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x69;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				default:  					throw new NotSupportedException();  			}
Magic Number,Confuser.DynCipher.Generation,x86Instruction,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\x86CodeGen.cs,Assemble,The following statement contains a magic number: switch (OpCode) {  				case x86OpCode.MOV: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x89;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[5];  						ret[0] = 0xb8;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 1' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.ADD: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x01;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.SUB: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x29;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xe8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NEG: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NOT: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.XOR: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x31;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xf0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.POP: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[1];  						ret[0] = 0x58;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.IMUL: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[3];  						ret[0] = 0x0f;  						ret[1] = 0xaf;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x69;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				default:  					throw new NotSupportedException();  			}
Magic Number,Confuser.DynCipher.Generation,x86Instruction,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\x86CodeGen.cs,Assemble,The following statement contains a magic number: switch (OpCode) {  				case x86OpCode.MOV: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x89;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[5];  						ret[0] = 0xb8;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 1' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.ADD: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x01;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.SUB: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x29;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xe8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NEG: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NOT: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.XOR: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x31;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xf0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.POP: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[1];  						ret[0] = 0x58;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.IMUL: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[3];  						ret[0] = 0x0f;  						ret[1] = 0xaf;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x69;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				default:  					throw new NotSupportedException();  			}
Magic Number,Confuser.DynCipher.Generation,x86Instruction,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\x86CodeGen.cs,Assemble,The following statement contains a magic number: switch (OpCode) {  				case x86OpCode.MOV: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x89;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[5];  						ret[0] = 0xb8;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 1' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.ADD: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x01;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.SUB: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x29;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xe8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NEG: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NOT: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.XOR: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x31;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xf0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.POP: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[1];  						ret[0] = 0x58;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.IMUL: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[3];  						ret[0] = 0x0f;  						ret[1] = 0xaf;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x69;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				default:  					throw new NotSupportedException();  			}
Magic Number,Confuser.DynCipher.Generation,x86Instruction,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\x86CodeGen.cs,Assemble,The following statement contains a magic number: switch (OpCode) {  				case x86OpCode.MOV: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x89;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[5];  						ret[0] = 0xb8;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 1' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.ADD: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x01;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.SUB: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x29;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xe8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NEG: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NOT: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.XOR: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x31;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xf0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.POP: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[1];  						ret[0] = 0x58;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.IMUL: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[3];  						ret[0] = 0x0f;  						ret[1] = 0xaf;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x69;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				default:  					throw new NotSupportedException();  			}
Magic Number,Confuser.DynCipher.Generation,x86Instruction,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\x86CodeGen.cs,Assemble,The following statement contains a magic number: switch (OpCode) {  				case x86OpCode.MOV: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x89;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[5];  						ret[0] = 0xb8;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 1' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.ADD: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x01;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.SUB: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x29;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xe8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NEG: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NOT: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.XOR: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x31;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xf0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.POP: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[1];  						ret[0] = 0x58;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.IMUL: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[3];  						ret[0] = 0x0f;  						ret[1] = 0xaf;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x69;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				default:  					throw new NotSupportedException();  			}
Magic Number,Confuser.DynCipher.Generation,x86Instruction,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\x86CodeGen.cs,Assemble,The following statement contains a magic number: switch (OpCode) {  				case x86OpCode.MOV: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x89;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[5];  						ret[0] = 0xb8;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 1' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.ADD: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x01;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.SUB: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x29;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xe8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NEG: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NOT: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.XOR: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x31;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xf0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.POP: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[1];  						ret[0] = 0x58;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.IMUL: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[3];  						ret[0] = 0x0f;  						ret[1] = 0xaf;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x69;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				default:  					throw new NotSupportedException();  			}
Magic Number,Confuser.DynCipher.Generation,x86Instruction,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\x86CodeGen.cs,Assemble,The following statement contains a magic number: switch (OpCode) {  				case x86OpCode.MOV: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x89;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[5];  						ret[0] = 0xb8;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 1' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.ADD: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x01;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.SUB: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x29;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xe8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NEG: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NOT: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.XOR: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x31;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xf0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.POP: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[1];  						ret[0] = 0x58;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.IMUL: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[3];  						ret[0] = 0x0f;  						ret[1] = 0xaf;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x69;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				default:  					throw new NotSupportedException();  			}
Magic Number,Confuser.DynCipher.Generation,x86Instruction,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\x86CodeGen.cs,Assemble,The following statement contains a magic number: switch (OpCode) {  				case x86OpCode.MOV: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x89;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[5];  						ret[0] = 0xb8;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 1' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.ADD: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x01;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.SUB: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x29;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xe8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NEG: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NOT: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.XOR: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x31;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xf0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.POP: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[1];  						ret[0] = 0x58;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.IMUL: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[3];  						ret[0] = 0x0f;  						ret[1] = 0xaf;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x69;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				default:  					throw new NotSupportedException();  			}
Magic Number,Confuser.DynCipher.Generation,x86Instruction,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\x86CodeGen.cs,Assemble,The following statement contains a magic number: switch (OpCode) {  				case x86OpCode.MOV: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x89;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[5];  						ret[0] = 0xb8;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 1' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.ADD: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x01;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.SUB: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x29;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xe8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NEG: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd8;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.NOT: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0xf7;  						ret[1] = 0xd0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.XOR: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[2];  						ret[0] = 0x31;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x81;  						ret[1] = 0xf0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.POP: {  					if (Operands.Length != 1) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand) {  						var ret = new byte[1];  						ret[0] = 0x58;  						ret[0] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					throw new NotSupportedException();  				}    				case x86OpCode.IMUL: {  					if (Operands.Length != 2) throw new InvalidOperationException();  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86RegisterOperand) {  						var ret = new byte[3];  						ret[0] = 0x0f;  						ret[1] = 0xaf;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[1] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						return ret;  					}  					if (Operands[0] is x86RegisterOperand &&  					    Operands[1] is x86ImmediateOperand) {  						var ret = new byte[6];  						ret[0] = 0x69;  						ret[1] = 0xc0;  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 3);  						ret[1] |= (byte)((int)(Operands[0] as x86RegisterOperand).Register << 0);  						Buffer.BlockCopy(BitConverter.GetBytes((Operands[1] as x86ImmediateOperand).Immediate)' 0' ret' 2' 4);  						return ret;  					}  					throw new NotSupportedException();  				}    				default:  					throw new NotSupportedException();  			}
Magic Number,Confuser.DynCipher.Transforms,MulToShiftTransform,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Transforms\MulToShiftTransform.cs,NumberOfSetBits,The following statement contains a magic number: i = (i & 0x33333333) + ((i >> 2) & 0x33333333);
Magic Number,Confuser.DynCipher.Transforms,MulToShiftTransform,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Transforms\MulToShiftTransform.cs,NumberOfSetBits,The following statement contains a magic number: return (((i + (i >> 4)) & 0x0F0F0F0F) * 0x01010101) >> 24;
Magic Number,Confuser.DynCipher.Transforms,MulToShiftTransform,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Transforms\MulToShiftTransform.cs,NumberOfSetBits,The following statement contains a magic number: return (((i + (i >> 4)) & 0x0F0F0F0F) * 0x01010101) >> 24;
Magic Number,Confuser.DynCipher.Transforms,MulToShiftTransform,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Transforms\MulToShiftTransform.cs,ProcessExpression,The following statement contains a magic number: bits <= 2
Missing Default,Confuser.DynCipher.Elements,BinOp,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\BinOp.cs,Emit,The following switch statement is missing a default case: switch (Operation) {  				case CryptoBinOps.Add:  					context.Emit(new AssignmentStatement {  						Value = a + b'  						Target = a  					});  					break;  				case CryptoBinOps.Xor:  					context.Emit(new AssignmentStatement {  						Value = a ^ b'  						Target = a  					});  					break;  				case CryptoBinOps.Xnor:  					context.Emit(new AssignmentStatement {  						Value = ~(a ^ b)'  						Target = a  					});  					break;  			}
Missing Default,Confuser.DynCipher.Elements,BinOp,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\BinOp.cs,EmitInverse,The following switch statement is missing a default case: switch (Operation) {  				case CryptoBinOps.Add:  					context.Emit(new AssignmentStatement {  						Value = a - b'  						Target = a  					});  					break;  				case CryptoBinOps.Xor:  					context.Emit(new AssignmentStatement {  						Value = a ^ b'  						Target = a  					});  					break;  				case CryptoBinOps.Xnor:  					context.Emit(new AssignmentStatement {  						Value = a ^ (~b)'  						Target = a  					});  					break;  			}
Missing Default,Confuser.DynCipher.Elements,NumOp,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\NumOp.cs,Initialize,The following switch statement is missing a default case: switch (Operation) {  				case CryptoNumOps.Add:  				case CryptoNumOps.Xor:  					Key = InverseKey = random.NextUInt32();  					break;  				case CryptoNumOps.Mul:  					Key = random.NextUInt32() | 1;  					InverseKey = MathsUtils.modInv(Key);  					break;  				case CryptoNumOps.Xnor:  					Key = random.NextUInt32();  					InverseKey = ~Key;  					break;  			}
Missing Default,Confuser.DynCipher.Elements,NumOp,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\NumOp.cs,Emit,The following switch statement is missing a default case: switch (Operation) {  				case CryptoNumOps.Add:  					context.Emit(new AssignmentStatement {  						Value = val + (LiteralExpression)Key'  						Target = val  					});  					break;  				case CryptoNumOps.Xor:  					context.Emit(new AssignmentStatement {  						Value = val ^ (LiteralExpression)Key'  						Target = val  					});  					break;  				case CryptoNumOps.Mul:  					context.Emit(new AssignmentStatement {  						Value = val * (LiteralExpression)Key'  						Target = val  					});  					break;  				case CryptoNumOps.Xnor:  					context.Emit(new AssignmentStatement {  						Value = ~(val ^ (LiteralExpression)Key)'  						Target = val  					});  					break;  			}
Missing Default,Confuser.DynCipher.Elements,NumOp,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Elements\NumOp.cs,EmitInverse,The following switch statement is missing a default case: switch (Operation) {  				case CryptoNumOps.Add:  					context.Emit(new AssignmentStatement {  						Value = val - (LiteralExpression)InverseKey'  						Target = val  					});  					break;  				case CryptoNumOps.Xor:  					context.Emit(new AssignmentStatement {  						Value = val ^ (LiteralExpression)InverseKey'  						Target = val  					});  					break;  				case CryptoNumOps.Mul:  					context.Emit(new AssignmentStatement {  						Value = val * (LiteralExpression)InverseKey'  						Target = val  					});  					break;  				case CryptoNumOps.Xnor:  					context.Emit(new AssignmentStatement {  						Value = val ^ (LiteralExpression)InverseKey'  						Target = val  					});  					break;  			}
Missing Default,Confuser.DynCipher.Generation,ExpressionGenerator,D:\research\architectureSmells\repos\yck1509_ConfuserEx\Confuser.DynCipher\Generation\ExpressionGenerator.cs,GenerateExpression,The following switch statement is missing a default case: switch ((ExpressionOps)random.NextInt32(6)) {  				case ExpressionOps.Add:  					return GenerateExpression(random' current' currentDepth + 1' targetDepth) +  					       GenerateExpression(random' (LiteralExpression)random.NextUInt32()' currentDepth + 1' targetDepth);    				case ExpressionOps.Sub:  					return GenerateExpression(random' current' currentDepth + 1' targetDepth) -  					       GenerateExpression(random' (LiteralExpression)random.NextUInt32()' currentDepth + 1' targetDepth);    				case ExpressionOps.Mul:  					return GenerateExpression(random' current' currentDepth + 1' targetDepth) * (LiteralExpression)(random.NextUInt32() | 1);    				case ExpressionOps.Xor:  					return GenerateExpression(random' current' currentDepth + 1' targetDepth) ^  					       GenerateExpression(random' (LiteralExpression)random.NextUInt32()' currentDepth + 1' targetDepth);    				case ExpressionOps.Not:  					return ~GenerateExpression(random' current' currentDepth + 1' targetDepth);    				case ExpressionOps.Neg:  					return -GenerateExpression(random' current' currentDepth + 1' targetDepth);  			}
