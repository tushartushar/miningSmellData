Implementation smell,Namespace,Class,File,Method,Description
Long Method,Confuser.Runtime,AntiDump,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiDump.cs,Initialize,The method has 209 lines of code.
Complex Method,Confuser.Runtime,AntiDump,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiDump.cs,Initialize,Cyclomatic complexity of the method is 11
Complex Method,Confuser.Runtime,AntiDebugWin32,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiDebug.Win32.cs,Worker,Cyclomatic complexity of the method is 8
Complex Method,Confuser.Runtime,AntiDebugAntinet,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiDebug.Antinet.cs,FindDebuggerRCThreadAddress,Cyclomatic complexity of the method is 9
Complex Method,Confuser.Runtime,ProfilerDetectorCLR20,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FindProfilerStatus,Cyclomatic complexity of the method is 10
Complex Method,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FindThreadingModeAddress,Cyclomatic complexity of the method is 16
Complex Method,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FindAttacherThreadProc,Cyclomatic complexity of the method is 10
Complex Method,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FindProfilerControlBlock,Cyclomatic complexity of the method is 11
Complex Method,Confuser.Runtime,AntiTamperJIT,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiTamper.JIT.cs,HookHandler,Cyclomatic complexity of the method is 11
Long Parameter List,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,CreateNamedPipe,The method has 8 parameters. Parameters: lpName' dwOpenMode' dwPipeMode' nMaxInstances' nOutBufferSize' nInBufferSize' nDefaultTimeOut' lpSecurityAttributes
Long Parameter List,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,CreateFile,The method has 7 parameters. Parameters: lpFileName' dwDesiredAccess' dwShareMode' lpSecurityAttributes' dwCreationDisposition' dwFlagsAndAttributes' hTemplateFile
Long Parameter List,Confuser.Runtime,AntiTamperJIT,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiTamper.JIT.cs,HookHandler,The method has 6 parameters. Parameters: self' comp' info' flags' nativeEntry' nativeSizeOfCode
Long Identifier,Confuser.Runtime,Info,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedDebugger.cs,,The length of the parameter DebuggerRCThread_pDebuggerIPCControlBlock is 41.
Long Identifier,Confuser.Runtime,Info,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedDebugger.cs,,The length of the parameter DebuggerRCThread_shouldKeepLooping is 34.
Long Identifier,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,,The length of the parameter ProfAPIMaxWaitForTriggerMs_name is 31.
Long Statement,Confuser.Runtime,AntiDebugAntinet,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiDebug.Antinet.cs,InitializeAntiDebugger,The length of the statement  "			var pDebuggerIPCControlBlock = (byte*)*(IntPtr*)((byte*)pDebuggerRCThread + info.DebuggerRCThread_pDebuggerIPCControlBlock); " is 124.
Long Statement,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,CreatePipeFileHandle,The length of the statement  "				return CreateFile(GetPipeName()' GENERIC_READ | GENERIC_WRITE' 0' IntPtr.Zero' OPEN_EXISTING' FILE_FLAG_OVERLAPPED' IntPtr.Zero); " is 129.
Long Statement,Confuser.Runtime,AntiTamperJIT,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiTamper.JIT.cs,Initialize,The length of the statement  "				moduleHnd = (IntPtr)m.GetType().GetField(new string((sbyte*)str)' BindingFlags.NonPublic | BindingFlags.Instance).GetValue(m); " is 126.
Long Statement,Confuser.Runtime,AntiTamperJIT,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiTamper.JIT.cs,HookHandler,The length of the statement  "					var getMethodDef = (getMethodDefFromMethod)Marshal.GetDelegateForFunctionPointer(comp->vfptr[0x64]' typeof(getMethodDefFromMethod)); " is 132.
Long Statement,Confuser.Runtime,AntiTamperJIT,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiTamper.JIT.cs,HookHandler,The length of the statement  "					ICorClassInfo* clsInfo = ICorStaticInfo.ICorClassInfo(ICorDynamicInfo.ICorStaticInfo(ICorJitInfo.ICorDynamicInfo(comp))); " is 121.
Long Statement,Confuser.Runtime,AntiTamperJIT,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiTamper.JIT.cs,HookHandler,The length of the statement  "					var getMethodDef = (getMethodDefFromMethod)Marshal.GetDelegateForFunctionPointer(clsInfo->vfptr[gmdSlot]' typeof(getMethodDefFromMethod)); " is 138.
Long Statement,Confuser.Runtime,CorMethodInfoHook,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiTamper.JIT.cs,Hook,The length of the statement  "				ICorMethodInfo* mtdInfo = ICorStaticInfo.ICorMethodInfo(ICorDynamicInfo.ICorStaticInfo(ICorJitInfo.ICorDynamicInfo(comp))); " is 123.
Long Statement,Confuser.Runtime,RefProxyStrong,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\RefProxy.Strong.cs,Initialize,The length of the statement  "						dm = new DynamicMethod(""' invoke.ReturnType' argTypes' (declType.IsInterface || declType.IsArray) ? delegateType : declType' true); " is 132.
Complex Conditional,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FindAttacherThreadProc,The conditional expression  "p[1] != push || p[2] != push || p[8] != push || p[9] != push"  is complex.
Complex Conditional,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FindProfilerControlBlock,The conditional expression  "*p == 0xA1 && p[5] == 0x83 && p[6] == 0xF8 && p[7] == 0x04"  is complex.
Complex Conditional,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FindProfilerControlBlock,The conditional expression  "*p == 0x8B && p[1] == 0x05 && p[6] == 0x83 && p[7] == 0xF8 && p[8] == 0x04"  is complex.
Complex Conditional,Confuser.Runtime,CorMethodInfoHook,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiTamper.JIT.cs,Hook,The conditional expression  "IntPtr.Size == 8 ?  								    (*func == 0x48 && *(func + 1) == 0x81 && *(func + 2) == 0xe9) :  								    (*func == 0x83 && *(func + 1) == 0xe9)"  is complex.
Empty Catch Block,Confuser.Runtime,AntiDebugAntinet,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiDebug.Antinet.cs,FindDebuggerRCThreadAddress,The method has an empty catch block.
Empty Catch Block,Confuser.Runtime,AntiDebugAntinet,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiDebug.Antinet.cs,FindDebuggerRCThreadAddress,The method has an empty catch block.
Empty Catch Block,Confuser.Runtime,ProfilerDetectorCLR20,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FindProfilerStatus,The method has an empty catch block.
Empty Catch Block,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,TakeOwnershipOfNamedPipe,The method has an empty catch block.
Empty Catch Block,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FindThreadingModeAddress,The method has an empty catch block.
Empty Catch Block,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FindThreadingModeAddress,The method has an empty catch block.
Empty Catch Block,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FindTimeOutOptionAddress,The method has an empty catch block.
Empty Catch Block,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FindTimeOutOptionAddress,The method has an empty catch block.
Empty Catch Block,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FindAttacherThreadProc,The method has an empty catch block.
Empty Catch Block,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,CheckThreadProc,The method has an empty catch block.
Empty Catch Block,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FindProfilerControlBlock,The method has an empty catch block.
Magic Number,Confuser.Runtime,AntiDump,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiDump.cs,Initialize,The following statement contains a magic number: ptr += 14;
Magic Number,Confuser.Runtime,AntiDump,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiDump.cs,Initialize,The following statement contains a magic number: byte* @new = stackalloc byte[11];
Magic Number,Confuser.Runtime,AntiDump,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiDump.cs,Initialize,The following statement contains a magic number: if (module.FullyQualifiedName[0] != '<') //Mapped  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				byte* mdDir = bas + *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;    				if (*(uint*)(ptr - 0x78) != 0) {  					byte* importDir = bas + *(uint*)(ptr - 0x78);  					byte* oftMod = bas + *(uint*)importDir;  					byte* modName = bas + *(uint*)(importDir + 12);  					byte* funcName = bas + *(uint*)oftMod + 2;  					VirtualProtect(modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(modName + i) = *(@new + i);    					VirtualProtect(funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(funcName + i) = *(@new + i);  				}    				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					ptr += 0x28;  				}  				VirtualProtect(mdDir' 0x48' 0x40' out old);  				byte* mdHdr = bas + *(uint*)(mdDir + 8);  				*(uint*)mdDir = 0;  				*((uint*)mdDir + 1) = 0;  				*((uint*)mdDir + 2) = 0;  				*((uint*)mdDir + 3) = 0;    				VirtualProtect(mdHdr' 4' 0x40' out old);  				*(uint*)mdHdr = 0;  				mdHdr += 12;  				mdHdr += *(uint*)mdHdr;  				mdHdr = (byte*)(((ulong)mdHdr + 7) & ~3UL);  				mdHdr += 2;  				ushort numOfStream = *mdHdr;  				mdHdr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdr' 8' 0x40' out old);  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdr' 4' 0x40' out old);  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 3;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 2;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 1;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  					}  				}  			}  			else //Flat  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				uint mdDir = *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;  				uint importDir = *(uint*)(ptr - 0x78);    				var vAdrs = new uint[sectNum];  				var vSizes = new uint[sectNum];  				var rAdrs = new uint[sectNum];  				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					vAdrs[i] = *(uint*)(ptr + 12);  					vSizes[i] = *(uint*)(ptr + 8);  					rAdrs[i] = *(uint*)(ptr + 20);  					ptr += 0x28;  				}      				if (importDir != 0) {  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= importDir && importDir < vAdrs[i] + vSizes[i]) {  							importDir = importDir - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* importDirPtr = bas + importDir;  					uint oftMod = *(uint*)importDirPtr;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= oftMod && oftMod < vAdrs[i] + vSizes[i]) {  							oftMod = oftMod - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* oftModPtr = bas + oftMod;  					uint modName = *(uint*)(importDirPtr + 12);  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= modName && modName < vAdrs[i] + vSizes[i]) {  							modName = modName - vAdrs[i] + rAdrs[i];  							break;  						}  					uint funcName = *(uint*)oftModPtr + 2;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= funcName && funcName < vAdrs[i] + vSizes[i]) {  							funcName = funcName - vAdrs[i] + rAdrs[i];  							break;  						}  					VirtualProtect(bas + modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + modName + i) = *(@new + i);    					VirtualProtect(bas + funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + funcName + i) = *(@new + i);  				}      				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdDir && mdDir < vAdrs[i] + vSizes[i]) {  						mdDir = mdDir - vAdrs[i] + rAdrs[i];  						break;  					}  				byte* mdDirPtr = bas + mdDir;  				VirtualProtect(mdDirPtr' 0x48' 0x40' out old);  				uint mdHdr = *(uint*)(mdDirPtr + 8);  				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdHdr && mdHdr < vAdrs[i] + vSizes[i]) {  						mdHdr = mdHdr - vAdrs[i] + rAdrs[i];  						break;  					}  				*(uint*)mdDirPtr = 0;  				*((uint*)mdDirPtr + 1) = 0;  				*((uint*)mdDirPtr + 2) = 0;  				*((uint*)mdDirPtr + 3) = 0;      				byte* mdHdrPtr = bas + mdHdr;  				VirtualProtect(mdHdrPtr' 4' 0x40' out old);  				*(uint*)mdHdrPtr = 0;  				mdHdrPtr += 12;  				mdHdrPtr += *(uint*)mdHdrPtr;  				mdHdrPtr = (byte*)(((ulong)mdHdrPtr + 7) & ~3UL);  				mdHdrPtr += 2;  				ushort numOfStream = *mdHdrPtr;  				mdHdrPtr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdrPtr' 8' 0x40' out old);  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdrPtr' 4' 0x40' out old);  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 3;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 2;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 1;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  					}  				}  			}
Magic Number,Confuser.Runtime,AntiDump,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiDump.cs,Initialize,The following statement contains a magic number: if (module.FullyQualifiedName[0] != '<') //Mapped  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				byte* mdDir = bas + *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;    				if (*(uint*)(ptr - 0x78) != 0) {  					byte* importDir = bas + *(uint*)(ptr - 0x78);  					byte* oftMod = bas + *(uint*)importDir;  					byte* modName = bas + *(uint*)(importDir + 12);  					byte* funcName = bas + *(uint*)oftMod + 2;  					VirtualProtect(modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(modName + i) = *(@new + i);    					VirtualProtect(funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(funcName + i) = *(@new + i);  				}    				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					ptr += 0x28;  				}  				VirtualProtect(mdDir' 0x48' 0x40' out old);  				byte* mdHdr = bas + *(uint*)(mdDir + 8);  				*(uint*)mdDir = 0;  				*((uint*)mdDir + 1) = 0;  				*((uint*)mdDir + 2) = 0;  				*((uint*)mdDir + 3) = 0;    				VirtualProtect(mdHdr' 4' 0x40' out old);  				*(uint*)mdHdr = 0;  				mdHdr += 12;  				mdHdr += *(uint*)mdHdr;  				mdHdr = (byte*)(((ulong)mdHdr + 7) & ~3UL);  				mdHdr += 2;  				ushort numOfStream = *mdHdr;  				mdHdr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdr' 8' 0x40' out old);  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdr' 4' 0x40' out old);  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 3;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 2;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 1;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  					}  				}  			}  			else //Flat  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				uint mdDir = *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;  				uint importDir = *(uint*)(ptr - 0x78);    				var vAdrs = new uint[sectNum];  				var vSizes = new uint[sectNum];  				var rAdrs = new uint[sectNum];  				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					vAdrs[i] = *(uint*)(ptr + 12);  					vSizes[i] = *(uint*)(ptr + 8);  					rAdrs[i] = *(uint*)(ptr + 20);  					ptr += 0x28;  				}      				if (importDir != 0) {  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= importDir && importDir < vAdrs[i] + vSizes[i]) {  							importDir = importDir - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* importDirPtr = bas + importDir;  					uint oftMod = *(uint*)importDirPtr;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= oftMod && oftMod < vAdrs[i] + vSizes[i]) {  							oftMod = oftMod - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* oftModPtr = bas + oftMod;  					uint modName = *(uint*)(importDirPtr + 12);  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= modName && modName < vAdrs[i] + vSizes[i]) {  							modName = modName - vAdrs[i] + rAdrs[i];  							break;  						}  					uint funcName = *(uint*)oftModPtr + 2;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= funcName && funcName < vAdrs[i] + vSizes[i]) {  							funcName = funcName - vAdrs[i] + rAdrs[i];  							break;  						}  					VirtualProtect(bas + modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + modName + i) = *(@new + i);    					VirtualProtect(bas + funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + funcName + i) = *(@new + i);  				}      				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdDir && mdDir < vAdrs[i] + vSizes[i]) {  						mdDir = mdDir - vAdrs[i] + rAdrs[i];  						break;  					}  				byte* mdDirPtr = bas + mdDir;  				VirtualProtect(mdDirPtr' 0x48' 0x40' out old);  				uint mdHdr = *(uint*)(mdDirPtr + 8);  				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdHdr && mdHdr < vAdrs[i] + vSizes[i]) {  						mdHdr = mdHdr - vAdrs[i] + rAdrs[i];  						break;  					}  				*(uint*)mdDirPtr = 0;  				*((uint*)mdDirPtr + 1) = 0;  				*((uint*)mdDirPtr + 2) = 0;  				*((uint*)mdDirPtr + 3) = 0;      				byte* mdHdrPtr = bas + mdHdr;  				VirtualProtect(mdHdrPtr' 4' 0x40' out old);  				*(uint*)mdHdrPtr = 0;  				mdHdrPtr += 12;  				mdHdrPtr += *(uint*)mdHdrPtr;  				mdHdrPtr = (byte*)(((ulong)mdHdrPtr + 7) & ~3UL);  				mdHdrPtr += 2;  				ushort numOfStream = *mdHdrPtr;  				mdHdrPtr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdrPtr' 8' 0x40' out old);  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdrPtr' 4' 0x40' out old);  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 3;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 2;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 1;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  					}  				}  			}
Magic Number,Confuser.Runtime,AntiDump,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiDump.cs,Initialize,The following statement contains a magic number: if (module.FullyQualifiedName[0] != '<') //Mapped  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				byte* mdDir = bas + *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;    				if (*(uint*)(ptr - 0x78) != 0) {  					byte* importDir = bas + *(uint*)(ptr - 0x78);  					byte* oftMod = bas + *(uint*)importDir;  					byte* modName = bas + *(uint*)(importDir + 12);  					byte* funcName = bas + *(uint*)oftMod + 2;  					VirtualProtect(modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(modName + i) = *(@new + i);    					VirtualProtect(funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(funcName + i) = *(@new + i);  				}    				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					ptr += 0x28;  				}  				VirtualProtect(mdDir' 0x48' 0x40' out old);  				byte* mdHdr = bas + *(uint*)(mdDir + 8);  				*(uint*)mdDir = 0;  				*((uint*)mdDir + 1) = 0;  				*((uint*)mdDir + 2) = 0;  				*((uint*)mdDir + 3) = 0;    				VirtualProtect(mdHdr' 4' 0x40' out old);  				*(uint*)mdHdr = 0;  				mdHdr += 12;  				mdHdr += *(uint*)mdHdr;  				mdHdr = (byte*)(((ulong)mdHdr + 7) & ~3UL);  				mdHdr += 2;  				ushort numOfStream = *mdHdr;  				mdHdr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdr' 8' 0x40' out old);  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdr' 4' 0x40' out old);  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 3;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 2;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 1;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  					}  				}  			}  			else //Flat  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				uint mdDir = *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;  				uint importDir = *(uint*)(ptr - 0x78);    				var vAdrs = new uint[sectNum];  				var vSizes = new uint[sectNum];  				var rAdrs = new uint[sectNum];  				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					vAdrs[i] = *(uint*)(ptr + 12);  					vSizes[i] = *(uint*)(ptr + 8);  					rAdrs[i] = *(uint*)(ptr + 20);  					ptr += 0x28;  				}      				if (importDir != 0) {  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= importDir && importDir < vAdrs[i] + vSizes[i]) {  							importDir = importDir - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* importDirPtr = bas + importDir;  					uint oftMod = *(uint*)importDirPtr;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= oftMod && oftMod < vAdrs[i] + vSizes[i]) {  							oftMod = oftMod - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* oftModPtr = bas + oftMod;  					uint modName = *(uint*)(importDirPtr + 12);  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= modName && modName < vAdrs[i] + vSizes[i]) {  							modName = modName - vAdrs[i] + rAdrs[i];  							break;  						}  					uint funcName = *(uint*)oftModPtr + 2;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= funcName && funcName < vAdrs[i] + vSizes[i]) {  							funcName = funcName - vAdrs[i] + rAdrs[i];  							break;  						}  					VirtualProtect(bas + modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + modName + i) = *(@new + i);    					VirtualProtect(bas + funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + funcName + i) = *(@new + i);  				}      				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdDir && mdDir < vAdrs[i] + vSizes[i]) {  						mdDir = mdDir - vAdrs[i] + rAdrs[i];  						break;  					}  				byte* mdDirPtr = bas + mdDir;  				VirtualProtect(mdDirPtr' 0x48' 0x40' out old);  				uint mdHdr = *(uint*)(mdDirPtr + 8);  				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdHdr && mdHdr < vAdrs[i] + vSizes[i]) {  						mdHdr = mdHdr - vAdrs[i] + rAdrs[i];  						break;  					}  				*(uint*)mdDirPtr = 0;  				*((uint*)mdDirPtr + 1) = 0;  				*((uint*)mdDirPtr + 2) = 0;  				*((uint*)mdDirPtr + 3) = 0;      				byte* mdHdrPtr = bas + mdHdr;  				VirtualProtect(mdHdrPtr' 4' 0x40' out old);  				*(uint*)mdHdrPtr = 0;  				mdHdrPtr += 12;  				mdHdrPtr += *(uint*)mdHdrPtr;  				mdHdrPtr = (byte*)(((ulong)mdHdrPtr + 7) & ~3UL);  				mdHdrPtr += 2;  				ushort numOfStream = *mdHdrPtr;  				mdHdrPtr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdrPtr' 8' 0x40' out old);  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdrPtr' 4' 0x40' out old);  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 3;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 2;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 1;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  					}  				}  			}
Magic Number,Confuser.Runtime,AntiDump,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiDump.cs,Initialize,The following statement contains a magic number: if (module.FullyQualifiedName[0] != '<') //Mapped  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				byte* mdDir = bas + *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;    				if (*(uint*)(ptr - 0x78) != 0) {  					byte* importDir = bas + *(uint*)(ptr - 0x78);  					byte* oftMod = bas + *(uint*)importDir;  					byte* modName = bas + *(uint*)(importDir + 12);  					byte* funcName = bas + *(uint*)oftMod + 2;  					VirtualProtect(modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(modName + i) = *(@new + i);    					VirtualProtect(funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(funcName + i) = *(@new + i);  				}    				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					ptr += 0x28;  				}  				VirtualProtect(mdDir' 0x48' 0x40' out old);  				byte* mdHdr = bas + *(uint*)(mdDir + 8);  				*(uint*)mdDir = 0;  				*((uint*)mdDir + 1) = 0;  				*((uint*)mdDir + 2) = 0;  				*((uint*)mdDir + 3) = 0;    				VirtualProtect(mdHdr' 4' 0x40' out old);  				*(uint*)mdHdr = 0;  				mdHdr += 12;  				mdHdr += *(uint*)mdHdr;  				mdHdr = (byte*)(((ulong)mdHdr + 7) & ~3UL);  				mdHdr += 2;  				ushort numOfStream = *mdHdr;  				mdHdr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdr' 8' 0x40' out old);  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdr' 4' 0x40' out old);  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 3;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 2;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 1;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  					}  				}  			}  			else //Flat  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				uint mdDir = *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;  				uint importDir = *(uint*)(ptr - 0x78);    				var vAdrs = new uint[sectNum];  				var vSizes = new uint[sectNum];  				var rAdrs = new uint[sectNum];  				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					vAdrs[i] = *(uint*)(ptr + 12);  					vSizes[i] = *(uint*)(ptr + 8);  					rAdrs[i] = *(uint*)(ptr + 20);  					ptr += 0x28;  				}      				if (importDir != 0) {  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= importDir && importDir < vAdrs[i] + vSizes[i]) {  							importDir = importDir - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* importDirPtr = bas + importDir;  					uint oftMod = *(uint*)importDirPtr;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= oftMod && oftMod < vAdrs[i] + vSizes[i]) {  							oftMod = oftMod - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* oftModPtr = bas + oftMod;  					uint modName = *(uint*)(importDirPtr + 12);  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= modName && modName < vAdrs[i] + vSizes[i]) {  							modName = modName - vAdrs[i] + rAdrs[i];  							break;  						}  					uint funcName = *(uint*)oftModPtr + 2;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= funcName && funcName < vAdrs[i] + vSizes[i]) {  							funcName = funcName - vAdrs[i] + rAdrs[i];  							break;  						}  					VirtualProtect(bas + modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + modName + i) = *(@new + i);    					VirtualProtect(bas + funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + funcName + i) = *(@new + i);  				}      				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdDir && mdDir < vAdrs[i] + vSizes[i]) {  						mdDir = mdDir - vAdrs[i] + rAdrs[i];  						break;  					}  				byte* mdDirPtr = bas + mdDir;  				VirtualProtect(mdDirPtr' 0x48' 0x40' out old);  				uint mdHdr = *(uint*)(mdDirPtr + 8);  				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdHdr && mdHdr < vAdrs[i] + vSizes[i]) {  						mdHdr = mdHdr - vAdrs[i] + rAdrs[i];  						break;  					}  				*(uint*)mdDirPtr = 0;  				*((uint*)mdDirPtr + 1) = 0;  				*((uint*)mdDirPtr + 2) = 0;  				*((uint*)mdDirPtr + 3) = 0;      				byte* mdHdrPtr = bas + mdHdr;  				VirtualProtect(mdHdrPtr' 4' 0x40' out old);  				*(uint*)mdHdrPtr = 0;  				mdHdrPtr += 12;  				mdHdrPtr += *(uint*)mdHdrPtr;  				mdHdrPtr = (byte*)(((ulong)mdHdrPtr + 7) & ~3UL);  				mdHdrPtr += 2;  				ushort numOfStream = *mdHdrPtr;  				mdHdrPtr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdrPtr' 8' 0x40' out old);  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdrPtr' 4' 0x40' out old);  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 3;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 2;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 1;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  					}  				}  			}
Magic Number,Confuser.Runtime,AntiDump,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiDump.cs,Initialize,The following statement contains a magic number: if (module.FullyQualifiedName[0] != '<') //Mapped  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				byte* mdDir = bas + *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;    				if (*(uint*)(ptr - 0x78) != 0) {  					byte* importDir = bas + *(uint*)(ptr - 0x78);  					byte* oftMod = bas + *(uint*)importDir;  					byte* modName = bas + *(uint*)(importDir + 12);  					byte* funcName = bas + *(uint*)oftMod + 2;  					VirtualProtect(modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(modName + i) = *(@new + i);    					VirtualProtect(funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(funcName + i) = *(@new + i);  				}    				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					ptr += 0x28;  				}  				VirtualProtect(mdDir' 0x48' 0x40' out old);  				byte* mdHdr = bas + *(uint*)(mdDir + 8);  				*(uint*)mdDir = 0;  				*((uint*)mdDir + 1) = 0;  				*((uint*)mdDir + 2) = 0;  				*((uint*)mdDir + 3) = 0;    				VirtualProtect(mdHdr' 4' 0x40' out old);  				*(uint*)mdHdr = 0;  				mdHdr += 12;  				mdHdr += *(uint*)mdHdr;  				mdHdr = (byte*)(((ulong)mdHdr + 7) & ~3UL);  				mdHdr += 2;  				ushort numOfStream = *mdHdr;  				mdHdr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdr' 8' 0x40' out old);  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdr' 4' 0x40' out old);  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 3;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 2;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 1;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  					}  				}  			}  			else //Flat  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				uint mdDir = *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;  				uint importDir = *(uint*)(ptr - 0x78);    				var vAdrs = new uint[sectNum];  				var vSizes = new uint[sectNum];  				var rAdrs = new uint[sectNum];  				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					vAdrs[i] = *(uint*)(ptr + 12);  					vSizes[i] = *(uint*)(ptr + 8);  					rAdrs[i] = *(uint*)(ptr + 20);  					ptr += 0x28;  				}      				if (importDir != 0) {  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= importDir && importDir < vAdrs[i] + vSizes[i]) {  							importDir = importDir - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* importDirPtr = bas + importDir;  					uint oftMod = *(uint*)importDirPtr;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= oftMod && oftMod < vAdrs[i] + vSizes[i]) {  							oftMod = oftMod - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* oftModPtr = bas + oftMod;  					uint modName = *(uint*)(importDirPtr + 12);  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= modName && modName < vAdrs[i] + vSizes[i]) {  							modName = modName - vAdrs[i] + rAdrs[i];  							break;  						}  					uint funcName = *(uint*)oftModPtr + 2;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= funcName && funcName < vAdrs[i] + vSizes[i]) {  							funcName = funcName - vAdrs[i] + rAdrs[i];  							break;  						}  					VirtualProtect(bas + modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + modName + i) = *(@new + i);    					VirtualProtect(bas + funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + funcName + i) = *(@new + i);  				}      				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdDir && mdDir < vAdrs[i] + vSizes[i]) {  						mdDir = mdDir - vAdrs[i] + rAdrs[i];  						break;  					}  				byte* mdDirPtr = bas + mdDir;  				VirtualProtect(mdDirPtr' 0x48' 0x40' out old);  				uint mdHdr = *(uint*)(mdDirPtr + 8);  				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdHdr && mdHdr < vAdrs[i] + vSizes[i]) {  						mdHdr = mdHdr - vAdrs[i] + rAdrs[i];  						break;  					}  				*(uint*)mdDirPtr = 0;  				*((uint*)mdDirPtr + 1) = 0;  				*((uint*)mdDirPtr + 2) = 0;  				*((uint*)mdDirPtr + 3) = 0;      				byte* mdHdrPtr = bas + mdHdr;  				VirtualProtect(mdHdrPtr' 4' 0x40' out old);  				*(uint*)mdHdrPtr = 0;  				mdHdrPtr += 12;  				mdHdrPtr += *(uint*)mdHdrPtr;  				mdHdrPtr = (byte*)(((ulong)mdHdrPtr + 7) & ~3UL);  				mdHdrPtr += 2;  				ushort numOfStream = *mdHdrPtr;  				mdHdrPtr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdrPtr' 8' 0x40' out old);  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdrPtr' 4' 0x40' out old);  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 3;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 2;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 1;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  					}  				}  			}
Magic Number,Confuser.Runtime,AntiDump,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiDump.cs,Initialize,The following statement contains a magic number: if (module.FullyQualifiedName[0] != '<') //Mapped  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				byte* mdDir = bas + *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;    				if (*(uint*)(ptr - 0x78) != 0) {  					byte* importDir = bas + *(uint*)(ptr - 0x78);  					byte* oftMod = bas + *(uint*)importDir;  					byte* modName = bas + *(uint*)(importDir + 12);  					byte* funcName = bas + *(uint*)oftMod + 2;  					VirtualProtect(modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(modName + i) = *(@new + i);    					VirtualProtect(funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(funcName + i) = *(@new + i);  				}    				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					ptr += 0x28;  				}  				VirtualProtect(mdDir' 0x48' 0x40' out old);  				byte* mdHdr = bas + *(uint*)(mdDir + 8);  				*(uint*)mdDir = 0;  				*((uint*)mdDir + 1) = 0;  				*((uint*)mdDir + 2) = 0;  				*((uint*)mdDir + 3) = 0;    				VirtualProtect(mdHdr' 4' 0x40' out old);  				*(uint*)mdHdr = 0;  				mdHdr += 12;  				mdHdr += *(uint*)mdHdr;  				mdHdr = (byte*)(((ulong)mdHdr + 7) & ~3UL);  				mdHdr += 2;  				ushort numOfStream = *mdHdr;  				mdHdr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdr' 8' 0x40' out old);  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdr' 4' 0x40' out old);  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 3;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 2;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 1;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  					}  				}  			}  			else //Flat  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				uint mdDir = *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;  				uint importDir = *(uint*)(ptr - 0x78);    				var vAdrs = new uint[sectNum];  				var vSizes = new uint[sectNum];  				var rAdrs = new uint[sectNum];  				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					vAdrs[i] = *(uint*)(ptr + 12);  					vSizes[i] = *(uint*)(ptr + 8);  					rAdrs[i] = *(uint*)(ptr + 20);  					ptr += 0x28;  				}      				if (importDir != 0) {  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= importDir && importDir < vAdrs[i] + vSizes[i]) {  							importDir = importDir - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* importDirPtr = bas + importDir;  					uint oftMod = *(uint*)importDirPtr;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= oftMod && oftMod < vAdrs[i] + vSizes[i]) {  							oftMod = oftMod - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* oftModPtr = bas + oftMod;  					uint modName = *(uint*)(importDirPtr + 12);  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= modName && modName < vAdrs[i] + vSizes[i]) {  							modName = modName - vAdrs[i] + rAdrs[i];  							break;  						}  					uint funcName = *(uint*)oftModPtr + 2;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= funcName && funcName < vAdrs[i] + vSizes[i]) {  							funcName = funcName - vAdrs[i] + rAdrs[i];  							break;  						}  					VirtualProtect(bas + modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + modName + i) = *(@new + i);    					VirtualProtect(bas + funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + funcName + i) = *(@new + i);  				}      				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdDir && mdDir < vAdrs[i] + vSizes[i]) {  						mdDir = mdDir - vAdrs[i] + rAdrs[i];  						break;  					}  				byte* mdDirPtr = bas + mdDir;  				VirtualProtect(mdDirPtr' 0x48' 0x40' out old);  				uint mdHdr = *(uint*)(mdDirPtr + 8);  				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdHdr && mdHdr < vAdrs[i] + vSizes[i]) {  						mdHdr = mdHdr - vAdrs[i] + rAdrs[i];  						break;  					}  				*(uint*)mdDirPtr = 0;  				*((uint*)mdDirPtr + 1) = 0;  				*((uint*)mdDirPtr + 2) = 0;  				*((uint*)mdDirPtr + 3) = 0;      				byte* mdHdrPtr = bas + mdHdr;  				VirtualProtect(mdHdrPtr' 4' 0x40' out old);  				*(uint*)mdHdrPtr = 0;  				mdHdrPtr += 12;  				mdHdrPtr += *(uint*)mdHdrPtr;  				mdHdrPtr = (byte*)(((ulong)mdHdrPtr + 7) & ~3UL);  				mdHdrPtr += 2;  				ushort numOfStream = *mdHdrPtr;  				mdHdrPtr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdrPtr' 8' 0x40' out old);  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdrPtr' 4' 0x40' out old);  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 3;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 2;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 1;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  					}  				}  			}
Magic Number,Confuser.Runtime,AntiDump,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiDump.cs,Initialize,The following statement contains a magic number: if (module.FullyQualifiedName[0] != '<') //Mapped  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				byte* mdDir = bas + *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;    				if (*(uint*)(ptr - 0x78) != 0) {  					byte* importDir = bas + *(uint*)(ptr - 0x78);  					byte* oftMod = bas + *(uint*)importDir;  					byte* modName = bas + *(uint*)(importDir + 12);  					byte* funcName = bas + *(uint*)oftMod + 2;  					VirtualProtect(modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(modName + i) = *(@new + i);    					VirtualProtect(funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(funcName + i) = *(@new + i);  				}    				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					ptr += 0x28;  				}  				VirtualProtect(mdDir' 0x48' 0x40' out old);  				byte* mdHdr = bas + *(uint*)(mdDir + 8);  				*(uint*)mdDir = 0;  				*((uint*)mdDir + 1) = 0;  				*((uint*)mdDir + 2) = 0;  				*((uint*)mdDir + 3) = 0;    				VirtualProtect(mdHdr' 4' 0x40' out old);  				*(uint*)mdHdr = 0;  				mdHdr += 12;  				mdHdr += *(uint*)mdHdr;  				mdHdr = (byte*)(((ulong)mdHdr + 7) & ~3UL);  				mdHdr += 2;  				ushort numOfStream = *mdHdr;  				mdHdr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdr' 8' 0x40' out old);  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdr' 4' 0x40' out old);  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 3;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 2;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 1;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  					}  				}  			}  			else //Flat  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				uint mdDir = *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;  				uint importDir = *(uint*)(ptr - 0x78);    				var vAdrs = new uint[sectNum];  				var vSizes = new uint[sectNum];  				var rAdrs = new uint[sectNum];  				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					vAdrs[i] = *(uint*)(ptr + 12);  					vSizes[i] = *(uint*)(ptr + 8);  					rAdrs[i] = *(uint*)(ptr + 20);  					ptr += 0x28;  				}      				if (importDir != 0) {  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= importDir && importDir < vAdrs[i] + vSizes[i]) {  							importDir = importDir - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* importDirPtr = bas + importDir;  					uint oftMod = *(uint*)importDirPtr;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= oftMod && oftMod < vAdrs[i] + vSizes[i]) {  							oftMod = oftMod - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* oftModPtr = bas + oftMod;  					uint modName = *(uint*)(importDirPtr + 12);  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= modName && modName < vAdrs[i] + vSizes[i]) {  							modName = modName - vAdrs[i] + rAdrs[i];  							break;  						}  					uint funcName = *(uint*)oftModPtr + 2;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= funcName && funcName < vAdrs[i] + vSizes[i]) {  							funcName = funcName - vAdrs[i] + rAdrs[i];  							break;  						}  					VirtualProtect(bas + modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + modName + i) = *(@new + i);    					VirtualProtect(bas + funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + funcName + i) = *(@new + i);  				}      				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdDir && mdDir < vAdrs[i] + vSizes[i]) {  						mdDir = mdDir - vAdrs[i] + rAdrs[i];  						break;  					}  				byte* mdDirPtr = bas + mdDir;  				VirtualProtect(mdDirPtr' 0x48' 0x40' out old);  				uint mdHdr = *(uint*)(mdDirPtr + 8);  				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdHdr && mdHdr < vAdrs[i] + vSizes[i]) {  						mdHdr = mdHdr - vAdrs[i] + rAdrs[i];  						break;  					}  				*(uint*)mdDirPtr = 0;  				*((uint*)mdDirPtr + 1) = 0;  				*((uint*)mdDirPtr + 2) = 0;  				*((uint*)mdDirPtr + 3) = 0;      				byte* mdHdrPtr = bas + mdHdr;  				VirtualProtect(mdHdrPtr' 4' 0x40' out old);  				*(uint*)mdHdrPtr = 0;  				mdHdrPtr += 12;  				mdHdrPtr += *(uint*)mdHdrPtr;  				mdHdrPtr = (byte*)(((ulong)mdHdrPtr + 7) & ~3UL);  				mdHdrPtr += 2;  				ushort numOfStream = *mdHdrPtr;  				mdHdrPtr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdrPtr' 8' 0x40' out old);  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdrPtr' 4' 0x40' out old);  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 3;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 2;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 1;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  					}  				}  			}
Magic Number,Confuser.Runtime,AntiDump,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiDump.cs,Initialize,The following statement contains a magic number: if (module.FullyQualifiedName[0] != '<') //Mapped  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				byte* mdDir = bas + *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;    				if (*(uint*)(ptr - 0x78) != 0) {  					byte* importDir = bas + *(uint*)(ptr - 0x78);  					byte* oftMod = bas + *(uint*)importDir;  					byte* modName = bas + *(uint*)(importDir + 12);  					byte* funcName = bas + *(uint*)oftMod + 2;  					VirtualProtect(modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(modName + i) = *(@new + i);    					VirtualProtect(funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(funcName + i) = *(@new + i);  				}    				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					ptr += 0x28;  				}  				VirtualProtect(mdDir' 0x48' 0x40' out old);  				byte* mdHdr = bas + *(uint*)(mdDir + 8);  				*(uint*)mdDir = 0;  				*((uint*)mdDir + 1) = 0;  				*((uint*)mdDir + 2) = 0;  				*((uint*)mdDir + 3) = 0;    				VirtualProtect(mdHdr' 4' 0x40' out old);  				*(uint*)mdHdr = 0;  				mdHdr += 12;  				mdHdr += *(uint*)mdHdr;  				mdHdr = (byte*)(((ulong)mdHdr + 7) & ~3UL);  				mdHdr += 2;  				ushort numOfStream = *mdHdr;  				mdHdr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdr' 8' 0x40' out old);  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdr' 4' 0x40' out old);  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 3;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 2;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 1;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  					}  				}  			}  			else //Flat  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				uint mdDir = *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;  				uint importDir = *(uint*)(ptr - 0x78);    				var vAdrs = new uint[sectNum];  				var vSizes = new uint[sectNum];  				var rAdrs = new uint[sectNum];  				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					vAdrs[i] = *(uint*)(ptr + 12);  					vSizes[i] = *(uint*)(ptr + 8);  					rAdrs[i] = *(uint*)(ptr + 20);  					ptr += 0x28;  				}      				if (importDir != 0) {  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= importDir && importDir < vAdrs[i] + vSizes[i]) {  							importDir = importDir - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* importDirPtr = bas + importDir;  					uint oftMod = *(uint*)importDirPtr;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= oftMod && oftMod < vAdrs[i] + vSizes[i]) {  							oftMod = oftMod - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* oftModPtr = bas + oftMod;  					uint modName = *(uint*)(importDirPtr + 12);  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= modName && modName < vAdrs[i] + vSizes[i]) {  							modName = modName - vAdrs[i] + rAdrs[i];  							break;  						}  					uint funcName = *(uint*)oftModPtr + 2;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= funcName && funcName < vAdrs[i] + vSizes[i]) {  							funcName = funcName - vAdrs[i] + rAdrs[i];  							break;  						}  					VirtualProtect(bas + modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + modName + i) = *(@new + i);    					VirtualProtect(bas + funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + funcName + i) = *(@new + i);  				}      				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdDir && mdDir < vAdrs[i] + vSizes[i]) {  						mdDir = mdDir - vAdrs[i] + rAdrs[i];  						break;  					}  				byte* mdDirPtr = bas + mdDir;  				VirtualProtect(mdDirPtr' 0x48' 0x40' out old);  				uint mdHdr = *(uint*)(mdDirPtr + 8);  				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdHdr && mdHdr < vAdrs[i] + vSizes[i]) {  						mdHdr = mdHdr - vAdrs[i] + rAdrs[i];  						break;  					}  				*(uint*)mdDirPtr = 0;  				*((uint*)mdDirPtr + 1) = 0;  				*((uint*)mdDirPtr + 2) = 0;  				*((uint*)mdDirPtr + 3) = 0;      				byte* mdHdrPtr = bas + mdHdr;  				VirtualProtect(mdHdrPtr' 4' 0x40' out old);  				*(uint*)mdHdrPtr = 0;  				mdHdrPtr += 12;  				mdHdrPtr += *(uint*)mdHdrPtr;  				mdHdrPtr = (byte*)(((ulong)mdHdrPtr + 7) & ~3UL);  				mdHdrPtr += 2;  				ushort numOfStream = *mdHdrPtr;  				mdHdrPtr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdrPtr' 8' 0x40' out old);  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdrPtr' 4' 0x40' out old);  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 3;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 2;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 1;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  					}  				}  			}
Magic Number,Confuser.Runtime,AntiDump,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiDump.cs,Initialize,The following statement contains a magic number: if (module.FullyQualifiedName[0] != '<') //Mapped  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				byte* mdDir = bas + *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;    				if (*(uint*)(ptr - 0x78) != 0) {  					byte* importDir = bas + *(uint*)(ptr - 0x78);  					byte* oftMod = bas + *(uint*)importDir;  					byte* modName = bas + *(uint*)(importDir + 12);  					byte* funcName = bas + *(uint*)oftMod + 2;  					VirtualProtect(modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(modName + i) = *(@new + i);    					VirtualProtect(funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(funcName + i) = *(@new + i);  				}    				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					ptr += 0x28;  				}  				VirtualProtect(mdDir' 0x48' 0x40' out old);  				byte* mdHdr = bas + *(uint*)(mdDir + 8);  				*(uint*)mdDir = 0;  				*((uint*)mdDir + 1) = 0;  				*((uint*)mdDir + 2) = 0;  				*((uint*)mdDir + 3) = 0;    				VirtualProtect(mdHdr' 4' 0x40' out old);  				*(uint*)mdHdr = 0;  				mdHdr += 12;  				mdHdr += *(uint*)mdHdr;  				mdHdr = (byte*)(((ulong)mdHdr + 7) & ~3UL);  				mdHdr += 2;  				ushort numOfStream = *mdHdr;  				mdHdr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdr' 8' 0x40' out old);  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdr' 4' 0x40' out old);  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 3;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 2;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 1;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  					}  				}  			}  			else //Flat  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				uint mdDir = *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;  				uint importDir = *(uint*)(ptr - 0x78);    				var vAdrs = new uint[sectNum];  				var vSizes = new uint[sectNum];  				var rAdrs = new uint[sectNum];  				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					vAdrs[i] = *(uint*)(ptr + 12);  					vSizes[i] = *(uint*)(ptr + 8);  					rAdrs[i] = *(uint*)(ptr + 20);  					ptr += 0x28;  				}      				if (importDir != 0) {  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= importDir && importDir < vAdrs[i] + vSizes[i]) {  							importDir = importDir - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* importDirPtr = bas + importDir;  					uint oftMod = *(uint*)importDirPtr;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= oftMod && oftMod < vAdrs[i] + vSizes[i]) {  							oftMod = oftMod - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* oftModPtr = bas + oftMod;  					uint modName = *(uint*)(importDirPtr + 12);  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= modName && modName < vAdrs[i] + vSizes[i]) {  							modName = modName - vAdrs[i] + rAdrs[i];  							break;  						}  					uint funcName = *(uint*)oftModPtr + 2;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= funcName && funcName < vAdrs[i] + vSizes[i]) {  							funcName = funcName - vAdrs[i] + rAdrs[i];  							break;  						}  					VirtualProtect(bas + modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + modName + i) = *(@new + i);    					VirtualProtect(bas + funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + funcName + i) = *(@new + i);  				}      				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdDir && mdDir < vAdrs[i] + vSizes[i]) {  						mdDir = mdDir - vAdrs[i] + rAdrs[i];  						break;  					}  				byte* mdDirPtr = bas + mdDir;  				VirtualProtect(mdDirPtr' 0x48' 0x40' out old);  				uint mdHdr = *(uint*)(mdDirPtr + 8);  				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdHdr && mdHdr < vAdrs[i] + vSizes[i]) {  						mdHdr = mdHdr - vAdrs[i] + rAdrs[i];  						break;  					}  				*(uint*)mdDirPtr = 0;  				*((uint*)mdDirPtr + 1) = 0;  				*((uint*)mdDirPtr + 2) = 0;  				*((uint*)mdDirPtr + 3) = 0;      				byte* mdHdrPtr = bas + mdHdr;  				VirtualProtect(mdHdrPtr' 4' 0x40' out old);  				*(uint*)mdHdrPtr = 0;  				mdHdrPtr += 12;  				mdHdrPtr += *(uint*)mdHdrPtr;  				mdHdrPtr = (byte*)(((ulong)mdHdrPtr + 7) & ~3UL);  				mdHdrPtr += 2;  				ushort numOfStream = *mdHdrPtr;  				mdHdrPtr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdrPtr' 8' 0x40' out old);  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdrPtr' 4' 0x40' out old);  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 3;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 2;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 1;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  					}  				}  			}
Magic Number,Confuser.Runtime,AntiDump,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiDump.cs,Initialize,The following statement contains a magic number: if (module.FullyQualifiedName[0] != '<') //Mapped  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				byte* mdDir = bas + *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;    				if (*(uint*)(ptr - 0x78) != 0) {  					byte* importDir = bas + *(uint*)(ptr - 0x78);  					byte* oftMod = bas + *(uint*)importDir;  					byte* modName = bas + *(uint*)(importDir + 12);  					byte* funcName = bas + *(uint*)oftMod + 2;  					VirtualProtect(modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(modName + i) = *(@new + i);    					VirtualProtect(funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(funcName + i) = *(@new + i);  				}    				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					ptr += 0x28;  				}  				VirtualProtect(mdDir' 0x48' 0x40' out old);  				byte* mdHdr = bas + *(uint*)(mdDir + 8);  				*(uint*)mdDir = 0;  				*((uint*)mdDir + 1) = 0;  				*((uint*)mdDir + 2) = 0;  				*((uint*)mdDir + 3) = 0;    				VirtualProtect(mdHdr' 4' 0x40' out old);  				*(uint*)mdHdr = 0;  				mdHdr += 12;  				mdHdr += *(uint*)mdHdr;  				mdHdr = (byte*)(((ulong)mdHdr + 7) & ~3UL);  				mdHdr += 2;  				ushort numOfStream = *mdHdr;  				mdHdr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdr' 8' 0x40' out old);  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdr' 4' 0x40' out old);  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 3;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 2;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 1;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  					}  				}  			}  			else //Flat  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				uint mdDir = *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;  				uint importDir = *(uint*)(ptr - 0x78);    				var vAdrs = new uint[sectNum];  				var vSizes = new uint[sectNum];  				var rAdrs = new uint[sectNum];  				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					vAdrs[i] = *(uint*)(ptr + 12);  					vSizes[i] = *(uint*)(ptr + 8);  					rAdrs[i] = *(uint*)(ptr + 20);  					ptr += 0x28;  				}      				if (importDir != 0) {  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= importDir && importDir < vAdrs[i] + vSizes[i]) {  							importDir = importDir - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* importDirPtr = bas + importDir;  					uint oftMod = *(uint*)importDirPtr;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= oftMod && oftMod < vAdrs[i] + vSizes[i]) {  							oftMod = oftMod - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* oftModPtr = bas + oftMod;  					uint modName = *(uint*)(importDirPtr + 12);  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= modName && modName < vAdrs[i] + vSizes[i]) {  							modName = modName - vAdrs[i] + rAdrs[i];  							break;  						}  					uint funcName = *(uint*)oftModPtr + 2;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= funcName && funcName < vAdrs[i] + vSizes[i]) {  							funcName = funcName - vAdrs[i] + rAdrs[i];  							break;  						}  					VirtualProtect(bas + modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + modName + i) = *(@new + i);    					VirtualProtect(bas + funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + funcName + i) = *(@new + i);  				}      				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdDir && mdDir < vAdrs[i] + vSizes[i]) {  						mdDir = mdDir - vAdrs[i] + rAdrs[i];  						break;  					}  				byte* mdDirPtr = bas + mdDir;  				VirtualProtect(mdDirPtr' 0x48' 0x40' out old);  				uint mdHdr = *(uint*)(mdDirPtr + 8);  				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdHdr && mdHdr < vAdrs[i] + vSizes[i]) {  						mdHdr = mdHdr - vAdrs[i] + rAdrs[i];  						break;  					}  				*(uint*)mdDirPtr = 0;  				*((uint*)mdDirPtr + 1) = 0;  				*((uint*)mdDirPtr + 2) = 0;  				*((uint*)mdDirPtr + 3) = 0;      				byte* mdHdrPtr = bas + mdHdr;  				VirtualProtect(mdHdrPtr' 4' 0x40' out old);  				*(uint*)mdHdrPtr = 0;  				mdHdrPtr += 12;  				mdHdrPtr += *(uint*)mdHdrPtr;  				mdHdrPtr = (byte*)(((ulong)mdHdrPtr + 7) & ~3UL);  				mdHdrPtr += 2;  				ushort numOfStream = *mdHdrPtr;  				mdHdrPtr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdrPtr' 8' 0x40' out old);  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdrPtr' 4' 0x40' out old);  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 3;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 2;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 1;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  					}  				}  			}
Magic Number,Confuser.Runtime,AntiDump,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiDump.cs,Initialize,The following statement contains a magic number: if (module.FullyQualifiedName[0] != '<') //Mapped  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				byte* mdDir = bas + *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;    				if (*(uint*)(ptr - 0x78) != 0) {  					byte* importDir = bas + *(uint*)(ptr - 0x78);  					byte* oftMod = bas + *(uint*)importDir;  					byte* modName = bas + *(uint*)(importDir + 12);  					byte* funcName = bas + *(uint*)oftMod + 2;  					VirtualProtect(modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(modName + i) = *(@new + i);    					VirtualProtect(funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(funcName + i) = *(@new + i);  				}    				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					ptr += 0x28;  				}  				VirtualProtect(mdDir' 0x48' 0x40' out old);  				byte* mdHdr = bas + *(uint*)(mdDir + 8);  				*(uint*)mdDir = 0;  				*((uint*)mdDir + 1) = 0;  				*((uint*)mdDir + 2) = 0;  				*((uint*)mdDir + 3) = 0;    				VirtualProtect(mdHdr' 4' 0x40' out old);  				*(uint*)mdHdr = 0;  				mdHdr += 12;  				mdHdr += *(uint*)mdHdr;  				mdHdr = (byte*)(((ulong)mdHdr + 7) & ~3UL);  				mdHdr += 2;  				ushort numOfStream = *mdHdr;  				mdHdr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdr' 8' 0x40' out old);  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdr' 4' 0x40' out old);  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 3;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 2;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 1;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  					}  				}  			}  			else //Flat  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				uint mdDir = *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;  				uint importDir = *(uint*)(ptr - 0x78);    				var vAdrs = new uint[sectNum];  				var vSizes = new uint[sectNum];  				var rAdrs = new uint[sectNum];  				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					vAdrs[i] = *(uint*)(ptr + 12);  					vSizes[i] = *(uint*)(ptr + 8);  					rAdrs[i] = *(uint*)(ptr + 20);  					ptr += 0x28;  				}      				if (importDir != 0) {  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= importDir && importDir < vAdrs[i] + vSizes[i]) {  							importDir = importDir - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* importDirPtr = bas + importDir;  					uint oftMod = *(uint*)importDirPtr;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= oftMod && oftMod < vAdrs[i] + vSizes[i]) {  							oftMod = oftMod - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* oftModPtr = bas + oftMod;  					uint modName = *(uint*)(importDirPtr + 12);  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= modName && modName < vAdrs[i] + vSizes[i]) {  							modName = modName - vAdrs[i] + rAdrs[i];  							break;  						}  					uint funcName = *(uint*)oftModPtr + 2;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= funcName && funcName < vAdrs[i] + vSizes[i]) {  							funcName = funcName - vAdrs[i] + rAdrs[i];  							break;  						}  					VirtualProtect(bas + modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + modName + i) = *(@new + i);    					VirtualProtect(bas + funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + funcName + i) = *(@new + i);  				}      				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdDir && mdDir < vAdrs[i] + vSizes[i]) {  						mdDir = mdDir - vAdrs[i] + rAdrs[i];  						break;  					}  				byte* mdDirPtr = bas + mdDir;  				VirtualProtect(mdDirPtr' 0x48' 0x40' out old);  				uint mdHdr = *(uint*)(mdDirPtr + 8);  				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdHdr && mdHdr < vAdrs[i] + vSizes[i]) {  						mdHdr = mdHdr - vAdrs[i] + rAdrs[i];  						break;  					}  				*(uint*)mdDirPtr = 0;  				*((uint*)mdDirPtr + 1) = 0;  				*((uint*)mdDirPtr + 2) = 0;  				*((uint*)mdDirPtr + 3) = 0;      				byte* mdHdrPtr = bas + mdHdr;  				VirtualProtect(mdHdrPtr' 4' 0x40' out old);  				*(uint*)mdHdrPtr = 0;  				mdHdrPtr += 12;  				mdHdrPtr += *(uint*)mdHdrPtr;  				mdHdrPtr = (byte*)(((ulong)mdHdrPtr + 7) & ~3UL);  				mdHdrPtr += 2;  				ushort numOfStream = *mdHdrPtr;  				mdHdrPtr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdrPtr' 8' 0x40' out old);  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdrPtr' 4' 0x40' out old);  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 3;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 2;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 1;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  					}  				}  			}
Magic Number,Confuser.Runtime,AntiDump,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiDump.cs,Initialize,The following statement contains a magic number: if (module.FullyQualifiedName[0] != '<') //Mapped  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				byte* mdDir = bas + *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;    				if (*(uint*)(ptr - 0x78) != 0) {  					byte* importDir = bas + *(uint*)(ptr - 0x78);  					byte* oftMod = bas + *(uint*)importDir;  					byte* modName = bas + *(uint*)(importDir + 12);  					byte* funcName = bas + *(uint*)oftMod + 2;  					VirtualProtect(modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(modName + i) = *(@new + i);    					VirtualProtect(funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(funcName + i) = *(@new + i);  				}    				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					ptr += 0x28;  				}  				VirtualProtect(mdDir' 0x48' 0x40' out old);  				byte* mdHdr = bas + *(uint*)(mdDir + 8);  				*(uint*)mdDir = 0;  				*((uint*)mdDir + 1) = 0;  				*((uint*)mdDir + 2) = 0;  				*((uint*)mdDir + 3) = 0;    				VirtualProtect(mdHdr' 4' 0x40' out old);  				*(uint*)mdHdr = 0;  				mdHdr += 12;  				mdHdr += *(uint*)mdHdr;  				mdHdr = (byte*)(((ulong)mdHdr + 7) & ~3UL);  				mdHdr += 2;  				ushort numOfStream = *mdHdr;  				mdHdr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdr' 8' 0x40' out old);  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdr' 4' 0x40' out old);  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 3;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 2;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 1;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  					}  				}  			}  			else //Flat  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				uint mdDir = *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;  				uint importDir = *(uint*)(ptr - 0x78);    				var vAdrs = new uint[sectNum];  				var vSizes = new uint[sectNum];  				var rAdrs = new uint[sectNum];  				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					vAdrs[i] = *(uint*)(ptr + 12);  					vSizes[i] = *(uint*)(ptr + 8);  					rAdrs[i] = *(uint*)(ptr + 20);  					ptr += 0x28;  				}      				if (importDir != 0) {  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= importDir && importDir < vAdrs[i] + vSizes[i]) {  							importDir = importDir - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* importDirPtr = bas + importDir;  					uint oftMod = *(uint*)importDirPtr;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= oftMod && oftMod < vAdrs[i] + vSizes[i]) {  							oftMod = oftMod - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* oftModPtr = bas + oftMod;  					uint modName = *(uint*)(importDirPtr + 12);  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= modName && modName < vAdrs[i] + vSizes[i]) {  							modName = modName - vAdrs[i] + rAdrs[i];  							break;  						}  					uint funcName = *(uint*)oftModPtr + 2;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= funcName && funcName < vAdrs[i] + vSizes[i]) {  							funcName = funcName - vAdrs[i] + rAdrs[i];  							break;  						}  					VirtualProtect(bas + modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + modName + i) = *(@new + i);    					VirtualProtect(bas + funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + funcName + i) = *(@new + i);  				}      				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdDir && mdDir < vAdrs[i] + vSizes[i]) {  						mdDir = mdDir - vAdrs[i] + rAdrs[i];  						break;  					}  				byte* mdDirPtr = bas + mdDir;  				VirtualProtect(mdDirPtr' 0x48' 0x40' out old);  				uint mdHdr = *(uint*)(mdDirPtr + 8);  				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdHdr && mdHdr < vAdrs[i] + vSizes[i]) {  						mdHdr = mdHdr - vAdrs[i] + rAdrs[i];  						break;  					}  				*(uint*)mdDirPtr = 0;  				*((uint*)mdDirPtr + 1) = 0;  				*((uint*)mdDirPtr + 2) = 0;  				*((uint*)mdDirPtr + 3) = 0;      				byte* mdHdrPtr = bas + mdHdr;  				VirtualProtect(mdHdrPtr' 4' 0x40' out old);  				*(uint*)mdHdrPtr = 0;  				mdHdrPtr += 12;  				mdHdrPtr += *(uint*)mdHdrPtr;  				mdHdrPtr = (byte*)(((ulong)mdHdrPtr + 7) & ~3UL);  				mdHdrPtr += 2;  				ushort numOfStream = *mdHdrPtr;  				mdHdrPtr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdrPtr' 8' 0x40' out old);  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdrPtr' 4' 0x40' out old);  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 3;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 2;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 1;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  					}  				}  			}
Magic Number,Confuser.Runtime,AntiDump,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiDump.cs,Initialize,The following statement contains a magic number: if (module.FullyQualifiedName[0] != '<') //Mapped  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				byte* mdDir = bas + *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;    				if (*(uint*)(ptr - 0x78) != 0) {  					byte* importDir = bas + *(uint*)(ptr - 0x78);  					byte* oftMod = bas + *(uint*)importDir;  					byte* modName = bas + *(uint*)(importDir + 12);  					byte* funcName = bas + *(uint*)oftMod + 2;  					VirtualProtect(modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(modName + i) = *(@new + i);    					VirtualProtect(funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(funcName + i) = *(@new + i);  				}    				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					ptr += 0x28;  				}  				VirtualProtect(mdDir' 0x48' 0x40' out old);  				byte* mdHdr = bas + *(uint*)(mdDir + 8);  				*(uint*)mdDir = 0;  				*((uint*)mdDir + 1) = 0;  				*((uint*)mdDir + 2) = 0;  				*((uint*)mdDir + 3) = 0;    				VirtualProtect(mdHdr' 4' 0x40' out old);  				*(uint*)mdHdr = 0;  				mdHdr += 12;  				mdHdr += *(uint*)mdHdr;  				mdHdr = (byte*)(((ulong)mdHdr + 7) & ~3UL);  				mdHdr += 2;  				ushort numOfStream = *mdHdr;  				mdHdr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdr' 8' 0x40' out old);  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdr' 4' 0x40' out old);  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 3;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 2;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 1;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  					}  				}  			}  			else //Flat  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				uint mdDir = *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;  				uint importDir = *(uint*)(ptr - 0x78);    				var vAdrs = new uint[sectNum];  				var vSizes = new uint[sectNum];  				var rAdrs = new uint[sectNum];  				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					vAdrs[i] = *(uint*)(ptr + 12);  					vSizes[i] = *(uint*)(ptr + 8);  					rAdrs[i] = *(uint*)(ptr + 20);  					ptr += 0x28;  				}      				if (importDir != 0) {  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= importDir && importDir < vAdrs[i] + vSizes[i]) {  							importDir = importDir - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* importDirPtr = bas + importDir;  					uint oftMod = *(uint*)importDirPtr;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= oftMod && oftMod < vAdrs[i] + vSizes[i]) {  							oftMod = oftMod - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* oftModPtr = bas + oftMod;  					uint modName = *(uint*)(importDirPtr + 12);  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= modName && modName < vAdrs[i] + vSizes[i]) {  							modName = modName - vAdrs[i] + rAdrs[i];  							break;  						}  					uint funcName = *(uint*)oftModPtr + 2;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= funcName && funcName < vAdrs[i] + vSizes[i]) {  							funcName = funcName - vAdrs[i] + rAdrs[i];  							break;  						}  					VirtualProtect(bas + modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + modName + i) = *(@new + i);    					VirtualProtect(bas + funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + funcName + i) = *(@new + i);  				}      				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdDir && mdDir < vAdrs[i] + vSizes[i]) {  						mdDir = mdDir - vAdrs[i] + rAdrs[i];  						break;  					}  				byte* mdDirPtr = bas + mdDir;  				VirtualProtect(mdDirPtr' 0x48' 0x40' out old);  				uint mdHdr = *(uint*)(mdDirPtr + 8);  				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdHdr && mdHdr < vAdrs[i] + vSizes[i]) {  						mdHdr = mdHdr - vAdrs[i] + rAdrs[i];  						break;  					}  				*(uint*)mdDirPtr = 0;  				*((uint*)mdDirPtr + 1) = 0;  				*((uint*)mdDirPtr + 2) = 0;  				*((uint*)mdDirPtr + 3) = 0;      				byte* mdHdrPtr = bas + mdHdr;  				VirtualProtect(mdHdrPtr' 4' 0x40' out old);  				*(uint*)mdHdrPtr = 0;  				mdHdrPtr += 12;  				mdHdrPtr += *(uint*)mdHdrPtr;  				mdHdrPtr = (byte*)(((ulong)mdHdrPtr + 7) & ~3UL);  				mdHdrPtr += 2;  				ushort numOfStream = *mdHdrPtr;  				mdHdrPtr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdrPtr' 8' 0x40' out old);  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdrPtr' 4' 0x40' out old);  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 3;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 2;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 1;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  					}  				}  			}
Magic Number,Confuser.Runtime,AntiDump,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiDump.cs,Initialize,The following statement contains a magic number: if (module.FullyQualifiedName[0] != '<') //Mapped  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				byte* mdDir = bas + *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;    				if (*(uint*)(ptr - 0x78) != 0) {  					byte* importDir = bas + *(uint*)(ptr - 0x78);  					byte* oftMod = bas + *(uint*)importDir;  					byte* modName = bas + *(uint*)(importDir + 12);  					byte* funcName = bas + *(uint*)oftMod + 2;  					VirtualProtect(modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(modName + i) = *(@new + i);    					VirtualProtect(funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(funcName + i) = *(@new + i);  				}    				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					ptr += 0x28;  				}  				VirtualProtect(mdDir' 0x48' 0x40' out old);  				byte* mdHdr = bas + *(uint*)(mdDir + 8);  				*(uint*)mdDir = 0;  				*((uint*)mdDir + 1) = 0;  				*((uint*)mdDir + 2) = 0;  				*((uint*)mdDir + 3) = 0;    				VirtualProtect(mdHdr' 4' 0x40' out old);  				*(uint*)mdHdr = 0;  				mdHdr += 12;  				mdHdr += *(uint*)mdHdr;  				mdHdr = (byte*)(((ulong)mdHdr + 7) & ~3UL);  				mdHdr += 2;  				ushort numOfStream = *mdHdr;  				mdHdr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdr' 8' 0x40' out old);  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdr' 4' 0x40' out old);  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 3;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 2;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 1;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  					}  				}  			}  			else //Flat  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				uint mdDir = *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;  				uint importDir = *(uint*)(ptr - 0x78);    				var vAdrs = new uint[sectNum];  				var vSizes = new uint[sectNum];  				var rAdrs = new uint[sectNum];  				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					vAdrs[i] = *(uint*)(ptr + 12);  					vSizes[i] = *(uint*)(ptr + 8);  					rAdrs[i] = *(uint*)(ptr + 20);  					ptr += 0x28;  				}      				if (importDir != 0) {  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= importDir && importDir < vAdrs[i] + vSizes[i]) {  							importDir = importDir - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* importDirPtr = bas + importDir;  					uint oftMod = *(uint*)importDirPtr;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= oftMod && oftMod < vAdrs[i] + vSizes[i]) {  							oftMod = oftMod - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* oftModPtr = bas + oftMod;  					uint modName = *(uint*)(importDirPtr + 12);  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= modName && modName < vAdrs[i] + vSizes[i]) {  							modName = modName - vAdrs[i] + rAdrs[i];  							break;  						}  					uint funcName = *(uint*)oftModPtr + 2;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= funcName && funcName < vAdrs[i] + vSizes[i]) {  							funcName = funcName - vAdrs[i] + rAdrs[i];  							break;  						}  					VirtualProtect(bas + modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + modName + i) = *(@new + i);    					VirtualProtect(bas + funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + funcName + i) = *(@new + i);  				}      				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdDir && mdDir < vAdrs[i] + vSizes[i]) {  						mdDir = mdDir - vAdrs[i] + rAdrs[i];  						break;  					}  				byte* mdDirPtr = bas + mdDir;  				VirtualProtect(mdDirPtr' 0x48' 0x40' out old);  				uint mdHdr = *(uint*)(mdDirPtr + 8);  				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdHdr && mdHdr < vAdrs[i] + vSizes[i]) {  						mdHdr = mdHdr - vAdrs[i] + rAdrs[i];  						break;  					}  				*(uint*)mdDirPtr = 0;  				*((uint*)mdDirPtr + 1) = 0;  				*((uint*)mdDirPtr + 2) = 0;  				*((uint*)mdDirPtr + 3) = 0;      				byte* mdHdrPtr = bas + mdHdr;  				VirtualProtect(mdHdrPtr' 4' 0x40' out old);  				*(uint*)mdHdrPtr = 0;  				mdHdrPtr += 12;  				mdHdrPtr += *(uint*)mdHdrPtr;  				mdHdrPtr = (byte*)(((ulong)mdHdrPtr + 7) & ~3UL);  				mdHdrPtr += 2;  				ushort numOfStream = *mdHdrPtr;  				mdHdrPtr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdrPtr' 8' 0x40' out old);  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdrPtr' 4' 0x40' out old);  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 3;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 2;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 1;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  					}  				}  			}
Magic Number,Confuser.Runtime,AntiDump,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiDump.cs,Initialize,The following statement contains a magic number: if (module.FullyQualifiedName[0] != '<') //Mapped  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				byte* mdDir = bas + *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;    				if (*(uint*)(ptr - 0x78) != 0) {  					byte* importDir = bas + *(uint*)(ptr - 0x78);  					byte* oftMod = bas + *(uint*)importDir;  					byte* modName = bas + *(uint*)(importDir + 12);  					byte* funcName = bas + *(uint*)oftMod + 2;  					VirtualProtect(modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(modName + i) = *(@new + i);    					VirtualProtect(funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(funcName + i) = *(@new + i);  				}    				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					ptr += 0x28;  				}  				VirtualProtect(mdDir' 0x48' 0x40' out old);  				byte* mdHdr = bas + *(uint*)(mdDir + 8);  				*(uint*)mdDir = 0;  				*((uint*)mdDir + 1) = 0;  				*((uint*)mdDir + 2) = 0;  				*((uint*)mdDir + 3) = 0;    				VirtualProtect(mdHdr' 4' 0x40' out old);  				*(uint*)mdHdr = 0;  				mdHdr += 12;  				mdHdr += *(uint*)mdHdr;  				mdHdr = (byte*)(((ulong)mdHdr + 7) & ~3UL);  				mdHdr += 2;  				ushort numOfStream = *mdHdr;  				mdHdr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdr' 8' 0x40' out old);  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdr' 4' 0x40' out old);  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 3;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 2;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 1;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  					}  				}  			}  			else //Flat  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				uint mdDir = *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;  				uint importDir = *(uint*)(ptr - 0x78);    				var vAdrs = new uint[sectNum];  				var vSizes = new uint[sectNum];  				var rAdrs = new uint[sectNum];  				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					vAdrs[i] = *(uint*)(ptr + 12);  					vSizes[i] = *(uint*)(ptr + 8);  					rAdrs[i] = *(uint*)(ptr + 20);  					ptr += 0x28;  				}      				if (importDir != 0) {  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= importDir && importDir < vAdrs[i] + vSizes[i]) {  							importDir = importDir - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* importDirPtr = bas + importDir;  					uint oftMod = *(uint*)importDirPtr;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= oftMod && oftMod < vAdrs[i] + vSizes[i]) {  							oftMod = oftMod - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* oftModPtr = bas + oftMod;  					uint modName = *(uint*)(importDirPtr + 12);  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= modName && modName < vAdrs[i] + vSizes[i]) {  							modName = modName - vAdrs[i] + rAdrs[i];  							break;  						}  					uint funcName = *(uint*)oftModPtr + 2;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= funcName && funcName < vAdrs[i] + vSizes[i]) {  							funcName = funcName - vAdrs[i] + rAdrs[i];  							break;  						}  					VirtualProtect(bas + modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + modName + i) = *(@new + i);    					VirtualProtect(bas + funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + funcName + i) = *(@new + i);  				}      				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdDir && mdDir < vAdrs[i] + vSizes[i]) {  						mdDir = mdDir - vAdrs[i] + rAdrs[i];  						break;  					}  				byte* mdDirPtr = bas + mdDir;  				VirtualProtect(mdDirPtr' 0x48' 0x40' out old);  				uint mdHdr = *(uint*)(mdDirPtr + 8);  				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdHdr && mdHdr < vAdrs[i] + vSizes[i]) {  						mdHdr = mdHdr - vAdrs[i] + rAdrs[i];  						break;  					}  				*(uint*)mdDirPtr = 0;  				*((uint*)mdDirPtr + 1) = 0;  				*((uint*)mdDirPtr + 2) = 0;  				*((uint*)mdDirPtr + 3) = 0;      				byte* mdHdrPtr = bas + mdHdr;  				VirtualProtect(mdHdrPtr' 4' 0x40' out old);  				*(uint*)mdHdrPtr = 0;  				mdHdrPtr += 12;  				mdHdrPtr += *(uint*)mdHdrPtr;  				mdHdrPtr = (byte*)(((ulong)mdHdrPtr + 7) & ~3UL);  				mdHdrPtr += 2;  				ushort numOfStream = *mdHdrPtr;  				mdHdrPtr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdrPtr' 8' 0x40' out old);  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdrPtr' 4' 0x40' out old);  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 3;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 2;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 1;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  					}  				}  			}
Magic Number,Confuser.Runtime,AntiDump,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiDump.cs,Initialize,The following statement contains a magic number: if (module.FullyQualifiedName[0] != '<') //Mapped  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				byte* mdDir = bas + *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;    				if (*(uint*)(ptr - 0x78) != 0) {  					byte* importDir = bas + *(uint*)(ptr - 0x78);  					byte* oftMod = bas + *(uint*)importDir;  					byte* modName = bas + *(uint*)(importDir + 12);  					byte* funcName = bas + *(uint*)oftMod + 2;  					VirtualProtect(modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(modName + i) = *(@new + i);    					VirtualProtect(funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(funcName + i) = *(@new + i);  				}    				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					ptr += 0x28;  				}  				VirtualProtect(mdDir' 0x48' 0x40' out old);  				byte* mdHdr = bas + *(uint*)(mdDir + 8);  				*(uint*)mdDir = 0;  				*((uint*)mdDir + 1) = 0;  				*((uint*)mdDir + 2) = 0;  				*((uint*)mdDir + 3) = 0;    				VirtualProtect(mdHdr' 4' 0x40' out old);  				*(uint*)mdHdr = 0;  				mdHdr += 12;  				mdHdr += *(uint*)mdHdr;  				mdHdr = (byte*)(((ulong)mdHdr + 7) & ~3UL);  				mdHdr += 2;  				ushort numOfStream = *mdHdr;  				mdHdr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdr' 8' 0x40' out old);  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdr' 4' 0x40' out old);  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 3;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 2;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 1;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  					}  				}  			}  			else //Flat  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				uint mdDir = *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;  				uint importDir = *(uint*)(ptr - 0x78);    				var vAdrs = new uint[sectNum];  				var vSizes = new uint[sectNum];  				var rAdrs = new uint[sectNum];  				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					vAdrs[i] = *(uint*)(ptr + 12);  					vSizes[i] = *(uint*)(ptr + 8);  					rAdrs[i] = *(uint*)(ptr + 20);  					ptr += 0x28;  				}      				if (importDir != 0) {  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= importDir && importDir < vAdrs[i] + vSizes[i]) {  							importDir = importDir - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* importDirPtr = bas + importDir;  					uint oftMod = *(uint*)importDirPtr;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= oftMod && oftMod < vAdrs[i] + vSizes[i]) {  							oftMod = oftMod - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* oftModPtr = bas + oftMod;  					uint modName = *(uint*)(importDirPtr + 12);  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= modName && modName < vAdrs[i] + vSizes[i]) {  							modName = modName - vAdrs[i] + rAdrs[i];  							break;  						}  					uint funcName = *(uint*)oftModPtr + 2;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= funcName && funcName < vAdrs[i] + vSizes[i]) {  							funcName = funcName - vAdrs[i] + rAdrs[i];  							break;  						}  					VirtualProtect(bas + modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + modName + i) = *(@new + i);    					VirtualProtect(bas + funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + funcName + i) = *(@new + i);  				}      				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdDir && mdDir < vAdrs[i] + vSizes[i]) {  						mdDir = mdDir - vAdrs[i] + rAdrs[i];  						break;  					}  				byte* mdDirPtr = bas + mdDir;  				VirtualProtect(mdDirPtr' 0x48' 0x40' out old);  				uint mdHdr = *(uint*)(mdDirPtr + 8);  				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdHdr && mdHdr < vAdrs[i] + vSizes[i]) {  						mdHdr = mdHdr - vAdrs[i] + rAdrs[i];  						break;  					}  				*(uint*)mdDirPtr = 0;  				*((uint*)mdDirPtr + 1) = 0;  				*((uint*)mdDirPtr + 2) = 0;  				*((uint*)mdDirPtr + 3) = 0;      				byte* mdHdrPtr = bas + mdHdr;  				VirtualProtect(mdHdrPtr' 4' 0x40' out old);  				*(uint*)mdHdrPtr = 0;  				mdHdrPtr += 12;  				mdHdrPtr += *(uint*)mdHdrPtr;  				mdHdrPtr = (byte*)(((ulong)mdHdrPtr + 7) & ~3UL);  				mdHdrPtr += 2;  				ushort numOfStream = *mdHdrPtr;  				mdHdrPtr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdrPtr' 8' 0x40' out old);  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdrPtr' 4' 0x40' out old);  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 3;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 2;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 1;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  					}  				}  			}
Magic Number,Confuser.Runtime,AntiDump,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiDump.cs,Initialize,The following statement contains a magic number: if (module.FullyQualifiedName[0] != '<') //Mapped  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				byte* mdDir = bas + *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;    				if (*(uint*)(ptr - 0x78) != 0) {  					byte* importDir = bas + *(uint*)(ptr - 0x78);  					byte* oftMod = bas + *(uint*)importDir;  					byte* modName = bas + *(uint*)(importDir + 12);  					byte* funcName = bas + *(uint*)oftMod + 2;  					VirtualProtect(modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(modName + i) = *(@new + i);    					VirtualProtect(funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(funcName + i) = *(@new + i);  				}    				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					ptr += 0x28;  				}  				VirtualProtect(mdDir' 0x48' 0x40' out old);  				byte* mdHdr = bas + *(uint*)(mdDir + 8);  				*(uint*)mdDir = 0;  				*((uint*)mdDir + 1) = 0;  				*((uint*)mdDir + 2) = 0;  				*((uint*)mdDir + 3) = 0;    				VirtualProtect(mdHdr' 4' 0x40' out old);  				*(uint*)mdHdr = 0;  				mdHdr += 12;  				mdHdr += *(uint*)mdHdr;  				mdHdr = (byte*)(((ulong)mdHdr + 7) & ~3UL);  				mdHdr += 2;  				ushort numOfStream = *mdHdr;  				mdHdr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdr' 8' 0x40' out old);  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdr' 4' 0x40' out old);  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 3;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 2;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 1;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  					}  				}  			}  			else //Flat  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				uint mdDir = *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;  				uint importDir = *(uint*)(ptr - 0x78);    				var vAdrs = new uint[sectNum];  				var vSizes = new uint[sectNum];  				var rAdrs = new uint[sectNum];  				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					vAdrs[i] = *(uint*)(ptr + 12);  					vSizes[i] = *(uint*)(ptr + 8);  					rAdrs[i] = *(uint*)(ptr + 20);  					ptr += 0x28;  				}      				if (importDir != 0) {  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= importDir && importDir < vAdrs[i] + vSizes[i]) {  							importDir = importDir - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* importDirPtr = bas + importDir;  					uint oftMod = *(uint*)importDirPtr;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= oftMod && oftMod < vAdrs[i] + vSizes[i]) {  							oftMod = oftMod - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* oftModPtr = bas + oftMod;  					uint modName = *(uint*)(importDirPtr + 12);  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= modName && modName < vAdrs[i] + vSizes[i]) {  							modName = modName - vAdrs[i] + rAdrs[i];  							break;  						}  					uint funcName = *(uint*)oftModPtr + 2;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= funcName && funcName < vAdrs[i] + vSizes[i]) {  							funcName = funcName - vAdrs[i] + rAdrs[i];  							break;  						}  					VirtualProtect(bas + modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + modName + i) = *(@new + i);    					VirtualProtect(bas + funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + funcName + i) = *(@new + i);  				}      				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdDir && mdDir < vAdrs[i] + vSizes[i]) {  						mdDir = mdDir - vAdrs[i] + rAdrs[i];  						break;  					}  				byte* mdDirPtr = bas + mdDir;  				VirtualProtect(mdDirPtr' 0x48' 0x40' out old);  				uint mdHdr = *(uint*)(mdDirPtr + 8);  				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdHdr && mdHdr < vAdrs[i] + vSizes[i]) {  						mdHdr = mdHdr - vAdrs[i] + rAdrs[i];  						break;  					}  				*(uint*)mdDirPtr = 0;  				*((uint*)mdDirPtr + 1) = 0;  				*((uint*)mdDirPtr + 2) = 0;  				*((uint*)mdDirPtr + 3) = 0;      				byte* mdHdrPtr = bas + mdHdr;  				VirtualProtect(mdHdrPtr' 4' 0x40' out old);  				*(uint*)mdHdrPtr = 0;  				mdHdrPtr += 12;  				mdHdrPtr += *(uint*)mdHdrPtr;  				mdHdrPtr = (byte*)(((ulong)mdHdrPtr + 7) & ~3UL);  				mdHdrPtr += 2;  				ushort numOfStream = *mdHdrPtr;  				mdHdrPtr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdrPtr' 8' 0x40' out old);  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdrPtr' 4' 0x40' out old);  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 3;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 2;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 1;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  					}  				}  			}
Magic Number,Confuser.Runtime,AntiDump,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiDump.cs,Initialize,The following statement contains a magic number: if (module.FullyQualifiedName[0] != '<') //Mapped  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				byte* mdDir = bas + *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;    				if (*(uint*)(ptr - 0x78) != 0) {  					byte* importDir = bas + *(uint*)(ptr - 0x78);  					byte* oftMod = bas + *(uint*)importDir;  					byte* modName = bas + *(uint*)(importDir + 12);  					byte* funcName = bas + *(uint*)oftMod + 2;  					VirtualProtect(modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(modName + i) = *(@new + i);    					VirtualProtect(funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(funcName + i) = *(@new + i);  				}    				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					ptr += 0x28;  				}  				VirtualProtect(mdDir' 0x48' 0x40' out old);  				byte* mdHdr = bas + *(uint*)(mdDir + 8);  				*(uint*)mdDir = 0;  				*((uint*)mdDir + 1) = 0;  				*((uint*)mdDir + 2) = 0;  				*((uint*)mdDir + 3) = 0;    				VirtualProtect(mdHdr' 4' 0x40' out old);  				*(uint*)mdHdr = 0;  				mdHdr += 12;  				mdHdr += *(uint*)mdHdr;  				mdHdr = (byte*)(((ulong)mdHdr + 7) & ~3UL);  				mdHdr += 2;  				ushort numOfStream = *mdHdr;  				mdHdr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdr' 8' 0x40' out old);  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdr' 4' 0x40' out old);  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 3;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 2;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 1;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  					}  				}  			}  			else //Flat  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				uint mdDir = *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;  				uint importDir = *(uint*)(ptr - 0x78);    				var vAdrs = new uint[sectNum];  				var vSizes = new uint[sectNum];  				var rAdrs = new uint[sectNum];  				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					vAdrs[i] = *(uint*)(ptr + 12);  					vSizes[i] = *(uint*)(ptr + 8);  					rAdrs[i] = *(uint*)(ptr + 20);  					ptr += 0x28;  				}      				if (importDir != 0) {  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= importDir && importDir < vAdrs[i] + vSizes[i]) {  							importDir = importDir - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* importDirPtr = bas + importDir;  					uint oftMod = *(uint*)importDirPtr;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= oftMod && oftMod < vAdrs[i] + vSizes[i]) {  							oftMod = oftMod - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* oftModPtr = bas + oftMod;  					uint modName = *(uint*)(importDirPtr + 12);  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= modName && modName < vAdrs[i] + vSizes[i]) {  							modName = modName - vAdrs[i] + rAdrs[i];  							break;  						}  					uint funcName = *(uint*)oftModPtr + 2;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= funcName && funcName < vAdrs[i] + vSizes[i]) {  							funcName = funcName - vAdrs[i] + rAdrs[i];  							break;  						}  					VirtualProtect(bas + modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + modName + i) = *(@new + i);    					VirtualProtect(bas + funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + funcName + i) = *(@new + i);  				}      				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdDir && mdDir < vAdrs[i] + vSizes[i]) {  						mdDir = mdDir - vAdrs[i] + rAdrs[i];  						break;  					}  				byte* mdDirPtr = bas + mdDir;  				VirtualProtect(mdDirPtr' 0x48' 0x40' out old);  				uint mdHdr = *(uint*)(mdDirPtr + 8);  				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdHdr && mdHdr < vAdrs[i] + vSizes[i]) {  						mdHdr = mdHdr - vAdrs[i] + rAdrs[i];  						break;  					}  				*(uint*)mdDirPtr = 0;  				*((uint*)mdDirPtr + 1) = 0;  				*((uint*)mdDirPtr + 2) = 0;  				*((uint*)mdDirPtr + 3) = 0;      				byte* mdHdrPtr = bas + mdHdr;  				VirtualProtect(mdHdrPtr' 4' 0x40' out old);  				*(uint*)mdHdrPtr = 0;  				mdHdrPtr += 12;  				mdHdrPtr += *(uint*)mdHdrPtr;  				mdHdrPtr = (byte*)(((ulong)mdHdrPtr + 7) & ~3UL);  				mdHdrPtr += 2;  				ushort numOfStream = *mdHdrPtr;  				mdHdrPtr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdrPtr' 8' 0x40' out old);  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdrPtr' 4' 0x40' out old);  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 3;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 2;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 1;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  					}  				}  			}
Magic Number,Confuser.Runtime,AntiDump,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiDump.cs,Initialize,The following statement contains a magic number: if (module.FullyQualifiedName[0] != '<') //Mapped  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				byte* mdDir = bas + *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;    				if (*(uint*)(ptr - 0x78) != 0) {  					byte* importDir = bas + *(uint*)(ptr - 0x78);  					byte* oftMod = bas + *(uint*)importDir;  					byte* modName = bas + *(uint*)(importDir + 12);  					byte* funcName = bas + *(uint*)oftMod + 2;  					VirtualProtect(modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(modName + i) = *(@new + i);    					VirtualProtect(funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(funcName + i) = *(@new + i);  				}    				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					ptr += 0x28;  				}  				VirtualProtect(mdDir' 0x48' 0x40' out old);  				byte* mdHdr = bas + *(uint*)(mdDir + 8);  				*(uint*)mdDir = 0;  				*((uint*)mdDir + 1) = 0;  				*((uint*)mdDir + 2) = 0;  				*((uint*)mdDir + 3) = 0;    				VirtualProtect(mdHdr' 4' 0x40' out old);  				*(uint*)mdHdr = 0;  				mdHdr += 12;  				mdHdr += *(uint*)mdHdr;  				mdHdr = (byte*)(((ulong)mdHdr + 7) & ~3UL);  				mdHdr += 2;  				ushort numOfStream = *mdHdr;  				mdHdr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdr' 8' 0x40' out old);  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdr' 4' 0x40' out old);  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 3;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 2;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 1;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  					}  				}  			}  			else //Flat  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				uint mdDir = *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;  				uint importDir = *(uint*)(ptr - 0x78);    				var vAdrs = new uint[sectNum];  				var vSizes = new uint[sectNum];  				var rAdrs = new uint[sectNum];  				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					vAdrs[i] = *(uint*)(ptr + 12);  					vSizes[i] = *(uint*)(ptr + 8);  					rAdrs[i] = *(uint*)(ptr + 20);  					ptr += 0x28;  				}      				if (importDir != 0) {  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= importDir && importDir < vAdrs[i] + vSizes[i]) {  							importDir = importDir - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* importDirPtr = bas + importDir;  					uint oftMod = *(uint*)importDirPtr;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= oftMod && oftMod < vAdrs[i] + vSizes[i]) {  							oftMod = oftMod - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* oftModPtr = bas + oftMod;  					uint modName = *(uint*)(importDirPtr + 12);  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= modName && modName < vAdrs[i] + vSizes[i]) {  							modName = modName - vAdrs[i] + rAdrs[i];  							break;  						}  					uint funcName = *(uint*)oftModPtr + 2;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= funcName && funcName < vAdrs[i] + vSizes[i]) {  							funcName = funcName - vAdrs[i] + rAdrs[i];  							break;  						}  					VirtualProtect(bas + modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + modName + i) = *(@new + i);    					VirtualProtect(bas + funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + funcName + i) = *(@new + i);  				}      				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdDir && mdDir < vAdrs[i] + vSizes[i]) {  						mdDir = mdDir - vAdrs[i] + rAdrs[i];  						break;  					}  				byte* mdDirPtr = bas + mdDir;  				VirtualProtect(mdDirPtr' 0x48' 0x40' out old);  				uint mdHdr = *(uint*)(mdDirPtr + 8);  				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdHdr && mdHdr < vAdrs[i] + vSizes[i]) {  						mdHdr = mdHdr - vAdrs[i] + rAdrs[i];  						break;  					}  				*(uint*)mdDirPtr = 0;  				*((uint*)mdDirPtr + 1) = 0;  				*((uint*)mdDirPtr + 2) = 0;  				*((uint*)mdDirPtr + 3) = 0;      				byte* mdHdrPtr = bas + mdHdr;  				VirtualProtect(mdHdrPtr' 4' 0x40' out old);  				*(uint*)mdHdrPtr = 0;  				mdHdrPtr += 12;  				mdHdrPtr += *(uint*)mdHdrPtr;  				mdHdrPtr = (byte*)(((ulong)mdHdrPtr + 7) & ~3UL);  				mdHdrPtr += 2;  				ushort numOfStream = *mdHdrPtr;  				mdHdrPtr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdrPtr' 8' 0x40' out old);  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdrPtr' 4' 0x40' out old);  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 3;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 2;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 1;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  					}  				}  			}
Magic Number,Confuser.Runtime,AntiDump,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiDump.cs,Initialize,The following statement contains a magic number: if (module.FullyQualifiedName[0] != '<') //Mapped  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				byte* mdDir = bas + *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;    				if (*(uint*)(ptr - 0x78) != 0) {  					byte* importDir = bas + *(uint*)(ptr - 0x78);  					byte* oftMod = bas + *(uint*)importDir;  					byte* modName = bas + *(uint*)(importDir + 12);  					byte* funcName = bas + *(uint*)oftMod + 2;  					VirtualProtect(modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(modName + i) = *(@new + i);    					VirtualProtect(funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(funcName + i) = *(@new + i);  				}    				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					ptr += 0x28;  				}  				VirtualProtect(mdDir' 0x48' 0x40' out old);  				byte* mdHdr = bas + *(uint*)(mdDir + 8);  				*(uint*)mdDir = 0;  				*((uint*)mdDir + 1) = 0;  				*((uint*)mdDir + 2) = 0;  				*((uint*)mdDir + 3) = 0;    				VirtualProtect(mdHdr' 4' 0x40' out old);  				*(uint*)mdHdr = 0;  				mdHdr += 12;  				mdHdr += *(uint*)mdHdr;  				mdHdr = (byte*)(((ulong)mdHdr + 7) & ~3UL);  				mdHdr += 2;  				ushort numOfStream = *mdHdr;  				mdHdr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdr' 8' 0x40' out old);  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdr' 4' 0x40' out old);  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 3;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 2;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 1;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  					}  				}  			}  			else //Flat  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				uint mdDir = *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;  				uint importDir = *(uint*)(ptr - 0x78);    				var vAdrs = new uint[sectNum];  				var vSizes = new uint[sectNum];  				var rAdrs = new uint[sectNum];  				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					vAdrs[i] = *(uint*)(ptr + 12);  					vSizes[i] = *(uint*)(ptr + 8);  					rAdrs[i] = *(uint*)(ptr + 20);  					ptr += 0x28;  				}      				if (importDir != 0) {  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= importDir && importDir < vAdrs[i] + vSizes[i]) {  							importDir = importDir - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* importDirPtr = bas + importDir;  					uint oftMod = *(uint*)importDirPtr;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= oftMod && oftMod < vAdrs[i] + vSizes[i]) {  							oftMod = oftMod - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* oftModPtr = bas + oftMod;  					uint modName = *(uint*)(importDirPtr + 12);  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= modName && modName < vAdrs[i] + vSizes[i]) {  							modName = modName - vAdrs[i] + rAdrs[i];  							break;  						}  					uint funcName = *(uint*)oftModPtr + 2;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= funcName && funcName < vAdrs[i] + vSizes[i]) {  							funcName = funcName - vAdrs[i] + rAdrs[i];  							break;  						}  					VirtualProtect(bas + modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + modName + i) = *(@new + i);    					VirtualProtect(bas + funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + funcName + i) = *(@new + i);  				}      				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdDir && mdDir < vAdrs[i] + vSizes[i]) {  						mdDir = mdDir - vAdrs[i] + rAdrs[i];  						break;  					}  				byte* mdDirPtr = bas + mdDir;  				VirtualProtect(mdDirPtr' 0x48' 0x40' out old);  				uint mdHdr = *(uint*)(mdDirPtr + 8);  				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdHdr && mdHdr < vAdrs[i] + vSizes[i]) {  						mdHdr = mdHdr - vAdrs[i] + rAdrs[i];  						break;  					}  				*(uint*)mdDirPtr = 0;  				*((uint*)mdDirPtr + 1) = 0;  				*((uint*)mdDirPtr + 2) = 0;  				*((uint*)mdDirPtr + 3) = 0;      				byte* mdHdrPtr = bas + mdHdr;  				VirtualProtect(mdHdrPtr' 4' 0x40' out old);  				*(uint*)mdHdrPtr = 0;  				mdHdrPtr += 12;  				mdHdrPtr += *(uint*)mdHdrPtr;  				mdHdrPtr = (byte*)(((ulong)mdHdrPtr + 7) & ~3UL);  				mdHdrPtr += 2;  				ushort numOfStream = *mdHdrPtr;  				mdHdrPtr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdrPtr' 8' 0x40' out old);  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdrPtr' 4' 0x40' out old);  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 3;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 2;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 1;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  					}  				}  			}
Magic Number,Confuser.Runtime,AntiDump,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiDump.cs,Initialize,The following statement contains a magic number: if (module.FullyQualifiedName[0] != '<') //Mapped  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				byte* mdDir = bas + *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;    				if (*(uint*)(ptr - 0x78) != 0) {  					byte* importDir = bas + *(uint*)(ptr - 0x78);  					byte* oftMod = bas + *(uint*)importDir;  					byte* modName = bas + *(uint*)(importDir + 12);  					byte* funcName = bas + *(uint*)oftMod + 2;  					VirtualProtect(modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(modName + i) = *(@new + i);    					VirtualProtect(funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(funcName + i) = *(@new + i);  				}    				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					ptr += 0x28;  				}  				VirtualProtect(mdDir' 0x48' 0x40' out old);  				byte* mdHdr = bas + *(uint*)(mdDir + 8);  				*(uint*)mdDir = 0;  				*((uint*)mdDir + 1) = 0;  				*((uint*)mdDir + 2) = 0;  				*((uint*)mdDir + 3) = 0;    				VirtualProtect(mdHdr' 4' 0x40' out old);  				*(uint*)mdHdr = 0;  				mdHdr += 12;  				mdHdr += *(uint*)mdHdr;  				mdHdr = (byte*)(((ulong)mdHdr + 7) & ~3UL);  				mdHdr += 2;  				ushort numOfStream = *mdHdr;  				mdHdr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdr' 8' 0x40' out old);  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdr' 4' 0x40' out old);  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 3;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 2;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 1;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  					}  				}  			}  			else //Flat  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				uint mdDir = *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;  				uint importDir = *(uint*)(ptr - 0x78);    				var vAdrs = new uint[sectNum];  				var vSizes = new uint[sectNum];  				var rAdrs = new uint[sectNum];  				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					vAdrs[i] = *(uint*)(ptr + 12);  					vSizes[i] = *(uint*)(ptr + 8);  					rAdrs[i] = *(uint*)(ptr + 20);  					ptr += 0x28;  				}      				if (importDir != 0) {  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= importDir && importDir < vAdrs[i] + vSizes[i]) {  							importDir = importDir - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* importDirPtr = bas + importDir;  					uint oftMod = *(uint*)importDirPtr;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= oftMod && oftMod < vAdrs[i] + vSizes[i]) {  							oftMod = oftMod - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* oftModPtr = bas + oftMod;  					uint modName = *(uint*)(importDirPtr + 12);  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= modName && modName < vAdrs[i] + vSizes[i]) {  							modName = modName - vAdrs[i] + rAdrs[i];  							break;  						}  					uint funcName = *(uint*)oftModPtr + 2;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= funcName && funcName < vAdrs[i] + vSizes[i]) {  							funcName = funcName - vAdrs[i] + rAdrs[i];  							break;  						}  					VirtualProtect(bas + modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + modName + i) = *(@new + i);    					VirtualProtect(bas + funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + funcName + i) = *(@new + i);  				}      				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdDir && mdDir < vAdrs[i] + vSizes[i]) {  						mdDir = mdDir - vAdrs[i] + rAdrs[i];  						break;  					}  				byte* mdDirPtr = bas + mdDir;  				VirtualProtect(mdDirPtr' 0x48' 0x40' out old);  				uint mdHdr = *(uint*)(mdDirPtr + 8);  				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdHdr && mdHdr < vAdrs[i] + vSizes[i]) {  						mdHdr = mdHdr - vAdrs[i] + rAdrs[i];  						break;  					}  				*(uint*)mdDirPtr = 0;  				*((uint*)mdDirPtr + 1) = 0;  				*((uint*)mdDirPtr + 2) = 0;  				*((uint*)mdDirPtr + 3) = 0;      				byte* mdHdrPtr = bas + mdHdr;  				VirtualProtect(mdHdrPtr' 4' 0x40' out old);  				*(uint*)mdHdrPtr = 0;  				mdHdrPtr += 12;  				mdHdrPtr += *(uint*)mdHdrPtr;  				mdHdrPtr = (byte*)(((ulong)mdHdrPtr + 7) & ~3UL);  				mdHdrPtr += 2;  				ushort numOfStream = *mdHdrPtr;  				mdHdrPtr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdrPtr' 8' 0x40' out old);  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdrPtr' 4' 0x40' out old);  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 3;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 2;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 1;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  					}  				}  			}
Magic Number,Confuser.Runtime,AntiDump,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiDump.cs,Initialize,The following statement contains a magic number: if (module.FullyQualifiedName[0] != '<') //Mapped  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				byte* mdDir = bas + *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;    				if (*(uint*)(ptr - 0x78) != 0) {  					byte* importDir = bas + *(uint*)(ptr - 0x78);  					byte* oftMod = bas + *(uint*)importDir;  					byte* modName = bas + *(uint*)(importDir + 12);  					byte* funcName = bas + *(uint*)oftMod + 2;  					VirtualProtect(modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(modName + i) = *(@new + i);    					VirtualProtect(funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(funcName + i) = *(@new + i);  				}    				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					ptr += 0x28;  				}  				VirtualProtect(mdDir' 0x48' 0x40' out old);  				byte* mdHdr = bas + *(uint*)(mdDir + 8);  				*(uint*)mdDir = 0;  				*((uint*)mdDir + 1) = 0;  				*((uint*)mdDir + 2) = 0;  				*((uint*)mdDir + 3) = 0;    				VirtualProtect(mdHdr' 4' 0x40' out old);  				*(uint*)mdHdr = 0;  				mdHdr += 12;  				mdHdr += *(uint*)mdHdr;  				mdHdr = (byte*)(((ulong)mdHdr + 7) & ~3UL);  				mdHdr += 2;  				ushort numOfStream = *mdHdr;  				mdHdr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdr' 8' 0x40' out old);  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdr' 4' 0x40' out old);  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 3;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 2;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 1;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  					}  				}  			}  			else //Flat  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				uint mdDir = *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;  				uint importDir = *(uint*)(ptr - 0x78);    				var vAdrs = new uint[sectNum];  				var vSizes = new uint[sectNum];  				var rAdrs = new uint[sectNum];  				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					vAdrs[i] = *(uint*)(ptr + 12);  					vSizes[i] = *(uint*)(ptr + 8);  					rAdrs[i] = *(uint*)(ptr + 20);  					ptr += 0x28;  				}      				if (importDir != 0) {  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= importDir && importDir < vAdrs[i] + vSizes[i]) {  							importDir = importDir - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* importDirPtr = bas + importDir;  					uint oftMod = *(uint*)importDirPtr;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= oftMod && oftMod < vAdrs[i] + vSizes[i]) {  							oftMod = oftMod - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* oftModPtr = bas + oftMod;  					uint modName = *(uint*)(importDirPtr + 12);  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= modName && modName < vAdrs[i] + vSizes[i]) {  							modName = modName - vAdrs[i] + rAdrs[i];  							break;  						}  					uint funcName = *(uint*)oftModPtr + 2;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= funcName && funcName < vAdrs[i] + vSizes[i]) {  							funcName = funcName - vAdrs[i] + rAdrs[i];  							break;  						}  					VirtualProtect(bas + modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + modName + i) = *(@new + i);    					VirtualProtect(bas + funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + funcName + i) = *(@new + i);  				}      				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdDir && mdDir < vAdrs[i] + vSizes[i]) {  						mdDir = mdDir - vAdrs[i] + rAdrs[i];  						break;  					}  				byte* mdDirPtr = bas + mdDir;  				VirtualProtect(mdDirPtr' 0x48' 0x40' out old);  				uint mdHdr = *(uint*)(mdDirPtr + 8);  				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdHdr && mdHdr < vAdrs[i] + vSizes[i]) {  						mdHdr = mdHdr - vAdrs[i] + rAdrs[i];  						break;  					}  				*(uint*)mdDirPtr = 0;  				*((uint*)mdDirPtr + 1) = 0;  				*((uint*)mdDirPtr + 2) = 0;  				*((uint*)mdDirPtr + 3) = 0;      				byte* mdHdrPtr = bas + mdHdr;  				VirtualProtect(mdHdrPtr' 4' 0x40' out old);  				*(uint*)mdHdrPtr = 0;  				mdHdrPtr += 12;  				mdHdrPtr += *(uint*)mdHdrPtr;  				mdHdrPtr = (byte*)(((ulong)mdHdrPtr + 7) & ~3UL);  				mdHdrPtr += 2;  				ushort numOfStream = *mdHdrPtr;  				mdHdrPtr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdrPtr' 8' 0x40' out old);  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdrPtr' 4' 0x40' out old);  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 3;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 2;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 1;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  					}  				}  			}
Magic Number,Confuser.Runtime,AntiDump,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiDump.cs,Initialize,The following statement contains a magic number: if (module.FullyQualifiedName[0] != '<') //Mapped  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				byte* mdDir = bas + *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;    				if (*(uint*)(ptr - 0x78) != 0) {  					byte* importDir = bas + *(uint*)(ptr - 0x78);  					byte* oftMod = bas + *(uint*)importDir;  					byte* modName = bas + *(uint*)(importDir + 12);  					byte* funcName = bas + *(uint*)oftMod + 2;  					VirtualProtect(modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(modName + i) = *(@new + i);    					VirtualProtect(funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(funcName + i) = *(@new + i);  				}    				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					ptr += 0x28;  				}  				VirtualProtect(mdDir' 0x48' 0x40' out old);  				byte* mdHdr = bas + *(uint*)(mdDir + 8);  				*(uint*)mdDir = 0;  				*((uint*)mdDir + 1) = 0;  				*((uint*)mdDir + 2) = 0;  				*((uint*)mdDir + 3) = 0;    				VirtualProtect(mdHdr' 4' 0x40' out old);  				*(uint*)mdHdr = 0;  				mdHdr += 12;  				mdHdr += *(uint*)mdHdr;  				mdHdr = (byte*)(((ulong)mdHdr + 7) & ~3UL);  				mdHdr += 2;  				ushort numOfStream = *mdHdr;  				mdHdr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdr' 8' 0x40' out old);  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdr' 4' 0x40' out old);  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 3;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 2;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 1;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  					}  				}  			}  			else //Flat  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				uint mdDir = *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;  				uint importDir = *(uint*)(ptr - 0x78);    				var vAdrs = new uint[sectNum];  				var vSizes = new uint[sectNum];  				var rAdrs = new uint[sectNum];  				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					vAdrs[i] = *(uint*)(ptr + 12);  					vSizes[i] = *(uint*)(ptr + 8);  					rAdrs[i] = *(uint*)(ptr + 20);  					ptr += 0x28;  				}      				if (importDir != 0) {  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= importDir && importDir < vAdrs[i] + vSizes[i]) {  							importDir = importDir - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* importDirPtr = bas + importDir;  					uint oftMod = *(uint*)importDirPtr;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= oftMod && oftMod < vAdrs[i] + vSizes[i]) {  							oftMod = oftMod - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* oftModPtr = bas + oftMod;  					uint modName = *(uint*)(importDirPtr + 12);  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= modName && modName < vAdrs[i] + vSizes[i]) {  							modName = modName - vAdrs[i] + rAdrs[i];  							break;  						}  					uint funcName = *(uint*)oftModPtr + 2;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= funcName && funcName < vAdrs[i] + vSizes[i]) {  							funcName = funcName - vAdrs[i] + rAdrs[i];  							break;  						}  					VirtualProtect(bas + modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + modName + i) = *(@new + i);    					VirtualProtect(bas + funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + funcName + i) = *(@new + i);  				}      				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdDir && mdDir < vAdrs[i] + vSizes[i]) {  						mdDir = mdDir - vAdrs[i] + rAdrs[i];  						break;  					}  				byte* mdDirPtr = bas + mdDir;  				VirtualProtect(mdDirPtr' 0x48' 0x40' out old);  				uint mdHdr = *(uint*)(mdDirPtr + 8);  				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdHdr && mdHdr < vAdrs[i] + vSizes[i]) {  						mdHdr = mdHdr - vAdrs[i] + rAdrs[i];  						break;  					}  				*(uint*)mdDirPtr = 0;  				*((uint*)mdDirPtr + 1) = 0;  				*((uint*)mdDirPtr + 2) = 0;  				*((uint*)mdDirPtr + 3) = 0;      				byte* mdHdrPtr = bas + mdHdr;  				VirtualProtect(mdHdrPtr' 4' 0x40' out old);  				*(uint*)mdHdrPtr = 0;  				mdHdrPtr += 12;  				mdHdrPtr += *(uint*)mdHdrPtr;  				mdHdrPtr = (byte*)(((ulong)mdHdrPtr + 7) & ~3UL);  				mdHdrPtr += 2;  				ushort numOfStream = *mdHdrPtr;  				mdHdrPtr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdrPtr' 8' 0x40' out old);  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdrPtr' 4' 0x40' out old);  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 3;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 2;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 1;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  					}  				}  			}
Magic Number,Confuser.Runtime,AntiDump,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiDump.cs,Initialize,The following statement contains a magic number: if (module.FullyQualifiedName[0] != '<') //Mapped  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				byte* mdDir = bas + *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;    				if (*(uint*)(ptr - 0x78) != 0) {  					byte* importDir = bas + *(uint*)(ptr - 0x78);  					byte* oftMod = bas + *(uint*)importDir;  					byte* modName = bas + *(uint*)(importDir + 12);  					byte* funcName = bas + *(uint*)oftMod + 2;  					VirtualProtect(modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(modName + i) = *(@new + i);    					VirtualProtect(funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(funcName + i) = *(@new + i);  				}    				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					ptr += 0x28;  				}  				VirtualProtect(mdDir' 0x48' 0x40' out old);  				byte* mdHdr = bas + *(uint*)(mdDir + 8);  				*(uint*)mdDir = 0;  				*((uint*)mdDir + 1) = 0;  				*((uint*)mdDir + 2) = 0;  				*((uint*)mdDir + 3) = 0;    				VirtualProtect(mdHdr' 4' 0x40' out old);  				*(uint*)mdHdr = 0;  				mdHdr += 12;  				mdHdr += *(uint*)mdHdr;  				mdHdr = (byte*)(((ulong)mdHdr + 7) & ~3UL);  				mdHdr += 2;  				ushort numOfStream = *mdHdr;  				mdHdr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdr' 8' 0x40' out old);  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdr' 4' 0x40' out old);  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 3;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 2;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 1;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  					}  				}  			}  			else //Flat  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				uint mdDir = *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;  				uint importDir = *(uint*)(ptr - 0x78);    				var vAdrs = new uint[sectNum];  				var vSizes = new uint[sectNum];  				var rAdrs = new uint[sectNum];  				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					vAdrs[i] = *(uint*)(ptr + 12);  					vSizes[i] = *(uint*)(ptr + 8);  					rAdrs[i] = *(uint*)(ptr + 20);  					ptr += 0x28;  				}      				if (importDir != 0) {  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= importDir && importDir < vAdrs[i] + vSizes[i]) {  							importDir = importDir - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* importDirPtr = bas + importDir;  					uint oftMod = *(uint*)importDirPtr;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= oftMod && oftMod < vAdrs[i] + vSizes[i]) {  							oftMod = oftMod - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* oftModPtr = bas + oftMod;  					uint modName = *(uint*)(importDirPtr + 12);  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= modName && modName < vAdrs[i] + vSizes[i]) {  							modName = modName - vAdrs[i] + rAdrs[i];  							break;  						}  					uint funcName = *(uint*)oftModPtr + 2;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= funcName && funcName < vAdrs[i] + vSizes[i]) {  							funcName = funcName - vAdrs[i] + rAdrs[i];  							break;  						}  					VirtualProtect(bas + modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + modName + i) = *(@new + i);    					VirtualProtect(bas + funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + funcName + i) = *(@new + i);  				}      				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdDir && mdDir < vAdrs[i] + vSizes[i]) {  						mdDir = mdDir - vAdrs[i] + rAdrs[i];  						break;  					}  				byte* mdDirPtr = bas + mdDir;  				VirtualProtect(mdDirPtr' 0x48' 0x40' out old);  				uint mdHdr = *(uint*)(mdDirPtr + 8);  				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdHdr && mdHdr < vAdrs[i] + vSizes[i]) {  						mdHdr = mdHdr - vAdrs[i] + rAdrs[i];  						break;  					}  				*(uint*)mdDirPtr = 0;  				*((uint*)mdDirPtr + 1) = 0;  				*((uint*)mdDirPtr + 2) = 0;  				*((uint*)mdDirPtr + 3) = 0;      				byte* mdHdrPtr = bas + mdHdr;  				VirtualProtect(mdHdrPtr' 4' 0x40' out old);  				*(uint*)mdHdrPtr = 0;  				mdHdrPtr += 12;  				mdHdrPtr += *(uint*)mdHdrPtr;  				mdHdrPtr = (byte*)(((ulong)mdHdrPtr + 7) & ~3UL);  				mdHdrPtr += 2;  				ushort numOfStream = *mdHdrPtr;  				mdHdrPtr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdrPtr' 8' 0x40' out old);  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdrPtr' 4' 0x40' out old);  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 3;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 2;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 1;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  					}  				}  			}
Magic Number,Confuser.Runtime,AntiDump,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiDump.cs,Initialize,The following statement contains a magic number: if (module.FullyQualifiedName[0] != '<') //Mapped  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				byte* mdDir = bas + *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;    				if (*(uint*)(ptr - 0x78) != 0) {  					byte* importDir = bas + *(uint*)(ptr - 0x78);  					byte* oftMod = bas + *(uint*)importDir;  					byte* modName = bas + *(uint*)(importDir + 12);  					byte* funcName = bas + *(uint*)oftMod + 2;  					VirtualProtect(modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(modName + i) = *(@new + i);    					VirtualProtect(funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(funcName + i) = *(@new + i);  				}    				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					ptr += 0x28;  				}  				VirtualProtect(mdDir' 0x48' 0x40' out old);  				byte* mdHdr = bas + *(uint*)(mdDir + 8);  				*(uint*)mdDir = 0;  				*((uint*)mdDir + 1) = 0;  				*((uint*)mdDir + 2) = 0;  				*((uint*)mdDir + 3) = 0;    				VirtualProtect(mdHdr' 4' 0x40' out old);  				*(uint*)mdHdr = 0;  				mdHdr += 12;  				mdHdr += *(uint*)mdHdr;  				mdHdr = (byte*)(((ulong)mdHdr + 7) & ~3UL);  				mdHdr += 2;  				ushort numOfStream = *mdHdr;  				mdHdr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdr' 8' 0x40' out old);  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdr' 4' 0x40' out old);  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 3;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 2;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 1;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  					}  				}  			}  			else //Flat  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				uint mdDir = *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;  				uint importDir = *(uint*)(ptr - 0x78);    				var vAdrs = new uint[sectNum];  				var vSizes = new uint[sectNum];  				var rAdrs = new uint[sectNum];  				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					vAdrs[i] = *(uint*)(ptr + 12);  					vSizes[i] = *(uint*)(ptr + 8);  					rAdrs[i] = *(uint*)(ptr + 20);  					ptr += 0x28;  				}      				if (importDir != 0) {  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= importDir && importDir < vAdrs[i] + vSizes[i]) {  							importDir = importDir - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* importDirPtr = bas + importDir;  					uint oftMod = *(uint*)importDirPtr;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= oftMod && oftMod < vAdrs[i] + vSizes[i]) {  							oftMod = oftMod - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* oftModPtr = bas + oftMod;  					uint modName = *(uint*)(importDirPtr + 12);  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= modName && modName < vAdrs[i] + vSizes[i]) {  							modName = modName - vAdrs[i] + rAdrs[i];  							break;  						}  					uint funcName = *(uint*)oftModPtr + 2;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= funcName && funcName < vAdrs[i] + vSizes[i]) {  							funcName = funcName - vAdrs[i] + rAdrs[i];  							break;  						}  					VirtualProtect(bas + modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + modName + i) = *(@new + i);    					VirtualProtect(bas + funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + funcName + i) = *(@new + i);  				}      				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdDir && mdDir < vAdrs[i] + vSizes[i]) {  						mdDir = mdDir - vAdrs[i] + rAdrs[i];  						break;  					}  				byte* mdDirPtr = bas + mdDir;  				VirtualProtect(mdDirPtr' 0x48' 0x40' out old);  				uint mdHdr = *(uint*)(mdDirPtr + 8);  				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdHdr && mdHdr < vAdrs[i] + vSizes[i]) {  						mdHdr = mdHdr - vAdrs[i] + rAdrs[i];  						break;  					}  				*(uint*)mdDirPtr = 0;  				*((uint*)mdDirPtr + 1) = 0;  				*((uint*)mdDirPtr + 2) = 0;  				*((uint*)mdDirPtr + 3) = 0;      				byte* mdHdrPtr = bas + mdHdr;  				VirtualProtect(mdHdrPtr' 4' 0x40' out old);  				*(uint*)mdHdrPtr = 0;  				mdHdrPtr += 12;  				mdHdrPtr += *(uint*)mdHdrPtr;  				mdHdrPtr = (byte*)(((ulong)mdHdrPtr + 7) & ~3UL);  				mdHdrPtr += 2;  				ushort numOfStream = *mdHdrPtr;  				mdHdrPtr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdrPtr' 8' 0x40' out old);  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdrPtr' 4' 0x40' out old);  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 3;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 2;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 1;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  					}  				}  			}
Magic Number,Confuser.Runtime,AntiDump,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiDump.cs,Initialize,The following statement contains a magic number: if (module.FullyQualifiedName[0] != '<') //Mapped  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				byte* mdDir = bas + *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;    				if (*(uint*)(ptr - 0x78) != 0) {  					byte* importDir = bas + *(uint*)(ptr - 0x78);  					byte* oftMod = bas + *(uint*)importDir;  					byte* modName = bas + *(uint*)(importDir + 12);  					byte* funcName = bas + *(uint*)oftMod + 2;  					VirtualProtect(modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(modName + i) = *(@new + i);    					VirtualProtect(funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(funcName + i) = *(@new + i);  				}    				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					ptr += 0x28;  				}  				VirtualProtect(mdDir' 0x48' 0x40' out old);  				byte* mdHdr = bas + *(uint*)(mdDir + 8);  				*(uint*)mdDir = 0;  				*((uint*)mdDir + 1) = 0;  				*((uint*)mdDir + 2) = 0;  				*((uint*)mdDir + 3) = 0;    				VirtualProtect(mdHdr' 4' 0x40' out old);  				*(uint*)mdHdr = 0;  				mdHdr += 12;  				mdHdr += *(uint*)mdHdr;  				mdHdr = (byte*)(((ulong)mdHdr + 7) & ~3UL);  				mdHdr += 2;  				ushort numOfStream = *mdHdr;  				mdHdr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdr' 8' 0x40' out old);  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdr' 4' 0x40' out old);  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 3;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 2;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 1;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  					}  				}  			}  			else //Flat  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				uint mdDir = *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;  				uint importDir = *(uint*)(ptr - 0x78);    				var vAdrs = new uint[sectNum];  				var vSizes = new uint[sectNum];  				var rAdrs = new uint[sectNum];  				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					vAdrs[i] = *(uint*)(ptr + 12);  					vSizes[i] = *(uint*)(ptr + 8);  					rAdrs[i] = *(uint*)(ptr + 20);  					ptr += 0x28;  				}      				if (importDir != 0) {  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= importDir && importDir < vAdrs[i] + vSizes[i]) {  							importDir = importDir - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* importDirPtr = bas + importDir;  					uint oftMod = *(uint*)importDirPtr;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= oftMod && oftMod < vAdrs[i] + vSizes[i]) {  							oftMod = oftMod - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* oftModPtr = bas + oftMod;  					uint modName = *(uint*)(importDirPtr + 12);  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= modName && modName < vAdrs[i] + vSizes[i]) {  							modName = modName - vAdrs[i] + rAdrs[i];  							break;  						}  					uint funcName = *(uint*)oftModPtr + 2;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= funcName && funcName < vAdrs[i] + vSizes[i]) {  							funcName = funcName - vAdrs[i] + rAdrs[i];  							break;  						}  					VirtualProtect(bas + modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + modName + i) = *(@new + i);    					VirtualProtect(bas + funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + funcName + i) = *(@new + i);  				}      				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdDir && mdDir < vAdrs[i] + vSizes[i]) {  						mdDir = mdDir - vAdrs[i] + rAdrs[i];  						break;  					}  				byte* mdDirPtr = bas + mdDir;  				VirtualProtect(mdDirPtr' 0x48' 0x40' out old);  				uint mdHdr = *(uint*)(mdDirPtr + 8);  				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdHdr && mdHdr < vAdrs[i] + vSizes[i]) {  						mdHdr = mdHdr - vAdrs[i] + rAdrs[i];  						break;  					}  				*(uint*)mdDirPtr = 0;  				*((uint*)mdDirPtr + 1) = 0;  				*((uint*)mdDirPtr + 2) = 0;  				*((uint*)mdDirPtr + 3) = 0;      				byte* mdHdrPtr = bas + mdHdr;  				VirtualProtect(mdHdrPtr' 4' 0x40' out old);  				*(uint*)mdHdrPtr = 0;  				mdHdrPtr += 12;  				mdHdrPtr += *(uint*)mdHdrPtr;  				mdHdrPtr = (byte*)(((ulong)mdHdrPtr + 7) & ~3UL);  				mdHdrPtr += 2;  				ushort numOfStream = *mdHdrPtr;  				mdHdrPtr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdrPtr' 8' 0x40' out old);  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdrPtr' 4' 0x40' out old);  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 3;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 2;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 1;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  					}  				}  			}
Magic Number,Confuser.Runtime,AntiDump,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiDump.cs,Initialize,The following statement contains a magic number: if (module.FullyQualifiedName[0] != '<') //Mapped  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				byte* mdDir = bas + *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;    				if (*(uint*)(ptr - 0x78) != 0) {  					byte* importDir = bas + *(uint*)(ptr - 0x78);  					byte* oftMod = bas + *(uint*)importDir;  					byte* modName = bas + *(uint*)(importDir + 12);  					byte* funcName = bas + *(uint*)oftMod + 2;  					VirtualProtect(modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(modName + i) = *(@new + i);    					VirtualProtect(funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(funcName + i) = *(@new + i);  				}    				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					ptr += 0x28;  				}  				VirtualProtect(mdDir' 0x48' 0x40' out old);  				byte* mdHdr = bas + *(uint*)(mdDir + 8);  				*(uint*)mdDir = 0;  				*((uint*)mdDir + 1) = 0;  				*((uint*)mdDir + 2) = 0;  				*((uint*)mdDir + 3) = 0;    				VirtualProtect(mdHdr' 4' 0x40' out old);  				*(uint*)mdHdr = 0;  				mdHdr += 12;  				mdHdr += *(uint*)mdHdr;  				mdHdr = (byte*)(((ulong)mdHdr + 7) & ~3UL);  				mdHdr += 2;  				ushort numOfStream = *mdHdr;  				mdHdr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdr' 8' 0x40' out old);  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdr' 4' 0x40' out old);  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 3;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 2;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 1;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  					}  				}  			}  			else //Flat  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				uint mdDir = *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;  				uint importDir = *(uint*)(ptr - 0x78);    				var vAdrs = new uint[sectNum];  				var vSizes = new uint[sectNum];  				var rAdrs = new uint[sectNum];  				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					vAdrs[i] = *(uint*)(ptr + 12);  					vSizes[i] = *(uint*)(ptr + 8);  					rAdrs[i] = *(uint*)(ptr + 20);  					ptr += 0x28;  				}      				if (importDir != 0) {  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= importDir && importDir < vAdrs[i] + vSizes[i]) {  							importDir = importDir - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* importDirPtr = bas + importDir;  					uint oftMod = *(uint*)importDirPtr;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= oftMod && oftMod < vAdrs[i] + vSizes[i]) {  							oftMod = oftMod - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* oftModPtr = bas + oftMod;  					uint modName = *(uint*)(importDirPtr + 12);  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= modName && modName < vAdrs[i] + vSizes[i]) {  							modName = modName - vAdrs[i] + rAdrs[i];  							break;  						}  					uint funcName = *(uint*)oftModPtr + 2;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= funcName && funcName < vAdrs[i] + vSizes[i]) {  							funcName = funcName - vAdrs[i] + rAdrs[i];  							break;  						}  					VirtualProtect(bas + modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + modName + i) = *(@new + i);    					VirtualProtect(bas + funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + funcName + i) = *(@new + i);  				}      				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdDir && mdDir < vAdrs[i] + vSizes[i]) {  						mdDir = mdDir - vAdrs[i] + rAdrs[i];  						break;  					}  				byte* mdDirPtr = bas + mdDir;  				VirtualProtect(mdDirPtr' 0x48' 0x40' out old);  				uint mdHdr = *(uint*)(mdDirPtr + 8);  				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdHdr && mdHdr < vAdrs[i] + vSizes[i]) {  						mdHdr = mdHdr - vAdrs[i] + rAdrs[i];  						break;  					}  				*(uint*)mdDirPtr = 0;  				*((uint*)mdDirPtr + 1) = 0;  				*((uint*)mdDirPtr + 2) = 0;  				*((uint*)mdDirPtr + 3) = 0;      				byte* mdHdrPtr = bas + mdHdr;  				VirtualProtect(mdHdrPtr' 4' 0x40' out old);  				*(uint*)mdHdrPtr = 0;  				mdHdrPtr += 12;  				mdHdrPtr += *(uint*)mdHdrPtr;  				mdHdrPtr = (byte*)(((ulong)mdHdrPtr + 7) & ~3UL);  				mdHdrPtr += 2;  				ushort numOfStream = *mdHdrPtr;  				mdHdrPtr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdrPtr' 8' 0x40' out old);  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdrPtr' 4' 0x40' out old);  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 3;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 2;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 1;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  					}  				}  			}
Magic Number,Confuser.Runtime,AntiDump,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiDump.cs,Initialize,The following statement contains a magic number: if (module.FullyQualifiedName[0] != '<') //Mapped  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				byte* mdDir = bas + *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;    				if (*(uint*)(ptr - 0x78) != 0) {  					byte* importDir = bas + *(uint*)(ptr - 0x78);  					byte* oftMod = bas + *(uint*)importDir;  					byte* modName = bas + *(uint*)(importDir + 12);  					byte* funcName = bas + *(uint*)oftMod + 2;  					VirtualProtect(modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(modName + i) = *(@new + i);    					VirtualProtect(funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(funcName + i) = *(@new + i);  				}    				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					ptr += 0x28;  				}  				VirtualProtect(mdDir' 0x48' 0x40' out old);  				byte* mdHdr = bas + *(uint*)(mdDir + 8);  				*(uint*)mdDir = 0;  				*((uint*)mdDir + 1) = 0;  				*((uint*)mdDir + 2) = 0;  				*((uint*)mdDir + 3) = 0;    				VirtualProtect(mdHdr' 4' 0x40' out old);  				*(uint*)mdHdr = 0;  				mdHdr += 12;  				mdHdr += *(uint*)mdHdr;  				mdHdr = (byte*)(((ulong)mdHdr + 7) & ~3UL);  				mdHdr += 2;  				ushort numOfStream = *mdHdr;  				mdHdr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdr' 8' 0x40' out old);  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdr' 4' 0x40' out old);  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 3;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 2;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 1;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  					}  				}  			}  			else //Flat  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				uint mdDir = *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;  				uint importDir = *(uint*)(ptr - 0x78);    				var vAdrs = new uint[sectNum];  				var vSizes = new uint[sectNum];  				var rAdrs = new uint[sectNum];  				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					vAdrs[i] = *(uint*)(ptr + 12);  					vSizes[i] = *(uint*)(ptr + 8);  					rAdrs[i] = *(uint*)(ptr + 20);  					ptr += 0x28;  				}      				if (importDir != 0) {  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= importDir && importDir < vAdrs[i] + vSizes[i]) {  							importDir = importDir - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* importDirPtr = bas + importDir;  					uint oftMod = *(uint*)importDirPtr;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= oftMod && oftMod < vAdrs[i] + vSizes[i]) {  							oftMod = oftMod - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* oftModPtr = bas + oftMod;  					uint modName = *(uint*)(importDirPtr + 12);  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= modName && modName < vAdrs[i] + vSizes[i]) {  							modName = modName - vAdrs[i] + rAdrs[i];  							break;  						}  					uint funcName = *(uint*)oftModPtr + 2;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= funcName && funcName < vAdrs[i] + vSizes[i]) {  							funcName = funcName - vAdrs[i] + rAdrs[i];  							break;  						}  					VirtualProtect(bas + modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + modName + i) = *(@new + i);    					VirtualProtect(bas + funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + funcName + i) = *(@new + i);  				}      				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdDir && mdDir < vAdrs[i] + vSizes[i]) {  						mdDir = mdDir - vAdrs[i] + rAdrs[i];  						break;  					}  				byte* mdDirPtr = bas + mdDir;  				VirtualProtect(mdDirPtr' 0x48' 0x40' out old);  				uint mdHdr = *(uint*)(mdDirPtr + 8);  				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdHdr && mdHdr < vAdrs[i] + vSizes[i]) {  						mdHdr = mdHdr - vAdrs[i] + rAdrs[i];  						break;  					}  				*(uint*)mdDirPtr = 0;  				*((uint*)mdDirPtr + 1) = 0;  				*((uint*)mdDirPtr + 2) = 0;  				*((uint*)mdDirPtr + 3) = 0;      				byte* mdHdrPtr = bas + mdHdr;  				VirtualProtect(mdHdrPtr' 4' 0x40' out old);  				*(uint*)mdHdrPtr = 0;  				mdHdrPtr += 12;  				mdHdrPtr += *(uint*)mdHdrPtr;  				mdHdrPtr = (byte*)(((ulong)mdHdrPtr + 7) & ~3UL);  				mdHdrPtr += 2;  				ushort numOfStream = *mdHdrPtr;  				mdHdrPtr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdrPtr' 8' 0x40' out old);  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdrPtr' 4' 0x40' out old);  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 3;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 2;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 1;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  					}  				}  			}
Magic Number,Confuser.Runtime,AntiDump,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiDump.cs,Initialize,The following statement contains a magic number: if (module.FullyQualifiedName[0] != '<') //Mapped  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				byte* mdDir = bas + *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;    				if (*(uint*)(ptr - 0x78) != 0) {  					byte* importDir = bas + *(uint*)(ptr - 0x78);  					byte* oftMod = bas + *(uint*)importDir;  					byte* modName = bas + *(uint*)(importDir + 12);  					byte* funcName = bas + *(uint*)oftMod + 2;  					VirtualProtect(modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(modName + i) = *(@new + i);    					VirtualProtect(funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(funcName + i) = *(@new + i);  				}    				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					ptr += 0x28;  				}  				VirtualProtect(mdDir' 0x48' 0x40' out old);  				byte* mdHdr = bas + *(uint*)(mdDir + 8);  				*(uint*)mdDir = 0;  				*((uint*)mdDir + 1) = 0;  				*((uint*)mdDir + 2) = 0;  				*((uint*)mdDir + 3) = 0;    				VirtualProtect(mdHdr' 4' 0x40' out old);  				*(uint*)mdHdr = 0;  				mdHdr += 12;  				mdHdr += *(uint*)mdHdr;  				mdHdr = (byte*)(((ulong)mdHdr + 7) & ~3UL);  				mdHdr += 2;  				ushort numOfStream = *mdHdr;  				mdHdr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdr' 8' 0x40' out old);  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdr' 4' 0x40' out old);  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 3;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 2;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 1;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  					}  				}  			}  			else //Flat  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				uint mdDir = *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;  				uint importDir = *(uint*)(ptr - 0x78);    				var vAdrs = new uint[sectNum];  				var vSizes = new uint[sectNum];  				var rAdrs = new uint[sectNum];  				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					vAdrs[i] = *(uint*)(ptr + 12);  					vSizes[i] = *(uint*)(ptr + 8);  					rAdrs[i] = *(uint*)(ptr + 20);  					ptr += 0x28;  				}      				if (importDir != 0) {  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= importDir && importDir < vAdrs[i] + vSizes[i]) {  							importDir = importDir - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* importDirPtr = bas + importDir;  					uint oftMod = *(uint*)importDirPtr;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= oftMod && oftMod < vAdrs[i] + vSizes[i]) {  							oftMod = oftMod - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* oftModPtr = bas + oftMod;  					uint modName = *(uint*)(importDirPtr + 12);  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= modName && modName < vAdrs[i] + vSizes[i]) {  							modName = modName - vAdrs[i] + rAdrs[i];  							break;  						}  					uint funcName = *(uint*)oftModPtr + 2;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= funcName && funcName < vAdrs[i] + vSizes[i]) {  							funcName = funcName - vAdrs[i] + rAdrs[i];  							break;  						}  					VirtualProtect(bas + modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + modName + i) = *(@new + i);    					VirtualProtect(bas + funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + funcName + i) = *(@new + i);  				}      				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdDir && mdDir < vAdrs[i] + vSizes[i]) {  						mdDir = mdDir - vAdrs[i] + rAdrs[i];  						break;  					}  				byte* mdDirPtr = bas + mdDir;  				VirtualProtect(mdDirPtr' 0x48' 0x40' out old);  				uint mdHdr = *(uint*)(mdDirPtr + 8);  				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdHdr && mdHdr < vAdrs[i] + vSizes[i]) {  						mdHdr = mdHdr - vAdrs[i] + rAdrs[i];  						break;  					}  				*(uint*)mdDirPtr = 0;  				*((uint*)mdDirPtr + 1) = 0;  				*((uint*)mdDirPtr + 2) = 0;  				*((uint*)mdDirPtr + 3) = 0;      				byte* mdHdrPtr = bas + mdHdr;  				VirtualProtect(mdHdrPtr' 4' 0x40' out old);  				*(uint*)mdHdrPtr = 0;  				mdHdrPtr += 12;  				mdHdrPtr += *(uint*)mdHdrPtr;  				mdHdrPtr = (byte*)(((ulong)mdHdrPtr + 7) & ~3UL);  				mdHdrPtr += 2;  				ushort numOfStream = *mdHdrPtr;  				mdHdrPtr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdrPtr' 8' 0x40' out old);  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdrPtr' 4' 0x40' out old);  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 3;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 2;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 1;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  					}  				}  			}
Magic Number,Confuser.Runtime,AntiDump,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiDump.cs,Initialize,The following statement contains a magic number: if (module.FullyQualifiedName[0] != '<') //Mapped  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				byte* mdDir = bas + *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;    				if (*(uint*)(ptr - 0x78) != 0) {  					byte* importDir = bas + *(uint*)(ptr - 0x78);  					byte* oftMod = bas + *(uint*)importDir;  					byte* modName = bas + *(uint*)(importDir + 12);  					byte* funcName = bas + *(uint*)oftMod + 2;  					VirtualProtect(modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(modName + i) = *(@new + i);    					VirtualProtect(funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(funcName + i) = *(@new + i);  				}    				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					ptr += 0x28;  				}  				VirtualProtect(mdDir' 0x48' 0x40' out old);  				byte* mdHdr = bas + *(uint*)(mdDir + 8);  				*(uint*)mdDir = 0;  				*((uint*)mdDir + 1) = 0;  				*((uint*)mdDir + 2) = 0;  				*((uint*)mdDir + 3) = 0;    				VirtualProtect(mdHdr' 4' 0x40' out old);  				*(uint*)mdHdr = 0;  				mdHdr += 12;  				mdHdr += *(uint*)mdHdr;  				mdHdr = (byte*)(((ulong)mdHdr + 7) & ~3UL);  				mdHdr += 2;  				ushort numOfStream = *mdHdr;  				mdHdr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdr' 8' 0x40' out old);  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdr' 4' 0x40' out old);  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 3;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 2;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 1;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  					}  				}  			}  			else //Flat  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				uint mdDir = *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;  				uint importDir = *(uint*)(ptr - 0x78);    				var vAdrs = new uint[sectNum];  				var vSizes = new uint[sectNum];  				var rAdrs = new uint[sectNum];  				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					vAdrs[i] = *(uint*)(ptr + 12);  					vSizes[i] = *(uint*)(ptr + 8);  					rAdrs[i] = *(uint*)(ptr + 20);  					ptr += 0x28;  				}      				if (importDir != 0) {  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= importDir && importDir < vAdrs[i] + vSizes[i]) {  							importDir = importDir - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* importDirPtr = bas + importDir;  					uint oftMod = *(uint*)importDirPtr;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= oftMod && oftMod < vAdrs[i] + vSizes[i]) {  							oftMod = oftMod - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* oftModPtr = bas + oftMod;  					uint modName = *(uint*)(importDirPtr + 12);  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= modName && modName < vAdrs[i] + vSizes[i]) {  							modName = modName - vAdrs[i] + rAdrs[i];  							break;  						}  					uint funcName = *(uint*)oftModPtr + 2;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= funcName && funcName < vAdrs[i] + vSizes[i]) {  							funcName = funcName - vAdrs[i] + rAdrs[i];  							break;  						}  					VirtualProtect(bas + modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + modName + i) = *(@new + i);    					VirtualProtect(bas + funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + funcName + i) = *(@new + i);  				}      				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdDir && mdDir < vAdrs[i] + vSizes[i]) {  						mdDir = mdDir - vAdrs[i] + rAdrs[i];  						break;  					}  				byte* mdDirPtr = bas + mdDir;  				VirtualProtect(mdDirPtr' 0x48' 0x40' out old);  				uint mdHdr = *(uint*)(mdDirPtr + 8);  				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdHdr && mdHdr < vAdrs[i] + vSizes[i]) {  						mdHdr = mdHdr - vAdrs[i] + rAdrs[i];  						break;  					}  				*(uint*)mdDirPtr = 0;  				*((uint*)mdDirPtr + 1) = 0;  				*((uint*)mdDirPtr + 2) = 0;  				*((uint*)mdDirPtr + 3) = 0;      				byte* mdHdrPtr = bas + mdHdr;  				VirtualProtect(mdHdrPtr' 4' 0x40' out old);  				*(uint*)mdHdrPtr = 0;  				mdHdrPtr += 12;  				mdHdrPtr += *(uint*)mdHdrPtr;  				mdHdrPtr = (byte*)(((ulong)mdHdrPtr + 7) & ~3UL);  				mdHdrPtr += 2;  				ushort numOfStream = *mdHdrPtr;  				mdHdrPtr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdrPtr' 8' 0x40' out old);  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdrPtr' 4' 0x40' out old);  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 3;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 2;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 1;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  					}  				}  			}
Magic Number,Confuser.Runtime,AntiDump,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiDump.cs,Initialize,The following statement contains a magic number: if (module.FullyQualifiedName[0] != '<') //Mapped  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				byte* mdDir = bas + *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;    				if (*(uint*)(ptr - 0x78) != 0) {  					byte* importDir = bas + *(uint*)(ptr - 0x78);  					byte* oftMod = bas + *(uint*)importDir;  					byte* modName = bas + *(uint*)(importDir + 12);  					byte* funcName = bas + *(uint*)oftMod + 2;  					VirtualProtect(modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(modName + i) = *(@new + i);    					VirtualProtect(funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(funcName + i) = *(@new + i);  				}    				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					ptr += 0x28;  				}  				VirtualProtect(mdDir' 0x48' 0x40' out old);  				byte* mdHdr = bas + *(uint*)(mdDir + 8);  				*(uint*)mdDir = 0;  				*((uint*)mdDir + 1) = 0;  				*((uint*)mdDir + 2) = 0;  				*((uint*)mdDir + 3) = 0;    				VirtualProtect(mdHdr' 4' 0x40' out old);  				*(uint*)mdHdr = 0;  				mdHdr += 12;  				mdHdr += *(uint*)mdHdr;  				mdHdr = (byte*)(((ulong)mdHdr + 7) & ~3UL);  				mdHdr += 2;  				ushort numOfStream = *mdHdr;  				mdHdr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdr' 8' 0x40' out old);  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdr' 4' 0x40' out old);  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 3;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 2;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 1;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  					}  				}  			}  			else //Flat  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				uint mdDir = *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;  				uint importDir = *(uint*)(ptr - 0x78);    				var vAdrs = new uint[sectNum];  				var vSizes = new uint[sectNum];  				var rAdrs = new uint[sectNum];  				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					vAdrs[i] = *(uint*)(ptr + 12);  					vSizes[i] = *(uint*)(ptr + 8);  					rAdrs[i] = *(uint*)(ptr + 20);  					ptr += 0x28;  				}      				if (importDir != 0) {  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= importDir && importDir < vAdrs[i] + vSizes[i]) {  							importDir = importDir - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* importDirPtr = bas + importDir;  					uint oftMod = *(uint*)importDirPtr;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= oftMod && oftMod < vAdrs[i] + vSizes[i]) {  							oftMod = oftMod - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* oftModPtr = bas + oftMod;  					uint modName = *(uint*)(importDirPtr + 12);  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= modName && modName < vAdrs[i] + vSizes[i]) {  							modName = modName - vAdrs[i] + rAdrs[i];  							break;  						}  					uint funcName = *(uint*)oftModPtr + 2;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= funcName && funcName < vAdrs[i] + vSizes[i]) {  							funcName = funcName - vAdrs[i] + rAdrs[i];  							break;  						}  					VirtualProtect(bas + modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + modName + i) = *(@new + i);    					VirtualProtect(bas + funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + funcName + i) = *(@new + i);  				}      				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdDir && mdDir < vAdrs[i] + vSizes[i]) {  						mdDir = mdDir - vAdrs[i] + rAdrs[i];  						break;  					}  				byte* mdDirPtr = bas + mdDir;  				VirtualProtect(mdDirPtr' 0x48' 0x40' out old);  				uint mdHdr = *(uint*)(mdDirPtr + 8);  				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdHdr && mdHdr < vAdrs[i] + vSizes[i]) {  						mdHdr = mdHdr - vAdrs[i] + rAdrs[i];  						break;  					}  				*(uint*)mdDirPtr = 0;  				*((uint*)mdDirPtr + 1) = 0;  				*((uint*)mdDirPtr + 2) = 0;  				*((uint*)mdDirPtr + 3) = 0;      				byte* mdHdrPtr = bas + mdHdr;  				VirtualProtect(mdHdrPtr' 4' 0x40' out old);  				*(uint*)mdHdrPtr = 0;  				mdHdrPtr += 12;  				mdHdrPtr += *(uint*)mdHdrPtr;  				mdHdrPtr = (byte*)(((ulong)mdHdrPtr + 7) & ~3UL);  				mdHdrPtr += 2;  				ushort numOfStream = *mdHdrPtr;  				mdHdrPtr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdrPtr' 8' 0x40' out old);  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdrPtr' 4' 0x40' out old);  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 3;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 2;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 1;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  					}  				}  			}
Magic Number,Confuser.Runtime,AntiDump,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiDump.cs,Initialize,The following statement contains a magic number: if (module.FullyQualifiedName[0] != '<') //Mapped  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				byte* mdDir = bas + *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;    				if (*(uint*)(ptr - 0x78) != 0) {  					byte* importDir = bas + *(uint*)(ptr - 0x78);  					byte* oftMod = bas + *(uint*)importDir;  					byte* modName = bas + *(uint*)(importDir + 12);  					byte* funcName = bas + *(uint*)oftMod + 2;  					VirtualProtect(modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(modName + i) = *(@new + i);    					VirtualProtect(funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(funcName + i) = *(@new + i);  				}    				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					ptr += 0x28;  				}  				VirtualProtect(mdDir' 0x48' 0x40' out old);  				byte* mdHdr = bas + *(uint*)(mdDir + 8);  				*(uint*)mdDir = 0;  				*((uint*)mdDir + 1) = 0;  				*((uint*)mdDir + 2) = 0;  				*((uint*)mdDir + 3) = 0;    				VirtualProtect(mdHdr' 4' 0x40' out old);  				*(uint*)mdHdr = 0;  				mdHdr += 12;  				mdHdr += *(uint*)mdHdr;  				mdHdr = (byte*)(((ulong)mdHdr + 7) & ~3UL);  				mdHdr += 2;  				ushort numOfStream = *mdHdr;  				mdHdr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdr' 8' 0x40' out old);  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdr' 4' 0x40' out old);  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 3;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 2;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 1;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  					}  				}  			}  			else //Flat  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				uint mdDir = *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;  				uint importDir = *(uint*)(ptr - 0x78);    				var vAdrs = new uint[sectNum];  				var vSizes = new uint[sectNum];  				var rAdrs = new uint[sectNum];  				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					vAdrs[i] = *(uint*)(ptr + 12);  					vSizes[i] = *(uint*)(ptr + 8);  					rAdrs[i] = *(uint*)(ptr + 20);  					ptr += 0x28;  				}      				if (importDir != 0) {  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= importDir && importDir < vAdrs[i] + vSizes[i]) {  							importDir = importDir - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* importDirPtr = bas + importDir;  					uint oftMod = *(uint*)importDirPtr;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= oftMod && oftMod < vAdrs[i] + vSizes[i]) {  							oftMod = oftMod - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* oftModPtr = bas + oftMod;  					uint modName = *(uint*)(importDirPtr + 12);  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= modName && modName < vAdrs[i] + vSizes[i]) {  							modName = modName - vAdrs[i] + rAdrs[i];  							break;  						}  					uint funcName = *(uint*)oftModPtr + 2;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= funcName && funcName < vAdrs[i] + vSizes[i]) {  							funcName = funcName - vAdrs[i] + rAdrs[i];  							break;  						}  					VirtualProtect(bas + modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + modName + i) = *(@new + i);    					VirtualProtect(bas + funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + funcName + i) = *(@new + i);  				}      				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdDir && mdDir < vAdrs[i] + vSizes[i]) {  						mdDir = mdDir - vAdrs[i] + rAdrs[i];  						break;  					}  				byte* mdDirPtr = bas + mdDir;  				VirtualProtect(mdDirPtr' 0x48' 0x40' out old);  				uint mdHdr = *(uint*)(mdDirPtr + 8);  				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdHdr && mdHdr < vAdrs[i] + vSizes[i]) {  						mdHdr = mdHdr - vAdrs[i] + rAdrs[i];  						break;  					}  				*(uint*)mdDirPtr = 0;  				*((uint*)mdDirPtr + 1) = 0;  				*((uint*)mdDirPtr + 2) = 0;  				*((uint*)mdDirPtr + 3) = 0;      				byte* mdHdrPtr = bas + mdHdr;  				VirtualProtect(mdHdrPtr' 4' 0x40' out old);  				*(uint*)mdHdrPtr = 0;  				mdHdrPtr += 12;  				mdHdrPtr += *(uint*)mdHdrPtr;  				mdHdrPtr = (byte*)(((ulong)mdHdrPtr + 7) & ~3UL);  				mdHdrPtr += 2;  				ushort numOfStream = *mdHdrPtr;  				mdHdrPtr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdrPtr' 8' 0x40' out old);  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdrPtr' 4' 0x40' out old);  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 3;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 2;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 1;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  					}  				}  			}
Magic Number,Confuser.Runtime,AntiDump,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiDump.cs,Initialize,The following statement contains a magic number: if (module.FullyQualifiedName[0] != '<') //Mapped  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				byte* mdDir = bas + *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;    				if (*(uint*)(ptr - 0x78) != 0) {  					byte* importDir = bas + *(uint*)(ptr - 0x78);  					byte* oftMod = bas + *(uint*)importDir;  					byte* modName = bas + *(uint*)(importDir + 12);  					byte* funcName = bas + *(uint*)oftMod + 2;  					VirtualProtect(modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(modName + i) = *(@new + i);    					VirtualProtect(funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(funcName + i) = *(@new + i);  				}    				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					ptr += 0x28;  				}  				VirtualProtect(mdDir' 0x48' 0x40' out old);  				byte* mdHdr = bas + *(uint*)(mdDir + 8);  				*(uint*)mdDir = 0;  				*((uint*)mdDir + 1) = 0;  				*((uint*)mdDir + 2) = 0;  				*((uint*)mdDir + 3) = 0;    				VirtualProtect(mdHdr' 4' 0x40' out old);  				*(uint*)mdHdr = 0;  				mdHdr += 12;  				mdHdr += *(uint*)mdHdr;  				mdHdr = (byte*)(((ulong)mdHdr + 7) & ~3UL);  				mdHdr += 2;  				ushort numOfStream = *mdHdr;  				mdHdr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdr' 8' 0x40' out old);  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdr' 4' 0x40' out old);  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 3;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 2;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 1;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  					}  				}  			}  			else //Flat  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				uint mdDir = *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;  				uint importDir = *(uint*)(ptr - 0x78);    				var vAdrs = new uint[sectNum];  				var vSizes = new uint[sectNum];  				var rAdrs = new uint[sectNum];  				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					vAdrs[i] = *(uint*)(ptr + 12);  					vSizes[i] = *(uint*)(ptr + 8);  					rAdrs[i] = *(uint*)(ptr + 20);  					ptr += 0x28;  				}      				if (importDir != 0) {  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= importDir && importDir < vAdrs[i] + vSizes[i]) {  							importDir = importDir - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* importDirPtr = bas + importDir;  					uint oftMod = *(uint*)importDirPtr;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= oftMod && oftMod < vAdrs[i] + vSizes[i]) {  							oftMod = oftMod - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* oftModPtr = bas + oftMod;  					uint modName = *(uint*)(importDirPtr + 12);  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= modName && modName < vAdrs[i] + vSizes[i]) {  							modName = modName - vAdrs[i] + rAdrs[i];  							break;  						}  					uint funcName = *(uint*)oftModPtr + 2;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= funcName && funcName < vAdrs[i] + vSizes[i]) {  							funcName = funcName - vAdrs[i] + rAdrs[i];  							break;  						}  					VirtualProtect(bas + modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + modName + i) = *(@new + i);    					VirtualProtect(bas + funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + funcName + i) = *(@new + i);  				}      				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdDir && mdDir < vAdrs[i] + vSizes[i]) {  						mdDir = mdDir - vAdrs[i] + rAdrs[i];  						break;  					}  				byte* mdDirPtr = bas + mdDir;  				VirtualProtect(mdDirPtr' 0x48' 0x40' out old);  				uint mdHdr = *(uint*)(mdDirPtr + 8);  				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdHdr && mdHdr < vAdrs[i] + vSizes[i]) {  						mdHdr = mdHdr - vAdrs[i] + rAdrs[i];  						break;  					}  				*(uint*)mdDirPtr = 0;  				*((uint*)mdDirPtr + 1) = 0;  				*((uint*)mdDirPtr + 2) = 0;  				*((uint*)mdDirPtr + 3) = 0;      				byte* mdHdrPtr = bas + mdHdr;  				VirtualProtect(mdHdrPtr' 4' 0x40' out old);  				*(uint*)mdHdrPtr = 0;  				mdHdrPtr += 12;  				mdHdrPtr += *(uint*)mdHdrPtr;  				mdHdrPtr = (byte*)(((ulong)mdHdrPtr + 7) & ~3UL);  				mdHdrPtr += 2;  				ushort numOfStream = *mdHdrPtr;  				mdHdrPtr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdrPtr' 8' 0x40' out old);  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdrPtr' 4' 0x40' out old);  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 3;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 2;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 1;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  					}  				}  			}
Magic Number,Confuser.Runtime,AntiDump,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiDump.cs,Initialize,The following statement contains a magic number: if (module.FullyQualifiedName[0] != '<') //Mapped  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				byte* mdDir = bas + *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;    				if (*(uint*)(ptr - 0x78) != 0) {  					byte* importDir = bas + *(uint*)(ptr - 0x78);  					byte* oftMod = bas + *(uint*)importDir;  					byte* modName = bas + *(uint*)(importDir + 12);  					byte* funcName = bas + *(uint*)oftMod + 2;  					VirtualProtect(modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(modName + i) = *(@new + i);    					VirtualProtect(funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(funcName + i) = *(@new + i);  				}    				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					ptr += 0x28;  				}  				VirtualProtect(mdDir' 0x48' 0x40' out old);  				byte* mdHdr = bas + *(uint*)(mdDir + 8);  				*(uint*)mdDir = 0;  				*((uint*)mdDir + 1) = 0;  				*((uint*)mdDir + 2) = 0;  				*((uint*)mdDir + 3) = 0;    				VirtualProtect(mdHdr' 4' 0x40' out old);  				*(uint*)mdHdr = 0;  				mdHdr += 12;  				mdHdr += *(uint*)mdHdr;  				mdHdr = (byte*)(((ulong)mdHdr + 7) & ~3UL);  				mdHdr += 2;  				ushort numOfStream = *mdHdr;  				mdHdr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdr' 8' 0x40' out old);  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdr' 4' 0x40' out old);  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 3;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 2;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 1;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  					}  				}  			}  			else //Flat  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				uint mdDir = *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;  				uint importDir = *(uint*)(ptr - 0x78);    				var vAdrs = new uint[sectNum];  				var vSizes = new uint[sectNum];  				var rAdrs = new uint[sectNum];  				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					vAdrs[i] = *(uint*)(ptr + 12);  					vSizes[i] = *(uint*)(ptr + 8);  					rAdrs[i] = *(uint*)(ptr + 20);  					ptr += 0x28;  				}      				if (importDir != 0) {  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= importDir && importDir < vAdrs[i] + vSizes[i]) {  							importDir = importDir - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* importDirPtr = bas + importDir;  					uint oftMod = *(uint*)importDirPtr;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= oftMod && oftMod < vAdrs[i] + vSizes[i]) {  							oftMod = oftMod - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* oftModPtr = bas + oftMod;  					uint modName = *(uint*)(importDirPtr + 12);  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= modName && modName < vAdrs[i] + vSizes[i]) {  							modName = modName - vAdrs[i] + rAdrs[i];  							break;  						}  					uint funcName = *(uint*)oftModPtr + 2;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= funcName && funcName < vAdrs[i] + vSizes[i]) {  							funcName = funcName - vAdrs[i] + rAdrs[i];  							break;  						}  					VirtualProtect(bas + modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + modName + i) = *(@new + i);    					VirtualProtect(bas + funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + funcName + i) = *(@new + i);  				}      				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdDir && mdDir < vAdrs[i] + vSizes[i]) {  						mdDir = mdDir - vAdrs[i] + rAdrs[i];  						break;  					}  				byte* mdDirPtr = bas + mdDir;  				VirtualProtect(mdDirPtr' 0x48' 0x40' out old);  				uint mdHdr = *(uint*)(mdDirPtr + 8);  				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdHdr && mdHdr < vAdrs[i] + vSizes[i]) {  						mdHdr = mdHdr - vAdrs[i] + rAdrs[i];  						break;  					}  				*(uint*)mdDirPtr = 0;  				*((uint*)mdDirPtr + 1) = 0;  				*((uint*)mdDirPtr + 2) = 0;  				*((uint*)mdDirPtr + 3) = 0;      				byte* mdHdrPtr = bas + mdHdr;  				VirtualProtect(mdHdrPtr' 4' 0x40' out old);  				*(uint*)mdHdrPtr = 0;  				mdHdrPtr += 12;  				mdHdrPtr += *(uint*)mdHdrPtr;  				mdHdrPtr = (byte*)(((ulong)mdHdrPtr + 7) & ~3UL);  				mdHdrPtr += 2;  				ushort numOfStream = *mdHdrPtr;  				mdHdrPtr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdrPtr' 8' 0x40' out old);  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdrPtr' 4' 0x40' out old);  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 3;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 2;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 1;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  					}  				}  			}
Magic Number,Confuser.Runtime,AntiDump,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiDump.cs,Initialize,The following statement contains a magic number: if (module.FullyQualifiedName[0] != '<') //Mapped  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				byte* mdDir = bas + *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;    				if (*(uint*)(ptr - 0x78) != 0) {  					byte* importDir = bas + *(uint*)(ptr - 0x78);  					byte* oftMod = bas + *(uint*)importDir;  					byte* modName = bas + *(uint*)(importDir + 12);  					byte* funcName = bas + *(uint*)oftMod + 2;  					VirtualProtect(modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(modName + i) = *(@new + i);    					VirtualProtect(funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(funcName + i) = *(@new + i);  				}    				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					ptr += 0x28;  				}  				VirtualProtect(mdDir' 0x48' 0x40' out old);  				byte* mdHdr = bas + *(uint*)(mdDir + 8);  				*(uint*)mdDir = 0;  				*((uint*)mdDir + 1) = 0;  				*((uint*)mdDir + 2) = 0;  				*((uint*)mdDir + 3) = 0;    				VirtualProtect(mdHdr' 4' 0x40' out old);  				*(uint*)mdHdr = 0;  				mdHdr += 12;  				mdHdr += *(uint*)mdHdr;  				mdHdr = (byte*)(((ulong)mdHdr + 7) & ~3UL);  				mdHdr += 2;  				ushort numOfStream = *mdHdr;  				mdHdr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdr' 8' 0x40' out old);  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdr' 4' 0x40' out old);  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 3;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 2;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 1;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  					}  				}  			}  			else //Flat  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				uint mdDir = *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;  				uint importDir = *(uint*)(ptr - 0x78);    				var vAdrs = new uint[sectNum];  				var vSizes = new uint[sectNum];  				var rAdrs = new uint[sectNum];  				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					vAdrs[i] = *(uint*)(ptr + 12);  					vSizes[i] = *(uint*)(ptr + 8);  					rAdrs[i] = *(uint*)(ptr + 20);  					ptr += 0x28;  				}      				if (importDir != 0) {  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= importDir && importDir < vAdrs[i] + vSizes[i]) {  							importDir = importDir - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* importDirPtr = bas + importDir;  					uint oftMod = *(uint*)importDirPtr;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= oftMod && oftMod < vAdrs[i] + vSizes[i]) {  							oftMod = oftMod - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* oftModPtr = bas + oftMod;  					uint modName = *(uint*)(importDirPtr + 12);  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= modName && modName < vAdrs[i] + vSizes[i]) {  							modName = modName - vAdrs[i] + rAdrs[i];  							break;  						}  					uint funcName = *(uint*)oftModPtr + 2;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= funcName && funcName < vAdrs[i] + vSizes[i]) {  							funcName = funcName - vAdrs[i] + rAdrs[i];  							break;  						}  					VirtualProtect(bas + modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + modName + i) = *(@new + i);    					VirtualProtect(bas + funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + funcName + i) = *(@new + i);  				}      				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdDir && mdDir < vAdrs[i] + vSizes[i]) {  						mdDir = mdDir - vAdrs[i] + rAdrs[i];  						break;  					}  				byte* mdDirPtr = bas + mdDir;  				VirtualProtect(mdDirPtr' 0x48' 0x40' out old);  				uint mdHdr = *(uint*)(mdDirPtr + 8);  				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdHdr && mdHdr < vAdrs[i] + vSizes[i]) {  						mdHdr = mdHdr - vAdrs[i] + rAdrs[i];  						break;  					}  				*(uint*)mdDirPtr = 0;  				*((uint*)mdDirPtr + 1) = 0;  				*((uint*)mdDirPtr + 2) = 0;  				*((uint*)mdDirPtr + 3) = 0;      				byte* mdHdrPtr = bas + mdHdr;  				VirtualProtect(mdHdrPtr' 4' 0x40' out old);  				*(uint*)mdHdrPtr = 0;  				mdHdrPtr += 12;  				mdHdrPtr += *(uint*)mdHdrPtr;  				mdHdrPtr = (byte*)(((ulong)mdHdrPtr + 7) & ~3UL);  				mdHdrPtr += 2;  				ushort numOfStream = *mdHdrPtr;  				mdHdrPtr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdrPtr' 8' 0x40' out old);  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdrPtr' 4' 0x40' out old);  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 3;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 2;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 1;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  					}  				}  			}
Magic Number,Confuser.Runtime,AntiDump,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiDump.cs,Initialize,The following statement contains a magic number: if (module.FullyQualifiedName[0] != '<') //Mapped  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				byte* mdDir = bas + *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;    				if (*(uint*)(ptr - 0x78) != 0) {  					byte* importDir = bas + *(uint*)(ptr - 0x78);  					byte* oftMod = bas + *(uint*)importDir;  					byte* modName = bas + *(uint*)(importDir + 12);  					byte* funcName = bas + *(uint*)oftMod + 2;  					VirtualProtect(modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(modName + i) = *(@new + i);    					VirtualProtect(funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(funcName + i) = *(@new + i);  				}    				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					ptr += 0x28;  				}  				VirtualProtect(mdDir' 0x48' 0x40' out old);  				byte* mdHdr = bas + *(uint*)(mdDir + 8);  				*(uint*)mdDir = 0;  				*((uint*)mdDir + 1) = 0;  				*((uint*)mdDir + 2) = 0;  				*((uint*)mdDir + 3) = 0;    				VirtualProtect(mdHdr' 4' 0x40' out old);  				*(uint*)mdHdr = 0;  				mdHdr += 12;  				mdHdr += *(uint*)mdHdr;  				mdHdr = (byte*)(((ulong)mdHdr + 7) & ~3UL);  				mdHdr += 2;  				ushort numOfStream = *mdHdr;  				mdHdr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdr' 8' 0x40' out old);  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdr' 4' 0x40' out old);  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 3;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 2;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 1;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  					}  				}  			}  			else //Flat  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				uint mdDir = *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;  				uint importDir = *(uint*)(ptr - 0x78);    				var vAdrs = new uint[sectNum];  				var vSizes = new uint[sectNum];  				var rAdrs = new uint[sectNum];  				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					vAdrs[i] = *(uint*)(ptr + 12);  					vSizes[i] = *(uint*)(ptr + 8);  					rAdrs[i] = *(uint*)(ptr + 20);  					ptr += 0x28;  				}      				if (importDir != 0) {  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= importDir && importDir < vAdrs[i] + vSizes[i]) {  							importDir = importDir - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* importDirPtr = bas + importDir;  					uint oftMod = *(uint*)importDirPtr;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= oftMod && oftMod < vAdrs[i] + vSizes[i]) {  							oftMod = oftMod - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* oftModPtr = bas + oftMod;  					uint modName = *(uint*)(importDirPtr + 12);  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= modName && modName < vAdrs[i] + vSizes[i]) {  							modName = modName - vAdrs[i] + rAdrs[i];  							break;  						}  					uint funcName = *(uint*)oftModPtr + 2;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= funcName && funcName < vAdrs[i] + vSizes[i]) {  							funcName = funcName - vAdrs[i] + rAdrs[i];  							break;  						}  					VirtualProtect(bas + modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + modName + i) = *(@new + i);    					VirtualProtect(bas + funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + funcName + i) = *(@new + i);  				}      				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdDir && mdDir < vAdrs[i] + vSizes[i]) {  						mdDir = mdDir - vAdrs[i] + rAdrs[i];  						break;  					}  				byte* mdDirPtr = bas + mdDir;  				VirtualProtect(mdDirPtr' 0x48' 0x40' out old);  				uint mdHdr = *(uint*)(mdDirPtr + 8);  				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdHdr && mdHdr < vAdrs[i] + vSizes[i]) {  						mdHdr = mdHdr - vAdrs[i] + rAdrs[i];  						break;  					}  				*(uint*)mdDirPtr = 0;  				*((uint*)mdDirPtr + 1) = 0;  				*((uint*)mdDirPtr + 2) = 0;  				*((uint*)mdDirPtr + 3) = 0;      				byte* mdHdrPtr = bas + mdHdr;  				VirtualProtect(mdHdrPtr' 4' 0x40' out old);  				*(uint*)mdHdrPtr = 0;  				mdHdrPtr += 12;  				mdHdrPtr += *(uint*)mdHdrPtr;  				mdHdrPtr = (byte*)(((ulong)mdHdrPtr + 7) & ~3UL);  				mdHdrPtr += 2;  				ushort numOfStream = *mdHdrPtr;  				mdHdrPtr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdrPtr' 8' 0x40' out old);  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdrPtr' 4' 0x40' out old);  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 3;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 2;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 1;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  					}  				}  			}
Magic Number,Confuser.Runtime,AntiDump,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiDump.cs,Initialize,The following statement contains a magic number: if (module.FullyQualifiedName[0] != '<') //Mapped  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				byte* mdDir = bas + *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;    				if (*(uint*)(ptr - 0x78) != 0) {  					byte* importDir = bas + *(uint*)(ptr - 0x78);  					byte* oftMod = bas + *(uint*)importDir;  					byte* modName = bas + *(uint*)(importDir + 12);  					byte* funcName = bas + *(uint*)oftMod + 2;  					VirtualProtect(modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(modName + i) = *(@new + i);    					VirtualProtect(funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(funcName + i) = *(@new + i);  				}    				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					ptr += 0x28;  				}  				VirtualProtect(mdDir' 0x48' 0x40' out old);  				byte* mdHdr = bas + *(uint*)(mdDir + 8);  				*(uint*)mdDir = 0;  				*((uint*)mdDir + 1) = 0;  				*((uint*)mdDir + 2) = 0;  				*((uint*)mdDir + 3) = 0;    				VirtualProtect(mdHdr' 4' 0x40' out old);  				*(uint*)mdHdr = 0;  				mdHdr += 12;  				mdHdr += *(uint*)mdHdr;  				mdHdr = (byte*)(((ulong)mdHdr + 7) & ~3UL);  				mdHdr += 2;  				ushort numOfStream = *mdHdr;  				mdHdr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdr' 8' 0x40' out old);  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdr' 4' 0x40' out old);  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 3;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 2;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 1;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  					}  				}  			}  			else //Flat  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				uint mdDir = *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;  				uint importDir = *(uint*)(ptr - 0x78);    				var vAdrs = new uint[sectNum];  				var vSizes = new uint[sectNum];  				var rAdrs = new uint[sectNum];  				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					vAdrs[i] = *(uint*)(ptr + 12);  					vSizes[i] = *(uint*)(ptr + 8);  					rAdrs[i] = *(uint*)(ptr + 20);  					ptr += 0x28;  				}      				if (importDir != 0) {  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= importDir && importDir < vAdrs[i] + vSizes[i]) {  							importDir = importDir - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* importDirPtr = bas + importDir;  					uint oftMod = *(uint*)importDirPtr;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= oftMod && oftMod < vAdrs[i] + vSizes[i]) {  							oftMod = oftMod - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* oftModPtr = bas + oftMod;  					uint modName = *(uint*)(importDirPtr + 12);  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= modName && modName < vAdrs[i] + vSizes[i]) {  							modName = modName - vAdrs[i] + rAdrs[i];  							break;  						}  					uint funcName = *(uint*)oftModPtr + 2;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= funcName && funcName < vAdrs[i] + vSizes[i]) {  							funcName = funcName - vAdrs[i] + rAdrs[i];  							break;  						}  					VirtualProtect(bas + modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + modName + i) = *(@new + i);    					VirtualProtect(bas + funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + funcName + i) = *(@new + i);  				}      				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdDir && mdDir < vAdrs[i] + vSizes[i]) {  						mdDir = mdDir - vAdrs[i] + rAdrs[i];  						break;  					}  				byte* mdDirPtr = bas + mdDir;  				VirtualProtect(mdDirPtr' 0x48' 0x40' out old);  				uint mdHdr = *(uint*)(mdDirPtr + 8);  				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdHdr && mdHdr < vAdrs[i] + vSizes[i]) {  						mdHdr = mdHdr - vAdrs[i] + rAdrs[i];  						break;  					}  				*(uint*)mdDirPtr = 0;  				*((uint*)mdDirPtr + 1) = 0;  				*((uint*)mdDirPtr + 2) = 0;  				*((uint*)mdDirPtr + 3) = 0;      				byte* mdHdrPtr = bas + mdHdr;  				VirtualProtect(mdHdrPtr' 4' 0x40' out old);  				*(uint*)mdHdrPtr = 0;  				mdHdrPtr += 12;  				mdHdrPtr += *(uint*)mdHdrPtr;  				mdHdrPtr = (byte*)(((ulong)mdHdrPtr + 7) & ~3UL);  				mdHdrPtr += 2;  				ushort numOfStream = *mdHdrPtr;  				mdHdrPtr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdrPtr' 8' 0x40' out old);  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdrPtr' 4' 0x40' out old);  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 3;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 2;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 1;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  					}  				}  			}
Magic Number,Confuser.Runtime,AntiDump,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiDump.cs,Initialize,The following statement contains a magic number: if (module.FullyQualifiedName[0] != '<') //Mapped  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				byte* mdDir = bas + *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;    				if (*(uint*)(ptr - 0x78) != 0) {  					byte* importDir = bas + *(uint*)(ptr - 0x78);  					byte* oftMod = bas + *(uint*)importDir;  					byte* modName = bas + *(uint*)(importDir + 12);  					byte* funcName = bas + *(uint*)oftMod + 2;  					VirtualProtect(modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(modName + i) = *(@new + i);    					VirtualProtect(funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(funcName + i) = *(@new + i);  				}    				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					ptr += 0x28;  				}  				VirtualProtect(mdDir' 0x48' 0x40' out old);  				byte* mdHdr = bas + *(uint*)(mdDir + 8);  				*(uint*)mdDir = 0;  				*((uint*)mdDir + 1) = 0;  				*((uint*)mdDir + 2) = 0;  				*((uint*)mdDir + 3) = 0;    				VirtualProtect(mdHdr' 4' 0x40' out old);  				*(uint*)mdHdr = 0;  				mdHdr += 12;  				mdHdr += *(uint*)mdHdr;  				mdHdr = (byte*)(((ulong)mdHdr + 7) & ~3UL);  				mdHdr += 2;  				ushort numOfStream = *mdHdr;  				mdHdr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdr' 8' 0x40' out old);  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdr' 4' 0x40' out old);  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 3;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 2;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 1;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  					}  				}  			}  			else //Flat  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				uint mdDir = *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;  				uint importDir = *(uint*)(ptr - 0x78);    				var vAdrs = new uint[sectNum];  				var vSizes = new uint[sectNum];  				var rAdrs = new uint[sectNum];  				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					vAdrs[i] = *(uint*)(ptr + 12);  					vSizes[i] = *(uint*)(ptr + 8);  					rAdrs[i] = *(uint*)(ptr + 20);  					ptr += 0x28;  				}      				if (importDir != 0) {  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= importDir && importDir < vAdrs[i] + vSizes[i]) {  							importDir = importDir - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* importDirPtr = bas + importDir;  					uint oftMod = *(uint*)importDirPtr;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= oftMod && oftMod < vAdrs[i] + vSizes[i]) {  							oftMod = oftMod - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* oftModPtr = bas + oftMod;  					uint modName = *(uint*)(importDirPtr + 12);  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= modName && modName < vAdrs[i] + vSizes[i]) {  							modName = modName - vAdrs[i] + rAdrs[i];  							break;  						}  					uint funcName = *(uint*)oftModPtr + 2;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= funcName && funcName < vAdrs[i] + vSizes[i]) {  							funcName = funcName - vAdrs[i] + rAdrs[i];  							break;  						}  					VirtualProtect(bas + modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + modName + i) = *(@new + i);    					VirtualProtect(bas + funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + funcName + i) = *(@new + i);  				}      				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdDir && mdDir < vAdrs[i] + vSizes[i]) {  						mdDir = mdDir - vAdrs[i] + rAdrs[i];  						break;  					}  				byte* mdDirPtr = bas + mdDir;  				VirtualProtect(mdDirPtr' 0x48' 0x40' out old);  				uint mdHdr = *(uint*)(mdDirPtr + 8);  				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdHdr && mdHdr < vAdrs[i] + vSizes[i]) {  						mdHdr = mdHdr - vAdrs[i] + rAdrs[i];  						break;  					}  				*(uint*)mdDirPtr = 0;  				*((uint*)mdDirPtr + 1) = 0;  				*((uint*)mdDirPtr + 2) = 0;  				*((uint*)mdDirPtr + 3) = 0;      				byte* mdHdrPtr = bas + mdHdr;  				VirtualProtect(mdHdrPtr' 4' 0x40' out old);  				*(uint*)mdHdrPtr = 0;  				mdHdrPtr += 12;  				mdHdrPtr += *(uint*)mdHdrPtr;  				mdHdrPtr = (byte*)(((ulong)mdHdrPtr + 7) & ~3UL);  				mdHdrPtr += 2;  				ushort numOfStream = *mdHdrPtr;  				mdHdrPtr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdrPtr' 8' 0x40' out old);  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdrPtr' 4' 0x40' out old);  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 3;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 2;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 1;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  					}  				}  			}
Magic Number,Confuser.Runtime,AntiDump,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiDump.cs,Initialize,The following statement contains a magic number: if (module.FullyQualifiedName[0] != '<') //Mapped  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				byte* mdDir = bas + *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;    				if (*(uint*)(ptr - 0x78) != 0) {  					byte* importDir = bas + *(uint*)(ptr - 0x78);  					byte* oftMod = bas + *(uint*)importDir;  					byte* modName = bas + *(uint*)(importDir + 12);  					byte* funcName = bas + *(uint*)oftMod + 2;  					VirtualProtect(modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(modName + i) = *(@new + i);    					VirtualProtect(funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(funcName + i) = *(@new + i);  				}    				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					ptr += 0x28;  				}  				VirtualProtect(mdDir' 0x48' 0x40' out old);  				byte* mdHdr = bas + *(uint*)(mdDir + 8);  				*(uint*)mdDir = 0;  				*((uint*)mdDir + 1) = 0;  				*((uint*)mdDir + 2) = 0;  				*((uint*)mdDir + 3) = 0;    				VirtualProtect(mdHdr' 4' 0x40' out old);  				*(uint*)mdHdr = 0;  				mdHdr += 12;  				mdHdr += *(uint*)mdHdr;  				mdHdr = (byte*)(((ulong)mdHdr + 7) & ~3UL);  				mdHdr += 2;  				ushort numOfStream = *mdHdr;  				mdHdr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdr' 8' 0x40' out old);  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdr' 4' 0x40' out old);  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 3;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 2;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 1;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  					}  				}  			}  			else //Flat  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				uint mdDir = *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;  				uint importDir = *(uint*)(ptr - 0x78);    				var vAdrs = new uint[sectNum];  				var vSizes = new uint[sectNum];  				var rAdrs = new uint[sectNum];  				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					vAdrs[i] = *(uint*)(ptr + 12);  					vSizes[i] = *(uint*)(ptr + 8);  					rAdrs[i] = *(uint*)(ptr + 20);  					ptr += 0x28;  				}      				if (importDir != 0) {  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= importDir && importDir < vAdrs[i] + vSizes[i]) {  							importDir = importDir - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* importDirPtr = bas + importDir;  					uint oftMod = *(uint*)importDirPtr;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= oftMod && oftMod < vAdrs[i] + vSizes[i]) {  							oftMod = oftMod - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* oftModPtr = bas + oftMod;  					uint modName = *(uint*)(importDirPtr + 12);  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= modName && modName < vAdrs[i] + vSizes[i]) {  							modName = modName - vAdrs[i] + rAdrs[i];  							break;  						}  					uint funcName = *(uint*)oftModPtr + 2;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= funcName && funcName < vAdrs[i] + vSizes[i]) {  							funcName = funcName - vAdrs[i] + rAdrs[i];  							break;  						}  					VirtualProtect(bas + modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + modName + i) = *(@new + i);    					VirtualProtect(bas + funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + funcName + i) = *(@new + i);  				}      				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdDir && mdDir < vAdrs[i] + vSizes[i]) {  						mdDir = mdDir - vAdrs[i] + rAdrs[i];  						break;  					}  				byte* mdDirPtr = bas + mdDir;  				VirtualProtect(mdDirPtr' 0x48' 0x40' out old);  				uint mdHdr = *(uint*)(mdDirPtr + 8);  				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdHdr && mdHdr < vAdrs[i] + vSizes[i]) {  						mdHdr = mdHdr - vAdrs[i] + rAdrs[i];  						break;  					}  				*(uint*)mdDirPtr = 0;  				*((uint*)mdDirPtr + 1) = 0;  				*((uint*)mdDirPtr + 2) = 0;  				*((uint*)mdDirPtr + 3) = 0;      				byte* mdHdrPtr = bas + mdHdr;  				VirtualProtect(mdHdrPtr' 4' 0x40' out old);  				*(uint*)mdHdrPtr = 0;  				mdHdrPtr += 12;  				mdHdrPtr += *(uint*)mdHdrPtr;  				mdHdrPtr = (byte*)(((ulong)mdHdrPtr + 7) & ~3UL);  				mdHdrPtr += 2;  				ushort numOfStream = *mdHdrPtr;  				mdHdrPtr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdrPtr' 8' 0x40' out old);  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdrPtr' 4' 0x40' out old);  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 3;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 2;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 1;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  					}  				}  			}
Magic Number,Confuser.Runtime,AntiDump,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiDump.cs,Initialize,The following statement contains a magic number: if (module.FullyQualifiedName[0] != '<') //Mapped  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				byte* mdDir = bas + *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;    				if (*(uint*)(ptr - 0x78) != 0) {  					byte* importDir = bas + *(uint*)(ptr - 0x78);  					byte* oftMod = bas + *(uint*)importDir;  					byte* modName = bas + *(uint*)(importDir + 12);  					byte* funcName = bas + *(uint*)oftMod + 2;  					VirtualProtect(modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(modName + i) = *(@new + i);    					VirtualProtect(funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(funcName + i) = *(@new + i);  				}    				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					ptr += 0x28;  				}  				VirtualProtect(mdDir' 0x48' 0x40' out old);  				byte* mdHdr = bas + *(uint*)(mdDir + 8);  				*(uint*)mdDir = 0;  				*((uint*)mdDir + 1) = 0;  				*((uint*)mdDir + 2) = 0;  				*((uint*)mdDir + 3) = 0;    				VirtualProtect(mdHdr' 4' 0x40' out old);  				*(uint*)mdHdr = 0;  				mdHdr += 12;  				mdHdr += *(uint*)mdHdr;  				mdHdr = (byte*)(((ulong)mdHdr + 7) & ~3UL);  				mdHdr += 2;  				ushort numOfStream = *mdHdr;  				mdHdr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdr' 8' 0x40' out old);  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdr' 4' 0x40' out old);  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 3;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 2;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 1;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  					}  				}  			}  			else //Flat  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				uint mdDir = *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;  				uint importDir = *(uint*)(ptr - 0x78);    				var vAdrs = new uint[sectNum];  				var vSizes = new uint[sectNum];  				var rAdrs = new uint[sectNum];  				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					vAdrs[i] = *(uint*)(ptr + 12);  					vSizes[i] = *(uint*)(ptr + 8);  					rAdrs[i] = *(uint*)(ptr + 20);  					ptr += 0x28;  				}      				if (importDir != 0) {  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= importDir && importDir < vAdrs[i] + vSizes[i]) {  							importDir = importDir - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* importDirPtr = bas + importDir;  					uint oftMod = *(uint*)importDirPtr;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= oftMod && oftMod < vAdrs[i] + vSizes[i]) {  							oftMod = oftMod - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* oftModPtr = bas + oftMod;  					uint modName = *(uint*)(importDirPtr + 12);  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= modName && modName < vAdrs[i] + vSizes[i]) {  							modName = modName - vAdrs[i] + rAdrs[i];  							break;  						}  					uint funcName = *(uint*)oftModPtr + 2;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= funcName && funcName < vAdrs[i] + vSizes[i]) {  							funcName = funcName - vAdrs[i] + rAdrs[i];  							break;  						}  					VirtualProtect(bas + modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + modName + i) = *(@new + i);    					VirtualProtect(bas + funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + funcName + i) = *(@new + i);  				}      				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdDir && mdDir < vAdrs[i] + vSizes[i]) {  						mdDir = mdDir - vAdrs[i] + rAdrs[i];  						break;  					}  				byte* mdDirPtr = bas + mdDir;  				VirtualProtect(mdDirPtr' 0x48' 0x40' out old);  				uint mdHdr = *(uint*)(mdDirPtr + 8);  				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdHdr && mdHdr < vAdrs[i] + vSizes[i]) {  						mdHdr = mdHdr - vAdrs[i] + rAdrs[i];  						break;  					}  				*(uint*)mdDirPtr = 0;  				*((uint*)mdDirPtr + 1) = 0;  				*((uint*)mdDirPtr + 2) = 0;  				*((uint*)mdDirPtr + 3) = 0;      				byte* mdHdrPtr = bas + mdHdr;  				VirtualProtect(mdHdrPtr' 4' 0x40' out old);  				*(uint*)mdHdrPtr = 0;  				mdHdrPtr += 12;  				mdHdrPtr += *(uint*)mdHdrPtr;  				mdHdrPtr = (byte*)(((ulong)mdHdrPtr + 7) & ~3UL);  				mdHdrPtr += 2;  				ushort numOfStream = *mdHdrPtr;  				mdHdrPtr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdrPtr' 8' 0x40' out old);  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdrPtr' 4' 0x40' out old);  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 3;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 2;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 1;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  					}  				}  			}
Magic Number,Confuser.Runtime,AntiDump,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiDump.cs,Initialize,The following statement contains a magic number: if (module.FullyQualifiedName[0] != '<') //Mapped  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				byte* mdDir = bas + *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;    				if (*(uint*)(ptr - 0x78) != 0) {  					byte* importDir = bas + *(uint*)(ptr - 0x78);  					byte* oftMod = bas + *(uint*)importDir;  					byte* modName = bas + *(uint*)(importDir + 12);  					byte* funcName = bas + *(uint*)oftMod + 2;  					VirtualProtect(modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(modName + i) = *(@new + i);    					VirtualProtect(funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(funcName + i) = *(@new + i);  				}    				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					ptr += 0x28;  				}  				VirtualProtect(mdDir' 0x48' 0x40' out old);  				byte* mdHdr = bas + *(uint*)(mdDir + 8);  				*(uint*)mdDir = 0;  				*((uint*)mdDir + 1) = 0;  				*((uint*)mdDir + 2) = 0;  				*((uint*)mdDir + 3) = 0;    				VirtualProtect(mdHdr' 4' 0x40' out old);  				*(uint*)mdHdr = 0;  				mdHdr += 12;  				mdHdr += *(uint*)mdHdr;  				mdHdr = (byte*)(((ulong)mdHdr + 7) & ~3UL);  				mdHdr += 2;  				ushort numOfStream = *mdHdr;  				mdHdr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdr' 8' 0x40' out old);  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdr' 4' 0x40' out old);  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 3;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 2;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 1;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  					}  				}  			}  			else //Flat  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				uint mdDir = *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;  				uint importDir = *(uint*)(ptr - 0x78);    				var vAdrs = new uint[sectNum];  				var vSizes = new uint[sectNum];  				var rAdrs = new uint[sectNum];  				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					vAdrs[i] = *(uint*)(ptr + 12);  					vSizes[i] = *(uint*)(ptr + 8);  					rAdrs[i] = *(uint*)(ptr + 20);  					ptr += 0x28;  				}      				if (importDir != 0) {  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= importDir && importDir < vAdrs[i] + vSizes[i]) {  							importDir = importDir - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* importDirPtr = bas + importDir;  					uint oftMod = *(uint*)importDirPtr;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= oftMod && oftMod < vAdrs[i] + vSizes[i]) {  							oftMod = oftMod - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* oftModPtr = bas + oftMod;  					uint modName = *(uint*)(importDirPtr + 12);  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= modName && modName < vAdrs[i] + vSizes[i]) {  							modName = modName - vAdrs[i] + rAdrs[i];  							break;  						}  					uint funcName = *(uint*)oftModPtr + 2;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= funcName && funcName < vAdrs[i] + vSizes[i]) {  							funcName = funcName - vAdrs[i] + rAdrs[i];  							break;  						}  					VirtualProtect(bas + modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + modName + i) = *(@new + i);    					VirtualProtect(bas + funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + funcName + i) = *(@new + i);  				}      				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdDir && mdDir < vAdrs[i] + vSizes[i]) {  						mdDir = mdDir - vAdrs[i] + rAdrs[i];  						break;  					}  				byte* mdDirPtr = bas + mdDir;  				VirtualProtect(mdDirPtr' 0x48' 0x40' out old);  				uint mdHdr = *(uint*)(mdDirPtr + 8);  				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdHdr && mdHdr < vAdrs[i] + vSizes[i]) {  						mdHdr = mdHdr - vAdrs[i] + rAdrs[i];  						break;  					}  				*(uint*)mdDirPtr = 0;  				*((uint*)mdDirPtr + 1) = 0;  				*((uint*)mdDirPtr + 2) = 0;  				*((uint*)mdDirPtr + 3) = 0;      				byte* mdHdrPtr = bas + mdHdr;  				VirtualProtect(mdHdrPtr' 4' 0x40' out old);  				*(uint*)mdHdrPtr = 0;  				mdHdrPtr += 12;  				mdHdrPtr += *(uint*)mdHdrPtr;  				mdHdrPtr = (byte*)(((ulong)mdHdrPtr + 7) & ~3UL);  				mdHdrPtr += 2;  				ushort numOfStream = *mdHdrPtr;  				mdHdrPtr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdrPtr' 8' 0x40' out old);  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdrPtr' 4' 0x40' out old);  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 3;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 2;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 1;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  					}  				}  			}
Magic Number,Confuser.Runtime,AntiDump,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiDump.cs,Initialize,The following statement contains a magic number: if (module.FullyQualifiedName[0] != '<') //Mapped  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				byte* mdDir = bas + *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;    				if (*(uint*)(ptr - 0x78) != 0) {  					byte* importDir = bas + *(uint*)(ptr - 0x78);  					byte* oftMod = bas + *(uint*)importDir;  					byte* modName = bas + *(uint*)(importDir + 12);  					byte* funcName = bas + *(uint*)oftMod + 2;  					VirtualProtect(modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(modName + i) = *(@new + i);    					VirtualProtect(funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(funcName + i) = *(@new + i);  				}    				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					ptr += 0x28;  				}  				VirtualProtect(mdDir' 0x48' 0x40' out old);  				byte* mdHdr = bas + *(uint*)(mdDir + 8);  				*(uint*)mdDir = 0;  				*((uint*)mdDir + 1) = 0;  				*((uint*)mdDir + 2) = 0;  				*((uint*)mdDir + 3) = 0;    				VirtualProtect(mdHdr' 4' 0x40' out old);  				*(uint*)mdHdr = 0;  				mdHdr += 12;  				mdHdr += *(uint*)mdHdr;  				mdHdr = (byte*)(((ulong)mdHdr + 7) & ~3UL);  				mdHdr += 2;  				ushort numOfStream = *mdHdr;  				mdHdr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdr' 8' 0x40' out old);  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdr' 4' 0x40' out old);  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 3;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 2;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 1;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  					}  				}  			}  			else //Flat  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				uint mdDir = *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;  				uint importDir = *(uint*)(ptr - 0x78);    				var vAdrs = new uint[sectNum];  				var vSizes = new uint[sectNum];  				var rAdrs = new uint[sectNum];  				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					vAdrs[i] = *(uint*)(ptr + 12);  					vSizes[i] = *(uint*)(ptr + 8);  					rAdrs[i] = *(uint*)(ptr + 20);  					ptr += 0x28;  				}      				if (importDir != 0) {  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= importDir && importDir < vAdrs[i] + vSizes[i]) {  							importDir = importDir - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* importDirPtr = bas + importDir;  					uint oftMod = *(uint*)importDirPtr;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= oftMod && oftMod < vAdrs[i] + vSizes[i]) {  							oftMod = oftMod - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* oftModPtr = bas + oftMod;  					uint modName = *(uint*)(importDirPtr + 12);  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= modName && modName < vAdrs[i] + vSizes[i]) {  							modName = modName - vAdrs[i] + rAdrs[i];  							break;  						}  					uint funcName = *(uint*)oftModPtr + 2;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= funcName && funcName < vAdrs[i] + vSizes[i]) {  							funcName = funcName - vAdrs[i] + rAdrs[i];  							break;  						}  					VirtualProtect(bas + modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + modName + i) = *(@new + i);    					VirtualProtect(bas + funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + funcName + i) = *(@new + i);  				}      				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdDir && mdDir < vAdrs[i] + vSizes[i]) {  						mdDir = mdDir - vAdrs[i] + rAdrs[i];  						break;  					}  				byte* mdDirPtr = bas + mdDir;  				VirtualProtect(mdDirPtr' 0x48' 0x40' out old);  				uint mdHdr = *(uint*)(mdDirPtr + 8);  				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdHdr && mdHdr < vAdrs[i] + vSizes[i]) {  						mdHdr = mdHdr - vAdrs[i] + rAdrs[i];  						break;  					}  				*(uint*)mdDirPtr = 0;  				*((uint*)mdDirPtr + 1) = 0;  				*((uint*)mdDirPtr + 2) = 0;  				*((uint*)mdDirPtr + 3) = 0;      				byte* mdHdrPtr = bas + mdHdr;  				VirtualProtect(mdHdrPtr' 4' 0x40' out old);  				*(uint*)mdHdrPtr = 0;  				mdHdrPtr += 12;  				mdHdrPtr += *(uint*)mdHdrPtr;  				mdHdrPtr = (byte*)(((ulong)mdHdrPtr + 7) & ~3UL);  				mdHdrPtr += 2;  				ushort numOfStream = *mdHdrPtr;  				mdHdrPtr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdrPtr' 8' 0x40' out old);  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdrPtr' 4' 0x40' out old);  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 3;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 2;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 1;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  					}  				}  			}
Magic Number,Confuser.Runtime,AntiDump,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiDump.cs,Initialize,The following statement contains a magic number: if (module.FullyQualifiedName[0] != '<') //Mapped  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				byte* mdDir = bas + *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;    				if (*(uint*)(ptr - 0x78) != 0) {  					byte* importDir = bas + *(uint*)(ptr - 0x78);  					byte* oftMod = bas + *(uint*)importDir;  					byte* modName = bas + *(uint*)(importDir + 12);  					byte* funcName = bas + *(uint*)oftMod + 2;  					VirtualProtect(modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(modName + i) = *(@new + i);    					VirtualProtect(funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(funcName + i) = *(@new + i);  				}    				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					ptr += 0x28;  				}  				VirtualProtect(mdDir' 0x48' 0x40' out old);  				byte* mdHdr = bas + *(uint*)(mdDir + 8);  				*(uint*)mdDir = 0;  				*((uint*)mdDir + 1) = 0;  				*((uint*)mdDir + 2) = 0;  				*((uint*)mdDir + 3) = 0;    				VirtualProtect(mdHdr' 4' 0x40' out old);  				*(uint*)mdHdr = 0;  				mdHdr += 12;  				mdHdr += *(uint*)mdHdr;  				mdHdr = (byte*)(((ulong)mdHdr + 7) & ~3UL);  				mdHdr += 2;  				ushort numOfStream = *mdHdr;  				mdHdr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdr' 8' 0x40' out old);  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdr' 4' 0x40' out old);  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 3;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 2;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 1;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  					}  				}  			}  			else //Flat  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				uint mdDir = *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;  				uint importDir = *(uint*)(ptr - 0x78);    				var vAdrs = new uint[sectNum];  				var vSizes = new uint[sectNum];  				var rAdrs = new uint[sectNum];  				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					vAdrs[i] = *(uint*)(ptr + 12);  					vSizes[i] = *(uint*)(ptr + 8);  					rAdrs[i] = *(uint*)(ptr + 20);  					ptr += 0x28;  				}      				if (importDir != 0) {  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= importDir && importDir < vAdrs[i] + vSizes[i]) {  							importDir = importDir - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* importDirPtr = bas + importDir;  					uint oftMod = *(uint*)importDirPtr;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= oftMod && oftMod < vAdrs[i] + vSizes[i]) {  							oftMod = oftMod - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* oftModPtr = bas + oftMod;  					uint modName = *(uint*)(importDirPtr + 12);  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= modName && modName < vAdrs[i] + vSizes[i]) {  							modName = modName - vAdrs[i] + rAdrs[i];  							break;  						}  					uint funcName = *(uint*)oftModPtr + 2;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= funcName && funcName < vAdrs[i] + vSizes[i]) {  							funcName = funcName - vAdrs[i] + rAdrs[i];  							break;  						}  					VirtualProtect(bas + modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + modName + i) = *(@new + i);    					VirtualProtect(bas + funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + funcName + i) = *(@new + i);  				}      				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdDir && mdDir < vAdrs[i] + vSizes[i]) {  						mdDir = mdDir - vAdrs[i] + rAdrs[i];  						break;  					}  				byte* mdDirPtr = bas + mdDir;  				VirtualProtect(mdDirPtr' 0x48' 0x40' out old);  				uint mdHdr = *(uint*)(mdDirPtr + 8);  				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdHdr && mdHdr < vAdrs[i] + vSizes[i]) {  						mdHdr = mdHdr - vAdrs[i] + rAdrs[i];  						break;  					}  				*(uint*)mdDirPtr = 0;  				*((uint*)mdDirPtr + 1) = 0;  				*((uint*)mdDirPtr + 2) = 0;  				*((uint*)mdDirPtr + 3) = 0;      				byte* mdHdrPtr = bas + mdHdr;  				VirtualProtect(mdHdrPtr' 4' 0x40' out old);  				*(uint*)mdHdrPtr = 0;  				mdHdrPtr += 12;  				mdHdrPtr += *(uint*)mdHdrPtr;  				mdHdrPtr = (byte*)(((ulong)mdHdrPtr + 7) & ~3UL);  				mdHdrPtr += 2;  				ushort numOfStream = *mdHdrPtr;  				mdHdrPtr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdrPtr' 8' 0x40' out old);  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdrPtr' 4' 0x40' out old);  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 3;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 2;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 1;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  					}  				}  			}
Magic Number,Confuser.Runtime,AntiDump,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiDump.cs,Initialize,The following statement contains a magic number: if (module.FullyQualifiedName[0] != '<') //Mapped  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				byte* mdDir = bas + *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;    				if (*(uint*)(ptr - 0x78) != 0) {  					byte* importDir = bas + *(uint*)(ptr - 0x78);  					byte* oftMod = bas + *(uint*)importDir;  					byte* modName = bas + *(uint*)(importDir + 12);  					byte* funcName = bas + *(uint*)oftMod + 2;  					VirtualProtect(modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(modName + i) = *(@new + i);    					VirtualProtect(funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(funcName + i) = *(@new + i);  				}    				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					ptr += 0x28;  				}  				VirtualProtect(mdDir' 0x48' 0x40' out old);  				byte* mdHdr = bas + *(uint*)(mdDir + 8);  				*(uint*)mdDir = 0;  				*((uint*)mdDir + 1) = 0;  				*((uint*)mdDir + 2) = 0;  				*((uint*)mdDir + 3) = 0;    				VirtualProtect(mdHdr' 4' 0x40' out old);  				*(uint*)mdHdr = 0;  				mdHdr += 12;  				mdHdr += *(uint*)mdHdr;  				mdHdr = (byte*)(((ulong)mdHdr + 7) & ~3UL);  				mdHdr += 2;  				ushort numOfStream = *mdHdr;  				mdHdr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdr' 8' 0x40' out old);  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdr' 4' 0x40' out old);  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 3;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 2;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 1;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  					}  				}  			}  			else //Flat  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				uint mdDir = *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;  				uint importDir = *(uint*)(ptr - 0x78);    				var vAdrs = new uint[sectNum];  				var vSizes = new uint[sectNum];  				var rAdrs = new uint[sectNum];  				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					vAdrs[i] = *(uint*)(ptr + 12);  					vSizes[i] = *(uint*)(ptr + 8);  					rAdrs[i] = *(uint*)(ptr + 20);  					ptr += 0x28;  				}      				if (importDir != 0) {  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= importDir && importDir < vAdrs[i] + vSizes[i]) {  							importDir = importDir - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* importDirPtr = bas + importDir;  					uint oftMod = *(uint*)importDirPtr;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= oftMod && oftMod < vAdrs[i] + vSizes[i]) {  							oftMod = oftMod - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* oftModPtr = bas + oftMod;  					uint modName = *(uint*)(importDirPtr + 12);  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= modName && modName < vAdrs[i] + vSizes[i]) {  							modName = modName - vAdrs[i] + rAdrs[i];  							break;  						}  					uint funcName = *(uint*)oftModPtr + 2;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= funcName && funcName < vAdrs[i] + vSizes[i]) {  							funcName = funcName - vAdrs[i] + rAdrs[i];  							break;  						}  					VirtualProtect(bas + modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + modName + i) = *(@new + i);    					VirtualProtect(bas + funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + funcName + i) = *(@new + i);  				}      				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdDir && mdDir < vAdrs[i] + vSizes[i]) {  						mdDir = mdDir - vAdrs[i] + rAdrs[i];  						break;  					}  				byte* mdDirPtr = bas + mdDir;  				VirtualProtect(mdDirPtr' 0x48' 0x40' out old);  				uint mdHdr = *(uint*)(mdDirPtr + 8);  				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdHdr && mdHdr < vAdrs[i] + vSizes[i]) {  						mdHdr = mdHdr - vAdrs[i] + rAdrs[i];  						break;  					}  				*(uint*)mdDirPtr = 0;  				*((uint*)mdDirPtr + 1) = 0;  				*((uint*)mdDirPtr + 2) = 0;  				*((uint*)mdDirPtr + 3) = 0;      				byte* mdHdrPtr = bas + mdHdr;  				VirtualProtect(mdHdrPtr' 4' 0x40' out old);  				*(uint*)mdHdrPtr = 0;  				mdHdrPtr += 12;  				mdHdrPtr += *(uint*)mdHdrPtr;  				mdHdrPtr = (byte*)(((ulong)mdHdrPtr + 7) & ~3UL);  				mdHdrPtr += 2;  				ushort numOfStream = *mdHdrPtr;  				mdHdrPtr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdrPtr' 8' 0x40' out old);  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdrPtr' 4' 0x40' out old);  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 3;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 2;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 1;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  					}  				}  			}
Magic Number,Confuser.Runtime,AntiDump,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiDump.cs,Initialize,The following statement contains a magic number: if (module.FullyQualifiedName[0] != '<') //Mapped  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				byte* mdDir = bas + *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;    				if (*(uint*)(ptr - 0x78) != 0) {  					byte* importDir = bas + *(uint*)(ptr - 0x78);  					byte* oftMod = bas + *(uint*)importDir;  					byte* modName = bas + *(uint*)(importDir + 12);  					byte* funcName = bas + *(uint*)oftMod + 2;  					VirtualProtect(modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(modName + i) = *(@new + i);    					VirtualProtect(funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(funcName + i) = *(@new + i);  				}    				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					ptr += 0x28;  				}  				VirtualProtect(mdDir' 0x48' 0x40' out old);  				byte* mdHdr = bas + *(uint*)(mdDir + 8);  				*(uint*)mdDir = 0;  				*((uint*)mdDir + 1) = 0;  				*((uint*)mdDir + 2) = 0;  				*((uint*)mdDir + 3) = 0;    				VirtualProtect(mdHdr' 4' 0x40' out old);  				*(uint*)mdHdr = 0;  				mdHdr += 12;  				mdHdr += *(uint*)mdHdr;  				mdHdr = (byte*)(((ulong)mdHdr + 7) & ~3UL);  				mdHdr += 2;  				ushort numOfStream = *mdHdr;  				mdHdr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdr' 8' 0x40' out old);  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdr' 4' 0x40' out old);  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 3;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 2;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 1;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  					}  				}  			}  			else //Flat  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				uint mdDir = *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;  				uint importDir = *(uint*)(ptr - 0x78);    				var vAdrs = new uint[sectNum];  				var vSizes = new uint[sectNum];  				var rAdrs = new uint[sectNum];  				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					vAdrs[i] = *(uint*)(ptr + 12);  					vSizes[i] = *(uint*)(ptr + 8);  					rAdrs[i] = *(uint*)(ptr + 20);  					ptr += 0x28;  				}      				if (importDir != 0) {  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= importDir && importDir < vAdrs[i] + vSizes[i]) {  							importDir = importDir - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* importDirPtr = bas + importDir;  					uint oftMod = *(uint*)importDirPtr;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= oftMod && oftMod < vAdrs[i] + vSizes[i]) {  							oftMod = oftMod - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* oftModPtr = bas + oftMod;  					uint modName = *(uint*)(importDirPtr + 12);  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= modName && modName < vAdrs[i] + vSizes[i]) {  							modName = modName - vAdrs[i] + rAdrs[i];  							break;  						}  					uint funcName = *(uint*)oftModPtr + 2;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= funcName && funcName < vAdrs[i] + vSizes[i]) {  							funcName = funcName - vAdrs[i] + rAdrs[i];  							break;  						}  					VirtualProtect(bas + modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + modName + i) = *(@new + i);    					VirtualProtect(bas + funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + funcName + i) = *(@new + i);  				}      				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdDir && mdDir < vAdrs[i] + vSizes[i]) {  						mdDir = mdDir - vAdrs[i] + rAdrs[i];  						break;  					}  				byte* mdDirPtr = bas + mdDir;  				VirtualProtect(mdDirPtr' 0x48' 0x40' out old);  				uint mdHdr = *(uint*)(mdDirPtr + 8);  				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdHdr && mdHdr < vAdrs[i] + vSizes[i]) {  						mdHdr = mdHdr - vAdrs[i] + rAdrs[i];  						break;  					}  				*(uint*)mdDirPtr = 0;  				*((uint*)mdDirPtr + 1) = 0;  				*((uint*)mdDirPtr + 2) = 0;  				*((uint*)mdDirPtr + 3) = 0;      				byte* mdHdrPtr = bas + mdHdr;  				VirtualProtect(mdHdrPtr' 4' 0x40' out old);  				*(uint*)mdHdrPtr = 0;  				mdHdrPtr += 12;  				mdHdrPtr += *(uint*)mdHdrPtr;  				mdHdrPtr = (byte*)(((ulong)mdHdrPtr + 7) & ~3UL);  				mdHdrPtr += 2;  				ushort numOfStream = *mdHdrPtr;  				mdHdrPtr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdrPtr' 8' 0x40' out old);  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdrPtr' 4' 0x40' out old);  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 3;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 2;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 1;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  					}  				}  			}
Magic Number,Confuser.Runtime,AntiDump,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiDump.cs,Initialize,The following statement contains a magic number: if (module.FullyQualifiedName[0] != '<') //Mapped  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				byte* mdDir = bas + *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;    				if (*(uint*)(ptr - 0x78) != 0) {  					byte* importDir = bas + *(uint*)(ptr - 0x78);  					byte* oftMod = bas + *(uint*)importDir;  					byte* modName = bas + *(uint*)(importDir + 12);  					byte* funcName = bas + *(uint*)oftMod + 2;  					VirtualProtect(modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(modName + i) = *(@new + i);    					VirtualProtect(funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(funcName + i) = *(@new + i);  				}    				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					ptr += 0x28;  				}  				VirtualProtect(mdDir' 0x48' 0x40' out old);  				byte* mdHdr = bas + *(uint*)(mdDir + 8);  				*(uint*)mdDir = 0;  				*((uint*)mdDir + 1) = 0;  				*((uint*)mdDir + 2) = 0;  				*((uint*)mdDir + 3) = 0;    				VirtualProtect(mdHdr' 4' 0x40' out old);  				*(uint*)mdHdr = 0;  				mdHdr += 12;  				mdHdr += *(uint*)mdHdr;  				mdHdr = (byte*)(((ulong)mdHdr + 7) & ~3UL);  				mdHdr += 2;  				ushort numOfStream = *mdHdr;  				mdHdr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdr' 8' 0x40' out old);  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdr' 4' 0x40' out old);  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 3;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 2;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 1;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  					}  				}  			}  			else //Flat  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				uint mdDir = *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;  				uint importDir = *(uint*)(ptr - 0x78);    				var vAdrs = new uint[sectNum];  				var vSizes = new uint[sectNum];  				var rAdrs = new uint[sectNum];  				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					vAdrs[i] = *(uint*)(ptr + 12);  					vSizes[i] = *(uint*)(ptr + 8);  					rAdrs[i] = *(uint*)(ptr + 20);  					ptr += 0x28;  				}      				if (importDir != 0) {  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= importDir && importDir < vAdrs[i] + vSizes[i]) {  							importDir = importDir - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* importDirPtr = bas + importDir;  					uint oftMod = *(uint*)importDirPtr;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= oftMod && oftMod < vAdrs[i] + vSizes[i]) {  							oftMod = oftMod - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* oftModPtr = bas + oftMod;  					uint modName = *(uint*)(importDirPtr + 12);  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= modName && modName < vAdrs[i] + vSizes[i]) {  							modName = modName - vAdrs[i] + rAdrs[i];  							break;  						}  					uint funcName = *(uint*)oftModPtr + 2;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= funcName && funcName < vAdrs[i] + vSizes[i]) {  							funcName = funcName - vAdrs[i] + rAdrs[i];  							break;  						}  					VirtualProtect(bas + modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + modName + i) = *(@new + i);    					VirtualProtect(bas + funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + funcName + i) = *(@new + i);  				}      				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdDir && mdDir < vAdrs[i] + vSizes[i]) {  						mdDir = mdDir - vAdrs[i] + rAdrs[i];  						break;  					}  				byte* mdDirPtr = bas + mdDir;  				VirtualProtect(mdDirPtr' 0x48' 0x40' out old);  				uint mdHdr = *(uint*)(mdDirPtr + 8);  				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdHdr && mdHdr < vAdrs[i] + vSizes[i]) {  						mdHdr = mdHdr - vAdrs[i] + rAdrs[i];  						break;  					}  				*(uint*)mdDirPtr = 0;  				*((uint*)mdDirPtr + 1) = 0;  				*((uint*)mdDirPtr + 2) = 0;  				*((uint*)mdDirPtr + 3) = 0;      				byte* mdHdrPtr = bas + mdHdr;  				VirtualProtect(mdHdrPtr' 4' 0x40' out old);  				*(uint*)mdHdrPtr = 0;  				mdHdrPtr += 12;  				mdHdrPtr += *(uint*)mdHdrPtr;  				mdHdrPtr = (byte*)(((ulong)mdHdrPtr + 7) & ~3UL);  				mdHdrPtr += 2;  				ushort numOfStream = *mdHdrPtr;  				mdHdrPtr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdrPtr' 8' 0x40' out old);  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdrPtr' 4' 0x40' out old);  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 3;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 2;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 1;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  					}  				}  			}
Magic Number,Confuser.Runtime,AntiDump,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiDump.cs,Initialize,The following statement contains a magic number: if (module.FullyQualifiedName[0] != '<') //Mapped  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				byte* mdDir = bas + *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;    				if (*(uint*)(ptr - 0x78) != 0) {  					byte* importDir = bas + *(uint*)(ptr - 0x78);  					byte* oftMod = bas + *(uint*)importDir;  					byte* modName = bas + *(uint*)(importDir + 12);  					byte* funcName = bas + *(uint*)oftMod + 2;  					VirtualProtect(modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(modName + i) = *(@new + i);    					VirtualProtect(funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(funcName + i) = *(@new + i);  				}    				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					ptr += 0x28;  				}  				VirtualProtect(mdDir' 0x48' 0x40' out old);  				byte* mdHdr = bas + *(uint*)(mdDir + 8);  				*(uint*)mdDir = 0;  				*((uint*)mdDir + 1) = 0;  				*((uint*)mdDir + 2) = 0;  				*((uint*)mdDir + 3) = 0;    				VirtualProtect(mdHdr' 4' 0x40' out old);  				*(uint*)mdHdr = 0;  				mdHdr += 12;  				mdHdr += *(uint*)mdHdr;  				mdHdr = (byte*)(((ulong)mdHdr + 7) & ~3UL);  				mdHdr += 2;  				ushort numOfStream = *mdHdr;  				mdHdr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdr' 8' 0x40' out old);  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdr' 4' 0x40' out old);  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 3;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 2;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 1;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  					}  				}  			}  			else //Flat  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				uint mdDir = *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;  				uint importDir = *(uint*)(ptr - 0x78);    				var vAdrs = new uint[sectNum];  				var vSizes = new uint[sectNum];  				var rAdrs = new uint[sectNum];  				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					vAdrs[i] = *(uint*)(ptr + 12);  					vSizes[i] = *(uint*)(ptr + 8);  					rAdrs[i] = *(uint*)(ptr + 20);  					ptr += 0x28;  				}      				if (importDir != 0) {  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= importDir && importDir < vAdrs[i] + vSizes[i]) {  							importDir = importDir - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* importDirPtr = bas + importDir;  					uint oftMod = *(uint*)importDirPtr;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= oftMod && oftMod < vAdrs[i] + vSizes[i]) {  							oftMod = oftMod - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* oftModPtr = bas + oftMod;  					uint modName = *(uint*)(importDirPtr + 12);  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= modName && modName < vAdrs[i] + vSizes[i]) {  							modName = modName - vAdrs[i] + rAdrs[i];  							break;  						}  					uint funcName = *(uint*)oftModPtr + 2;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= funcName && funcName < vAdrs[i] + vSizes[i]) {  							funcName = funcName - vAdrs[i] + rAdrs[i];  							break;  						}  					VirtualProtect(bas + modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + modName + i) = *(@new + i);    					VirtualProtect(bas + funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + funcName + i) = *(@new + i);  				}      				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdDir && mdDir < vAdrs[i] + vSizes[i]) {  						mdDir = mdDir - vAdrs[i] + rAdrs[i];  						break;  					}  				byte* mdDirPtr = bas + mdDir;  				VirtualProtect(mdDirPtr' 0x48' 0x40' out old);  				uint mdHdr = *(uint*)(mdDirPtr + 8);  				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdHdr && mdHdr < vAdrs[i] + vSizes[i]) {  						mdHdr = mdHdr - vAdrs[i] + rAdrs[i];  						break;  					}  				*(uint*)mdDirPtr = 0;  				*((uint*)mdDirPtr + 1) = 0;  				*((uint*)mdDirPtr + 2) = 0;  				*((uint*)mdDirPtr + 3) = 0;      				byte* mdHdrPtr = bas + mdHdr;  				VirtualProtect(mdHdrPtr' 4' 0x40' out old);  				*(uint*)mdHdrPtr = 0;  				mdHdrPtr += 12;  				mdHdrPtr += *(uint*)mdHdrPtr;  				mdHdrPtr = (byte*)(((ulong)mdHdrPtr + 7) & ~3UL);  				mdHdrPtr += 2;  				ushort numOfStream = *mdHdrPtr;  				mdHdrPtr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdrPtr' 8' 0x40' out old);  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdrPtr' 4' 0x40' out old);  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 3;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 2;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 1;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  					}  				}  			}
Magic Number,Confuser.Runtime,AntiDump,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiDump.cs,Initialize,The following statement contains a magic number: if (module.FullyQualifiedName[0] != '<') //Mapped  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				byte* mdDir = bas + *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;    				if (*(uint*)(ptr - 0x78) != 0) {  					byte* importDir = bas + *(uint*)(ptr - 0x78);  					byte* oftMod = bas + *(uint*)importDir;  					byte* modName = bas + *(uint*)(importDir + 12);  					byte* funcName = bas + *(uint*)oftMod + 2;  					VirtualProtect(modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(modName + i) = *(@new + i);    					VirtualProtect(funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(funcName + i) = *(@new + i);  				}    				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					ptr += 0x28;  				}  				VirtualProtect(mdDir' 0x48' 0x40' out old);  				byte* mdHdr = bas + *(uint*)(mdDir + 8);  				*(uint*)mdDir = 0;  				*((uint*)mdDir + 1) = 0;  				*((uint*)mdDir + 2) = 0;  				*((uint*)mdDir + 3) = 0;    				VirtualProtect(mdHdr' 4' 0x40' out old);  				*(uint*)mdHdr = 0;  				mdHdr += 12;  				mdHdr += *(uint*)mdHdr;  				mdHdr = (byte*)(((ulong)mdHdr + 7) & ~3UL);  				mdHdr += 2;  				ushort numOfStream = *mdHdr;  				mdHdr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdr' 8' 0x40' out old);  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdr' 4' 0x40' out old);  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 3;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 2;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 1;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  					}  				}  			}  			else //Flat  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				uint mdDir = *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;  				uint importDir = *(uint*)(ptr - 0x78);    				var vAdrs = new uint[sectNum];  				var vSizes = new uint[sectNum];  				var rAdrs = new uint[sectNum];  				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					vAdrs[i] = *(uint*)(ptr + 12);  					vSizes[i] = *(uint*)(ptr + 8);  					rAdrs[i] = *(uint*)(ptr + 20);  					ptr += 0x28;  				}      				if (importDir != 0) {  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= importDir && importDir < vAdrs[i] + vSizes[i]) {  							importDir = importDir - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* importDirPtr = bas + importDir;  					uint oftMod = *(uint*)importDirPtr;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= oftMod && oftMod < vAdrs[i] + vSizes[i]) {  							oftMod = oftMod - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* oftModPtr = bas + oftMod;  					uint modName = *(uint*)(importDirPtr + 12);  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= modName && modName < vAdrs[i] + vSizes[i]) {  							modName = modName - vAdrs[i] + rAdrs[i];  							break;  						}  					uint funcName = *(uint*)oftModPtr + 2;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= funcName && funcName < vAdrs[i] + vSizes[i]) {  							funcName = funcName - vAdrs[i] + rAdrs[i];  							break;  						}  					VirtualProtect(bas + modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + modName + i) = *(@new + i);    					VirtualProtect(bas + funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + funcName + i) = *(@new + i);  				}      				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdDir && mdDir < vAdrs[i] + vSizes[i]) {  						mdDir = mdDir - vAdrs[i] + rAdrs[i];  						break;  					}  				byte* mdDirPtr = bas + mdDir;  				VirtualProtect(mdDirPtr' 0x48' 0x40' out old);  				uint mdHdr = *(uint*)(mdDirPtr + 8);  				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdHdr && mdHdr < vAdrs[i] + vSizes[i]) {  						mdHdr = mdHdr - vAdrs[i] + rAdrs[i];  						break;  					}  				*(uint*)mdDirPtr = 0;  				*((uint*)mdDirPtr + 1) = 0;  				*((uint*)mdDirPtr + 2) = 0;  				*((uint*)mdDirPtr + 3) = 0;      				byte* mdHdrPtr = bas + mdHdr;  				VirtualProtect(mdHdrPtr' 4' 0x40' out old);  				*(uint*)mdHdrPtr = 0;  				mdHdrPtr += 12;  				mdHdrPtr += *(uint*)mdHdrPtr;  				mdHdrPtr = (byte*)(((ulong)mdHdrPtr + 7) & ~3UL);  				mdHdrPtr += 2;  				ushort numOfStream = *mdHdrPtr;  				mdHdrPtr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdrPtr' 8' 0x40' out old);  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdrPtr' 4' 0x40' out old);  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 3;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 2;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 1;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  					}  				}  			}
Magic Number,Confuser.Runtime,AntiDump,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiDump.cs,Initialize,The following statement contains a magic number: if (module.FullyQualifiedName[0] != '<') //Mapped  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				byte* mdDir = bas + *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;    				if (*(uint*)(ptr - 0x78) != 0) {  					byte* importDir = bas + *(uint*)(ptr - 0x78);  					byte* oftMod = bas + *(uint*)importDir;  					byte* modName = bas + *(uint*)(importDir + 12);  					byte* funcName = bas + *(uint*)oftMod + 2;  					VirtualProtect(modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(modName + i) = *(@new + i);    					VirtualProtect(funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(funcName + i) = *(@new + i);  				}    				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					ptr += 0x28;  				}  				VirtualProtect(mdDir' 0x48' 0x40' out old);  				byte* mdHdr = bas + *(uint*)(mdDir + 8);  				*(uint*)mdDir = 0;  				*((uint*)mdDir + 1) = 0;  				*((uint*)mdDir + 2) = 0;  				*((uint*)mdDir + 3) = 0;    				VirtualProtect(mdHdr' 4' 0x40' out old);  				*(uint*)mdHdr = 0;  				mdHdr += 12;  				mdHdr += *(uint*)mdHdr;  				mdHdr = (byte*)(((ulong)mdHdr + 7) & ~3UL);  				mdHdr += 2;  				ushort numOfStream = *mdHdr;  				mdHdr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdr' 8' 0x40' out old);  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdr' 4' 0x40' out old);  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 3;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 2;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 1;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  					}  				}  			}  			else //Flat  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				uint mdDir = *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;  				uint importDir = *(uint*)(ptr - 0x78);    				var vAdrs = new uint[sectNum];  				var vSizes = new uint[sectNum];  				var rAdrs = new uint[sectNum];  				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					vAdrs[i] = *(uint*)(ptr + 12);  					vSizes[i] = *(uint*)(ptr + 8);  					rAdrs[i] = *(uint*)(ptr + 20);  					ptr += 0x28;  				}      				if (importDir != 0) {  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= importDir && importDir < vAdrs[i] + vSizes[i]) {  							importDir = importDir - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* importDirPtr = bas + importDir;  					uint oftMod = *(uint*)importDirPtr;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= oftMod && oftMod < vAdrs[i] + vSizes[i]) {  							oftMod = oftMod - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* oftModPtr = bas + oftMod;  					uint modName = *(uint*)(importDirPtr + 12);  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= modName && modName < vAdrs[i] + vSizes[i]) {  							modName = modName - vAdrs[i] + rAdrs[i];  							break;  						}  					uint funcName = *(uint*)oftModPtr + 2;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= funcName && funcName < vAdrs[i] + vSizes[i]) {  							funcName = funcName - vAdrs[i] + rAdrs[i];  							break;  						}  					VirtualProtect(bas + modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + modName + i) = *(@new + i);    					VirtualProtect(bas + funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + funcName + i) = *(@new + i);  				}      				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdDir && mdDir < vAdrs[i] + vSizes[i]) {  						mdDir = mdDir - vAdrs[i] + rAdrs[i];  						break;  					}  				byte* mdDirPtr = bas + mdDir;  				VirtualProtect(mdDirPtr' 0x48' 0x40' out old);  				uint mdHdr = *(uint*)(mdDirPtr + 8);  				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdHdr && mdHdr < vAdrs[i] + vSizes[i]) {  						mdHdr = mdHdr - vAdrs[i] + rAdrs[i];  						break;  					}  				*(uint*)mdDirPtr = 0;  				*((uint*)mdDirPtr + 1) = 0;  				*((uint*)mdDirPtr + 2) = 0;  				*((uint*)mdDirPtr + 3) = 0;      				byte* mdHdrPtr = bas + mdHdr;  				VirtualProtect(mdHdrPtr' 4' 0x40' out old);  				*(uint*)mdHdrPtr = 0;  				mdHdrPtr += 12;  				mdHdrPtr += *(uint*)mdHdrPtr;  				mdHdrPtr = (byte*)(((ulong)mdHdrPtr + 7) & ~3UL);  				mdHdrPtr += 2;  				ushort numOfStream = *mdHdrPtr;  				mdHdrPtr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdrPtr' 8' 0x40' out old);  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdrPtr' 4' 0x40' out old);  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 3;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 2;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 1;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  					}  				}  			}
Magic Number,Confuser.Runtime,AntiDump,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiDump.cs,Initialize,The following statement contains a magic number: if (module.FullyQualifiedName[0] != '<') //Mapped  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				byte* mdDir = bas + *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;    				if (*(uint*)(ptr - 0x78) != 0) {  					byte* importDir = bas + *(uint*)(ptr - 0x78);  					byte* oftMod = bas + *(uint*)importDir;  					byte* modName = bas + *(uint*)(importDir + 12);  					byte* funcName = bas + *(uint*)oftMod + 2;  					VirtualProtect(modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(modName + i) = *(@new + i);    					VirtualProtect(funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(funcName + i) = *(@new + i);  				}    				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					ptr += 0x28;  				}  				VirtualProtect(mdDir' 0x48' 0x40' out old);  				byte* mdHdr = bas + *(uint*)(mdDir + 8);  				*(uint*)mdDir = 0;  				*((uint*)mdDir + 1) = 0;  				*((uint*)mdDir + 2) = 0;  				*((uint*)mdDir + 3) = 0;    				VirtualProtect(mdHdr' 4' 0x40' out old);  				*(uint*)mdHdr = 0;  				mdHdr += 12;  				mdHdr += *(uint*)mdHdr;  				mdHdr = (byte*)(((ulong)mdHdr + 7) & ~3UL);  				mdHdr += 2;  				ushort numOfStream = *mdHdr;  				mdHdr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdr' 8' 0x40' out old);  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdr' 4' 0x40' out old);  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 3;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 2;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 1;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  					}  				}  			}  			else //Flat  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				uint mdDir = *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;  				uint importDir = *(uint*)(ptr - 0x78);    				var vAdrs = new uint[sectNum];  				var vSizes = new uint[sectNum];  				var rAdrs = new uint[sectNum];  				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					vAdrs[i] = *(uint*)(ptr + 12);  					vSizes[i] = *(uint*)(ptr + 8);  					rAdrs[i] = *(uint*)(ptr + 20);  					ptr += 0x28;  				}      				if (importDir != 0) {  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= importDir && importDir < vAdrs[i] + vSizes[i]) {  							importDir = importDir - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* importDirPtr = bas + importDir;  					uint oftMod = *(uint*)importDirPtr;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= oftMod && oftMod < vAdrs[i] + vSizes[i]) {  							oftMod = oftMod - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* oftModPtr = bas + oftMod;  					uint modName = *(uint*)(importDirPtr + 12);  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= modName && modName < vAdrs[i] + vSizes[i]) {  							modName = modName - vAdrs[i] + rAdrs[i];  							break;  						}  					uint funcName = *(uint*)oftModPtr + 2;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= funcName && funcName < vAdrs[i] + vSizes[i]) {  							funcName = funcName - vAdrs[i] + rAdrs[i];  							break;  						}  					VirtualProtect(bas + modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + modName + i) = *(@new + i);    					VirtualProtect(bas + funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + funcName + i) = *(@new + i);  				}      				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdDir && mdDir < vAdrs[i] + vSizes[i]) {  						mdDir = mdDir - vAdrs[i] + rAdrs[i];  						break;  					}  				byte* mdDirPtr = bas + mdDir;  				VirtualProtect(mdDirPtr' 0x48' 0x40' out old);  				uint mdHdr = *(uint*)(mdDirPtr + 8);  				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdHdr && mdHdr < vAdrs[i] + vSizes[i]) {  						mdHdr = mdHdr - vAdrs[i] + rAdrs[i];  						break;  					}  				*(uint*)mdDirPtr = 0;  				*((uint*)mdDirPtr + 1) = 0;  				*((uint*)mdDirPtr + 2) = 0;  				*((uint*)mdDirPtr + 3) = 0;      				byte* mdHdrPtr = bas + mdHdr;  				VirtualProtect(mdHdrPtr' 4' 0x40' out old);  				*(uint*)mdHdrPtr = 0;  				mdHdrPtr += 12;  				mdHdrPtr += *(uint*)mdHdrPtr;  				mdHdrPtr = (byte*)(((ulong)mdHdrPtr + 7) & ~3UL);  				mdHdrPtr += 2;  				ushort numOfStream = *mdHdrPtr;  				mdHdrPtr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdrPtr' 8' 0x40' out old);  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdrPtr' 4' 0x40' out old);  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 3;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 2;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 1;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  					}  				}  			}
Magic Number,Confuser.Runtime,AntiDump,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiDump.cs,Initialize,The following statement contains a magic number: if (module.FullyQualifiedName[0] != '<') //Mapped  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				byte* mdDir = bas + *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;    				if (*(uint*)(ptr - 0x78) != 0) {  					byte* importDir = bas + *(uint*)(ptr - 0x78);  					byte* oftMod = bas + *(uint*)importDir;  					byte* modName = bas + *(uint*)(importDir + 12);  					byte* funcName = bas + *(uint*)oftMod + 2;  					VirtualProtect(modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(modName + i) = *(@new + i);    					VirtualProtect(funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(funcName + i) = *(@new + i);  				}    				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					ptr += 0x28;  				}  				VirtualProtect(mdDir' 0x48' 0x40' out old);  				byte* mdHdr = bas + *(uint*)(mdDir + 8);  				*(uint*)mdDir = 0;  				*((uint*)mdDir + 1) = 0;  				*((uint*)mdDir + 2) = 0;  				*((uint*)mdDir + 3) = 0;    				VirtualProtect(mdHdr' 4' 0x40' out old);  				*(uint*)mdHdr = 0;  				mdHdr += 12;  				mdHdr += *(uint*)mdHdr;  				mdHdr = (byte*)(((ulong)mdHdr + 7) & ~3UL);  				mdHdr += 2;  				ushort numOfStream = *mdHdr;  				mdHdr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdr' 8' 0x40' out old);  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdr' 4' 0x40' out old);  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 3;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 2;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 1;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  					}  				}  			}  			else //Flat  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				uint mdDir = *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;  				uint importDir = *(uint*)(ptr - 0x78);    				var vAdrs = new uint[sectNum];  				var vSizes = new uint[sectNum];  				var rAdrs = new uint[sectNum];  				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					vAdrs[i] = *(uint*)(ptr + 12);  					vSizes[i] = *(uint*)(ptr + 8);  					rAdrs[i] = *(uint*)(ptr + 20);  					ptr += 0x28;  				}      				if (importDir != 0) {  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= importDir && importDir < vAdrs[i] + vSizes[i]) {  							importDir = importDir - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* importDirPtr = bas + importDir;  					uint oftMod = *(uint*)importDirPtr;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= oftMod && oftMod < vAdrs[i] + vSizes[i]) {  							oftMod = oftMod - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* oftModPtr = bas + oftMod;  					uint modName = *(uint*)(importDirPtr + 12);  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= modName && modName < vAdrs[i] + vSizes[i]) {  							modName = modName - vAdrs[i] + rAdrs[i];  							break;  						}  					uint funcName = *(uint*)oftModPtr + 2;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= funcName && funcName < vAdrs[i] + vSizes[i]) {  							funcName = funcName - vAdrs[i] + rAdrs[i];  							break;  						}  					VirtualProtect(bas + modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + modName + i) = *(@new + i);    					VirtualProtect(bas + funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + funcName + i) = *(@new + i);  				}      				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdDir && mdDir < vAdrs[i] + vSizes[i]) {  						mdDir = mdDir - vAdrs[i] + rAdrs[i];  						break;  					}  				byte* mdDirPtr = bas + mdDir;  				VirtualProtect(mdDirPtr' 0x48' 0x40' out old);  				uint mdHdr = *(uint*)(mdDirPtr + 8);  				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdHdr && mdHdr < vAdrs[i] + vSizes[i]) {  						mdHdr = mdHdr - vAdrs[i] + rAdrs[i];  						break;  					}  				*(uint*)mdDirPtr = 0;  				*((uint*)mdDirPtr + 1) = 0;  				*((uint*)mdDirPtr + 2) = 0;  				*((uint*)mdDirPtr + 3) = 0;      				byte* mdHdrPtr = bas + mdHdr;  				VirtualProtect(mdHdrPtr' 4' 0x40' out old);  				*(uint*)mdHdrPtr = 0;  				mdHdrPtr += 12;  				mdHdrPtr += *(uint*)mdHdrPtr;  				mdHdrPtr = (byte*)(((ulong)mdHdrPtr + 7) & ~3UL);  				mdHdrPtr += 2;  				ushort numOfStream = *mdHdrPtr;  				mdHdrPtr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdrPtr' 8' 0x40' out old);  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdrPtr' 4' 0x40' out old);  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 3;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 2;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 1;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  					}  				}  			}
Magic Number,Confuser.Runtime,AntiDump,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiDump.cs,Initialize,The following statement contains a magic number: if (module.FullyQualifiedName[0] != '<') //Mapped  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				byte* mdDir = bas + *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;    				if (*(uint*)(ptr - 0x78) != 0) {  					byte* importDir = bas + *(uint*)(ptr - 0x78);  					byte* oftMod = bas + *(uint*)importDir;  					byte* modName = bas + *(uint*)(importDir + 12);  					byte* funcName = bas + *(uint*)oftMod + 2;  					VirtualProtect(modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(modName + i) = *(@new + i);    					VirtualProtect(funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(funcName + i) = *(@new + i);  				}    				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					ptr += 0x28;  				}  				VirtualProtect(mdDir' 0x48' 0x40' out old);  				byte* mdHdr = bas + *(uint*)(mdDir + 8);  				*(uint*)mdDir = 0;  				*((uint*)mdDir + 1) = 0;  				*((uint*)mdDir + 2) = 0;  				*((uint*)mdDir + 3) = 0;    				VirtualProtect(mdHdr' 4' 0x40' out old);  				*(uint*)mdHdr = 0;  				mdHdr += 12;  				mdHdr += *(uint*)mdHdr;  				mdHdr = (byte*)(((ulong)mdHdr + 7) & ~3UL);  				mdHdr += 2;  				ushort numOfStream = *mdHdr;  				mdHdr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdr' 8' 0x40' out old);  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdr' 4' 0x40' out old);  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 3;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 2;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 1;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  					}  				}  			}  			else //Flat  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				uint mdDir = *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;  				uint importDir = *(uint*)(ptr - 0x78);    				var vAdrs = new uint[sectNum];  				var vSizes = new uint[sectNum];  				var rAdrs = new uint[sectNum];  				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					vAdrs[i] = *(uint*)(ptr + 12);  					vSizes[i] = *(uint*)(ptr + 8);  					rAdrs[i] = *(uint*)(ptr + 20);  					ptr += 0x28;  				}      				if (importDir != 0) {  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= importDir && importDir < vAdrs[i] + vSizes[i]) {  							importDir = importDir - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* importDirPtr = bas + importDir;  					uint oftMod = *(uint*)importDirPtr;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= oftMod && oftMod < vAdrs[i] + vSizes[i]) {  							oftMod = oftMod - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* oftModPtr = bas + oftMod;  					uint modName = *(uint*)(importDirPtr + 12);  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= modName && modName < vAdrs[i] + vSizes[i]) {  							modName = modName - vAdrs[i] + rAdrs[i];  							break;  						}  					uint funcName = *(uint*)oftModPtr + 2;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= funcName && funcName < vAdrs[i] + vSizes[i]) {  							funcName = funcName - vAdrs[i] + rAdrs[i];  							break;  						}  					VirtualProtect(bas + modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + modName + i) = *(@new + i);    					VirtualProtect(bas + funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + funcName + i) = *(@new + i);  				}      				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdDir && mdDir < vAdrs[i] + vSizes[i]) {  						mdDir = mdDir - vAdrs[i] + rAdrs[i];  						break;  					}  				byte* mdDirPtr = bas + mdDir;  				VirtualProtect(mdDirPtr' 0x48' 0x40' out old);  				uint mdHdr = *(uint*)(mdDirPtr + 8);  				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdHdr && mdHdr < vAdrs[i] + vSizes[i]) {  						mdHdr = mdHdr - vAdrs[i] + rAdrs[i];  						break;  					}  				*(uint*)mdDirPtr = 0;  				*((uint*)mdDirPtr + 1) = 0;  				*((uint*)mdDirPtr + 2) = 0;  				*((uint*)mdDirPtr + 3) = 0;      				byte* mdHdrPtr = bas + mdHdr;  				VirtualProtect(mdHdrPtr' 4' 0x40' out old);  				*(uint*)mdHdrPtr = 0;  				mdHdrPtr += 12;  				mdHdrPtr += *(uint*)mdHdrPtr;  				mdHdrPtr = (byte*)(((ulong)mdHdrPtr + 7) & ~3UL);  				mdHdrPtr += 2;  				ushort numOfStream = *mdHdrPtr;  				mdHdrPtr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdrPtr' 8' 0x40' out old);  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdrPtr' 4' 0x40' out old);  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 3;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 2;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 1;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  					}  				}  			}
Magic Number,Confuser.Runtime,AntiDump,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiDump.cs,Initialize,The following statement contains a magic number: if (module.FullyQualifiedName[0] != '<') //Mapped  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				byte* mdDir = bas + *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;    				if (*(uint*)(ptr - 0x78) != 0) {  					byte* importDir = bas + *(uint*)(ptr - 0x78);  					byte* oftMod = bas + *(uint*)importDir;  					byte* modName = bas + *(uint*)(importDir + 12);  					byte* funcName = bas + *(uint*)oftMod + 2;  					VirtualProtect(modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(modName + i) = *(@new + i);    					VirtualProtect(funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(funcName + i) = *(@new + i);  				}    				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					ptr += 0x28;  				}  				VirtualProtect(mdDir' 0x48' 0x40' out old);  				byte* mdHdr = bas + *(uint*)(mdDir + 8);  				*(uint*)mdDir = 0;  				*((uint*)mdDir + 1) = 0;  				*((uint*)mdDir + 2) = 0;  				*((uint*)mdDir + 3) = 0;    				VirtualProtect(mdHdr' 4' 0x40' out old);  				*(uint*)mdHdr = 0;  				mdHdr += 12;  				mdHdr += *(uint*)mdHdr;  				mdHdr = (byte*)(((ulong)mdHdr + 7) & ~3UL);  				mdHdr += 2;  				ushort numOfStream = *mdHdr;  				mdHdr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdr' 8' 0x40' out old);  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdr' 4' 0x40' out old);  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 3;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 2;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 1;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  					}  				}  			}  			else //Flat  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				uint mdDir = *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;  				uint importDir = *(uint*)(ptr - 0x78);    				var vAdrs = new uint[sectNum];  				var vSizes = new uint[sectNum];  				var rAdrs = new uint[sectNum];  				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					vAdrs[i] = *(uint*)(ptr + 12);  					vSizes[i] = *(uint*)(ptr + 8);  					rAdrs[i] = *(uint*)(ptr + 20);  					ptr += 0x28;  				}      				if (importDir != 0) {  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= importDir && importDir < vAdrs[i] + vSizes[i]) {  							importDir = importDir - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* importDirPtr = bas + importDir;  					uint oftMod = *(uint*)importDirPtr;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= oftMod && oftMod < vAdrs[i] + vSizes[i]) {  							oftMod = oftMod - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* oftModPtr = bas + oftMod;  					uint modName = *(uint*)(importDirPtr + 12);  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= modName && modName < vAdrs[i] + vSizes[i]) {  							modName = modName - vAdrs[i] + rAdrs[i];  							break;  						}  					uint funcName = *(uint*)oftModPtr + 2;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= funcName && funcName < vAdrs[i] + vSizes[i]) {  							funcName = funcName - vAdrs[i] + rAdrs[i];  							break;  						}  					VirtualProtect(bas + modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + modName + i) = *(@new + i);    					VirtualProtect(bas + funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + funcName + i) = *(@new + i);  				}      				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdDir && mdDir < vAdrs[i] + vSizes[i]) {  						mdDir = mdDir - vAdrs[i] + rAdrs[i];  						break;  					}  				byte* mdDirPtr = bas + mdDir;  				VirtualProtect(mdDirPtr' 0x48' 0x40' out old);  				uint mdHdr = *(uint*)(mdDirPtr + 8);  				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdHdr && mdHdr < vAdrs[i] + vSizes[i]) {  						mdHdr = mdHdr - vAdrs[i] + rAdrs[i];  						break;  					}  				*(uint*)mdDirPtr = 0;  				*((uint*)mdDirPtr + 1) = 0;  				*((uint*)mdDirPtr + 2) = 0;  				*((uint*)mdDirPtr + 3) = 0;      				byte* mdHdrPtr = bas + mdHdr;  				VirtualProtect(mdHdrPtr' 4' 0x40' out old);  				*(uint*)mdHdrPtr = 0;  				mdHdrPtr += 12;  				mdHdrPtr += *(uint*)mdHdrPtr;  				mdHdrPtr = (byte*)(((ulong)mdHdrPtr + 7) & ~3UL);  				mdHdrPtr += 2;  				ushort numOfStream = *mdHdrPtr;  				mdHdrPtr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdrPtr' 8' 0x40' out old);  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdrPtr' 4' 0x40' out old);  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 3;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 2;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 1;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  					}  				}  			}
Magic Number,Confuser.Runtime,AntiDump,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiDump.cs,Initialize,The following statement contains a magic number: if (module.FullyQualifiedName[0] != '<') //Mapped  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				byte* mdDir = bas + *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;    				if (*(uint*)(ptr - 0x78) != 0) {  					byte* importDir = bas + *(uint*)(ptr - 0x78);  					byte* oftMod = bas + *(uint*)importDir;  					byte* modName = bas + *(uint*)(importDir + 12);  					byte* funcName = bas + *(uint*)oftMod + 2;  					VirtualProtect(modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(modName + i) = *(@new + i);    					VirtualProtect(funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(funcName + i) = *(@new + i);  				}    				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					ptr += 0x28;  				}  				VirtualProtect(mdDir' 0x48' 0x40' out old);  				byte* mdHdr = bas + *(uint*)(mdDir + 8);  				*(uint*)mdDir = 0;  				*((uint*)mdDir + 1) = 0;  				*((uint*)mdDir + 2) = 0;  				*((uint*)mdDir + 3) = 0;    				VirtualProtect(mdHdr' 4' 0x40' out old);  				*(uint*)mdHdr = 0;  				mdHdr += 12;  				mdHdr += *(uint*)mdHdr;  				mdHdr = (byte*)(((ulong)mdHdr + 7) & ~3UL);  				mdHdr += 2;  				ushort numOfStream = *mdHdr;  				mdHdr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdr' 8' 0x40' out old);  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdr' 4' 0x40' out old);  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 3;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 2;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 1;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  					}  				}  			}  			else //Flat  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				uint mdDir = *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;  				uint importDir = *(uint*)(ptr - 0x78);    				var vAdrs = new uint[sectNum];  				var vSizes = new uint[sectNum];  				var rAdrs = new uint[sectNum];  				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					vAdrs[i] = *(uint*)(ptr + 12);  					vSizes[i] = *(uint*)(ptr + 8);  					rAdrs[i] = *(uint*)(ptr + 20);  					ptr += 0x28;  				}      				if (importDir != 0) {  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= importDir && importDir < vAdrs[i] + vSizes[i]) {  							importDir = importDir - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* importDirPtr = bas + importDir;  					uint oftMod = *(uint*)importDirPtr;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= oftMod && oftMod < vAdrs[i] + vSizes[i]) {  							oftMod = oftMod - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* oftModPtr = bas + oftMod;  					uint modName = *(uint*)(importDirPtr + 12);  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= modName && modName < vAdrs[i] + vSizes[i]) {  							modName = modName - vAdrs[i] + rAdrs[i];  							break;  						}  					uint funcName = *(uint*)oftModPtr + 2;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= funcName && funcName < vAdrs[i] + vSizes[i]) {  							funcName = funcName - vAdrs[i] + rAdrs[i];  							break;  						}  					VirtualProtect(bas + modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + modName + i) = *(@new + i);    					VirtualProtect(bas + funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + funcName + i) = *(@new + i);  				}      				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdDir && mdDir < vAdrs[i] + vSizes[i]) {  						mdDir = mdDir - vAdrs[i] + rAdrs[i];  						break;  					}  				byte* mdDirPtr = bas + mdDir;  				VirtualProtect(mdDirPtr' 0x48' 0x40' out old);  				uint mdHdr = *(uint*)(mdDirPtr + 8);  				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdHdr && mdHdr < vAdrs[i] + vSizes[i]) {  						mdHdr = mdHdr - vAdrs[i] + rAdrs[i];  						break;  					}  				*(uint*)mdDirPtr = 0;  				*((uint*)mdDirPtr + 1) = 0;  				*((uint*)mdDirPtr + 2) = 0;  				*((uint*)mdDirPtr + 3) = 0;      				byte* mdHdrPtr = bas + mdHdr;  				VirtualProtect(mdHdrPtr' 4' 0x40' out old);  				*(uint*)mdHdrPtr = 0;  				mdHdrPtr += 12;  				mdHdrPtr += *(uint*)mdHdrPtr;  				mdHdrPtr = (byte*)(((ulong)mdHdrPtr + 7) & ~3UL);  				mdHdrPtr += 2;  				ushort numOfStream = *mdHdrPtr;  				mdHdrPtr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdrPtr' 8' 0x40' out old);  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdrPtr' 4' 0x40' out old);  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 3;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 2;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 1;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  					}  				}  			}
Magic Number,Confuser.Runtime,AntiDump,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiDump.cs,Initialize,The following statement contains a magic number: if (module.FullyQualifiedName[0] != '<') //Mapped  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				byte* mdDir = bas + *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;    				if (*(uint*)(ptr - 0x78) != 0) {  					byte* importDir = bas + *(uint*)(ptr - 0x78);  					byte* oftMod = bas + *(uint*)importDir;  					byte* modName = bas + *(uint*)(importDir + 12);  					byte* funcName = bas + *(uint*)oftMod + 2;  					VirtualProtect(modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(modName + i) = *(@new + i);    					VirtualProtect(funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(funcName + i) = *(@new + i);  				}    				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					ptr += 0x28;  				}  				VirtualProtect(mdDir' 0x48' 0x40' out old);  				byte* mdHdr = bas + *(uint*)(mdDir + 8);  				*(uint*)mdDir = 0;  				*((uint*)mdDir + 1) = 0;  				*((uint*)mdDir + 2) = 0;  				*((uint*)mdDir + 3) = 0;    				VirtualProtect(mdHdr' 4' 0x40' out old);  				*(uint*)mdHdr = 0;  				mdHdr += 12;  				mdHdr += *(uint*)mdHdr;  				mdHdr = (byte*)(((ulong)mdHdr + 7) & ~3UL);  				mdHdr += 2;  				ushort numOfStream = *mdHdr;  				mdHdr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdr' 8' 0x40' out old);  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdr' 4' 0x40' out old);  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 3;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 2;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 1;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  					}  				}  			}  			else //Flat  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				uint mdDir = *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;  				uint importDir = *(uint*)(ptr - 0x78);    				var vAdrs = new uint[sectNum];  				var vSizes = new uint[sectNum];  				var rAdrs = new uint[sectNum];  				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					vAdrs[i] = *(uint*)(ptr + 12);  					vSizes[i] = *(uint*)(ptr + 8);  					rAdrs[i] = *(uint*)(ptr + 20);  					ptr += 0x28;  				}      				if (importDir != 0) {  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= importDir && importDir < vAdrs[i] + vSizes[i]) {  							importDir = importDir - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* importDirPtr = bas + importDir;  					uint oftMod = *(uint*)importDirPtr;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= oftMod && oftMod < vAdrs[i] + vSizes[i]) {  							oftMod = oftMod - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* oftModPtr = bas + oftMod;  					uint modName = *(uint*)(importDirPtr + 12);  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= modName && modName < vAdrs[i] + vSizes[i]) {  							modName = modName - vAdrs[i] + rAdrs[i];  							break;  						}  					uint funcName = *(uint*)oftModPtr + 2;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= funcName && funcName < vAdrs[i] + vSizes[i]) {  							funcName = funcName - vAdrs[i] + rAdrs[i];  							break;  						}  					VirtualProtect(bas + modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + modName + i) = *(@new + i);    					VirtualProtect(bas + funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + funcName + i) = *(@new + i);  				}      				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdDir && mdDir < vAdrs[i] + vSizes[i]) {  						mdDir = mdDir - vAdrs[i] + rAdrs[i];  						break;  					}  				byte* mdDirPtr = bas + mdDir;  				VirtualProtect(mdDirPtr' 0x48' 0x40' out old);  				uint mdHdr = *(uint*)(mdDirPtr + 8);  				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdHdr && mdHdr < vAdrs[i] + vSizes[i]) {  						mdHdr = mdHdr - vAdrs[i] + rAdrs[i];  						break;  					}  				*(uint*)mdDirPtr = 0;  				*((uint*)mdDirPtr + 1) = 0;  				*((uint*)mdDirPtr + 2) = 0;  				*((uint*)mdDirPtr + 3) = 0;      				byte* mdHdrPtr = bas + mdHdr;  				VirtualProtect(mdHdrPtr' 4' 0x40' out old);  				*(uint*)mdHdrPtr = 0;  				mdHdrPtr += 12;  				mdHdrPtr += *(uint*)mdHdrPtr;  				mdHdrPtr = (byte*)(((ulong)mdHdrPtr + 7) & ~3UL);  				mdHdrPtr += 2;  				ushort numOfStream = *mdHdrPtr;  				mdHdrPtr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdrPtr' 8' 0x40' out old);  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdrPtr' 4' 0x40' out old);  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 3;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 2;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 1;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  					}  				}  			}
Magic Number,Confuser.Runtime,AntiDump,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiDump.cs,Initialize,The following statement contains a magic number: if (module.FullyQualifiedName[0] != '<') //Mapped  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				byte* mdDir = bas + *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;    				if (*(uint*)(ptr - 0x78) != 0) {  					byte* importDir = bas + *(uint*)(ptr - 0x78);  					byte* oftMod = bas + *(uint*)importDir;  					byte* modName = bas + *(uint*)(importDir + 12);  					byte* funcName = bas + *(uint*)oftMod + 2;  					VirtualProtect(modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(modName + i) = *(@new + i);    					VirtualProtect(funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(funcName + i) = *(@new + i);  				}    				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					ptr += 0x28;  				}  				VirtualProtect(mdDir' 0x48' 0x40' out old);  				byte* mdHdr = bas + *(uint*)(mdDir + 8);  				*(uint*)mdDir = 0;  				*((uint*)mdDir + 1) = 0;  				*((uint*)mdDir + 2) = 0;  				*((uint*)mdDir + 3) = 0;    				VirtualProtect(mdHdr' 4' 0x40' out old);  				*(uint*)mdHdr = 0;  				mdHdr += 12;  				mdHdr += *(uint*)mdHdr;  				mdHdr = (byte*)(((ulong)mdHdr + 7) & ~3UL);  				mdHdr += 2;  				ushort numOfStream = *mdHdr;  				mdHdr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdr' 8' 0x40' out old);  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdr' 4' 0x40' out old);  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 3;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 2;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 1;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  					}  				}  			}  			else //Flat  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				uint mdDir = *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;  				uint importDir = *(uint*)(ptr - 0x78);    				var vAdrs = new uint[sectNum];  				var vSizes = new uint[sectNum];  				var rAdrs = new uint[sectNum];  				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					vAdrs[i] = *(uint*)(ptr + 12);  					vSizes[i] = *(uint*)(ptr + 8);  					rAdrs[i] = *(uint*)(ptr + 20);  					ptr += 0x28;  				}      				if (importDir != 0) {  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= importDir && importDir < vAdrs[i] + vSizes[i]) {  							importDir = importDir - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* importDirPtr = bas + importDir;  					uint oftMod = *(uint*)importDirPtr;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= oftMod && oftMod < vAdrs[i] + vSizes[i]) {  							oftMod = oftMod - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* oftModPtr = bas + oftMod;  					uint modName = *(uint*)(importDirPtr + 12);  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= modName && modName < vAdrs[i] + vSizes[i]) {  							modName = modName - vAdrs[i] + rAdrs[i];  							break;  						}  					uint funcName = *(uint*)oftModPtr + 2;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= funcName && funcName < vAdrs[i] + vSizes[i]) {  							funcName = funcName - vAdrs[i] + rAdrs[i];  							break;  						}  					VirtualProtect(bas + modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + modName + i) = *(@new + i);    					VirtualProtect(bas + funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + funcName + i) = *(@new + i);  				}      				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdDir && mdDir < vAdrs[i] + vSizes[i]) {  						mdDir = mdDir - vAdrs[i] + rAdrs[i];  						break;  					}  				byte* mdDirPtr = bas + mdDir;  				VirtualProtect(mdDirPtr' 0x48' 0x40' out old);  				uint mdHdr = *(uint*)(mdDirPtr + 8);  				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdHdr && mdHdr < vAdrs[i] + vSizes[i]) {  						mdHdr = mdHdr - vAdrs[i] + rAdrs[i];  						break;  					}  				*(uint*)mdDirPtr = 0;  				*((uint*)mdDirPtr + 1) = 0;  				*((uint*)mdDirPtr + 2) = 0;  				*((uint*)mdDirPtr + 3) = 0;      				byte* mdHdrPtr = bas + mdHdr;  				VirtualProtect(mdHdrPtr' 4' 0x40' out old);  				*(uint*)mdHdrPtr = 0;  				mdHdrPtr += 12;  				mdHdrPtr += *(uint*)mdHdrPtr;  				mdHdrPtr = (byte*)(((ulong)mdHdrPtr + 7) & ~3UL);  				mdHdrPtr += 2;  				ushort numOfStream = *mdHdrPtr;  				mdHdrPtr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdrPtr' 8' 0x40' out old);  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdrPtr' 4' 0x40' out old);  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 3;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 2;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 1;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  					}  				}  			}
Magic Number,Confuser.Runtime,AntiDump,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiDump.cs,Initialize,The following statement contains a magic number: if (module.FullyQualifiedName[0] != '<') //Mapped  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				byte* mdDir = bas + *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;    				if (*(uint*)(ptr - 0x78) != 0) {  					byte* importDir = bas + *(uint*)(ptr - 0x78);  					byte* oftMod = bas + *(uint*)importDir;  					byte* modName = bas + *(uint*)(importDir + 12);  					byte* funcName = bas + *(uint*)oftMod + 2;  					VirtualProtect(modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(modName + i) = *(@new + i);    					VirtualProtect(funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(funcName + i) = *(@new + i);  				}    				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					ptr += 0x28;  				}  				VirtualProtect(mdDir' 0x48' 0x40' out old);  				byte* mdHdr = bas + *(uint*)(mdDir + 8);  				*(uint*)mdDir = 0;  				*((uint*)mdDir + 1) = 0;  				*((uint*)mdDir + 2) = 0;  				*((uint*)mdDir + 3) = 0;    				VirtualProtect(mdHdr' 4' 0x40' out old);  				*(uint*)mdHdr = 0;  				mdHdr += 12;  				mdHdr += *(uint*)mdHdr;  				mdHdr = (byte*)(((ulong)mdHdr + 7) & ~3UL);  				mdHdr += 2;  				ushort numOfStream = *mdHdr;  				mdHdr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdr' 8' 0x40' out old);  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdr' 4' 0x40' out old);  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 3;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 2;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 1;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  					}  				}  			}  			else //Flat  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				uint mdDir = *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;  				uint importDir = *(uint*)(ptr - 0x78);    				var vAdrs = new uint[sectNum];  				var vSizes = new uint[sectNum];  				var rAdrs = new uint[sectNum];  				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					vAdrs[i] = *(uint*)(ptr + 12);  					vSizes[i] = *(uint*)(ptr + 8);  					rAdrs[i] = *(uint*)(ptr + 20);  					ptr += 0x28;  				}      				if (importDir != 0) {  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= importDir && importDir < vAdrs[i] + vSizes[i]) {  							importDir = importDir - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* importDirPtr = bas + importDir;  					uint oftMod = *(uint*)importDirPtr;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= oftMod && oftMod < vAdrs[i] + vSizes[i]) {  							oftMod = oftMod - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* oftModPtr = bas + oftMod;  					uint modName = *(uint*)(importDirPtr + 12);  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= modName && modName < vAdrs[i] + vSizes[i]) {  							modName = modName - vAdrs[i] + rAdrs[i];  							break;  						}  					uint funcName = *(uint*)oftModPtr + 2;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= funcName && funcName < vAdrs[i] + vSizes[i]) {  							funcName = funcName - vAdrs[i] + rAdrs[i];  							break;  						}  					VirtualProtect(bas + modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + modName + i) = *(@new + i);    					VirtualProtect(bas + funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + funcName + i) = *(@new + i);  				}      				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdDir && mdDir < vAdrs[i] + vSizes[i]) {  						mdDir = mdDir - vAdrs[i] + rAdrs[i];  						break;  					}  				byte* mdDirPtr = bas + mdDir;  				VirtualProtect(mdDirPtr' 0x48' 0x40' out old);  				uint mdHdr = *(uint*)(mdDirPtr + 8);  				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdHdr && mdHdr < vAdrs[i] + vSizes[i]) {  						mdHdr = mdHdr - vAdrs[i] + rAdrs[i];  						break;  					}  				*(uint*)mdDirPtr = 0;  				*((uint*)mdDirPtr + 1) = 0;  				*((uint*)mdDirPtr + 2) = 0;  				*((uint*)mdDirPtr + 3) = 0;      				byte* mdHdrPtr = bas + mdHdr;  				VirtualProtect(mdHdrPtr' 4' 0x40' out old);  				*(uint*)mdHdrPtr = 0;  				mdHdrPtr += 12;  				mdHdrPtr += *(uint*)mdHdrPtr;  				mdHdrPtr = (byte*)(((ulong)mdHdrPtr + 7) & ~3UL);  				mdHdrPtr += 2;  				ushort numOfStream = *mdHdrPtr;  				mdHdrPtr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdrPtr' 8' 0x40' out old);  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdrPtr' 4' 0x40' out old);  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 3;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 2;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 1;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  					}  				}  			}
Magic Number,Confuser.Runtime,AntiDump,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiDump.cs,Initialize,The following statement contains a magic number: if (module.FullyQualifiedName[0] != '<') //Mapped  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				byte* mdDir = bas + *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;    				if (*(uint*)(ptr - 0x78) != 0) {  					byte* importDir = bas + *(uint*)(ptr - 0x78);  					byte* oftMod = bas + *(uint*)importDir;  					byte* modName = bas + *(uint*)(importDir + 12);  					byte* funcName = bas + *(uint*)oftMod + 2;  					VirtualProtect(modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(modName + i) = *(@new + i);    					VirtualProtect(funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(funcName + i) = *(@new + i);  				}    				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					ptr += 0x28;  				}  				VirtualProtect(mdDir' 0x48' 0x40' out old);  				byte* mdHdr = bas + *(uint*)(mdDir + 8);  				*(uint*)mdDir = 0;  				*((uint*)mdDir + 1) = 0;  				*((uint*)mdDir + 2) = 0;  				*((uint*)mdDir + 3) = 0;    				VirtualProtect(mdHdr' 4' 0x40' out old);  				*(uint*)mdHdr = 0;  				mdHdr += 12;  				mdHdr += *(uint*)mdHdr;  				mdHdr = (byte*)(((ulong)mdHdr + 7) & ~3UL);  				mdHdr += 2;  				ushort numOfStream = *mdHdr;  				mdHdr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdr' 8' 0x40' out old);  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdr' 4' 0x40' out old);  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 3;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 2;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 1;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  					}  				}  			}  			else //Flat  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				uint mdDir = *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;  				uint importDir = *(uint*)(ptr - 0x78);    				var vAdrs = new uint[sectNum];  				var vSizes = new uint[sectNum];  				var rAdrs = new uint[sectNum];  				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					vAdrs[i] = *(uint*)(ptr + 12);  					vSizes[i] = *(uint*)(ptr + 8);  					rAdrs[i] = *(uint*)(ptr + 20);  					ptr += 0x28;  				}      				if (importDir != 0) {  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= importDir && importDir < vAdrs[i] + vSizes[i]) {  							importDir = importDir - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* importDirPtr = bas + importDir;  					uint oftMod = *(uint*)importDirPtr;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= oftMod && oftMod < vAdrs[i] + vSizes[i]) {  							oftMod = oftMod - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* oftModPtr = bas + oftMod;  					uint modName = *(uint*)(importDirPtr + 12);  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= modName && modName < vAdrs[i] + vSizes[i]) {  							modName = modName - vAdrs[i] + rAdrs[i];  							break;  						}  					uint funcName = *(uint*)oftModPtr + 2;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= funcName && funcName < vAdrs[i] + vSizes[i]) {  							funcName = funcName - vAdrs[i] + rAdrs[i];  							break;  						}  					VirtualProtect(bas + modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + modName + i) = *(@new + i);    					VirtualProtect(bas + funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + funcName + i) = *(@new + i);  				}      				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdDir && mdDir < vAdrs[i] + vSizes[i]) {  						mdDir = mdDir - vAdrs[i] + rAdrs[i];  						break;  					}  				byte* mdDirPtr = bas + mdDir;  				VirtualProtect(mdDirPtr' 0x48' 0x40' out old);  				uint mdHdr = *(uint*)(mdDirPtr + 8);  				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdHdr && mdHdr < vAdrs[i] + vSizes[i]) {  						mdHdr = mdHdr - vAdrs[i] + rAdrs[i];  						break;  					}  				*(uint*)mdDirPtr = 0;  				*((uint*)mdDirPtr + 1) = 0;  				*((uint*)mdDirPtr + 2) = 0;  				*((uint*)mdDirPtr + 3) = 0;      				byte* mdHdrPtr = bas + mdHdr;  				VirtualProtect(mdHdrPtr' 4' 0x40' out old);  				*(uint*)mdHdrPtr = 0;  				mdHdrPtr += 12;  				mdHdrPtr += *(uint*)mdHdrPtr;  				mdHdrPtr = (byte*)(((ulong)mdHdrPtr + 7) & ~3UL);  				mdHdrPtr += 2;  				ushort numOfStream = *mdHdrPtr;  				mdHdrPtr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdrPtr' 8' 0x40' out old);  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdrPtr' 4' 0x40' out old);  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 3;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 2;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 1;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  					}  				}  			}
Magic Number,Confuser.Runtime,AntiDump,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiDump.cs,Initialize,The following statement contains a magic number: if (module.FullyQualifiedName[0] != '<') //Mapped  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				byte* mdDir = bas + *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;    				if (*(uint*)(ptr - 0x78) != 0) {  					byte* importDir = bas + *(uint*)(ptr - 0x78);  					byte* oftMod = bas + *(uint*)importDir;  					byte* modName = bas + *(uint*)(importDir + 12);  					byte* funcName = bas + *(uint*)oftMod + 2;  					VirtualProtect(modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(modName + i) = *(@new + i);    					VirtualProtect(funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(funcName + i) = *(@new + i);  				}    				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					ptr += 0x28;  				}  				VirtualProtect(mdDir' 0x48' 0x40' out old);  				byte* mdHdr = bas + *(uint*)(mdDir + 8);  				*(uint*)mdDir = 0;  				*((uint*)mdDir + 1) = 0;  				*((uint*)mdDir + 2) = 0;  				*((uint*)mdDir + 3) = 0;    				VirtualProtect(mdHdr' 4' 0x40' out old);  				*(uint*)mdHdr = 0;  				mdHdr += 12;  				mdHdr += *(uint*)mdHdr;  				mdHdr = (byte*)(((ulong)mdHdr + 7) & ~3UL);  				mdHdr += 2;  				ushort numOfStream = *mdHdr;  				mdHdr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdr' 8' 0x40' out old);  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdr' 4' 0x40' out old);  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 3;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 2;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 1;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  					}  				}  			}  			else //Flat  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				uint mdDir = *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;  				uint importDir = *(uint*)(ptr - 0x78);    				var vAdrs = new uint[sectNum];  				var vSizes = new uint[sectNum];  				var rAdrs = new uint[sectNum];  				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					vAdrs[i] = *(uint*)(ptr + 12);  					vSizes[i] = *(uint*)(ptr + 8);  					rAdrs[i] = *(uint*)(ptr + 20);  					ptr += 0x28;  				}      				if (importDir != 0) {  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= importDir && importDir < vAdrs[i] + vSizes[i]) {  							importDir = importDir - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* importDirPtr = bas + importDir;  					uint oftMod = *(uint*)importDirPtr;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= oftMod && oftMod < vAdrs[i] + vSizes[i]) {  							oftMod = oftMod - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* oftModPtr = bas + oftMod;  					uint modName = *(uint*)(importDirPtr + 12);  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= modName && modName < vAdrs[i] + vSizes[i]) {  							modName = modName - vAdrs[i] + rAdrs[i];  							break;  						}  					uint funcName = *(uint*)oftModPtr + 2;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= funcName && funcName < vAdrs[i] + vSizes[i]) {  							funcName = funcName - vAdrs[i] + rAdrs[i];  							break;  						}  					VirtualProtect(bas + modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + modName + i) = *(@new + i);    					VirtualProtect(bas + funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + funcName + i) = *(@new + i);  				}      				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdDir && mdDir < vAdrs[i] + vSizes[i]) {  						mdDir = mdDir - vAdrs[i] + rAdrs[i];  						break;  					}  				byte* mdDirPtr = bas + mdDir;  				VirtualProtect(mdDirPtr' 0x48' 0x40' out old);  				uint mdHdr = *(uint*)(mdDirPtr + 8);  				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdHdr && mdHdr < vAdrs[i] + vSizes[i]) {  						mdHdr = mdHdr - vAdrs[i] + rAdrs[i];  						break;  					}  				*(uint*)mdDirPtr = 0;  				*((uint*)mdDirPtr + 1) = 0;  				*((uint*)mdDirPtr + 2) = 0;  				*((uint*)mdDirPtr + 3) = 0;      				byte* mdHdrPtr = bas + mdHdr;  				VirtualProtect(mdHdrPtr' 4' 0x40' out old);  				*(uint*)mdHdrPtr = 0;  				mdHdrPtr += 12;  				mdHdrPtr += *(uint*)mdHdrPtr;  				mdHdrPtr = (byte*)(((ulong)mdHdrPtr + 7) & ~3UL);  				mdHdrPtr += 2;  				ushort numOfStream = *mdHdrPtr;  				mdHdrPtr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdrPtr' 8' 0x40' out old);  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdrPtr' 4' 0x40' out old);  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 3;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 2;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 1;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  					}  				}  			}
Magic Number,Confuser.Runtime,AntiDump,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiDump.cs,Initialize,The following statement contains a magic number: if (module.FullyQualifiedName[0] != '<') //Mapped  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				byte* mdDir = bas + *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;    				if (*(uint*)(ptr - 0x78) != 0) {  					byte* importDir = bas + *(uint*)(ptr - 0x78);  					byte* oftMod = bas + *(uint*)importDir;  					byte* modName = bas + *(uint*)(importDir + 12);  					byte* funcName = bas + *(uint*)oftMod + 2;  					VirtualProtect(modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(modName + i) = *(@new + i);    					VirtualProtect(funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(funcName + i) = *(@new + i);  				}    				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					ptr += 0x28;  				}  				VirtualProtect(mdDir' 0x48' 0x40' out old);  				byte* mdHdr = bas + *(uint*)(mdDir + 8);  				*(uint*)mdDir = 0;  				*((uint*)mdDir + 1) = 0;  				*((uint*)mdDir + 2) = 0;  				*((uint*)mdDir + 3) = 0;    				VirtualProtect(mdHdr' 4' 0x40' out old);  				*(uint*)mdHdr = 0;  				mdHdr += 12;  				mdHdr += *(uint*)mdHdr;  				mdHdr = (byte*)(((ulong)mdHdr + 7) & ~3UL);  				mdHdr += 2;  				ushort numOfStream = *mdHdr;  				mdHdr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdr' 8' 0x40' out old);  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdr' 4' 0x40' out old);  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 3;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 2;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 1;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  					}  				}  			}  			else //Flat  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				uint mdDir = *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;  				uint importDir = *(uint*)(ptr - 0x78);    				var vAdrs = new uint[sectNum];  				var vSizes = new uint[sectNum];  				var rAdrs = new uint[sectNum];  				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					vAdrs[i] = *(uint*)(ptr + 12);  					vSizes[i] = *(uint*)(ptr + 8);  					rAdrs[i] = *(uint*)(ptr + 20);  					ptr += 0x28;  				}      				if (importDir != 0) {  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= importDir && importDir < vAdrs[i] + vSizes[i]) {  							importDir = importDir - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* importDirPtr = bas + importDir;  					uint oftMod = *(uint*)importDirPtr;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= oftMod && oftMod < vAdrs[i] + vSizes[i]) {  							oftMod = oftMod - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* oftModPtr = bas + oftMod;  					uint modName = *(uint*)(importDirPtr + 12);  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= modName && modName < vAdrs[i] + vSizes[i]) {  							modName = modName - vAdrs[i] + rAdrs[i];  							break;  						}  					uint funcName = *(uint*)oftModPtr + 2;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= funcName && funcName < vAdrs[i] + vSizes[i]) {  							funcName = funcName - vAdrs[i] + rAdrs[i];  							break;  						}  					VirtualProtect(bas + modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + modName + i) = *(@new + i);    					VirtualProtect(bas + funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + funcName + i) = *(@new + i);  				}      				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdDir && mdDir < vAdrs[i] + vSizes[i]) {  						mdDir = mdDir - vAdrs[i] + rAdrs[i];  						break;  					}  				byte* mdDirPtr = bas + mdDir;  				VirtualProtect(mdDirPtr' 0x48' 0x40' out old);  				uint mdHdr = *(uint*)(mdDirPtr + 8);  				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdHdr && mdHdr < vAdrs[i] + vSizes[i]) {  						mdHdr = mdHdr - vAdrs[i] + rAdrs[i];  						break;  					}  				*(uint*)mdDirPtr = 0;  				*((uint*)mdDirPtr + 1) = 0;  				*((uint*)mdDirPtr + 2) = 0;  				*((uint*)mdDirPtr + 3) = 0;      				byte* mdHdrPtr = bas + mdHdr;  				VirtualProtect(mdHdrPtr' 4' 0x40' out old);  				*(uint*)mdHdrPtr = 0;  				mdHdrPtr += 12;  				mdHdrPtr += *(uint*)mdHdrPtr;  				mdHdrPtr = (byte*)(((ulong)mdHdrPtr + 7) & ~3UL);  				mdHdrPtr += 2;  				ushort numOfStream = *mdHdrPtr;  				mdHdrPtr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdrPtr' 8' 0x40' out old);  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdrPtr' 4' 0x40' out old);  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 3;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 2;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 1;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  					}  				}  			}
Magic Number,Confuser.Runtime,AntiDump,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiDump.cs,Initialize,The following statement contains a magic number: if (module.FullyQualifiedName[0] != '<') //Mapped  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				byte* mdDir = bas + *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;    				if (*(uint*)(ptr - 0x78) != 0) {  					byte* importDir = bas + *(uint*)(ptr - 0x78);  					byte* oftMod = bas + *(uint*)importDir;  					byte* modName = bas + *(uint*)(importDir + 12);  					byte* funcName = bas + *(uint*)oftMod + 2;  					VirtualProtect(modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(modName + i) = *(@new + i);    					VirtualProtect(funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(funcName + i) = *(@new + i);  				}    				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					ptr += 0x28;  				}  				VirtualProtect(mdDir' 0x48' 0x40' out old);  				byte* mdHdr = bas + *(uint*)(mdDir + 8);  				*(uint*)mdDir = 0;  				*((uint*)mdDir + 1) = 0;  				*((uint*)mdDir + 2) = 0;  				*((uint*)mdDir + 3) = 0;    				VirtualProtect(mdHdr' 4' 0x40' out old);  				*(uint*)mdHdr = 0;  				mdHdr += 12;  				mdHdr += *(uint*)mdHdr;  				mdHdr = (byte*)(((ulong)mdHdr + 7) & ~3UL);  				mdHdr += 2;  				ushort numOfStream = *mdHdr;  				mdHdr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdr' 8' 0x40' out old);  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					//*(uint*)mdHdr = 0;  					mdHdr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdr' 4' 0x40' out old);  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 3;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 2;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  						if (*mdHdr == 0) {  							mdHdr += 1;  							break;  						}  						*mdHdr = 0;  						mdHdr++;  					}  				}  			}  			else //Flat  			{  				//VirtualProtect(ptr - 16' 8' 0x40' out old);  				//*(uint*)(ptr - 12) = 0;  				uint mdDir = *(uint*)(ptr - 16);  				//*(uint*)(ptr - 16) = 0;  				uint importDir = *(uint*)(ptr - 0x78);    				var vAdrs = new uint[sectNum];  				var vSizes = new uint[sectNum];  				var rAdrs = new uint[sectNum];  				for (int i = 0; i < sectNum; i++) {  					VirtualProtect(ptr' 8' 0x40' out old);  					Marshal.Copy(new byte[8]' 0' (IntPtr)ptr' 8);  					vAdrs[i] = *(uint*)(ptr + 12);  					vSizes[i] = *(uint*)(ptr + 8);  					rAdrs[i] = *(uint*)(ptr + 20);  					ptr += 0x28;  				}      				if (importDir != 0) {  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= importDir && importDir < vAdrs[i] + vSizes[i]) {  							importDir = importDir - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* importDirPtr = bas + importDir;  					uint oftMod = *(uint*)importDirPtr;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= oftMod && oftMod < vAdrs[i] + vSizes[i]) {  							oftMod = oftMod - vAdrs[i] + rAdrs[i];  							break;  						}  					byte* oftModPtr = bas + oftMod;  					uint modName = *(uint*)(importDirPtr + 12);  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= modName && modName < vAdrs[i] + vSizes[i]) {  							modName = modName - vAdrs[i] + rAdrs[i];  							break;  						}  					uint funcName = *(uint*)oftModPtr + 2;  					for (int i = 0; i < sectNum; i++)  						if (vAdrs[i] <= funcName && funcName < vAdrs[i] + vSizes[i]) {  							funcName = funcName - vAdrs[i] + rAdrs[i];  							break;  						}  					VirtualProtect(bas + modName' 11' 0x40' out old);    					*(uint*)@new = 0x6c64746e;  					*((uint*)@new + 1) = 0x6c642e6c;  					*((ushort*)@new + 4) = 0x006c;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + modName + i) = *(@new + i);    					VirtualProtect(bas + funcName' 11' 0x40' out old);    					*(uint*)@new = 0x6f43744e;  					*((uint*)@new + 1) = 0x6e69746e;  					*((ushort*)@new + 4) = 0x6575;  					*(@new + 10) = 0;    					for (int i = 0; i < 11; i++)  						*(bas + funcName + i) = *(@new + i);  				}      				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdDir && mdDir < vAdrs[i] + vSizes[i]) {  						mdDir = mdDir - vAdrs[i] + rAdrs[i];  						break;  					}  				byte* mdDirPtr = bas + mdDir;  				VirtualProtect(mdDirPtr' 0x48' 0x40' out old);  				uint mdHdr = *(uint*)(mdDirPtr + 8);  				for (int i = 0; i < sectNum; i++)  					if (vAdrs[i] <= mdHdr && mdHdr < vAdrs[i] + vSizes[i]) {  						mdHdr = mdHdr - vAdrs[i] + rAdrs[i];  						break;  					}  				*(uint*)mdDirPtr = 0;  				*((uint*)mdDirPtr + 1) = 0;  				*((uint*)mdDirPtr + 2) = 0;  				*((uint*)mdDirPtr + 3) = 0;      				byte* mdHdrPtr = bas + mdHdr;  				VirtualProtect(mdHdrPtr' 4' 0x40' out old);  				*(uint*)mdHdrPtr = 0;  				mdHdrPtr += 12;  				mdHdrPtr += *(uint*)mdHdrPtr;  				mdHdrPtr = (byte*)(((ulong)mdHdrPtr + 7) & ~3UL);  				mdHdrPtr += 2;  				ushort numOfStream = *mdHdrPtr;  				mdHdrPtr += 2;  				for (int i = 0; i < numOfStream; i++) {  					VirtualProtect(mdHdrPtr' 8' 0x40' out old);  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					//*(uint*)mdHdrPtr = 0;  					mdHdrPtr += 4;  					for (int ii = 0; ii < 8; ii++) {  						VirtualProtect(mdHdrPtr' 4' 0x40' out old);  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 3;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 2;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  						if (*mdHdrPtr == 0) {  							mdHdrPtr += 1;  							break;  						}  						*mdHdrPtr = 0;  						mdHdrPtr++;  					}  				}  			}
Magic Number,Confuser.Runtime,AntiDebugWin32,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiDebug.Win32.cs,Worker,The following statement contains a magic number: if (th == null) {  				th = new Thread(Worker);  				th.IsBackground = true;  				th.Start(Thread.CurrentThread);  				Thread.Sleep(500);  			}
Magic Number,Confuser.Runtime,AntiDebugWin32,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiDebug.Win32.cs,Worker,The following statement contains a magic number: while (true) {  				// Managed  				if (Debugger.IsAttached || Debugger.IsLogging())  					Environment.FailFast("");    				// IsDebuggerPresent  				if (IsDebuggerPresent())  					Environment.FailFast("");    				// OpenProcess  				Process ps = Process.GetCurrentProcess();  				if (ps.Handle == IntPtr.Zero)  					Environment.FailFast("");  				ps.Close();    				// OutputDebugString  				if (OutputDebugString("") > IntPtr.Size)  					Environment.FailFast("");    				// CloseHandle  				try {  					CloseHandle(IntPtr.Zero);  				}  				catch {  					Environment.FailFast("");  				}    				if (!th.IsAlive)  					Environment.FailFast("");    				Thread.Sleep(1000);  			}
Magic Number,Confuser.Runtime,AntiDebugAntinet,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiDebug.Antinet.cs,InitializeAntiDebugger,The following statement contains a magic number: if (Environment.Version.Major == 2)  				pDebuggerIPCControlBlock = (byte*)*(IntPtr*)pDebuggerIPCControlBlock;
Magic Number,Confuser.Runtime,AntiDebugAntinet,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiDebug.Antinet.cs,GetInfo,The following statement contains a magic number: switch (Environment.Version.Major) {  				case 2:  					return IntPtr.Size == 4 ? Infos.info_CLR20_x86 : Infos.info_CLR20_x64;  				case 4:  					if (Environment.Version.Revision <= 17020)  						return IntPtr.Size == 4 ? Infos.info_CLR40_x86_1 : Infos.info_CLR40_x64;  					return IntPtr.Size == 4 ? Infos.info_CLR40_x86_2 : Infos.info_CLR40_x64;  				default:  					goto case 4; // Assume CLR 4.0  			}
Magic Number,Confuser.Runtime,AntiDebugAntinet,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiDebug.Antinet.cs,GetInfo,The following statement contains a magic number: switch (Environment.Version.Major) {  				case 2:  					return IntPtr.Size == 4 ? Infos.info_CLR20_x86 : Infos.info_CLR20_x64;  				case 4:  					if (Environment.Version.Revision <= 17020)  						return IntPtr.Size == 4 ? Infos.info_CLR40_x86_1 : Infos.info_CLR40_x64;  					return IntPtr.Size == 4 ? Infos.info_CLR40_x86_2 : Infos.info_CLR40_x64;  				default:  					goto case 4; // Assume CLR 4.0  			}
Magic Number,Confuser.Runtime,AntiDebugAntinet,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiDebug.Antinet.cs,GetInfo,The following statement contains a magic number: switch (Environment.Version.Major) {  				case 2:  					return IntPtr.Size == 4 ? Infos.info_CLR20_x86 : Infos.info_CLR20_x64;  				case 4:  					if (Environment.Version.Revision <= 17020)  						return IntPtr.Size == 4 ? Infos.info_CLR40_x86_1 : Infos.info_CLR40_x64;  					return IntPtr.Size == 4 ? Infos.info_CLR40_x86_2 : Infos.info_CLR40_x64;  				default:  					goto case 4; // Assume CLR 4.0  			}
Magic Number,Confuser.Runtime,AntiDebugAntinet,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiDebug.Antinet.cs,GetInfo,The following statement contains a magic number: switch (Environment.Version.Major) {  				case 2:  					return IntPtr.Size == 4 ? Infos.info_CLR20_x86 : Infos.info_CLR20_x64;  				case 4:  					if (Environment.Version.Revision <= 17020)  						return IntPtr.Size == 4 ? Infos.info_CLR40_x86_1 : Infos.info_CLR40_x64;  					return IntPtr.Size == 4 ? Infos.info_CLR40_x86_2 : Infos.info_CLR40_x64;  				default:  					goto case 4; // Assume CLR 4.0  			}
Magic Number,Confuser.Runtime,AntiDebugAntinet,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiDebug.Antinet.cs,GetInfo,The following statement contains a magic number: switch (Environment.Version.Major) {  				case 2:  					return IntPtr.Size == 4 ? Infos.info_CLR20_x86 : Infos.info_CLR20_x64;  				case 4:  					if (Environment.Version.Revision <= 17020)  						return IntPtr.Size == 4 ? Infos.info_CLR40_x86_1 : Infos.info_CLR40_x64;  					return IntPtr.Size == 4 ? Infos.info_CLR40_x86_2 : Infos.info_CLR40_x64;  				default:  					goto case 4; // Assume CLR 4.0  			}
Magic Number,Confuser.Runtime,AntiDebugAntinet,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiDebug.Antinet.cs,GetInfo,The following statement contains a magic number: switch (Environment.Version.Major) {  				case 2:  					return IntPtr.Size == 4 ? Infos.info_CLR20_x86 : Infos.info_CLR20_x64;  				case 4:  					if (Environment.Version.Revision <= 17020)  						return IntPtr.Size == 4 ? Infos.info_CLR40_x86_1 : Infos.info_CLR40_x64;  					return IntPtr.Size == 4 ? Infos.info_CLR40_x86_2 : Infos.info_CLR40_x64;  				default:  					goto case 4; // Assume CLR 4.0  			}
Magic Number,Confuser.Runtime,AntiDebugAntinet,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiDebug.Antinet.cs,GetInfo,The following statement contains a magic number: switch (Environment.Version.Major) {  				case 2:  					return IntPtr.Size == 4 ? Infos.info_CLR20_x86 : Infos.info_CLR20_x64;  				case 4:  					if (Environment.Version.Revision <= 17020)  						return IntPtr.Size == 4 ? Infos.info_CLR40_x86_1 : Infos.info_CLR40_x64;  					return IntPtr.Size == 4 ? Infos.info_CLR40_x86_2 : Infos.info_CLR40_x64;  				default:  					goto case 4; // Assume CLR 4.0  			}
Magic Number,Confuser.Runtime,AntiDebugAntinet,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiDebug.Antinet.cs,CreateProfilerDetector,The following statement contains a magic number: if (Environment.Version.Major == 2)  				return new ProfilerDetectorCLR20();
Magic Number,Confuser.Runtime,ProfilerDetectorCLR20,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,IsProfilerAttached,The following statement contains a magic number: unsafe {  					if (profilerStatusFlag == IntPtr.Zero)  						return false;  					return (*(uint*)profilerStatusFlag & 6) != 0;  				}
Magic Number,Confuser.Runtime,ProfilerDetectorCLR20,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FindProfilerStatus,The following statement contains a magic number: try {  					PEInfo peInfo = PEInfo.GetCLR();  					if (peInfo == null)  						return false;    					IntPtr sectionAddr;  					uint sectionSize;  					if (!peInfo.FindSection(".text"' out sectionAddr' out sectionSize))  						return false;    					const int MAX_COUNTS = 50;  					var p = (byte*)sectionAddr;  					byte* end = (byte*)sectionAddr + sectionSize;  					for (; p < end; p++) {  						IntPtr addr;    						// F6 05 XX XX XX XX 06	test byte ptr [mem]'6  						if (*p == 0xF6 && p[1] == 0x05 && p[6] == 0x06) {  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 2));  							else  								addr = new IntPtr(p + 7 + *(int*)(p + 2));  						}  						else  							continue;    						if (!PEInfo.IsAligned(addr' 4))  							continue;  						if (!peInfo.IsValidImageAddress(addr' 4))  							continue;    						try {  							*(uint*)addr = *(uint*)addr;  						}  						catch {  							continue;  						}    						int count = 0;  						addrCounts.TryGetValue(addr' out count);  						count++;  						addrCounts[addr] = count;  						if (count >= MAX_COUNTS)  							break;  					}  				}  				catch { }
Magic Number,Confuser.Runtime,ProfilerDetectorCLR20,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FindProfilerStatus,The following statement contains a magic number: try {  					PEInfo peInfo = PEInfo.GetCLR();  					if (peInfo == null)  						return false;    					IntPtr sectionAddr;  					uint sectionSize;  					if (!peInfo.FindSection(".text"' out sectionAddr' out sectionSize))  						return false;    					const int MAX_COUNTS = 50;  					var p = (byte*)sectionAddr;  					byte* end = (byte*)sectionAddr + sectionSize;  					for (; p < end; p++) {  						IntPtr addr;    						// F6 05 XX XX XX XX 06	test byte ptr [mem]'6  						if (*p == 0xF6 && p[1] == 0x05 && p[6] == 0x06) {  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 2));  							else  								addr = new IntPtr(p + 7 + *(int*)(p + 2));  						}  						else  							continue;    						if (!PEInfo.IsAligned(addr' 4))  							continue;  						if (!peInfo.IsValidImageAddress(addr' 4))  							continue;    						try {  							*(uint*)addr = *(uint*)addr;  						}  						catch {  							continue;  						}    						int count = 0;  						addrCounts.TryGetValue(addr' out count);  						count++;  						addrCounts[addr] = count;  						if (count >= MAX_COUNTS)  							break;  					}  				}  				catch { }
Magic Number,Confuser.Runtime,ProfilerDetectorCLR20,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FindProfilerStatus,The following statement contains a magic number: try {  					PEInfo peInfo = PEInfo.GetCLR();  					if (peInfo == null)  						return false;    					IntPtr sectionAddr;  					uint sectionSize;  					if (!peInfo.FindSection(".text"' out sectionAddr' out sectionSize))  						return false;    					const int MAX_COUNTS = 50;  					var p = (byte*)sectionAddr;  					byte* end = (byte*)sectionAddr + sectionSize;  					for (; p < end; p++) {  						IntPtr addr;    						// F6 05 XX XX XX XX 06	test byte ptr [mem]'6  						if (*p == 0xF6 && p[1] == 0x05 && p[6] == 0x06) {  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 2));  							else  								addr = new IntPtr(p + 7 + *(int*)(p + 2));  						}  						else  							continue;    						if (!PEInfo.IsAligned(addr' 4))  							continue;  						if (!peInfo.IsValidImageAddress(addr' 4))  							continue;    						try {  							*(uint*)addr = *(uint*)addr;  						}  						catch {  							continue;  						}    						int count = 0;  						addrCounts.TryGetValue(addr' out count);  						count++;  						addrCounts[addr] = count;  						if (count >= MAX_COUNTS)  							break;  					}  				}  				catch { }
Magic Number,Confuser.Runtime,ProfilerDetectorCLR20,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FindProfilerStatus,The following statement contains a magic number: try {  					PEInfo peInfo = PEInfo.GetCLR();  					if (peInfo == null)  						return false;    					IntPtr sectionAddr;  					uint sectionSize;  					if (!peInfo.FindSection(".text"' out sectionAddr' out sectionSize))  						return false;    					const int MAX_COUNTS = 50;  					var p = (byte*)sectionAddr;  					byte* end = (byte*)sectionAddr + sectionSize;  					for (; p < end; p++) {  						IntPtr addr;    						// F6 05 XX XX XX XX 06	test byte ptr [mem]'6  						if (*p == 0xF6 && p[1] == 0x05 && p[6] == 0x06) {  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 2));  							else  								addr = new IntPtr(p + 7 + *(int*)(p + 2));  						}  						else  							continue;    						if (!PEInfo.IsAligned(addr' 4))  							continue;  						if (!peInfo.IsValidImageAddress(addr' 4))  							continue;    						try {  							*(uint*)addr = *(uint*)addr;  						}  						catch {  							continue;  						}    						int count = 0;  						addrCounts.TryGetValue(addr' out count);  						count++;  						addrCounts[addr] = count;  						if (count >= MAX_COUNTS)  							break;  					}  				}  				catch { }
Magic Number,Confuser.Runtime,ProfilerDetectorCLR20,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FindProfilerStatus,The following statement contains a magic number: try {  					PEInfo peInfo = PEInfo.GetCLR();  					if (peInfo == null)  						return false;    					IntPtr sectionAddr;  					uint sectionSize;  					if (!peInfo.FindSection(".text"' out sectionAddr' out sectionSize))  						return false;    					const int MAX_COUNTS = 50;  					var p = (byte*)sectionAddr;  					byte* end = (byte*)sectionAddr + sectionSize;  					for (; p < end; p++) {  						IntPtr addr;    						// F6 05 XX XX XX XX 06	test byte ptr [mem]'6  						if (*p == 0xF6 && p[1] == 0x05 && p[6] == 0x06) {  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 2));  							else  								addr = new IntPtr(p + 7 + *(int*)(p + 2));  						}  						else  							continue;    						if (!PEInfo.IsAligned(addr' 4))  							continue;  						if (!peInfo.IsValidImageAddress(addr' 4))  							continue;    						try {  							*(uint*)addr = *(uint*)addr;  						}  						catch {  							continue;  						}    						int count = 0;  						addrCounts.TryGetValue(addr' out count);  						count++;  						addrCounts[addr] = count;  						if (count >= MAX_COUNTS)  							break;  					}  				}  				catch { }
Magic Number,Confuser.Runtime,ProfilerDetectorCLR20,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FindProfilerStatus,The following statement contains a magic number: try {  					PEInfo peInfo = PEInfo.GetCLR();  					if (peInfo == null)  						return false;    					IntPtr sectionAddr;  					uint sectionSize;  					if (!peInfo.FindSection(".text"' out sectionAddr' out sectionSize))  						return false;    					const int MAX_COUNTS = 50;  					var p = (byte*)sectionAddr;  					byte* end = (byte*)sectionAddr + sectionSize;  					for (; p < end; p++) {  						IntPtr addr;    						// F6 05 XX XX XX XX 06	test byte ptr [mem]'6  						if (*p == 0xF6 && p[1] == 0x05 && p[6] == 0x06) {  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 2));  							else  								addr = new IntPtr(p + 7 + *(int*)(p + 2));  						}  						else  							continue;    						if (!PEInfo.IsAligned(addr' 4))  							continue;  						if (!peInfo.IsValidImageAddress(addr' 4))  							continue;    						try {  							*(uint*)addr = *(uint*)addr;  						}  						catch {  							continue;  						}    						int count = 0;  						addrCounts.TryGetValue(addr' out count);  						count++;  						addrCounts[addr] = count;  						if (count >= MAX_COUNTS)  							break;  					}  				}  				catch { }
Magic Number,Confuser.Runtime,ProfilerDetectorCLR20,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FindProfilerStatus,The following statement contains a magic number: try {  					PEInfo peInfo = PEInfo.GetCLR();  					if (peInfo == null)  						return false;    					IntPtr sectionAddr;  					uint sectionSize;  					if (!peInfo.FindSection(".text"' out sectionAddr' out sectionSize))  						return false;    					const int MAX_COUNTS = 50;  					var p = (byte*)sectionAddr;  					byte* end = (byte*)sectionAddr + sectionSize;  					for (; p < end; p++) {  						IntPtr addr;    						// F6 05 XX XX XX XX 06	test byte ptr [mem]'6  						if (*p == 0xF6 && p[1] == 0x05 && p[6] == 0x06) {  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 2));  							else  								addr = new IntPtr(p + 7 + *(int*)(p + 2));  						}  						else  							continue;    						if (!PEInfo.IsAligned(addr' 4))  							continue;  						if (!peInfo.IsValidImageAddress(addr' 4))  							continue;    						try {  							*(uint*)addr = *(uint*)addr;  						}  						catch {  							continue;  						}    						int count = 0;  						addrCounts.TryGetValue(addr' out count);  						count++;  						addrCounts[addr] = count;  						if (count >= MAX_COUNTS)  							break;  					}  				}  				catch { }
Magic Number,Confuser.Runtime,ProfilerDetectorCLR20,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FindProfilerStatus,The following statement contains a magic number: try {  					PEInfo peInfo = PEInfo.GetCLR();  					if (peInfo == null)  						return false;    					IntPtr sectionAddr;  					uint sectionSize;  					if (!peInfo.FindSection(".text"' out sectionAddr' out sectionSize))  						return false;    					const int MAX_COUNTS = 50;  					var p = (byte*)sectionAddr;  					byte* end = (byte*)sectionAddr + sectionSize;  					for (; p < end; p++) {  						IntPtr addr;    						// F6 05 XX XX XX XX 06	test byte ptr [mem]'6  						if (*p == 0xF6 && p[1] == 0x05 && p[6] == 0x06) {  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 2));  							else  								addr = new IntPtr(p + 7 + *(int*)(p + 2));  						}  						else  							continue;    						if (!PEInfo.IsAligned(addr' 4))  							continue;  						if (!peInfo.IsValidImageAddress(addr' 4))  							continue;    						try {  							*(uint*)addr = *(uint*)addr;  						}  						catch {  							continue;  						}    						int count = 0;  						addrCounts.TryGetValue(addr' out count);  						count++;  						addrCounts[addr] = count;  						if (count >= MAX_COUNTS)  							break;  					}  				}  				catch { }
Magic Number,Confuser.Runtime,ProfilerDetectorCLR20,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FindProfilerStatus,The following statement contains a magic number: IntPtr foundAddr = GetMax(addrCounts' 5);
Magic Number,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,IsProfilerAttached,The following statement contains a magic number: unsafe {  					if (profilerControlBlock == IntPtr.Zero)  						return false;  					return *(uint*)((byte*)profilerControlBlock + IntPtr.Size + 4) != 0;  				}
Magic Number,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,TakeOwnershipOfNamedPipe,The following statement contains a magic number: try {  					if (CreateNamedPipe())  						return true;    					// The CLR has already created the named pipe. Either the AttachThreadAlwaysOn  					// CLR option is enabled or some profiler has just attached or is attaching.  					// We must force it to exit its loop. There are two options that can prevent  					// it from exiting the thread' AttachThreadAlwaysOn and  					// ProfAPIMaxWaitForTriggerMs. If AttachThreadAlwaysOn is enabled' the thread  					// is started immediately when the CLR is loaded and it never exits.  					// ProfAPIMaxWaitForTriggerMs is the timeout in ms to use when waiting on  					// client attach messages. A user could set this to FFFFFFFF which is equal  					// to the INFINITE constant.  					//  					// To force it to exit' we must do this:  					//	- Find clr!ProfilingAPIAttachDetach::s_attachThreadingMode and make sure  					//	  it's not 2 (AttachThreadAlwaysOn is enabled).  					//	- Find clr!EXTERNAL_ProfAPIMaxWaitForTriggerMs and:  					//		- Set its default value to 0  					//		- Rename the option so the user can't override it  					//	- Open the named pipe to wake it up and then close the file to force a  					//	  timeout error.  					//	- Wait a little while until the thread has exited    					IntPtr threadingModeAddr = FindThreadingModeAddress();  					IntPtr timeOutOptionAddr = FindTimeOutOptionAddress();    					if (timeOutOptionAddr == IntPtr.Zero)  						return false;    					// Make sure the thread can exit. If this value is 2' it will never exit.  					if (threadingModeAddr != IntPtr.Zero && *(uint*)threadingModeAddr == 2)  						*(uint*)threadingModeAddr = 1;    					// Set default timeout to 0 and rename timeout option  					FixTimeOutOption(timeOutOptionAddr);    					// Wake up clr!ProfilingAPIAttachServer::ConnectToClient(). We immediately  					// close the pipe so it will fail to read any data. It will then start over  					// again but this time' its timeout value will be 0' and it will fail. Since  					// the thread can now exit' it will exit and close its named pipe.  					using (SafeFileHandle hPipe = CreatePipeFileHandleWait()) {  						if (hPipe == null)  							return false;  						if (hPipe.IsInvalid)  							return false;  					}    					return CreateNamedPipeWait();  				}  				catch { }
Magic Number,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,CreateNamedPipeWait,The following statement contains a magic number: int timeLeft = 100;
Magic Number,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,CreateNamedPipeWait,The following statement contains a magic number: const int waitTime = 5;
Magic Number,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FixTimeOutOption,The following statement contains a magic number: VirtualProtect(timeOutOptionAddr' (int)ConfigDWORDInfo_defValue + 4' PAGE_EXECUTE_READWRITE' out oldProtect);
Magic Number,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FixTimeOutOption,The following statement contains a magic number: try {  					// Set default timeout to 0 to make sure it fails immediately  					*(uint*)((byte*)timeOutOptionAddr + ConfigDWORDInfo_defValue) = 0;  				}  				finally {  					VirtualProtect(timeOutOptionAddr' (int)ConfigDWORDInfo_defValue + 4' oldProtect' out oldProtect);  				}
Magic Number,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FixTimeOutOption,The following statement contains a magic number: VirtualProtect(nameAddr' ProfAPIMaxWaitForTriggerMs_name.Length * 2' PAGE_EXECUTE_READWRITE' out oldProtect);
Magic Number,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,CreatePipeFileHandleWait,The following statement contains a magic number: int timeLeft = 100;
Magic Number,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,CreatePipeFileHandleWait,The following statement contains a magic number: const int waitTime = 5;
Magic Number,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,CreateNamedPipe,The following statement contains a magic number: profilerPipe = CreateNamedPipe(GetPipeName()'  				                               FILE_FLAG_OVERLAPPED | PIPE_ACCESS_DUPLEX'  				                               PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE'  				                               1' // nMaxInstances  				                               0x24' // nOutBufferSize  				                               0x338' // nInBufferSize  				                               1000' // nDefaultTimeOut  				                               IntPtr.Zero);
Magic Number,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FindThreadingModeAddress,The following statement contains a magic number: try {  					// Find this code in clr!ProfilingAPIAttachServer::ExecutePipeRequests()  					//	83 3D XX XX XX XX 02	cmp dword ptr [mem]'2  					//	74 / 0F 84 XX			je there  					//	83 E8+r 00 / 85 C0+rr	sub reg'0 / test reg'reg  					//	74 / 0F 84 XX			je there  					//	48+r / FF C8+r			dec reg  					//	74 / 0F 84 XX			je there  					//	48+r / FF C8+r			dec reg    					PEInfo peInfo = PEInfo.GetCLR();  					if (peInfo == null)  						return IntPtr.Zero;    					IntPtr sectionAddr;  					uint sectionSize;  					if (!peInfo.FindSection(".text"' out sectionAddr' out sectionSize))  						return IntPtr.Zero;    					var ptr = (byte*)sectionAddr;  					byte* end = (byte*)sectionAddr + sectionSize;  					for (; ptr < end; ptr++) {  						IntPtr addr;    						try {  							//	83 3D XX XX XX XX 02	cmp dword ptr [mem]'2  							byte* p = ptr;  							if (*p != 0x83 || p[1] != 0x3D || p[6] != 2)  								continue;  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 2));  							else  								addr = new IntPtr(p + 7 + *(int*)(p + 2));  							if (!PEInfo.IsAligned(addr' 4))  								continue;  							if (!peInfo.IsValidImageAddress(addr))  								continue;  							p += 7;    							// 1 = normal lazy thread creation. 2 = thread is always present  							if (*(uint*)addr < 1 || *(uint*)addr > 2)  								continue;  							*(uint*)addr = *(uint*)addr;    							//	74 / 0F 84 XX			je there  							if (!NextJz(ref p))  								continue;    							//	83 E8+r 00 / 85 C0+rr	sub reg'0 / test reg'reg  							SkipRex(ref p);  							if (*p == 0x83 && p[2] == 0) {  								if ((uint)(p[1] - 0xE8) > 7)  									continue;  								p += 3;  							}  							else if (*p == 0x85) {  								int reg = (p[1] >> 3) & 7;  								int rm = p[1] & 7;  								if (reg != rm)  									continue;  								p += 2;  							}  							else  								continue;    							//	74 / 0F 84 XX			je there  							if (!NextJz(ref p))  								continue;    							//	48+r / FF C8+r			dec reg  							if (!SkipDecReg(ref p))  								continue;    							//	74 / 0F 84 XX			je there  							if (!NextJz(ref p))  								continue;    							//	48+r / FF C8+r			dec reg  							if (!SkipDecReg(ref p))  								continue;    							return addr;  						}  						catch { }  					}  				}  				catch { }
Magic Number,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FindThreadingModeAddress,The following statement contains a magic number: try {  					// Find this code in clr!ProfilingAPIAttachServer::ExecutePipeRequests()  					//	83 3D XX XX XX XX 02	cmp dword ptr [mem]'2  					//	74 / 0F 84 XX			je there  					//	83 E8+r 00 / 85 C0+rr	sub reg'0 / test reg'reg  					//	74 / 0F 84 XX			je there  					//	48+r / FF C8+r			dec reg  					//	74 / 0F 84 XX			je there  					//	48+r / FF C8+r			dec reg    					PEInfo peInfo = PEInfo.GetCLR();  					if (peInfo == null)  						return IntPtr.Zero;    					IntPtr sectionAddr;  					uint sectionSize;  					if (!peInfo.FindSection(".text"' out sectionAddr' out sectionSize))  						return IntPtr.Zero;    					var ptr = (byte*)sectionAddr;  					byte* end = (byte*)sectionAddr + sectionSize;  					for (; ptr < end; ptr++) {  						IntPtr addr;    						try {  							//	83 3D XX XX XX XX 02	cmp dword ptr [mem]'2  							byte* p = ptr;  							if (*p != 0x83 || p[1] != 0x3D || p[6] != 2)  								continue;  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 2));  							else  								addr = new IntPtr(p + 7 + *(int*)(p + 2));  							if (!PEInfo.IsAligned(addr' 4))  								continue;  							if (!peInfo.IsValidImageAddress(addr))  								continue;  							p += 7;    							// 1 = normal lazy thread creation. 2 = thread is always present  							if (*(uint*)addr < 1 || *(uint*)addr > 2)  								continue;  							*(uint*)addr = *(uint*)addr;    							//	74 / 0F 84 XX			je there  							if (!NextJz(ref p))  								continue;    							//	83 E8+r 00 / 85 C0+rr	sub reg'0 / test reg'reg  							SkipRex(ref p);  							if (*p == 0x83 && p[2] == 0) {  								if ((uint)(p[1] - 0xE8) > 7)  									continue;  								p += 3;  							}  							else if (*p == 0x85) {  								int reg = (p[1] >> 3) & 7;  								int rm = p[1] & 7;  								if (reg != rm)  									continue;  								p += 2;  							}  							else  								continue;    							//	74 / 0F 84 XX			je there  							if (!NextJz(ref p))  								continue;    							//	48+r / FF C8+r			dec reg  							if (!SkipDecReg(ref p))  								continue;    							//	74 / 0F 84 XX			je there  							if (!NextJz(ref p))  								continue;    							//	48+r / FF C8+r			dec reg  							if (!SkipDecReg(ref p))  								continue;    							return addr;  						}  						catch { }  					}  				}  				catch { }
Magic Number,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FindThreadingModeAddress,The following statement contains a magic number: try {  					// Find this code in clr!ProfilingAPIAttachServer::ExecutePipeRequests()  					//	83 3D XX XX XX XX 02	cmp dword ptr [mem]'2  					//	74 / 0F 84 XX			je there  					//	83 E8+r 00 / 85 C0+rr	sub reg'0 / test reg'reg  					//	74 / 0F 84 XX			je there  					//	48+r / FF C8+r			dec reg  					//	74 / 0F 84 XX			je there  					//	48+r / FF C8+r			dec reg    					PEInfo peInfo = PEInfo.GetCLR();  					if (peInfo == null)  						return IntPtr.Zero;    					IntPtr sectionAddr;  					uint sectionSize;  					if (!peInfo.FindSection(".text"' out sectionAddr' out sectionSize))  						return IntPtr.Zero;    					var ptr = (byte*)sectionAddr;  					byte* end = (byte*)sectionAddr + sectionSize;  					for (; ptr < end; ptr++) {  						IntPtr addr;    						try {  							//	83 3D XX XX XX XX 02	cmp dword ptr [mem]'2  							byte* p = ptr;  							if (*p != 0x83 || p[1] != 0x3D || p[6] != 2)  								continue;  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 2));  							else  								addr = new IntPtr(p + 7 + *(int*)(p + 2));  							if (!PEInfo.IsAligned(addr' 4))  								continue;  							if (!peInfo.IsValidImageAddress(addr))  								continue;  							p += 7;    							// 1 = normal lazy thread creation. 2 = thread is always present  							if (*(uint*)addr < 1 || *(uint*)addr > 2)  								continue;  							*(uint*)addr = *(uint*)addr;    							//	74 / 0F 84 XX			je there  							if (!NextJz(ref p))  								continue;    							//	83 E8+r 00 / 85 C0+rr	sub reg'0 / test reg'reg  							SkipRex(ref p);  							if (*p == 0x83 && p[2] == 0) {  								if ((uint)(p[1] - 0xE8) > 7)  									continue;  								p += 3;  							}  							else if (*p == 0x85) {  								int reg = (p[1] >> 3) & 7;  								int rm = p[1] & 7;  								if (reg != rm)  									continue;  								p += 2;  							}  							else  								continue;    							//	74 / 0F 84 XX			je there  							if (!NextJz(ref p))  								continue;    							//	48+r / FF C8+r			dec reg  							if (!SkipDecReg(ref p))  								continue;    							//	74 / 0F 84 XX			je there  							if (!NextJz(ref p))  								continue;    							//	48+r / FF C8+r			dec reg  							if (!SkipDecReg(ref p))  								continue;    							return addr;  						}  						catch { }  					}  				}  				catch { }
Magic Number,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FindThreadingModeAddress,The following statement contains a magic number: try {  					// Find this code in clr!ProfilingAPIAttachServer::ExecutePipeRequests()  					//	83 3D XX XX XX XX 02	cmp dword ptr [mem]'2  					//	74 / 0F 84 XX			je there  					//	83 E8+r 00 / 85 C0+rr	sub reg'0 / test reg'reg  					//	74 / 0F 84 XX			je there  					//	48+r / FF C8+r			dec reg  					//	74 / 0F 84 XX			je there  					//	48+r / FF C8+r			dec reg    					PEInfo peInfo = PEInfo.GetCLR();  					if (peInfo == null)  						return IntPtr.Zero;    					IntPtr sectionAddr;  					uint sectionSize;  					if (!peInfo.FindSection(".text"' out sectionAddr' out sectionSize))  						return IntPtr.Zero;    					var ptr = (byte*)sectionAddr;  					byte* end = (byte*)sectionAddr + sectionSize;  					for (; ptr < end; ptr++) {  						IntPtr addr;    						try {  							//	83 3D XX XX XX XX 02	cmp dword ptr [mem]'2  							byte* p = ptr;  							if (*p != 0x83 || p[1] != 0x3D || p[6] != 2)  								continue;  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 2));  							else  								addr = new IntPtr(p + 7 + *(int*)(p + 2));  							if (!PEInfo.IsAligned(addr' 4))  								continue;  							if (!peInfo.IsValidImageAddress(addr))  								continue;  							p += 7;    							// 1 = normal lazy thread creation. 2 = thread is always present  							if (*(uint*)addr < 1 || *(uint*)addr > 2)  								continue;  							*(uint*)addr = *(uint*)addr;    							//	74 / 0F 84 XX			je there  							if (!NextJz(ref p))  								continue;    							//	83 E8+r 00 / 85 C0+rr	sub reg'0 / test reg'reg  							SkipRex(ref p);  							if (*p == 0x83 && p[2] == 0) {  								if ((uint)(p[1] - 0xE8) > 7)  									continue;  								p += 3;  							}  							else if (*p == 0x85) {  								int reg = (p[1] >> 3) & 7;  								int rm = p[1] & 7;  								if (reg != rm)  									continue;  								p += 2;  							}  							else  								continue;    							//	74 / 0F 84 XX			je there  							if (!NextJz(ref p))  								continue;    							//	48+r / FF C8+r			dec reg  							if (!SkipDecReg(ref p))  								continue;    							//	74 / 0F 84 XX			je there  							if (!NextJz(ref p))  								continue;    							//	48+r / FF C8+r			dec reg  							if (!SkipDecReg(ref p))  								continue;    							return addr;  						}  						catch { }  					}  				}  				catch { }
Magic Number,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FindThreadingModeAddress,The following statement contains a magic number: try {  					// Find this code in clr!ProfilingAPIAttachServer::ExecutePipeRequests()  					//	83 3D XX XX XX XX 02	cmp dword ptr [mem]'2  					//	74 / 0F 84 XX			je there  					//	83 E8+r 00 / 85 C0+rr	sub reg'0 / test reg'reg  					//	74 / 0F 84 XX			je there  					//	48+r / FF C8+r			dec reg  					//	74 / 0F 84 XX			je there  					//	48+r / FF C8+r			dec reg    					PEInfo peInfo = PEInfo.GetCLR();  					if (peInfo == null)  						return IntPtr.Zero;    					IntPtr sectionAddr;  					uint sectionSize;  					if (!peInfo.FindSection(".text"' out sectionAddr' out sectionSize))  						return IntPtr.Zero;    					var ptr = (byte*)sectionAddr;  					byte* end = (byte*)sectionAddr + sectionSize;  					for (; ptr < end; ptr++) {  						IntPtr addr;    						try {  							//	83 3D XX XX XX XX 02	cmp dword ptr [mem]'2  							byte* p = ptr;  							if (*p != 0x83 || p[1] != 0x3D || p[6] != 2)  								continue;  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 2));  							else  								addr = new IntPtr(p + 7 + *(int*)(p + 2));  							if (!PEInfo.IsAligned(addr' 4))  								continue;  							if (!peInfo.IsValidImageAddress(addr))  								continue;  							p += 7;    							// 1 = normal lazy thread creation. 2 = thread is always present  							if (*(uint*)addr < 1 || *(uint*)addr > 2)  								continue;  							*(uint*)addr = *(uint*)addr;    							//	74 / 0F 84 XX			je there  							if (!NextJz(ref p))  								continue;    							//	83 E8+r 00 / 85 C0+rr	sub reg'0 / test reg'reg  							SkipRex(ref p);  							if (*p == 0x83 && p[2] == 0) {  								if ((uint)(p[1] - 0xE8) > 7)  									continue;  								p += 3;  							}  							else if (*p == 0x85) {  								int reg = (p[1] >> 3) & 7;  								int rm = p[1] & 7;  								if (reg != rm)  									continue;  								p += 2;  							}  							else  								continue;    							//	74 / 0F 84 XX			je there  							if (!NextJz(ref p))  								continue;    							//	48+r / FF C8+r			dec reg  							if (!SkipDecReg(ref p))  								continue;    							//	74 / 0F 84 XX			je there  							if (!NextJz(ref p))  								continue;    							//	48+r / FF C8+r			dec reg  							if (!SkipDecReg(ref p))  								continue;    							return addr;  						}  						catch { }  					}  				}  				catch { }
Magic Number,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FindThreadingModeAddress,The following statement contains a magic number: try {  					// Find this code in clr!ProfilingAPIAttachServer::ExecutePipeRequests()  					//	83 3D XX XX XX XX 02	cmp dword ptr [mem]'2  					//	74 / 0F 84 XX			je there  					//	83 E8+r 00 / 85 C0+rr	sub reg'0 / test reg'reg  					//	74 / 0F 84 XX			je there  					//	48+r / FF C8+r			dec reg  					//	74 / 0F 84 XX			je there  					//	48+r / FF C8+r			dec reg    					PEInfo peInfo = PEInfo.GetCLR();  					if (peInfo == null)  						return IntPtr.Zero;    					IntPtr sectionAddr;  					uint sectionSize;  					if (!peInfo.FindSection(".text"' out sectionAddr' out sectionSize))  						return IntPtr.Zero;    					var ptr = (byte*)sectionAddr;  					byte* end = (byte*)sectionAddr + sectionSize;  					for (; ptr < end; ptr++) {  						IntPtr addr;    						try {  							//	83 3D XX XX XX XX 02	cmp dword ptr [mem]'2  							byte* p = ptr;  							if (*p != 0x83 || p[1] != 0x3D || p[6] != 2)  								continue;  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 2));  							else  								addr = new IntPtr(p + 7 + *(int*)(p + 2));  							if (!PEInfo.IsAligned(addr' 4))  								continue;  							if (!peInfo.IsValidImageAddress(addr))  								continue;  							p += 7;    							// 1 = normal lazy thread creation. 2 = thread is always present  							if (*(uint*)addr < 1 || *(uint*)addr > 2)  								continue;  							*(uint*)addr = *(uint*)addr;    							//	74 / 0F 84 XX			je there  							if (!NextJz(ref p))  								continue;    							//	83 E8+r 00 / 85 C0+rr	sub reg'0 / test reg'reg  							SkipRex(ref p);  							if (*p == 0x83 && p[2] == 0) {  								if ((uint)(p[1] - 0xE8) > 7)  									continue;  								p += 3;  							}  							else if (*p == 0x85) {  								int reg = (p[1] >> 3) & 7;  								int rm = p[1] & 7;  								if (reg != rm)  									continue;  								p += 2;  							}  							else  								continue;    							//	74 / 0F 84 XX			je there  							if (!NextJz(ref p))  								continue;    							//	48+r / FF C8+r			dec reg  							if (!SkipDecReg(ref p))  								continue;    							//	74 / 0F 84 XX			je there  							if (!NextJz(ref p))  								continue;    							//	48+r / FF C8+r			dec reg  							if (!SkipDecReg(ref p))  								continue;    							return addr;  						}  						catch { }  					}  				}  				catch { }
Magic Number,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FindThreadingModeAddress,The following statement contains a magic number: try {  					// Find this code in clr!ProfilingAPIAttachServer::ExecutePipeRequests()  					//	83 3D XX XX XX XX 02	cmp dword ptr [mem]'2  					//	74 / 0F 84 XX			je there  					//	83 E8+r 00 / 85 C0+rr	sub reg'0 / test reg'reg  					//	74 / 0F 84 XX			je there  					//	48+r / FF C8+r			dec reg  					//	74 / 0F 84 XX			je there  					//	48+r / FF C8+r			dec reg    					PEInfo peInfo = PEInfo.GetCLR();  					if (peInfo == null)  						return IntPtr.Zero;    					IntPtr sectionAddr;  					uint sectionSize;  					if (!peInfo.FindSection(".text"' out sectionAddr' out sectionSize))  						return IntPtr.Zero;    					var ptr = (byte*)sectionAddr;  					byte* end = (byte*)sectionAddr + sectionSize;  					for (; ptr < end; ptr++) {  						IntPtr addr;    						try {  							//	83 3D XX XX XX XX 02	cmp dword ptr [mem]'2  							byte* p = ptr;  							if (*p != 0x83 || p[1] != 0x3D || p[6] != 2)  								continue;  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 2));  							else  								addr = new IntPtr(p + 7 + *(int*)(p + 2));  							if (!PEInfo.IsAligned(addr' 4))  								continue;  							if (!peInfo.IsValidImageAddress(addr))  								continue;  							p += 7;    							// 1 = normal lazy thread creation. 2 = thread is always present  							if (*(uint*)addr < 1 || *(uint*)addr > 2)  								continue;  							*(uint*)addr = *(uint*)addr;    							//	74 / 0F 84 XX			je there  							if (!NextJz(ref p))  								continue;    							//	83 E8+r 00 / 85 C0+rr	sub reg'0 / test reg'reg  							SkipRex(ref p);  							if (*p == 0x83 && p[2] == 0) {  								if ((uint)(p[1] - 0xE8) > 7)  									continue;  								p += 3;  							}  							else if (*p == 0x85) {  								int reg = (p[1] >> 3) & 7;  								int rm = p[1] & 7;  								if (reg != rm)  									continue;  								p += 2;  							}  							else  								continue;    							//	74 / 0F 84 XX			je there  							if (!NextJz(ref p))  								continue;    							//	48+r / FF C8+r			dec reg  							if (!SkipDecReg(ref p))  								continue;    							//	74 / 0F 84 XX			je there  							if (!NextJz(ref p))  								continue;    							//	48+r / FF C8+r			dec reg  							if (!SkipDecReg(ref p))  								continue;    							return addr;  						}  						catch { }  					}  				}  				catch { }
Magic Number,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FindThreadingModeAddress,The following statement contains a magic number: try {  					// Find this code in clr!ProfilingAPIAttachServer::ExecutePipeRequests()  					//	83 3D XX XX XX XX 02	cmp dword ptr [mem]'2  					//	74 / 0F 84 XX			je there  					//	83 E8+r 00 / 85 C0+rr	sub reg'0 / test reg'reg  					//	74 / 0F 84 XX			je there  					//	48+r / FF C8+r			dec reg  					//	74 / 0F 84 XX			je there  					//	48+r / FF C8+r			dec reg    					PEInfo peInfo = PEInfo.GetCLR();  					if (peInfo == null)  						return IntPtr.Zero;    					IntPtr sectionAddr;  					uint sectionSize;  					if (!peInfo.FindSection(".text"' out sectionAddr' out sectionSize))  						return IntPtr.Zero;    					var ptr = (byte*)sectionAddr;  					byte* end = (byte*)sectionAddr + sectionSize;  					for (; ptr < end; ptr++) {  						IntPtr addr;    						try {  							//	83 3D XX XX XX XX 02	cmp dword ptr [mem]'2  							byte* p = ptr;  							if (*p != 0x83 || p[1] != 0x3D || p[6] != 2)  								continue;  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 2));  							else  								addr = new IntPtr(p + 7 + *(int*)(p + 2));  							if (!PEInfo.IsAligned(addr' 4))  								continue;  							if (!peInfo.IsValidImageAddress(addr))  								continue;  							p += 7;    							// 1 = normal lazy thread creation. 2 = thread is always present  							if (*(uint*)addr < 1 || *(uint*)addr > 2)  								continue;  							*(uint*)addr = *(uint*)addr;    							//	74 / 0F 84 XX			je there  							if (!NextJz(ref p))  								continue;    							//	83 E8+r 00 / 85 C0+rr	sub reg'0 / test reg'reg  							SkipRex(ref p);  							if (*p == 0x83 && p[2] == 0) {  								if ((uint)(p[1] - 0xE8) > 7)  									continue;  								p += 3;  							}  							else if (*p == 0x85) {  								int reg = (p[1] >> 3) & 7;  								int rm = p[1] & 7;  								if (reg != rm)  									continue;  								p += 2;  							}  							else  								continue;    							//	74 / 0F 84 XX			je there  							if (!NextJz(ref p))  								continue;    							//	48+r / FF C8+r			dec reg  							if (!SkipDecReg(ref p))  								continue;    							//	74 / 0F 84 XX			je there  							if (!NextJz(ref p))  								continue;    							//	48+r / FF C8+r			dec reg  							if (!SkipDecReg(ref p))  								continue;    							return addr;  						}  						catch { }  					}  				}  				catch { }
Magic Number,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FindThreadingModeAddress,The following statement contains a magic number: try {  					// Find this code in clr!ProfilingAPIAttachServer::ExecutePipeRequests()  					//	83 3D XX XX XX XX 02	cmp dword ptr [mem]'2  					//	74 / 0F 84 XX			je there  					//	83 E8+r 00 / 85 C0+rr	sub reg'0 / test reg'reg  					//	74 / 0F 84 XX			je there  					//	48+r / FF C8+r			dec reg  					//	74 / 0F 84 XX			je there  					//	48+r / FF C8+r			dec reg    					PEInfo peInfo = PEInfo.GetCLR();  					if (peInfo == null)  						return IntPtr.Zero;    					IntPtr sectionAddr;  					uint sectionSize;  					if (!peInfo.FindSection(".text"' out sectionAddr' out sectionSize))  						return IntPtr.Zero;    					var ptr = (byte*)sectionAddr;  					byte* end = (byte*)sectionAddr + sectionSize;  					for (; ptr < end; ptr++) {  						IntPtr addr;    						try {  							//	83 3D XX XX XX XX 02	cmp dword ptr [mem]'2  							byte* p = ptr;  							if (*p != 0x83 || p[1] != 0x3D || p[6] != 2)  								continue;  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 2));  							else  								addr = new IntPtr(p + 7 + *(int*)(p + 2));  							if (!PEInfo.IsAligned(addr' 4))  								continue;  							if (!peInfo.IsValidImageAddress(addr))  								continue;  							p += 7;    							// 1 = normal lazy thread creation. 2 = thread is always present  							if (*(uint*)addr < 1 || *(uint*)addr > 2)  								continue;  							*(uint*)addr = *(uint*)addr;    							//	74 / 0F 84 XX			je there  							if (!NextJz(ref p))  								continue;    							//	83 E8+r 00 / 85 C0+rr	sub reg'0 / test reg'reg  							SkipRex(ref p);  							if (*p == 0x83 && p[2] == 0) {  								if ((uint)(p[1] - 0xE8) > 7)  									continue;  								p += 3;  							}  							else if (*p == 0x85) {  								int reg = (p[1] >> 3) & 7;  								int rm = p[1] & 7;  								if (reg != rm)  									continue;  								p += 2;  							}  							else  								continue;    							//	74 / 0F 84 XX			je there  							if (!NextJz(ref p))  								continue;    							//	48+r / FF C8+r			dec reg  							if (!SkipDecReg(ref p))  								continue;    							//	74 / 0F 84 XX			je there  							if (!NextJz(ref p))  								continue;    							//	48+r / FF C8+r			dec reg  							if (!SkipDecReg(ref p))  								continue;    							return addr;  						}  						catch { }  					}  				}  				catch { }
Magic Number,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FindThreadingModeAddress,The following statement contains a magic number: try {  					// Find this code in clr!ProfilingAPIAttachServer::ExecutePipeRequests()  					//	83 3D XX XX XX XX 02	cmp dword ptr [mem]'2  					//	74 / 0F 84 XX			je there  					//	83 E8+r 00 / 85 C0+rr	sub reg'0 / test reg'reg  					//	74 / 0F 84 XX			je there  					//	48+r / FF C8+r			dec reg  					//	74 / 0F 84 XX			je there  					//	48+r / FF C8+r			dec reg    					PEInfo peInfo = PEInfo.GetCLR();  					if (peInfo == null)  						return IntPtr.Zero;    					IntPtr sectionAddr;  					uint sectionSize;  					if (!peInfo.FindSection(".text"' out sectionAddr' out sectionSize))  						return IntPtr.Zero;    					var ptr = (byte*)sectionAddr;  					byte* end = (byte*)sectionAddr + sectionSize;  					for (; ptr < end; ptr++) {  						IntPtr addr;    						try {  							//	83 3D XX XX XX XX 02	cmp dword ptr [mem]'2  							byte* p = ptr;  							if (*p != 0x83 || p[1] != 0x3D || p[6] != 2)  								continue;  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 2));  							else  								addr = new IntPtr(p + 7 + *(int*)(p + 2));  							if (!PEInfo.IsAligned(addr' 4))  								continue;  							if (!peInfo.IsValidImageAddress(addr))  								continue;  							p += 7;    							// 1 = normal lazy thread creation. 2 = thread is always present  							if (*(uint*)addr < 1 || *(uint*)addr > 2)  								continue;  							*(uint*)addr = *(uint*)addr;    							//	74 / 0F 84 XX			je there  							if (!NextJz(ref p))  								continue;    							//	83 E8+r 00 / 85 C0+rr	sub reg'0 / test reg'reg  							SkipRex(ref p);  							if (*p == 0x83 && p[2] == 0) {  								if ((uint)(p[1] - 0xE8) > 7)  									continue;  								p += 3;  							}  							else if (*p == 0x85) {  								int reg = (p[1] >> 3) & 7;  								int rm = p[1] & 7;  								if (reg != rm)  									continue;  								p += 2;  							}  							else  								continue;    							//	74 / 0F 84 XX			je there  							if (!NextJz(ref p))  								continue;    							//	48+r / FF C8+r			dec reg  							if (!SkipDecReg(ref p))  								continue;    							//	74 / 0F 84 XX			je there  							if (!NextJz(ref p))  								continue;    							//	48+r / FF C8+r			dec reg  							if (!SkipDecReg(ref p))  								continue;    							return addr;  						}  						catch { }  					}  				}  				catch { }
Magic Number,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FindThreadingModeAddress,The following statement contains a magic number: try {  					// Find this code in clr!ProfilingAPIAttachServer::ExecutePipeRequests()  					//	83 3D XX XX XX XX 02	cmp dword ptr [mem]'2  					//	74 / 0F 84 XX			je there  					//	83 E8+r 00 / 85 C0+rr	sub reg'0 / test reg'reg  					//	74 / 0F 84 XX			je there  					//	48+r / FF C8+r			dec reg  					//	74 / 0F 84 XX			je there  					//	48+r / FF C8+r			dec reg    					PEInfo peInfo = PEInfo.GetCLR();  					if (peInfo == null)  						return IntPtr.Zero;    					IntPtr sectionAddr;  					uint sectionSize;  					if (!peInfo.FindSection(".text"' out sectionAddr' out sectionSize))  						return IntPtr.Zero;    					var ptr = (byte*)sectionAddr;  					byte* end = (byte*)sectionAddr + sectionSize;  					for (; ptr < end; ptr++) {  						IntPtr addr;    						try {  							//	83 3D XX XX XX XX 02	cmp dword ptr [mem]'2  							byte* p = ptr;  							if (*p != 0x83 || p[1] != 0x3D || p[6] != 2)  								continue;  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 2));  							else  								addr = new IntPtr(p + 7 + *(int*)(p + 2));  							if (!PEInfo.IsAligned(addr' 4))  								continue;  							if (!peInfo.IsValidImageAddress(addr))  								continue;  							p += 7;    							// 1 = normal lazy thread creation. 2 = thread is always present  							if (*(uint*)addr < 1 || *(uint*)addr > 2)  								continue;  							*(uint*)addr = *(uint*)addr;    							//	74 / 0F 84 XX			je there  							if (!NextJz(ref p))  								continue;    							//	83 E8+r 00 / 85 C0+rr	sub reg'0 / test reg'reg  							SkipRex(ref p);  							if (*p == 0x83 && p[2] == 0) {  								if ((uint)(p[1] - 0xE8) > 7)  									continue;  								p += 3;  							}  							else if (*p == 0x85) {  								int reg = (p[1] >> 3) & 7;  								int rm = p[1] & 7;  								if (reg != rm)  									continue;  								p += 2;  							}  							else  								continue;    							//	74 / 0F 84 XX			je there  							if (!NextJz(ref p))  								continue;    							//	48+r / FF C8+r			dec reg  							if (!SkipDecReg(ref p))  								continue;    							//	74 / 0F 84 XX			je there  							if (!NextJz(ref p))  								continue;    							//	48+r / FF C8+r			dec reg  							if (!SkipDecReg(ref p))  								continue;    							return addr;  						}  						catch { }  					}  				}  				catch { }
Magic Number,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FindThreadingModeAddress,The following statement contains a magic number: try {  					// Find this code in clr!ProfilingAPIAttachServer::ExecutePipeRequests()  					//	83 3D XX XX XX XX 02	cmp dword ptr [mem]'2  					//	74 / 0F 84 XX			je there  					//	83 E8+r 00 / 85 C0+rr	sub reg'0 / test reg'reg  					//	74 / 0F 84 XX			je there  					//	48+r / FF C8+r			dec reg  					//	74 / 0F 84 XX			je there  					//	48+r / FF C8+r			dec reg    					PEInfo peInfo = PEInfo.GetCLR();  					if (peInfo == null)  						return IntPtr.Zero;    					IntPtr sectionAddr;  					uint sectionSize;  					if (!peInfo.FindSection(".text"' out sectionAddr' out sectionSize))  						return IntPtr.Zero;    					var ptr = (byte*)sectionAddr;  					byte* end = (byte*)sectionAddr + sectionSize;  					for (; ptr < end; ptr++) {  						IntPtr addr;    						try {  							//	83 3D XX XX XX XX 02	cmp dword ptr [mem]'2  							byte* p = ptr;  							if (*p != 0x83 || p[1] != 0x3D || p[6] != 2)  								continue;  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 2));  							else  								addr = new IntPtr(p + 7 + *(int*)(p + 2));  							if (!PEInfo.IsAligned(addr' 4))  								continue;  							if (!peInfo.IsValidImageAddress(addr))  								continue;  							p += 7;    							// 1 = normal lazy thread creation. 2 = thread is always present  							if (*(uint*)addr < 1 || *(uint*)addr > 2)  								continue;  							*(uint*)addr = *(uint*)addr;    							//	74 / 0F 84 XX			je there  							if (!NextJz(ref p))  								continue;    							//	83 E8+r 00 / 85 C0+rr	sub reg'0 / test reg'reg  							SkipRex(ref p);  							if (*p == 0x83 && p[2] == 0) {  								if ((uint)(p[1] - 0xE8) > 7)  									continue;  								p += 3;  							}  							else if (*p == 0x85) {  								int reg = (p[1] >> 3) & 7;  								int rm = p[1] & 7;  								if (reg != rm)  									continue;  								p += 2;  							}  							else  								continue;    							//	74 / 0F 84 XX			je there  							if (!NextJz(ref p))  								continue;    							//	48+r / FF C8+r			dec reg  							if (!SkipDecReg(ref p))  								continue;    							//	74 / 0F 84 XX			je there  							if (!NextJz(ref p))  								continue;    							//	48+r / FF C8+r			dec reg  							if (!SkipDecReg(ref p))  								continue;    							return addr;  						}  						catch { }  					}  				}  				catch { }
Magic Number,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FindThreadingModeAddress,The following statement contains a magic number: try {  					// Find this code in clr!ProfilingAPIAttachServer::ExecutePipeRequests()  					//	83 3D XX XX XX XX 02	cmp dword ptr [mem]'2  					//	74 / 0F 84 XX			je there  					//	83 E8+r 00 / 85 C0+rr	sub reg'0 / test reg'reg  					//	74 / 0F 84 XX			je there  					//	48+r / FF C8+r			dec reg  					//	74 / 0F 84 XX			je there  					//	48+r / FF C8+r			dec reg    					PEInfo peInfo = PEInfo.GetCLR();  					if (peInfo == null)  						return IntPtr.Zero;    					IntPtr sectionAddr;  					uint sectionSize;  					if (!peInfo.FindSection(".text"' out sectionAddr' out sectionSize))  						return IntPtr.Zero;    					var ptr = (byte*)sectionAddr;  					byte* end = (byte*)sectionAddr + sectionSize;  					for (; ptr < end; ptr++) {  						IntPtr addr;    						try {  							//	83 3D XX XX XX XX 02	cmp dword ptr [mem]'2  							byte* p = ptr;  							if (*p != 0x83 || p[1] != 0x3D || p[6] != 2)  								continue;  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 2));  							else  								addr = new IntPtr(p + 7 + *(int*)(p + 2));  							if (!PEInfo.IsAligned(addr' 4))  								continue;  							if (!peInfo.IsValidImageAddress(addr))  								continue;  							p += 7;    							// 1 = normal lazy thread creation. 2 = thread is always present  							if (*(uint*)addr < 1 || *(uint*)addr > 2)  								continue;  							*(uint*)addr = *(uint*)addr;    							//	74 / 0F 84 XX			je there  							if (!NextJz(ref p))  								continue;    							//	83 E8+r 00 / 85 C0+rr	sub reg'0 / test reg'reg  							SkipRex(ref p);  							if (*p == 0x83 && p[2] == 0) {  								if ((uint)(p[1] - 0xE8) > 7)  									continue;  								p += 3;  							}  							else if (*p == 0x85) {  								int reg = (p[1] >> 3) & 7;  								int rm = p[1] & 7;  								if (reg != rm)  									continue;  								p += 2;  							}  							else  								continue;    							//	74 / 0F 84 XX			je there  							if (!NextJz(ref p))  								continue;    							//	48+r / FF C8+r			dec reg  							if (!SkipDecReg(ref p))  								continue;    							//	74 / 0F 84 XX			je there  							if (!NextJz(ref p))  								continue;    							//	48+r / FF C8+r			dec reg  							if (!SkipDecReg(ref p))  								continue;    							return addr;  						}  						catch { }  					}  				}  				catch { }
Magic Number,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FindThreadingModeAddress,The following statement contains a magic number: try {  					// Find this code in clr!ProfilingAPIAttachServer::ExecutePipeRequests()  					//	83 3D XX XX XX XX 02	cmp dword ptr [mem]'2  					//	74 / 0F 84 XX			je there  					//	83 E8+r 00 / 85 C0+rr	sub reg'0 / test reg'reg  					//	74 / 0F 84 XX			je there  					//	48+r / FF C8+r			dec reg  					//	74 / 0F 84 XX			je there  					//	48+r / FF C8+r			dec reg    					PEInfo peInfo = PEInfo.GetCLR();  					if (peInfo == null)  						return IntPtr.Zero;    					IntPtr sectionAddr;  					uint sectionSize;  					if (!peInfo.FindSection(".text"' out sectionAddr' out sectionSize))  						return IntPtr.Zero;    					var ptr = (byte*)sectionAddr;  					byte* end = (byte*)sectionAddr + sectionSize;  					for (; ptr < end; ptr++) {  						IntPtr addr;    						try {  							//	83 3D XX XX XX XX 02	cmp dword ptr [mem]'2  							byte* p = ptr;  							if (*p != 0x83 || p[1] != 0x3D || p[6] != 2)  								continue;  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 2));  							else  								addr = new IntPtr(p + 7 + *(int*)(p + 2));  							if (!PEInfo.IsAligned(addr' 4))  								continue;  							if (!peInfo.IsValidImageAddress(addr))  								continue;  							p += 7;    							// 1 = normal lazy thread creation. 2 = thread is always present  							if (*(uint*)addr < 1 || *(uint*)addr > 2)  								continue;  							*(uint*)addr = *(uint*)addr;    							//	74 / 0F 84 XX			je there  							if (!NextJz(ref p))  								continue;    							//	83 E8+r 00 / 85 C0+rr	sub reg'0 / test reg'reg  							SkipRex(ref p);  							if (*p == 0x83 && p[2] == 0) {  								if ((uint)(p[1] - 0xE8) > 7)  									continue;  								p += 3;  							}  							else if (*p == 0x85) {  								int reg = (p[1] >> 3) & 7;  								int rm = p[1] & 7;  								if (reg != rm)  									continue;  								p += 2;  							}  							else  								continue;    							//	74 / 0F 84 XX			je there  							if (!NextJz(ref p))  								continue;    							//	48+r / FF C8+r			dec reg  							if (!SkipDecReg(ref p))  								continue;    							//	74 / 0F 84 XX			je there  							if (!NextJz(ref p))  								continue;    							//	48+r / FF C8+r			dec reg  							if (!SkipDecReg(ref p))  								continue;    							return addr;  						}  						catch { }  					}  				}  				catch { }
Magic Number,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FindThreadingModeAddress,The following statement contains a magic number: try {  					// Find this code in clr!ProfilingAPIAttachServer::ExecutePipeRequests()  					//	83 3D XX XX XX XX 02	cmp dword ptr [mem]'2  					//	74 / 0F 84 XX			je there  					//	83 E8+r 00 / 85 C0+rr	sub reg'0 / test reg'reg  					//	74 / 0F 84 XX			je there  					//	48+r / FF C8+r			dec reg  					//	74 / 0F 84 XX			je there  					//	48+r / FF C8+r			dec reg    					PEInfo peInfo = PEInfo.GetCLR();  					if (peInfo == null)  						return IntPtr.Zero;    					IntPtr sectionAddr;  					uint sectionSize;  					if (!peInfo.FindSection(".text"' out sectionAddr' out sectionSize))  						return IntPtr.Zero;    					var ptr = (byte*)sectionAddr;  					byte* end = (byte*)sectionAddr + sectionSize;  					for (; ptr < end; ptr++) {  						IntPtr addr;    						try {  							//	83 3D XX XX XX XX 02	cmp dword ptr [mem]'2  							byte* p = ptr;  							if (*p != 0x83 || p[1] != 0x3D || p[6] != 2)  								continue;  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 2));  							else  								addr = new IntPtr(p + 7 + *(int*)(p + 2));  							if (!PEInfo.IsAligned(addr' 4))  								continue;  							if (!peInfo.IsValidImageAddress(addr))  								continue;  							p += 7;    							// 1 = normal lazy thread creation. 2 = thread is always present  							if (*(uint*)addr < 1 || *(uint*)addr > 2)  								continue;  							*(uint*)addr = *(uint*)addr;    							//	74 / 0F 84 XX			je there  							if (!NextJz(ref p))  								continue;    							//	83 E8+r 00 / 85 C0+rr	sub reg'0 / test reg'reg  							SkipRex(ref p);  							if (*p == 0x83 && p[2] == 0) {  								if ((uint)(p[1] - 0xE8) > 7)  									continue;  								p += 3;  							}  							else if (*p == 0x85) {  								int reg = (p[1] >> 3) & 7;  								int rm = p[1] & 7;  								if (reg != rm)  									continue;  								p += 2;  							}  							else  								continue;    							//	74 / 0F 84 XX			je there  							if (!NextJz(ref p))  								continue;    							//	48+r / FF C8+r			dec reg  							if (!SkipDecReg(ref p))  								continue;    							//	74 / 0F 84 XX			je there  							if (!NextJz(ref p))  								continue;    							//	48+r / FF C8+r			dec reg  							if (!SkipDecReg(ref p))  								continue;    							return addr;  						}  						catch { }  					}  				}  				catch { }
Magic Number,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FindThreadingModeAddress,The following statement contains a magic number: try {  					// Find this code in clr!ProfilingAPIAttachServer::ExecutePipeRequests()  					//	83 3D XX XX XX XX 02	cmp dword ptr [mem]'2  					//	74 / 0F 84 XX			je there  					//	83 E8+r 00 / 85 C0+rr	sub reg'0 / test reg'reg  					//	74 / 0F 84 XX			je there  					//	48+r / FF C8+r			dec reg  					//	74 / 0F 84 XX			je there  					//	48+r / FF C8+r			dec reg    					PEInfo peInfo = PEInfo.GetCLR();  					if (peInfo == null)  						return IntPtr.Zero;    					IntPtr sectionAddr;  					uint sectionSize;  					if (!peInfo.FindSection(".text"' out sectionAddr' out sectionSize))  						return IntPtr.Zero;    					var ptr = (byte*)sectionAddr;  					byte* end = (byte*)sectionAddr + sectionSize;  					for (; ptr < end; ptr++) {  						IntPtr addr;    						try {  							//	83 3D XX XX XX XX 02	cmp dword ptr [mem]'2  							byte* p = ptr;  							if (*p != 0x83 || p[1] != 0x3D || p[6] != 2)  								continue;  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 2));  							else  								addr = new IntPtr(p + 7 + *(int*)(p + 2));  							if (!PEInfo.IsAligned(addr' 4))  								continue;  							if (!peInfo.IsValidImageAddress(addr))  								continue;  							p += 7;    							// 1 = normal lazy thread creation. 2 = thread is always present  							if (*(uint*)addr < 1 || *(uint*)addr > 2)  								continue;  							*(uint*)addr = *(uint*)addr;    							//	74 / 0F 84 XX			je there  							if (!NextJz(ref p))  								continue;    							//	83 E8+r 00 / 85 C0+rr	sub reg'0 / test reg'reg  							SkipRex(ref p);  							if (*p == 0x83 && p[2] == 0) {  								if ((uint)(p[1] - 0xE8) > 7)  									continue;  								p += 3;  							}  							else if (*p == 0x85) {  								int reg = (p[1] >> 3) & 7;  								int rm = p[1] & 7;  								if (reg != rm)  									continue;  								p += 2;  							}  							else  								continue;    							//	74 / 0F 84 XX			je there  							if (!NextJz(ref p))  								continue;    							//	48+r / FF C8+r			dec reg  							if (!SkipDecReg(ref p))  								continue;    							//	74 / 0F 84 XX			je there  							if (!NextJz(ref p))  								continue;    							//	48+r / FF C8+r			dec reg  							if (!SkipDecReg(ref p))  								continue;    							return addr;  						}  						catch { }  					}  				}  				catch { }
Magic Number,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FindTimeOutOptionAddress,The following statement contains a magic number: try {  					PEInfo peInfo = PEInfo.GetCLR();  					if (peInfo == null)  						return IntPtr.Zero;    					IntPtr sectionAddr;  					uint sectionSize;  					if (!peInfo.FindSection(".rdata"' out sectionAddr' out sectionSize) &&  					    !peInfo.FindSection(".text"' out sectionAddr' out sectionSize))  						return IntPtr.Zero;    					var p = (byte*)sectionAddr;  					byte* end = (byte*)sectionAddr + sectionSize;  					for (; p < end; p++) {  						try {  							char* name = *(char**)(p + ConfigDWORDInfo_name);  							if (!PEInfo.IsAligned(new IntPtr(name)' 2))  								continue;  							if (!peInfo.IsValidImageAddress(name))  								continue;    							if (!Equals(name' ProfAPIMaxWaitForTriggerMs_name))  								continue;    							return new IntPtr(p);  						}  						catch { }  					}  				}  				catch { }
Magic Number,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,SkipRex,The following statement contains a magic number: if (IntPtr.Size != 8)  					return;
Magic Number,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,SkipDecReg,The following statement contains a magic number: if (IntPtr.Size == 4 && *p >= 0x48 && *p <= 0x4F)  					p++;  				else if (*p == 0xFF && p[1] >= 0xC8 && p[1] <= 0xCF)  					p += 2;  				else  					return false;
Magic Number,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,SkipDecReg,The following statement contains a magic number: if (IntPtr.Size == 4 && *p >= 0x48 && *p <= 0x4F)  					p++;  				else if (*p == 0xFF && p[1] >= 0xC8 && p[1] <= 0xCF)  					p += 2;  				else  					return false;
Magic Number,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,NextJz,The following statement contains a magic number: if (*p == 0x74) {  					p += 2;  					return true;  				}
Magic Number,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,NextJz,The following statement contains a magic number: if (*p == 0x0F && p[1] == 0x84) {  					p += 6;  					return true;  				}
Magic Number,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,PatchAttacherThreadProc,The following statement contains a magic number: VirtualProtect(new IntPtr(p)' 5' PAGE_EXECUTE_READWRITE' out oldProtect);
Magic Number,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,PatchAttacherThreadProc,The following statement contains a magic number: try {  					if (IntPtr.Size == 4) {  						// xor eax'eax  						p[0] = 0x33;  						p[1] = 0xC0;  						// retn 4  						p[2] = 0xC2;  						p[3] = 0x04;  						p[4] = 0x00;  					}  					else {  						// xor eax'eax  						p[0] = 0x33;  						p[1] = 0xC0;  						// retn  						p[2] = 0xC3;  					}  				}  				finally {  					VirtualProtect(new IntPtr(p)' 5' oldProtect' out oldProtect);  				}
Magic Number,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,PatchAttacherThreadProc,The following statement contains a magic number: try {  					if (IntPtr.Size == 4) {  						// xor eax'eax  						p[0] = 0x33;  						p[1] = 0xC0;  						// retn 4  						p[2] = 0xC2;  						p[3] = 0x04;  						p[4] = 0x00;  					}  					else {  						// xor eax'eax  						p[0] = 0x33;  						p[1] = 0xC0;  						// retn  						p[2] = 0xC3;  					}  				}  				finally {  					VirtualProtect(new IntPtr(p)' 5' oldProtect' out oldProtect);  				}
Magic Number,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,PatchAttacherThreadProc,The following statement contains a magic number: try {  					if (IntPtr.Size == 4) {  						// xor eax'eax  						p[0] = 0x33;  						p[1] = 0xC0;  						// retn 4  						p[2] = 0xC2;  						p[3] = 0x04;  						p[4] = 0x00;  					}  					else {  						// xor eax'eax  						p[0] = 0x33;  						p[1] = 0xC0;  						// retn  						p[2] = 0xC3;  					}  				}  				finally {  					VirtualProtect(new IntPtr(p)' 5' oldProtect' out oldProtect);  				}
Magic Number,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,PatchAttacherThreadProc,The following statement contains a magic number: try {  					if (IntPtr.Size == 4) {  						// xor eax'eax  						p[0] = 0x33;  						p[1] = 0xC0;  						// retn 4  						p[2] = 0xC2;  						p[3] = 0x04;  						p[4] = 0x00;  					}  					else {  						// xor eax'eax  						p[0] = 0x33;  						p[1] = 0xC0;  						// retn  						p[2] = 0xC3;  					}  				}  				finally {  					VirtualProtect(new IntPtr(p)' 5' oldProtect' out oldProtect);  				}
Magic Number,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,PatchAttacherThreadProc,The following statement contains a magic number: try {  					if (IntPtr.Size == 4) {  						// xor eax'eax  						p[0] = 0x33;  						p[1] = 0xC0;  						// retn 4  						p[2] = 0xC2;  						p[3] = 0x04;  						p[4] = 0x00;  					}  					else {  						// xor eax'eax  						p[0] = 0x33;  						p[1] = 0xC0;  						// retn  						p[2] = 0xC3;  					}  				}  				finally {  					VirtualProtect(new IntPtr(p)' 5' oldProtect' out oldProtect);  				}
Magic Number,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,PatchAttacherThreadProc,The following statement contains a magic number: try {  					if (IntPtr.Size == 4) {  						// xor eax'eax  						p[0] = 0x33;  						p[1] = 0xC0;  						// retn 4  						p[2] = 0xC2;  						p[3] = 0x04;  						p[4] = 0x00;  					}  					else {  						// xor eax'eax  						p[0] = 0x33;  						p[1] = 0xC0;  						// retn  						p[2] = 0xC3;  					}  				}  				finally {  					VirtualProtect(new IntPtr(p)' 5' oldProtect' out oldProtect);  				}
Magic Number,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FindAttacherThreadProc,The following statement contains a magic number: try {  					PEInfo peInfo = PEInfo.GetCLR();  					if (peInfo == null)  						return IntPtr.Zero;    					IntPtr sectionAddr;  					uint sectionSize;  					if (!peInfo.FindSection(".text"' out sectionAddr' out sectionSize))  						return IntPtr.Zero;    					var p = (byte*)sectionAddr;  					byte* start = p;  					byte* end = (byte*)sectionAddr + sectionSize;    					if (IntPtr.Size == 4) {  						for (; p < end; p++) {  							// Find this code:  							//	50+r				push reg  							//	50+r				push reg  							//	50+r				push reg  							//	68 XX XX XX XX		push offset ThreadProc  							//	50+r				push reg  							//	50+r				push reg  							//	FF 15 XX XX XX XX	call dword ptr [mem] // CreateThread()    							byte push = *p;  							if (push < 0x50 || push > 0x57)  								continue;  							if (p[1] != push || p[2] != push || p[8] != push || p[9] != push)  								continue;  							if (p[3] != 0x68)  								continue;  							if (p[10] != 0xFF || p[11] != 0x15)  								continue;    							var threadProc = new IntPtr((void*)*(uint*)(p + 4));  							if (!CheckThreadProc(start' end' threadProc))  								continue;    							return threadProc;  						}  					}  					else {  						for (; p < end; p++) {  							// Find this code:  							//	45 33 C9				xor r9d'r9d  							//	4C 8D 05 XX XX XX XX	lea r8'ThreadProc  							//	33 D2					xor edx'edx  							//	33 C9					xor ecx'ecx  							//	FF 15 XX XX XX XX		call dword ptr [mem] // CreateThread()    							if (*p != 0x45 && p[1] != 0x33 && p[2] != 0xC9)  								continue;  							if (p[3] != 0x4C && p[4] != 0x8D && p[5] != 0x05)  								continue;  							if (p[10] != 0x33 && p[11] != 0xD2)  								continue;  							if (p[12] != 0x33 && p[13] != 0xC9)  								continue;  							if (p[14] != 0xFF && p[15] != 0x15)  								continue;    							var threadProc = new IntPtr(p + 10 + *(int*)(p + 6));  							if (!CheckThreadProc(start' end' threadProc))  								continue;    							return threadProc;  						}  					}  				}  				catch { }
Magic Number,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FindAttacherThreadProc,The following statement contains a magic number: try {  					PEInfo peInfo = PEInfo.GetCLR();  					if (peInfo == null)  						return IntPtr.Zero;    					IntPtr sectionAddr;  					uint sectionSize;  					if (!peInfo.FindSection(".text"' out sectionAddr' out sectionSize))  						return IntPtr.Zero;    					var p = (byte*)sectionAddr;  					byte* start = p;  					byte* end = (byte*)sectionAddr + sectionSize;    					if (IntPtr.Size == 4) {  						for (; p < end; p++) {  							// Find this code:  							//	50+r				push reg  							//	50+r				push reg  							//	50+r				push reg  							//	68 XX XX XX XX		push offset ThreadProc  							//	50+r				push reg  							//	50+r				push reg  							//	FF 15 XX XX XX XX	call dword ptr [mem] // CreateThread()    							byte push = *p;  							if (push < 0x50 || push > 0x57)  								continue;  							if (p[1] != push || p[2] != push || p[8] != push || p[9] != push)  								continue;  							if (p[3] != 0x68)  								continue;  							if (p[10] != 0xFF || p[11] != 0x15)  								continue;    							var threadProc = new IntPtr((void*)*(uint*)(p + 4));  							if (!CheckThreadProc(start' end' threadProc))  								continue;    							return threadProc;  						}  					}  					else {  						for (; p < end; p++) {  							// Find this code:  							//	45 33 C9				xor r9d'r9d  							//	4C 8D 05 XX XX XX XX	lea r8'ThreadProc  							//	33 D2					xor edx'edx  							//	33 C9					xor ecx'ecx  							//	FF 15 XX XX XX XX		call dword ptr [mem] // CreateThread()    							if (*p != 0x45 && p[1] != 0x33 && p[2] != 0xC9)  								continue;  							if (p[3] != 0x4C && p[4] != 0x8D && p[5] != 0x05)  								continue;  							if (p[10] != 0x33 && p[11] != 0xD2)  								continue;  							if (p[12] != 0x33 && p[13] != 0xC9)  								continue;  							if (p[14] != 0xFF && p[15] != 0x15)  								continue;    							var threadProc = new IntPtr(p + 10 + *(int*)(p + 6));  							if (!CheckThreadProc(start' end' threadProc))  								continue;    							return threadProc;  						}  					}  				}  				catch { }
Magic Number,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FindAttacherThreadProc,The following statement contains a magic number: try {  					PEInfo peInfo = PEInfo.GetCLR();  					if (peInfo == null)  						return IntPtr.Zero;    					IntPtr sectionAddr;  					uint sectionSize;  					if (!peInfo.FindSection(".text"' out sectionAddr' out sectionSize))  						return IntPtr.Zero;    					var p = (byte*)sectionAddr;  					byte* start = p;  					byte* end = (byte*)sectionAddr + sectionSize;    					if (IntPtr.Size == 4) {  						for (; p < end; p++) {  							// Find this code:  							//	50+r				push reg  							//	50+r				push reg  							//	50+r				push reg  							//	68 XX XX XX XX		push offset ThreadProc  							//	50+r				push reg  							//	50+r				push reg  							//	FF 15 XX XX XX XX	call dword ptr [mem] // CreateThread()    							byte push = *p;  							if (push < 0x50 || push > 0x57)  								continue;  							if (p[1] != push || p[2] != push || p[8] != push || p[9] != push)  								continue;  							if (p[3] != 0x68)  								continue;  							if (p[10] != 0xFF || p[11] != 0x15)  								continue;    							var threadProc = new IntPtr((void*)*(uint*)(p + 4));  							if (!CheckThreadProc(start' end' threadProc))  								continue;    							return threadProc;  						}  					}  					else {  						for (; p < end; p++) {  							// Find this code:  							//	45 33 C9				xor r9d'r9d  							//	4C 8D 05 XX XX XX XX	lea r8'ThreadProc  							//	33 D2					xor edx'edx  							//	33 C9					xor ecx'ecx  							//	FF 15 XX XX XX XX		call dword ptr [mem] // CreateThread()    							if (*p != 0x45 && p[1] != 0x33 && p[2] != 0xC9)  								continue;  							if (p[3] != 0x4C && p[4] != 0x8D && p[5] != 0x05)  								continue;  							if (p[10] != 0x33 && p[11] != 0xD2)  								continue;  							if (p[12] != 0x33 && p[13] != 0xC9)  								continue;  							if (p[14] != 0xFF && p[15] != 0x15)  								continue;    							var threadProc = new IntPtr(p + 10 + *(int*)(p + 6));  							if (!CheckThreadProc(start' end' threadProc))  								continue;    							return threadProc;  						}  					}  				}  				catch { }
Magic Number,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FindAttacherThreadProc,The following statement contains a magic number: try {  					PEInfo peInfo = PEInfo.GetCLR();  					if (peInfo == null)  						return IntPtr.Zero;    					IntPtr sectionAddr;  					uint sectionSize;  					if (!peInfo.FindSection(".text"' out sectionAddr' out sectionSize))  						return IntPtr.Zero;    					var p = (byte*)sectionAddr;  					byte* start = p;  					byte* end = (byte*)sectionAddr + sectionSize;    					if (IntPtr.Size == 4) {  						for (; p < end; p++) {  							// Find this code:  							//	50+r				push reg  							//	50+r				push reg  							//	50+r				push reg  							//	68 XX XX XX XX		push offset ThreadProc  							//	50+r				push reg  							//	50+r				push reg  							//	FF 15 XX XX XX XX	call dword ptr [mem] // CreateThread()    							byte push = *p;  							if (push < 0x50 || push > 0x57)  								continue;  							if (p[1] != push || p[2] != push || p[8] != push || p[9] != push)  								continue;  							if (p[3] != 0x68)  								continue;  							if (p[10] != 0xFF || p[11] != 0x15)  								continue;    							var threadProc = new IntPtr((void*)*(uint*)(p + 4));  							if (!CheckThreadProc(start' end' threadProc))  								continue;    							return threadProc;  						}  					}  					else {  						for (; p < end; p++) {  							// Find this code:  							//	45 33 C9				xor r9d'r9d  							//	4C 8D 05 XX XX XX XX	lea r8'ThreadProc  							//	33 D2					xor edx'edx  							//	33 C9					xor ecx'ecx  							//	FF 15 XX XX XX XX		call dword ptr [mem] // CreateThread()    							if (*p != 0x45 && p[1] != 0x33 && p[2] != 0xC9)  								continue;  							if (p[3] != 0x4C && p[4] != 0x8D && p[5] != 0x05)  								continue;  							if (p[10] != 0x33 && p[11] != 0xD2)  								continue;  							if (p[12] != 0x33 && p[13] != 0xC9)  								continue;  							if (p[14] != 0xFF && p[15] != 0x15)  								continue;    							var threadProc = new IntPtr(p + 10 + *(int*)(p + 6));  							if (!CheckThreadProc(start' end' threadProc))  								continue;    							return threadProc;  						}  					}  				}  				catch { }
Magic Number,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FindAttacherThreadProc,The following statement contains a magic number: try {  					PEInfo peInfo = PEInfo.GetCLR();  					if (peInfo == null)  						return IntPtr.Zero;    					IntPtr sectionAddr;  					uint sectionSize;  					if (!peInfo.FindSection(".text"' out sectionAddr' out sectionSize))  						return IntPtr.Zero;    					var p = (byte*)sectionAddr;  					byte* start = p;  					byte* end = (byte*)sectionAddr + sectionSize;    					if (IntPtr.Size == 4) {  						for (; p < end; p++) {  							// Find this code:  							//	50+r				push reg  							//	50+r				push reg  							//	50+r				push reg  							//	68 XX XX XX XX		push offset ThreadProc  							//	50+r				push reg  							//	50+r				push reg  							//	FF 15 XX XX XX XX	call dword ptr [mem] // CreateThread()    							byte push = *p;  							if (push < 0x50 || push > 0x57)  								continue;  							if (p[1] != push || p[2] != push || p[8] != push || p[9] != push)  								continue;  							if (p[3] != 0x68)  								continue;  							if (p[10] != 0xFF || p[11] != 0x15)  								continue;    							var threadProc = new IntPtr((void*)*(uint*)(p + 4));  							if (!CheckThreadProc(start' end' threadProc))  								continue;    							return threadProc;  						}  					}  					else {  						for (; p < end; p++) {  							// Find this code:  							//	45 33 C9				xor r9d'r9d  							//	4C 8D 05 XX XX XX XX	lea r8'ThreadProc  							//	33 D2					xor edx'edx  							//	33 C9					xor ecx'ecx  							//	FF 15 XX XX XX XX		call dword ptr [mem] // CreateThread()    							if (*p != 0x45 && p[1] != 0x33 && p[2] != 0xC9)  								continue;  							if (p[3] != 0x4C && p[4] != 0x8D && p[5] != 0x05)  								continue;  							if (p[10] != 0x33 && p[11] != 0xD2)  								continue;  							if (p[12] != 0x33 && p[13] != 0xC9)  								continue;  							if (p[14] != 0xFF && p[15] != 0x15)  								continue;    							var threadProc = new IntPtr(p + 10 + *(int*)(p + 6));  							if (!CheckThreadProc(start' end' threadProc))  								continue;    							return threadProc;  						}  					}  				}  				catch { }
Magic Number,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FindAttacherThreadProc,The following statement contains a magic number: try {  					PEInfo peInfo = PEInfo.GetCLR();  					if (peInfo == null)  						return IntPtr.Zero;    					IntPtr sectionAddr;  					uint sectionSize;  					if (!peInfo.FindSection(".text"' out sectionAddr' out sectionSize))  						return IntPtr.Zero;    					var p = (byte*)sectionAddr;  					byte* start = p;  					byte* end = (byte*)sectionAddr + sectionSize;    					if (IntPtr.Size == 4) {  						for (; p < end; p++) {  							// Find this code:  							//	50+r				push reg  							//	50+r				push reg  							//	50+r				push reg  							//	68 XX XX XX XX		push offset ThreadProc  							//	50+r				push reg  							//	50+r				push reg  							//	FF 15 XX XX XX XX	call dword ptr [mem] // CreateThread()    							byte push = *p;  							if (push < 0x50 || push > 0x57)  								continue;  							if (p[1] != push || p[2] != push || p[8] != push || p[9] != push)  								continue;  							if (p[3] != 0x68)  								continue;  							if (p[10] != 0xFF || p[11] != 0x15)  								continue;    							var threadProc = new IntPtr((void*)*(uint*)(p + 4));  							if (!CheckThreadProc(start' end' threadProc))  								continue;    							return threadProc;  						}  					}  					else {  						for (; p < end; p++) {  							// Find this code:  							//	45 33 C9				xor r9d'r9d  							//	4C 8D 05 XX XX XX XX	lea r8'ThreadProc  							//	33 D2					xor edx'edx  							//	33 C9					xor ecx'ecx  							//	FF 15 XX XX XX XX		call dword ptr [mem] // CreateThread()    							if (*p != 0x45 && p[1] != 0x33 && p[2] != 0xC9)  								continue;  							if (p[3] != 0x4C && p[4] != 0x8D && p[5] != 0x05)  								continue;  							if (p[10] != 0x33 && p[11] != 0xD2)  								continue;  							if (p[12] != 0x33 && p[13] != 0xC9)  								continue;  							if (p[14] != 0xFF && p[15] != 0x15)  								continue;    							var threadProc = new IntPtr(p + 10 + *(int*)(p + 6));  							if (!CheckThreadProc(start' end' threadProc))  								continue;    							return threadProc;  						}  					}  				}  				catch { }
Magic Number,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FindAttacherThreadProc,The following statement contains a magic number: try {  					PEInfo peInfo = PEInfo.GetCLR();  					if (peInfo == null)  						return IntPtr.Zero;    					IntPtr sectionAddr;  					uint sectionSize;  					if (!peInfo.FindSection(".text"' out sectionAddr' out sectionSize))  						return IntPtr.Zero;    					var p = (byte*)sectionAddr;  					byte* start = p;  					byte* end = (byte*)sectionAddr + sectionSize;    					if (IntPtr.Size == 4) {  						for (; p < end; p++) {  							// Find this code:  							//	50+r				push reg  							//	50+r				push reg  							//	50+r				push reg  							//	68 XX XX XX XX		push offset ThreadProc  							//	50+r				push reg  							//	50+r				push reg  							//	FF 15 XX XX XX XX	call dword ptr [mem] // CreateThread()    							byte push = *p;  							if (push < 0x50 || push > 0x57)  								continue;  							if (p[1] != push || p[2] != push || p[8] != push || p[9] != push)  								continue;  							if (p[3] != 0x68)  								continue;  							if (p[10] != 0xFF || p[11] != 0x15)  								continue;    							var threadProc = new IntPtr((void*)*(uint*)(p + 4));  							if (!CheckThreadProc(start' end' threadProc))  								continue;    							return threadProc;  						}  					}  					else {  						for (; p < end; p++) {  							// Find this code:  							//	45 33 C9				xor r9d'r9d  							//	4C 8D 05 XX XX XX XX	lea r8'ThreadProc  							//	33 D2					xor edx'edx  							//	33 C9					xor ecx'ecx  							//	FF 15 XX XX XX XX		call dword ptr [mem] // CreateThread()    							if (*p != 0x45 && p[1] != 0x33 && p[2] != 0xC9)  								continue;  							if (p[3] != 0x4C && p[4] != 0x8D && p[5] != 0x05)  								continue;  							if (p[10] != 0x33 && p[11] != 0xD2)  								continue;  							if (p[12] != 0x33 && p[13] != 0xC9)  								continue;  							if (p[14] != 0xFF && p[15] != 0x15)  								continue;    							var threadProc = new IntPtr(p + 10 + *(int*)(p + 6));  							if (!CheckThreadProc(start' end' threadProc))  								continue;    							return threadProc;  						}  					}  				}  				catch { }
Magic Number,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FindAttacherThreadProc,The following statement contains a magic number: try {  					PEInfo peInfo = PEInfo.GetCLR();  					if (peInfo == null)  						return IntPtr.Zero;    					IntPtr sectionAddr;  					uint sectionSize;  					if (!peInfo.FindSection(".text"' out sectionAddr' out sectionSize))  						return IntPtr.Zero;    					var p = (byte*)sectionAddr;  					byte* start = p;  					byte* end = (byte*)sectionAddr + sectionSize;    					if (IntPtr.Size == 4) {  						for (; p < end; p++) {  							// Find this code:  							//	50+r				push reg  							//	50+r				push reg  							//	50+r				push reg  							//	68 XX XX XX XX		push offset ThreadProc  							//	50+r				push reg  							//	50+r				push reg  							//	FF 15 XX XX XX XX	call dword ptr [mem] // CreateThread()    							byte push = *p;  							if (push < 0x50 || push > 0x57)  								continue;  							if (p[1] != push || p[2] != push || p[8] != push || p[9] != push)  								continue;  							if (p[3] != 0x68)  								continue;  							if (p[10] != 0xFF || p[11] != 0x15)  								continue;    							var threadProc = new IntPtr((void*)*(uint*)(p + 4));  							if (!CheckThreadProc(start' end' threadProc))  								continue;    							return threadProc;  						}  					}  					else {  						for (; p < end; p++) {  							// Find this code:  							//	45 33 C9				xor r9d'r9d  							//	4C 8D 05 XX XX XX XX	lea r8'ThreadProc  							//	33 D2					xor edx'edx  							//	33 C9					xor ecx'ecx  							//	FF 15 XX XX XX XX		call dword ptr [mem] // CreateThread()    							if (*p != 0x45 && p[1] != 0x33 && p[2] != 0xC9)  								continue;  							if (p[3] != 0x4C && p[4] != 0x8D && p[5] != 0x05)  								continue;  							if (p[10] != 0x33 && p[11] != 0xD2)  								continue;  							if (p[12] != 0x33 && p[13] != 0xC9)  								continue;  							if (p[14] != 0xFF && p[15] != 0x15)  								continue;    							var threadProc = new IntPtr(p + 10 + *(int*)(p + 6));  							if (!CheckThreadProc(start' end' threadProc))  								continue;    							return threadProc;  						}  					}  				}  				catch { }
Magic Number,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FindAttacherThreadProc,The following statement contains a magic number: try {  					PEInfo peInfo = PEInfo.GetCLR();  					if (peInfo == null)  						return IntPtr.Zero;    					IntPtr sectionAddr;  					uint sectionSize;  					if (!peInfo.FindSection(".text"' out sectionAddr' out sectionSize))  						return IntPtr.Zero;    					var p = (byte*)sectionAddr;  					byte* start = p;  					byte* end = (byte*)sectionAddr + sectionSize;    					if (IntPtr.Size == 4) {  						for (; p < end; p++) {  							// Find this code:  							//	50+r				push reg  							//	50+r				push reg  							//	50+r				push reg  							//	68 XX XX XX XX		push offset ThreadProc  							//	50+r				push reg  							//	50+r				push reg  							//	FF 15 XX XX XX XX	call dword ptr [mem] // CreateThread()    							byte push = *p;  							if (push < 0x50 || push > 0x57)  								continue;  							if (p[1] != push || p[2] != push || p[8] != push || p[9] != push)  								continue;  							if (p[3] != 0x68)  								continue;  							if (p[10] != 0xFF || p[11] != 0x15)  								continue;    							var threadProc = new IntPtr((void*)*(uint*)(p + 4));  							if (!CheckThreadProc(start' end' threadProc))  								continue;    							return threadProc;  						}  					}  					else {  						for (; p < end; p++) {  							// Find this code:  							//	45 33 C9				xor r9d'r9d  							//	4C 8D 05 XX XX XX XX	lea r8'ThreadProc  							//	33 D2					xor edx'edx  							//	33 C9					xor ecx'ecx  							//	FF 15 XX XX XX XX		call dword ptr [mem] // CreateThread()    							if (*p != 0x45 && p[1] != 0x33 && p[2] != 0xC9)  								continue;  							if (p[3] != 0x4C && p[4] != 0x8D && p[5] != 0x05)  								continue;  							if (p[10] != 0x33 && p[11] != 0xD2)  								continue;  							if (p[12] != 0x33 && p[13] != 0xC9)  								continue;  							if (p[14] != 0xFF && p[15] != 0x15)  								continue;    							var threadProc = new IntPtr(p + 10 + *(int*)(p + 6));  							if (!CheckThreadProc(start' end' threadProc))  								continue;    							return threadProc;  						}  					}  				}  				catch { }
Magic Number,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FindAttacherThreadProc,The following statement contains a magic number: try {  					PEInfo peInfo = PEInfo.GetCLR();  					if (peInfo == null)  						return IntPtr.Zero;    					IntPtr sectionAddr;  					uint sectionSize;  					if (!peInfo.FindSection(".text"' out sectionAddr' out sectionSize))  						return IntPtr.Zero;    					var p = (byte*)sectionAddr;  					byte* start = p;  					byte* end = (byte*)sectionAddr + sectionSize;    					if (IntPtr.Size == 4) {  						for (; p < end; p++) {  							// Find this code:  							//	50+r				push reg  							//	50+r				push reg  							//	50+r				push reg  							//	68 XX XX XX XX		push offset ThreadProc  							//	50+r				push reg  							//	50+r				push reg  							//	FF 15 XX XX XX XX	call dword ptr [mem] // CreateThread()    							byte push = *p;  							if (push < 0x50 || push > 0x57)  								continue;  							if (p[1] != push || p[2] != push || p[8] != push || p[9] != push)  								continue;  							if (p[3] != 0x68)  								continue;  							if (p[10] != 0xFF || p[11] != 0x15)  								continue;    							var threadProc = new IntPtr((void*)*(uint*)(p + 4));  							if (!CheckThreadProc(start' end' threadProc))  								continue;    							return threadProc;  						}  					}  					else {  						for (; p < end; p++) {  							// Find this code:  							//	45 33 C9				xor r9d'r9d  							//	4C 8D 05 XX XX XX XX	lea r8'ThreadProc  							//	33 D2					xor edx'edx  							//	33 C9					xor ecx'ecx  							//	FF 15 XX XX XX XX		call dword ptr [mem] // CreateThread()    							if (*p != 0x45 && p[1] != 0x33 && p[2] != 0xC9)  								continue;  							if (p[3] != 0x4C && p[4] != 0x8D && p[5] != 0x05)  								continue;  							if (p[10] != 0x33 && p[11] != 0xD2)  								continue;  							if (p[12] != 0x33 && p[13] != 0xC9)  								continue;  							if (p[14] != 0xFF && p[15] != 0x15)  								continue;    							var threadProc = new IntPtr(p + 10 + *(int*)(p + 6));  							if (!CheckThreadProc(start' end' threadProc))  								continue;    							return threadProc;  						}  					}  				}  				catch { }
Magic Number,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FindAttacherThreadProc,The following statement contains a magic number: try {  					PEInfo peInfo = PEInfo.GetCLR();  					if (peInfo == null)  						return IntPtr.Zero;    					IntPtr sectionAddr;  					uint sectionSize;  					if (!peInfo.FindSection(".text"' out sectionAddr' out sectionSize))  						return IntPtr.Zero;    					var p = (byte*)sectionAddr;  					byte* start = p;  					byte* end = (byte*)sectionAddr + sectionSize;    					if (IntPtr.Size == 4) {  						for (; p < end; p++) {  							// Find this code:  							//	50+r				push reg  							//	50+r				push reg  							//	50+r				push reg  							//	68 XX XX XX XX		push offset ThreadProc  							//	50+r				push reg  							//	50+r				push reg  							//	FF 15 XX XX XX XX	call dword ptr [mem] // CreateThread()    							byte push = *p;  							if (push < 0x50 || push > 0x57)  								continue;  							if (p[1] != push || p[2] != push || p[8] != push || p[9] != push)  								continue;  							if (p[3] != 0x68)  								continue;  							if (p[10] != 0xFF || p[11] != 0x15)  								continue;    							var threadProc = new IntPtr((void*)*(uint*)(p + 4));  							if (!CheckThreadProc(start' end' threadProc))  								continue;    							return threadProc;  						}  					}  					else {  						for (; p < end; p++) {  							// Find this code:  							//	45 33 C9				xor r9d'r9d  							//	4C 8D 05 XX XX XX XX	lea r8'ThreadProc  							//	33 D2					xor edx'edx  							//	33 C9					xor ecx'ecx  							//	FF 15 XX XX XX XX		call dword ptr [mem] // CreateThread()    							if (*p != 0x45 && p[1] != 0x33 && p[2] != 0xC9)  								continue;  							if (p[3] != 0x4C && p[4] != 0x8D && p[5] != 0x05)  								continue;  							if (p[10] != 0x33 && p[11] != 0xD2)  								continue;  							if (p[12] != 0x33 && p[13] != 0xC9)  								continue;  							if (p[14] != 0xFF && p[15] != 0x15)  								continue;    							var threadProc = new IntPtr(p + 10 + *(int*)(p + 6));  							if (!CheckThreadProc(start' end' threadProc))  								continue;    							return threadProc;  						}  					}  				}  				catch { }
Magic Number,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FindAttacherThreadProc,The following statement contains a magic number: try {  					PEInfo peInfo = PEInfo.GetCLR();  					if (peInfo == null)  						return IntPtr.Zero;    					IntPtr sectionAddr;  					uint sectionSize;  					if (!peInfo.FindSection(".text"' out sectionAddr' out sectionSize))  						return IntPtr.Zero;    					var p = (byte*)sectionAddr;  					byte* start = p;  					byte* end = (byte*)sectionAddr + sectionSize;    					if (IntPtr.Size == 4) {  						for (; p < end; p++) {  							// Find this code:  							//	50+r				push reg  							//	50+r				push reg  							//	50+r				push reg  							//	68 XX XX XX XX		push offset ThreadProc  							//	50+r				push reg  							//	50+r				push reg  							//	FF 15 XX XX XX XX	call dword ptr [mem] // CreateThread()    							byte push = *p;  							if (push < 0x50 || push > 0x57)  								continue;  							if (p[1] != push || p[2] != push || p[8] != push || p[9] != push)  								continue;  							if (p[3] != 0x68)  								continue;  							if (p[10] != 0xFF || p[11] != 0x15)  								continue;    							var threadProc = new IntPtr((void*)*(uint*)(p + 4));  							if (!CheckThreadProc(start' end' threadProc))  								continue;    							return threadProc;  						}  					}  					else {  						for (; p < end; p++) {  							// Find this code:  							//	45 33 C9				xor r9d'r9d  							//	4C 8D 05 XX XX XX XX	lea r8'ThreadProc  							//	33 D2					xor edx'edx  							//	33 C9					xor ecx'ecx  							//	FF 15 XX XX XX XX		call dword ptr [mem] // CreateThread()    							if (*p != 0x45 && p[1] != 0x33 && p[2] != 0xC9)  								continue;  							if (p[3] != 0x4C && p[4] != 0x8D && p[5] != 0x05)  								continue;  							if (p[10] != 0x33 && p[11] != 0xD2)  								continue;  							if (p[12] != 0x33 && p[13] != 0xC9)  								continue;  							if (p[14] != 0xFF && p[15] != 0x15)  								continue;    							var threadProc = new IntPtr(p + 10 + *(int*)(p + 6));  							if (!CheckThreadProc(start' end' threadProc))  								continue;    							return threadProc;  						}  					}  				}  				catch { }
Magic Number,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FindAttacherThreadProc,The following statement contains a magic number: try {  					PEInfo peInfo = PEInfo.GetCLR();  					if (peInfo == null)  						return IntPtr.Zero;    					IntPtr sectionAddr;  					uint sectionSize;  					if (!peInfo.FindSection(".text"' out sectionAddr' out sectionSize))  						return IntPtr.Zero;    					var p = (byte*)sectionAddr;  					byte* start = p;  					byte* end = (byte*)sectionAddr + sectionSize;    					if (IntPtr.Size == 4) {  						for (; p < end; p++) {  							// Find this code:  							//	50+r				push reg  							//	50+r				push reg  							//	50+r				push reg  							//	68 XX XX XX XX		push offset ThreadProc  							//	50+r				push reg  							//	50+r				push reg  							//	FF 15 XX XX XX XX	call dword ptr [mem] // CreateThread()    							byte push = *p;  							if (push < 0x50 || push > 0x57)  								continue;  							if (p[1] != push || p[2] != push || p[8] != push || p[9] != push)  								continue;  							if (p[3] != 0x68)  								continue;  							if (p[10] != 0xFF || p[11] != 0x15)  								continue;    							var threadProc = new IntPtr((void*)*(uint*)(p + 4));  							if (!CheckThreadProc(start' end' threadProc))  								continue;    							return threadProc;  						}  					}  					else {  						for (; p < end; p++) {  							// Find this code:  							//	45 33 C9				xor r9d'r9d  							//	4C 8D 05 XX XX XX XX	lea r8'ThreadProc  							//	33 D2					xor edx'edx  							//	33 C9					xor ecx'ecx  							//	FF 15 XX XX XX XX		call dword ptr [mem] // CreateThread()    							if (*p != 0x45 && p[1] != 0x33 && p[2] != 0xC9)  								continue;  							if (p[3] != 0x4C && p[4] != 0x8D && p[5] != 0x05)  								continue;  							if (p[10] != 0x33 && p[11] != 0xD2)  								continue;  							if (p[12] != 0x33 && p[13] != 0xC9)  								continue;  							if (p[14] != 0xFF && p[15] != 0x15)  								continue;    							var threadProc = new IntPtr(p + 10 + *(int*)(p + 6));  							if (!CheckThreadProc(start' end' threadProc))  								continue;    							return threadProc;  						}  					}  				}  				catch { }
Magic Number,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FindAttacherThreadProc,The following statement contains a magic number: try {  					PEInfo peInfo = PEInfo.GetCLR();  					if (peInfo == null)  						return IntPtr.Zero;    					IntPtr sectionAddr;  					uint sectionSize;  					if (!peInfo.FindSection(".text"' out sectionAddr' out sectionSize))  						return IntPtr.Zero;    					var p = (byte*)sectionAddr;  					byte* start = p;  					byte* end = (byte*)sectionAddr + sectionSize;    					if (IntPtr.Size == 4) {  						for (; p < end; p++) {  							// Find this code:  							//	50+r				push reg  							//	50+r				push reg  							//	50+r				push reg  							//	68 XX XX XX XX		push offset ThreadProc  							//	50+r				push reg  							//	50+r				push reg  							//	FF 15 XX XX XX XX	call dword ptr [mem] // CreateThread()    							byte push = *p;  							if (push < 0x50 || push > 0x57)  								continue;  							if (p[1] != push || p[2] != push || p[8] != push || p[9] != push)  								continue;  							if (p[3] != 0x68)  								continue;  							if (p[10] != 0xFF || p[11] != 0x15)  								continue;    							var threadProc = new IntPtr((void*)*(uint*)(p + 4));  							if (!CheckThreadProc(start' end' threadProc))  								continue;    							return threadProc;  						}  					}  					else {  						for (; p < end; p++) {  							// Find this code:  							//	45 33 C9				xor r9d'r9d  							//	4C 8D 05 XX XX XX XX	lea r8'ThreadProc  							//	33 D2					xor edx'edx  							//	33 C9					xor ecx'ecx  							//	FF 15 XX XX XX XX		call dword ptr [mem] // CreateThread()    							if (*p != 0x45 && p[1] != 0x33 && p[2] != 0xC9)  								continue;  							if (p[3] != 0x4C && p[4] != 0x8D && p[5] != 0x05)  								continue;  							if (p[10] != 0x33 && p[11] != 0xD2)  								continue;  							if (p[12] != 0x33 && p[13] != 0xC9)  								continue;  							if (p[14] != 0xFF && p[15] != 0x15)  								continue;    							var threadProc = new IntPtr(p + 10 + *(int*)(p + 6));  							if (!CheckThreadProc(start' end' threadProc))  								continue;    							return threadProc;  						}  					}  				}  				catch { }
Magic Number,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FindAttacherThreadProc,The following statement contains a magic number: try {  					PEInfo peInfo = PEInfo.GetCLR();  					if (peInfo == null)  						return IntPtr.Zero;    					IntPtr sectionAddr;  					uint sectionSize;  					if (!peInfo.FindSection(".text"' out sectionAddr' out sectionSize))  						return IntPtr.Zero;    					var p = (byte*)sectionAddr;  					byte* start = p;  					byte* end = (byte*)sectionAddr + sectionSize;    					if (IntPtr.Size == 4) {  						for (; p < end; p++) {  							// Find this code:  							//	50+r				push reg  							//	50+r				push reg  							//	50+r				push reg  							//	68 XX XX XX XX		push offset ThreadProc  							//	50+r				push reg  							//	50+r				push reg  							//	FF 15 XX XX XX XX	call dword ptr [mem] // CreateThread()    							byte push = *p;  							if (push < 0x50 || push > 0x57)  								continue;  							if (p[1] != push || p[2] != push || p[8] != push || p[9] != push)  								continue;  							if (p[3] != 0x68)  								continue;  							if (p[10] != 0xFF || p[11] != 0x15)  								continue;    							var threadProc = new IntPtr((void*)*(uint*)(p + 4));  							if (!CheckThreadProc(start' end' threadProc))  								continue;    							return threadProc;  						}  					}  					else {  						for (; p < end; p++) {  							// Find this code:  							//	45 33 C9				xor r9d'r9d  							//	4C 8D 05 XX XX XX XX	lea r8'ThreadProc  							//	33 D2					xor edx'edx  							//	33 C9					xor ecx'ecx  							//	FF 15 XX XX XX XX		call dword ptr [mem] // CreateThread()    							if (*p != 0x45 && p[1] != 0x33 && p[2] != 0xC9)  								continue;  							if (p[3] != 0x4C && p[4] != 0x8D && p[5] != 0x05)  								continue;  							if (p[10] != 0x33 && p[11] != 0xD2)  								continue;  							if (p[12] != 0x33 && p[13] != 0xC9)  								continue;  							if (p[14] != 0xFF && p[15] != 0x15)  								continue;    							var threadProc = new IntPtr(p + 10 + *(int*)(p + 6));  							if (!CheckThreadProc(start' end' threadProc))  								continue;    							return threadProc;  						}  					}  				}  				catch { }
Magic Number,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FindAttacherThreadProc,The following statement contains a magic number: try {  					PEInfo peInfo = PEInfo.GetCLR();  					if (peInfo == null)  						return IntPtr.Zero;    					IntPtr sectionAddr;  					uint sectionSize;  					if (!peInfo.FindSection(".text"' out sectionAddr' out sectionSize))  						return IntPtr.Zero;    					var p = (byte*)sectionAddr;  					byte* start = p;  					byte* end = (byte*)sectionAddr + sectionSize;    					if (IntPtr.Size == 4) {  						for (; p < end; p++) {  							// Find this code:  							//	50+r				push reg  							//	50+r				push reg  							//	50+r				push reg  							//	68 XX XX XX XX		push offset ThreadProc  							//	50+r				push reg  							//	50+r				push reg  							//	FF 15 XX XX XX XX	call dword ptr [mem] // CreateThread()    							byte push = *p;  							if (push < 0x50 || push > 0x57)  								continue;  							if (p[1] != push || p[2] != push || p[8] != push || p[9] != push)  								continue;  							if (p[3] != 0x68)  								continue;  							if (p[10] != 0xFF || p[11] != 0x15)  								continue;    							var threadProc = new IntPtr((void*)*(uint*)(p + 4));  							if (!CheckThreadProc(start' end' threadProc))  								continue;    							return threadProc;  						}  					}  					else {  						for (; p < end; p++) {  							// Find this code:  							//	45 33 C9				xor r9d'r9d  							//	4C 8D 05 XX XX XX XX	lea r8'ThreadProc  							//	33 D2					xor edx'edx  							//	33 C9					xor ecx'ecx  							//	FF 15 XX XX XX XX		call dword ptr [mem] // CreateThread()    							if (*p != 0x45 && p[1] != 0x33 && p[2] != 0xC9)  								continue;  							if (p[3] != 0x4C && p[4] != 0x8D && p[5] != 0x05)  								continue;  							if (p[10] != 0x33 && p[11] != 0xD2)  								continue;  							if (p[12] != 0x33 && p[13] != 0xC9)  								continue;  							if (p[14] != 0xFF && p[15] != 0x15)  								continue;    							var threadProc = new IntPtr(p + 10 + *(int*)(p + 6));  							if (!CheckThreadProc(start' end' threadProc))  								continue;    							return threadProc;  						}  					}  				}  				catch { }
Magic Number,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FindAttacherThreadProc,The following statement contains a magic number: try {  					PEInfo peInfo = PEInfo.GetCLR();  					if (peInfo == null)  						return IntPtr.Zero;    					IntPtr sectionAddr;  					uint sectionSize;  					if (!peInfo.FindSection(".text"' out sectionAddr' out sectionSize))  						return IntPtr.Zero;    					var p = (byte*)sectionAddr;  					byte* start = p;  					byte* end = (byte*)sectionAddr + sectionSize;    					if (IntPtr.Size == 4) {  						for (; p < end; p++) {  							// Find this code:  							//	50+r				push reg  							//	50+r				push reg  							//	50+r				push reg  							//	68 XX XX XX XX		push offset ThreadProc  							//	50+r				push reg  							//	50+r				push reg  							//	FF 15 XX XX XX XX	call dword ptr [mem] // CreateThread()    							byte push = *p;  							if (push < 0x50 || push > 0x57)  								continue;  							if (p[1] != push || p[2] != push || p[8] != push || p[9] != push)  								continue;  							if (p[3] != 0x68)  								continue;  							if (p[10] != 0xFF || p[11] != 0x15)  								continue;    							var threadProc = new IntPtr((void*)*(uint*)(p + 4));  							if (!CheckThreadProc(start' end' threadProc))  								continue;    							return threadProc;  						}  					}  					else {  						for (; p < end; p++) {  							// Find this code:  							//	45 33 C9				xor r9d'r9d  							//	4C 8D 05 XX XX XX XX	lea r8'ThreadProc  							//	33 D2					xor edx'edx  							//	33 C9					xor ecx'ecx  							//	FF 15 XX XX XX XX		call dword ptr [mem] // CreateThread()    							if (*p != 0x45 && p[1] != 0x33 && p[2] != 0xC9)  								continue;  							if (p[3] != 0x4C && p[4] != 0x8D && p[5] != 0x05)  								continue;  							if (p[10] != 0x33 && p[11] != 0xD2)  								continue;  							if (p[12] != 0x33 && p[13] != 0xC9)  								continue;  							if (p[14] != 0xFF && p[15] != 0x15)  								continue;    							var threadProc = new IntPtr(p + 10 + *(int*)(p + 6));  							if (!CheckThreadProc(start' end' threadProc))  								continue;    							return threadProc;  						}  					}  				}  				catch { }
Magic Number,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FindAttacherThreadProc,The following statement contains a magic number: try {  					PEInfo peInfo = PEInfo.GetCLR();  					if (peInfo == null)  						return IntPtr.Zero;    					IntPtr sectionAddr;  					uint sectionSize;  					if (!peInfo.FindSection(".text"' out sectionAddr' out sectionSize))  						return IntPtr.Zero;    					var p = (byte*)sectionAddr;  					byte* start = p;  					byte* end = (byte*)sectionAddr + sectionSize;    					if (IntPtr.Size == 4) {  						for (; p < end; p++) {  							// Find this code:  							//	50+r				push reg  							//	50+r				push reg  							//	50+r				push reg  							//	68 XX XX XX XX		push offset ThreadProc  							//	50+r				push reg  							//	50+r				push reg  							//	FF 15 XX XX XX XX	call dword ptr [mem] // CreateThread()    							byte push = *p;  							if (push < 0x50 || push > 0x57)  								continue;  							if (p[1] != push || p[2] != push || p[8] != push || p[9] != push)  								continue;  							if (p[3] != 0x68)  								continue;  							if (p[10] != 0xFF || p[11] != 0x15)  								continue;    							var threadProc = new IntPtr((void*)*(uint*)(p + 4));  							if (!CheckThreadProc(start' end' threadProc))  								continue;    							return threadProc;  						}  					}  					else {  						for (; p < end; p++) {  							// Find this code:  							//	45 33 C9				xor r9d'r9d  							//	4C 8D 05 XX XX XX XX	lea r8'ThreadProc  							//	33 D2					xor edx'edx  							//	33 C9					xor ecx'ecx  							//	FF 15 XX XX XX XX		call dword ptr [mem] // CreateThread()    							if (*p != 0x45 && p[1] != 0x33 && p[2] != 0xC9)  								continue;  							if (p[3] != 0x4C && p[4] != 0x8D && p[5] != 0x05)  								continue;  							if (p[10] != 0x33 && p[11] != 0xD2)  								continue;  							if (p[12] != 0x33 && p[13] != 0xC9)  								continue;  							if (p[14] != 0xFF && p[15] != 0x15)  								continue;    							var threadProc = new IntPtr(p + 10 + *(int*)(p + 6));  							if (!CheckThreadProc(start' end' threadProc))  								continue;    							return threadProc;  						}  					}  				}  				catch { }
Magic Number,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FindAttacherThreadProc,The following statement contains a magic number: try {  					PEInfo peInfo = PEInfo.GetCLR();  					if (peInfo == null)  						return IntPtr.Zero;    					IntPtr sectionAddr;  					uint sectionSize;  					if (!peInfo.FindSection(".text"' out sectionAddr' out sectionSize))  						return IntPtr.Zero;    					var p = (byte*)sectionAddr;  					byte* start = p;  					byte* end = (byte*)sectionAddr + sectionSize;    					if (IntPtr.Size == 4) {  						for (; p < end; p++) {  							// Find this code:  							//	50+r				push reg  							//	50+r				push reg  							//	50+r				push reg  							//	68 XX XX XX XX		push offset ThreadProc  							//	50+r				push reg  							//	50+r				push reg  							//	FF 15 XX XX XX XX	call dword ptr [mem] // CreateThread()    							byte push = *p;  							if (push < 0x50 || push > 0x57)  								continue;  							if (p[1] != push || p[2] != push || p[8] != push || p[9] != push)  								continue;  							if (p[3] != 0x68)  								continue;  							if (p[10] != 0xFF || p[11] != 0x15)  								continue;    							var threadProc = new IntPtr((void*)*(uint*)(p + 4));  							if (!CheckThreadProc(start' end' threadProc))  								continue;    							return threadProc;  						}  					}  					else {  						for (; p < end; p++) {  							// Find this code:  							//	45 33 C9				xor r9d'r9d  							//	4C 8D 05 XX XX XX XX	lea r8'ThreadProc  							//	33 D2					xor edx'edx  							//	33 C9					xor ecx'ecx  							//	FF 15 XX XX XX XX		call dword ptr [mem] // CreateThread()    							if (*p != 0x45 && p[1] != 0x33 && p[2] != 0xC9)  								continue;  							if (p[3] != 0x4C && p[4] != 0x8D && p[5] != 0x05)  								continue;  							if (p[10] != 0x33 && p[11] != 0xD2)  								continue;  							if (p[12] != 0x33 && p[13] != 0xC9)  								continue;  							if (p[14] != 0xFF && p[15] != 0x15)  								continue;    							var threadProc = new IntPtr(p + 10 + *(int*)(p + 6));  							if (!CheckThreadProc(start' end' threadProc))  								continue;    							return threadProc;  						}  					}  				}  				catch { }
Magic Number,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FindAttacherThreadProc,The following statement contains a magic number: try {  					PEInfo peInfo = PEInfo.GetCLR();  					if (peInfo == null)  						return IntPtr.Zero;    					IntPtr sectionAddr;  					uint sectionSize;  					if (!peInfo.FindSection(".text"' out sectionAddr' out sectionSize))  						return IntPtr.Zero;    					var p = (byte*)sectionAddr;  					byte* start = p;  					byte* end = (byte*)sectionAddr + sectionSize;    					if (IntPtr.Size == 4) {  						for (; p < end; p++) {  							// Find this code:  							//	50+r				push reg  							//	50+r				push reg  							//	50+r				push reg  							//	68 XX XX XX XX		push offset ThreadProc  							//	50+r				push reg  							//	50+r				push reg  							//	FF 15 XX XX XX XX	call dword ptr [mem] // CreateThread()    							byte push = *p;  							if (push < 0x50 || push > 0x57)  								continue;  							if (p[1] != push || p[2] != push || p[8] != push || p[9] != push)  								continue;  							if (p[3] != 0x68)  								continue;  							if (p[10] != 0xFF || p[11] != 0x15)  								continue;    							var threadProc = new IntPtr((void*)*(uint*)(p + 4));  							if (!CheckThreadProc(start' end' threadProc))  								continue;    							return threadProc;  						}  					}  					else {  						for (; p < end; p++) {  							// Find this code:  							//	45 33 C9				xor r9d'r9d  							//	4C 8D 05 XX XX XX XX	lea r8'ThreadProc  							//	33 D2					xor edx'edx  							//	33 C9					xor ecx'ecx  							//	FF 15 XX XX XX XX		call dword ptr [mem] // CreateThread()    							if (*p != 0x45 && p[1] != 0x33 && p[2] != 0xC9)  								continue;  							if (p[3] != 0x4C && p[4] != 0x8D && p[5] != 0x05)  								continue;  							if (p[10] != 0x33 && p[11] != 0xD2)  								continue;  							if (p[12] != 0x33 && p[13] != 0xC9)  								continue;  							if (p[14] != 0xFF && p[15] != 0x15)  								continue;    							var threadProc = new IntPtr(p + 10 + *(int*)(p + 6));  							if (!CheckThreadProc(start' end' threadProc))  								continue;    							return threadProc;  						}  					}  				}  				catch { }
Magic Number,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FindProfilerControlBlock,The following statement contains a magic number: try {  					PEInfo peInfo = PEInfo.GetCLR();  					if (peInfo == null)  						return false;    					IntPtr sectionAddr;  					uint sectionSize;  					if (!peInfo.FindSection(".text"' out sectionAddr' out sectionSize))  						return false;    					const int MAX_COUNTS = 50;  					var p = (byte*)sectionAddr;  					byte* end = (byte*)sectionAddr + sectionSize;  					for (; p < end; p++) {  						IntPtr addr;    						// A1 xx xx xx xx		mov eax'[mem]  						// 83 F8 04				cmp eax'4  						if (*p == 0xA1 && p[5] == 0x83 && p[6] == 0xF8 && p[7] == 0x04) {  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 1));  							else  								addr = new IntPtr(p + 5 + *(int*)(p + 1));  						}  							// 8B 05 xx xx xx xx	mov eax'[mem]  							// 83 F8 04				cmp eax'4  						else if (*p == 0x8B && p[1] == 0x05 && p[6] == 0x83 && p[7] == 0xF8 && p[8] == 0x04) {  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 2));  							else  								addr = new IntPtr(p + 6 + *(int*)(p + 2));  						}  							// 83 3D XX XX XX XX 04	cmp dword ptr [mem]'4  						else if (*p == 0x83 && p[1] == 0x3D && p[6] == 0x04) {  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 2));  							else  								addr = new IntPtr(p + 7 + *(int*)(p + 2));  						}  						else  							continue;    						if (!PEInfo.IsAligned(addr' 4))  							continue;  						if (!peInfo.IsValidImageAddress(addr' 4))  							continue;    						// Valid values are 0-4. 4 being attached.  						try {  							if (*(uint*)addr > 4)  								continue;  							*(uint*)addr = *(uint*)addr;  						}  						catch {  							continue;  						}    						int count = 0;  						addrCounts.TryGetValue(addr' out count);  						count++;  						addrCounts[addr] = count;  						if (count >= MAX_COUNTS)  							break;  					}  				}  				catch { }
Magic Number,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FindProfilerControlBlock,The following statement contains a magic number: try {  					PEInfo peInfo = PEInfo.GetCLR();  					if (peInfo == null)  						return false;    					IntPtr sectionAddr;  					uint sectionSize;  					if (!peInfo.FindSection(".text"' out sectionAddr' out sectionSize))  						return false;    					const int MAX_COUNTS = 50;  					var p = (byte*)sectionAddr;  					byte* end = (byte*)sectionAddr + sectionSize;  					for (; p < end; p++) {  						IntPtr addr;    						// A1 xx xx xx xx		mov eax'[mem]  						// 83 F8 04				cmp eax'4  						if (*p == 0xA1 && p[5] == 0x83 && p[6] == 0xF8 && p[7] == 0x04) {  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 1));  							else  								addr = new IntPtr(p + 5 + *(int*)(p + 1));  						}  							// 8B 05 xx xx xx xx	mov eax'[mem]  							// 83 F8 04				cmp eax'4  						else if (*p == 0x8B && p[1] == 0x05 && p[6] == 0x83 && p[7] == 0xF8 && p[8] == 0x04) {  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 2));  							else  								addr = new IntPtr(p + 6 + *(int*)(p + 2));  						}  							// 83 3D XX XX XX XX 04	cmp dword ptr [mem]'4  						else if (*p == 0x83 && p[1] == 0x3D && p[6] == 0x04) {  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 2));  							else  								addr = new IntPtr(p + 7 + *(int*)(p + 2));  						}  						else  							continue;    						if (!PEInfo.IsAligned(addr' 4))  							continue;  						if (!peInfo.IsValidImageAddress(addr' 4))  							continue;    						// Valid values are 0-4. 4 being attached.  						try {  							if (*(uint*)addr > 4)  								continue;  							*(uint*)addr = *(uint*)addr;  						}  						catch {  							continue;  						}    						int count = 0;  						addrCounts.TryGetValue(addr' out count);  						count++;  						addrCounts[addr] = count;  						if (count >= MAX_COUNTS)  							break;  					}  				}  				catch { }
Magic Number,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FindProfilerControlBlock,The following statement contains a magic number: try {  					PEInfo peInfo = PEInfo.GetCLR();  					if (peInfo == null)  						return false;    					IntPtr sectionAddr;  					uint sectionSize;  					if (!peInfo.FindSection(".text"' out sectionAddr' out sectionSize))  						return false;    					const int MAX_COUNTS = 50;  					var p = (byte*)sectionAddr;  					byte* end = (byte*)sectionAddr + sectionSize;  					for (; p < end; p++) {  						IntPtr addr;    						// A1 xx xx xx xx		mov eax'[mem]  						// 83 F8 04				cmp eax'4  						if (*p == 0xA1 && p[5] == 0x83 && p[6] == 0xF8 && p[7] == 0x04) {  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 1));  							else  								addr = new IntPtr(p + 5 + *(int*)(p + 1));  						}  							// 8B 05 xx xx xx xx	mov eax'[mem]  							// 83 F8 04				cmp eax'4  						else if (*p == 0x8B && p[1] == 0x05 && p[6] == 0x83 && p[7] == 0xF8 && p[8] == 0x04) {  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 2));  							else  								addr = new IntPtr(p + 6 + *(int*)(p + 2));  						}  							// 83 3D XX XX XX XX 04	cmp dword ptr [mem]'4  						else if (*p == 0x83 && p[1] == 0x3D && p[6] == 0x04) {  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 2));  							else  								addr = new IntPtr(p + 7 + *(int*)(p + 2));  						}  						else  							continue;    						if (!PEInfo.IsAligned(addr' 4))  							continue;  						if (!peInfo.IsValidImageAddress(addr' 4))  							continue;    						// Valid values are 0-4. 4 being attached.  						try {  							if (*(uint*)addr > 4)  								continue;  							*(uint*)addr = *(uint*)addr;  						}  						catch {  							continue;  						}    						int count = 0;  						addrCounts.TryGetValue(addr' out count);  						count++;  						addrCounts[addr] = count;  						if (count >= MAX_COUNTS)  							break;  					}  				}  				catch { }
Magic Number,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FindProfilerControlBlock,The following statement contains a magic number: try {  					PEInfo peInfo = PEInfo.GetCLR();  					if (peInfo == null)  						return false;    					IntPtr sectionAddr;  					uint sectionSize;  					if (!peInfo.FindSection(".text"' out sectionAddr' out sectionSize))  						return false;    					const int MAX_COUNTS = 50;  					var p = (byte*)sectionAddr;  					byte* end = (byte*)sectionAddr + sectionSize;  					for (; p < end; p++) {  						IntPtr addr;    						// A1 xx xx xx xx		mov eax'[mem]  						// 83 F8 04				cmp eax'4  						if (*p == 0xA1 && p[5] == 0x83 && p[6] == 0xF8 && p[7] == 0x04) {  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 1));  							else  								addr = new IntPtr(p + 5 + *(int*)(p + 1));  						}  							// 8B 05 xx xx xx xx	mov eax'[mem]  							// 83 F8 04				cmp eax'4  						else if (*p == 0x8B && p[1] == 0x05 && p[6] == 0x83 && p[7] == 0xF8 && p[8] == 0x04) {  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 2));  							else  								addr = new IntPtr(p + 6 + *(int*)(p + 2));  						}  							// 83 3D XX XX XX XX 04	cmp dword ptr [mem]'4  						else if (*p == 0x83 && p[1] == 0x3D && p[6] == 0x04) {  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 2));  							else  								addr = new IntPtr(p + 7 + *(int*)(p + 2));  						}  						else  							continue;    						if (!PEInfo.IsAligned(addr' 4))  							continue;  						if (!peInfo.IsValidImageAddress(addr' 4))  							continue;    						// Valid values are 0-4. 4 being attached.  						try {  							if (*(uint*)addr > 4)  								continue;  							*(uint*)addr = *(uint*)addr;  						}  						catch {  							continue;  						}    						int count = 0;  						addrCounts.TryGetValue(addr' out count);  						count++;  						addrCounts[addr] = count;  						if (count >= MAX_COUNTS)  							break;  					}  				}  				catch { }
Magic Number,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FindProfilerControlBlock,The following statement contains a magic number: try {  					PEInfo peInfo = PEInfo.GetCLR();  					if (peInfo == null)  						return false;    					IntPtr sectionAddr;  					uint sectionSize;  					if (!peInfo.FindSection(".text"' out sectionAddr' out sectionSize))  						return false;    					const int MAX_COUNTS = 50;  					var p = (byte*)sectionAddr;  					byte* end = (byte*)sectionAddr + sectionSize;  					for (; p < end; p++) {  						IntPtr addr;    						// A1 xx xx xx xx		mov eax'[mem]  						// 83 F8 04				cmp eax'4  						if (*p == 0xA1 && p[5] == 0x83 && p[6] == 0xF8 && p[7] == 0x04) {  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 1));  							else  								addr = new IntPtr(p + 5 + *(int*)(p + 1));  						}  							// 8B 05 xx xx xx xx	mov eax'[mem]  							// 83 F8 04				cmp eax'4  						else if (*p == 0x8B && p[1] == 0x05 && p[6] == 0x83 && p[7] == 0xF8 && p[8] == 0x04) {  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 2));  							else  								addr = new IntPtr(p + 6 + *(int*)(p + 2));  						}  							// 83 3D XX XX XX XX 04	cmp dword ptr [mem]'4  						else if (*p == 0x83 && p[1] == 0x3D && p[6] == 0x04) {  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 2));  							else  								addr = new IntPtr(p + 7 + *(int*)(p + 2));  						}  						else  							continue;    						if (!PEInfo.IsAligned(addr' 4))  							continue;  						if (!peInfo.IsValidImageAddress(addr' 4))  							continue;    						// Valid values are 0-4. 4 being attached.  						try {  							if (*(uint*)addr > 4)  								continue;  							*(uint*)addr = *(uint*)addr;  						}  						catch {  							continue;  						}    						int count = 0;  						addrCounts.TryGetValue(addr' out count);  						count++;  						addrCounts[addr] = count;  						if (count >= MAX_COUNTS)  							break;  					}  				}  				catch { }
Magic Number,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FindProfilerControlBlock,The following statement contains a magic number: try {  					PEInfo peInfo = PEInfo.GetCLR();  					if (peInfo == null)  						return false;    					IntPtr sectionAddr;  					uint sectionSize;  					if (!peInfo.FindSection(".text"' out sectionAddr' out sectionSize))  						return false;    					const int MAX_COUNTS = 50;  					var p = (byte*)sectionAddr;  					byte* end = (byte*)sectionAddr + sectionSize;  					for (; p < end; p++) {  						IntPtr addr;    						// A1 xx xx xx xx		mov eax'[mem]  						// 83 F8 04				cmp eax'4  						if (*p == 0xA1 && p[5] == 0x83 && p[6] == 0xF8 && p[7] == 0x04) {  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 1));  							else  								addr = new IntPtr(p + 5 + *(int*)(p + 1));  						}  							// 8B 05 xx xx xx xx	mov eax'[mem]  							// 83 F8 04				cmp eax'4  						else if (*p == 0x8B && p[1] == 0x05 && p[6] == 0x83 && p[7] == 0xF8 && p[8] == 0x04) {  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 2));  							else  								addr = new IntPtr(p + 6 + *(int*)(p + 2));  						}  							// 83 3D XX XX XX XX 04	cmp dword ptr [mem]'4  						else if (*p == 0x83 && p[1] == 0x3D && p[6] == 0x04) {  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 2));  							else  								addr = new IntPtr(p + 7 + *(int*)(p + 2));  						}  						else  							continue;    						if (!PEInfo.IsAligned(addr' 4))  							continue;  						if (!peInfo.IsValidImageAddress(addr' 4))  							continue;    						// Valid values are 0-4. 4 being attached.  						try {  							if (*(uint*)addr > 4)  								continue;  							*(uint*)addr = *(uint*)addr;  						}  						catch {  							continue;  						}    						int count = 0;  						addrCounts.TryGetValue(addr' out count);  						count++;  						addrCounts[addr] = count;  						if (count >= MAX_COUNTS)  							break;  					}  				}  				catch { }
Magic Number,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FindProfilerControlBlock,The following statement contains a magic number: try {  					PEInfo peInfo = PEInfo.GetCLR();  					if (peInfo == null)  						return false;    					IntPtr sectionAddr;  					uint sectionSize;  					if (!peInfo.FindSection(".text"' out sectionAddr' out sectionSize))  						return false;    					const int MAX_COUNTS = 50;  					var p = (byte*)sectionAddr;  					byte* end = (byte*)sectionAddr + sectionSize;  					for (; p < end; p++) {  						IntPtr addr;    						// A1 xx xx xx xx		mov eax'[mem]  						// 83 F8 04				cmp eax'4  						if (*p == 0xA1 && p[5] == 0x83 && p[6] == 0xF8 && p[7] == 0x04) {  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 1));  							else  								addr = new IntPtr(p + 5 + *(int*)(p + 1));  						}  							// 8B 05 xx xx xx xx	mov eax'[mem]  							// 83 F8 04				cmp eax'4  						else if (*p == 0x8B && p[1] == 0x05 && p[6] == 0x83 && p[7] == 0xF8 && p[8] == 0x04) {  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 2));  							else  								addr = new IntPtr(p + 6 + *(int*)(p + 2));  						}  							// 83 3D XX XX XX XX 04	cmp dword ptr [mem]'4  						else if (*p == 0x83 && p[1] == 0x3D && p[6] == 0x04) {  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 2));  							else  								addr = new IntPtr(p + 7 + *(int*)(p + 2));  						}  						else  							continue;    						if (!PEInfo.IsAligned(addr' 4))  							continue;  						if (!peInfo.IsValidImageAddress(addr' 4))  							continue;    						// Valid values are 0-4. 4 being attached.  						try {  							if (*(uint*)addr > 4)  								continue;  							*(uint*)addr = *(uint*)addr;  						}  						catch {  							continue;  						}    						int count = 0;  						addrCounts.TryGetValue(addr' out count);  						count++;  						addrCounts[addr] = count;  						if (count >= MAX_COUNTS)  							break;  					}  				}  				catch { }
Magic Number,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FindProfilerControlBlock,The following statement contains a magic number: try {  					PEInfo peInfo = PEInfo.GetCLR();  					if (peInfo == null)  						return false;    					IntPtr sectionAddr;  					uint sectionSize;  					if (!peInfo.FindSection(".text"' out sectionAddr' out sectionSize))  						return false;    					const int MAX_COUNTS = 50;  					var p = (byte*)sectionAddr;  					byte* end = (byte*)sectionAddr + sectionSize;  					for (; p < end; p++) {  						IntPtr addr;    						// A1 xx xx xx xx		mov eax'[mem]  						// 83 F8 04				cmp eax'4  						if (*p == 0xA1 && p[5] == 0x83 && p[6] == 0xF8 && p[7] == 0x04) {  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 1));  							else  								addr = new IntPtr(p + 5 + *(int*)(p + 1));  						}  							// 8B 05 xx xx xx xx	mov eax'[mem]  							// 83 F8 04				cmp eax'4  						else if (*p == 0x8B && p[1] == 0x05 && p[6] == 0x83 && p[7] == 0xF8 && p[8] == 0x04) {  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 2));  							else  								addr = new IntPtr(p + 6 + *(int*)(p + 2));  						}  							// 83 3D XX XX XX XX 04	cmp dword ptr [mem]'4  						else if (*p == 0x83 && p[1] == 0x3D && p[6] == 0x04) {  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 2));  							else  								addr = new IntPtr(p + 7 + *(int*)(p + 2));  						}  						else  							continue;    						if (!PEInfo.IsAligned(addr' 4))  							continue;  						if (!peInfo.IsValidImageAddress(addr' 4))  							continue;    						// Valid values are 0-4. 4 being attached.  						try {  							if (*(uint*)addr > 4)  								continue;  							*(uint*)addr = *(uint*)addr;  						}  						catch {  							continue;  						}    						int count = 0;  						addrCounts.TryGetValue(addr' out count);  						count++;  						addrCounts[addr] = count;  						if (count >= MAX_COUNTS)  							break;  					}  				}  				catch { }
Magic Number,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FindProfilerControlBlock,The following statement contains a magic number: try {  					PEInfo peInfo = PEInfo.GetCLR();  					if (peInfo == null)  						return false;    					IntPtr sectionAddr;  					uint sectionSize;  					if (!peInfo.FindSection(".text"' out sectionAddr' out sectionSize))  						return false;    					const int MAX_COUNTS = 50;  					var p = (byte*)sectionAddr;  					byte* end = (byte*)sectionAddr + sectionSize;  					for (; p < end; p++) {  						IntPtr addr;    						// A1 xx xx xx xx		mov eax'[mem]  						// 83 F8 04				cmp eax'4  						if (*p == 0xA1 && p[5] == 0x83 && p[6] == 0xF8 && p[7] == 0x04) {  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 1));  							else  								addr = new IntPtr(p + 5 + *(int*)(p + 1));  						}  							// 8B 05 xx xx xx xx	mov eax'[mem]  							// 83 F8 04				cmp eax'4  						else if (*p == 0x8B && p[1] == 0x05 && p[6] == 0x83 && p[7] == 0xF8 && p[8] == 0x04) {  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 2));  							else  								addr = new IntPtr(p + 6 + *(int*)(p + 2));  						}  							// 83 3D XX XX XX XX 04	cmp dword ptr [mem]'4  						else if (*p == 0x83 && p[1] == 0x3D && p[6] == 0x04) {  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 2));  							else  								addr = new IntPtr(p + 7 + *(int*)(p + 2));  						}  						else  							continue;    						if (!PEInfo.IsAligned(addr' 4))  							continue;  						if (!peInfo.IsValidImageAddress(addr' 4))  							continue;    						// Valid values are 0-4. 4 being attached.  						try {  							if (*(uint*)addr > 4)  								continue;  							*(uint*)addr = *(uint*)addr;  						}  						catch {  							continue;  						}    						int count = 0;  						addrCounts.TryGetValue(addr' out count);  						count++;  						addrCounts[addr] = count;  						if (count >= MAX_COUNTS)  							break;  					}  				}  				catch { }
Magic Number,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FindProfilerControlBlock,The following statement contains a magic number: try {  					PEInfo peInfo = PEInfo.GetCLR();  					if (peInfo == null)  						return false;    					IntPtr sectionAddr;  					uint sectionSize;  					if (!peInfo.FindSection(".text"' out sectionAddr' out sectionSize))  						return false;    					const int MAX_COUNTS = 50;  					var p = (byte*)sectionAddr;  					byte* end = (byte*)sectionAddr + sectionSize;  					for (; p < end; p++) {  						IntPtr addr;    						// A1 xx xx xx xx		mov eax'[mem]  						// 83 F8 04				cmp eax'4  						if (*p == 0xA1 && p[5] == 0x83 && p[6] == 0xF8 && p[7] == 0x04) {  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 1));  							else  								addr = new IntPtr(p + 5 + *(int*)(p + 1));  						}  							// 8B 05 xx xx xx xx	mov eax'[mem]  							// 83 F8 04				cmp eax'4  						else if (*p == 0x8B && p[1] == 0x05 && p[6] == 0x83 && p[7] == 0xF8 && p[8] == 0x04) {  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 2));  							else  								addr = new IntPtr(p + 6 + *(int*)(p + 2));  						}  							// 83 3D XX XX XX XX 04	cmp dword ptr [mem]'4  						else if (*p == 0x83 && p[1] == 0x3D && p[6] == 0x04) {  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 2));  							else  								addr = new IntPtr(p + 7 + *(int*)(p + 2));  						}  						else  							continue;    						if (!PEInfo.IsAligned(addr' 4))  							continue;  						if (!peInfo.IsValidImageAddress(addr' 4))  							continue;    						// Valid values are 0-4. 4 being attached.  						try {  							if (*(uint*)addr > 4)  								continue;  							*(uint*)addr = *(uint*)addr;  						}  						catch {  							continue;  						}    						int count = 0;  						addrCounts.TryGetValue(addr' out count);  						count++;  						addrCounts[addr] = count;  						if (count >= MAX_COUNTS)  							break;  					}  				}  				catch { }
Magic Number,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FindProfilerControlBlock,The following statement contains a magic number: try {  					PEInfo peInfo = PEInfo.GetCLR();  					if (peInfo == null)  						return false;    					IntPtr sectionAddr;  					uint sectionSize;  					if (!peInfo.FindSection(".text"' out sectionAddr' out sectionSize))  						return false;    					const int MAX_COUNTS = 50;  					var p = (byte*)sectionAddr;  					byte* end = (byte*)sectionAddr + sectionSize;  					for (; p < end; p++) {  						IntPtr addr;    						// A1 xx xx xx xx		mov eax'[mem]  						// 83 F8 04				cmp eax'4  						if (*p == 0xA1 && p[5] == 0x83 && p[6] == 0xF8 && p[7] == 0x04) {  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 1));  							else  								addr = new IntPtr(p + 5 + *(int*)(p + 1));  						}  							// 8B 05 xx xx xx xx	mov eax'[mem]  							// 83 F8 04				cmp eax'4  						else if (*p == 0x8B && p[1] == 0x05 && p[6] == 0x83 && p[7] == 0xF8 && p[8] == 0x04) {  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 2));  							else  								addr = new IntPtr(p + 6 + *(int*)(p + 2));  						}  							// 83 3D XX XX XX XX 04	cmp dword ptr [mem]'4  						else if (*p == 0x83 && p[1] == 0x3D && p[6] == 0x04) {  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 2));  							else  								addr = new IntPtr(p + 7 + *(int*)(p + 2));  						}  						else  							continue;    						if (!PEInfo.IsAligned(addr' 4))  							continue;  						if (!peInfo.IsValidImageAddress(addr' 4))  							continue;    						// Valid values are 0-4. 4 being attached.  						try {  							if (*(uint*)addr > 4)  								continue;  							*(uint*)addr = *(uint*)addr;  						}  						catch {  							continue;  						}    						int count = 0;  						addrCounts.TryGetValue(addr' out count);  						count++;  						addrCounts[addr] = count;  						if (count >= MAX_COUNTS)  							break;  					}  				}  				catch { }
Magic Number,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FindProfilerControlBlock,The following statement contains a magic number: try {  					PEInfo peInfo = PEInfo.GetCLR();  					if (peInfo == null)  						return false;    					IntPtr sectionAddr;  					uint sectionSize;  					if (!peInfo.FindSection(".text"' out sectionAddr' out sectionSize))  						return false;    					const int MAX_COUNTS = 50;  					var p = (byte*)sectionAddr;  					byte* end = (byte*)sectionAddr + sectionSize;  					for (; p < end; p++) {  						IntPtr addr;    						// A1 xx xx xx xx		mov eax'[mem]  						// 83 F8 04				cmp eax'4  						if (*p == 0xA1 && p[5] == 0x83 && p[6] == 0xF8 && p[7] == 0x04) {  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 1));  							else  								addr = new IntPtr(p + 5 + *(int*)(p + 1));  						}  							// 8B 05 xx xx xx xx	mov eax'[mem]  							// 83 F8 04				cmp eax'4  						else if (*p == 0x8B && p[1] == 0x05 && p[6] == 0x83 && p[7] == 0xF8 && p[8] == 0x04) {  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 2));  							else  								addr = new IntPtr(p + 6 + *(int*)(p + 2));  						}  							// 83 3D XX XX XX XX 04	cmp dword ptr [mem]'4  						else if (*p == 0x83 && p[1] == 0x3D && p[6] == 0x04) {  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 2));  							else  								addr = new IntPtr(p + 7 + *(int*)(p + 2));  						}  						else  							continue;    						if (!PEInfo.IsAligned(addr' 4))  							continue;  						if (!peInfo.IsValidImageAddress(addr' 4))  							continue;    						// Valid values are 0-4. 4 being attached.  						try {  							if (*(uint*)addr > 4)  								continue;  							*(uint*)addr = *(uint*)addr;  						}  						catch {  							continue;  						}    						int count = 0;  						addrCounts.TryGetValue(addr' out count);  						count++;  						addrCounts[addr] = count;  						if (count >= MAX_COUNTS)  							break;  					}  				}  				catch { }
Magic Number,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FindProfilerControlBlock,The following statement contains a magic number: try {  					PEInfo peInfo = PEInfo.GetCLR();  					if (peInfo == null)  						return false;    					IntPtr sectionAddr;  					uint sectionSize;  					if (!peInfo.FindSection(".text"' out sectionAddr' out sectionSize))  						return false;    					const int MAX_COUNTS = 50;  					var p = (byte*)sectionAddr;  					byte* end = (byte*)sectionAddr + sectionSize;  					for (; p < end; p++) {  						IntPtr addr;    						// A1 xx xx xx xx		mov eax'[mem]  						// 83 F8 04				cmp eax'4  						if (*p == 0xA1 && p[5] == 0x83 && p[6] == 0xF8 && p[7] == 0x04) {  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 1));  							else  								addr = new IntPtr(p + 5 + *(int*)(p + 1));  						}  							// 8B 05 xx xx xx xx	mov eax'[mem]  							// 83 F8 04				cmp eax'4  						else if (*p == 0x8B && p[1] == 0x05 && p[6] == 0x83 && p[7] == 0xF8 && p[8] == 0x04) {  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 2));  							else  								addr = new IntPtr(p + 6 + *(int*)(p + 2));  						}  							// 83 3D XX XX XX XX 04	cmp dword ptr [mem]'4  						else if (*p == 0x83 && p[1] == 0x3D && p[6] == 0x04) {  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 2));  							else  								addr = new IntPtr(p + 7 + *(int*)(p + 2));  						}  						else  							continue;    						if (!PEInfo.IsAligned(addr' 4))  							continue;  						if (!peInfo.IsValidImageAddress(addr' 4))  							continue;    						// Valid values are 0-4. 4 being attached.  						try {  							if (*(uint*)addr > 4)  								continue;  							*(uint*)addr = *(uint*)addr;  						}  						catch {  							continue;  						}    						int count = 0;  						addrCounts.TryGetValue(addr' out count);  						count++;  						addrCounts[addr] = count;  						if (count >= MAX_COUNTS)  							break;  					}  				}  				catch { }
Magic Number,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FindProfilerControlBlock,The following statement contains a magic number: try {  					PEInfo peInfo = PEInfo.GetCLR();  					if (peInfo == null)  						return false;    					IntPtr sectionAddr;  					uint sectionSize;  					if (!peInfo.FindSection(".text"' out sectionAddr' out sectionSize))  						return false;    					const int MAX_COUNTS = 50;  					var p = (byte*)sectionAddr;  					byte* end = (byte*)sectionAddr + sectionSize;  					for (; p < end; p++) {  						IntPtr addr;    						// A1 xx xx xx xx		mov eax'[mem]  						// 83 F8 04				cmp eax'4  						if (*p == 0xA1 && p[5] == 0x83 && p[6] == 0xF8 && p[7] == 0x04) {  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 1));  							else  								addr = new IntPtr(p + 5 + *(int*)(p + 1));  						}  							// 8B 05 xx xx xx xx	mov eax'[mem]  							// 83 F8 04				cmp eax'4  						else if (*p == 0x8B && p[1] == 0x05 && p[6] == 0x83 && p[7] == 0xF8 && p[8] == 0x04) {  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 2));  							else  								addr = new IntPtr(p + 6 + *(int*)(p + 2));  						}  							// 83 3D XX XX XX XX 04	cmp dword ptr [mem]'4  						else if (*p == 0x83 && p[1] == 0x3D && p[6] == 0x04) {  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 2));  							else  								addr = new IntPtr(p + 7 + *(int*)(p + 2));  						}  						else  							continue;    						if (!PEInfo.IsAligned(addr' 4))  							continue;  						if (!peInfo.IsValidImageAddress(addr' 4))  							continue;    						// Valid values are 0-4. 4 being attached.  						try {  							if (*(uint*)addr > 4)  								continue;  							*(uint*)addr = *(uint*)addr;  						}  						catch {  							continue;  						}    						int count = 0;  						addrCounts.TryGetValue(addr' out count);  						count++;  						addrCounts[addr] = count;  						if (count >= MAX_COUNTS)  							break;  					}  				}  				catch { }
Magic Number,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FindProfilerControlBlock,The following statement contains a magic number: try {  					PEInfo peInfo = PEInfo.GetCLR();  					if (peInfo == null)  						return false;    					IntPtr sectionAddr;  					uint sectionSize;  					if (!peInfo.FindSection(".text"' out sectionAddr' out sectionSize))  						return false;    					const int MAX_COUNTS = 50;  					var p = (byte*)sectionAddr;  					byte* end = (byte*)sectionAddr + sectionSize;  					for (; p < end; p++) {  						IntPtr addr;    						// A1 xx xx xx xx		mov eax'[mem]  						// 83 F8 04				cmp eax'4  						if (*p == 0xA1 && p[5] == 0x83 && p[6] == 0xF8 && p[7] == 0x04) {  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 1));  							else  								addr = new IntPtr(p + 5 + *(int*)(p + 1));  						}  							// 8B 05 xx xx xx xx	mov eax'[mem]  							// 83 F8 04				cmp eax'4  						else if (*p == 0x8B && p[1] == 0x05 && p[6] == 0x83 && p[7] == 0xF8 && p[8] == 0x04) {  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 2));  							else  								addr = new IntPtr(p + 6 + *(int*)(p + 2));  						}  							// 83 3D XX XX XX XX 04	cmp dword ptr [mem]'4  						else if (*p == 0x83 && p[1] == 0x3D && p[6] == 0x04) {  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 2));  							else  								addr = new IntPtr(p + 7 + *(int*)(p + 2));  						}  						else  							continue;    						if (!PEInfo.IsAligned(addr' 4))  							continue;  						if (!peInfo.IsValidImageAddress(addr' 4))  							continue;    						// Valid values are 0-4. 4 being attached.  						try {  							if (*(uint*)addr > 4)  								continue;  							*(uint*)addr = *(uint*)addr;  						}  						catch {  							continue;  						}    						int count = 0;  						addrCounts.TryGetValue(addr' out count);  						count++;  						addrCounts[addr] = count;  						if (count >= MAX_COUNTS)  							break;  					}  				}  				catch { }
Magic Number,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FindProfilerControlBlock,The following statement contains a magic number: try {  					PEInfo peInfo = PEInfo.GetCLR();  					if (peInfo == null)  						return false;    					IntPtr sectionAddr;  					uint sectionSize;  					if (!peInfo.FindSection(".text"' out sectionAddr' out sectionSize))  						return false;    					const int MAX_COUNTS = 50;  					var p = (byte*)sectionAddr;  					byte* end = (byte*)sectionAddr + sectionSize;  					for (; p < end; p++) {  						IntPtr addr;    						// A1 xx xx xx xx		mov eax'[mem]  						// 83 F8 04				cmp eax'4  						if (*p == 0xA1 && p[5] == 0x83 && p[6] == 0xF8 && p[7] == 0x04) {  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 1));  							else  								addr = new IntPtr(p + 5 + *(int*)(p + 1));  						}  							// 8B 05 xx xx xx xx	mov eax'[mem]  							// 83 F8 04				cmp eax'4  						else if (*p == 0x8B && p[1] == 0x05 && p[6] == 0x83 && p[7] == 0xF8 && p[8] == 0x04) {  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 2));  							else  								addr = new IntPtr(p + 6 + *(int*)(p + 2));  						}  							// 83 3D XX XX XX XX 04	cmp dword ptr [mem]'4  						else if (*p == 0x83 && p[1] == 0x3D && p[6] == 0x04) {  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 2));  							else  								addr = new IntPtr(p + 7 + *(int*)(p + 2));  						}  						else  							continue;    						if (!PEInfo.IsAligned(addr' 4))  							continue;  						if (!peInfo.IsValidImageAddress(addr' 4))  							continue;    						// Valid values are 0-4. 4 being attached.  						try {  							if (*(uint*)addr > 4)  								continue;  							*(uint*)addr = *(uint*)addr;  						}  						catch {  							continue;  						}    						int count = 0;  						addrCounts.TryGetValue(addr' out count);  						count++;  						addrCounts[addr] = count;  						if (count >= MAX_COUNTS)  							break;  					}  				}  				catch { }
Magic Number,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FindProfilerControlBlock,The following statement contains a magic number: try {  					PEInfo peInfo = PEInfo.GetCLR();  					if (peInfo == null)  						return false;    					IntPtr sectionAddr;  					uint sectionSize;  					if (!peInfo.FindSection(".text"' out sectionAddr' out sectionSize))  						return false;    					const int MAX_COUNTS = 50;  					var p = (byte*)sectionAddr;  					byte* end = (byte*)sectionAddr + sectionSize;  					for (; p < end; p++) {  						IntPtr addr;    						// A1 xx xx xx xx		mov eax'[mem]  						// 83 F8 04				cmp eax'4  						if (*p == 0xA1 && p[5] == 0x83 && p[6] == 0xF8 && p[7] == 0x04) {  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 1));  							else  								addr = new IntPtr(p + 5 + *(int*)(p + 1));  						}  							// 8B 05 xx xx xx xx	mov eax'[mem]  							// 83 F8 04				cmp eax'4  						else if (*p == 0x8B && p[1] == 0x05 && p[6] == 0x83 && p[7] == 0xF8 && p[8] == 0x04) {  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 2));  							else  								addr = new IntPtr(p + 6 + *(int*)(p + 2));  						}  							// 83 3D XX XX XX XX 04	cmp dword ptr [mem]'4  						else if (*p == 0x83 && p[1] == 0x3D && p[6] == 0x04) {  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 2));  							else  								addr = new IntPtr(p + 7 + *(int*)(p + 2));  						}  						else  							continue;    						if (!PEInfo.IsAligned(addr' 4))  							continue;  						if (!peInfo.IsValidImageAddress(addr' 4))  							continue;    						// Valid values are 0-4. 4 being attached.  						try {  							if (*(uint*)addr > 4)  								continue;  							*(uint*)addr = *(uint*)addr;  						}  						catch {  							continue;  						}    						int count = 0;  						addrCounts.TryGetValue(addr' out count);  						count++;  						addrCounts[addr] = count;  						if (count >= MAX_COUNTS)  							break;  					}  				}  				catch { }
Magic Number,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FindProfilerControlBlock,The following statement contains a magic number: try {  					PEInfo peInfo = PEInfo.GetCLR();  					if (peInfo == null)  						return false;    					IntPtr sectionAddr;  					uint sectionSize;  					if (!peInfo.FindSection(".text"' out sectionAddr' out sectionSize))  						return false;    					const int MAX_COUNTS = 50;  					var p = (byte*)sectionAddr;  					byte* end = (byte*)sectionAddr + sectionSize;  					for (; p < end; p++) {  						IntPtr addr;    						// A1 xx xx xx xx		mov eax'[mem]  						// 83 F8 04				cmp eax'4  						if (*p == 0xA1 && p[5] == 0x83 && p[6] == 0xF8 && p[7] == 0x04) {  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 1));  							else  								addr = new IntPtr(p + 5 + *(int*)(p + 1));  						}  							// 8B 05 xx xx xx xx	mov eax'[mem]  							// 83 F8 04				cmp eax'4  						else if (*p == 0x8B && p[1] == 0x05 && p[6] == 0x83 && p[7] == 0xF8 && p[8] == 0x04) {  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 2));  							else  								addr = new IntPtr(p + 6 + *(int*)(p + 2));  						}  							// 83 3D XX XX XX XX 04	cmp dword ptr [mem]'4  						else if (*p == 0x83 && p[1] == 0x3D && p[6] == 0x04) {  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 2));  							else  								addr = new IntPtr(p + 7 + *(int*)(p + 2));  						}  						else  							continue;    						if (!PEInfo.IsAligned(addr' 4))  							continue;  						if (!peInfo.IsValidImageAddress(addr' 4))  							continue;    						// Valid values are 0-4. 4 being attached.  						try {  							if (*(uint*)addr > 4)  								continue;  							*(uint*)addr = *(uint*)addr;  						}  						catch {  							continue;  						}    						int count = 0;  						addrCounts.TryGetValue(addr' out count);  						count++;  						addrCounts[addr] = count;  						if (count >= MAX_COUNTS)  							break;  					}  				}  				catch { }
Magic Number,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FindProfilerControlBlock,The following statement contains a magic number: try {  					PEInfo peInfo = PEInfo.GetCLR();  					if (peInfo == null)  						return false;    					IntPtr sectionAddr;  					uint sectionSize;  					if (!peInfo.FindSection(".text"' out sectionAddr' out sectionSize))  						return false;    					const int MAX_COUNTS = 50;  					var p = (byte*)sectionAddr;  					byte* end = (byte*)sectionAddr + sectionSize;  					for (; p < end; p++) {  						IntPtr addr;    						// A1 xx xx xx xx		mov eax'[mem]  						// 83 F8 04				cmp eax'4  						if (*p == 0xA1 && p[5] == 0x83 && p[6] == 0xF8 && p[7] == 0x04) {  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 1));  							else  								addr = new IntPtr(p + 5 + *(int*)(p + 1));  						}  							// 8B 05 xx xx xx xx	mov eax'[mem]  							// 83 F8 04				cmp eax'4  						else if (*p == 0x8B && p[1] == 0x05 && p[6] == 0x83 && p[7] == 0xF8 && p[8] == 0x04) {  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 2));  							else  								addr = new IntPtr(p + 6 + *(int*)(p + 2));  						}  							// 83 3D XX XX XX XX 04	cmp dword ptr [mem]'4  						else if (*p == 0x83 && p[1] == 0x3D && p[6] == 0x04) {  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 2));  							else  								addr = new IntPtr(p + 7 + *(int*)(p + 2));  						}  						else  							continue;    						if (!PEInfo.IsAligned(addr' 4))  							continue;  						if (!peInfo.IsValidImageAddress(addr' 4))  							continue;    						// Valid values are 0-4. 4 being attached.  						try {  							if (*(uint*)addr > 4)  								continue;  							*(uint*)addr = *(uint*)addr;  						}  						catch {  							continue;  						}    						int count = 0;  						addrCounts.TryGetValue(addr' out count);  						count++;  						addrCounts[addr] = count;  						if (count >= MAX_COUNTS)  							break;  					}  				}  				catch { }
Magic Number,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FindProfilerControlBlock,The following statement contains a magic number: try {  					PEInfo peInfo = PEInfo.GetCLR();  					if (peInfo == null)  						return false;    					IntPtr sectionAddr;  					uint sectionSize;  					if (!peInfo.FindSection(".text"' out sectionAddr' out sectionSize))  						return false;    					const int MAX_COUNTS = 50;  					var p = (byte*)sectionAddr;  					byte* end = (byte*)sectionAddr + sectionSize;  					for (; p < end; p++) {  						IntPtr addr;    						// A1 xx xx xx xx		mov eax'[mem]  						// 83 F8 04				cmp eax'4  						if (*p == 0xA1 && p[5] == 0x83 && p[6] == 0xF8 && p[7] == 0x04) {  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 1));  							else  								addr = new IntPtr(p + 5 + *(int*)(p + 1));  						}  							// 8B 05 xx xx xx xx	mov eax'[mem]  							// 83 F8 04				cmp eax'4  						else if (*p == 0x8B && p[1] == 0x05 && p[6] == 0x83 && p[7] == 0xF8 && p[8] == 0x04) {  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 2));  							else  								addr = new IntPtr(p + 6 + *(int*)(p + 2));  						}  							// 83 3D XX XX XX XX 04	cmp dword ptr [mem]'4  						else if (*p == 0x83 && p[1] == 0x3D && p[6] == 0x04) {  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 2));  							else  								addr = new IntPtr(p + 7 + *(int*)(p + 2));  						}  						else  							continue;    						if (!PEInfo.IsAligned(addr' 4))  							continue;  						if (!peInfo.IsValidImageAddress(addr' 4))  							continue;    						// Valid values are 0-4. 4 being attached.  						try {  							if (*(uint*)addr > 4)  								continue;  							*(uint*)addr = *(uint*)addr;  						}  						catch {  							continue;  						}    						int count = 0;  						addrCounts.TryGetValue(addr' out count);  						count++;  						addrCounts[addr] = count;  						if (count >= MAX_COUNTS)  							break;  					}  				}  				catch { }
Magic Number,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FindProfilerControlBlock,The following statement contains a magic number: try {  					PEInfo peInfo = PEInfo.GetCLR();  					if (peInfo == null)  						return false;    					IntPtr sectionAddr;  					uint sectionSize;  					if (!peInfo.FindSection(".text"' out sectionAddr' out sectionSize))  						return false;    					const int MAX_COUNTS = 50;  					var p = (byte*)sectionAddr;  					byte* end = (byte*)sectionAddr + sectionSize;  					for (; p < end; p++) {  						IntPtr addr;    						// A1 xx xx xx xx		mov eax'[mem]  						// 83 F8 04				cmp eax'4  						if (*p == 0xA1 && p[5] == 0x83 && p[6] == 0xF8 && p[7] == 0x04) {  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 1));  							else  								addr = new IntPtr(p + 5 + *(int*)(p + 1));  						}  							// 8B 05 xx xx xx xx	mov eax'[mem]  							// 83 F8 04				cmp eax'4  						else if (*p == 0x8B && p[1] == 0x05 && p[6] == 0x83 && p[7] == 0xF8 && p[8] == 0x04) {  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 2));  							else  								addr = new IntPtr(p + 6 + *(int*)(p + 2));  						}  							// 83 3D XX XX XX XX 04	cmp dword ptr [mem]'4  						else if (*p == 0x83 && p[1] == 0x3D && p[6] == 0x04) {  							if (IntPtr.Size == 4)  								addr = new IntPtr((void*)*(uint*)(p + 2));  							else  								addr = new IntPtr(p + 7 + *(int*)(p + 2));  						}  						else  							continue;    						if (!PEInfo.IsAligned(addr' 4))  							continue;  						if (!peInfo.IsValidImageAddress(addr' 4))  							continue;    						// Valid values are 0-4. 4 being attached.  						try {  							if (*(uint*)addr > 4)  								continue;  							*(uint*)addr = *(uint*)addr;  						}  						catch {  							continue;  						}    						int count = 0;  						addrCounts.TryGetValue(addr' out count);  						count++;  						addrCounts[addr] = count;  						if (count >= MAX_COUNTS)  							break;  					}  				}  				catch { }
Magic Number,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FindProfilerControlBlock,The following statement contains a magic number: IntPtr foundAddr = GetMax(addrCounts' 5);
Magic Number,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,FindProfilerControlBlock,The following statement contains a magic number: profilerControlBlock = new IntPtr((byte*)foundAddr - (IntPtr.Size + 4));
Magic Number,Confuser.Runtime,ProfilerDetectorCLR40,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\AntiManagedProfiler.cs,PreventActiveProfilerFromReceivingProfilingMessages,The following statement contains a magic number: *(uint*)((byte*)profilerControlBlock + IntPtr.Size + 4) = 0;
Magic Number,Confuser.Runtime,PEInfo,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\PEInfo.cs,GetCLRAddress,The following statement contains a magic number: if (Environment.Version.Major == 2)  					return GetModuleHandle("mscorwks");
Magic Number,Confuser.Runtime,PEInfo,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\PEInfo.cs,Init,The following statement contains a magic number: p += 4 + 2;
Magic Number,Confuser.Runtime,PEInfo,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\PEInfo.cs,Init,The following statement contains a magic number: p += 4 + 2;
Magic Number,Confuser.Runtime,PEInfo,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\PEInfo.cs,Init,The following statement contains a magic number: p += 2 + 0x10;
Magic Number,Confuser.Runtime,PEInfo,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\PEInfo.cs,Init,The following statement contains a magic number: p += 0x10 * 8;
Magic Number,Confuser.Runtime,PEInfo,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\PEInfo.cs,FindSection,The following statement contains a magic number: for (int i = 0; i < numSects; i++) {  					byte* p = (byte*)sectionsAddr + i * 0x28;  					if (!CompareSectionName(p' nameBytes))  						continue;    					sectionStart = new IntPtr((byte*)imageBase + *(uint*)(p + 12));  					sectionSize = Math.Max(*(uint*)(p + 8)' *(uint*)(p + 16));  					return true;  				}
Magic Number,Confuser.Runtime,PEInfo,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\PEInfo.cs,FindSection,The following statement contains a magic number: for (int i = 0; i < numSects; i++) {  					byte* p = (byte*)sectionsAddr + i * 0x28;  					if (!CompareSectionName(p' nameBytes))  						continue;    					sectionStart = new IntPtr((byte*)imageBase + *(uint*)(p + 12));  					sectionSize = Math.Max(*(uint*)(p + 8)' *(uint*)(p + 16));  					return true;  				}
Magic Number,Confuser.Runtime,PEInfo,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\PEInfo.cs,FindSection,The following statement contains a magic number: for (int i = 0; i < numSects; i++) {  					byte* p = (byte*)sectionsAddr + i * 0x28;  					if (!CompareSectionName(p' nameBytes))  						continue;    					sectionStart = new IntPtr((byte*)imageBase + *(uint*)(p + 12));  					sectionSize = Math.Max(*(uint*)(p + 8)' *(uint*)(p + 16));  					return true;  				}
Magic Number,Confuser.Runtime,PEInfo,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\antinet\PEInfo.cs,CompareSectionName,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  					if (*sectionName != nameBytes[i])  						return false;  					sectionName++;  				}
Magic Number,Confuser.Runtime,Compressor,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Compressor.cs,Decrypt,The following statement contains a magic number: var b = new byte[data.Length << 2];
Magic Number,Confuser.Runtime,Compressor,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Compressor.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < data.Length; i++) {  				uint d = data[i] ^ w[i & 0xf];  				w[i & 0xf] = (w[i & 0xf] ^ d) + 0x3ddb2819;  				b[h + 0] = (byte)(d >> 0);  				b[h + 1] = (byte)(d >> 8);  				b[h + 2] = (byte)(d >> 16);  				b[h + 3] = (byte)(d >> 24);  				h += 4;  			}
Magic Number,Confuser.Runtime,Compressor,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Compressor.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < data.Length; i++) {  				uint d = data[i] ^ w[i & 0xf];  				w[i & 0xf] = (w[i & 0xf] ^ d) + 0x3ddb2819;  				b[h + 0] = (byte)(d >> 0);  				b[h + 1] = (byte)(d >> 8);  				b[h + 2] = (byte)(d >> 16);  				b[h + 3] = (byte)(d >> 24);  				h += 4;  			}
Magic Number,Confuser.Runtime,Compressor,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Compressor.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < data.Length; i++) {  				uint d = data[i] ^ w[i & 0xf];  				w[i & 0xf] = (w[i & 0xf] ^ d) + 0x3ddb2819;  				b[h + 0] = (byte)(d >> 0);  				b[h + 1] = (byte)(d >> 8);  				b[h + 2] = (byte)(d >> 16);  				b[h + 3] = (byte)(d >> 24);  				h += 4;  			}
Magic Number,Confuser.Runtime,Compressor,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Compressor.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < data.Length; i++) {  				uint d = data[i] ^ w[i & 0xf];  				w[i & 0xf] = (w[i & 0xf] ^ d) + 0x3ddb2819;  				b[h + 0] = (byte)(d >> 0);  				b[h + 1] = (byte)(d >> 8);  				b[h + 2] = (byte)(d >> 16);  				b[h + 3] = (byte)(d >> 24);  				h += 4;  			}
Magic Number,Confuser.Runtime,Compressor,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Compressor.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < data.Length; i++) {  				uint d = data[i] ^ w[i & 0xf];  				w[i & 0xf] = (w[i & 0xf] ^ d) + 0x3ddb2819;  				b[h + 0] = (byte)(d >> 0);  				b[h + 1] = (byte)(d >> 8);  				b[h + 2] = (byte)(d >> 16);  				b[h + 3] = (byte)(d >> 24);  				h += 4;  			}
Magic Number,Confuser.Runtime,Compressor,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Compressor.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < data.Length; i++) {  				uint d = data[i] ^ w[i & 0xf];  				w[i & 0xf] = (w[i & 0xf] ^ d) + 0x3ddb2819;  				b[h + 0] = (byte)(d >> 0);  				b[h + 1] = (byte)(d >> 8);  				b[h + 2] = (byte)(d >> 16);  				b[h + 3] = (byte)(d >> 24);  				h += 4;  			}
Magic Number,Confuser.Runtime,Compressor,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Compressor.cs,Main,The following statement contains a magic number: MethodBase e = m.ResolveMethod(key[0] | (key[1] << 8) | (key[2] << 16) | (key[3] << 24));
Magic Number,Confuser.Runtime,Compressor,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Compressor.cs,Main,The following statement contains a magic number: MethodBase e = m.ResolveMethod(key[0] | (key[1] << 8) | (key[2] << 16) | (key[3] << 24));
Magic Number,Confuser.Runtime,Compressor,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Compressor.cs,Main,The following statement contains a magic number: MethodBase e = m.ResolveMethod(key[0] | (key[1] << 8) | (key[2] << 16) | (key[3] << 24));
Magic Number,Confuser.Runtime,Compressor,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Compressor.cs,Main,The following statement contains a magic number: MethodBase e = m.ResolveMethod(key[0] | (key[1] << 8) | (key[2] << 16) | (key[3] << 24));
Magic Number,Confuser.Runtime,Compressor,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Compressor.cs,Main,The following statement contains a magic number: MethodBase e = m.ResolveMethod(key[0] | (key[1] << 8) | (key[2] << 16) | (key[3] << 24));
Magic Number,Confuser.Runtime,Compressor,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Compressor.cs,Resolve,The following statement contains a magic number: if (b.Length + 4 <= key.Length) {  				for (int i = 0; i < b.Length; i++)  					b[i] *= key[i + 4];  				string n = Convert.ToBase64String(b);  				m = Assembly.GetEntryAssembly().GetManifestResourceStream(n);  			}
Magic Number,Confuser.Runtime,Compressor,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Compressor.cs,Resolve,The following statement contains a magic number: if (b.Length + 4 <= key.Length) {  				for (int i = 0; i < b.Length; i++)  					b[i] *= key[i + 4];  				string n = Convert.ToBase64String(b);  				m = Assembly.GetEntryAssembly().GetManifestResourceStream(n);  			}
Magic Number,Confuser.Runtime,Compressor,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Compressor.cs,Resolve,The following statement contains a magic number: if (m != null) {  				var d = new uint[m.Length >> 2];  				var t = new byte[0x100];  				int r;  				int o = 0;  				while ((r = m.Read(t' 0' 0x100)) > 0) {  					Buffer.BlockCopy(t' 0' d' o' r);  					o += r;  				}  				uint s = 0x6fff61;  				foreach (byte c in b)  					s = s * 0x5e3f1f + c;  				GCHandle h = Decrypt(d' s);    				var f = (byte[])h.Target;  				Assembly a = Assembly.Load(f);  				Array.Clear(f' 0' f.Length);  				h.Free();  				Array.Clear(d' 0' d.Length);    				return a;  			}
Magic Number,Confuser.Runtime,Constant,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Constant.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < 0x10; i++) {  				n ^= n >> 12;  				n ^= n << 25;  				n ^= n >> 27;  				k[i] = n;  			}
Magic Number,Confuser.Runtime,Constant,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Constant.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < 0x10; i++) {  				n ^= n >> 12;  				n ^= n << 25;  				n ^= n >> 27;  				k[i] = n;  			}
Magic Number,Confuser.Runtime,Constant,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Constant.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < 0x10; i++) {  				n ^= n >> 12;  				n ^= n << 25;  				n ^= n >> 27;  				k[i] = n;  			}
Magic Number,Confuser.Runtime,Constant,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Constant.cs,Initialize,The following statement contains a magic number: var o = new byte[l * 4];
Magic Number,Confuser.Runtime,Constant,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Constant.cs,Initialize,The following statement contains a magic number: while (s < l) {  				for (int j = 0; j < 0x10; j++)  					w[j] = q[s + j];  				Mutation.Crypt(w' k);  				for (int j = 0; j < 0x10; j++) {  					uint e = w[j];  					o[d++] = (byte)e;  					o[d++] = (byte)(e >> 8);  					o[d++] = (byte)(e >> 16);  					o[d++] = (byte)(e >> 24);  					k[j] ^= e;  				}  				s += 0x10;  			}
Magic Number,Confuser.Runtime,Constant,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Constant.cs,Initialize,The following statement contains a magic number: while (s < l) {  				for (int j = 0; j < 0x10; j++)  					w[j] = q[s + j];  				Mutation.Crypt(w' k);  				for (int j = 0; j < 0x10; j++) {  					uint e = w[j];  					o[d++] = (byte)e;  					o[d++] = (byte)(e >> 8);  					o[d++] = (byte)(e >> 16);  					o[d++] = (byte)(e >> 24);  					k[j] ^= e;  				}  				s += 0x10;  			}
Magic Number,Confuser.Runtime,Constant,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Constant.cs,Initialize,The following statement contains a magic number: while (s < l) {  				for (int j = 0; j < 0x10; j++)  					w[j] = q[s + j];  				Mutation.Crypt(w' k);  				for (int j = 0; j < 0x10; j++) {  					uint e = w[j];  					o[d++] = (byte)e;  					o[d++] = (byte)(e >> 8);  					o[d++] = (byte)(e >> 16);  					o[d++] = (byte)(e >> 24);  					k[j] ^= e;  				}  				s += 0x10;  			}
Magic Number,Confuser.Runtime,Constant,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Constant.cs,Get,The following statement contains a magic number: uint t = id >> 30;
Magic Number,Confuser.Runtime,Constant,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Constant.cs,Get,The following statement contains a magic number: id <<= 2;
Magic Number,Confuser.Runtime,Constant,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Constant.cs,Get,The following statement contains a magic number: if (t == Mutation.KeyI0) {  				int l = b[id++] | (b[id++] << 8) | (b[id++] << 16) | (b[id++] << 24);  				ret = (T)(object)string.Intern(Encoding.UTF8.GetString(b' (int)id' l));  			}  			// NOTE: Assume little-endian  			else if (t == Mutation.KeyI1) {  				var v = new T[1];  				Buffer.BlockCopy(b' (int)id' v' 0' Mutation.Value<int>());  				ret = v[0];  			}  			else if (t == Mutation.KeyI2) {  				int s = b[id++] | (b[id++] << 8) | (b[id++] << 16) | (b[id++] << 24);  				int l = b[id++] | (b[id++] << 8) | (b[id++] << 16) | (b[id++] << 24);  				Array v = Array.CreateInstance(typeof(T).GetElementType()' l);  				Buffer.BlockCopy(b' (int)id' v' 0' s - 4);  				ret = (T)(object)v;  			}
Magic Number,Confuser.Runtime,Constant,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Constant.cs,Get,The following statement contains a magic number: if (t == Mutation.KeyI0) {  				int l = b[id++] | (b[id++] << 8) | (b[id++] << 16) | (b[id++] << 24);  				ret = (T)(object)string.Intern(Encoding.UTF8.GetString(b' (int)id' l));  			}  			// NOTE: Assume little-endian  			else if (t == Mutation.KeyI1) {  				var v = new T[1];  				Buffer.BlockCopy(b' (int)id' v' 0' Mutation.Value<int>());  				ret = v[0];  			}  			else if (t == Mutation.KeyI2) {  				int s = b[id++] | (b[id++] << 8) | (b[id++] << 16) | (b[id++] << 24);  				int l = b[id++] | (b[id++] << 8) | (b[id++] << 16) | (b[id++] << 24);  				Array v = Array.CreateInstance(typeof(T).GetElementType()' l);  				Buffer.BlockCopy(b' (int)id' v' 0' s - 4);  				ret = (T)(object)v;  			}
Magic Number,Confuser.Runtime,Constant,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Constant.cs,Get,The following statement contains a magic number: if (t == Mutation.KeyI0) {  				int l = b[id++] | (b[id++] << 8) | (b[id++] << 16) | (b[id++] << 24);  				ret = (T)(object)string.Intern(Encoding.UTF8.GetString(b' (int)id' l));  			}  			// NOTE: Assume little-endian  			else if (t == Mutation.KeyI1) {  				var v = new T[1];  				Buffer.BlockCopy(b' (int)id' v' 0' Mutation.Value<int>());  				ret = v[0];  			}  			else if (t == Mutation.KeyI2) {  				int s = b[id++] | (b[id++] << 8) | (b[id++] << 16) | (b[id++] << 24);  				int l = b[id++] | (b[id++] << 8) | (b[id++] << 16) | (b[id++] << 24);  				Array v = Array.CreateInstance(typeof(T).GetElementType()' l);  				Buffer.BlockCopy(b' (int)id' v' 0' s - 4);  				ret = (T)(object)v;  			}
Magic Number,Confuser.Runtime,Constant,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Constant.cs,Get,The following statement contains a magic number: if (t == Mutation.KeyI0) {  				int l = b[id++] | (b[id++] << 8) | (b[id++] << 16) | (b[id++] << 24);  				ret = (T)(object)string.Intern(Encoding.UTF8.GetString(b' (int)id' l));  			}  			// NOTE: Assume little-endian  			else if (t == Mutation.KeyI1) {  				var v = new T[1];  				Buffer.BlockCopy(b' (int)id' v' 0' Mutation.Value<int>());  				ret = v[0];  			}  			else if (t == Mutation.KeyI2) {  				int s = b[id++] | (b[id++] << 8) | (b[id++] << 16) | (b[id++] << 24);  				int l = b[id++] | (b[id++] << 8) | (b[id++] << 16) | (b[id++] << 24);  				Array v = Array.CreateInstance(typeof(T).GetElementType()' l);  				Buffer.BlockCopy(b' (int)id' v' 0' s - 4);  				ret = (T)(object)v;  			}
Magic Number,Confuser.Runtime,Constant,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Constant.cs,Get,The following statement contains a magic number: if (t == Mutation.KeyI0) {  				int l = b[id++] | (b[id++] << 8) | (b[id++] << 16) | (b[id++] << 24);  				ret = (T)(object)string.Intern(Encoding.UTF8.GetString(b' (int)id' l));  			}  			// NOTE: Assume little-endian  			else if (t == Mutation.KeyI1) {  				var v = new T[1];  				Buffer.BlockCopy(b' (int)id' v' 0' Mutation.Value<int>());  				ret = v[0];  			}  			else if (t == Mutation.KeyI2) {  				int s = b[id++] | (b[id++] << 8) | (b[id++] << 16) | (b[id++] << 24);  				int l = b[id++] | (b[id++] << 8) | (b[id++] << 16) | (b[id++] << 24);  				Array v = Array.CreateInstance(typeof(T).GetElementType()' l);  				Buffer.BlockCopy(b' (int)id' v' 0' s - 4);  				ret = (T)(object)v;  			}
Magic Number,Confuser.Runtime,Constant,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Constant.cs,Get,The following statement contains a magic number: if (t == Mutation.KeyI0) {  				int l = b[id++] | (b[id++] << 8) | (b[id++] << 16) | (b[id++] << 24);  				ret = (T)(object)string.Intern(Encoding.UTF8.GetString(b' (int)id' l));  			}  			// NOTE: Assume little-endian  			else if (t == Mutation.KeyI1) {  				var v = new T[1];  				Buffer.BlockCopy(b' (int)id' v' 0' Mutation.Value<int>());  				ret = v[0];  			}  			else if (t == Mutation.KeyI2) {  				int s = b[id++] | (b[id++] << 8) | (b[id++] << 16) | (b[id++] << 24);  				int l = b[id++] | (b[id++] << 8) | (b[id++] << 16) | (b[id++] << 24);  				Array v = Array.CreateInstance(typeof(T).GetElementType()' l);  				Buffer.BlockCopy(b' (int)id' v' 0' s - 4);  				ret = (T)(object)v;  			}
Magic Number,Confuser.Runtime,Constant,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Constant.cs,Get,The following statement contains a magic number: if (t == Mutation.KeyI0) {  				int l = b[id++] | (b[id++] << 8) | (b[id++] << 16) | (b[id++] << 24);  				ret = (T)(object)string.Intern(Encoding.UTF8.GetString(b' (int)id' l));  			}  			// NOTE: Assume little-endian  			else if (t == Mutation.KeyI1) {  				var v = new T[1];  				Buffer.BlockCopy(b' (int)id' v' 0' Mutation.Value<int>());  				ret = v[0];  			}  			else if (t == Mutation.KeyI2) {  				int s = b[id++] | (b[id++] << 8) | (b[id++] << 16) | (b[id++] << 24);  				int l = b[id++] | (b[id++] << 8) | (b[id++] << 16) | (b[id++] << 24);  				Array v = Array.CreateInstance(typeof(T).GetElementType()' l);  				Buffer.BlockCopy(b' (int)id' v' 0' s - 4);  				ret = (T)(object)v;  			}
Magic Number,Confuser.Runtime,Constant,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Constant.cs,Get,The following statement contains a magic number: if (t == Mutation.KeyI0) {  				int l = b[id++] | (b[id++] << 8) | (b[id++] << 16) | (b[id++] << 24);  				ret = (T)(object)string.Intern(Encoding.UTF8.GetString(b' (int)id' l));  			}  			// NOTE: Assume little-endian  			else if (t == Mutation.KeyI1) {  				var v = new T[1];  				Buffer.BlockCopy(b' (int)id' v' 0' Mutation.Value<int>());  				ret = v[0];  			}  			else if (t == Mutation.KeyI2) {  				int s = b[id++] | (b[id++] << 8) | (b[id++] << 16) | (b[id++] << 24);  				int l = b[id++] | (b[id++] << 8) | (b[id++] << 16) | (b[id++] << 24);  				Array v = Array.CreateInstance(typeof(T).GetElementType()' l);  				Buffer.BlockCopy(b' (int)id' v' 0' s - 4);  				ret = (T)(object)v;  			}
Magic Number,Confuser.Runtime,Constant,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Constant.cs,Get,The following statement contains a magic number: if (t == Mutation.KeyI0) {  				int l = b[id++] | (b[id++] << 8) | (b[id++] << 16) | (b[id++] << 24);  				ret = (T)(object)string.Intern(Encoding.UTF8.GetString(b' (int)id' l));  			}  			// NOTE: Assume little-endian  			else if (t == Mutation.KeyI1) {  				var v = new T[1];  				Buffer.BlockCopy(b' (int)id' v' 0' Mutation.Value<int>());  				ret = v[0];  			}  			else if (t == Mutation.KeyI2) {  				int s = b[id++] | (b[id++] << 8) | (b[id++] << 16) | (b[id++] << 24);  				int l = b[id++] | (b[id++] << 8) | (b[id++] << 16) | (b[id++] << 24);  				Array v = Array.CreateInstance(typeof(T).GetElementType()' l);  				Buffer.BlockCopy(b' (int)id' v' 0' s - 4);  				ret = (T)(object)v;  			}
Magic Number,Confuser.Runtime,Constant,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Constant.cs,Get,The following statement contains a magic number: if (t == Mutation.KeyI0) {  				int l = b[id++] | (b[id++] << 8) | (b[id++] << 16) | (b[id++] << 24);  				ret = (T)(object)string.Intern(Encoding.UTF8.GetString(b' (int)id' l));  			}  			// NOTE: Assume little-endian  			else if (t == Mutation.KeyI1) {  				var v = new T[1];  				Buffer.BlockCopy(b' (int)id' v' 0' Mutation.Value<int>());  				ret = v[0];  			}  			else if (t == Mutation.KeyI2) {  				int s = b[id++] | (b[id++] << 8) | (b[id++] << 16) | (b[id++] << 24);  				int l = b[id++] | (b[id++] << 8) | (b[id++] << 16) | (b[id++] << 24);  				Array v = Array.CreateInstance(typeof(T).GetElementType()' l);  				Buffer.BlockCopy(b' (int)id' v' 0' s - 4);  				ret = (T)(object)v;  			}
Magic Number,Confuser.Runtime,CFGCtx,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Constant.cs,Next,The following statement contains a magic number: if ((f & 0x80) != 0) {  				switch (f & 0x3) {  					case 0:  						A = q;  						break;  					case 1:  						B = q;  						break;  					case 2:  						C = q;  						break;  					case 3:  						D = q;  						break;  				}  			}  			else {  				switch (f & 0x3) {  					case 0:  						A ^= q;  						break;  					case 1:  						B += q;  						break;  					case 2:  						C ^= q;  						break;  					case 3:  						D -= q;  						break;  				}  			}
Magic Number,Confuser.Runtime,CFGCtx,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Constant.cs,Next,The following statement contains a magic number: if ((f & 0x80) != 0) {  				switch (f & 0x3) {  					case 0:  						A = q;  						break;  					case 1:  						B = q;  						break;  					case 2:  						C = q;  						break;  					case 3:  						D = q;  						break;  				}  			}  			else {  				switch (f & 0x3) {  					case 0:  						A ^= q;  						break;  					case 1:  						B += q;  						break;  					case 2:  						C ^= q;  						break;  					case 3:  						D -= q;  						break;  				}  			}
Magic Number,Confuser.Runtime,CFGCtx,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Constant.cs,Next,The following statement contains a magic number: if ((f & 0x80) != 0) {  				switch (f & 0x3) {  					case 0:  						A = q;  						break;  					case 1:  						B = q;  						break;  					case 2:  						C = q;  						break;  					case 3:  						D = q;  						break;  				}  			}  			else {  				switch (f & 0x3) {  					case 0:  						A ^= q;  						break;  					case 1:  						B += q;  						break;  					case 2:  						C ^= q;  						break;  					case 3:  						D -= q;  						break;  				}  			}
Magic Number,Confuser.Runtime,CFGCtx,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Constant.cs,Next,The following statement contains a magic number: if ((f & 0x80) != 0) {  				switch (f & 0x3) {  					case 0:  						A = q;  						break;  					case 1:  						B = q;  						break;  					case 2:  						C = q;  						break;  					case 3:  						D = q;  						break;  				}  			}  			else {  				switch (f & 0x3) {  					case 0:  						A ^= q;  						break;  					case 1:  						B += q;  						break;  					case 2:  						C ^= q;  						break;  					case 3:  						D -= q;  						break;  				}  			}
Magic Number,Confuser.Runtime,CFGCtx,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Constant.cs,Next,The following statement contains a magic number: switch ((f >> 2) & 0x3) {  				case 0:  					return A;  				case 1:  					return B;  				case 2:  					return C;  			}
Magic Number,Confuser.Runtime,CFGCtx,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Constant.cs,Next,The following statement contains a magic number: switch ((f >> 2) & 0x3) {  				case 0:  					return A;  				case 1:  					return B;  				case 2:  					return C;  			}
Magic Number,Confuser.Runtime,AntiTamperJIT,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiTamper.JIT.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < s; i++) {  				uint g = (*r++) * (*r++);  				if (g == (uint)Mutation.KeyI0) {  					e = (uint*)(b + (f ? *(r + 3) : *(r + 1)));  					l = (f ? *(r + 2) : *(r + 0)) >> 2;  				}  				else if (g != 0) {  					var q = (uint*)(b + (f ? *(r + 3) : *(r + 1)));  					uint j = *(r + 2) >> 2;  					for (uint k = 0; k < j; k++) {  						uint t = (z ^ (*q++)) + x + c * v;  						z = x;  						x = c;  						x = v;  						v = t;  					}  				}  				r += 8;  			}
Magic Number,Confuser.Runtime,AntiTamperJIT,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiTamper.JIT.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < s; i++) {  				uint g = (*r++) * (*r++);  				if (g == (uint)Mutation.KeyI0) {  					e = (uint*)(b + (f ? *(r + 3) : *(r + 1)));  					l = (f ? *(r + 2) : *(r + 0)) >> 2;  				}  				else if (g != 0) {  					var q = (uint*)(b + (f ? *(r + 3) : *(r + 1)));  					uint j = *(r + 2) >> 2;  					for (uint k = 0; k < j; k++) {  						uint t = (z ^ (*q++)) + x + c * v;  						z = x;  						x = c;  						x = v;  						v = t;  					}  				}  				r += 8;  			}
Magic Number,Confuser.Runtime,AntiTamperJIT,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiTamper.JIT.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < s; i++) {  				uint g = (*r++) * (*r++);  				if (g == (uint)Mutation.KeyI0) {  					e = (uint*)(b + (f ? *(r + 3) : *(r + 1)));  					l = (f ? *(r + 2) : *(r + 0)) >> 2;  				}  				else if (g != 0) {  					var q = (uint*)(b + (f ? *(r + 3) : *(r + 1)));  					uint j = *(r + 2) >> 2;  					for (uint k = 0; k < j; k++) {  						uint t = (z ^ (*q++)) + x + c * v;  						z = x;  						x = c;  						x = v;  						v = t;  					}  				}  				r += 8;  			}
Magic Number,Confuser.Runtime,AntiTamperJIT,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiTamper.JIT.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < s; i++) {  				uint g = (*r++) * (*r++);  				if (g == (uint)Mutation.KeyI0) {  					e = (uint*)(b + (f ? *(r + 3) : *(r + 1)));  					l = (f ? *(r + 2) : *(r + 0)) >> 2;  				}  				else if (g != 0) {  					var q = (uint*)(b + (f ? *(r + 3) : *(r + 1)));  					uint j = *(r + 2) >> 2;  					for (uint k = 0; k < j; k++) {  						uint t = (z ^ (*q++)) + x + c * v;  						z = x;  						x = c;  						x = v;  						v = t;  					}  				}  				r += 8;  			}
Magic Number,Confuser.Runtime,AntiTamperJIT,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiTamper.JIT.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < s; i++) {  				uint g = (*r++) * (*r++);  				if (g == (uint)Mutation.KeyI0) {  					e = (uint*)(b + (f ? *(r + 3) : *(r + 1)));  					l = (f ? *(r + 2) : *(r + 0)) >> 2;  				}  				else if (g != 0) {  					var q = (uint*)(b + (f ? *(r + 3) : *(r + 1)));  					uint j = *(r + 2) >> 2;  					for (uint k = 0; k < j; k++) {  						uint t = (z ^ (*q++)) + x + c * v;  						z = x;  						x = c;  						x = v;  						v = t;  					}  				}  				r += 8;  			}
Magic Number,Confuser.Runtime,AntiTamperJIT,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiTamper.JIT.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < s; i++) {  				uint g = (*r++) * (*r++);  				if (g == (uint)Mutation.KeyI0) {  					e = (uint*)(b + (f ? *(r + 3) : *(r + 1)));  					l = (f ? *(r + 2) : *(r + 0)) >> 2;  				}  				else if (g != 0) {  					var q = (uint*)(b + (f ? *(r + 3) : *(r + 1)));  					uint j = *(r + 2) >> 2;  					for (uint k = 0; k < j; k++) {  						uint t = (z ^ (*q++)) + x + c * v;  						z = x;  						x = c;  						x = v;  						v = t;  					}  				}  				r += 8;  			}
Magic Number,Confuser.Runtime,AntiTamperJIT,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiTamper.JIT.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < s; i++) {  				uint g = (*r++) * (*r++);  				if (g == (uint)Mutation.KeyI0) {  					e = (uint*)(b + (f ? *(r + 3) : *(r + 1)));  					l = (f ? *(r + 2) : *(r + 0)) >> 2;  				}  				else if (g != 0) {  					var q = (uint*)(b + (f ? *(r + 3) : *(r + 1)));  					uint j = *(r + 2) >> 2;  					for (uint k = 0; k < j; k++) {  						uint t = (z ^ (*q++)) + x + c * v;  						z = x;  						x = c;  						x = v;  						v = t;  					}  				}  				r += 8;  			}
Magic Number,Confuser.Runtime,AntiTamperJIT,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiTamper.JIT.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < 0x10; i++) {  				y[i] = v;  				d[i] = x;  				z = (x >> 5) | (x << 27);  				x = (c >> 3) | (c << 29);  				c = (v >> 7) | (v << 25);  				v = (z >> 11) | (z << 21);  			}
Magic Number,Confuser.Runtime,AntiTamperJIT,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiTamper.JIT.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < 0x10; i++) {  				y[i] = v;  				d[i] = x;  				z = (x >> 5) | (x << 27);  				x = (c >> 3) | (c << 29);  				c = (v >> 7) | (v << 25);  				v = (z >> 11) | (z << 21);  			}
Magic Number,Confuser.Runtime,AntiTamperJIT,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiTamper.JIT.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < 0x10; i++) {  				y[i] = v;  				d[i] = x;  				z = (x >> 5) | (x << 27);  				x = (c >> 3) | (c << 29);  				c = (v >> 7) | (v << 25);  				v = (z >> 11) | (z << 21);  			}
Magic Number,Confuser.Runtime,AntiTamperJIT,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiTamper.JIT.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < 0x10; i++) {  				y[i] = v;  				d[i] = x;  				z = (x >> 5) | (x << 27);  				x = (c >> 3) | (c << 29);  				c = (v >> 7) | (v << 25);  				v = (z >> 11) | (z << 21);  			}
Magic Number,Confuser.Runtime,AntiTamperJIT,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiTamper.JIT.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < 0x10; i++) {  				y[i] = v;  				d[i] = x;  				z = (x >> 5) | (x << 27);  				x = (c >> 3) | (c << 29);  				c = (v >> 7) | (v << 25);  				v = (z >> 11) | (z << 21);  			}
Magic Number,Confuser.Runtime,AntiTamperJIT,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiTamper.JIT.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < 0x10; i++) {  				y[i] = v;  				d[i] = x;  				z = (x >> 5) | (x << 27);  				x = (c >> 3) | (c << 29);  				c = (v >> 7) | (v << 25);  				v = (z >> 11) | (z << 21);  			}
Magic Number,Confuser.Runtime,AntiTamperJIT,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiTamper.JIT.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < 0x10; i++) {  				y[i] = v;  				d[i] = x;  				z = (x >> 5) | (x << 27);  				x = (c >> 3) | (c << 29);  				c = (v >> 7) | (v << 25);  				v = (z >> 11) | (z << 21);  			}
Magic Number,Confuser.Runtime,AntiTamperJIT,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiTamper.JIT.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < 0x10; i++) {  				y[i] = v;  				d[i] = x;  				z = (x >> 5) | (x << 27);  				x = (c >> 3) | (c << 29);  				c = (v >> 7) | (v << 25);  				v = (z >> 11) | (z << 21);  			}
Magic Number,Confuser.Runtime,AntiTamperJIT,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiTamper.JIT.cs,Initialize,The following statement contains a magic number: VirtualProtect((IntPtr)e' l << 2' 0x40' out z);
Magic Number,Confuser.Runtime,AntiTamperJIT,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiTamper.JIT.cs,Initialize,The following statement contains a magic number: ptr = u + 4;
Magic Number,Confuser.Runtime,AntiTamperJIT,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiTamper.JIT.cs,Initialize,The following statement contains a magic number: ver4 = Environment.Version.Major == 4;
Magic Number,Confuser.Runtime,AntiTamperJIT,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiTamper.JIT.cs,Initialize,The following statement contains a magic number: if (ver4) {  				ulong* str = stackalloc ulong[1];  				str[0] = 0x0061746144705f6d; //m_pData.  				moduleHnd = (IntPtr)m.GetType().GetField(new string((sbyte*)str)' BindingFlags.NonPublic | BindingFlags.Instance).GetValue(m);  				ver5 = Environment.Version.Revision > 17020;  			}  			else  				moduleHnd = *(IntPtr*)(&hnd);
Magic Number,Confuser.Runtime,AntiTamperJIT,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiTamper.JIT.cs,Hook,The following statement contains a magic number: ulong* ptr = stackalloc ulong[2];
Magic Number,Confuser.Runtime,AntiTamperJIT,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiTamper.JIT.cs,Hook,The following statement contains a magic number: if (IntPtr.Size == 8) {  				trampoline = Marshal.AllocHGlobal(16);  				var tptr = (ulong*)trampoline;  				tptr[0] = 0xffffffffffffb848;  				tptr[1] = 0x90909090e0ffffff;    				VirtualProtect(trampoline' 12' 0x40' out oldPl);  				Marshal.WriteIntPtr(trampoline' 2' original);  			}  			else {  				trampoline = Marshal.AllocHGlobal(8);  				var tptr = (ulong*)trampoline;  				tptr[0] = 0x90e0ffffffffffb8;    				VirtualProtect(trampoline' 7' 0x40' out oldPl);  				Marshal.WriteIntPtr(trampoline' 1' original);  			}
Magic Number,Confuser.Runtime,AntiTamperJIT,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiTamper.JIT.cs,Hook,The following statement contains a magic number: if (IntPtr.Size == 8) {  				trampoline = Marshal.AllocHGlobal(16);  				var tptr = (ulong*)trampoline;  				tptr[0] = 0xffffffffffffb848;  				tptr[1] = 0x90909090e0ffffff;    				VirtualProtect(trampoline' 12' 0x40' out oldPl);  				Marshal.WriteIntPtr(trampoline' 2' original);  			}  			else {  				trampoline = Marshal.AllocHGlobal(8);  				var tptr = (ulong*)trampoline;  				tptr[0] = 0x90e0ffffffffffb8;    				VirtualProtect(trampoline' 7' 0x40' out oldPl);  				Marshal.WriteIntPtr(trampoline' 1' original);  			}
Magic Number,Confuser.Runtime,AntiTamperJIT,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiTamper.JIT.cs,Hook,The following statement contains a magic number: if (IntPtr.Size == 8) {  				trampoline = Marshal.AllocHGlobal(16);  				var tptr = (ulong*)trampoline;  				tptr[0] = 0xffffffffffffb848;  				tptr[1] = 0x90909090e0ffffff;    				VirtualProtect(trampoline' 12' 0x40' out oldPl);  				Marshal.WriteIntPtr(trampoline' 2' original);  			}  			else {  				trampoline = Marshal.AllocHGlobal(8);  				var tptr = (ulong*)trampoline;  				tptr[0] = 0x90e0ffffffffffb8;    				VirtualProtect(trampoline' 7' 0x40' out oldPl);  				Marshal.WriteIntPtr(trampoline' 1' original);  			}
Magic Number,Confuser.Runtime,AntiTamperJIT,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiTamper.JIT.cs,Hook,The following statement contains a magic number: if (IntPtr.Size == 8) {  				trampoline = Marshal.AllocHGlobal(16);  				var tptr = (ulong*)trampoline;  				tptr[0] = 0xffffffffffffb848;  				tptr[1] = 0x90909090e0ffffff;    				VirtualProtect(trampoline' 12' 0x40' out oldPl);  				Marshal.WriteIntPtr(trampoline' 2' original);  			}  			else {  				trampoline = Marshal.AllocHGlobal(8);  				var tptr = (ulong*)trampoline;  				tptr[0] = 0x90e0ffffffffffb8;    				VirtualProtect(trampoline' 7' 0x40' out oldPl);  				Marshal.WriteIntPtr(trampoline' 1' original);  			}
Magic Number,Confuser.Runtime,AntiTamperJIT,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiTamper.JIT.cs,Hook,The following statement contains a magic number: if (IntPtr.Size == 8) {  				trampoline = Marshal.AllocHGlobal(16);  				var tptr = (ulong*)trampoline;  				tptr[0] = 0xffffffffffffb848;  				tptr[1] = 0x90909090e0ffffff;    				VirtualProtect(trampoline' 12' 0x40' out oldPl);  				Marshal.WriteIntPtr(trampoline' 2' original);  			}  			else {  				trampoline = Marshal.AllocHGlobal(8);  				var tptr = (ulong*)trampoline;  				tptr[0] = 0x90e0ffffffffffb8;    				VirtualProtect(trampoline' 7' 0x40' out oldPl);  				Marshal.WriteIntPtr(trampoline' 1' original);  			}
Magic Number,Confuser.Runtime,AntiTamperJIT,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiTamper.JIT.cs,Hook,The following statement contains a magic number: if (IntPtr.Size == 8) {  				trampoline = Marshal.AllocHGlobal(16);  				var tptr = (ulong*)trampoline;  				tptr[0] = 0xffffffffffffb848;  				tptr[1] = 0x90909090e0ffffff;    				VirtualProtect(trampoline' 12' 0x40' out oldPl);  				Marshal.WriteIntPtr(trampoline' 2' original);  			}  			else {  				trampoline = Marshal.AllocHGlobal(8);  				var tptr = (ulong*)trampoline;  				tptr[0] = 0x90e0ffffffffffb8;    				VirtualProtect(trampoline' 7' 0x40' out oldPl);  				Marshal.WriteIntPtr(trampoline' 1' original);  			}
Magic Number,Confuser.Runtime,AntiTamperJIT,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiTamper.JIT.cs,ExtractLocalVars,The following statement contains a magic number: if (ver4) {  				if (IntPtr.Size == 8)  					sigInfo = (CORINFO_SIG_INFO_x64*)((uint*)(info + 1) + (ver5 ? 7 : 5)) + 1;  				else  					sigInfo = (CORINFO_SIG_INFO_x86*)((uint*)(info + 1) + (ver5 ? 5 : 4)) + 1;  			}  			else {  				if (IntPtr.Size == 8)  					sigInfo = (CORINFO_SIG_INFO_x64*)((uint*)(info + 1) + 3) + 1;  				else  					sigInfo = (CORINFO_SIG_INFO_x86*)((uint*)(info + 1) + 3) + 1;  			}
Magic Number,Confuser.Runtime,AntiTamperJIT,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiTamper.JIT.cs,ExtractLocalVars,The following statement contains a magic number: if (ver4) {  				if (IntPtr.Size == 8)  					sigInfo = (CORINFO_SIG_INFO_x64*)((uint*)(info + 1) + (ver5 ? 7 : 5)) + 1;  				else  					sigInfo = (CORINFO_SIG_INFO_x86*)((uint*)(info + 1) + (ver5 ? 5 : 4)) + 1;  			}  			else {  				if (IntPtr.Size == 8)  					sigInfo = (CORINFO_SIG_INFO_x64*)((uint*)(info + 1) + 3) + 1;  				else  					sigInfo = (CORINFO_SIG_INFO_x86*)((uint*)(info + 1) + 3) + 1;  			}
Magic Number,Confuser.Runtime,AntiTamperJIT,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiTamper.JIT.cs,ExtractLocalVars,The following statement contains a magic number: if (ver4) {  				if (IntPtr.Size == 8)  					sigInfo = (CORINFO_SIG_INFO_x64*)((uint*)(info + 1) + (ver5 ? 7 : 5)) + 1;  				else  					sigInfo = (CORINFO_SIG_INFO_x86*)((uint*)(info + 1) + (ver5 ? 5 : 4)) + 1;  			}  			else {  				if (IntPtr.Size == 8)  					sigInfo = (CORINFO_SIG_INFO_x64*)((uint*)(info + 1) + 3) + 1;  				else  					sigInfo = (CORINFO_SIG_INFO_x86*)((uint*)(info + 1) + 3) + 1;  			}
Magic Number,Confuser.Runtime,AntiTamperJIT,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiTamper.JIT.cs,ExtractLocalVars,The following statement contains a magic number: if (ver4) {  				if (IntPtr.Size == 8)  					sigInfo = (CORINFO_SIG_INFO_x64*)((uint*)(info + 1) + (ver5 ? 7 : 5)) + 1;  				else  					sigInfo = (CORINFO_SIG_INFO_x86*)((uint*)(info + 1) + (ver5 ? 5 : 4)) + 1;  			}  			else {  				if (IntPtr.Size == 8)  					sigInfo = (CORINFO_SIG_INFO_x64*)((uint*)(info + 1) + 3) + 1;  				else  					sigInfo = (CORINFO_SIG_INFO_x86*)((uint*)(info + 1) + 3) + 1;  			}
Magic Number,Confuser.Runtime,AntiTamperJIT,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiTamper.JIT.cs,ExtractLocalVars,The following statement contains a magic number: if (ver4) {  				if (IntPtr.Size == 8)  					sigInfo = (CORINFO_SIG_INFO_x64*)((uint*)(info + 1) + (ver5 ? 7 : 5)) + 1;  				else  					sigInfo = (CORINFO_SIG_INFO_x86*)((uint*)(info + 1) + (ver5 ? 5 : 4)) + 1;  			}  			else {  				if (IntPtr.Size == 8)  					sigInfo = (CORINFO_SIG_INFO_x64*)((uint*)(info + 1) + 3) + 1;  				else  					sigInfo = (CORINFO_SIG_INFO_x86*)((uint*)(info + 1) + 3) + 1;  			}
Magic Number,Confuser.Runtime,AntiTamperJIT,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiTamper.JIT.cs,ExtractLocalVars,The following statement contains a magic number: if (ver4) {  				if (IntPtr.Size == 8)  					sigInfo = (CORINFO_SIG_INFO_x64*)((uint*)(info + 1) + (ver5 ? 7 : 5)) + 1;  				else  					sigInfo = (CORINFO_SIG_INFO_x86*)((uint*)(info + 1) + (ver5 ? 5 : 4)) + 1;  			}  			else {  				if (IntPtr.Size == 8)  					sigInfo = (CORINFO_SIG_INFO_x64*)((uint*)(info + 1) + 3) + 1;  				else  					sigInfo = (CORINFO_SIG_INFO_x86*)((uint*)(info + 1) + 3) + 1;  			}
Magic Number,Confuser.Runtime,AntiTamperJIT,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiTamper.JIT.cs,ExtractLocalVars,The following statement contains a magic number: if (ver4) {  				if (IntPtr.Size == 8)  					sigInfo = (CORINFO_SIG_INFO_x64*)((uint*)(info + 1) + (ver5 ? 7 : 5)) + 1;  				else  					sigInfo = (CORINFO_SIG_INFO_x86*)((uint*)(info + 1) + (ver5 ? 5 : 4)) + 1;  			}  			else {  				if (IntPtr.Size == 8)  					sigInfo = (CORINFO_SIG_INFO_x64*)((uint*)(info + 1) + 3) + 1;  				else  					sigInfo = (CORINFO_SIG_INFO_x86*)((uint*)(info + 1) + 3) + 1;  			}
Magic Number,Confuser.Runtime,AntiTamperJIT,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiTamper.JIT.cs,ExtractLocalVars,The following statement contains a magic number: if (ver4) {  				if (IntPtr.Size == 8)  					sigInfo = (CORINFO_SIG_INFO_x64*)((uint*)(info + 1) + (ver5 ? 7 : 5)) + 1;  				else  					sigInfo = (CORINFO_SIG_INFO_x86*)((uint*)(info + 1) + (ver5 ? 5 : 4)) + 1;  			}  			else {  				if (IntPtr.Size == 8)  					sigInfo = (CORINFO_SIG_INFO_x64*)((uint*)(info + 1) + 3) + 1;  				else  					sigInfo = (CORINFO_SIG_INFO_x86*)((uint*)(info + 1) + 3) + 1;  			}
Magic Number,Confuser.Runtime,AntiTamperJIT,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiTamper.JIT.cs,ExtractLocalVars,The following statement contains a magic number: if (IntPtr.Size == 8)  				((CORINFO_SIG_INFO_x64*)sigInfo)->sig = (IntPtr)localVar;  			else  				((CORINFO_SIG_INFO_x86*)sigInfo)->sig = (IntPtr)localVar;
Magic Number,Confuser.Runtime,AntiTamperJIT,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiTamper.JIT.cs,ExtractLocalVars,The following statement contains a magic number: if ((b & 0x80) == 0) {  				numArgs = b;  				args = (IntPtr)(localVar + 1);  			}  			else {  				numArgs = (ushort)(((uint)(b & ~0x80) << 8) | *(localVar + 1));  				args = (IntPtr)(localVar + 2);  			}
Magic Number,Confuser.Runtime,AntiTamperJIT,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiTamper.JIT.cs,ExtractLocalVars,The following statement contains a magic number: if ((b & 0x80) == 0) {  				numArgs = b;  				args = (IntPtr)(localVar + 1);  			}  			else {  				numArgs = (ushort)(((uint)(b & ~0x80) << 8) | *(localVar + 1));  				args = (IntPtr)(localVar + 2);  			}
Magic Number,Confuser.Runtime,AntiTamperJIT,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiTamper.JIT.cs,ExtractLocalVars,The following statement contains a magic number: if (IntPtr.Size == 8) {  				var sigInfox64 = (CORINFO_SIG_INFO_x64*)sigInfo;  				sigInfox64->callConv = 0;  				sigInfox64->retType = 1;  				sigInfox64->flags = 1;  				sigInfox64->numArgs = numArgs;  				sigInfox64->args = args;  			}  			else {  				var sigInfox86 = (CORINFO_SIG_INFO_x86*)sigInfo;  				sigInfox86->callConv = 0;  				sigInfox86->retType = 1;  				sigInfox86->flags = 1;  				sigInfox86->numArgs = numArgs;  				sigInfox86->args = args;  			}
Magic Number,Confuser.Runtime,AntiTamperJIT,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiTamper.JIT.cs,HookHandler,The following statement contains a magic number: if (info != null && info->scope == moduleHnd && info->ILCode[0] == 0x14) {  				uint token;  				if (ver5) {  					var getMethodDef = (getMethodDefFromMethod)Marshal.GetDelegateForFunctionPointer(comp->vfptr[0x64]' typeof(getMethodDefFromMethod));  					token = getMethodDef((IntPtr)comp' info->ftn);  				}  				else {  					ICorClassInfo* clsInfo = ICorStaticInfo.ICorClassInfo(ICorDynamicInfo.ICorStaticInfo(ICorJitInfo.ICorDynamicInfo(comp)));  					int gmdSlot = 12 + (ver4 ? 2 : 1);  					var getMethodDef = (getMethodDefFromMethod)Marshal.GetDelegateForFunctionPointer(clsInfo->vfptr[gmdSlot]' typeof(getMethodDefFromMethod));  					token = getMethodDef((IntPtr)clsInfo' info->ftn);  				}    				uint lo = 0' hi = len;  				uint? offset = null;  				while (hi >= lo) {  					uint mid = lo + ((hi - lo) >> 1);  					uint midTok = *(ptr + (mid << 1));  					if (midTok == token) {  						offset = *(ptr + (mid << 1) + 1);  						break;  					}  					if (midTok < token)  						lo = mid + 1;  					else  						hi = mid - 1;  				}  				if (offset == null)  					return originalDelegate(self' comp' info' flags' nativeEntry' nativeSizeOfCode);    				uint* dataPtr = ptr + (uint)offset;  				uint dataLen = *dataPtr++;  				var newPtr = (uint*)Marshal.AllocHGlobal((int)dataLen << 2);  				try {  					var data = (MethodData*)newPtr;  					uint* copyData = newPtr;    					uint state = token * (uint)Mutation.KeyI0;  					uint counter = state;  					for (uint i = 0; i < dataLen; i++) {  						*copyData = *dataPtr++ ^ state;  						state += (*copyData++) ^ counter;  						counter ^= (state >> 5) | (state << 27);  					}    					info->ILCodeSize = data->ILCodeSize;  					if (ver4) {  						*((uint*)(info + 1) + 0) = data->MaxStack;  						*((uint*)(info + 1) + 1) = data->EHCount;  						*((uint*)(info + 1) + 2) = data->Options;  					}  					else {  						*((ushort*)(info + 1) + 0) = (ushort)data->MaxStack;  						*((ushort*)(info + 1) + 1) = (ushort)data->EHCount;  						*((uint*)(info + 1) + 1) = data->Options;  					}    					var body = (byte*)(data + 1);    					info->ILCode = body;  					body += info->ILCodeSize;    					if (data->LocalVars != 0) {  						ExtractLocalVars(info' data->LocalVars' body);  						body += data->LocalVars;  					}    					var ehPtr = (CORINFO_EH_CLAUSE*)body;    					uint ret;  					if (ver5) {  						CorJitInfoHook hook = CorJitInfoHook.Hook(comp' info->ftn' ehPtr);  						ret = originalDelegate(self' comp' info' flags' nativeEntry' nativeSizeOfCode);  						hook.Dispose();  					}  					else {  						CorMethodInfoHook hook = CorMethodInfoHook.Hook(comp' info->ftn' ehPtr);  						ret = originalDelegate(self' comp' info' flags' nativeEntry' nativeSizeOfCode);  						hook.Dispose();  					}    					return ret;  				}  				finally {  					Marshal.FreeHGlobal((IntPtr)newPtr);  				}  			}
Magic Number,Confuser.Runtime,AntiTamperJIT,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiTamper.JIT.cs,HookHandler,The following statement contains a magic number: if (info != null && info->scope == moduleHnd && info->ILCode[0] == 0x14) {  				uint token;  				if (ver5) {  					var getMethodDef = (getMethodDefFromMethod)Marshal.GetDelegateForFunctionPointer(comp->vfptr[0x64]' typeof(getMethodDefFromMethod));  					token = getMethodDef((IntPtr)comp' info->ftn);  				}  				else {  					ICorClassInfo* clsInfo = ICorStaticInfo.ICorClassInfo(ICorDynamicInfo.ICorStaticInfo(ICorJitInfo.ICorDynamicInfo(comp)));  					int gmdSlot = 12 + (ver4 ? 2 : 1);  					var getMethodDef = (getMethodDefFromMethod)Marshal.GetDelegateForFunctionPointer(clsInfo->vfptr[gmdSlot]' typeof(getMethodDefFromMethod));  					token = getMethodDef((IntPtr)clsInfo' info->ftn);  				}    				uint lo = 0' hi = len;  				uint? offset = null;  				while (hi >= lo) {  					uint mid = lo + ((hi - lo) >> 1);  					uint midTok = *(ptr + (mid << 1));  					if (midTok == token) {  						offset = *(ptr + (mid << 1) + 1);  						break;  					}  					if (midTok < token)  						lo = mid + 1;  					else  						hi = mid - 1;  				}  				if (offset == null)  					return originalDelegate(self' comp' info' flags' nativeEntry' nativeSizeOfCode);    				uint* dataPtr = ptr + (uint)offset;  				uint dataLen = *dataPtr++;  				var newPtr = (uint*)Marshal.AllocHGlobal((int)dataLen << 2);  				try {  					var data = (MethodData*)newPtr;  					uint* copyData = newPtr;    					uint state = token * (uint)Mutation.KeyI0;  					uint counter = state;  					for (uint i = 0; i < dataLen; i++) {  						*copyData = *dataPtr++ ^ state;  						state += (*copyData++) ^ counter;  						counter ^= (state >> 5) | (state << 27);  					}    					info->ILCodeSize = data->ILCodeSize;  					if (ver4) {  						*((uint*)(info + 1) + 0) = data->MaxStack;  						*((uint*)(info + 1) + 1) = data->EHCount;  						*((uint*)(info + 1) + 2) = data->Options;  					}  					else {  						*((ushort*)(info + 1) + 0) = (ushort)data->MaxStack;  						*((ushort*)(info + 1) + 1) = (ushort)data->EHCount;  						*((uint*)(info + 1) + 1) = data->Options;  					}    					var body = (byte*)(data + 1);    					info->ILCode = body;  					body += info->ILCodeSize;    					if (data->LocalVars != 0) {  						ExtractLocalVars(info' data->LocalVars' body);  						body += data->LocalVars;  					}    					var ehPtr = (CORINFO_EH_CLAUSE*)body;    					uint ret;  					if (ver5) {  						CorJitInfoHook hook = CorJitInfoHook.Hook(comp' info->ftn' ehPtr);  						ret = originalDelegate(self' comp' info' flags' nativeEntry' nativeSizeOfCode);  						hook.Dispose();  					}  					else {  						CorMethodInfoHook hook = CorMethodInfoHook.Hook(comp' info->ftn' ehPtr);  						ret = originalDelegate(self' comp' info' flags' nativeEntry' nativeSizeOfCode);  						hook.Dispose();  					}    					return ret;  				}  				finally {  					Marshal.FreeHGlobal((IntPtr)newPtr);  				}  			}
Magic Number,Confuser.Runtime,AntiTamperJIT,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiTamper.JIT.cs,HookHandler,The following statement contains a magic number: if (info != null && info->scope == moduleHnd && info->ILCode[0] == 0x14) {  				uint token;  				if (ver5) {  					var getMethodDef = (getMethodDefFromMethod)Marshal.GetDelegateForFunctionPointer(comp->vfptr[0x64]' typeof(getMethodDefFromMethod));  					token = getMethodDef((IntPtr)comp' info->ftn);  				}  				else {  					ICorClassInfo* clsInfo = ICorStaticInfo.ICorClassInfo(ICorDynamicInfo.ICorStaticInfo(ICorJitInfo.ICorDynamicInfo(comp)));  					int gmdSlot = 12 + (ver4 ? 2 : 1);  					var getMethodDef = (getMethodDefFromMethod)Marshal.GetDelegateForFunctionPointer(clsInfo->vfptr[gmdSlot]' typeof(getMethodDefFromMethod));  					token = getMethodDef((IntPtr)clsInfo' info->ftn);  				}    				uint lo = 0' hi = len;  				uint? offset = null;  				while (hi >= lo) {  					uint mid = lo + ((hi - lo) >> 1);  					uint midTok = *(ptr + (mid << 1));  					if (midTok == token) {  						offset = *(ptr + (mid << 1) + 1);  						break;  					}  					if (midTok < token)  						lo = mid + 1;  					else  						hi = mid - 1;  				}  				if (offset == null)  					return originalDelegate(self' comp' info' flags' nativeEntry' nativeSizeOfCode);    				uint* dataPtr = ptr + (uint)offset;  				uint dataLen = *dataPtr++;  				var newPtr = (uint*)Marshal.AllocHGlobal((int)dataLen << 2);  				try {  					var data = (MethodData*)newPtr;  					uint* copyData = newPtr;    					uint state = token * (uint)Mutation.KeyI0;  					uint counter = state;  					for (uint i = 0; i < dataLen; i++) {  						*copyData = *dataPtr++ ^ state;  						state += (*copyData++) ^ counter;  						counter ^= (state >> 5) | (state << 27);  					}    					info->ILCodeSize = data->ILCodeSize;  					if (ver4) {  						*((uint*)(info + 1) + 0) = data->MaxStack;  						*((uint*)(info + 1) + 1) = data->EHCount;  						*((uint*)(info + 1) + 2) = data->Options;  					}  					else {  						*((ushort*)(info + 1) + 0) = (ushort)data->MaxStack;  						*((ushort*)(info + 1) + 1) = (ushort)data->EHCount;  						*((uint*)(info + 1) + 1) = data->Options;  					}    					var body = (byte*)(data + 1);    					info->ILCode = body;  					body += info->ILCodeSize;    					if (data->LocalVars != 0) {  						ExtractLocalVars(info' data->LocalVars' body);  						body += data->LocalVars;  					}    					var ehPtr = (CORINFO_EH_CLAUSE*)body;    					uint ret;  					if (ver5) {  						CorJitInfoHook hook = CorJitInfoHook.Hook(comp' info->ftn' ehPtr);  						ret = originalDelegate(self' comp' info' flags' nativeEntry' nativeSizeOfCode);  						hook.Dispose();  					}  					else {  						CorMethodInfoHook hook = CorMethodInfoHook.Hook(comp' info->ftn' ehPtr);  						ret = originalDelegate(self' comp' info' flags' nativeEntry' nativeSizeOfCode);  						hook.Dispose();  					}    					return ret;  				}  				finally {  					Marshal.FreeHGlobal((IntPtr)newPtr);  				}  			}
Magic Number,Confuser.Runtime,AntiTamperJIT,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiTamper.JIT.cs,HookHandler,The following statement contains a magic number: if (info != null && info->scope == moduleHnd && info->ILCode[0] == 0x14) {  				uint token;  				if (ver5) {  					var getMethodDef = (getMethodDefFromMethod)Marshal.GetDelegateForFunctionPointer(comp->vfptr[0x64]' typeof(getMethodDefFromMethod));  					token = getMethodDef((IntPtr)comp' info->ftn);  				}  				else {  					ICorClassInfo* clsInfo = ICorStaticInfo.ICorClassInfo(ICorDynamicInfo.ICorStaticInfo(ICorJitInfo.ICorDynamicInfo(comp)));  					int gmdSlot = 12 + (ver4 ? 2 : 1);  					var getMethodDef = (getMethodDefFromMethod)Marshal.GetDelegateForFunctionPointer(clsInfo->vfptr[gmdSlot]' typeof(getMethodDefFromMethod));  					token = getMethodDef((IntPtr)clsInfo' info->ftn);  				}    				uint lo = 0' hi = len;  				uint? offset = null;  				while (hi >= lo) {  					uint mid = lo + ((hi - lo) >> 1);  					uint midTok = *(ptr + (mid << 1));  					if (midTok == token) {  						offset = *(ptr + (mid << 1) + 1);  						break;  					}  					if (midTok < token)  						lo = mid + 1;  					else  						hi = mid - 1;  				}  				if (offset == null)  					return originalDelegate(self' comp' info' flags' nativeEntry' nativeSizeOfCode);    				uint* dataPtr = ptr + (uint)offset;  				uint dataLen = *dataPtr++;  				var newPtr = (uint*)Marshal.AllocHGlobal((int)dataLen << 2);  				try {  					var data = (MethodData*)newPtr;  					uint* copyData = newPtr;    					uint state = token * (uint)Mutation.KeyI0;  					uint counter = state;  					for (uint i = 0; i < dataLen; i++) {  						*copyData = *dataPtr++ ^ state;  						state += (*copyData++) ^ counter;  						counter ^= (state >> 5) | (state << 27);  					}    					info->ILCodeSize = data->ILCodeSize;  					if (ver4) {  						*((uint*)(info + 1) + 0) = data->MaxStack;  						*((uint*)(info + 1) + 1) = data->EHCount;  						*((uint*)(info + 1) + 2) = data->Options;  					}  					else {  						*((ushort*)(info + 1) + 0) = (ushort)data->MaxStack;  						*((ushort*)(info + 1) + 1) = (ushort)data->EHCount;  						*((uint*)(info + 1) + 1) = data->Options;  					}    					var body = (byte*)(data + 1);    					info->ILCode = body;  					body += info->ILCodeSize;    					if (data->LocalVars != 0) {  						ExtractLocalVars(info' data->LocalVars' body);  						body += data->LocalVars;  					}    					var ehPtr = (CORINFO_EH_CLAUSE*)body;    					uint ret;  					if (ver5) {  						CorJitInfoHook hook = CorJitInfoHook.Hook(comp' info->ftn' ehPtr);  						ret = originalDelegate(self' comp' info' flags' nativeEntry' nativeSizeOfCode);  						hook.Dispose();  					}  					else {  						CorMethodInfoHook hook = CorMethodInfoHook.Hook(comp' info->ftn' ehPtr);  						ret = originalDelegate(self' comp' info' flags' nativeEntry' nativeSizeOfCode);  						hook.Dispose();  					}    					return ret;  				}  				finally {  					Marshal.FreeHGlobal((IntPtr)newPtr);  				}  			}
Magic Number,Confuser.Runtime,AntiTamperJIT,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiTamper.JIT.cs,HookHandler,The following statement contains a magic number: if (info != null && info->scope == moduleHnd && info->ILCode[0] == 0x14) {  				uint token;  				if (ver5) {  					var getMethodDef = (getMethodDefFromMethod)Marshal.GetDelegateForFunctionPointer(comp->vfptr[0x64]' typeof(getMethodDefFromMethod));  					token = getMethodDef((IntPtr)comp' info->ftn);  				}  				else {  					ICorClassInfo* clsInfo = ICorStaticInfo.ICorClassInfo(ICorDynamicInfo.ICorStaticInfo(ICorJitInfo.ICorDynamicInfo(comp)));  					int gmdSlot = 12 + (ver4 ? 2 : 1);  					var getMethodDef = (getMethodDefFromMethod)Marshal.GetDelegateForFunctionPointer(clsInfo->vfptr[gmdSlot]' typeof(getMethodDefFromMethod));  					token = getMethodDef((IntPtr)clsInfo' info->ftn);  				}    				uint lo = 0' hi = len;  				uint? offset = null;  				while (hi >= lo) {  					uint mid = lo + ((hi - lo) >> 1);  					uint midTok = *(ptr + (mid << 1));  					if (midTok == token) {  						offset = *(ptr + (mid << 1) + 1);  						break;  					}  					if (midTok < token)  						lo = mid + 1;  					else  						hi = mid - 1;  				}  				if (offset == null)  					return originalDelegate(self' comp' info' flags' nativeEntry' nativeSizeOfCode);    				uint* dataPtr = ptr + (uint)offset;  				uint dataLen = *dataPtr++;  				var newPtr = (uint*)Marshal.AllocHGlobal((int)dataLen << 2);  				try {  					var data = (MethodData*)newPtr;  					uint* copyData = newPtr;    					uint state = token * (uint)Mutation.KeyI0;  					uint counter = state;  					for (uint i = 0; i < dataLen; i++) {  						*copyData = *dataPtr++ ^ state;  						state += (*copyData++) ^ counter;  						counter ^= (state >> 5) | (state << 27);  					}    					info->ILCodeSize = data->ILCodeSize;  					if (ver4) {  						*((uint*)(info + 1) + 0) = data->MaxStack;  						*((uint*)(info + 1) + 1) = data->EHCount;  						*((uint*)(info + 1) + 2) = data->Options;  					}  					else {  						*((ushort*)(info + 1) + 0) = (ushort)data->MaxStack;  						*((ushort*)(info + 1) + 1) = (ushort)data->EHCount;  						*((uint*)(info + 1) + 1) = data->Options;  					}    					var body = (byte*)(data + 1);    					info->ILCode = body;  					body += info->ILCodeSize;    					if (data->LocalVars != 0) {  						ExtractLocalVars(info' data->LocalVars' body);  						body += data->LocalVars;  					}    					var ehPtr = (CORINFO_EH_CLAUSE*)body;    					uint ret;  					if (ver5) {  						CorJitInfoHook hook = CorJitInfoHook.Hook(comp' info->ftn' ehPtr);  						ret = originalDelegate(self' comp' info' flags' nativeEntry' nativeSizeOfCode);  						hook.Dispose();  					}  					else {  						CorMethodInfoHook hook = CorMethodInfoHook.Hook(comp' info->ftn' ehPtr);  						ret = originalDelegate(self' comp' info' flags' nativeEntry' nativeSizeOfCode);  						hook.Dispose();  					}    					return ret;  				}  				finally {  					Marshal.FreeHGlobal((IntPtr)newPtr);  				}  			}
Magic Number,Confuser.Runtime,AntiTamperJIT,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiTamper.JIT.cs,HookHandler,The following statement contains a magic number: if (info != null && info->scope == moduleHnd && info->ILCode[0] == 0x14) {  				uint token;  				if (ver5) {  					var getMethodDef = (getMethodDefFromMethod)Marshal.GetDelegateForFunctionPointer(comp->vfptr[0x64]' typeof(getMethodDefFromMethod));  					token = getMethodDef((IntPtr)comp' info->ftn);  				}  				else {  					ICorClassInfo* clsInfo = ICorStaticInfo.ICorClassInfo(ICorDynamicInfo.ICorStaticInfo(ICorJitInfo.ICorDynamicInfo(comp)));  					int gmdSlot = 12 + (ver4 ? 2 : 1);  					var getMethodDef = (getMethodDefFromMethod)Marshal.GetDelegateForFunctionPointer(clsInfo->vfptr[gmdSlot]' typeof(getMethodDefFromMethod));  					token = getMethodDef((IntPtr)clsInfo' info->ftn);  				}    				uint lo = 0' hi = len;  				uint? offset = null;  				while (hi >= lo) {  					uint mid = lo + ((hi - lo) >> 1);  					uint midTok = *(ptr + (mid << 1));  					if (midTok == token) {  						offset = *(ptr + (mid << 1) + 1);  						break;  					}  					if (midTok < token)  						lo = mid + 1;  					else  						hi = mid - 1;  				}  				if (offset == null)  					return originalDelegate(self' comp' info' flags' nativeEntry' nativeSizeOfCode);    				uint* dataPtr = ptr + (uint)offset;  				uint dataLen = *dataPtr++;  				var newPtr = (uint*)Marshal.AllocHGlobal((int)dataLen << 2);  				try {  					var data = (MethodData*)newPtr;  					uint* copyData = newPtr;    					uint state = token * (uint)Mutation.KeyI0;  					uint counter = state;  					for (uint i = 0; i < dataLen; i++) {  						*copyData = *dataPtr++ ^ state;  						state += (*copyData++) ^ counter;  						counter ^= (state >> 5) | (state << 27);  					}    					info->ILCodeSize = data->ILCodeSize;  					if (ver4) {  						*((uint*)(info + 1) + 0) = data->MaxStack;  						*((uint*)(info + 1) + 1) = data->EHCount;  						*((uint*)(info + 1) + 2) = data->Options;  					}  					else {  						*((ushort*)(info + 1) + 0) = (ushort)data->MaxStack;  						*((ushort*)(info + 1) + 1) = (ushort)data->EHCount;  						*((uint*)(info + 1) + 1) = data->Options;  					}    					var body = (byte*)(data + 1);    					info->ILCode = body;  					body += info->ILCodeSize;    					if (data->LocalVars != 0) {  						ExtractLocalVars(info' data->LocalVars' body);  						body += data->LocalVars;  					}    					var ehPtr = (CORINFO_EH_CLAUSE*)body;    					uint ret;  					if (ver5) {  						CorJitInfoHook hook = CorJitInfoHook.Hook(comp' info->ftn' ehPtr);  						ret = originalDelegate(self' comp' info' flags' nativeEntry' nativeSizeOfCode);  						hook.Dispose();  					}  					else {  						CorMethodInfoHook hook = CorMethodInfoHook.Hook(comp' info->ftn' ehPtr);  						ret = originalDelegate(self' comp' info' flags' nativeEntry' nativeSizeOfCode);  						hook.Dispose();  					}    					return ret;  				}  				finally {  					Marshal.FreeHGlobal((IntPtr)newPtr);  				}  			}
Magic Number,Confuser.Runtime,ICorDynamicInfo,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiTamper.JIT.cs,ICorStaticInfo,The following statement contains a magic number: return (ICorStaticInfo*)((byte*)&ptr->vbptr + ptr->vbptr[hasLinkInfo ? 9 : 8]);
Magic Number,Confuser.Runtime,ICorDynamicInfo,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiTamper.JIT.cs,ICorStaticInfo,The following statement contains a magic number: return (ICorStaticInfo*)((byte*)&ptr->vbptr + ptr->vbptr[hasLinkInfo ? 9 : 8]);
Magic Number,Confuser.Runtime,ICorJitInfo,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiTamper.JIT.cs,ICorDynamicInfo,The following statement contains a magic number: hasLinkInfo = ptr->vbptr[10] > 0 && ptr->vbptr[10] >> 16 == 0;
Magic Number,Confuser.Runtime,ICorJitInfo,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiTamper.JIT.cs,ICorDynamicInfo,The following statement contains a magic number: hasLinkInfo = ptr->vbptr[10] > 0 && ptr->vbptr[10] >> 16 == 0;
Magic Number,Confuser.Runtime,ICorJitInfo,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiTamper.JIT.cs,ICorDynamicInfo,The following statement contains a magic number: hasLinkInfo = ptr->vbptr[10] > 0 && ptr->vbptr[10] >> 16 == 0;
Magic Number,Confuser.Runtime,ICorJitInfo,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiTamper.JIT.cs,ICorDynamicInfo,The following statement contains a magic number: return (ICorDynamicInfo*)((byte*)&ptr->vbptr + ptr->vbptr[hasLinkInfo ? 10 : 9]);
Magic Number,Confuser.Runtime,ICorJitInfo,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiTamper.JIT.cs,ICorDynamicInfo,The following statement contains a magic number: return (ICorDynamicInfo*)((byte*)&ptr->vbptr + ptr->vbptr[hasLinkInfo ? 10 : 9]);
Magic Number,Confuser.Runtime,ICorStaticInfo,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiTamper.JIT.cs,ICorModuleInfo,The following statement contains a magic number: return (ICorModuleInfo*)((byte*)&ptr->vbptr + ptr->vbptr[2]);
Magic Number,Confuser.Runtime,ICorStaticInfo,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiTamper.JIT.cs,ICorClassInfo,The following statement contains a magic number: return (ICorClassInfo*)((byte*)&ptr->vbptr + ptr->vbptr[3]);
Magic Number,Confuser.Runtime,CorMethodInfoHook,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiTamper.JIT.cs,Hook,The following statement contains a magic number: if (ehNum == -1)  					for (int i = 0; i < SLOT_NUM; i++) {  						bool isEh = true;  						for (var func = (byte*)vfTbl[i]; *func != 0xe9; func++)  							if (IntPtr.Size == 8 ?  								    (*func == 0x48 && *(func + 1) == 0x81 && *(func + 2) == 0xe9) :  								    (*func == 0x83 && *(func + 1) == 0xe9)) {  								isEh = false;  								break;  							}  						if (isEh) {  							ehNum = i;  							break;  						}  					}
Magic Number,Confuser.Runtime,CorMethodInfoHook,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiTamper.JIT.cs,Hook,The following statement contains a magic number: if (ehNum == -1)  					for (int i = 0; i < SLOT_NUM; i++) {  						bool isEh = true;  						for (var func = (byte*)vfTbl[i]; *func != 0xe9; func++)  							if (IntPtr.Size == 8 ?  								    (*func == 0x48 && *(func + 1) == 0x81 && *(func + 2) == 0xe9) :  								    (*func == 0x83 && *(func + 1) == 0xe9)) {  								isEh = false;  								break;  							}  						if (isEh) {  							ehNum = i;  							break;  						}  					}
Magic Number,Confuser.Runtime,CorJitInfoHook,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiTamper.JIT.cs,Hook,The following statement contains a magic number: const int slotNum = 8;
Magic Number,Confuser.Runtime,CompressorCompat,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Compressor.Compat.cs,Decrypt,The following statement contains a magic number: var b = new byte[data.Length << 2];
Magic Number,Confuser.Runtime,CompressorCompat,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Compressor.Compat.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < data.Length; i++) {  				uint d = data[i] ^ w[i & 0xf];  				w[i & 0xf] = (w[i & 0xf] ^ d) + 0x3ddb2819;  				b[h + 0] = (byte)(d >> 0);  				b[h + 1] = (byte)(d >> 8);  				b[h + 2] = (byte)(d >> 16);  				b[h + 3] = (byte)(d >> 24);  				h += 4;  			}
Magic Number,Confuser.Runtime,CompressorCompat,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Compressor.Compat.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < data.Length; i++) {  				uint d = data[i] ^ w[i & 0xf];  				w[i & 0xf] = (w[i & 0xf] ^ d) + 0x3ddb2819;  				b[h + 0] = (byte)(d >> 0);  				b[h + 1] = (byte)(d >> 8);  				b[h + 2] = (byte)(d >> 16);  				b[h + 3] = (byte)(d >> 24);  				h += 4;  			}
Magic Number,Confuser.Runtime,CompressorCompat,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Compressor.Compat.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < data.Length; i++) {  				uint d = data[i] ^ w[i & 0xf];  				w[i & 0xf] = (w[i & 0xf] ^ d) + 0x3ddb2819;  				b[h + 0] = (byte)(d >> 0);  				b[h + 1] = (byte)(d >> 8);  				b[h + 2] = (byte)(d >> 16);  				b[h + 3] = (byte)(d >> 24);  				h += 4;  			}
Magic Number,Confuser.Runtime,CompressorCompat,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Compressor.Compat.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < data.Length; i++) {  				uint d = data[i] ^ w[i & 0xf];  				w[i & 0xf] = (w[i & 0xf] ^ d) + 0x3ddb2819;  				b[h + 0] = (byte)(d >> 0);  				b[h + 1] = (byte)(d >> 8);  				b[h + 2] = (byte)(d >> 16);  				b[h + 3] = (byte)(d >> 24);  				h += 4;  			}
Magic Number,Confuser.Runtime,CompressorCompat,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Compressor.Compat.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < data.Length; i++) {  				uint d = data[i] ^ w[i & 0xf];  				w[i & 0xf] = (w[i & 0xf] ^ d) + 0x3ddb2819;  				b[h + 0] = (byte)(d >> 0);  				b[h + 1] = (byte)(d >> 8);  				b[h + 2] = (byte)(d >> 16);  				b[h + 3] = (byte)(d >> 24);  				h += 4;  			}
Magic Number,Confuser.Runtime,CompressorCompat,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Compressor.Compat.cs,Decrypt,The following statement contains a magic number: for (int i = 0; i < data.Length; i++) {  				uint d = data[i] ^ w[i & 0xf];  				w[i & 0xf] = (w[i & 0xf] ^ d) + 0x3ddb2819;  				b[h + 0] = (byte)(d >> 0);  				b[h + 1] = (byte)(d >> 8);  				b[h + 2] = (byte)(d >> 16);  				b[h + 3] = (byte)(d >> 24);  				h += 4;  			}
Magic Number,Confuser.Runtime,CompressorCompat,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Compressor.Compat.cs,Main,The following statement contains a magic number: MethodBase e = a.ManifestModule.ResolveMethod(key[0] | (key[1] << 8) | (key[2] << 16) | (key[3] << 24));
Magic Number,Confuser.Runtime,CompressorCompat,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Compressor.Compat.cs,Main,The following statement contains a magic number: MethodBase e = a.ManifestModule.ResolveMethod(key[0] | (key[1] << 8) | (key[2] << 16) | (key[3] << 24));
Magic Number,Confuser.Runtime,CompressorCompat,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Compressor.Compat.cs,Main,The following statement contains a magic number: MethodBase e = a.ManifestModule.ResolveMethod(key[0] | (key[1] << 8) | (key[2] << 16) | (key[3] << 24));
Magic Number,Confuser.Runtime,CompressorCompat,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Compressor.Compat.cs,Main,The following statement contains a magic number: MethodBase e = a.ManifestModule.ResolveMethod(key[0] | (key[1] << 8) | (key[2] << 16) | (key[3] << 24));
Magic Number,Confuser.Runtime,CompressorCompat,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Compressor.Compat.cs,Main,The following statement contains a magic number: MethodBase e = a.ManifestModule.ResolveMethod(key[0] | (key[1] << 8) | (key[2] << 16) | (key[3] << 24));
Magic Number,Confuser.Runtime,CompressorCompat,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Compressor.Compat.cs,Resolve,The following statement contains a magic number: if (b.Length + 4 <= key.Length) {  				for (int i = 0; i < b.Length; i++)  					b[i] *= key[i + 4];  				string n = Convert.ToBase64String(b);  				m = Assembly.GetEntryAssembly().GetManifestResourceStream(n);  			}
Magic Number,Confuser.Runtime,CompressorCompat,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Compressor.Compat.cs,Resolve,The following statement contains a magic number: if (b.Length + 4 <= key.Length) {  				for (int i = 0; i < b.Length; i++)  					b[i] *= key[i + 4];  				string n = Convert.ToBase64String(b);  				m = Assembly.GetEntryAssembly().GetManifestResourceStream(n);  			}
Magic Number,Confuser.Runtime,CompressorCompat,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Compressor.Compat.cs,Resolve,The following statement contains a magic number: if (m != null) {  				var d = new uint[m.Length >> 2];  				var t = new byte[0x100];  				int r;  				int o = 0;  				while ((r = m.Read(t' 0' 0x100)) > 0) {  					Buffer.BlockCopy(t' 0' d' o' r);  					o += r;  				}  				uint s = 0x6fff61;  				foreach (byte c in b)  					s = s * 0x5e3f1f + c;  				GCHandle h = Decrypt(d' s);    				var f = (byte[])h.Target;  				Assembly a = Assembly.Load(f);  				Array.Clear(f' 0' f.Length);  				h.Free();  				Array.Clear(d' 0' d.Length);    				return a;  			}
Magic Number,Confuser.Runtime,Lzma,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Lzma.cs,Decompress,The following statement contains a magic number: var prop = new byte[5];
Magic Number,Confuser.Runtime,Lzma,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Lzma.cs,Decompress,The following statement contains a magic number: s.Read(prop' 0' 5);
Magic Number,Confuser.Runtime,Lzma,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Lzma.cs,Decompress,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  				int v = s.ReadByte();  				outSize |= ((long)(byte)v) << (8 * i);  			}
Magic Number,Confuser.Runtime,Lzma,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Lzma.cs,Decompress,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  				int v = s.ReadByte();  				outSize |= ((long)(byte)v) << (8 * i);  			}
Magic Number,Confuser.Runtime,Lzma,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Lzma.cs,Decompress,The following statement contains a magic number: long compressedSize = s.Length - 13;
Magic Number,Confuser.Runtime,BitDecoder,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Lzma.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Code < newBound) {  					rangeDecoder.Range = newBound;  					Prob += (kBitModelTotal - Prob) >> kNumMoveBits;  					if (rangeDecoder.Range < Decoder.kTopValue) {  						rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();  						rangeDecoder.Range <<= 8;  					}  					return 0;  				}
Magic Number,Confuser.Runtime,BitDecoder,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Lzma.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Code < newBound) {  					rangeDecoder.Range = newBound;  					Prob += (kBitModelTotal - Prob) >> kNumMoveBits;  					if (rangeDecoder.Range < Decoder.kTopValue) {  						rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();  						rangeDecoder.Range <<= 8;  					}  					return 0;  				}
Magic Number,Confuser.Runtime,BitDecoder,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Lzma.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Range < Decoder.kTopValue) {  					rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();  					rangeDecoder.Range <<= 8;  				}
Magic Number,Confuser.Runtime,BitDecoder,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Lzma.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Range < Decoder.kTopValue) {  					rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();  					rangeDecoder.Range <<= 8;  				}
Magic Number,Confuser.Runtime,Decoder,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Lzma.cs,Init,The following statement contains a magic number: for (int i = 0; i < 5; i++)  					Code = (Code << 8) | (byte)Stream.ReadByte();
Magic Number,Confuser.Runtime,Decoder,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Lzma.cs,Init,The following statement contains a magic number: for (int i = 0; i < 5; i++)  					Code = (Code << 8) | (byte)Stream.ReadByte();
Magic Number,Confuser.Runtime,Decoder,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Lzma.cs,Normalize,The following statement contains a magic number: while (Range < kTopValue) {  					Code = (Code << 8) | (byte)Stream.ReadByte();  					Range <<= 8;  				}
Magic Number,Confuser.Runtime,Decoder,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Lzma.cs,Normalize,The following statement contains a magic number: while (Range < kTopValue) {  					Code = (Code << 8) | (byte)Stream.ReadByte();  					Range <<= 8;  				}
Magic Number,Confuser.Runtime,Decoder,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Lzma.cs,DecodeDirectBits,The following statement contains a magic number: for (int i = numTotalBits; i > 0; i--) {  					range >>= 1;  					/*                      result <<= 1;                      if (code >= range)                      {                          code -= range;                          result |= 1;                      }                      */  					uint t = (code - range) >> 31;  					code -= range & (t - 1);  					result = (result << 1) | (1 - t);    					if (range < kTopValue) {  						code = (code << 8) | (byte)Stream.ReadByte();  						range <<= 8;  					}  				}
Magic Number,Confuser.Runtime,Decoder,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Lzma.cs,DecodeDirectBits,The following statement contains a magic number: for (int i = numTotalBits; i > 0; i--) {  					range >>= 1;  					/*                      result <<= 1;                      if (code >= range)                      {                          code -= range;                          result |= 1;                      }                      */  					uint t = (code - range) >> 31;  					code -= range & (t - 1);  					result = (result << 1) | (1 - t);    					if (range < kTopValue) {  						code = (code << 8) | (byte)Stream.ReadByte();  						range <<= 8;  					}  				}
Magic Number,Confuser.Runtime,Decoder,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Lzma.cs,DecodeDirectBits,The following statement contains a magic number: for (int i = numTotalBits; i > 0; i--) {  					range >>= 1;  					/*                      result <<= 1;                      if (code >= range)                      {                          code -= range;                          result |= 1;                      }                      */  					uint t = (code - range) >> 31;  					code -= range & (t - 1);  					result = (result << 1) | (1 - t);    					if (range < kTopValue) {  						code = (code << 8) | (byte)Stream.ReadByte();  						range <<= 8;  					}  				}
Magic Number,Confuser.Runtime,LzmaDecoder,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Lzma.cs,SetDictionarySize,The following statement contains a magic number: if (m_DictionarySize != dictionarySize) {  					m_DictionarySize = dictionarySize;  					m_DictionarySizeCheck = Math.Max(m_DictionarySize' 1);  					uint blockSize = Math.Max(m_DictionarySizeCheck' (1 << 12));  					m_OutWindow.Create(blockSize);  				}
Magic Number,Confuser.Runtime,LzmaDecoder,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Lzma.cs,Code,The following statement contains a magic number: while (nowPos64 < outSize64) {  					// UInt64 next = Math.Min(nowPos64 + (1 << 18)' outSize64);  					// while(nowPos64 < next)  					{  						uint posState = (uint)nowPos64 & m_PosStateMask;  						if (m_IsMatchDecoders[(state.Index << kNumPosStatesBitsMax) + posState].Decode(m_RangeDecoder) == 0) {  							byte b;  							byte prevByte = m_OutWindow.GetByte(0);  							if (!state.IsCharState())  								b = m_LiteralDecoder.DecodeWithMatchByte(m_RangeDecoder'  								                                         (uint)nowPos64' prevByte' m_OutWindow.GetByte(rep0));  							else  								b = m_LiteralDecoder.DecodeNormal(m_RangeDecoder' (uint)nowPos64' prevByte);  							m_OutWindow.PutByte(b);  							state.UpdateChar();  							nowPos64++;  						}  						else {  							uint len;  							if (m_IsRepDecoders[state.Index].Decode(m_RangeDecoder) == 1) {  								if (m_IsRepG0Decoders[state.Index].Decode(m_RangeDecoder) == 0) {  									if (m_IsRep0LongDecoders[(state.Index << kNumPosStatesBitsMax) + posState].Decode(m_RangeDecoder) == 0) {  										state.UpdateShortRep();  										m_OutWindow.PutByte(m_OutWindow.GetByte(rep0));  										nowPos64++;  										continue;  									}  								}  								else {  									UInt32 distance;  									if (m_IsRepG1Decoders[state.Index].Decode(m_RangeDecoder) == 0) {  										distance = rep1;  									}  									else {  										if (m_IsRepG2Decoders[state.Index].Decode(m_RangeDecoder) == 0)  											distance = rep2;  										else {  											distance = rep3;  											rep3 = rep2;  										}  										rep2 = rep1;  									}  									rep1 = rep0;  									rep0 = distance;  								}  								len = m_RepLenDecoder.Decode(m_RangeDecoder' posState) + kMatchMinLen;  								state.UpdateRep();  							}  							else {  								rep3 = rep2;  								rep2 = rep1;  								rep1 = rep0;  								len = kMatchMinLen + m_LenDecoder.Decode(m_RangeDecoder' posState);  								state.UpdateMatch();  								uint posSlot = m_PosSlotDecoder[GetLenToPosState(len)].Decode(m_RangeDecoder);  								if (posSlot >= kStartPosModelIndex) {  									var numDirectBits = (int)((posSlot >> 1) - 1);  									rep0 = ((2 | (posSlot & 1)) << numDirectBits);  									if (posSlot < kEndPosModelIndex)  										rep0 += BitTreeDecoder.ReverseDecode(m_PosDecoders'  										                                     rep0 - posSlot - 1' m_RangeDecoder' numDirectBits);  									else {  										rep0 += (m_RangeDecoder.DecodeDirectBits(  											numDirectBits - kNumAlignBits) << kNumAlignBits);  										rep0 += m_PosAlignDecoder.ReverseDecode(m_RangeDecoder);  									}  								}  								else  									rep0 = posSlot;  							}  							if (rep0 >= nowPos64 || rep0 >= m_DictionarySizeCheck) {  								if (rep0 == 0xFFFFFFFF)  									break;  							}  							m_OutWindow.CopyBlock(rep0' len);  							nowPos64 += len;  						}  					}  				}
Magic Number,Confuser.Runtime,LzmaDecoder,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Lzma.cs,SetDecoderProperties,The following statement contains a magic number: int lc = properties[0] % 9;
Magic Number,Confuser.Runtime,LzmaDecoder,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Lzma.cs,SetDecoderProperties,The following statement contains a magic number: int remainder = properties[0] / 9;
Magic Number,Confuser.Runtime,LzmaDecoder,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Lzma.cs,SetDecoderProperties,The following statement contains a magic number: int lp = remainder % 5;
Magic Number,Confuser.Runtime,LzmaDecoder,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Lzma.cs,SetDecoderProperties,The following statement contains a magic number: int pb = remainder / 5;
Magic Number,Confuser.Runtime,LzmaDecoder,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Lzma.cs,SetDecoderProperties,The following statement contains a magic number: for (int i = 0; i < 4; i++)  					dictionarySize += ((UInt32)(properties[1 + i])) << (i * 8);
Magic Number,Confuser.Runtime,LzmaDecoder,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Lzma.cs,SetDecoderProperties,The following statement contains a magic number: for (int i = 0; i < 4; i++)  					dictionarySize += ((UInt32)(properties[1 + i])) << (i * 8);
Magic Number,Confuser.Runtime,LiteralDecoder,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Lzma.cs,GetState,The following statement contains a magic number: return ((pos & m_PosMask) << m_NumPrevBits) + (uint)(prevByte >> (8 - m_NumPrevBits));
Magic Number,Confuser.Runtime,Decoder2,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Lzma.cs,DecodeWithMatchByte,The following statement contains a magic number: do {  							uint matchBit = (uint)(matchByte >> 7) & 1;  							matchByte <<= 1;  							uint bit = m_Decoders[((1 + matchBit) << 8) + symbol].Decode(rangeDecoder);  							symbol = (symbol << 1) | bit;  							if (matchBit != bit) {  								while (symbol < 0x100)  									symbol = (symbol << 1) | m_Decoders[symbol].Decode(rangeDecoder);  								break;  							}  						} while (symbol < 0x100);
Magic Number,Confuser.Runtime,Decoder2,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Lzma.cs,DecodeWithMatchByte,The following statement contains a magic number: do {  							uint matchBit = (uint)(matchByte >> 7) & 1;  							matchByte <<= 1;  							uint bit = m_Decoders[((1 + matchBit) << 8) + symbol].Decode(rangeDecoder);  							symbol = (symbol << 1) | bit;  							if (matchBit != bit) {  								while (symbol < 0x100)  									symbol = (symbol << 1) | m_Decoders[symbol].Decode(rangeDecoder);  								break;  							}  						} while (symbol < 0x100);
Magic Number,Confuser.Runtime,State,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Lzma.cs,UpdateChar,The following statement contains a magic number: if (Index < 4) Index = 0;  				else if (Index < 10) Index -= 3;  				else Index -= 6;
Magic Number,Confuser.Runtime,State,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Lzma.cs,UpdateChar,The following statement contains a magic number: if (Index < 4) Index = 0;  				else if (Index < 10) Index -= 3;  				else Index -= 6;
Magic Number,Confuser.Runtime,State,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Lzma.cs,UpdateChar,The following statement contains a magic number: if (Index < 4) Index = 0;  				else if (Index < 10) Index -= 3;  				else Index -= 6;
Magic Number,Confuser.Runtime,State,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Lzma.cs,UpdateChar,The following statement contains a magic number: if (Index < 4) Index = 0;  				else if (Index < 10) Index -= 3;  				else Index -= 6;
Magic Number,Confuser.Runtime,State,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Lzma.cs,UpdateMatch,The following statement contains a magic number: Index = (uint)(Index < 7 ? 7 : 10);
Magic Number,Confuser.Runtime,State,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Lzma.cs,UpdateMatch,The following statement contains a magic number: Index = (uint)(Index < 7 ? 7 : 10);
Magic Number,Confuser.Runtime,State,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Lzma.cs,UpdateMatch,The following statement contains a magic number: Index = (uint)(Index < 7 ? 7 : 10);
Magic Number,Confuser.Runtime,State,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Lzma.cs,UpdateRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 8 : 11);
Magic Number,Confuser.Runtime,State,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Lzma.cs,UpdateRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 8 : 11);
Magic Number,Confuser.Runtime,State,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Lzma.cs,UpdateRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 8 : 11);
Magic Number,Confuser.Runtime,State,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Lzma.cs,UpdateShortRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 9 : 11);
Magic Number,Confuser.Runtime,State,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Lzma.cs,UpdateShortRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 9 : 11);
Magic Number,Confuser.Runtime,State,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Lzma.cs,UpdateShortRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 9 : 11);
Magic Number,Confuser.Runtime,State,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Lzma.cs,IsCharState,The following statement contains a magic number: return Index < 7;
Magic Number,Confuser.Runtime,RefProxyStrong,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\RefProxy.Strong.cs,Initialize,The following statement contains a magic number: if (method.IsStatic)  				fieldInfo.SetValue(null' Delegate.CreateDelegate(delegateType' (MethodInfo)method));    			else {  				DynamicMethod dm = null;  				Type[] argTypes = null;    				foreach (MethodInfo invoke in fieldInfo.FieldType.GetMethods(BindingFlags.NonPublic | BindingFlags.Instance))  					if (invoke.DeclaringType == delegateType) {  						ParameterInfo[] paramTypes = invoke.GetParameters();  						argTypes = new Type[paramTypes.Length];  						for (int i = 0; i < argTypes.Length; i++)  							argTypes[i] = paramTypes[i].ParameterType;    						Type declType = method.DeclaringType;  						dm = new DynamicMethod(""' invoke.ReturnType' argTypes' (declType.IsInterface || declType.IsArray) ? delegateType : declType' true);  						break;  					}    				DynamicILInfo info = dm.GetDynamicILInfo();  				info.SetLocalSignature(new byte[] { 0x7' 0x0 });  				var code = new byte[(2 + 5) * argTypes.Length + 6];  				int index = 0;  				var mParams = method.GetParameters();  				int mIndex = method.IsConstructor ? 0 : -1;  				for (int i = 0; i < argTypes.Length; i++) {  					code[index++] = 0x0e;  					code[index++] = (byte)i;    					var mType = mIndex == -1 ? method.DeclaringType : mParams[mIndex].ParameterType;  					if (mType.IsClass && !(mType.IsPointer || mType.IsByRef)) {  						var cToken = info.GetTokenFor(mType.TypeHandle);  						code[index++] = 0x74;  						code[index++] = (byte)cToken;  						code[index++] = (byte)(cToken >> 8);  						code[index++] = (byte)(cToken >> 16);  						code[index++] = (byte)(cToken >> 24);  					}  					else  						index += 5;  					mIndex++;  				}  				code[index++] = (byte)((byte)fieldInfo.Name[Mutation.KeyI8] ^ opKey);  				int dmToken = info.GetTokenFor(method.MethodHandle);  				code[index++] = (byte)dmToken;  				code[index++] = (byte)(dmToken >> 8);  				code[index++] = (byte)(dmToken >> 16);  				code[index++] = (byte)(dmToken >> 24);  				code[index] = 0x2a;  				info.SetCode(code' argTypes.Length + 1);    				fieldInfo.SetValue(null' dm.CreateDelegate(delegateType));  			}
Magic Number,Confuser.Runtime,RefProxyStrong,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\RefProxy.Strong.cs,Initialize,The following statement contains a magic number: if (method.IsStatic)  				fieldInfo.SetValue(null' Delegate.CreateDelegate(delegateType' (MethodInfo)method));    			else {  				DynamicMethod dm = null;  				Type[] argTypes = null;    				foreach (MethodInfo invoke in fieldInfo.FieldType.GetMethods(BindingFlags.NonPublic | BindingFlags.Instance))  					if (invoke.DeclaringType == delegateType) {  						ParameterInfo[] paramTypes = invoke.GetParameters();  						argTypes = new Type[paramTypes.Length];  						for (int i = 0; i < argTypes.Length; i++)  							argTypes[i] = paramTypes[i].ParameterType;    						Type declType = method.DeclaringType;  						dm = new DynamicMethod(""' invoke.ReturnType' argTypes' (declType.IsInterface || declType.IsArray) ? delegateType : declType' true);  						break;  					}    				DynamicILInfo info = dm.GetDynamicILInfo();  				info.SetLocalSignature(new byte[] { 0x7' 0x0 });  				var code = new byte[(2 + 5) * argTypes.Length + 6];  				int index = 0;  				var mParams = method.GetParameters();  				int mIndex = method.IsConstructor ? 0 : -1;  				for (int i = 0; i < argTypes.Length; i++) {  					code[index++] = 0x0e;  					code[index++] = (byte)i;    					var mType = mIndex == -1 ? method.DeclaringType : mParams[mIndex].ParameterType;  					if (mType.IsClass && !(mType.IsPointer || mType.IsByRef)) {  						var cToken = info.GetTokenFor(mType.TypeHandle);  						code[index++] = 0x74;  						code[index++] = (byte)cToken;  						code[index++] = (byte)(cToken >> 8);  						code[index++] = (byte)(cToken >> 16);  						code[index++] = (byte)(cToken >> 24);  					}  					else  						index += 5;  					mIndex++;  				}  				code[index++] = (byte)((byte)fieldInfo.Name[Mutation.KeyI8] ^ opKey);  				int dmToken = info.GetTokenFor(method.MethodHandle);  				code[index++] = (byte)dmToken;  				code[index++] = (byte)(dmToken >> 8);  				code[index++] = (byte)(dmToken >> 16);  				code[index++] = (byte)(dmToken >> 24);  				code[index] = 0x2a;  				info.SetCode(code' argTypes.Length + 1);    				fieldInfo.SetValue(null' dm.CreateDelegate(delegateType));  			}
Magic Number,Confuser.Runtime,RefProxyStrong,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\RefProxy.Strong.cs,Initialize,The following statement contains a magic number: if (method.IsStatic)  				fieldInfo.SetValue(null' Delegate.CreateDelegate(delegateType' (MethodInfo)method));    			else {  				DynamicMethod dm = null;  				Type[] argTypes = null;    				foreach (MethodInfo invoke in fieldInfo.FieldType.GetMethods(BindingFlags.NonPublic | BindingFlags.Instance))  					if (invoke.DeclaringType == delegateType) {  						ParameterInfo[] paramTypes = invoke.GetParameters();  						argTypes = new Type[paramTypes.Length];  						for (int i = 0; i < argTypes.Length; i++)  							argTypes[i] = paramTypes[i].ParameterType;    						Type declType = method.DeclaringType;  						dm = new DynamicMethod(""' invoke.ReturnType' argTypes' (declType.IsInterface || declType.IsArray) ? delegateType : declType' true);  						break;  					}    				DynamicILInfo info = dm.GetDynamicILInfo();  				info.SetLocalSignature(new byte[] { 0x7' 0x0 });  				var code = new byte[(2 + 5) * argTypes.Length + 6];  				int index = 0;  				var mParams = method.GetParameters();  				int mIndex = method.IsConstructor ? 0 : -1;  				for (int i = 0; i < argTypes.Length; i++) {  					code[index++] = 0x0e;  					code[index++] = (byte)i;    					var mType = mIndex == -1 ? method.DeclaringType : mParams[mIndex].ParameterType;  					if (mType.IsClass && !(mType.IsPointer || mType.IsByRef)) {  						var cToken = info.GetTokenFor(mType.TypeHandle);  						code[index++] = 0x74;  						code[index++] = (byte)cToken;  						code[index++] = (byte)(cToken >> 8);  						code[index++] = (byte)(cToken >> 16);  						code[index++] = (byte)(cToken >> 24);  					}  					else  						index += 5;  					mIndex++;  				}  				code[index++] = (byte)((byte)fieldInfo.Name[Mutation.KeyI8] ^ opKey);  				int dmToken = info.GetTokenFor(method.MethodHandle);  				code[index++] = (byte)dmToken;  				code[index++] = (byte)(dmToken >> 8);  				code[index++] = (byte)(dmToken >> 16);  				code[index++] = (byte)(dmToken >> 24);  				code[index] = 0x2a;  				info.SetCode(code' argTypes.Length + 1);    				fieldInfo.SetValue(null' dm.CreateDelegate(delegateType));  			}
Magic Number,Confuser.Runtime,RefProxyStrong,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\RefProxy.Strong.cs,Initialize,The following statement contains a magic number: if (method.IsStatic)  				fieldInfo.SetValue(null' Delegate.CreateDelegate(delegateType' (MethodInfo)method));    			else {  				DynamicMethod dm = null;  				Type[] argTypes = null;    				foreach (MethodInfo invoke in fieldInfo.FieldType.GetMethods(BindingFlags.NonPublic | BindingFlags.Instance))  					if (invoke.DeclaringType == delegateType) {  						ParameterInfo[] paramTypes = invoke.GetParameters();  						argTypes = new Type[paramTypes.Length];  						for (int i = 0; i < argTypes.Length; i++)  							argTypes[i] = paramTypes[i].ParameterType;    						Type declType = method.DeclaringType;  						dm = new DynamicMethod(""' invoke.ReturnType' argTypes' (declType.IsInterface || declType.IsArray) ? delegateType : declType' true);  						break;  					}    				DynamicILInfo info = dm.GetDynamicILInfo();  				info.SetLocalSignature(new byte[] { 0x7' 0x0 });  				var code = new byte[(2 + 5) * argTypes.Length + 6];  				int index = 0;  				var mParams = method.GetParameters();  				int mIndex = method.IsConstructor ? 0 : -1;  				for (int i = 0; i < argTypes.Length; i++) {  					code[index++] = 0x0e;  					code[index++] = (byte)i;    					var mType = mIndex == -1 ? method.DeclaringType : mParams[mIndex].ParameterType;  					if (mType.IsClass && !(mType.IsPointer || mType.IsByRef)) {  						var cToken = info.GetTokenFor(mType.TypeHandle);  						code[index++] = 0x74;  						code[index++] = (byte)cToken;  						code[index++] = (byte)(cToken >> 8);  						code[index++] = (byte)(cToken >> 16);  						code[index++] = (byte)(cToken >> 24);  					}  					else  						index += 5;  					mIndex++;  				}  				code[index++] = (byte)((byte)fieldInfo.Name[Mutation.KeyI8] ^ opKey);  				int dmToken = info.GetTokenFor(method.MethodHandle);  				code[index++] = (byte)dmToken;  				code[index++] = (byte)(dmToken >> 8);  				code[index++] = (byte)(dmToken >> 16);  				code[index++] = (byte)(dmToken >> 24);  				code[index] = 0x2a;  				info.SetCode(code' argTypes.Length + 1);    				fieldInfo.SetValue(null' dm.CreateDelegate(delegateType));  			}
Magic Number,Confuser.Runtime,RefProxyStrong,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\RefProxy.Strong.cs,Initialize,The following statement contains a magic number: if (method.IsStatic)  				fieldInfo.SetValue(null' Delegate.CreateDelegate(delegateType' (MethodInfo)method));    			else {  				DynamicMethod dm = null;  				Type[] argTypes = null;    				foreach (MethodInfo invoke in fieldInfo.FieldType.GetMethods(BindingFlags.NonPublic | BindingFlags.Instance))  					if (invoke.DeclaringType == delegateType) {  						ParameterInfo[] paramTypes = invoke.GetParameters();  						argTypes = new Type[paramTypes.Length];  						for (int i = 0; i < argTypes.Length; i++)  							argTypes[i] = paramTypes[i].ParameterType;    						Type declType = method.DeclaringType;  						dm = new DynamicMethod(""' invoke.ReturnType' argTypes' (declType.IsInterface || declType.IsArray) ? delegateType : declType' true);  						break;  					}    				DynamicILInfo info = dm.GetDynamicILInfo();  				info.SetLocalSignature(new byte[] { 0x7' 0x0 });  				var code = new byte[(2 + 5) * argTypes.Length + 6];  				int index = 0;  				var mParams = method.GetParameters();  				int mIndex = method.IsConstructor ? 0 : -1;  				for (int i = 0; i < argTypes.Length; i++) {  					code[index++] = 0x0e;  					code[index++] = (byte)i;    					var mType = mIndex == -1 ? method.DeclaringType : mParams[mIndex].ParameterType;  					if (mType.IsClass && !(mType.IsPointer || mType.IsByRef)) {  						var cToken = info.GetTokenFor(mType.TypeHandle);  						code[index++] = 0x74;  						code[index++] = (byte)cToken;  						code[index++] = (byte)(cToken >> 8);  						code[index++] = (byte)(cToken >> 16);  						code[index++] = (byte)(cToken >> 24);  					}  					else  						index += 5;  					mIndex++;  				}  				code[index++] = (byte)((byte)fieldInfo.Name[Mutation.KeyI8] ^ opKey);  				int dmToken = info.GetTokenFor(method.MethodHandle);  				code[index++] = (byte)dmToken;  				code[index++] = (byte)(dmToken >> 8);  				code[index++] = (byte)(dmToken >> 16);  				code[index++] = (byte)(dmToken >> 24);  				code[index] = 0x2a;  				info.SetCode(code' argTypes.Length + 1);    				fieldInfo.SetValue(null' dm.CreateDelegate(delegateType));  			}
Magic Number,Confuser.Runtime,RefProxyStrong,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\RefProxy.Strong.cs,Initialize,The following statement contains a magic number: if (method.IsStatic)  				fieldInfo.SetValue(null' Delegate.CreateDelegate(delegateType' (MethodInfo)method));    			else {  				DynamicMethod dm = null;  				Type[] argTypes = null;    				foreach (MethodInfo invoke in fieldInfo.FieldType.GetMethods(BindingFlags.NonPublic | BindingFlags.Instance))  					if (invoke.DeclaringType == delegateType) {  						ParameterInfo[] paramTypes = invoke.GetParameters();  						argTypes = new Type[paramTypes.Length];  						for (int i = 0; i < argTypes.Length; i++)  							argTypes[i] = paramTypes[i].ParameterType;    						Type declType = method.DeclaringType;  						dm = new DynamicMethod(""' invoke.ReturnType' argTypes' (declType.IsInterface || declType.IsArray) ? delegateType : declType' true);  						break;  					}    				DynamicILInfo info = dm.GetDynamicILInfo();  				info.SetLocalSignature(new byte[] { 0x7' 0x0 });  				var code = new byte[(2 + 5) * argTypes.Length + 6];  				int index = 0;  				var mParams = method.GetParameters();  				int mIndex = method.IsConstructor ? 0 : -1;  				for (int i = 0; i < argTypes.Length; i++) {  					code[index++] = 0x0e;  					code[index++] = (byte)i;    					var mType = mIndex == -1 ? method.DeclaringType : mParams[mIndex].ParameterType;  					if (mType.IsClass && !(mType.IsPointer || mType.IsByRef)) {  						var cToken = info.GetTokenFor(mType.TypeHandle);  						code[index++] = 0x74;  						code[index++] = (byte)cToken;  						code[index++] = (byte)(cToken >> 8);  						code[index++] = (byte)(cToken >> 16);  						code[index++] = (byte)(cToken >> 24);  					}  					else  						index += 5;  					mIndex++;  				}  				code[index++] = (byte)((byte)fieldInfo.Name[Mutation.KeyI8] ^ opKey);  				int dmToken = info.GetTokenFor(method.MethodHandle);  				code[index++] = (byte)dmToken;  				code[index++] = (byte)(dmToken >> 8);  				code[index++] = (byte)(dmToken >> 16);  				code[index++] = (byte)(dmToken >> 24);  				code[index] = 0x2a;  				info.SetCode(code' argTypes.Length + 1);    				fieldInfo.SetValue(null' dm.CreateDelegate(delegateType));  			}
Magic Number,Confuser.Runtime,RefProxyStrong,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\RefProxy.Strong.cs,Initialize,The following statement contains a magic number: if (method.IsStatic)  				fieldInfo.SetValue(null' Delegate.CreateDelegate(delegateType' (MethodInfo)method));    			else {  				DynamicMethod dm = null;  				Type[] argTypes = null;    				foreach (MethodInfo invoke in fieldInfo.FieldType.GetMethods(BindingFlags.NonPublic | BindingFlags.Instance))  					if (invoke.DeclaringType == delegateType) {  						ParameterInfo[] paramTypes = invoke.GetParameters();  						argTypes = new Type[paramTypes.Length];  						for (int i = 0; i < argTypes.Length; i++)  							argTypes[i] = paramTypes[i].ParameterType;    						Type declType = method.DeclaringType;  						dm = new DynamicMethod(""' invoke.ReturnType' argTypes' (declType.IsInterface || declType.IsArray) ? delegateType : declType' true);  						break;  					}    				DynamicILInfo info = dm.GetDynamicILInfo();  				info.SetLocalSignature(new byte[] { 0x7' 0x0 });  				var code = new byte[(2 + 5) * argTypes.Length + 6];  				int index = 0;  				var mParams = method.GetParameters();  				int mIndex = method.IsConstructor ? 0 : -1;  				for (int i = 0; i < argTypes.Length; i++) {  					code[index++] = 0x0e;  					code[index++] = (byte)i;    					var mType = mIndex == -1 ? method.DeclaringType : mParams[mIndex].ParameterType;  					if (mType.IsClass && !(mType.IsPointer || mType.IsByRef)) {  						var cToken = info.GetTokenFor(mType.TypeHandle);  						code[index++] = 0x74;  						code[index++] = (byte)cToken;  						code[index++] = (byte)(cToken >> 8);  						code[index++] = (byte)(cToken >> 16);  						code[index++] = (byte)(cToken >> 24);  					}  					else  						index += 5;  					mIndex++;  				}  				code[index++] = (byte)((byte)fieldInfo.Name[Mutation.KeyI8] ^ opKey);  				int dmToken = info.GetTokenFor(method.MethodHandle);  				code[index++] = (byte)dmToken;  				code[index++] = (byte)(dmToken >> 8);  				code[index++] = (byte)(dmToken >> 16);  				code[index++] = (byte)(dmToken >> 24);  				code[index] = 0x2a;  				info.SetCode(code' argTypes.Length + 1);    				fieldInfo.SetValue(null' dm.CreateDelegate(delegateType));  			}
Magic Number,Confuser.Runtime,RefProxyStrong,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\RefProxy.Strong.cs,Initialize,The following statement contains a magic number: if (method.IsStatic)  				fieldInfo.SetValue(null' Delegate.CreateDelegate(delegateType' (MethodInfo)method));    			else {  				DynamicMethod dm = null;  				Type[] argTypes = null;    				foreach (MethodInfo invoke in fieldInfo.FieldType.GetMethods(BindingFlags.NonPublic | BindingFlags.Instance))  					if (invoke.DeclaringType == delegateType) {  						ParameterInfo[] paramTypes = invoke.GetParameters();  						argTypes = new Type[paramTypes.Length];  						for (int i = 0; i < argTypes.Length; i++)  							argTypes[i] = paramTypes[i].ParameterType;    						Type declType = method.DeclaringType;  						dm = new DynamicMethod(""' invoke.ReturnType' argTypes' (declType.IsInterface || declType.IsArray) ? delegateType : declType' true);  						break;  					}    				DynamicILInfo info = dm.GetDynamicILInfo();  				info.SetLocalSignature(new byte[] { 0x7' 0x0 });  				var code = new byte[(2 + 5) * argTypes.Length + 6];  				int index = 0;  				var mParams = method.GetParameters();  				int mIndex = method.IsConstructor ? 0 : -1;  				for (int i = 0; i < argTypes.Length; i++) {  					code[index++] = 0x0e;  					code[index++] = (byte)i;    					var mType = mIndex == -1 ? method.DeclaringType : mParams[mIndex].ParameterType;  					if (mType.IsClass && !(mType.IsPointer || mType.IsByRef)) {  						var cToken = info.GetTokenFor(mType.TypeHandle);  						code[index++] = 0x74;  						code[index++] = (byte)cToken;  						code[index++] = (byte)(cToken >> 8);  						code[index++] = (byte)(cToken >> 16);  						code[index++] = (byte)(cToken >> 24);  					}  					else  						index += 5;  					mIndex++;  				}  				code[index++] = (byte)((byte)fieldInfo.Name[Mutation.KeyI8] ^ opKey);  				int dmToken = info.GetTokenFor(method.MethodHandle);  				code[index++] = (byte)dmToken;  				code[index++] = (byte)(dmToken >> 8);  				code[index++] = (byte)(dmToken >> 16);  				code[index++] = (byte)(dmToken >> 24);  				code[index] = 0x2a;  				info.SetCode(code' argTypes.Length + 1);    				fieldInfo.SetValue(null' dm.CreateDelegate(delegateType));  			}
Magic Number,Confuser.Runtime,RefProxyStrong,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\RefProxy.Strong.cs,Initialize,The following statement contains a magic number: if (method.IsStatic)  				fieldInfo.SetValue(null' Delegate.CreateDelegate(delegateType' (MethodInfo)method));    			else {  				DynamicMethod dm = null;  				Type[] argTypes = null;    				foreach (MethodInfo invoke in fieldInfo.FieldType.GetMethods(BindingFlags.NonPublic | BindingFlags.Instance))  					if (invoke.DeclaringType == delegateType) {  						ParameterInfo[] paramTypes = invoke.GetParameters();  						argTypes = new Type[paramTypes.Length];  						for (int i = 0; i < argTypes.Length; i++)  							argTypes[i] = paramTypes[i].ParameterType;    						Type declType = method.DeclaringType;  						dm = new DynamicMethod(""' invoke.ReturnType' argTypes' (declType.IsInterface || declType.IsArray) ? delegateType : declType' true);  						break;  					}    				DynamicILInfo info = dm.GetDynamicILInfo();  				info.SetLocalSignature(new byte[] { 0x7' 0x0 });  				var code = new byte[(2 + 5) * argTypes.Length + 6];  				int index = 0;  				var mParams = method.GetParameters();  				int mIndex = method.IsConstructor ? 0 : -1;  				for (int i = 0; i < argTypes.Length; i++) {  					code[index++] = 0x0e;  					code[index++] = (byte)i;    					var mType = mIndex == -1 ? method.DeclaringType : mParams[mIndex].ParameterType;  					if (mType.IsClass && !(mType.IsPointer || mType.IsByRef)) {  						var cToken = info.GetTokenFor(mType.TypeHandle);  						code[index++] = 0x74;  						code[index++] = (byte)cToken;  						code[index++] = (byte)(cToken >> 8);  						code[index++] = (byte)(cToken >> 16);  						code[index++] = (byte)(cToken >> 24);  					}  					else  						index += 5;  					mIndex++;  				}  				code[index++] = (byte)((byte)fieldInfo.Name[Mutation.KeyI8] ^ opKey);  				int dmToken = info.GetTokenFor(method.MethodHandle);  				code[index++] = (byte)dmToken;  				code[index++] = (byte)(dmToken >> 8);  				code[index++] = (byte)(dmToken >> 16);  				code[index++] = (byte)(dmToken >> 24);  				code[index] = 0x2a;  				info.SetCode(code' argTypes.Length + 1);    				fieldInfo.SetValue(null' dm.CreateDelegate(delegateType));  			}
Magic Number,Confuser.Runtime,RefProxyStrong,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\RefProxy.Strong.cs,Initialize,The following statement contains a magic number: if (method.IsStatic)  				fieldInfo.SetValue(null' Delegate.CreateDelegate(delegateType' (MethodInfo)method));    			else {  				DynamicMethod dm = null;  				Type[] argTypes = null;    				foreach (MethodInfo invoke in fieldInfo.FieldType.GetMethods(BindingFlags.NonPublic | BindingFlags.Instance))  					if (invoke.DeclaringType == delegateType) {  						ParameterInfo[] paramTypes = invoke.GetParameters();  						argTypes = new Type[paramTypes.Length];  						for (int i = 0; i < argTypes.Length; i++)  							argTypes[i] = paramTypes[i].ParameterType;    						Type declType = method.DeclaringType;  						dm = new DynamicMethod(""' invoke.ReturnType' argTypes' (declType.IsInterface || declType.IsArray) ? delegateType : declType' true);  						break;  					}    				DynamicILInfo info = dm.GetDynamicILInfo();  				info.SetLocalSignature(new byte[] { 0x7' 0x0 });  				var code = new byte[(2 + 5) * argTypes.Length + 6];  				int index = 0;  				var mParams = method.GetParameters();  				int mIndex = method.IsConstructor ? 0 : -1;  				for (int i = 0; i < argTypes.Length; i++) {  					code[index++] = 0x0e;  					code[index++] = (byte)i;    					var mType = mIndex == -1 ? method.DeclaringType : mParams[mIndex].ParameterType;  					if (mType.IsClass && !(mType.IsPointer || mType.IsByRef)) {  						var cToken = info.GetTokenFor(mType.TypeHandle);  						code[index++] = 0x74;  						code[index++] = (byte)cToken;  						code[index++] = (byte)(cToken >> 8);  						code[index++] = (byte)(cToken >> 16);  						code[index++] = (byte)(cToken >> 24);  					}  					else  						index += 5;  					mIndex++;  				}  				code[index++] = (byte)((byte)fieldInfo.Name[Mutation.KeyI8] ^ opKey);  				int dmToken = info.GetTokenFor(method.MethodHandle);  				code[index++] = (byte)dmToken;  				code[index++] = (byte)(dmToken >> 8);  				code[index++] = (byte)(dmToken >> 16);  				code[index++] = (byte)(dmToken >> 24);  				code[index] = 0x2a;  				info.SetCode(code' argTypes.Length + 1);    				fieldInfo.SetValue(null' dm.CreateDelegate(delegateType));  			}
Magic Number,Confuser.Runtime,AntiDebugSafe,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiDebug.Safe.cs,Worker,The following statement contains a magic number: if (th == null) {  				th = new Thread(Worker);  				th.IsBackground = true;  				th.Start(Thread.CurrentThread);  				Thread.Sleep(500);  			}
Magic Number,Confuser.Runtime,AntiDebugSafe,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiDebug.Safe.cs,Worker,The following statement contains a magic number: while (true) {  				if (Debugger.IsAttached || Debugger.IsLogging())  					Environment.FailFast(null);    				if (!th.IsAlive)  					Environment.FailFast(null);    				Thread.Sleep(1000);  			}
Magic Number,Confuser.Runtime,Resource,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Resource.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < 0x10; i++) {  				n ^= n >> 13;  				n ^= n << 25;  				n ^= n >> 27;  				k[i] = n;  			}
Magic Number,Confuser.Runtime,Resource,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Resource.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < 0x10; i++) {  				n ^= n >> 13;  				n ^= n << 25;  				n ^= n >> 27;  				k[i] = n;  			}
Magic Number,Confuser.Runtime,Resource,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Resource.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < 0x10; i++) {  				n ^= n >> 13;  				n ^= n << 25;  				n ^= n >> 27;  				k[i] = n;  			}
Magic Number,Confuser.Runtime,Resource,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Resource.cs,Initialize,The following statement contains a magic number: var o = new byte[l * 4];
Magic Number,Confuser.Runtime,Resource,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Resource.cs,Initialize,The following statement contains a magic number: while (s < l) {  				for (int j = 0; j < 0x10; j++)  					w[j] = q[s + j];  				Mutation.Crypt(w' k);  				for (int j = 0; j < 0x10; j++) {  					uint e = w[j];  					o[d++] = (byte)e;  					o[d++] = (byte)(e >> 8);  					o[d++] = (byte)(e >> 16);  					o[d++] = (byte)(e >> 24);  					k[j] ^= e;  				}  				s += 0x10;  			}
Magic Number,Confuser.Runtime,Resource,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Resource.cs,Initialize,The following statement contains a magic number: while (s < l) {  				for (int j = 0; j < 0x10; j++)  					w[j] = q[s + j];  				Mutation.Crypt(w' k);  				for (int j = 0; j < 0x10; j++) {  					uint e = w[j];  					o[d++] = (byte)e;  					o[d++] = (byte)(e >> 8);  					o[d++] = (byte)(e >> 16);  					o[d++] = (byte)(e >> 24);  					k[j] ^= e;  				}  				s += 0x10;  			}
Magic Number,Confuser.Runtime,Resource,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Resource.cs,Initialize,The following statement contains a magic number: while (s < l) {  				for (int j = 0; j < 0x10; j++)  					w[j] = q[s + j];  				Mutation.Crypt(w' k);  				for (int j = 0; j < 0x10; j++) {  					uint e = w[j];  					o[d++] = (byte)e;  					o[d++] = (byte)(e >> 8);  					o[d++] = (byte)(e >> 16);  					o[d++] = (byte)(e >> 24);  					k[j] ^= e;  				}  				s += 0x10;  			}
Magic Number,Confuser.Runtime,Resource_Packer,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Resource.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < 0x10; i++) {  				n ^= n >> 13;  				n ^= n << 25;  				n ^= n >> 27;  				k[i] = n;  			}
Magic Number,Confuser.Runtime,Resource_Packer,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Resource.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < 0x10; i++) {  				n ^= n >> 13;  				n ^= n << 25;  				n ^= n >> 27;  				k[i] = n;  			}
Magic Number,Confuser.Runtime,Resource_Packer,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Resource.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < 0x10; i++) {  				n ^= n >> 13;  				n ^= n << 25;  				n ^= n >> 27;  				k[i] = n;  			}
Magic Number,Confuser.Runtime,Resource_Packer,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Resource.cs,Initialize,The following statement contains a magic number: var o = new byte[l * 4];
Magic Number,Confuser.Runtime,Resource_Packer,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Resource.cs,Initialize,The following statement contains a magic number: while (s < l) {  				for (int j = 0; j < 0x10; j++)  					w[j] = q[s + j];  				Mutation.Crypt(w' k);  				for (int j = 0; j < 0x10; j++) {  					uint e = w[j];  					o[d++] = (byte)e;  					o[d++] = (byte)(e >> 8);  					o[d++] = (byte)(e >> 16);  					o[d++] = (byte)(e >> 24);  					k[j] ^= e;  				}  				s += 0x10;  			}
Magic Number,Confuser.Runtime,Resource_Packer,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Resource.cs,Initialize,The following statement contains a magic number: while (s < l) {  				for (int j = 0; j < 0x10; j++)  					w[j] = q[s + j];  				Mutation.Crypt(w' k);  				for (int j = 0; j < 0x10; j++) {  					uint e = w[j];  					o[d++] = (byte)e;  					o[d++] = (byte)(e >> 8);  					o[d++] = (byte)(e >> 16);  					o[d++] = (byte)(e >> 24);  					k[j] ^= e;  				}  				s += 0x10;  			}
Magic Number,Confuser.Runtime,Resource_Packer,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Resource.cs,Initialize,The following statement contains a magic number: while (s < l) {  				for (int j = 0; j < 0x10; j++)  					w[j] = q[s + j];  				Mutation.Crypt(w' k);  				for (int j = 0; j < 0x10; j++) {  					uint e = w[j];  					o[d++] = (byte)e;  					o[d++] = (byte)(e >> 8);  					o[d++] = (byte)(e >> 16);  					o[d++] = (byte)(e >> 24);  					k[j] ^= e;  				}  				s += 0x10;  			}
Magic Number,Confuser.Runtime,AntiTamperNormal,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiTamper.Normal.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < s; i++) {  				uint g = (*r++) * (*r++);  				if (g == (uint)Mutation.KeyI0) {  					e = (uint*)(b + (f ? *(r + 3) : *(r + 1)));  					l = (f ? *(r + 2) : *(r + 0)) >> 2;  				}  				else if (g != 0) {  					var q = (uint*)(b + (f ? *(r + 3) : *(r + 1)));  					uint j = *(r + 2) >> 2;  					for (uint k = 0; k < j; k++) {  						uint t = (z ^ (*q++)) + x + c * v;  						z = x;  						x = c;  						x = v;  						v = t;  					}  				}  				r += 8;  			}
Magic Number,Confuser.Runtime,AntiTamperNormal,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiTamper.Normal.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < s; i++) {  				uint g = (*r++) * (*r++);  				if (g == (uint)Mutation.KeyI0) {  					e = (uint*)(b + (f ? *(r + 3) : *(r + 1)));  					l = (f ? *(r + 2) : *(r + 0)) >> 2;  				}  				else if (g != 0) {  					var q = (uint*)(b + (f ? *(r + 3) : *(r + 1)));  					uint j = *(r + 2) >> 2;  					for (uint k = 0; k < j; k++) {  						uint t = (z ^ (*q++)) + x + c * v;  						z = x;  						x = c;  						x = v;  						v = t;  					}  				}  				r += 8;  			}
Magic Number,Confuser.Runtime,AntiTamperNormal,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiTamper.Normal.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < s; i++) {  				uint g = (*r++) * (*r++);  				if (g == (uint)Mutation.KeyI0) {  					e = (uint*)(b + (f ? *(r + 3) : *(r + 1)));  					l = (f ? *(r + 2) : *(r + 0)) >> 2;  				}  				else if (g != 0) {  					var q = (uint*)(b + (f ? *(r + 3) : *(r + 1)));  					uint j = *(r + 2) >> 2;  					for (uint k = 0; k < j; k++) {  						uint t = (z ^ (*q++)) + x + c * v;  						z = x;  						x = c;  						x = v;  						v = t;  					}  				}  				r += 8;  			}
Magic Number,Confuser.Runtime,AntiTamperNormal,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiTamper.Normal.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < s; i++) {  				uint g = (*r++) * (*r++);  				if (g == (uint)Mutation.KeyI0) {  					e = (uint*)(b + (f ? *(r + 3) : *(r + 1)));  					l = (f ? *(r + 2) : *(r + 0)) >> 2;  				}  				else if (g != 0) {  					var q = (uint*)(b + (f ? *(r + 3) : *(r + 1)));  					uint j = *(r + 2) >> 2;  					for (uint k = 0; k < j; k++) {  						uint t = (z ^ (*q++)) + x + c * v;  						z = x;  						x = c;  						x = v;  						v = t;  					}  				}  				r += 8;  			}
Magic Number,Confuser.Runtime,AntiTamperNormal,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiTamper.Normal.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < s; i++) {  				uint g = (*r++) * (*r++);  				if (g == (uint)Mutation.KeyI0) {  					e = (uint*)(b + (f ? *(r + 3) : *(r + 1)));  					l = (f ? *(r + 2) : *(r + 0)) >> 2;  				}  				else if (g != 0) {  					var q = (uint*)(b + (f ? *(r + 3) : *(r + 1)));  					uint j = *(r + 2) >> 2;  					for (uint k = 0; k < j; k++) {  						uint t = (z ^ (*q++)) + x + c * v;  						z = x;  						x = c;  						x = v;  						v = t;  					}  				}  				r += 8;  			}
Magic Number,Confuser.Runtime,AntiTamperNormal,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiTamper.Normal.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < s; i++) {  				uint g = (*r++) * (*r++);  				if (g == (uint)Mutation.KeyI0) {  					e = (uint*)(b + (f ? *(r + 3) : *(r + 1)));  					l = (f ? *(r + 2) : *(r + 0)) >> 2;  				}  				else if (g != 0) {  					var q = (uint*)(b + (f ? *(r + 3) : *(r + 1)));  					uint j = *(r + 2) >> 2;  					for (uint k = 0; k < j; k++) {  						uint t = (z ^ (*q++)) + x + c * v;  						z = x;  						x = c;  						x = v;  						v = t;  					}  				}  				r += 8;  			}
Magic Number,Confuser.Runtime,AntiTamperNormal,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiTamper.Normal.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < s; i++) {  				uint g = (*r++) * (*r++);  				if (g == (uint)Mutation.KeyI0) {  					e = (uint*)(b + (f ? *(r + 3) : *(r + 1)));  					l = (f ? *(r + 2) : *(r + 0)) >> 2;  				}  				else if (g != 0) {  					var q = (uint*)(b + (f ? *(r + 3) : *(r + 1)));  					uint j = *(r + 2) >> 2;  					for (uint k = 0; k < j; k++) {  						uint t = (z ^ (*q++)) + x + c * v;  						z = x;  						x = c;  						x = v;  						v = t;  					}  				}  				r += 8;  			}
Magic Number,Confuser.Runtime,AntiTamperNormal,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiTamper.Normal.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < 0x10; i++) {  				y[i] = v;  				d[i] = x;  				z = (x >> 5) | (x << 27);  				x = (c >> 3) | (c << 29);  				c = (v >> 7) | (v << 25);  				v = (z >> 11) | (z << 21);  			}
Magic Number,Confuser.Runtime,AntiTamperNormal,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiTamper.Normal.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < 0x10; i++) {  				y[i] = v;  				d[i] = x;  				z = (x >> 5) | (x << 27);  				x = (c >> 3) | (c << 29);  				c = (v >> 7) | (v << 25);  				v = (z >> 11) | (z << 21);  			}
Magic Number,Confuser.Runtime,AntiTamperNormal,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiTamper.Normal.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < 0x10; i++) {  				y[i] = v;  				d[i] = x;  				z = (x >> 5) | (x << 27);  				x = (c >> 3) | (c << 29);  				c = (v >> 7) | (v << 25);  				v = (z >> 11) | (z << 21);  			}
Magic Number,Confuser.Runtime,AntiTamperNormal,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiTamper.Normal.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < 0x10; i++) {  				y[i] = v;  				d[i] = x;  				z = (x >> 5) | (x << 27);  				x = (c >> 3) | (c << 29);  				c = (v >> 7) | (v << 25);  				v = (z >> 11) | (z << 21);  			}
Magic Number,Confuser.Runtime,AntiTamperNormal,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiTamper.Normal.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < 0x10; i++) {  				y[i] = v;  				d[i] = x;  				z = (x >> 5) | (x << 27);  				x = (c >> 3) | (c << 29);  				c = (v >> 7) | (v << 25);  				v = (z >> 11) | (z << 21);  			}
Magic Number,Confuser.Runtime,AntiTamperNormal,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiTamper.Normal.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < 0x10; i++) {  				y[i] = v;  				d[i] = x;  				z = (x >> 5) | (x << 27);  				x = (c >> 3) | (c << 29);  				c = (v >> 7) | (v << 25);  				v = (z >> 11) | (z << 21);  			}
Magic Number,Confuser.Runtime,AntiTamperNormal,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiTamper.Normal.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < 0x10; i++) {  				y[i] = v;  				d[i] = x;  				z = (x >> 5) | (x << 27);  				x = (c >> 3) | (c << 29);  				c = (v >> 7) | (v << 25);  				v = (z >> 11) | (z << 21);  			}
Magic Number,Confuser.Runtime,AntiTamperNormal,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiTamper.Normal.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < 0x10; i++) {  				y[i] = v;  				d[i] = x;  				z = (x >> 5) | (x << 27);  				x = (c >> 3) | (c << 29);  				c = (v >> 7) | (v << 25);  				v = (z >> 11) | (z << 21);  			}
Magic Number,Confuser.Runtime,AntiTamperNormal,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\AntiTamper.Normal.cs,Initialize,The following statement contains a magic number: VirtualProtect((IntPtr)e' l << 2' w' out w);
Missing Default,Confuser.Runtime,CFGCtx,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Constant.cs,Next,The following switch statement is missing a default case: switch (f & 0x3) {  					case 0:  						A = q;  						break;  					case 1:  						B = q;  						break;  					case 2:  						C = q;  						break;  					case 3:  						D = q;  						break;  				}
Missing Default,Confuser.Runtime,CFGCtx,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Constant.cs,Next,The following switch statement is missing a default case: switch (f & 0x3) {  					case 0:  						A ^= q;  						break;  					case 1:  						B += q;  						break;  					case 2:  						C ^= q;  						break;  					case 3:  						D -= q;  						break;  				}
Missing Default,Confuser.Runtime,CFGCtx,C:\repos\yck1509_ConfuserEx\Confuser.Runtime\Constant.cs,Next,The following switch statement is missing a default case: switch ((f >> 2) & 0x3) {  				case 0:  					return A;  				case 1:  					return B;  				case 2:  					return C;  			}
